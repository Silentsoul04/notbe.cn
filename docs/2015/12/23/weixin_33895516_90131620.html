<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>linux设备驱动之USB主机控制器驱动分析 【转】 « NotBeCN</title>
  <meta name="description" content="                       转自：http://blog.chinaunix.net/uid-20543183-id-1930831.html              &nbsp;              ------------------------------------------ ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/12/23/weixin_33895516_90131620.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">linux设备驱动之USB主机控制器驱动分析 【转】</h1>
    <p class="post-meta">Dec 23, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div> 
    <div>
     <span style="font-family:'楷体';font-size:small;">转自：<a href="http://blog.chinaunix.net/uid-20543183-id-1930831.html" rel="nofollow">http://blog.chinaunix.net/uid-20543183-id-1930831.html</a></span>
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     <span style="font-family:'楷体';font-size:small;">------------------------------------------</span>
    </div> 
    <div>
     <span style="font-family:'楷体';font-size:small;">本文系本站原创,欢迎转载!</span>
    </div> 
    <div>
     <span style="font-family:'楷体';font-size:small;">转载请注明出处:http://ericxiao.cublog.cn/</span>
    </div> 
    <div>
     <span style="font-family:'楷体';font-size:small;">------------------------------------------</span>
    </div> 
   </div> 
   <div>
    一:前言
   </div> 
   <div>
    Usb是一个很复杂的系统.在usb2.0规范中,将其定义成了一个分层模型.linux中的代码也是按照这个分层模型来设计的.具体的分为usb设备,hub和主机控制器三部份.在阅读代码的时候,必须要参考相应的规范.最基本的就是USB2.0的spec.它定义了USB协议.另外的一个是USB控制器的规范.有UHCI,EHCI,OHCI三种.其中UHCI是Intel推出的一种USB控制器标准.它将很多功能交给软件处理.相比之下,它也是最为复杂的.因此,本文档以UHCI为例分析.另外,在分析的过程中参考了情景分析和fudan_abc的&lt;&lt;linux那些事儿之我是uhci&gt;&gt;.正是因为踩在许多牛人的肩膀上,才使USB这个复杂的工程在我们面前变得越来越清晰.
   </div> 
   <div>
    本文的代码分析是基于linux kernel 2.6.25.涉及到的代码主要位于linux-2.6.25/drivers/usb目录下.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    二:UHCI的初始化
   </div> 
   <div>
    UHCI主机控制器的代码位于linux-2.6.25/drivers/usb/host下面.在配置kernel的时候可以选择将其编译进内核或者编译成模块.模块的入口函数为: uhci_hcd_init().代码如下:
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    static int __init uhci_hcd_init(void)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp; int retval = -ENOMEM;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "%s\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignore_oc ? ", overcurrent ignored" : "");
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (usb_disabled())
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -ENODEV;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (DEBUG_CONFIGURED) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!errbuf)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto errbuf_failed;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_debugfs_root = debugfs_create_dir("uhci", NULL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!uhci_debugfs_root)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto debug_failed;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_up_cachep = kmem_cache_create("uhci_urb_priv",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct urb_priv), 0, 0, NULL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!uhci_up_cachep)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto up_failed;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; retval = pci_register_driver(&amp;uhci_pci_driver);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (retval)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto init_failed;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    init_failed:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; kmem_cache_destroy(uhci_up_cachep);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    up_failed:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; debugfs_remove(uhci_debugfs_root);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    debug_failed:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; kfree(errbuf);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    errbuf_failed:
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    }
   </div> 
   <div>
    入口函数比较简单.其中涉及到的接口在之前都已经详细的分析过.
   </div> 
   <div>
    在引导系统的时候,可以为kernel指定参数.如果配置了”nousb”,就明确禁止使用USB.该入口函数首先通过usb_disabled()来检测用户指定了nousb参数.然后为struct urb_priv创建了一个cache.然后注册了一个PCI驱动.struct usb_priv等以后用到的时候再进行分析.UHCI是一个PCI设备.PCI的驱动架构我们之前已经分析过了,这里不再赘述.
   </div> 
   <div>
    uhci_pci_driver定义如下所示:
   </div> 
   <div>
    static struct pci_driver uhci_pci_driver = {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .name =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (char *)hcd_name,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .id_table =&nbsp;&nbsp; uhci_pci_ids,
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .probe = usb_hcd_pci_probe,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .remove = usb_hcd_pci_remove,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .shutdown =&nbsp;&nbsp; uhci_shutdown,
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    #ifdef&nbsp;&nbsp; CONFIG_PM
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .suspend =&nbsp;&nbsp;&nbsp; usb_hcd_pci_suspend,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .resume = usb_hcd_pci_resume,
   </div> 
   <div>
    #endif&nbsp;&nbsp; /* PM */
   </div> 
   <div>
    };
   </div> 
   <div>
    通过之前的对PCI的分析,我们知道对于pci_dev和pci_driver的匹配过程是通过判断pci_driver的id_table项和pci_dev的相关项是否符合来进行的.在这里.id_talbe的定义如下所示:
   </div> 
   <div>
    static const struct pci_dev_id uhci_pci_ids[] = { {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* handle any USB UHCI controller */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; PCI_DEV_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .driver_data =&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long) &amp;uhci_driver,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }, { /* end: all zeroes */ }
   </div> 
   <div>
    };
   </div> 
   <div>
    由此,可以看到,只要是属于PCI_CLASS_SERIAL_USB_UHCI类的设备,都能匹配到这个驱动.这个宏的定义如下:
   </div> 
   <div>
    #define PCI_CLASS_SERIAL_USB_UHCI&nbsp;&nbsp;&nbsp; 0x0c0300
   </div> 
   <div>
    其实该类型是由UHCI的spec规定的.
   </div> 
   <div>
    另外,id_talbe的私有项(driver_data)被置为了uhci_driver.这个在以后是会被用到的.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    如果pci_driver成功匹配到设备.就会调用其probe接口.在这里.probe接口被置为了usb_hcd_pci_probe.如下所示:
   </div> 
   <div>
    int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_dev_id *id)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct hc_driver&nbsp;&nbsp; *driver;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_hcd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *hcd;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (usb_disabled())
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -ENODEV;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!id)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; driver = (struct hc_driver *)id-&gt;driver_data;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!driver)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (pci_enable_device(dev) &lt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -ENODEV;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;current_state = PCI_D0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.power.power_state = PMSG_ON;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!dev-&gt;irq) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(&amp;dev-&gt;dev,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Found HC with no IRQ.&nbsp; Check BIOS/PCI %s setup!\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pci_name(dev));
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -ENODEV;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //创建usb_hcd
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd = usb_create_hcd(driver, &amp;dev-&gt;dev, pci_name(dev));
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!hcd) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //UCHI的flags没有定义成HCD_MEMORY
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (driver-&gt;flags &amp; HCD_MEMORY) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* EHCI, OHCI */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rsrc_start = pci_resource_start(dev, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rsrc_len = pci_resource_len(dev, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!request_mem_region(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver-&gt;description)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;dev-&gt;dev, "controller already in use\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -EBUSY;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err2;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;regs = ioremap_nocache(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;regs == NULL) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;dev-&gt;dev, "error mapping memory\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -EFAULT;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err3;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; } else {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* UHCI */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; region;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //找到一个I/O的缓冲区.UHCI只有一个I/O区间
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (region = 0; region &lt; PCI_ROM_RESOURCE; region++) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(pci_resource_flags(dev, region) &amp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IORESOURCE_IO))
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rsrc_start = pci_resource_start(dev, region);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rsrc_len = pci_resource_len(dev, region);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (request_region(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver-&gt;description))
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (region == PCI_ROM_RESOURCE) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;dev-&gt;dev, "no i/o regions available\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -EBUSY;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //使用DMA
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; pci_set_master(dev);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (retval != 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err4;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;err4:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (driver-&gt;flags &amp; HCD_MEMORY) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iounmap(hcd-&gt;regs);
   </div> 
   <div>
    &nbsp;err3:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_mem_region(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; } else
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release_region(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
   </div> 
   <div>
    &nbsp;err2:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_put_hcd(hcd);
   </div> 
   <div>
    &nbsp;err1:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; pci_disable_device(dev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev_err(&amp;dev-&gt;dev, "init %s fail, %d\n", pci_name(dev), retval);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    }
   </div> 
   <div>
    这段代码位于linux-2.6.25/drivers/usb/core下的hcd-pci.c中.该路径下的代码是被所有USB控制器共享的.因此,我们在代码中可以看到usb_hcd_pci_probe()会有区别UHCI还是其它类型的控制器的操作.在USB驱动架构中,有很多代码是关于电源管理的.在这里我们先忽略电源管理的部份.之后再以单独章节的形式来分析linux上的电源管理子系统.
   </div> 
   <div>
    首先,会调用&nbsp;pci_enable_device()来启用PCI设备.正如在分析PCI设备的时候.初始化之后的PCI设备很多功能都是被禁用的.例如I/O/内存空间,IRQ等.其次,OHCI必须要使用中断.如果对应中断号不存在,说明此设备不是一个UHCI.或者出现了错误.直接跳出.不进行后续操作.然后,OHCI必须要使用DMA.所以会调用pci_set_master()将开启设备的DMA传输能力.另外,OHCI SPEC上有定义.在PCI的配置空间中,0x20~0x23定义了OHCI的I/O区间和大小.也就是说OHCI对应的pci_dev中,只有一个I/O资源区间是有效的.
   </div> 
   <div>
    对应到上面的代码:
   </div> 
   <div>
    id-&gt;driver_data的赋值在uhci_hcd_init()中被特别指出过.被赋值为uhci_driver.它的结构如下:
   </div> 
   <div>
    static const struct hc_driver uhci_driver = {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .description =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd_name,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .product_desc =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "UHCI Host Controller",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .hcd_priv_size =&nbsp;&nbsp; sizeof(struct uhci_hcd),
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Generic hardware linkage */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .irq =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_irq,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .flags =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HCD_USB11,
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Basic lifecycle operations */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .reset =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_init,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .start =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_start,
   </div> 
   <div>
    #ifdef CONFIG_PM
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .suspend =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_suspend,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .resume =&nbsp;&nbsp;&nbsp;&nbsp; uhci_resume,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .bus_suspend =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_rh_suspend,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .bus_resume =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_rh_resume,
   </div> 
   <div>
    #endif
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .stop =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; uhci_stop,
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .urb_enqueue =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_urb_enqueue,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .urb_dequeue =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_urb_dequeue,
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .endpoint_disable =&nbsp;&nbsp;&nbsp; uhci_hcd_endpoint_disable,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .get_frame_number =&nbsp;&nbsp;&nbsp; uhci_hcd_get_frame_number,
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .hub_status_data = uhci_hub_status_data,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; .hub_control =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_hub_control,
   </div> 
   <div>
    };
   </div> 
   <div>
    可以看到,在的结构为struct hc_driver. Hc就是host control的意思.即为主机控制器驱动.该结构包函了很多函数指针,具体的操作我们等能后涉及的时候再回过来分析.另外,从里面可以看到,它的flags被定义成了HCD_USB1.1.
   </div> 
   <div>
    特别说明一下:UHCI是一个基于usb1.1的设备.USB1.1和USB2.0的最大区别就是USB2.0中定义有高速设备.因此,UHCI是一个不支持高速的USB控制器.只有EHCI才会支持高速.因此,在配置kernel的时候,UHCI和EHCI通常都会选上.如果只选用UHCI或者只选用EHCI.有很多设备都是不能够工作的.
   </div> 
   <div>
    因为flags被定义成HCD_USB1.1.所以代码中的if(driver-&gt;flags &amp; HCD_MEMORY) … else …流程就转入到else下面.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    然后,我们目光注视到usb_create_hcd()和usb_add_hcd()这两个函数.看函数名称,一个是产生struct usb_hcd.另外的一个是将这个hcd添加到系统.hcd就是host control driver的意思.先来分析一下usb_create_hcd的代码:
   </div> 
   <div>
    struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *dev, char *bus_name)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_hcd *hcd;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd = kzalloc(sizeof(*hcd) + driver-&gt;hcd_priv_size, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!hcd) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg (dev, "hcd alloc failed\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev_set_drvdata(dev, hcd);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; kref_init(&amp;hcd-&gt;kref);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_bus_init(&amp;hcd-&gt;self);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;self.controller = dev;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;self.bus_name = bus_name;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;self.uses_dma = (dev-&gt;dma_mask != NULL);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; init_timer(&amp;hcd-&gt;rh_timer);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rh_timer.function = rh_timer_func;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rh_timer.data = (unsigned long) hcd;
   </div> 
   <div>
    #ifdef CONFIG_PM
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; INIT_WORK(&amp;hcd-&gt;wakeup_work, hcd_resume_work);
   </div> 
   <div>
    #endif
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;driver = driver;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;product_desc = (driver-&gt;product_desc) ? driver-&gt;product_desc :
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "USB Host Controller";
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return hcd;
   </div> 
   <div>
    }
   </div> 
   <div>
    函数的三个参数:
   </div> 
   <div>
    1: driver:也就是上面分析的pci_driver的id_table的driver_data项.即struct hc_driver
   </div> 
   <div>
    2: dev: OHCI所对应的pci_dev中内嵌的struct device结构
   </div> 
   <div>
    3: bus_name:OHCI对应的pci_dev的name
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    在这里,注意一下hcd内存的分配.如下示:
   </div> 
   <div>
    hcd = kzalloc(sizeof(*hcd) + driver-&gt;hcd_priv_size, GFP_KERNEL);
   </div> 
   <div>
    我们知道,struct usb_hcd是一个位于usb_core下的东东,这个东东所有的host control都会用到.那么hcd就有一个私有区结构,用来表示host control之间不同的数据结构.而其它们相同的结构保存在struct usb_hcd中.这个hcd_priv成员在struct usb_hcd被定义成了0项数组的形式,而大小则是由hc_driver的hcd_priv_size项来指定的.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    struct usb_hcd结构很庞大.这里不方便将其全部列出.只来说明一下在这里会用到的成员:
   </div> 
   <div>
    1:self成员: 我们可以这想思考.每条USB总线上只有一个host control.每个host control都对应着一条总线. 这个self成员就是表示hcd所对应的USB总线. self.controller表示该总线上的控制器,也就是UHCI对应的pci_dev中封装的struct device. Self. bus_name表示该总线的名称.也就是OHCI对应的pci_dev的名称.self. uses_dma来表示该总线上的控制器是否使用DMA
   </div> 
   <div>
    2: rh_timer成员:该成员是一个定时器,用来轮询控制器的根集线器的状态改变,通常用做电源管理.在这里不加详分析.
   </div> 
   <div>
    2: driver成员:表示该hcd对应驱动.
   </div> 
   <div>
    总而言之, usb_create_hcd就是对hcd的各项成员赋值.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    相比之下usb_add_hcd()的代码就比较繁杂了.下面以分段的形式分析如下:
   </div> 
   <div>
    int usb_add_hcd(struct usb_hcd *hcd,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int irqnum, unsigned long irqflags)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_device *rhdev;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev_info(hcd-&gt;self.controller, "%s\n", hcd-&gt;product_desc);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;authorized_default = hcd-&gt;wireless? 0 : 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* HC is in reset state, but accessible.&nbsp; Now do the one-time init,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* bottom up so that hcds can customize the root hubs before khubd
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* starts talking to them.&nbsp; (Note, bus id is assigned early too.)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//创建pool
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if ((retval = hcd_buffer_create(hcd)) != 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(hcd-&gt;self.controller, "pool alloc failed\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    在我们分析的流程中, Hcd-&gt;wireless默认为0.相应的hcd-&gt;authorized_default也被置为了0.然后将hcd-&gt;flags置为HCD_FLAG_HW_ACCESSIBLE.表示该USB控制器是可以访问的.最后在hcd_buffer_create中,因为hc_driver的flags标志被末置HCD_LOCAL_MEM.该函数在这里什么都不做就返回0了.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //注册usb_bus
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if ((retval = usb_register_bus(&amp;hcd-&gt;self)) &lt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_register_bus;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //分配并初始化root hub
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if ((rhdev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0)) == NULL) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(hcd-&gt;self.controller, "unable to allocate root hub\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_allocate_root_hub;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //OHCI定义于usb1.1只能支持全速
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USB_SPEED_FULL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;self.root_hub = rhdev;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* wakeup flag init defaults to "everything works" for root hubs,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* but drivers can override it in reset() if needed, along with
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* recording the overall controller's system wakeup capability.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; device_init_wakeup(&amp;rhdev-&gt;dev, 1);
   </div> 
   <div>
    在前面.我们看到了在hcd的self成员的赋值过程,而所有的总线信息都要保存在一个地方,在其它的地方会用到这些总线信息.所以usb_register_bus()对应的工作就是在全局变量busmap的位图中找到没有被使用的位做为usb_bus的序号(我们暂且称呼它为USB总线号).然后为该总线注册一个属于usb_host_class类的设备.以后在/sys/class/host中就可以看到该bus对应的目录了.最后,将总线链接到usb_bus_list链表中.
   </div> 
   <div>
    然后,每一个USB控制器都有一个根集线器.这里也要为总线下的根集钱器创建相应的结构, usb_alloc_dev()用来生成并初始化的usb_device结构.这个函数比较重要,在后面给出这个函数的详细分析.
   </div> 
   <div>
    因为OHCI是USB1.1的设备,所以,根集线器的speed会被定义成USB_SPEED_FULL(全速).最后将这个根集线器关联到总线中.
   </div> 
   <div>
    device_init_wakeup(&amp;rhdev-&gt;dev, 1)是和总线相关的,忽略它吧 :-)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* "reset" is misnamed; its role is now one-time init. the controller
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* should already have been reset (and boot firmware kicked off etc).
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;driver-&gt;reset &amp;&amp; (retval = hcd-&gt;driver-&gt;reset(hcd)) &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(hcd-&gt;self.controller, "can't setup\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_hcd_driver_setup;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* NOTE: root hub and controller capabilities may not be the same */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (device_can_wakeup(hcd-&gt;self.controller)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp; device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(hcd-&gt;self.controller, "supports USB remote wakeup\n");
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* enable irqs just before we start the controller */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;driver-&gt;irq) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(hcd-&gt;irq_descr, sizeof(hcd-&gt;irq_descr), "%s:usb%d",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;driver-&gt;description, hcd-&gt;self.busnum);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((retval = request_irq(irqnum, &amp;usb_hcd_irq, irqflags,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;irq_descr, hcd)) != 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(hcd-&gt;self.controller,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "request interrupt %d failed\n", irqnum);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_request_irq;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;irq = irqnum;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_info(hcd-&gt;self.controller, "irq %d, %s 0x%08llx\n", irqnum,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hcd-&gt;driver-&gt;flags &amp; HCD_MEMORY) ?
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "io mem" : "io base",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long long)hcd-&gt;rsrc_start);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; } else {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;irq = -1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;rsrc_start)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_info(hcd-&gt;self.controller, "%s 0x%08llx\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hcd-&gt;driver-&gt;flags &amp; HCD_MEMORY) ?
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "io mem" : "io base",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long long)hcd-&gt;rsrc_start);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if ((retval = hcd-&gt;driver-&gt;start(hcd)) &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(hcd-&gt;self.controller, "startup error %d\n", retval);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_hcd_driver_start;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    调用hc_driver的rese函数来初始化OHCI. device_can_wakeup()那一段是属于电源管理的,忽略吧.然后为OHCI的中断号注册中断处理函数.然后再调用hc_driver的start函数来启动OHCI.在这里,提醒一下,注册中断处理函数时所带的标志是usb_add_hcd()函数的第三个参数,也就是IRQF_DISABLED | IRQF_SHARED.也就是说,在进入到中断处理的时候,要禁用本地中断.中断处理函数的参数就是hcd
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* starting here, usbcore will pay attention to this root hub */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; rhdev-&gt;bus_mA = min(500u, hcd-&gt;power_budget);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if ((retval = register_root_hub(hcd)) != 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_register_root_hub;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; retval = sysfs_create_group(&amp;rhdev-&gt;dev.kobj, &amp;usb_bus_attr_group);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (retval &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printk(KERN_ERR "Cannot register USB bus sysfs attributes: %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto error_create_attr_group;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;uses_new_polling &amp;&amp; hcd-&gt;poll_rh)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_hcd_poll_rh_status(hcd);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    rhdev-&gt;bus_mA表示该HUB当前可用电流限制.在前面的流程中,我们并末对hcd-&gt;power_budget进行赋值,也就是说,并没有对roo hub限制电流.
   </div> 
   <div>
    之后,会调用register_root_hub()来对根集线器进行操作,这个函数很重要,以后再单独给出分析.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    error_create_attr_group:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mutex_lock(&amp;usb_bus_list_lock);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_disconnect(&amp;hcd-&gt;self.root_hub);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;usb_bus_list_lock);
   </div> 
   <div>
    err_register_root_hub:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;driver-&gt;stop(hcd);
   </div> 
   <div>
    err_hcd_driver_start:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;irq &gt;= 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free_irq(irqnum, hcd);
   </div> 
   <div>
    err_request_irq:
   </div> 
   <div>
    err_hcd_driver_setup:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;self.root_hub = NULL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_put_dev(rhdev);
   </div> 
   <div>
    err_allocate_root_hub:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_deregister_bus(&amp;hcd-&gt;self);
   </div> 
   <div>
    err_register_bus:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd_buffer_destroy(hcd);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    经过前面的段式分析,我们对这个函数的流程有了一定的了解.其中有几个函数特别列出,分析如下:
   </div> 
   <div>
    2.1:usb_alloc_dev()的操作
   </div> 
   <div>
    之所以要特别列出分析,是因为这个函数中有很重要的赋值操作.代码如下:
   </div> 
   <div>
    struct usb_device *usb_alloc_dev(struct usb_device *parent,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;struct usb_bus *bus, unsigned port1)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_device *dev;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //从bus结构,求得usb_hcd
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_hcd *usb_hcd = container_of(bus, struct usb_hcd, self);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned root_hub = 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev = kzalloc(sizeof(*dev), GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!dev)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //增加hcd的引用计数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!usb_get_hcd(bus_to_hcd(bus))) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(dev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //usb_device,内嵌有struct device结构,对这个结构进行初始化
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; device_initialize(&amp;dev-&gt;dev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.bus = &amp;usb_bus_type;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.type = &amp;usb_device_type;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.dma_mask = bus-&gt;controller-&gt;dma_mask;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; set_dev_node(&amp;dev-&gt;dev, dev_to_node(bus-&gt;controller));
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //将dev的初始状态置为USB_STATE_ATTACHED.妻示已经连接上了
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;state = USB_STATE_ATTACHED;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; atomic_set(&amp;dev-&gt;urbnum, 0);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //初始化设备的端点0
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;dev-&gt;ep0.urb_list);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* ep0 maxpacket comes later, from device descriptor */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_enable_endpoint(dev, &amp;dev-&gt;ep0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;can_submit = 1;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Save readable and stable topology id, distinguishing devices
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* by location for diagnostics, tools, driver model, etc.&nbsp; The
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* string is a path along hub ports, from the root.&nbsp; Each device's
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* dev-&gt;devpath will be stable until USB is re-cabled, and hubs
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* are often labeled with these port numbers.&nbsp; The bus_id isn't
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* as stable:&nbsp; bus-&gt;busnum changes easily from modprobe order,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* cardbus or pci hotplugging, and so on.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//如果没有父结点,也即该设备是root hub.usb_device内嵌的dev的父结点指向它的控制器
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (unlikely(!parent)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;devpath[0] = '0';
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.parent = bus-&gt;controller;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(&amp;dev-&gt;dev.bus_id[0], "usb%d", bus-&gt;busnum);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root_hub = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; } else {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果有父结点,就指向其父结点
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* match any labeling on the hubs; it's one-based */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (parent-&gt;devpath[0] == '0')
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(dev-&gt;devpath, sizeof dev-&gt;devpath,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%d", port1);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(dev-&gt;devpath, sizeof dev-&gt;devpath,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s.%d", parent-&gt;devpath, port1);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.parent = &amp;parent-&gt;dev;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(&amp;dev-&gt;dev.bus_id[0], "%d-%s",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus-&gt;busnum, dev-&gt;devpath);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* hub driver sets up TT records */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    //上面的节点名称赋值很有意思: 如果是根集线器,它的名称为"usb"+总线号
   </div> 
   <div>
    //如果是第1条总线上的root hub,对应就是usb0
   </div> 
   <div>
    //如果是根集线其下面的设备.它的名称为:总线号+ "-" + portnum 或者:总线号+ "-"&nbsp; + 上层总线//的devpath
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;portnum = port1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;bus = bus;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;parent = parent;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;dev-&gt;filelist);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    #ifdef&nbsp;&nbsp; CONFIG_PM
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mutex_init(&amp;dev-&gt;pm_mutex);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; INIT_DELAYED_WORK(&amp;dev-&gt;autosuspend, usb_autosuspend_work);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;autosuspend_delay = usb_autosuspend_delay * HZ;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;connect_time = jiffies;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;active_duration = -jiffies;
   </div> 
   <div>
    #endif
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (root_hub) /* Root hub always ok [and always wired] */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;authorized = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;authorized = usb_hcd-&gt;authorized_default;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;wusb = usb_bus_is_wusb(bus)? 1 : 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return dev;
   </div> 
   <div>
    }
   </div> 
   <div>
    该函数的参数如下:
   </div> 
   <div>
    Parent:该设备的上层hub.对于root hub来说,该参数为NULL.表示它的上层无设备
   </div> 
   <div>
    Bus&nbsp; :该设备所属的bus
   </div> 
   <div>
    port1:该设备所连hub的端口号.对于root hub来说,该项为0.
   </div> 
   <div>
    参考添加的注释,这段代码应该很容易理解.注意在代码为usb_driver内嵌的struct device的赋值过程.它的bus被设置成了usb_bus_type.它的type被设置成了usb_device_type.这些赋值是我们以后分析usb设备驱动的基础.这里不再啰嗦.为以后的分析打一个伏笔.:-) .在这里,注重分析一下对端点0的操作以及设备的命名规则.
   </div> 
   <div>
    1:对于端点0:
   </div> 
   <div>
    USB协议规定每个设备都必须要有一个端点0.USB控制器和这个端点0通信都可以获得整个设备的信息.USB设备可以有多个端口.但是除了端点0外,其它端口的通信都是单向的.如:一些端点只能接收数据.另外的端点只能发送数据.每个端点都对应一个端点号,一个端点号+通信方向就确定了一个端点.也就是说,一个端点号对应二个端点,进来方向的一个,出去方向的一个.
   </div> 
   <div>
    对于端点0.就分析这么多.具体的流程.以后结合代码再来分析.
   </div> 
   <div>
    结合上面的代码:
   </div> 
   <div>
    dev-&gt;ep0.desc.表示ep0(端点0)的端点描述符.desc的定义为struct usb_endpoint_descriptor.在usb2.0的规范中,总共有8种描述符.端点描述符的类型定义为5.整个端点描述符的长度为7.
   </div> 
   <div>
    跟进去看一下usb_enable_endpoint():
   </div> 
   <div>
    void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int epnum = usb_endpoint_num(&amp;ep-&gt;desc);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int is_control = usb_endpoint_xfer_control(&amp;ep-&gt;desc);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (is_out || is_control) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_settoggle(dev, epnum, 1, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;ep_out[epnum] = ep;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!is_out || is_control) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_settoggle(dev, epnum, 0, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;ep_in[epnum] = ep;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ep-&gt;enabled = 1;
   </div> 
   <div>
    }
   </div> 
   <div>
    Usb_endpoint_num()定义如下:
   </div> 
   <div>
    static inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return epd-&gt;bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK;
   </div> 
   <div>
    }
   </div> 
   <div>
    即在描述符的bEndpointAddress字段中,取得端点号.
   </div> 
   <div>
    usb_endpoint_dir_out()定义如下:
   </div> 
   <div>
    static inline int usb_endpoint_dir_out(
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct usb_endpoint_descriptor *epd)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return ((epd-&gt;bEndpointAddress &amp; USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
   </div> 
   <div>
    }
   </div> 
   <div>
    即判断该端点是否是OUT方向的.OUT方向.就是指从主机发往设备方向.
   </div> 
   <div>
    usb_endpoint_xfer_control()定义如下:
   </div> 
   <div>
    static inline int usb_endpoint_xfer_control(
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct usb_endpoint_descriptor *epd)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return ((epd-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USB_ENDPOINT_XFER_CONTROL);
   </div> 
   <div>
    }
   </div> 
   <div>
    即检查该端点是否是控制传输端点.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    从上面的流程看,我们并没有对ep0的相关字段赋值,这些函数会全部都返回0.
   </div> 
   <div>
    所以,流程就转到这里:
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    if (!is_out || is_control) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_settoggle(dev, epnum, 0, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;ep_in[epnum] = ep;
   </div> 
   <div>
    }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ep-&gt;enabled = 1;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    这段代码执行的效果就是:dev-&gt;ep_in[0]=ep. Dev-&gt; toggle[0]的0位被置1.
   </div> 
   <div>
    最后将ep-&gt;enabled置为1.表示启用该设备.
   </div> 
   <div>
    其实该段代码主要是改变dev-&gt;ep_in[]和dev-&gt;toggle[].将struct usb_device的相关成员列出:
   </div> 
   <div>
    struct usb_device {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ……
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned int toggle[2];&nbsp;&nbsp;&nbsp;&nbsp; /* one bit for each endpoint*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ……
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_host_endpoint *ep_in[16];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_host_endpoint *ep_out[16];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ……
   </div> 
   <div>
    }
   </div> 
   <div>
    Usb2.0的spec规定.每个设备最多有15个端点号.即最多表示30个端点.另外再加一个端点0.共计31个.
   </div> 
   <div>
    数组ep_in[]表示in方向的端点集合.ep_out[]表示ONT方向的集合.它们在数组中的位置是以端点号做为索引的.
   </div> 
   <div> 
    <div>
     而对于toggle[]数组.他实际上就是一个位图.IN方向的是toggle[0].OUT方向的是toggle[1].其实,这个数组中的每一位表示ep的toggle值.关于toggle,在分析USB的数据传输再来说明,另外,从usb_enable_endpoint()中的代码可以看到,端点的toggle是初始化为0的.
    </div> 
   </div> 
   <div>
    2:对于usb设备的命名规则
   </div> 
   <div>
    注释中解释了一部份,在这里整理一下.相应的代码如下:
   </div> 
   <div>
    if (unlikely(!parent)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;devpath[0] = '0';
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.parent = bus-&gt;controller;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(&amp;dev-&gt;dev.bus_id[0], "usb%d", bus-&gt;busnum);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root_hub = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; } else {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果有父结点,就指向其父结点
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* match any labeling on the hubs; it's one-based */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (parent-&gt;devpath[0] == '0')
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(dev-&gt;devpath, sizeof dev-&gt;devpath,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%d", port1);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; snprintf(dev-&gt;devpath, sizeof dev-&gt;devpath,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s.%d", parent-&gt;devpath, port1);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.parent = &amp;parent-&gt;dev;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf(&amp;dev-&gt;dev.bus_id[0], "%d-%s",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus-&gt;busnum, dev-&gt;devpath);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* hub driver sets up TT records */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    如果父结点为NULL,也就是说root hub的情况.它的名称就是”usb”+usb总线号.例如,对于第1条总线上的root hub为usb1.第二条总线上的root hub为usb2….在这里要注意,对于root hub.会将dev-&gt;devpath[0]=’0’.
   </div> 
   <div>
    对于root hub下的设备.它的名称为:总线号+”-”+端口号.例如,第一条usb总线上的root hub的第一个端口上的设备叫”1-0”.第二个端口上的设备名称为”1-1”
   </div> 
   <div>
    对于父结点不是root hub的设备.它的名称为: 总线号+”-”+端口路径. 例如.在第一条usb总线上的root hub的第一个端口上的hub上.第一个端口上的设备名称叫做: 1-0.1 ,第二个端口上的设备名称叫做1-0.2
   </div> 
   <div>
    依次往下推……
   </div> 
   <div>
    如果你到/sys中查看usb设备的话,看到的名称跟这里分析的会不一样.这是因为,对bus_id的处理还没完呢!后面还有相关的处理.等代码分析到了的时候再看. *^_^*.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    2.2:hcd-&gt;driver-&gt;reset()的操作.
   </div> 
   <div>
    在我们分析的流程中,对应的接口为uhci_init().代码如下:
   </div> 
   <div>
    static int uhci_init(struct usb_hcd *hcd)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct uhci_hcd *uhci = hcd_to_uhci(hcd);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned io_size = (unsigned) hcd-&gt;rsrc_len;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int port;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;io_addr = (unsigned long) hcd-&gt;rsrc_start;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* The UHCI spec says devices must have 2 ports, and goes on to say
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* they may have more but gives no way to determine how many there
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* are.&nbsp; However according to the UHCI spec, Bit 7 of the port
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* status and control register is always set to 1.&nbsp; So we try to
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* use this to our advantage.&nbsp; Another common failure mode when
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* a nonexistent register is addressed is to return all ones, so
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* we test for that also.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (port = 0; port &lt; (io_size - USBPORTSC1) / 2; port++) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int portstatus;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; portstatus = inw(uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(portstatus &amp; 0x0080) || portstatus == 0xffff)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (debug)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_info(uhci_dev(uhci), "detected %d ports\n", port);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Anything greater than 7 is weird so we'll ignore it. */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (port &gt; UHCI_RH_MAXCHILD) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_info(uhci_dev(uhci), "port count misdetected? "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "forcing to 2 ports\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port = 2;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;rh_numports = port;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Kick BIOS off this hardware and reset if the controller
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* isn't already safely quiescent.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; check_and_reset_hc(uhci);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return 0;
   </div> 
   <div>
    }
   </div> 
   <div>
    代码中hcd_to_uhci()的操作就不做详细分析了.在分配usb_hcd的内存时就已经分析过.
   </div> 
   <div>
    结合UHCI spec来理解这段代码.spec中规定.从I/O空间的0x10处开始,为端口控制状态寄存器(PORTSC).占有两个字节.这个端口也是指UHCI控制器的root hub端口.该寄存器用来表示端口的状态,和操作相应端口.协议中并没有规定一个UHCI有多少个端口,但规定不能够超过8个.另外,协议中规定,PORTSC的bit7始终为1.因此可以根据这个特征来判断端口是否存在.另外,寄存器中的位全为1也是不正常的.
   </div> 
   <div>
    这样就可以计算出UHCI的root hub有多少个端口.然后将值存放到uhci的rh_numports中.
   </div> 
   <div>
    注意代码中取寄存器值的*2操作.这是因为每个PORTSC占两个字节.
   </div> 
   <div>
    剩下的代码就只有check_and_reset_hc( )了.该函数用来检查UHCI是否需要重置.如果需要重置.那就进行UHCI的重置操作.代码如下:
   </div> 
   <div>
    static void check_and_reset_hc(struct uhci_hcd *uhci)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (uhci_check_and_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr))
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finish_reset(uhci);
   </div> 
   <div>
    }
   </div> 
   <div>
    先来分析uhci_check_and_reset_hc()的代码.如下所示:
   </div> 
   <div>
    int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; u16 legsup;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned int cmd, intr;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /*
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* When restarting a suspended controller, we expect all the
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* settings to be the same as we left them:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;&nbsp; PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;&nbsp; Controller is stopped and configured with EGSM set;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;&nbsp; No interrupts enabled except possibly Resume Detect.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* If any of these conditions are violated we do a complete reset.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; pci_read_config_word(pdev, UHCI_USBLEGSUP, &amp;legsup);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (legsup &amp; ~(UHCI_USBLEGSUP_RO | UHCI_USBLEGSUP_RWC)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;pdev-&gt;dev, "%s: legsup = 0x%04x\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __FUNCTION__, legsup);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto reset_needed;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; cmd = inw(base + UHCI_USBCMD);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if ((cmd &amp; UHCI_USBCMD_RUN) || !(cmd &amp; UHCI_USBCMD_CONFIGURE) ||
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !(cmd &amp; UHCI_USBCMD_EGSM)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;pdev-&gt;dev, "%s: cmd = 0x%04x\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __FUNCTION__, cmd);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto reset_needed;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; intr = inw(base + UHCI_USBINTR);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (intr &amp; (~UHCI_USBINTR_RESUME)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;pdev-&gt;dev, "%s: intr = 0x%04x\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __FUNCTION__, intr);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto reset_needed;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    reset_needed:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(&amp;pdev-&gt;dev, "Performing full reset\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_reset_hc(pdev, base);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return 1;
   </div> 
   <div>
    }
   </div> 
   <div>
    该函数的第一个参数为UHCI对应的pci_dev.第二个参数是I/O区间的起始地址.从代码中看来,有三种情况是需要重置的.这三种情况分别为:
   </div> 
   <div>
    1:如果LEGACY SUPPORT REGISTER寄存器中R/W属性位被置,那就需要重启. LEGACY SUPPORT REGISTER通常是用于legacy 键盘和鼠标.UHCI spec上对其有详细的定义.对照spec.所有R/W属性的位都是某种能力的使能开关.例如,bit13表示USB PIRQ Enable.如果该位被置,表示设备能够产生中断.否则就不可以.
   </div> 
   <div>
    因此,对于这样的位,应该将其初始化.也即将设备的功能关闭.这也很容易理解,为了R/W属性位被置就需要重启UHCI
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    2:USB CMD寄存器的UHCI_USBCMD_RUN被置为1, UHCI_USBCMD_CONFIGURE和UHCI_USBCMD_EGSM位为0的时候需要重启.
   </div> 
   <div>
    UHCI_USBCMD_RUN表示UHCI正在调度数据,处于运行状态.显然,这个时候是应该被重启的
   </div> 
   <div>
    UHCI_USBCMD_CONFIGURE:这个位是由软件控制的,只是起一个标识作用,不会对硬件产生任何影响.如果该位为了1,表示UHCI正处于配置状态.没有处于配置状态,当然就可以重启了.
   </div> 
   <div>
    UHCI_USBCMD_EGSM表示UHCI是否处于Global Suspend mode.在这种模式下,是不会产生数据交互的.显然.如果该位为0.则表示该位不是Global Suspend mode模式,当然就需要重启了.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    3:USB INTR寄存器中除UHCI_USBINTR_RESUME如果其它位为1.则重启UHCI.
   </div> 
   <div>
    在USB　INTR寄存器中,bit4~bit15是保留的,始终为0.其它四位对应了UHCI的四种不同类型的中断,除了bit1表示的Resume interrupt外,其它类型的应该全部都被关掉.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    如果不需要重启UHCI,直接返回0即可.如果需要重启,则会调转到uhci_reset_hc().代码如下:
   </div> 
   <div>
    void uhci_reset_hc(struct pci_dev *pdev, unsigned long base)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Turn off PIRQ enable and SMI enable.&nbsp; (This also turns off the
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* BIOS's USB Legacy Support.)&nbsp; Turn off all the R/WC bits too.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; pci_write_config_word(pdev, UHCI_USBLEGSUP, UHCI_USBLEGSUP_RWC);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Reset the HC - this will force us to get a
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* new notification of any already connected
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* ports due to the virtual disconnect that it
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* implies.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outw(UHCI_USBCMD_HCRESET, base + UHCI_USBCMD);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mb();
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; udelay(5);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (inw(base + UHCI_USBCMD) &amp; UHCI_USBCMD_HCRESET)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(&amp;pdev-&gt;dev, "HCRESET not completed yet!\n");
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Just to be safe, disable interrupt requests and
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* make sure the controller is stopped.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outw(0, base + UHCI_USBINTR);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outw(0, base + UHCI_USBCMD);
   </div> 
   <div>
    }
   </div> 
   <div>
    重启OHCI的步骤如下:
   </div> 
   <div>
    1:将UHCI_USBLEGSUP寄存器中的,RWC属性位清空.
   </div> 
   <div>
    RWC属性即为:该位可读可写.如果往该位写1,就会将该位清0.如果写0则什么都不干.上面代码的操作也就是将RWC位置为0.代码的注释上说的很清楚了.这样会禁用PIRQ和SMI.当然也会关掉Legacy设备的支持.
   </div> 
   <div>
    2:往USB CMD寄存器写入UHCI_USBCMD_HCRESET.用来重启UHCI.
   </div> 
   <div>
    UHCI重启完了之后,又会将该位清空
   </div> 
   <div>
    3:清空USB INTR寄存器和CMD寄存器
   </div> 
   <div>
    对于重启UHCI的情况,返回到check_and_reset_hc()里,还会调用finish_reset().代码如下:
   </div> 
   <div>
    static void finish_reset(struct uhci_hcd *uhci)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int port;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* HCRESET doesn't affect the Suspend, Reset, and Resume Detect
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* bits in the port status and control registers.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* We have to clear them by hand.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (port = 0; port &lt; uhci-&gt;rh_numports; ++port)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outw(0, uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;port_c_suspend = uhci-&gt;resuming_ports = 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;rh_state = UHCI_RH_RESET;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;is_stopped = UHCI_IS_STOPPED;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_to_hcd(uhci)-&gt;poll_rh = 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;dead = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Full reset resurrects the controller */
   </div> 
   <div>
    }
   </div> 
   <div>
    该函数将UHCI 的各个PORTSC寄存器全部清空.然后设置UHCI为RESET状态.HCD为HALT状态等等.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    2.3:hcd-&gt;driver-&gt;start( )的操作
   </div> 
   <div>
    将UHCI重启之后,注册好了中断处理函数就可以启动UHCI了.对应的接口为uhci_start().在分析代码之前,先来了解一下UHCI的调度架构.
   </div> 
   <div>
    从UHCI的spec中摘出一个图,先看下UHCI调度的大概情况:
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    <img src="http://blogimg.chinaunix.net/blog/upfile2/080909094316.jpg" alt="">
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    从该图中可以看出:
   </div> 
   <div>
    图中的Frame List,翻译成中文叫框架表.TD表示Transfer Descriptor,即表示一次具体的传输.QH表示Queue Head.即传输队列.由上图可见.QH可以和其它的QH组成队列.QH下面又可以挂上TD链.
   </div> 
   <div>
    在UHCI内部.有一个Frame List Address Base Register(FLAB).用来存放Frame List的基地址和当前执行的Frame List序号.每过1ms. FLAB中的index段会加1.它总共占10位,当增加到1023时,又会回转到0.UHCI根据FLAB中存放的Frame list地址,以Index为序号执行Frame List的相关项.
   </div> 
   <div>
    由此可以看到.如果我们要UHCI往设备发送信息.只要将数据打成TD格式的,然后将其链入到相关QH或者TD就好.
   </div> 
   <div>
    从上图中也可以看到传送的优先级关系.先是ISO.然后是INTERRUPT.最后是CONTRL和BULK.关于这四种传输,请自行参照USB2.0 spec.
   </div> 
   <div>
    现在结合代码进行分析,如果代码较长,采用分段分析的方式:
   </div> 
   <div>
    static int uhci_start(struct usb_hcd *hcd)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct uhci_hcd *uhci = hcd_to_uhci(hcd);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int retval = -EBUSY;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int i;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct dentry *dentry;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;uses_new_polling = 1;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; spin_lock_init(&amp;uhci-&gt;lock);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; setup_timer(&amp;uhci-&gt;fsbr_timer, uhci_fsbr_timeout,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long) uhci);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; init_waitqueue_head(&amp;uhci-&gt;waitqh);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (DEBUG_CONFIGURED) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dentry = debugfs_create_file(hcd-&gt;self.bus_name,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci, &amp;uhci_debug_operations);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!dentry) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "couldn't create uhci "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "debugfs entry\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_create_debug_entry;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;dentry = dentry;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    建立fsbr_timer定时器. 这个定时器跟USB的高速传输有关.在后面再给出详细的分析.忽略选择调试的部份.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //1024个frame 指针
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;frame = dma_alloc_coherent(uhci_dev(uhci),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;uhci-&gt;frame_dma_handle, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!uhci-&gt;frame) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "unable to allocate "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "consistent memory for frame list\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_alloc_frame;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; memset(uhci-&gt;frame, 0, UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame));
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //cpu 的frame指针
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;frame_cpu = kcalloc(UHCI_NUMFRAMES, sizeof(*uhci-&gt;frame_cpu),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!uhci-&gt;frame_cpu) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "unable to allocate "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "memory for frame pointers\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_alloc_frame_cpu;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    按照UHCI SPEC的要求,初始化1024个frame list.在这里,UHCI都是使用DMA进行数据交互的.因此调用了dma_alloc_coherent的接口分配DMA内存.物理地址会保存在uhci-&gt;frame_dma_handle中.
   </div> 
   <div>
    然后再初始化了1024上cpu frame.这个结构是用来做辅助的,并不会影响具体的硬件
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //创建uhci_td的pool
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;td_pool = dma_pool_create("uhci_td", uhci_dev(uhci),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct uhci_td), 16, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!uhci-&gt;td_pool) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "unable to create td dma_pool\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_create_td_pool;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //创建uhci_qh的pool
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;qh_pool = dma_pool_create("uhci_qh", uhci_dev(uhci),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(struct uhci_qh), 16, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!uhci-&gt;qh_pool) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "unable to create qh dma_pool\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_create_qh_pool;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;term_td = uhci_alloc_td(uhci);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!uhci-&gt;term_td) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_alloc_term_td;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    因为以后要经常分配TD和QH结构.为其建立一个POLL.最后,我们还可以看到.初始化了uhci-&gt;term_td
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //创建11个skelqh
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci, NULL, NULL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!uhci-&gt;skelqh[i]) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(uhci_dev(uhci), "unable to allocate QH\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_alloc_skelqh;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    初始化11个QH,即uhci-&gt;skeqh[ ]数组
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /*
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* 8 Interrupt queues; link all higher int queues to int1 = async
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//skel_async_qh = skelqh[9]
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = SKEL_ISO + 1; i &lt; SKEL_ASYNC; ++i)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;skelqh[i]-&gt;link = LINK_TO_QH(uhci-&gt;skel_async_qh);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //int1后面没有跟TD或者QH了
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;skel_async_qh-&gt;link = UHCI_PTR_TERM;
   </div> 
   <div>
    然后uhci-&gt;skelqh[]的2到8项的后续指针都指向了skelqh[9].skelqh[9]指向了UHCI_PTR_TERM.
   </div> 
   <div>
    其实uhci-&gt;skelqh[2]~ uhci-&gt;skelqh[9].代表8个时间间隔的调度队列.依次被称为int128,int64,int32,int16,int8,int4,int2,int1.即对于int128,即每隔128ms调度一次.int1.即每隔1ms调度一次,
   </div> 
   <div>
    LINK_TO_QH定义如下:
   </div> 
   <div>
    #define LINK_TO_QH(qh)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UHCI_PTR_QH | cpu_to_le32((qh)-&gt;dma_handle))
   </div> 
   <div>
    UHCI_PTR_QH表示链接的是一个QH.然后加上QH的物理地址.相关的部份在UHCI spec上都有详细的描述.请自行查阅有关定义.
   </div> 
   <div>
    UHCI_PTR_TERM定义如下:
   </div> 
   <div>
    #define UHCI_PTR_TERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __constant_cpu_to_le32(0x0001)
   </div> 
   <div>
    即它的bit0 =1.表示” Empty Frame (pointer is invalid)”.也就是表示,它的后面已经没有有效项了.不要再往后面去遍历了.其实就是一个终止项
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //skel_term_qh = skelqh[10]
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* This dummy TD is to work around a bug in Intel PIIX controllers */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //term_td后面已经没有数据了
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;term_td-&gt;link = UHCI_PTR_TERM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;skel_async_qh-&gt;element = uhci-&gt;skel_term_qh-&gt;element =
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LINK_TO_TD(uhci-&gt;term_td);
   </div> 
   <div>
    Skel_term_qh定义成skelqh[10].即uhci-&gt;skelqh[ ]的最后一项.它自己指向了自己.
   </div> 
   <div>
    然后对于uhci-&gt;term_td是Intel PIIX的一个BUG.这部份就不再详细分析了.最后将uhci-&gt;term_td挂上了uhci-&gt;skelqh[9]和uhci-&gt;skelqh[10]
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /*
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* Fill the frame list: make all entries point to the proper
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* interrupt queue.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; UHCI_NUMFRAMES; i++) {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Only place we don't use the frame list routines */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;frame[i] = uhci_frame_skel_link(uhci, i);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /*
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* Some architectures require a full mb() to enforce completion of
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* the memory writes above before the I/O transfers in configure_hc().
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mb();
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; configure_hc(uhci);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;is_initialized = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; start_rh(uhci);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return 0;
   </div> 
   <div>
    最后,将初始化完成的TD和QH项挂到uhci-&gt;frame[].然后再调用configure_hc和start_rh来配置UHCI和启用UHCI.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    /*
   </div> 
   <div>
    &nbsp;* error exits:
   </div> 
   <div>
    &nbsp;*/
   </div> 
   <div>
    err_alloc_skelqh:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (uhci-&gt;skelqh[i])
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_free_td(uhci, uhci-&gt;term_td);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err_alloc_term_td:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dma_pool_destroy(uhci-&gt;qh_pool);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err_create_qh_pool:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dma_pool_destroy(uhci-&gt;td_pool);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err_create_td_pool:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; kfree(uhci-&gt;frame_cpu);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err_alloc_frame_cpu:A
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dma_free_coherent(uhci_dev(uhci),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;frame, uhci-&gt;frame_dma_handle);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err_alloc_frame:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; debugfs_remove(uhci-&gt;dentry);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err_create_debug_entry:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    }
   </div> 
   <div>
    这里的TD,QH交错复杂,很容易把头看昏.画了个图.如下 :
   </div> 
   <div>
    <img src="http://blogimg.chinaunix.net/blog/upfile2/080909094427.jpg" alt="">
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    从上图中可以看出,skelqh[]数组的第0项和第1项是没有经过初始化的.而skelqh[10]又是指向它本身的结点.
   </div> 
   <div>
    经过skelqh[]的初始化后.就可以将它和frmae[]关联起来了.
   </div> 
   <div>
    如下面代码片段所示:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; UHCI_NUMFRAMES; i++) {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Only place we don't use the frame list routines */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;frame[i] = uhci_frame_skel_link(uhci, i);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    Uhci_frame_skel_link()的代码如下所示:
   </div> 
   <div>
    static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int skelnum;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (skelnum &lt;= 1)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skelnum = 9;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return LINK_TO_QH(uhci-&gt;skelqh[skelnum]);
   </div> 
   <div>
    }
   </div> 
   <div>
    这个函数虽然很短小,但是算法却很复杂.
   </div> 
   <div>
    首先来看一下这个函数要做什么事情:
   </div> 
   <div>
    我们在前面说过,int128,int64,int32……int4,int2,int1这样8个QH.我们在后面看到.会将uhci-&gt;frame的物理地址存放到UHCI控制器的Frame List Base Address Register中.所以现在要做的事情就是将这些QH与uhci-&gt;frame[ ]关联起来.必须要按照相应的时间间隔将QH插入到uhci-&gt;frame[]中.例如,例如如果frame[]的n存放int128的QH,那么下一个int128的QH就必须要放到n+128的位置.很明显,对于int1是可以随便放的,也可放可不放.因为int1链接在所有的间隔的QH后面.同时int1又可以单独存放到frame[]中.
   </div> 
   <div>
    另外,从skelqh[2]~skelqh[9]分别表示int128~int1.对于skelqh[0]和skelqh[1]是不需要用到的,而且8- (int) __ffs(frame | UHCI_NUMFRAMES)不可能大于9.所以,将用到skelqh[0]和skelqh[1]的地方.用间隔1ms的skelqh[9]代替.
   </div> 
   <div>
    经过这个函数这后,uhci-&gt;frame[]中的各个QH都按照对应的间隔存放到一起了.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    接着看下面的configure_hc()函数:
   </div> 
   <div>
    static void configure_hc(struct uhci_hcd *uhci)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Set the frame length to the default: 1 ms exactly */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outb(USBSOF_DEFAULT, uhci-&gt;io_addr + USBSOF);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Store the frame list base address */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //将frame指针地址写入基地址寄存器
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outl(uhci-&gt;frame_dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Set the current frame number */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //当前的frame number
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outw(uhci-&gt;frame_number &amp; UHCI_MAX_SOF_NUMBER,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;io_addr + USBFRNUM);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Mark controller as not halted before we enable interrupts */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_to_hcd(uhci)-&gt;state = HC_STATE_SUSPENDED;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mb();
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Enable PIRQ */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USBLEGSUP_DEFAULT);
   </div> 
   <div>
    }
   </div> 
   <div>
    这个函数比较简单.首先将uhci-&gt;frame[ ]的物理地址写到FRBASEADD寄存器中.再将起始帧号写入到FRNUM寄存器.再将状态置为HC_STATE_SUSPENDED.最后到USBLEGSUP中启用PIRQ.这样UHCI就可以产生中断了.
   </div> 
   <div>
    到这里,UHCI已经初始化完成了.现在到了启用它的时候了.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    返回到uhci_start().流程转入到uhci_start().代码如下:
   </div> 
   <div>
    static void start_rh(struct uhci_hcd *uhci)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //将UHCI的状态置为HC_STATE_RUNNING
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;is_stopped = 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Mark it configured and running with a 64-byte max packet.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* All interrupts are enabled, even though RESUME won't do anything.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//启用UHCI,设置CF位,表示已经配置好了,指定最大的包长为64 byte
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //启用各种中断.包括传输超时或者CRC检验错误,RESUME状态中断.传输完成时产生中断
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //短包中断
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;io_addr + USBINTR);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mb();
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //然后将UHCI的状态置为UHCI_RH_RUNNING状态.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci-&gt;rh_state = UHCI_RH_RUNNING;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; uhci_to_hcd(uhci)-&gt;poll_rh = 1;
   </div> 
   <div>
    }
   </div> 
   <div>
    对照代码中的注释和UHCI spec,理解这段代码比较容易.在这里要特别提示一下,什么叫短包中断.
   </div> 
   <div>
    在发送包的时候,如果一次不能够打包完.那就需要将包截短成小包. 一个个传输传输出去.另外,最后一个包可能传输数据会小于允许包大小的最大值.这个的包叫短包.我们在后面的中断处理函数中会有对于短包的处理.到时再详细分析它的处理.
   </div> 
   <div>
    到这里.UHCI就开始调度了.不过这时候.整个调度系统中就只含有一个term_td.然而这个td的初始化如下(在uhci_start[ ]函数中):
   </div> 
   <div>
    uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
   </div> 
   <div>
    也就是它的status为空,也就是说,这个TD是一个INACTIVE的.实际这个UHCI是空负荷运行.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    运行到这里,hcd-&gt;start()运行完了.流程会返回到usb_add_hcd()到.的重要操作只剩余register_root_hub().probe过程也要接近尾声了.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    2.4:register_root_hub()的操作
   </div> 
   <div>
    这个函数主要是对UHCI的root hub进行处理.代码如下:
   </div> 
   <div>
    static int register_root_hub(struct usb_hcd *hcd)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct device *parent_dev = hcd-&gt;self.controller;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_device *usb_dev = hcd-&gt;self.root_hub;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; const int devnum = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int retval;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //root hub的devnum为1.下一个设备号从2开始.devnum也即设备地址
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_dev-&gt;devnum = devnum;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_dev-&gt;bus-&gt;devnum_next = devnum + 1;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //usb_bus-&gt;devmap是一个位图.表示设备号的分配情况
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; memset (&amp;usb_dev-&gt;bus-&gt;devmap.devicemap, 0,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof usb_dev-&gt;bus-&gt;devmap.devicemap);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //将root hub占用位置1
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; set_bit (devnum, usb_dev-&gt;bus-&gt;devmap.devicemap);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //设置成Address&nbsp; 状态
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_set_device_state(usb_dev, USB_STATE_ADDRESS);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mutex_lock(&amp;usb_bus_list_lock);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //端点0的最大发送或者接收值
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_dev-&gt;ep0.desc.wMaxPacketSize = __constant_cpu_to_le16(64);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //取得root hub的设备描述符
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; retval = usb_get_device_descriptor(usb_dev, USB_DT_DEVICE_SIZE);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (retval != sizeof usb_dev-&gt;descriptor) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;usb_bus_list_lock);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg (parent_dev, "can't read %s device descriptor %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_dev-&gt;dev.bus_id, retval);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (retval &lt; 0) ? retval : -EMSGSIZE;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //进一步初始化这个设备
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; retval = usb_new_device (usb_dev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (retval) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err (parent_dev, "can't register root hub for %s, %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_dev-&gt;dev.bus_id, retval);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;usb_bus_list_lock);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (retval == 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock_irq (&amp;hcd_root_hub_lock);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //root hub注册成功,将rh_registered设为1
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hcd-&gt;rh_registered = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock_irq (&amp;hcd_root_hub_lock);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Did the HC die before the root hub was registered? */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果hcd被人为置为了HALT
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hcd-&gt;state == HC_STATE_HALT)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_hc_died (hcd); /* This time clean up */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    }
   </div> 
   <div>
    对于代码中较简单部份,结合注释应该就能看懂了.详细分析一下里面涉及到的几个子函数.
   </div> 
   <div>
    第一个是usb_set_device_state().
   </div> 
   <div>
    在分析代码之前,先来看一下USB设备的状态机.在USB2.0的spec上.有一副这样的图:
   </div> 
   <div>
    <img src="http://blogimg.chinaunix.net/blog/upfile2/080909094606.jpg" alt="">
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    上图表示USB设备的各种状态的转变.
   </div> 
   <div>
    1:如果设备末连接,对应状态为USB_STATE_NOTATTACHED. 这个状态在spec上末表示.是linux中自定义的.实际上它就是表示Attached的一个对立状态.
   </div> 
   <div>
    2:如果设备连上了,但是没有打开电源,处于Attached状态.USB检测到一个设备的时候,会将它初始化这个状态(道理很简单,因为要连上才能检测到 ^_^).可以查看下usb_alloc_dev()函数对状态的初始化.在代码,这个状态对应为:
    <span style="font-size:medium;">&nbsp;</span>USB_STATE_ATTACHED.
   </div> 
   <div>
    3:如果在上个状态中打开了设备此时打开了电源,设备处于Rowered.在代码中对应USB_STATE_POWERED.
   </div> 
   <div>
    4:如果在上一个状态中,设备被重置,也即初始化,就会转入Default.代码中对应USB_STATE_DEFAULT.
   </div> 
   <div>
    5:如果在上一个状态中,USB为设备分配了地址,就会转入到Address.代码中对应USB_STATE_ADDRESS.
   </div> 
   <div>
    6:如果在上一个状态中,USB完成了设备的配置.就会转入Configured.代码中对应USB_STATE_CONFIGURED.
   </div> 
   <div>
    7:上面除NoAttached和Attached外的所有状态,如果设备被挂起,就会转入Suspended.代码中对应USB_STATE_SUSPENDED.
   </div> 
   <div>
    特别说明:UHCI本身带有root hub功能.hub是一个特殊的USB设备.它的设备地址被固定为1.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    对应到上面的代码中:
   </div> 
   <div>
    指定root hub的devnum之后,就将其状态设为Address.这个devnum也即设备的地址.设备状态函数为usb_set_device_state().代码如下:
   </div> 
   <div>
    void usb_set_device_state(struct usb_device *udev,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enum usb_device_state new_state)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned long flags;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; spin_lock_irqsave(&amp;device_state_lock, flags);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //如果设备末连接.不做任何处理
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;state == USB_STATE_NOTATTACHED)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; /* do nothing */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else if (new_state != USB_STATE_NOTATTACHED) {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* root hub wakeup capabilities are managed out-of-band
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* and may involve silicon errata ... ignore them here.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//如果不是root hub
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;parent) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;state == USB_STATE_SUSPENDED
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || new_state == USB_STATE_SUSPENDED)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp; /* No change to wakeup settings */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (new_state == USB_STATE_CONFIGURED)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_init_wakeup(&amp;udev-&gt;dev,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (udev-&gt;actconfig-&gt;desc.bmAttributes
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&amp; USB_CONFIG_ATT_WAKEUP));
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_init_wakeup(&amp;udev-&gt;dev, 0);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果是从Suspended转到其它状态或者是转到Suspended状态
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //更新active_duration计数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;state == USB_STATE_SUSPENDED &amp;&amp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_state != USB_STATE_SUSPENDED)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;active_duration -= jiffies;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (new_state == USB_STATE_SUSPENDED &amp;&amp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;state != USB_STATE_SUSPENDED)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;active_duration += jiffies;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //设置状态
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;state = new_state;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里是多余的吧?
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recursively_mark_NOTATTACHED(udev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; spin_unlock_irqrestore(&amp;device_state_lock, flags);
   </div> 
   <div>
    }
   </div> 
   <div>
    这段代码没有什么好多讲的.就是设置状态而已.对于不是root hub的情况,还涉及到了电源管理的情况,在这里不做分析.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    设置完设备状态之后,调用usb_get_device_descriptor()来取得设备描述符.这个函数涉及到数据的传输实现.在接下来的章节中再做详细分析.在这里只需知道,完成之后会将设备描述符存放在usb_dev-&gt;descriptor.
   </div> 
   <div>
    获取到设备描述符之后,就可以获得设备的详细信息了.具体的详细可考阅USB2.0 spec.在这些信息里会包括设备的配置项数目.因此在接下来的操作中,就会将设备所支持的所有配置取出来.这是在usb_new_device()中完成的.代码如下所示:
   </div> 
   <div>
    int usb_new_device(struct usb_device *udev)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int err;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //一些设备的fixup
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_detect_quirks(udev);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Determine quirks */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //取得配置描述符
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; err = usb_configure_device(udev);&nbsp;&nbsp;&nbsp; /* detect &amp; probe dev/intfs */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (err &lt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* export the usbdev device-node for libusb */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //指定设备的设备号
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;dev.devt = MKDEV(USB_DEVICE_MAJOR,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((udev-&gt;bus-&gt;busnum-1) * 128) + (udev-&gt;devnum-1)));
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Increment the parent's count of unsuspended children */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;parent)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_autoresume_device(udev-&gt;parent);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Register the device.&nbsp; The device driver is responsible
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* for adding the device files to sysfs and for configuring
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* the device.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//注册usb_dev中内嵌的struct device
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; err = device_add(&amp;udev-&gt;dev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (err) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(&amp;udev-&gt;dev, "can't device_add, error %d\n", err);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Tell the world! */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //输出一些该设备的信息
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; announce_device(udev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return err;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    fail:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; usb_set_device_state(udev, USB_STATE_NOTATTACHED);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return err;
   </div> 
   <div>
    }
   </div> 
   <div>
    这个代码的逻辑比较清淅.首先是usb_detect_quirks()函数,为个函数较简单,不打算进行详细分析,只是简单提一下.有些设备可能在设计存在一些问题.比如说,有的设备在Reset的时候会出现问题,或者在取string描述符的时候对buffer长度有要求.这样的设备都会在linux内核中形成一个链表,即usb_quirk_list.然后将设备的厂商ID,版本等信息与usb_quirk_list上的设备匹配.如果匹配到了,就在usb_dev添上相应的标识,不允许设备进行限制的功能.或者是设备驱动根据修改信息调整相关的操作.
   </div> 
   <div>
    然后是usb_configure_device()函数.这个函数比较重要,跟踪进去分析一下&nbsp;:
   </div> 
   <div>
    static int usb_configure_device(struct usb_device *udev)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int err;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //取得设备的配置
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;config == NULL) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = usb_get_configuration(udev);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(&amp;udev-&gt;dev, "can't read configurations, error %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto fail;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //如果是无线设备
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (udev-&gt;wusb == 1 &amp;&amp; udev-&gt;authorized == 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;product = kstrdup("n/a (unauthorized)", GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;manufacturer = kstrdup("n/a (unauthorized)", GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;serial = kstrdup("n/a (unauthorized)", GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //usb_cache_string:会将其关的字串存进一个缓冲,用户空间如果要取设备信息的话
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //只要从缓存区取就可以了
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* read the standard strings and cache them if present */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;product = usb_cache_string(udev, udev-&gt;descriptor.iProduct);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;manufacturer = usb_cache_string(udev,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;descriptor.iManufacturer);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev-&gt;serial = usb_cache_string(udev, udev-&gt;descriptor.iSerialNumber);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //OTG: On-The-GO.表示设备有主机控制器的功能
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; err = usb_configure_device_otg(udev);
   </div> 
   <div>
    fail:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return err;
   </div> 
   <div>
    }
   </div> 
   <div>
    首先解释一下CONFIG_USB_OTG的配置选项.一般来说,系统中只能有一个主机控制器.但有时候设备也可以带一个host control的功能.举个例子,数码相机.它接在PC上,做为一般的USB设备使用.它也可以连接在打印上直接打印,这时就会做会一个HC使用.
   </div> 
   <div>
    关于OTG的选择编译代码,这里不做深入研究,忽略掉.
   </div> 
   <div>
    其次要解释的是关于usb_cache_string()的操作.这个函数在取字串的时候还会将字符信息保存到一个缓存区.这样一些读USB信息的工具,就只要从指定的缓存区里取值就可以了.
   </div> 
   <div>
    重点放在usb_get_configuration()函数上.这个函数很烦锁.在分析之前.先来了解一下相关的部份.
   </div> 
   <div>
    USB设备有时候会用做多种用途.比如上面的一个例如.数码相机中的USB,可以用做视频存储,也可以当做U盘来使用.那做为驱动程序.它必须要知道设备有多少种功能.在USB2.0 spec中,用配置表示功能.也就是说,对于上在的例子来说,数码相机的USB设备至少应该有两个配置,一个是视频存储的配置,另外的是U盘的配置.由驱动程序来决定应用哪种配置来使用对应的功能.
   </div> 
   <div>
    接口是USB提供的单元组件.因此,有可能一个配置要使用到多个接口,也有可能一个接口也被多个配置使用的情况,不过不使用接口的配置是不存在的.
   </div> 
   <div>
    根据USB的spec有关设备的检测过程中描述,USB控制器先取得设备描述符,这个描述符里包含了配置的个数.然后再以长度9做为参数去取设备配置描述符头部,这个描述符里包含了描述符的实际长际.最后再以实际长度做参数去取完整的配置描述符.取得的配置描述符不仅包含配置描述符信息,还包括了接口信息和接口所使用的端口信息.
   </div> 
   <div>
    将代码中的有关数据结构如下所示&nbsp;:
   </div> 
   <div>
    <img src="http://blogimg.chinaunix.net/blog/upfile2/080909094714.jpg" alt="">
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    大概说一下,usb_dev中的config数组对应每一项配置.config数组的数据结构为struct usb_host_config.这个数据结构中又包含Inft_cache[ ]数组,这个数组用来表示存放接口信息.由于一个接口可能属于同一配置的不同设置,用接口描述符的bAlternateSetting字段来区别接口所属的接口描述符.所以在inft_cache[]对应的usb_host_cache中又有一个扩展项来存放每一个接口描述符.
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    以注释的方式列出usb_get_configuration(),就不做详细分析了,结合上面的说明和代码中的注释来分析这段代码应该没什么问题了.如下:
   </div> 
   <div>
    int usb_get_configuration(struct usb_device *dev)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct device *ddev = &amp;dev-&gt;dev;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int ncfg = dev-&gt;descriptor.bNumConfigurations;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int result = 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned int cfgno, length;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned char *buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned char *bigbuffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_config_descriptor *desc;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; cfgno = 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (dev-&gt;authorized == 0)&nbsp;&nbsp; /* Not really an error */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out_not_authorized;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; result = -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //如果配置项数目超过允许的最大数.将其强制设为最大数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (ncfg &gt; USB_MAXCONFIG) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "too many configurations: %d, "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "using maximum allowed: %d\n", ncfg, USB_MAXCONFIG);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //如果一个配置都没有.错误
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (ncfg &lt; 1) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "no configurations\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //dev-&gt;config所占内存大小.总共有ncfg个配置项
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; length = ncfg * sizeof(struct usb_host_config);
   </div> 
   <div>
    //为dev-&gt;config分存内存
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;config = kzalloc(length, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!dev-&gt;config)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err2;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; length = ncfg * sizeof(char *);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;rawdescriptors = kzalloc(length, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!dev-&gt;rawdescriptors)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err2;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; buffer = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!buffer)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err2;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; desc = (struct usb_config_descriptor *)buffer;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; result = 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //从设备中依次取出各配置.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (; cfgno &lt; ncfg; cfgno++) {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里有两次取CONFIG的过程.第一次是9为size取得配置的长度.然后
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //再以特定长度做为size去取完整的config
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We grab just the first descriptor so we know how long
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* the whole configuration is */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buffer, USB_DT_CONFIG_SIZE);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "unable to read config index %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "descriptor/%s: %d\n", cfgno, "start", result);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "chopping to %d config(s)\n", cfgno);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;descriptor.bNumConfigurations = cfgno;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (result &lt; 4) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "config index %d descriptor too short "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "(expected %i, got %i)\n", cfgno,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_CONFIG_SIZE, result);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = -EINVAL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取config长度
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = max((int) le16_to_cpu(desc-&gt;wTotalLength),
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_CONFIG_SIZE);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Now that we know the length, get the whole thing */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bigbuffer = kmalloc(length, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!bigbuffer) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取完整的config,并将其存放在bigbuffer中
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bigbuffer, length);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "unable to read config index %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "descriptor/%s\n", cfgno, "all");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(bigbuffer);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result &lt; length) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config index %d descriptor too short "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "(expected %i, got %i)\n", cfgno, length, result);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length = result;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //dev-&gt;rawdescriptors中存放了取得的CONFIG
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;rawdescriptors[cfgno] = bigbuffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //解析取得的config信息
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = usb_parse_configuration(&amp;dev-&gt;dev, cfgno,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;dev-&gt;config[cfgno], bigbuffer, length);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result &lt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++cfgno;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; result = 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    err:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; kfree(buffer);
   </div> 
   <div>
    out_not_authorized:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;descriptor.bNumConfigurations = cfgno;
   </div> 
   <div>
    err2:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (result == -ENOMEM)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "out of memory\n");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return result;
   </div> 
   <div>
    }
   </div> 
   <div>
    对每个配置都会调用usb_parse_configuration()对它进行解析.代码如下:
   </div> 
   <div>
    static int usb_parse_configuration(struct device *ddev, int cfgidx,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp; struct usb_host_config *config, unsigned char *buffer, int size)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned char *buffer0 = buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int cfgno;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int nintf, nintf_orig;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int i, j, n;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_interface_cache *intfc;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned char *buffer2;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int size2;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_descriptor_header *header;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int len, retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; u8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned iad_num = 0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //配置描述符信息.这个信息在后面还会修正的
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; memcpy(&amp;config-&gt;desc, buffer, USB_DT_CONFIG_SIZE);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (config-&gt;desc.bDescriptorType != USB_DT_CONFIG ||
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; config-&gt;desc.bLength &lt; USB_DT_CONFIG_SIZE) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(ddev, "invalid descriptor for config index %d: "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "type = 0x%X, length = %d\n", cfgidx,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; config-&gt;desc.bDescriptorType, config-&gt;desc.bLength);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //CONFIG序号
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; cfgno = config-&gt;desc.bConfigurationValue;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //完整的配置信息除了标准头部处,还会带上接口和端口描述符信息
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //bLength: 描述符长度
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; buffer += config-&gt;desc.bLength;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //接口描述符大小
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; size -= config-&gt;desc.bLength;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //接口数目
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; nintf = nintf_orig = config-&gt;desc.bNumInterfaces;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //接口数目太多
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (nintf &gt; USB_MAXINTERFACES) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has too many interfaces: %d, "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "using maximum allowed: %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, nintf, USB_MAXINTERFACES);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nintf = USB_MAXINTERFACES;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Go through the descriptors, checking their length and counting the
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* number of altsettings for each interface */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; n = 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for ((buffer2 = buffer, size2 = size);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size2 &gt; 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (buffer2 += header-&gt;bLength, size2 -= header-&gt;bLength)) {
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (size2 &lt; sizeof(struct usb_descriptor_header)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d descriptor has %d excess "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "byte%s, ignoring\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, size2, plural(size2));
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; header = (struct usb_descriptor_header *) buffer2;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((header-&gt;bLength &gt; size2) || (header-&gt;bLength &lt; 2)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has an invalid descriptor "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "of length %d, skipping remainder of the config\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, header-&gt;bLength);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果后面跟的是INTERFACE的描述符
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (header-&gt;bDescriptorType == USB_DT_INTERFACE) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct usb_interface_descriptor *d;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int inum;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d = (struct usb_interface_descriptor *) header;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果长度太短,不合法.继续下一个interface config
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (d-&gt;bLength &lt; USB_DT_INTERFACE_SIZE) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has an invalid "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "interface descriptor of length %d, "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "skipping\n", cfgno, d-&gt;bLength);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //接号序号&nbsp;&nbsp;&nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inum = d-&gt;bInterfaceNumber;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //接口序号超过了最大值
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (inum &gt;= nintf_orig)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has an invalid "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "interface number: %d but max is %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, nintf_orig - 1);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Have we already encountered this interface?
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* Count its altsettings */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//nalts[ ]是相同端口出现次数的统计
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//如果在inums[ ]中已经包含这个接口了.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; n; ++i) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (inums[i] == inum)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果已经在inums[ ]了,增加nalts[]相应项的统计计数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i &lt; n) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nalts[i] &lt; 255)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++nalts[i];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //否则将序号设置进inums[ ]中,nalts[]相应项为1.因为还是第一次出现
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (n &lt; USB_MAXINTERFACES) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inums[n] = inum;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nalts[n] = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++n;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //minor usb only
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (header-&gt;bDescriptorType ==
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USB_DT_INTERFACE_ASSOCIATION) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iad_num == USB_MAXIADS) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "found more Interface "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Association Descriptors "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "than allocated for in "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "configuration %d\n", cfgno);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config-&gt;intf_assoc[iad_num] =
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (struct usb_interface_assoc_descriptor
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)header;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iad_num++;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (header-&gt;bDescriptorType == USB_DT_DEVICE ||
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; header-&gt;bDescriptorType == USB_DT_CONFIG)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d contains an unexpected "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "descriptor of type 0x%X, skipping\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, header-&gt;bDescriptorType);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp; /* for ((buffer2 = buffer, size2 = size); ...) */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //size是有效的interface config数据部份的长度
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; size = buffer2 - buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; config-&gt;desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //n是inums[ ]数组的有效项数,也即端口个数.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //更新n,使表示实际的端口个数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (n != nintf)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has %d interface%s, different from "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "the descriptor's value: %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, n, plural(n), nintf_orig);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else if (n == 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has no interfaces?\n", cfgno);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; config-&gt;desc.bNumInterfaces = nintf = n;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Check for missing interface numbers */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //检查inums[ ]是否准确.如果有异常,打印出警告信息
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; nintf; ++i) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; nintf; ++j) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (inums[j] == i)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &gt;= nintf)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d has no interface number "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "%d\n", cfgno, i);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Allocate the usb_interface_caches and altsetting arrays */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //每一个接口号对应intf_cache[ ]一项.然nals[ ]表示该接口号的个数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; nintf; ++i) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = nalts[i];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (j &gt; USB_MAXALTSETTING) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "too many alternate settings for "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "config %d interface %d: %d, "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "using maximum allowed: %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inums[i], j, USB_MAXALTSETTING);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nalts[i] = j = USB_MAXALTSETTING;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config-&gt;intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!intfc)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kref_init(&amp;intfc-&gt;ref);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Skip over any Class Specific or Vendor Specific descriptors;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* find the first interface descriptor */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//config-&gt;extar:config的扩展部份,即interface config的那部份
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; config-&gt;extra = buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //找到一下个USB_DT_INTERFACE项.返回跳过去的数据长度和描述符项
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = find_next_descriptor(buffer, size, USB_DT_INTERFACE,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_INTERFACE, &amp;n);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; config-&gt;extralen = i;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //到现在为止,config-&gt;extra返回的是下一个配置描述符起始地址
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //config-&gt;extralen下一个配置描述符地址和config-&gt;extra的偏移值
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (n &gt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; n, plural(n), "configuration");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //现在interface config有效的起点位置,size有效大小
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; buffer += i;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; size -= i;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Parse all the interface/altsetting descriptors */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; while (size &gt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = usb_parse_interface(ddev, cfgno, config,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buffer, size, inums, nalts);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (retval &lt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer += retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size -= retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Check for missing altsettings */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //检查config-&gt;inft)cache[]中是否有异常
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; nintf; ++i) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfc = config-&gt;intf_cache[i];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; intfc-&gt;num_altsetting; ++j) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (n = 0; n &lt; intfc-&gt;num_altsetting; ++n) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (intfc-&gt;altsetting[n].desc.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bAlternateSetting == j)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n &gt;= intfc-&gt;num_altsetting)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d interface %d has no "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "altsetting %d\n", cfgno, inums[i], j);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return 0;
   </div> 
   <div>
    }
   </div> 
   <div>
    usb_parse_interface()代码如下:
   </div> 
   <div>
    static int usb_parse_interface(struct device *ddev, int cfgno,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp; struct usb_host_config *config, unsigned char *buffer, int size,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp; u8 inums[], u8 nalts[])
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned char *buffer0 = buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_interface_descriptor&nbsp; *d;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int inum, asnum;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_interface_cache *intfc;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_host_interface *alt;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int i, n;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int len, retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int num_ep, num_ep_orig;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; d = (struct usb_interface_descriptor *) buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; buffer += d-&gt;bLength;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; size -= d-&gt;bLength;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (d-&gt;bLength &lt; USB_DT_INTERFACE_SIZE)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto skip_to_next_interface_descriptor;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Which interface entry is this? */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; intfc = NULL;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; inum = d-&gt;bInterfaceNumber;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //config-&gt;intf_cache保存着端点的相关信息
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (inums[i] == inum) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intfc = config-&gt;intf_cache[i];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //保存的端口总数超过了最大值,非法
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (!intfc || intfc-&gt;num_altsetting &gt;= nalts[i])
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto skip_to_next_interface_descriptor;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Check for duplicate altsetting entries */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //标识字段
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; asnum = d-&gt;bAlternateSetting;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //如果存在相同的.非法
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; for ((i = 0, alt = &amp;intfc-&gt;altsetting[0]);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i &lt; intfc-&gt;num_altsetting;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; (++i, ++alt)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (alt-&gt;desc.bAlternateSetting == asnum) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "Duplicate descriptor for config %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "interface %d altsetting %d, skipping\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto skip_to_next_interface_descriptor;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //更新计数
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ++intfc-&gt;num_altsetting;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //如果合法的话,那alt就是指向一个空的接点描述符
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; memcpy(&amp;alt-&gt;desc, d, USB_DT_INTERFACE_SIZE);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Skip over any Class Specific or Vendor Specific descriptors;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* find the first endpoint or interface descriptor */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//下一个endpoint descriptors的地址
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; alt-&gt;extra = buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_INTERFACE, &amp;n);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //alt-&gt;extar+alt-&gt;extralen表示下一个描述符地址
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; alt-&gt;extralen = i;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (n &gt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; n, plural(n), "interface");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //下个intreface desp的地址
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; buffer += i;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; size -= i;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //接口中端点描述符的个数.
    <span style="font-size:medium;">&nbsp;</span>注意在这里将alt-&gt;desc.bNumEndpoints清0了
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Allocate space for the right(?) number of endpoints */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; num_ep = num_ep_orig = alt-&gt;desc.bNumEndpoints;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; alt-&gt;desc.bNumEndpoints = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Use as a counter */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (num_ep &gt; USB_MAXENDPOINTS) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "too many endpoints for config %d interface %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "altsetting %d: %d, using maximum allowed: %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_ep = USB_MAXENDPOINTS;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (num_ep &gt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Can't allocate 0 bytes */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = sizeof(struct usb_host_endpoint) * num_ep;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alt-&gt;endpoint = kzalloc(len, GFP_KERNEL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!alt-&gt;endpoint)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -ENOMEM;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Parse all the endpoint descriptors */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; n = 0;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; while (size &gt; 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (((struct usb_descriptor_header *) buffer)-&gt;bDescriptorType
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; == USB_DT_INTERFACE)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; num_ep, buffer, size);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (retval &lt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++n;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer += retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size -= retval;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (n != num_ep_orig)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d interface %d altsetting %d has %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "endpoint descriptor%s, different from the interface "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "descriptor's value: %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum, n, plural(n), num_ep_orig);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return buffer - buffer0;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    skip_to_next_interface_descriptor:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = find_next_descriptor(buffer, size, USB_DT_INTERFACE,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_INTERFACE, NULL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return buffer - buffer0 + i;
   </div> 
   <div>
    }
   </div> 
   <div>
    usb_parse_endpoint()代码如下:
   </div> 
   <div>
    static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp; int asnum, struct usb_host_interface *ifp, int num_ep,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp; unsigned char *buffer, int size)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; unsigned char *buffer0 = buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_endpoint_descriptor *d;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; struct usb_host_endpoint *endpoint;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; int n, i, j;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; d = (struct usb_endpoint_descriptor *) buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; buffer += d-&gt;bLength;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; size -= d-&gt;bLength;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //判断长度是否合法
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (d-&gt;bLength &gt;= USB_DT_ENDPOINT_AUDIO_SIZE)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = USB_DT_ENDPOINT_AUDIO_SIZE;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else if (d-&gt;bLength &gt;= USB_DT_ENDPOINT_SIZE)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = USB_DT_ENDPOINT_SIZE;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; else {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d interface %d altsetting %d has an "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "invalid endpoint descriptor of length %d, skipping\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum, d-&gt;bLength);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto skip_to_next_endpoint_or_interface_descriptor;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //取得端点的地址,也就是端口号
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = d-&gt;bEndpointAddress &amp; ~USB_ENDPOINT_DIR_MASK;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //不可能会超16个端点,也不可能
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (i &gt;= 16 || i == 0) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d interface %d altsetting %d has an "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "invalid endpoint with address 0x%X, skipping\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum, d-&gt;bEndpointAddress);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto skip_to_next_endpoint_or_interface_descriptor;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Only store as many endpoints as we have room for */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //注意在前面调用函数中已经将ifp-&gt;desc.bNumEndpoints清0了,以后每处理
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //一个端点描述符,都会将这个成员值+1
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (ifp-&gt;desc.bNumEndpoints &gt;= num_ep)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto skip_to_next_endpoint_or_interface_descriptor;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //保存端点描述符信息,并更新端点数目
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; endpoint = &amp;ifp-&gt;endpoint[ifp-&gt;desc.bNumEndpoints];
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; ++ifp-&gt;desc.bNumEndpoints;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; memcpy(&amp;endpoint-&gt;desc, d, n);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;endpoint-&gt;urb_list);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Fix up bInterval values outside the legal range. Use 32 ms if no
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* proper value can be guessed. */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* i = min, j = max, n = default */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; j = 255;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; //根据不同的传输类型,计算间隔时间
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (usb_endpoint_xfer_int(d)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (to_usb_device(ddev)-&gt;speed) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case USB_SPEED_HIGH:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Many device manufacturers are using full-speed
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* bInterval values in high-speed interrupt endpoint
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* descriptors. Try to fix those and fall back to a
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* 32 ms default value otherwise. */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = fls(d-&gt;bInterval*8);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n == 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 9;&nbsp;&nbsp; /* 32 ms = 2^(9-1) uframes */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 16;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* USB_SPEED_FULL or _LOW */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* For low-speed, 10 ms is the official minimum.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* But some "overclocked" devices might want faster
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* polling so we'll allow it. */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 32;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; } else if (usb_endpoint_xfer_isoc(d)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = 16;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (to_usb_device(ddev)-&gt;speed) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case USB_SPEED_HIGH:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 9;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32 ms = 2^(9-1) uframes */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* USB_SPEED_FULL */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 6;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32 ms = 2^(6-1) frames */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (d-&gt;bInterval &lt; i || d-&gt;bInterval &gt; j) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d interface %d altsetting %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "endpoint 0x%X has an invalid bInterval %d, "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "changing to %d\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; d-&gt;bEndpointAddress, d-&gt;bInterval, n);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint-&gt;desc.bInterval = n;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Some buggy low-speed devices have Bulk endpoints, which is
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* explicitly forbidden by the USB spec.&nbsp; In an attempt to make
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* them usable, we will try treating them as Interrupt endpoints.
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (to_usb_device(ddev)-&gt;speed == USB_SPEED_LOW &amp;&amp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_endpoint_xfer_bulk(d)) {
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(ddev, "config %d interface %d altsetting %d "
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "endpoint 0x%X is Bulk; changing to Interrupt\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; cfgno, inum, asnum, d-&gt;bEndpointAddress);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint-&gt;desc.bmAttributes = USB_ENDPOINT_XFER_INT;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint-&gt;desc.bInterval = 1;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (le16_to_cpu(endpoint-&gt;desc.wMaxPacketSize) &gt; 8)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; /* Skip over any Class Specific or Vendor Specific descriptors;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* find the next endpoint or interface descriptor */
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//同之前分析的一样,下一个描述符的有效地址和偏移
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; endpoint-&gt;extra = buffer;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_INTERFACE, &amp;n);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; endpoint-&gt;extralen = i;
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; if (n &gt; 0)
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; n, plural(n), "endpoint");
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return buffer - buffer0 + i;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    skip_to_next_endpoint_or_interface_descriptor:
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; USB_DT_INTERFACE, NULL);
   </div> 
   <div>
    &nbsp;&nbsp;&nbsp;&nbsp; return buffer - buffer0 + i;
   </div> 
   <div>
    }
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    到这里,root hub对应的配置,接口,端点信息都可以在usb_dev中找到了.UHCI的初始化工作就全部完成了.在之后的分析中,会经常涉及到具体的信息传输过程.在前面的代码中遇到也一笔代过了.为了以后的分析方便,在下一节里,对每个类型的传输过程做一个全面的分析.
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
