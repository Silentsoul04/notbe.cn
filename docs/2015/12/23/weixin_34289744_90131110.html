<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux USB驱动框架分析 【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://blog.chinaunix.net/uid-11848011-id-96188.html    初次接触与OS相关的设备驱动编写，感觉还挺有意思的，为了不至于忘掉看过的东西，笔记跟总结当然不可缺，更何况我决定为嵌入式卖命了。好，言归正传，我说一说这段时间的收获，跟大...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/12/23/weixin_34289744_90131110.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux USB驱动框架分析 【转】</h1>
    <p class="post-meta">Dec 23, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p><span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">转自：<a href="http://blog.chinaunix.net/uid-11848011-id-96188.html" rel="nofollow">http://blog.chinaunix.net/uid-11848011-id-96188.html</a></span></span></span></p> 
   <p><span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">初次接触与</span>OS<span style="font-family:'宋体';">相关的设备驱动编写，感觉还挺有意思的，为了不至于忘掉看过的东西，笔记跟总结当然不可缺，更何况我决定为嵌入式卖命了。好，言归正传，我说一说这段时间的收获，跟大家分享一下</span>Linux<span style="font-family:'宋体';">的驱动开发。但这次只先针对</span>Linux<span style="font-family:'宋体';">的</span>USB<span style="font-family:'宋体';">子系统作分析，因为周五研讨老板催货。当然，还会顺带提一下其他的驱动程序写法。</span></span></span></p> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>事实上，<span style="font-family:'Times New Roman';">Linux</span>的设备驱动都遵循一个惯例<span style="font-family:'Times New Roman';">——</span>表征驱动程序（用<span style="font-family:'Times New Roman';">driver</span>更贴切一些，应该称为驱动器比较好吧）的结构体，结构体里面应该包含了驱动程序所需要的所有资源。用术语来说，就是这个驱动器对象所拥有的属性及成员。由于<span style="font-family:'Times New Roman';">Linux</span>的内核用<span style="font-family:'Times New Roman';">c</span>来编写，所以我们也按照这种结构化的思想来分析代码，但我还是希望从<span style="font-family:'Times New Roman';">OO</span>的角度来阐述这些细节。这个结构体的名字有驱动开发人员决定，比如说，鼠标可能有一个叫做<span style="font-family:'Times New Roman';">mouse_dev</span>的<span style="font-family:'Times New Roman';">struct</span>，键盘可能由一个<span style="font-family:'Times New Roman';">keyboard_dev</span>的<span style="font-family:'Times New Roman';">struct</span>（<span style="font-family:'Times New Roman';">dev for device</span>，我们做的只是设备驱动）。而这次我们来分析一下<span style="font-family:'Times New Roman';">Linux</span>内核源码中的一个<span style="font-family:'Times New Roman';">usb-skeleton</span>（就是<span style="font-family:'Times New Roman';">usb</span>驱动的骨架咯），自然，他定义的设备结构体就叫做<span style="font-family:'Times New Roman';">usb-skel</span>：</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>struct usb_skel</strong>&nbsp;{</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct usb_device *&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;udev;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;/* the usb device for this device */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct usb_interface *&nbsp; &nbsp;interface;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;/* the interface for this device */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct semaphore&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limit_sem;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* limiting the number of writes in progress */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned char *&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bulk_in_buffer;&nbsp;&nbsp;&nbsp; &nbsp;/* the buffer to receive data */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;bulk_in_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* the size of the receive buffer */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; __u8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulk_in_endpointAddr;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* the address of the bulk in endpoint */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; __u8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;bulk_out_endpointAddr; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* the address of the bulk out endpoint */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct kref&nbsp;&nbsp; kref;</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">};</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这里我们得补充说明一下一些<span style="font-family:'Times New Roman';">USB</span>的协议规范细节。<span style="font-family:'Times New Roman';">USB</span>能够自动监测设备，并调用相应得驱动程序处理设备，所以其规范实际上是相当复杂的，幸好，我们不必理会大部分细节问题，因为<span style="font-family:'Times New Roman';">Linux</span>已经提供相应的解决方案。就我现在的理解来说，<span style="font-family:'Times New Roman';">USB</span>的驱动分为两块，一块是<span style="font-family:'Times New Roman';">USB</span>的<span style="font-family:'Times New Roman';">bus</span>驱动，这个东西，<span style="font-family:'Times New Roman';">Linux</span>内核已经做好了，我们可以不管，但我们至少要了解他的功能。形象得说，<span style="font-family:'Times New Roman';">USB</span>的<span style="font-family:'Times New Roman';">bus</span>驱动相当于铺出一条路来，让所有的信息都可以通过这条<span style="font-family:'Times New Roman';">USB</span>通道到达该到的地方，这部分工作由<span style="font-family:'Times New Roman';">usb_core</span>来完成。当<span style="font-family:'Times New Roman';">USB</span>设备接到<span style="font-family:'Times New Roman';">USB</span>控制器接口时，<span style="font-family:'Times New Roman';">usb_core</span>就检测该设备的一些信息，例如生产厂商<span style="font-family:'Times New Roman';">ID</span>和产品的<span style="font-family:'Times New Roman';">ID</span>，或者是设备所属的<span style="font-family:'Times New Roman';">class</span>、<span style="font-family:'Times New Roman';">subclass</span>跟<span style="font-family:'Times New Roman';">protocol</span>，以便确定应该调用哪一个驱动处理该设备。里面复杂细节我们不用管，我们要做的是另一块工作<span style="font-family:'Times New Roman';">——usb</span>的设备驱动。也就是说，我们就等着<span style="font-family:'Times New Roman';">usb_core</span>告诉我们要工作了，我们才工作。</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>从开发人员的角度看，每一个<span style="font-family:'Times New Roman';">usb</span>设备有若干个配置<span style="font-family:'Times New Roman';">(configuration)</span>组成，每个配置又可以有多个接口<span style="font-family:'Times New Roman';">(interface)</span>，每个接口又有多个设置<span style="font-family:'Times New Roman';">(setting</span>图中没有给出<span style="font-family:'Times New Roman';">)</span>，而接口本身可能没有端点或者多个端点（<span style="font-family:'Times New Roman';">end point</span>）。<span style="font-family:'Times New Roman';">USB</span>的数据交换通过端点来进行，主机与各个端点之间建立起单向的管道来传输数据。而这些接口可以分为四类：</span></span>
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>控制（</strong><strong><span style="font-family:'Times New Roman';">control</span></strong><strong>）</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>用于配置设备、获取设备信息、发送命令或者获取设备的状态报告</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>中断（</strong><strong><span style="font-family:'Times New Roman';">interrupt</span></strong><strong>）</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当<span style="font-family:'Times New Roman';">USB</span>宿主要求设备传输数据时，中断端点会以一个固定的速率传送少量数据，还用于发送数据到<span style="font-family:'Times New Roman';">USB</span>设备以控制设备，一般不用于传送大量数据。</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>批量（</strong><strong><span style="font-family:'Times New Roman';">bulk</span></strong><strong>）</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>用于大量数据的可靠传输，如果总线上的空间不足以发送整个批量包，它会被分割成多个包传输。</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>等时（</strong><strong><span style="font-family:'Times New Roman';">isochronous</span></strong><strong>）</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>大量数据的不可靠传输，不保证数据的到达，但保证恒定的数据流，多用于数据采集。</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linux</span>中用<strong><span style="font-family:'Times New Roman';">struct usb_host_endpoint</span></strong>来描述<span style="font-family:'Times New Roman';">USB</span>端点，每个<span style="font-family:'Times New Roman';">usb_host_endpoint</span>中包含一个<strong><span style="font-family:'Times New Roman';">struct usb_endpoint_descriptor</span></strong>结构体，当中包含该端点的信息以及设备自定义的各种信息，这些信息包括：</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong><span style="font-family:'Times New Roman';">bEndpointAddress</span></strong><strong>（</strong><strong><span style="font-family:'Times New Roman';">b for byte</span></strong><strong>）</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8</span>位端点地址，其地址还隐藏了端点方向的信息（之前说过，端点是单向的），可以用掩码<span style="font-family:'Times New Roman';">USB_DIR_OUT</span>和<span style="font-family:'Times New Roman';">USB_DIR_IN</span>来确定。</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>bmAttributes</strong></span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>端点的类型，结合<span style="font-family:'Times New Roman';">USB_ENDPOINT_XFERTYPE_MASK</span>可以确定端点是<span style="font-family:'Times New Roman';">USB_ENDPOINT_XFER_ISOC</span>（等时）、<span style="font-family:'Times New Roman';">USB_ENDPOINT_XFER_BULK</span>（批量）还是<span style="font-family:'Times New Roman';">USB_ENDPOINT_XFER_INT</span>（中断）。</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>wMaxPacketSize</strong></span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>端点一次处理的最大字节数。发送的<span style="font-family:'Times New Roman';">BULK</span>包可以大于这个数值，但会被分割传送。</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>bInterval</strong></span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>如果端点是中断类型，该值是端点的间隔设置，以毫秒为单位。</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在逻辑上，一个<span style="font-family:'Times New Roman';">USB</span>设备的功能划分是通过接口来完成的。比如说一个<span style="font-family:'Times New Roman';">USB</span>扬声器，可能会包括有两个接口：一个用于键盘控制，另外一个用于音频流传输。而事实上，这种设备需要用到不同的两个驱动程序来操作，一个控制键盘，一个控制音频流。但也有例外，比如蓝牙设备，要求有两个接口，第一用于<span style="font-family:'Times New Roman';">ACL</span>跟<span style="font-family:'Times New Roman';">EVENT</span>的传输，另外一个用于<span style="font-family:'Times New Roman';">SCO</span>链路，但两者通过一个驱动控制。在<span style="font-family:'Times New Roman';">Linux</span>上，接口使用<strong><span style="font-family:'Times New Roman';">struct usb_interface</span></strong>来描述，以下是该结构体中比较重要的字段：</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong><span style="font-family:'Times New Roman';">struct usb_host_interface *altsetting</span></strong>（注意不是<span style="font-family:'Times New Roman';">usb_interface</span>）</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>其实据我理解，他应该是每个接口的设置，虽然名字上有点奇怪。该字段是一个设置的数组（一个接口可以有多个设置），每个<span style="font-family:'Times New Roman';">usb_host_interface</span>都包含一套由<span style="font-family:'Times New Roman';">struct usb_host_endpoint</span>定义的端点配置。但这些配置次序是不定的。</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>unsigned num_altstting</strong></span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>可选设置的数量，即<span style="font-family:'Times New Roman';">altsetting</span>所指数组的元素个数。</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>struct usb_host_interface *cur_altsetting</strong></span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当前活动的设置，指向<span style="font-family:'Times New Roman';">altsetting</span>数组中的一个。</span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>int minor</strong></span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当捆绑到该接口的<span style="font-family:'Times New Roman';">USB</span>驱动程序使用<span style="font-family:'Times New Roman';">USB</span>主设备号时，<span style="font-family:'Times New Roman';">USB core</span>分配的次设备号。仅在成功调用<span style="font-family:'Times New Roman';">usb_register_dev</span>之后才有效。<span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>除了它可以用<span style="font-family:'Times New Roman';">struct usb_host_config</span>来描述之外，到现在为止，我对配置的了解不多。而整个<span style="font-family:'Times New Roman';">USB</span>设备则可以用<span style="font-family:'Times New Roman';">struct usb_device</span>来描述，但基本上只会用它来初始化函数的接口，真正用到的应该是我们之前所提到的自定义的一个结构体。</span></span>
   </div> 
   <h4><span style="color:#009900;">Linux USB<span style="font-family:'宋体';">驱动框架分析（二）</span></span></h4> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;好，了解过</span>USB<span style="font-family:'宋体';">一些规范细节之后，我们现在来看看</span>Linux<span style="font-family:'宋体';">的驱动框架。事实上，</span>Linux<span style="font-family:'宋体';">的设备驱动，特别是这种</span>hotplug<span style="font-family:'宋体';">的</span>USB<span style="font-family:'宋体';">设备驱动，会被编译成模块，然后在需要时挂在到内核。要写一个</span>Linux<span style="font-family:'宋体';">的模块并不复杂，以一个</span>helloworld<span style="font-family:'宋体';">为例：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">#include</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">#include</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">MODULE_LICENSE(“GPL”);</span></strong>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">static int hello_init(void)</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">{</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; printk(KERN_ALERT “Hello World!\n”);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; return 0;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">static int hello_exit(void)</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">{</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; printk(KERN_ALERT “GOODBYE!\n”);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">module_init(hello_init);</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>module_exit(hello_exit)</strong><strong>;</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;这个简单的程序告诉大家应该怎么写一个模块，</span>MODULE_LICENSE<span style="font-family:'宋体';">告诉内核该模块的版权信息，很多情况下，用</span>GPL<span style="font-family:'宋体';">或者</span>BSD<span style="font-family:'宋体';">，或者两个，因为一个私有模块一般很难得到社区的帮助。</span>module_init<span style="font-family:'宋体';">和</span>module_exit<span style="font-family:'宋体';">用于向内核注册模块的初始化函数和模块推出函数。如程序所示，初始化函数是</span>hello_init<span style="font-family:'宋体';">，而退出函数是</span>hello_exit<span style="font-family:'宋体';">。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;另外，要编译一个模块通常还需要用到内核源码树中的</span>makefile<span style="font-family:'宋体';">，所以模块的</span>Makefile<span style="font-family:'宋体';">可以写成：</span></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">ifneq ($(KERNELRELEASE),)</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">obj-m:= hello.o#usb-dongle.o</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">else</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">KDIR:= /usr/src/linux-headers-$(shell uname -r)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">BDIR:= $(shell pwd)</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">default:</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; $(MAKE) -C $(KDIR) M=$(PWD) modules</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">.PHONY: clean</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">clean:</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; make -C $(KDIR) M=$(BDIR) clean</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">endif</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;可以用</span>insmod<span style="font-family:'宋体';">跟</span>rmmod<span style="font-family:'宋体';">来验证模块的挂在跟卸载，但必须用</span>root<span style="font-family:'宋体';">的身份登陆命令行，用普通用户加</span>su<span style="font-family:'宋体';">或者</span>sudo<span style="font-family:'宋体';">在</span>Ubuntu<span style="font-family:'宋体';">上的测试是不行的。</span></span></span>
   </div> 
   <h4><span style="color:#009900;">Linux USB<span style="font-family:'宋体';">驱动框架分析（三）</span></span></h4> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;下面分析一下</span>usb-skeleton<span style="font-family:'宋体';">的源码。这个范例程序可以在</span>linux-2.6.17/drivers/usb<span style="font-family:'宋体';">下找到，其他版本的内核程序源码可能有所不同，但相差不大。大家可以先找到源码看一看，先有个整体印象。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;之前已经提到，模块先要向内核注册初始化跟销毁函数：</span></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">static int __init usb_skel_init(void)</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">{</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; int result;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; /* register this driver with the USB subsystem */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; result = usb_register(&amp;skel_driver);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; if (result)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err("usb_register failed. Error number %d", result);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; return result;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">static void __exit usb_skel_exit(void)</span></strong>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">{</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; /* deregister this driver with the USB subsystem */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; usb_deregister(&amp;skel_driver);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">module_init (usb_skel_init);</span></strong>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">module_exit (usb_skel_exit);</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>MODULE_LICENSE("GPL");</strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;从代码开来，这个</span>init<span style="font-family:'宋体';">跟</span>exit<span style="font-family:'宋体';">函数的作用只是用来注册驱动程序，这个描述驱动程序的结构体是系统定义的标准结构</span>struct usb_driver,<span style="font-family:'宋体';">注册和注销的方法很简单，</span><strong>usb_register</strong><strong><span style="font-family:'宋体';">（</span></strong><strong>struct *usb_driver</strong><strong><span style="font-family:'宋体';">）</span></strong><strong>, usb_deregister</strong><strong><span style="font-family:'宋体';">（</span></strong><strong>struct *usb_driver</strong><span style="font-family:'宋体';"><strong>）</strong>。那这个结构体需要做些什么呢？他要向系统提供几个函数入口，跟驱动的名字：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>static struct usb_driver skel_driver</strong>&nbsp;= {</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .name =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "skeleton",</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .probe = &nbsp;&nbsp;&nbsp;&nbsp;skel_probe,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .disconnect = skel_disconnect,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .id_table =&nbsp;&nbsp; &nbsp;skel_table,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">};</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;从代码看来，</span>usb_driver<span style="font-family:'宋体';">需要初始化四个东西：模块的名字</span>skeleton<span style="font-family:'宋体';">，</span>probe<span style="font-family:'宋体';">函数</span>skel_probe,disconnect<span style="font-family:'宋体';">函数</span>skel_disconnect,<span style="font-family:'宋体';">以及</span>id_table<span style="font-family:'宋体';">。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;在解释</span>skel_driver<span style="font-family:'宋体';">各个成员之前，我们先来看看另外一个结构体。这个结构体的名字有开发人员自定义，它描述的是该驱动拥有的所有资源及状态：</span></span></span>
   </div> 
   <div>
    <span style="font-family:'Times New Roman';"><span style="color:#009900;"><span style="font-size:medium;"><strong>struct usb_skel</strong>&nbsp;{</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct usb_device *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; udev;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the usb device for this device */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct usb_interface *&nbsp;&nbsp; interface;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;/* the interface for this device */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct semaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; limit_sem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;/* limiting the number of writes in progress */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned char *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulk_in_buffer;&nbsp;&nbsp;&nbsp; &nbsp;/* the buffer to receive data */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulk_in_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;/* the size of the receive buffer */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; __u8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bulk_in_endpointAddr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the address of the bulk in endpoint */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; __u8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;bulk_out_endpointAddr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* the address of the bulk out endpoint */</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; struct kref&nbsp;&nbsp; kref;</span>
   </div> 
   <div>
    <span style="color:#009900;font-family:'Times New Roman';font-size:medium;">};</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;我们先来对这个</span>usb_skel<span style="font-family:'宋体';">作个简单分析，他拥有一个描述</span>usb<span style="font-family:'宋体';">设备的结构体</span>udev<span style="font-family:'宋体';">，一个接口</span>interface<span style="font-family:'宋体';">，用于并发访问控制的</span>semaphore(<span style="font-family:'宋体';">信号量</span>) limit_sem<span style="font-family:'宋体';">，用于接收数据的缓冲</span>bulk_in_buffer<span style="font-family:'宋体';">及其尺寸</span>bulk_in_size<span style="font-family:'宋体';">，然后是批量输入输出端口地址</span>bulk_in_endpointAddr<span style="font-family:'宋体';">、</span>bulk_out_endpointAddr<span style="font-family:'宋体';">，最后是一个内核使用的引用计数器。他们的作用我们将在后面的代码中看到。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;我们再回过头来看看</span>skel_driver<span style="font-family:'宋体';">。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;<strong>n</strong></span><strong>ame</strong><span style="font-family:'宋体';">用来告诉内核模块的名字是什么，这个注册之后有系统来使用，跟我们关系不大。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong>id_table</strong><span style="font-family:'宋体';">用来告诉内核该模块支持的设备。</span>usb<span style="font-family:'宋体';">子系统通过设备的</span>production ID<span style="font-family:'宋体';">和</span>vendor ID<span style="font-family:'宋体';">的组合或者设备的</span>class<span style="font-family:'宋体';">、</span>subclass<span style="font-family:'宋体';">跟</span>protocol<span style="font-family:'宋体';">的组合来识别设备，并调用相关的驱动程序作处理。我们可以看看这个</span>id_table<span style="font-family:'宋体';">到底是什么东西：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* Define these values to match your devices */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">#define USB_SKEL_VENDOR_ID&nbsp; 0xfff0</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">#define USB_SKEL_PRODUCT_ID 0xfff0</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* table of devices that work with this driver */</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>static struct usb_device_id skel_table []</strong>&nbsp;= {</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; { }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Terminating entry */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">};</span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">MODULE_DEVICE_TABLE (usb, skel_table);&nbsp;</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;">&nbsp;&nbsp;&nbsp; MODULE_DEVICE_TABLE<span style="font-family:'宋体';">的第一个参数是设备的类型，如果是</span>USB<span style="font-family:'宋体';">设备，那自然是</span>usb<span style="font-family:'宋体';">（如果是</span>PCI<span style="font-family:'宋体';">设备，那将是</span>pci<span style="font-family:'宋体';">，这两个子系统用同一个宏来注册所支持的设备。这涉及</span>PCI<span style="font-family:'宋体';">设备的驱动了，在此先不深究）。后面一个参数是设备表，这个设备表的最后一个元素是空的，用于标识结束。代码定义了</span>USB_SKEL_VENDOR_ID<span style="font-family:'宋体';">是</span>0xfff0<span style="font-family:'宋体';">，</span>USB_SKEL_PRODUCT_ID<span style="font-family:'宋体';">是</span>0xfff0<span style="font-family:'宋体';">，也就是说，当有一个设备接到集线器时，</span>usb<span style="font-family:'宋体';">子系统就会检查这个设备的</span>vendor ID<span style="font-family:'宋体';">和</span>product ID<span style="font-family:'宋体';">，如果它们的值是</span>0xfff0<span style="font-family:'宋体';">时，那么子系统就会调用这个</span>skeleton<span style="font-family:'宋体';">模块作为设备的驱动。</span></span></span>
   </div> 
   <h4><span style="color:#009900;">Linux USB<span style="font-family:'宋体';">驱动框架分析（四）</span></span></h4> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>probe<span style="font-family:'宋体';">是</span>usb<span style="font-family:'宋体';">子系统自动调用的一个函数，有</span>USB<span style="font-family:'宋体';">设备接到硬件集线器时，</span>usb<span style="font-family:'宋体';">子系统会根据</span>production ID<span style="font-family:'宋体';">和</span>vendor ID<span style="font-family:'宋体';">的组合或者设备的</span>class<span style="font-family:'宋体';">、</span>subclass<span style="font-family:'宋体';">跟</span>protocol<span style="font-family:'宋体';">的组合来识别设备调用相应驱动程序的</span>probe<span style="font-family:'宋体';">（探测）函数，对于</span>skeleton<span style="font-family:'宋体';">来说，就是</span>skel_probe<span style="font-family:'宋体';">。系统会传递给探测函数一个</span>usb_interface *<span style="font-family:'宋体';">跟一个</span>struct usb_device_id *<span style="font-family:'宋体';">作为参数。他们分别是该</span>USB<span style="font-family:'宋体';">设备的接口描述（一般会是该设备的第</span>0<span style="font-family:'宋体';">号接口，该接口的默认设置也是第</span>0<span style="font-family:'宋体';">号设置）跟它的设备</span>ID<span style="font-family:'宋体';">描述（包括</span>Vendor ID<span style="font-family:'宋体';">、</span>Production ID<span style="font-family:'宋体';">等）。</span>probe<span style="font-family:'宋体';">函数比较长，我们分段来分析这个函数：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">dev-&gt;interface = interface;</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;在初始化了一些资源之后，可以看到第一个关键的函数调用</span>——interface_to_usbdev<span style="font-family:'宋体';">。他同</span>uo<span style="font-family:'宋体';">一个</span>usb_interface<span style="font-family:'宋体';">来得到该接口所在设备的设备描述结构。本来，要得到一个</span>usb_device<span style="font-family:'宋体';">只要用</span>interface_to_usbdev<span style="font-family:'宋体';">就够了，但因为要增加对该</span>usb_device<span style="font-family:'宋体';">的引用计数，我们应该在做一个</span>usb_get_dev<span style="font-family:'宋体';">的操作，来增加引用计数，并在释放设备时用</span>usb_put_dev<span style="font-family:'宋体';">来减少引用计数。这里要解释的是，该引用计数值是对该</span>usb_device<span style="font-family:'宋体';">的计数，并不是对本模块的计数，本模块的计数要由</span>kref<span style="font-family:'宋体';">来维护。所以，</span>probe<span style="font-family:'宋体';">一开始就有初始化</span>kref<span style="font-family:'宋体';">。事实上，</span>kref_init<span style="font-family:'宋体';">操作不单只初始化</span>kref<span style="font-family:'宋体';">，还将其置设成</span>1<span style="font-family:'宋体';">。所以在出错处理代码中有</span>kref_put<span style="font-family:'宋体';">，它把</span>kref<span style="font-family:'宋体';">的计数减</span>1<span style="font-family:'宋体';">，如果</span>kref<span style="font-family:'宋体';">计数已经为</span>0<span style="font-family:'宋体';">，那么</span>kref<span style="font-family:'宋体';">会被释放。</span>kref_put<span style="font-family:'宋体';">的第二个参数是一个函数指针，指向一个清理函数。注意，该指针不能为空，或者</span>kfree<span style="font-family:'宋体';">。该函数会在最后一个对</span>kref<span style="font-family:'宋体';">的引用释放时被调用（如果我的理解不准确，请指正）。下面是内核源码中的一段注释及代码：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/**</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* kref_put - decrement refcount for object.</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* @kref: object.</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* @release: pointer to the function that will clean up the object when the</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;*&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; last reference to the object is released.</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;*&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; This pointer is required, and it is not acceptable to pass kfree</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;*&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; in as this function.</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;*</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* Decrement the refcount, and if 0, call release().</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* Return 1 if the object was removed, otherwise return 0.&nbsp; Beware, if this</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* function returns 0, you still can not count on the kref from remaining in</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* memory.&nbsp; Only use the return value if you want to see if the kref is now</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;* gone, not present.</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;*/</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>int kref_put</strong>(struct kref *kref, void (*release)(struct kref *kref))</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">{</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(release == NULL);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; WARN_ON(release == (void (*)(struct kref *))kfree);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;/*</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* if current count is one, we are the last user and can release object</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;* right now, avoiding an atomic operation on 'refcount'</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*/</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; if ((atomic_read(&amp;kref-&gt;refcount) == 1) ||</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (atomic_dec_and_test(&amp;kref-&gt;refcount))) {</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; release(kref);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; }</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; return 0;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;当我们执行打开操作时，我们要增加</span>kref<span style="font-family:'宋体';">的计数，我们可以用</span>kref_get<span style="font-family:'宋体';">，来完成。所有对</span>struct kref<span style="font-family:'宋体';">的操作都有内核代码确保其原子性。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;得到了该</span>usb_device<span style="font-family:'宋体';">之后，我们要对我们自定义的</span>usb_skel<span style="font-family:'宋体';">各个状态跟资源作初始化。这部分工作的任务主要是向</span>usb_skel<span style="font-family:'宋体';">注册该</span>usb<span style="font-family:'宋体';">设备的端点。这里可能要补充以下一些关于</span>usb_interface_descriptor<span style="font-family:'宋体';">的知识，但因为内核源码对该结构体的注释不多，所以只能靠个人猜测。在一个</span>usb_host_interface<span style="font-family:'宋体';">结构里面有一个</span>usb_interface_descriptor<span style="font-family:'宋体';">叫做</span>desc<span style="font-family:'宋体';">的成员，他应该是用于描述该</span>interface<span style="font-family:'宋体';">的一些属性，其中</span>bNumEndpoints<span style="font-family:'宋体';">是一个</span>8<span style="font-family:'宋体';">位（</span>b for byte<span style="font-family:'宋体';">）的数字，他代表了该接口的端点数。</span>probe<span style="font-family:'宋体';">然后遍历所有的端点，检查他们的类型跟方向，注册到</span>usb_skel<span style="font-family:'宋体';">中。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; /* set up the endpoint information */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; /* use only the first bulk-in and bulk-out endpoints */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; iface_desc = interface-&gt;cur_altsetting;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endpoint = &amp;iface_desc-&gt;endpoint[i].desc;</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<strong>&nbsp;</strong><strong>!dev-&gt;bulk_in_endpointAddr &amp;&amp;</strong></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;((endpoint-&gt;bEndpointAddress &amp; USB_ENDPOINT_DIR_MASK) = = USB_DIR_IN) &amp;&amp;</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) = = USB_ENDPOINT_XFER_BULK))</strong><strong>&nbsp;</strong>{</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we found a bulk in endpoint */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;bulk_in_size = buffer_size;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!dev-&gt;bulk_in_buffer) {</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err("Could not allocate bulk_in_buffer");</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto error;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<strong>!dev-&gt;bulk_out_endpointAddr &amp;&amp;</strong></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ((endpoint-&gt;bEndpointAddress &amp; USB_ENDPOINT_DIR_MASK)= =USB_DIR_OUT) &amp;&amp;</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)= = USB_ENDPOINT_XFER_BULK))</strong>&nbsp;{</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we found a bulk out endpoint */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; }</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; if (!(dev-&gt;bulk_in_endpointAddr &amp;&amp; dev-&gt;bulk_out_endpointAddr)) {</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err("Could not find both bulk-in and bulk-out endpoints");</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto error;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; }</span>
   </div> 
   <h4><span style="color:#009900;">Linux USB<span style="font-family:'宋体';">驱动框架分析（五）</span></span></h4> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;接下来的工作是向系统注册一些以后会用的的信息。首先我们来说明一下</span>usb_set_intfdata()<span style="font-family:'宋体';">，他向内核注册一个</span>data<span style="font-family:'宋体';">，这个</span>data<span style="font-family:'宋体';">的结构可以是任意的，这段程序向内核注册了一个</span>usb_skel<span style="font-family:'宋体';">结构，就是我们刚刚看到的被初始化的那个，这个</span>data<span style="font-family:'宋体';">可以在以后用</span>usb_get_intfdata<span style="font-family:'宋体';">来得到。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">usb_set_intfdata(interface, dev);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">retval = usb_register_dev(interface, &amp;skel_class);</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;然后我们向这个</span>interface<span style="font-family:'宋体';">注册一个</span>skel_class<span style="font-family:'宋体';">结构。这个结构又是什么？我们就来看看这到底是个什么东西：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>static struct usb_class_driver skel_class</strong>&nbsp;= {</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .name =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "skel%d",</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .fops =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;skel_fops,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .minor_base = USB_SKEL_MINOR_BASE,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">};</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;它其实是一个系统定义的结构，里面包含了一名字、一个文件操作结构体还有一个次设备号的基准值。<strong>事实上它才是定义</strong></span><strong>&nbsp;</strong><strong><span style="font-family:'宋体';">真正完成对设备</span></strong><strong>IO</strong><span style="font-family:'宋体';"><strong>操作的函数。</strong>所以他的核心内容应该是</span>skel_fops<span style="font-family:'宋体';">。这里补充一些我个人的估计：因为</span>usb<span style="font-family:'宋体';">设备可以有多个</span>interface<span style="font-family:'宋体';">，每个</span>interface<span style="font-family:'宋体';">所定义的</span>IO<span style="font-family:'宋体';">操作可能不一样，所以向系统注册的</span>usb_class_driver<span style="font-family:'宋体';">要求注册到某一个</span>interface<span style="font-family:'宋体';">，而不是</span>device<span style="font-family:'宋体';">，因此，</span>usb_register_dev<span style="font-family:'宋体';">的第一个参数才是</span>interface<span style="font-family:'宋体';">，而第二个参数就是某一个</span>usb_class_driver<span style="font-family:'宋体';">。通常情况下，</span>linux<span style="font-family:'宋体';">系统用主设备号来识别某类设备的驱动程序，用次设备号管理识别具体的设备，驱动程序可以依照次设备号来区分不同的设备，所以，这里的次设备好其实是用来管理不同的</span>interface<span style="font-family:'宋体';">的，但由于这个范例只有一个</span>interface<span style="font-family:'宋体';">，在代码上无法求证这个猜想。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><strong>static struct file_operations skel_fops</strong>&nbsp;= {</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .owner = THIS_MODULE,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .read =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skel_read,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .write = &nbsp;&nbsp;skel_write,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .open =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skel_open,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; .release =&nbsp;&nbsp;&nbsp; skel_release,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">};</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;这个文件操作结构中定义了对设备的读写、打开、释放（</span>USB<span style="font-family:'宋体';">设备通常使用这个术语</span>release<span style="font-family:'宋体';">）。他们都是函数指针，分别指向</span>skel_read<span style="font-family:'宋体';">、</span>skel_write<span style="font-family:'宋体';">、</span>skel_open<span style="font-family:'宋体';">、</span>skel_release<span style="font-family:'宋体';">这四个函数，这四个函数应该有开发人员自己实现。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;当设备被拔出集线器时，</span>usb<span style="font-family:'宋体';">子系统会自动地调用</span>disconnect<span style="font-family:'宋体';">，他做的事情不多，最重要的是注销</span>class_driver<span style="font-family:'宋体';">（交还次设备号）和</span>interface<span style="font-family:'宋体';">的</span>data:</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">dev = usb_get_intfdata(interface);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">usb_set_intfdata(interface, NULL);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* give back our minor */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">usb_deregister_dev(interface, &amp;skel_class);</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;然后他会用</span>kref_put(&amp;dev-&gt;kref, skel_delete)<span style="font-family:'宋体';">进行清理，</span>kref_put<span style="font-family:'宋体';">的细节参见前文。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们已经分析完</span>usb<span style="font-family:'宋体';">子系统要求的各个主要操作，下一部分我们在讨论一下对</span>USB<span style="font-family:'宋体';">设备的</span>IO<span style="font-family:'宋体';">操作。</span></span></span>
   </div> 
   <h4><span style="color:#009900;">Linux USB<span style="font-family:'宋体';">驱动框架分析（六）</span></span></h4> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;说到</span>usb<span style="font-family:'宋体';">子系统的</span>IO<span style="font-family:'宋体';">操作，不得不说</span>usb request block<span style="font-family:'宋体';">，简称</span>urb<span style="font-family:'宋体';">。事实上，可以打一个这样的比喻，</span>usb<span style="font-family:'宋体';">总线就像一条高速公路，货物、人流之类的可以看成是系统与设备交互的数据，而</span>urb<span style="font-family:'宋体';">就可以看成是汽车。在一开始对</span>USB<span style="font-family:'宋体';">规范细节的介绍，我们就说过</span>USB<span style="font-family:'宋体';">的</span>endpoint<span style="font-family:'宋体';">有</span>4<span style="font-family:'宋体';">种不同类型，也就是说能在这条高速公路上流动的数据就有四种。但是这对汽车是没有要求的，所以</span>urb<span style="font-family:'宋体';">可以运载四种数据，不过你要先告诉司机你要运什么，目的地是什么。我们现在就看看</span>struct urb<span style="font-family:'宋体';">的具体内容。它的内容很多，为了不让我的理解误导各位，大家最好还是看一看内核源码的注释，具体内容参见源码树下</span>include/linux/usb.h<span style="font-family:'宋体';">。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;在这里我们重点介绍程序中出现的几个关键字段：</span></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">struct usb_device &nbsp;*dev</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>urb<span style="font-family:'宋体';">所发送的目标设备。</span></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">unsigned int pipe</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;一个管道号码，该管道记录了目标设备的端点以及管道的类型。每个管道只有一种类型和一个方向，它与他的目标设备的端点相对应，我们可以通过以下几个函数来获得管道号并设置管道类型：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_sndctrlpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个控制</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_rcvctrlpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个控制</span>IN<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_sndbulkpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个批量</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_rcvbulkpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个批量</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_sndintpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个中断</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_rcvintpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个中断</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_sndisocpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个等时</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp; unsigned int usb_rcvisocpipe(struct usb_device *dev, unsigned int endpoint)</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">把指定</span>USB<span style="font-family:'宋体';">设备的指定端点设置为一个等时</span>OUT<span style="font-family:'宋体';">端点。</span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">unsigned int transfer_flags</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;当不使用</span>DMA<span style="font-family:'宋体';">时，应该</span>transfer_flags |= URB_NO_TRANSFER_DMA_MAP<span style="font-family:'宋体';">（按照代码的理解，希望没有错）。</span></span></span>
   </div> 
   <div>
    <strong><span style="color:#009900;font-size:medium;">int status</span></strong>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;当一个</span>urb<span style="font-family:'宋体';">把数据送到设备时，这个</span>urb<span style="font-family:'宋体';">会由系统返回给驱动程序，并调用驱动程序的</span>urb<span style="font-family:'宋体';">完成回调函数处理。这时，</span>status<span style="font-family:'宋体';">记录了这次数据传输的有关状态，例如传送成功与否。成功的话会是</span>0<span style="font-family:'宋体';">。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;要能够运货当然首先要有车，所以第一步当然要创建</span>urb<span style="font-family:'宋体';">：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>struct urb *usb_alloc_urb(int isoc_packets, int mem_flags);</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;第一个参数是等时包的数量，如果不是乘载等时包，应该为</span>0<span style="font-family:'宋体';">，第二个参数与</span>kmalloc<span style="font-family:'宋体';">的标志相同。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;要释放一个</span>urb<span style="font-family:'宋体';">可以用：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>void usb_free_urb(struct urb *urb);</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;要承载数据，还要告诉司机目的地信息跟要运的货物，对于不同的数据，系统提供了不同的函数，对于中断</span>urb<span style="font-family:'宋体';">，我们用</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>void usb_fill_int_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>void *transfer_buffer, int buffer_length,</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>usb_complete_t complete, void *context, int interval);</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;这里要解释一下，</span>transfer_buffer<span style="font-family:'宋体';">是一个要送</span>/<span style="font-family:'宋体';">收的数据的缓冲，</span>buffer_length<span style="font-family:'宋体';">是它的长度，</span>complete<span style="font-family:'宋体';">是</span>urb<span style="font-family:'宋体';">完成回调函数的入口，</span>context<span style="font-family:'宋体';">由用户定义，可能会在回调函数中使用的数据，</span>interval<span style="font-family:'宋体';">就是</span>urb<span style="font-family:'宋体';">被调度的间隔。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;对于批量</span>urb<span style="font-family:'宋体';">和控制</span>urb<span style="font-family:'宋体';">，我们用</span>:</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>void usb_fill_bulk_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp; void *transfer_buffer, int buffer_length, usb_complete_t complete,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp; void *context);</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>void usb_fill_bulk_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,</span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char* setup_packet,void *transfer_buffer,</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>int buffer_length, usb_complete_t complete,void *context);</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;控制包有一个特殊参数</span>setup_packet<span style="font-family:'宋体';">，它指向即将被发送到端点的设置数据报的数据。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;<strong>对于等时</strong></span><strong>urb</strong><strong><span style="font-family:'宋体';">，系统没有专门的</span></strong><strong>fill</strong><strong><span style="font-family:'宋体';">函数，只能对各</span></strong><strong>urb</strong><strong><span style="font-family:'宋体';">字段显示赋值。</span></strong></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;有了汽车，有了司机，下一步就是要开始运货了，我们可以用下面的函数来提交</span>urb</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>int usb_submit_urb(struct urb *urb, int mem_flags);</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>mem_flags<span style="font-family:'宋体';">有几种：</span>GFP_ATOMIC<span style="font-family:'宋体';">、</span>GFP_NOIO<span style="font-family:'宋体';">、</span>GFP_KERNEL<span style="font-family:'宋体';">，通常在中断上下文环境我们会用</span>GFP_ATOMIC<span style="font-family:'宋体';">。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;当我们的卡车运货之后，系统会把它调回来，并调用</span>urb<span style="font-family:'宋体';">完成回调函数，并把这辆车作为函数传递给驱动程序。我们应该在回调函数里面检查</span>status<span style="font-family:'宋体';">字段，以确定数据的成功传输与否。下面是用</span>urb<span style="font-family:'宋体';">来传送数据的细节。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* initialize the urb properly */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">usb_fill_bulk_urb(urb, dev-&gt;udev,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp; &nbsp; buf, writesize, skel_write_bulk_callback, dev);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* send the data out the bulk port */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">retval = usb_submit_urb(urb, GFP_KERNEL);</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;这里</span>skel_write_bulk_callback<span style="font-family:'宋体';">就是一个完成回调函数，而他做的主要事情就是检查数据传输状态和释放</span>urb<span style="font-family:'宋体';">：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">dev = (struct usb_skel *)urb-&gt;context;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* sync/async unlink faults aren't errors */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">if (<strong>urb-&gt;status &amp;&amp; !(urb-&gt;status = = -ENOENT || urb-&gt;status == -ECONNRESET || urb-&gt;status = = -ESHUTDOWN)</strong>) {</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb-&gt;status);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* free up our allocated buffer */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">usb_buffer_free(urb-&gt;dev, urb-&gt;transfer_buffer_length,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; urb-&gt;transfer_buffer, urb-&gt;transfer_dma);</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;事实上，如果数据的量不大，那么可以不一定用卡车来运货，系统还提供了一种不用</span>urb<span style="font-family:'宋体';">的传输方式，而</span>usb-skeleton<span style="font-family:'宋体';">的读操作正是采用这种方式实现：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* do a blocking bulk read to get data from the device */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">retval = usb_bulk_msg(dev-&gt;udev,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;bulk_in_endpointAddr),</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>dev-&gt;bulk_in_buffer,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;min(dev-&gt;bulk_in_size, count),</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&amp;bytes_read, 10000);</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">/* if the read was successful, copy the data to userspace */</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">if (!retval) {</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (copy_to_user(buffer, dev-&gt;bulk_in_buffer, bytes_read))</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;retval = -EFAULT;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;retval = bytes_read;</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">}</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;程序使用了</span>usb_bulk_msg<span style="font-family:'宋体';">来传送数据，它的原型如下：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;</span>int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,void *data,</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span>int len, int *actual length, int timeout)</span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;这个函数会阻塞等待数据传输完成或者等到超时，</span>data<span style="font-family:'宋体';">是输入</span>/<span style="font-family:'宋体';">输出缓冲，</span>len<span style="font-family:'宋体';">是它的大小，</span>actual length<span style="font-family:'宋体';">是实际传送的数据大小，</span>timeout<span style="font-family:'宋体';">是阻塞超时。</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;对于控制数据，系统提供了另外一个函数，他的原型是：</span></span></span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int usb_contrl_msg(struct usb_device *dev, unsigned int pipe, __u8 request,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;__u8 requesttype, __u16 value, __u16 index, void *data,</span>
   </div> 
   <div>
    <span style="color:#009900;font-size:medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;__u16 size, int timeout);</span>
   </div> 
   <div>
    <span style="color:#009900;"><span style="font-size:medium;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;r</span>equest<span style="font-family:'宋体';">是控制消息的</span>USB<span style="font-family:'宋体';">请求值、</span>requesttype<span style="font-family:'宋体';">是控制消息的</span>USB<span style="font-family:'宋体';">请求类型，</span>value<span style="font-family:'宋体';">是控制消息的</span>USB<span style="font-family:'宋体';">消息值，</span>index<span style="font-family:'宋体';">是控制消息的</span>USB<span style="font-family:'宋体';">消息索引。具体是什么，暂时不是很清楚，希望大家提供说明。</span></span></span>
   </div> 
   <div>
    <span style="font-size:medium;"><span style="color:#009900;"><span style="font-family:'宋体';">&nbsp;&nbsp;&nbsp;&nbsp;至此，</span>Linux<span style="font-family:'宋体';">下的</span>USB<span style="font-family:'宋体';">驱动框架分析基本完成了。</span></span></span>
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
