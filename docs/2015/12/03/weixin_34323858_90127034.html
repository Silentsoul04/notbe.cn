<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>协议中UART的两种模式 【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://wjf88223.blog.163.com/blog/static/3516800120104179327286/    ^^……    协议栈中UART有两种模式:1、中断2、DMA    对于这两种模式具体运用在哪一步,纠结了很久.通过UART配置结构:typed...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/12/03/weixin_34323858_90127034.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">协议中UART的两种模式 【转】</h1>
    <p class="post-meta">Dec 3, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://wjf88223.blog.163.com/blog/static/3516800120104179327286/" rel="nofollow">http://wjf88223.blog.163.com/blog/static/3516800120104179327286/</a></p> 
   <p><img src="https://yqfile.alicdn.com/img_9e7321af6266799bc32f1e5bf357f1d5.gif" alt="协议中UART的两种模式 - 小峰 - happy~">^<strong><span style="color:#339966;">^……</span></strong></p> 
   <p><strong><span style="color:#339966;">协议栈中UART有两种模式:<br></span><span style="color:#ff0000;">1、中断<br>2、DMA</span></strong></p> 
   <p><strong><span style="color:#339966;">对于这两种模式具体运用在哪一步,纠结了很久.</span></strong><strong><span style="color:#339966;">通过UART配置结构:<br></span><span style="color:#3366ff;">typedef struct<br>{<br>&nbsp; uint8 *rxBuf;<br>&nbsp; uint8 rxHead;<br>&nbsp; uint8 rxTail;<br>&nbsp; uint8 rxMax;<br>&nbsp; uint8 rxCnt;<br>&nbsp; uint8 rxTick;<br>&nbsp; uint8 rxHigh;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; uint8 *txBuf;<br>#if HAL_UART_BIG_TX_BUF<br>&nbsp; uint16 txHead;<br>&nbsp; uint16 txTail;<br>&nbsp; uint16 txMax;<br>&nbsp; uint16 txCnt;<br>#else<br>&nbsp; uint8 txHead;<br>&nbsp; uint8 txTail;<br>&nbsp; uint8 txMax;<br>&nbsp; uint8 txCnt;<br>#endif<br>&nbsp; uint8 txTick;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; uint8 flag;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; halUARTCBack_t rxCB;<br>} uartCfg_t;</span></strong></p> 
   <p><strong><span style="color:#339966;">可以看到协议栈为串口收发分别配置了一块内存空间rxBuf和txBuf,具体在HalUARTOpen()里配置.<br>而中断与DMA这两种模式具体就运用于&nbsp;<span style="text-decoration:underline;">数据在串口缓存U0_1DBUF与rxBuf/txBuf之间传送</span>&nbsp;的过程.</span></strong></p> 
   <p><strong><span style="color:#ff6600;">串口接收DMA模式:(data) —&gt; U0DBUF —(DMA)—&gt; rxBuf —&gt; HalUARTRead()读取rxBuf数据进行处理<br>串口接收中断模式:(data) —&gt; U0DBUF —(中断)—&gt; rxBuf —&gt; HalUARTRead()读取rxBuf数据进行处理</span></strong></p> 
   <p><br><strong><span style="color:#ff6600;">串口发送DMA模式:(data) &lt;— U0DBUF &lt;—(DMA)— txBuf<br>串口发送中断模式:(data) &lt;— U0DBUF &lt;—(中断)— txBuf</span></strong></p> 
   <p><strong><span style="color:#ff0000;"><img src="https://yqfile.alicdn.com/img_53bc2511192f387d11418c29d4552c44.gif" alt="协议中UART的两种模式 - 小峰 - happy~">我觉得这样理解好像还有问题，本身对DMA不了解,网上又几乎查不到关于协议栈有关UART_DMA模式具体</span></strong></p> 
   <p><strong><span style="color:#ff0000;">流程资料,卡在这里很久,所以打算建立个大概印象就跳出来,以后再看.<img src="https://yqfile.alicdn.com/img_76c041d35f68a5d5c5b385f1c7b0615d.gif" alt="协议中UART的两种模式 - 小峰 - happy~"></span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#339966;">先记录下中断模式吧～<br>###########################################################################</span></strong></p> 
   <p><strong><span style="color:#339966;">###########################################################################<br></span><span style="color:#0000ff;font-size:large;">1、中断模式（UART接收）</span></strong></p> 
   <p><strong><span style="color:#339966;">当1写入UxCSR.RE位时，在UART上数据接收就开始了.然后UART会在输入引脚RXDx中寻找有效起始位，并且设</span></strong><strong><span style="color:#339966;">置UxCSR.ACTIVE位为1.当检测出有效起始位时,收到的字节就传入接收寄存器,UxCSR.RX_BUTE位设置为1.该操</span></strong><strong><span style="color:#339966;">作完成时，产生接收中断。通过寄存器UxBUF提供收到的数据字节。当UxBUF读出时，UxCSR.RX_BUTE位由硬件</span></strong><strong><span style="color:#339966;">清零.当产生中断时，自然进入中断程序，看下UART0接收中断函数:</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;***************************************<br>#if HAL_UART_0_ENABLE<br>HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )<br>{<br>&nbsp; cfg0-&gt;rxBuf[cfg0-&gt;rxHead] = U0DBUF;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; if ( cfg0-&gt;rxHead == cfg0-&gt;rxMax )<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; cfg0-&gt;rxHead = 0;<br>&nbsp; }<br>&nbsp; else<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; cfg0-&gt;rxHead++;<br>&nbsp; }<br>}<br>#endif</span></strong></p> 
   <p><strong><span style="color:#3366ff;">/**************************************</span></strong></p> 
   <p><strong><span style="color:#339966;">中断函数完成了把U0DBUF里一字节的数据传送到rxBuf[ ]存储空间去.这里rxHead是指向rxBuf[ ]的指针，看单词像是指在数组的头，其实应理解为rxBuf[ ]接收数据的个数(以字节</span></strong><strong><span style="color:#339966;">为单位).rxMax是rxBuf[ ]可以存储最大字节数，为128.而后面当用HalUARTRead()来读取rxBuf[ ]时，rxTail</span></strong><strong><span style="color:#339966;">应理解为rxBuf[]转移出去数据的个数(同样以字节为单位).那数据传送到rxBuf[ ]存储空间去后呢？先看下pollISR()</span></strong></p> 
   <p><strong><span style="color:#339966;">&nbsp;</span><span style="color:#3366ff;">*****************************************************************************/<br></span><span style="color:#ff0000;">//大概每200ms调用pollISR()函数.当串口UxDBUF接收到一字节数据产生中断,在中断<br>//程序中把UxDBUF中数据传送到rxbuf[ ]中(这有个坎要跨过来，pollISR()200ms才被调用一次，而不是每次</span></strong><strong><span style="color:#ff0000;">中断后都调用一次，如果串口接收的是大的数据包，则200ms内rxbuf[ ]已经接收了约48字节(这个后面分析)</span></strong><strong><span style="color:#ff0000;">，中断了48次??.当然如果串口没有接收到数据，也就是说没有发生串口接收中断，cfg应为是为空的，则</span></strong><strong><span style="color:#ff0000;">cnt=0).此后pollISR()进行轮询，主要是重置超时时间和计算rxbuf[ ]还有多少数据没有读走(即cnt).然后再</span></strong><strong><span style="color:#3366ff;"><span style="color:#ff0000;">跳回到HalUARTPoll()函数进行下一步处理.</span><br>static void pollISR( uartCfg_t *cfg )<br>{<br>&nbsp; uint8 cnt = UART_RX_AVAIL( cfg );&nbsp;</span><span style="color:#ff0000;">//计算rxBuf[]中还有多少数据没有读出(以字节为单位)</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; if ( !(cfg-&gt;flag &amp; UART_CFG_RXF) )&nbsp;<span style="color:#ff0000;">//UART_CFG_RXF:Rx flow is disabled.rx流控制未关闭<br></span>&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">// If anything received, reset the Rx idle timer.<br>&nbsp;&nbsp;&nbsp; //如果又有新的数据接收到，则重置超时时间<br></span>&nbsp;&nbsp;&nbsp; if ( cfg-&gt;rxCnt != cnt )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;rxTick = HAL_UART_RX_IDLE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;rxCnt = cnt;<br>&nbsp;&nbsp;&nbsp; }</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">/* It is necessary to stop Rx flow in advance of a full Rx buffer because<br>&nbsp;&nbsp;&nbsp;&nbsp; * bytes can keep coming while sending H/W fifo flushes.<br>&nbsp;&nbsp;&nbsp;&nbsp; */<br>&nbsp;&nbsp;&nbsp;&nbsp; //当接收数据超过安全界限的时候，通过硬件流控制停止接收数据<br></span>&nbsp;&nbsp;&nbsp; if ( cfg-&gt;rxCnt &gt;= (cfg-&gt;rxMax - SAFE_RX_MIN) )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RX_STOP_FLOW( cfg );<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}<br>#endif</span></strong></p> 
   <p><strong><span style="color:#3366ff;">/******************************************************************************<br><span style="color:#339966;">pollISR()函数主要就是设置rxTick和rxCnt，发生接收中断并且接收中断函数处理完后，这些参数都会改变.<br>pollISR()执行完成后就跳回到HalUARTPoll()中.<br>看下 HalUARTPoll()</span><br>/**************************************<br>void HalUARTPoll( void )<br>{<br>#if ( HAL_UART_0_ENABLE | HAL_UART_1_ENABLE )<br>&nbsp; static uint8 tickShdw;<br>&nbsp; uartCfg_t *cfg;<br>&nbsp; uint8 tick;</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">//---------以下设置cfg</span><br>#if HAL_UART_0_ENABLE<br>&nbsp; if ( cfg0 )&nbsp;&nbsp;</span><span style="color:#ff0000;">//当串口接收到数据时，在中断函数或DMA程序中会改变cfg0值，如果没有接收到数据，cfg0</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">为空.<br></span>&nbsp; {<br>&nbsp;&nbsp;&nbsp; cfg = cfg0;<br>&nbsp; }<br>#endif<br><span style="color:#ff0000;">//---------</span><br>#if HAL_UART_1_ENABLE<br>&nbsp; if ( cfg1 )<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; cfg = cfg1;//同上<br>&nbsp; }<br>#endif<br><span style="color:#ff0000;">//---------</span><br><span style="color:#ff0000;">&nbsp;&nbsp;<br>&nbsp; // Use the LSB of the sleep timer (ST0 must be read first anyway).<br>&nbsp; //睡眠定时器.ST0为睡眠定时器计数值的低8位</span><br>&nbsp; tick = ST0 - tickShdw;<br>&nbsp; tickShdw = ST0;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; do<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">//------------------------发送超时时间</span><br>&nbsp;&nbsp;&nbsp; if ( cfg-&gt;txTick &gt; tick )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;txTick -= tick;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;txTick = 0;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;//------------------------接收超时时间</span><br>&nbsp;&nbsp;&nbsp; if ( cfg-&gt;rxTick &gt; tick )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;rxTick -= tick;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;rxTick = 0;<br>&nbsp;&nbsp;&nbsp; }<br><span style="color:#ff0000;">&nbsp;&nbsp;&nbsp; //------------------------</span><br>#if HAL_UART_ISR<br>#if HAL_UART_DMA<br>&nbsp;&nbsp;&nbsp; if ( cfg-&gt;flag &amp; UART_CFG_DMA )<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pollDMA( cfg );&nbsp;<span style="color:#ff0000;">//pollDMA( cfg )<br></span>&nbsp;&nbsp;&nbsp; }&nbsp;<br>&nbsp;&nbsp;&nbsp; else<br>#endif<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pollISR( cfg );&nbsp;<span style="color:#ff0000;">&nbsp;//pollISR( cfg )&nbsp;&nbsp;<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>#elif HAL_UART_DMA&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; pollDMA( cfg );<br>#endif</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">/* The following logic makes continuous callbacks on any eligible flag(合法标志)<br>&nbsp;&nbsp;&nbsp;&nbsp; * until the condition corresponding to the flag is rectified.<br>&nbsp;&nbsp;&nbsp;&nbsp; * So even if new data is not received, continuous callbacks are made.<br>&nbsp;&nbsp;&nbsp;&nbsp; */<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( cfg-&gt;rxHead != cfg-&gt;rxTail )<span style="color:#ff0000;">&nbsp;//初始化时rxHead=rxTail=0，不相等，rxbuf[ ]中有数据<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8 evt;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( cfg-&gt;rxHead &gt;= (cfg-&gt;rxMax - SAFE_RX_MIN) )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evt = HAL_UART_RX_FULL;<span style="color:#ff0000;">&nbsp;//rxBuf接收[ ]满，则触发事件<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( cfg-&gt;rxHigh &amp;&amp; (cfg-&gt;rxHead &gt;= cfg-&gt;rxHigh) )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evt = HAL_UART_RX_ABOUT_FULL;<span style="color:#ff0000;">&nbsp;//rxBuf[ ]接收到预设值(默认80字节)，则触发事件<br></span>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( cfg-&gt;rxTick == 0 )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evt = HAL_UART_RX_TIMEOUT;&nbsp;&nbsp;<span style="color:#ff0000;">//RX接收事件超时，则触发事件<br></span>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; evt = 0;<br>&nbsp;&nbsp;&nbsp; }</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp; if ( evt &amp;&amp; cfg-&gt;rxCB )<span style="color:#ff0000;">&nbsp; //有事件并且有回调函数<br></span>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;rxCB( ((cfg-&gt;flag &amp; UART_CFG_U1F)!=0), evt );&nbsp;&nbsp;<span style="color:#ff0000;">//调用回调函数处理这些事件</span><br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; ………………</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; } while ( TRUE );<br>#else<br>&nbsp; return;<br>#endif<br>}</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#3366ff;">/**************************************<br></span>可以看到，初始化时rxHead=rxTail=0，如果发生接收中断，在中断服务函数中把UxDBUF中的数据传送到</span></strong><strong><span style="color:#339966;">rxbuf[ ]中(这一步也可以在DMA服务程序中完成),则rxHead与rxTail值不等(rxHead是rxBuf[ ]接收数据的个数</span></strong><strong><span style="color:#339966;">，rxTail是rxBuf[ ]转移出去数据个数)，再根据两值的差值，判断具体事件evt，最后再调用回调函数：cfg</span></strong><strong><span style="color:#339966;">-&gt;rxCB()；</span></strong><strong><span style="color:#339966;">回调函数在哪？回调函数 cfg-&gt;rxCB( ((cfg-&gt;flag &amp; UART_CFG_U1F)!=0), evt )，在cfg中有halUARTCBack_t rxCB；则肯</span></strong><strong><span style="color:#339966;">定有个地方配置cfg这个结构体，这个地方是HalUARTOpen( uint8 port, halUARTCfg_t *config )；在这个</span></strong><strong><span style="color:#339966;">函数中可以看到，结构体config的内容一项项赋给了结构体cfg，其中包括cfg-&gt;rxCB = config-</span></strong><strong><span style="color:#339966;">&gt;callBackFunc；那肯定有个地方配置config这个结构体，这个地方是SPIMgr_Init ()，这个函数有一句</span></strong><strong><span style="color:#339966;">HalUARTOpen (SPI_MGR_DEFAULT_PORT, &amp;uartConfig)，*config与&amp;uartConfig是同一halUARTCfg_t类型结构</span></strong><strong><span style="color:#339966;">体，而且SPIMgr_Init ()函数中对uartConfig进行了定义，如下：</span></strong></p> 
   <p><strong><span style="color:#339966;">&nbsp;&nbsp;</span><span style="color:#ff6600;">/* UART Configuration */<br>&nbsp; uartConfig.configured&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = TRUE;<br>&nbsp; uartConfig.baudRate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPI_MGR_DEFAULT_BAUDRATE;<br>&nbsp; uartConfig.flowControl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;//SPI_MGR_DEFAULT_OVERFLOW;<br>&nbsp; uartConfig.flowControlThreshold = SPI_MGR_DEFAULT_THRESHOLD;<br>&nbsp; uartConfig.rx.maxBufSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPI_MGR_DEFAULT_MAX_RX_BUFF;<br>&nbsp; uartConfig.tx.maxBufSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPI_MGR_DEFAULT_MAX_TX_BUFF;<br>&nbsp; uartConfig.idleTimeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPI_MGR_DEFAULT_IDLE_TIMEOUT;<br>&nbsp; uartConfig.intEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = TRUE;<br>#if defined (ZTOOL_P1) || defined (ZTOOL_P2)<br>&nbsp; uartConfig.callBackFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPIMgr_ProcessZToolData;&nbsp;&nbsp;<span style="color:#ff0000;">//回调函数<br></span>#elif defined (ZAPP_P1) || defined (ZAPP_P2)<br>&nbsp; uartConfig.callBackFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPIMgr_ProcessZAppData;&nbsp;&nbsp;<span style="color:#ff0000;">//回调函数<br></span>#else<br>&nbsp; uartConfig.callBackFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;<br>#endif</span></strong></p> 
   <p><br><strong><span style="color:#339966;">来看下SPIMgr_ProcessZToolData ( uint8 port, uint8 event )<br>/*****************************************************<br>&nbsp;* @fn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPIMgr_ProcessZToolRxData<br>&nbsp;*<br>&nbsp;* @brief&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;| SOP | CMD&nbsp; |&nbsp;&nbsp; Data Length&nbsp;&nbsp; | FSC&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; //帧格式<br></span>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;&nbsp;&nbsp;|&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; &nbsp; 2&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp; 1&nbsp;&nbsp; &nbsp; |<br></span>&nbsp;*<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parses the data and determine either is SPI or just simply serial data<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then send the data to correct place (MT or APP)<br>&nbsp;*<br>&nbsp;* @param&nbsp;&nbsp; pBuffer&nbsp; - pointer to the buffer that contains the data<br>&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length&nbsp;&nbsp; - length of the buffer<br>&nbsp;*<br>&nbsp;*<br>&nbsp;* @return&nbsp; None<br>&nbsp;<br></span><span style="color:#3366ff;">void SPIMgr_ProcessZToolData ( uint8 port, uint8 event )<br>{<br>&nbsp; uint8&nbsp; ch;</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; /* Verify events */</span><br>&nbsp; if (event == HAL_UART_TX_FULL)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;// Do something when TX if full<br></span>&nbsp;&nbsp;&nbsp; return;<br>&nbsp; }</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp; if (event &amp; (HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; while (Hal_UART_RxBufLen(SPI_MGR_DEFAULT_PORT))<span style="color:#ff0000;">&nbsp;//RxBuf[ ]中字节数，即有数据<br></span>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HalUARTRead (SPI_MGR_DEFAULT_PORT, &amp;ch, 1);<span style="color:#ff0000;">&nbsp;//每次读取1字节到ch所指空间<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//接下来对所读字节的state进行判断<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (state)&nbsp;<span style="color:#ff0000;">//state 参见上面宏定义/* State values for ZTool protocal */<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case SOP_STATE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ch == SOP_VALUE)&nbsp;&nbsp;<span style="color:#ff0000;">//SOP_VALUE=0x02<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = CMD_STATE1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case CMD_STATE1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMD_Token[0] = ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = CMD_STATE2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case CMD_STATE2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMD_Token[1] = ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = LEN_STATE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LEN_STATE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEN_Token = ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ch == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = FCS_STATE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = DATA_STATE;</span><span style="color:#ff0000;">&nbsp; //state = DATA_STATE=0x04</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempDataLen = 0;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;&nbsp; /* Allocate memory for the data */<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) +</span></strong></p> 
   <p><strong><span style="color:#3366ff;">2+1+LEN_Token );</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (SPI_Msg)&nbsp;&nbsp;<span style="color:#ff0000;">//构造消息：把SOP字节和FCS字节去掉,剩下2字节的CMD和1字节的Data<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;&nbsp;&nbsp; /* Fill up what we can */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;hdr.event = CMD_SERIAL_MSG;&nbsp;<span style="color:#ff0000;">&nbsp;//CMD_SERIAL_MSG<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg = (uint8*)(SPI_Msg+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg[0] = CMD_Token[0];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg[1] = CMD_Token[1];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg[2] = LEN_Token;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = SOP_STATE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DATA_STATE:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg[3 + tempDataLen++] = ch;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( tempDataLen == LEN_Token )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = FCS_STATE;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case FCS_STATE:&nbsp;&nbsp;</span><span style="color:#ff0000;">//帧校验序列(FCS),则判断是接收数据是否正确</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FSC_Token = ch;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp; /* Make sure it's correct */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((SPIMgr_CalcFCS ((uint8*)&amp;SPI_Msg-&gt;msg[0], 2 + 1 + LEN_Token) == FSC_Token))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; osal_msg_send( MT_TaskID, (byte *)SPI_Msg );&nbsp;&nbsp;</span><span style="color:#ff0000;">//接收数据正确则发送系统信息触发MT层任</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">务.事件为CMD_SERIAL_MSG<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* deallocate the msg */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; osal_msg_deallocate ( (uint8 *)SPI_Msg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">/* Reset the state, send or discard the buffers at this point */<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state = SOP_STATE;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></strong></p> 
   <p><br><strong><span style="color:#339966;"><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}<br>#endif*********************************************************<br></span>(这个函数只是总体上了解了下)<br>回调函数SPIMgr_ProcessZToolData()对rxbuf[]中的每一字节数据进行分析，并且构造一个发往系统的消息</span></strong><strong><span style="color:#339966;">包(具体事件为SPI_Msg-&gt;hdr.event = CMD_SERIAL_MSG)然后调用osal_msg_send( MT_TaskID, (byte *)</span></strong><strong><span style="color:#339966;">SPI_Msg )给系统发送消息,而下面肯定又会调用osal_set_event()来设置任务事件发生标志，最后调用MT层</span></strong><strong><span style="color:#339966;">的事件处理函数,下面来看下MT层的事件处理函数:<br><span style="color:#3366ff;">/**********************************************************</span><br>&nbsp;* @fn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MT_ProcessEvent<br>&nbsp;*<br>&nbsp;* @brief<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp; MonitorTest Task Event Processor.&nbsp; This task is put into the<br>&nbsp;*&nbsp;&nbsp; task table.<br>&nbsp;*<br>&nbsp;* @param&nbsp;&nbsp; byte task_id - task ID of the MT Task<br>&nbsp;* @param&nbsp;&nbsp; UINT16 events - event(s) for the MT Task<br>&nbsp;*<br>&nbsp;* @return&nbsp; void<br>&nbsp;*/<br></span><span style="color:#3366ff;">UINT16 MT_ProcessEvent( byte task_id, UINT16 events )<br>{<br>&nbsp; uint8 *msg_ptr;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp; ………………</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#3366ff;">&nbsp; if ( events &amp; SYS_EVENT_MSG )<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; while ( (msg_ptr = osal_msg_receive( MT_TaskID )) )<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MT_ProcessCommand( (mtOSALSerialData_t *)msg_ptr );<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp; ………………<br>/*********************************************************************<br></span>可以看到它调用了MT_ProcessCommand( (mtOSALSerialData_t *)msg_ptr )来进行下一步的操作，来看下</span></strong><strong><span style="color:#339966;">MT_ProcessCommand()这个函数：</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#3366ff;">/*********************************************************************</span><br>&nbsp;* @fn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MT_ProcessCommand&nbsp;*<br>&nbsp;* @brief</span></strong></p> 
   <p><strong><span style="color:#339966;">&nbsp;*<br>&nbsp;*&nbsp;&nbsp; Process Event Messages.<br>&nbsp;*<br>&nbsp;* @param&nbsp;&nbsp; byte *msg - pointer to event message<br>&nbsp;*<br>&nbsp;* @return<br>&nbsp;*/<br></span><span style="color:#3366ff;">void MT_ProcessCommand( mtOSALSerialData_t *msg )<br>{<br>&nbsp;&nbsp; ……………………<br>#if defined (ZTOOL_P1) || defined (ZTOOL_P2)<br>&nbsp;&nbsp;&nbsp; case CMD_SERIAL_MSG:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MT_ProcessSerialCommand( msg-&gt;msg );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; ……………………<br>}</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#3366ff;">/*********************************************************************</span><br>通过上面的MT_ProcessCommand()，再根据先前SPI_Msg-&gt;hdr.event = CMD_SERIAL_MSG，可以得到它调用</span></strong><strong><span style="color:#339966;">MT_ProcessSerialCommand( msg-&gt;msg )这个函数，而MT_ProcessSerialCommand()函数根据参数cmd来选择命</span></strong><strong><span style="color:#339966;">令，包括读RAM,写RAM等等很多命令指令来对接收到的数据进行下一步操作(先不钻了……)，对于这个cmd，</span></strong><strong><span style="color:#339966;">cmd = BUILD_UINT16( msg[1], msg[0] )，SPIMgr_ProcessZToolData()对msg[1], msg[0]进行了配置：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg[0] = CMD_Token[0];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPI_Msg-&gt;msg[1] = CMD_Token[1];<br>而CMD_Token[0]与CMD_Token[1]的值又与SPIMgr_ProcessZToolData()中的参数ch密切相关，对于这个ch具体</span></strong><strong><span style="color:#339966;">的定义，只是看到个uint8&nbsp; ch;，没看到具体初始化为什么值.个人在想，是不是通过对参数ch的自由设定来</span></strong><strong><span style="color:#339966;">选择串口命令cmd，通过cmd来实现对数据的不同处理<span style="color:#0000ff;">……【现在发现这个应该是跟ZTOOL有关，晴天那天说ZTOOL上面可以发送不同命令的】</span></span></strong><strong><span style="color:#339966;"><br></span><span style="color:#ff0000;">迷糊中！～<img src="https://yqfile.alicdn.com/img_d240fb22c5eeeb4429309b5493d34049.gif" alt="协议中UART的两种模式 - 小峰 - happy~">～纠结中！～<img src="https://yqfile.alicdn.com/img_df7fad4cfcab85870c5c96f33a8be49c.gif" alt="协议中UART的两种模式 - 小峰 - happy~"></span></strong></p> 
   <p><strong><span style="color:#339966;">上面分析了UART中断模式下,从接收到数据进入中断函数，把数据写入rxbuf[ ]，200ms调用一次pollISR()轮</span></strong><strong><span style="color:#339966;">询，跳回到HalUARTPoll()进行数据处理……………….</span></strong><strong><span style="color:#339966;">那这个具体轮询时间rxTick约为200ms是怎么得出来的？</span></strong><strong><span style="color:#339966;">借用<span style="color:#ff0000;">《Z-STACK问题之串口结构uartCfg_t乱说》</span>这篇文章的分析：<br><span style="color:#ff0000;">************</span><br><span style="color:#ff6600;">&nbsp;cfg-&gt;rxTick = HAL_UART_RX_IDLE<br>&nbsp;#define HAL_UART_RX_IDLE&nbsp; (6 * RX_MSECS_TO_TICKS)<br>#define RX_MSECS_TO_TICKS&nbsp; 33 (// The timeout tick is at 32-kHz, so multiply msecs by 33.)</span><br>(这个超时计数采用的是睡眠定时器，32KHZ时钟,一个微秒计数约33次)<br>因此cfg-&gt;rxTick=198,即大约200ms调用一次pollISR()；<br>论证&nbsp;<span style="color:#ff6600;">#define SAFE_RX_MIN&nbsp; 48&nbsp; // bytes - max expected per poll @ 115.2k</span><br>因为CC2430串口波特率为38400bps下，一个字节需要时间约为：4.16ms(这里……这?)，那么198/4.16等于</span></strong><strong><span style="color:#339966;">47.6（198ms是中断处理数据的间隔，这期间串口是不断接收数据，那在这期间能接收到多少数据呢？为47.6</span></strong><strong><span style="color:#339966;">字节，因此要保证至少48字节的存储空间），约为48.所以这也就是上面定义这个48的原因。因为 cfg-</span></strong><strong><span style="color:#339966;">&gt;rxTick定义了多久处理一次串口缓存区，而为了保证串口缓冲区不被新的数据覆盖，那么在这个间隔期间就</span></strong><strong><span style="color:#339966;">必须保证大于48字节存储空间空闲。<br><span style="color:#ff0000;">*************</span><br>hal_uart.c有这段话：<br><span style="color:#ff6600;">/* Need to leave enough of the Rx buffer free to handle the incoming bytes<br>&nbsp;* after asserting flow control, but before the transmitter has obeyed it.<br>&nbsp;* At the max expected baud rate of 115.2k, 16 bytes will only take ~1.3 msecs,<br>&nbsp;* but at the min expected baud rate of 38.4k, they could take ~4.2 msecs.<br>&nbsp;* SAFE_RX_MIN and DMA_RX_DLY must both be consistent according to<br>&nbsp;* the min &amp; max expected baud rate.<br>&nbsp;*/</span><br>我算了半天也算不出上面几个数来……悲剧！先这样吧……<br>对于串口里面的几个参数，后面直接转载<span style="color:#ff0000;">《Z-STACK问题之串口结构uartCfg_t乱说》</span>文章好了.<br>********************************************************<br>UART接收数据中断模式流程:(<span style="color:#ff0000;">纯属个人理解，还有很多地方不清楚</span>！<img src="https://yqfile.alicdn.com/img_b4eee36fde97eff65c2e4ae7875a9c11.gif" alt="协议中UART的两种模式 - 小峰 - happy~">)<br><span style="color:#0000ff;">(1)</span><br>ZMain.c调用HalDriverInit()，HalDriverInit调用HalUARTInit()初始化串口驱动程序任务初始化函数,MT_TaskInit()调用SPIMgr_Init()初始化串口配置<br><span style="color:#0000ff;">(2)</span><br>串口接收到数据产生中断，进入接收中断服务程序，把串口缓存UxDBUF中的数据传送到rxbuf[]中去.UxDBUF</span></strong><strong><span style="color:#339966;">只能存放1字节，rxbuf[]能存放128字节，但要空出48字节作为安全区，因此接收数据达到80字节时作为一个</span></strong><strong><span style="color:#339966;">临界值rxHigh，可以触发事件HAL_UART_RX_ABOUT_FUL.<br></span><span style="color:#0000ff;">(3)</span></strong></p> 
   <p><strong><span style="color:#339966;">系统主循环函数进入HalUARTPoll()轮询串口，大约每200ms调用一次pollISR()，然后跳回HalUARTPoll()</span></strong><strong><span style="color:#339966;">对rxbuf[]中的数据进行处理——&gt;调用回调函数SPIMgr_ProcessZToolData()分析rxbuf[]中每一字节，构造</span></strong><strong><span style="color:#339966;">发往系统的消息——&gt;调用osal_msg_send( MT_TaskID, (byte *)SPI_Msg )发送消息——&gt;触发MT任务事件,</span></strong><strong><span style="color:#339966;">调用MT任务事件处理函数 MT_ProcessEvent()——&gt;调用MT_ProcessCommand()，根据msg-&gt;hdr.event——&gt;调</span></strong><strong><span style="color:#339966;">用MT_ProcessSerialCommand()，根据参数cmd来进行最终处理.<br>********************************************************<br>UART发送数据中断模式暂时不分析了,一头雾水……</span></strong></p> 
   <p><strong><span style="color:#0000ff;">############################################（下面小段于2010.5.25更新）</span></strong></p> 
   <p><strong><span style="color:#339966;">对于串口的回调函数，SPIMgr_Init()中配置了两个：</span></strong></p> 
   <p><strong><span style="color:#ff6600;">#if defined (ZTOOL_P1) || defined (ZTOOL_P2)<br>&nbsp; uartConfig.callBackFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPIMgr_ProcessZToolData;&nbsp;&nbsp;<span style="color:#ff0000;">//回调函数<br></span>#elif defined (ZAPP_P1) || defined (ZAPP_P2)<br>&nbsp; uartConfig.callBackFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = SPIMgr_ProcessZAppData;&nbsp;&nbsp;<span style="color:#ff0000;">//回调函数<br></span>#else<br>&nbsp; uartConfig.callBackFunc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = NULL;</span></strong></p> 
   <p><strong><span style="color:#339966;">有什么区别呢？在<span style="color:#ff0000;">《Zigbee技术规范与协议栈分析》</span>这篇文章中看到过一段话：<br>&nbsp;&nbsp;&nbsp; 作为协调器，如果程序使用了串口调试助手，则DMA将上位机的数据按照一个字节波特率加一个字节数据的形式组装到cfg-&gt;rxBuf中供其他函数调用，并且通过回调函数SPIMgr_ProcessZToolData ( uint8 port, uint8 event )将任务的ID和强制事件发送到任务列表中，供主循环处理函数扫描；作为终端节点和路由设备，无法使用串口调试助手，则通过回调函数 SPIMgr_ProcessZAppData ( uint8 port, uint8 event ) 将任务的ID和强制事件发送到任务列表中。当扫描至参数events=1，则进入相应层的处理程序进行任务ID和events的约定比对，完成相应的功能。<br>根据这段话个人在想：ZTOOL上可以发命令数据到ZC??，协调器调用SPIMgr_ProcessZToolData()进行处理，那ZR和ED的串口接收到数据(怎么接收?)调用SPIMgr_ProcessZAppData()，SPIMgr_ProcessZAppData()最终会调用osal_msg_send()：<br></span><span style="color:#3366ff;">/**************************************<br>void SPIMgr_ProcessZAppData ( uint8 port, uint8 event )<br>{</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp; …………<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( msg_ptr )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg_ptr-&gt;event = SPI_INCOMING_ZAPP_DATA;//SPI_INCOMING_ZAPP_DATA<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg_ptr-&gt;status = length;</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">/* Read the data of Rx buffer *///Rx buffer是读到上面为msg_ptr 分配的空间去的<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HalUARTRead( SPI_MGR_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;">&nbsp;/* Send the raw data to application...or where ever */<br></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; osal_msg_send( App_TaskID, (uint8 *)msg_ptr );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp; …………<br>}<br>/**************************************</span></strong></p> 
   <p><strong><span style="color:#339966;">至于把串口接收到的数据传送到哪里去，这就跟App_TaskID有关，而App_TaskID是通过下面这个函数来定义的：</span></strong></p> 
   <p><strong><span style="color:#3366ff;">/**************************************<br>&nbsp;* @fn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MT_SerialRegisterTaskID<br>&nbsp;*<br>&nbsp;* @brief<br>&nbsp;*<br>&nbsp;*&nbsp;&nbsp; This function registers the taskID of the application so it knows<br>&nbsp;*&nbsp;&nbsp; where to send the messages whent they come in.<br>&nbsp;*<br>&nbsp;* @param&nbsp;&nbsp; void<br>&nbsp;*<br>&nbsp;* @return&nbsp; void<br>&nbsp;**************************************<br>void SPIMgr_RegisterTaskID( byte taskID )<br>{<br>&nbsp; App_TaskID = taskID;<br>}</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#3366ff;">/*************************************<br></span>可以看到，如果想把串口接收到的数据送到应用层任务(比如SampleApp)中，那这里应该注册SPIMgr_RegisterTaskID( SampleApp_TaskID ).这样就可以触发应用层任务(SampleApp)的事件(SPI_INCOMING_ZAPP_DATA)，在事件处理函数中添加一个对事件SPI_INCOMING_ZAPP_DATA进行处理的程序就可以.<br>但是，我好像看到协调器设备的预编译里都是<span style="color:#ff0000;">ZTOOL_P1</span>，终端和路由功能的设备的预编译为<span style="color:#ff0000;">XZTOOL_P1</span>,没有编译<span style="color:#ff0000;">ZAPP_P1</span>和<span style="color:#ff0000;">ZAPP_P2</span>,也就是没有回调函数,是不是就不能进行串口传输了?<br><span style="color:#ff6600;">那如果我在终端和路由节点上面编译ZTOOL_P1是否可行??<br></span><span style="color:#ff6600;">那如果我在协调器上编译ZAPP_P1，再在应用任务事件处理函数中添加相应SPI_INCOMING_ZAPP_DATA事件的处理程序，串口接收的数据是否可以顺利传送到应用层??<br></span>——等有了实验套件，我再验证下！</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#ff6600;">个人在想，协调器串口接收的数据送到应用层任务中的方法有</span>：<br><span style="color:#0000ff;">(1)</span>通过默认的SPIMgr_ProcessZToolData()处理函数把数据发送到应用层供应用层使用(这点只是猜测，还没找着，毕竟MT_ProcessSerialCommand()函数这么多命令)<br><span style="color:#0000ff;">(2)</span>通过SPIMgr_RegisterTaskID()注册相应TaskID，再通过SPIMgr_ProcessZAppData()处理函数把数据发送到相应任务中供其使用(也只是猜测，没有验证)<br><span style="color:#0000ff;">(3)</span>通过串口读写函数HalUARTRead()和HalUARTWrite()，这两个函数可以在应用层中直接调用来读取串口接收到的数据以及通过串口发送数据。</span></strong></p> 
   <p><strong><span style="color:#339966;">HalUARTRead( uint8 port, uint8 *buf, uint16 len )//从rxbuf[ ]读取len长度的数据到*buf所指空间<br>HalUARTWrite( uint8 port, uint8 *buf, uint16 len )//把len长度的数据从*buf所指空间发送到txbuf[ ]</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#0000ff;">&nbsp;&nbsp;以上问题见《协议栈中串口的两种回调函数》记录。。。。。。。。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></span><span style="color:#ff0000;font-size:medium;">纯属个人想法，有待验证！</span></strong></p> 
   <p><strong><span style="color:#0000ff;">###########################################################################</span></strong></p> 
   <p><strong><span style="color:#0000ff;">###########################################################################</span></strong></p> 
   <p><strong><span style="color:#0000ff;font-size:large;">2、DMA模式（UART接收）</span></strong></p> 
   <p><strong><span style="color:#339966;">hal_board_cfg.h中有这段话:</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#ff6600;">/* The preferred method of implementation is by DMA for faster buad rate<br>&nbsp;&nbsp; * support. Customer may prefer to use the DMA channels for something else,<br>&nbsp;&nbsp; * in which case USART can be driven by ISR. Also, if the 2nd USART is to be<br>&nbsp;&nbsp; * used, this module does not currently support using 2 more DMA channels for<br>&nbsp;&nbsp; * it, so it must use ISR.<br>&nbsp;&nbsp; */</span><br>对于USART操作,波特率高的情况下推荐使用DMA驱动模式.用户可能习惯把DMA应用在其它地方,这种情况下可</span></strong><strong><span style="color:#339966;">以用中断模式.同样,如果第二个USART也被使用了,由于USART模块不能在同一时间支持两条以上DMA通道,因此</span></strong><strong><span style="color:#339966;">这个时候必须使用中断来驱动.</span></strong></p> 
   <p><br><strong><span style="color:#339966;"><span style="color:#ff0000;">********************</span><br>DMA:<br>允许不同速度的硬件装置来沟通，而不需要依于CPU 的大量中断负载。否则，CPU需要从来源把每一片段的资</span></strong><strong><span style="color:#339966;">料复制到暂存器，然后把他们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为RAM与</span></strong><strong><span style="color:#339966;">I/O设备开辟一条直接传送数据的通路，使CPU的效率大为提高。<br><span style="color:#ff0000;">********************</span><br></span><span style="color:#ff6600;">typedef struct {<br>&nbsp; uint8 srcAddrH;<br>&nbsp; uint8 srcAddrL;<br>&nbsp; uint8 dstAddrH;<br>&nbsp; uint8 dstAddrL;<br>&nbsp; uint8 xferLenV;<br>&nbsp; uint8 xferLenL;<br>&nbsp; uint8 ctrlA;<br>&nbsp; uint8 ctrlB;<br>} halDMADesc_t; //DMA描述符结构体</span></strong></p> 
   <p><strong><span style="color:#339966;">每一个通道都有相应的描述符.DMA传送首先要进行DMA参数配置,需要配置以下参数:<br></span><span style="color:#0000ff;">(1)源地址:DMA信道要读的数据的首地址<br>(2)目标地址:DMA信道从源地址读出的要写数据的首地址.目标地址要可写<br>(3)传送长度<br>(4)可变长度(VLEN)设置<br>(5)优先级别<br>(6)触发事件<br>(7)源地址和目标地址增量<br>(8)DMA传送模式<br>(9)字节传送或字传送<br>(10)中断屏蔽<br>(11)设置M8模式</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#ff0000;">CC2430中DMA有5条通道,UART默认的是哪个通道呢?</span><br><span style="color:#ff6600;">********************</span><br>HalUARTInit()中初始化为:<br>&nbsp; // Setup Tx by DMA.<br>&nbsp;<span style="color:#ff6600;">&nbsp;ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX );<br></span>&nbsp; // Setup Rx by DMA.<br>&nbsp;&nbsp;</span><span style="color:#ff6600;">ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX );</span></strong></p> 
   <p><strong><span style="color:#339966;">#define HAL_DMA_GET_DESC1234( a )&nbsp;&nbsp;&nbsp;&nbsp; (dmaCh1234+((a)-1))</span></strong></p> 
   <p><strong><span style="color:#339966;">// Used by DMA macros to shift 1 to create a mask for DMA registers.<br>#define HAL_DMA_CH_TX&nbsp;&nbsp;&nbsp; 3&nbsp; //协议栈默认的用于UART发送的DMA通道 映射后为DMA通道2<br>#define HAL_DMA_CH_RX&nbsp;&nbsp;&nbsp; 4&nbsp; //协议栈默认的用于UART接收的DMA通道 映射后为DMA通道3</span></strong></p> 
   <p><strong><span style="color:#339966;">********************<br><span style="color:#ff0000;">对这两条分别用于发送与接收的DMA通道的配置是如何的?</span><br>********************<br>在HalUARTInit()中初始化为:<br></span><span style="color:#3366ff;">#if HAL_UART_DMA</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">//---------------------配置发送为DMA模式；数据从内存空间传送到DMA_UDBUF???</span><br><span style="color:#ff0000;">&nbsp; /*选择DMA通道*/<br>&nbsp; // Setup Tx by DMA.</span><br>&nbsp; ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_TX );</span><span style="color:#ff0000;">&nbsp;//协议栈默认的用于UART发送的DMA通道映射后为DMA通道2</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; /*配置ch-&gt;dstAddrH/L*/<br>&nbsp; // The start address of the destination.目的地的起始地址<br></span>&nbsp; HAL_DMA_SET_DEST( ch, DMA_UDBUF );&nbsp;<span style="color:#ff0000;">//DMA_UDBUF为目的地,通过这个函数把DMA_UDBUF地址的高8位<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//赋给ch-&gt;dstAddrH,低8位赋给ch-&gt;dstAddrL<br>&nbsp; /*配置ch-&gt;xferLenV*/<br>&nbsp; // Using the length field to determine how many bytes to transfer.<br></span>&nbsp; HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );</span><span style="color:#ff0000;">//HAL_DMA_VLEN_USE_LEN=0x00 //配置VLEN域使用LEN字段</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; /*配置ch-&gt;ctrlA(通过多次配置ctrlA的每一位,同理包括ctrlB)*/<br>&nbsp; // One byte is transferred each time. //初始化为一次传输一字节&nbsp;<br></span>&nbsp; HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_BYTE );</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;">&nbsp;<span style="color:#ff0000;">&nbsp;/*配置ch-&gt;ctrlA*/<br>&nbsp; // The bytes are transferred 1-by-1 on Tx Complete trigger. //一次触发只传输一个字节，触发源为UART0 TX完成&nbsp;<br></span>&nbsp; HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );<br>&nbsp; HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_TX );</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;">&nbsp;<span style="color:#ff0000;">&nbsp;/*配置ch-&gt;ctrlB*/<br>&nbsp; // The source address is decremented by 1 byte after each transfer.每次传送后源地址减1<br></span>&nbsp; HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_1 );</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;<span style="color:#ff0000;">/*配置ch-&gt;ctrlB*/<br>&nbsp; // The destination address is constant - the Tx Data Buffer.目的地址不变,始终为Tx Data Buffer<br></span>&nbsp; HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_0 );</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;<span style="color:#ff0000;">/*配置ch-&gt;ctrlB*/<br>&nbsp; // The DMA is to be polled and shall not issue an IRQ upon completion.传送完成后不传送中断请求<br></span>&nbsp; HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;">&nbsp;&nbsp;<span style="color:#ff0000;">/*配置ch-&gt;ctrlB*/<br>&nbsp; // Xfer all 8 bits of a byte xfer. 8位一字节<br></span>&nbsp; HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );</span></strong></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="color:#3366ff;">&nbsp;<span style="color:#ff0000;">&nbsp;/*配置ch-&gt;ctrlB*/<br>&nbsp; // DMA Tx has shared priority for memory access - every other one. 高优先级<br></span>&nbsp; HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );</span></strong></p> 
   <p><br>&nbsp;&nbsp;<br><span style="color:#ff0000;">//---------------------配置接收为DMA模式：数据从DMA_UDBUF传送到内存空间???<br>&nbsp; // Setup Rx by DMA.<br></span>&nbsp; ch = HAL_DMA_GET_DESC1234( HAL_DMA_CH_RX );//</p> 
   <p> <strong><strong><span style="color:#ff0000;">协议栈默认的用于UART接收的DMA通道 映射后为DMA通道3</span></strong></strong></p> 
   <p>&nbsp;</p> 
   <p> &nbsp;</p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // The start address of the source. 发源地起始地址</span><br>&nbsp; HAL_DMA_SET_SOURCE( ch, DMA_UDBUF );</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // Using the length field to determine how many bytes to transfer.</span><br>&nbsp; HAL_DMA_SET_VLEN( ch, HAL_DMA_VLEN_USE_LEN );</span></strong></p> 
   <p><strong><span style="color:#3366ff;">&nbsp;<span style="color:#ff6600;">&nbsp;/* The trick is to cfg DMA to xfer 2 bytes for every 1 byte of Rx.<br>&nbsp;&nbsp; * The byte after the Rx Data Buffer is the Baud Cfg Register,<br>&nbsp;&nbsp; * which always has a known value. So init Rx buffer to inverse of that<br>&nbsp;&nbsp; * known value. DMA word xfer will flip the bytes, so every valid Rx byte<br>&nbsp;&nbsp; * in the Rx buffer will be preceded by a DMA_PAD char equal to the<br>&nbsp;&nbsp; * Baud Cfg Register value.<br>&nbsp;&nbsp; */<br>&nbsp;&nbsp;</span>HAL_DMA_SET_WORD_SIZE( ch, HAL_DMA_WORDSIZE_WORD );</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // The bytes are transferred 1-by-1 on Rx Complete trigger.</span><br>&nbsp; HAL_DMA_SET_TRIG_MODE( ch, HAL_DMA_TMODE_SINGLE );<br>&nbsp; HAL_DMA_SET_TRIG_SRC( ch, DMATRIG_RX );</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // The source address is constant - the Rx Data Buffer.</span><br>&nbsp; HAL_DMA_SET_SRC_INC( ch, HAL_DMA_SRCINC_0 );</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // The destination address is incremented by 1 word after each transfer.</span><br>&nbsp; HAL_DMA_SET_DST_INC( ch, HAL_DMA_DSTINC_1 );</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // The DMA is to be polled and shall not issue an IRQ upon completion.</span><br>&nbsp; HAL_DMA_SET_IRQ( ch, HAL_DMA_IRQMASK_DISABLE );</span></strong></p> 
   <p><strong><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // Xfer all 8 bits of a byte xfer.</span><br>&nbsp; HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS );</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#3366ff;"><span style="color:#ff0000;">&nbsp; // DMA has highest priority for memory access.</span><br>&nbsp; HAL_DMA_SET_PRIORITY( ch, HAL_DMA_PRI_HIGH );<br>#endif<br></span>********************<br>对于发送,触发事件为HAL_DMA_TRIG_UTX1/0 :USART1/0 TX complete UART中数据发送完成就触发DMA从内存空间txbuf[ ]传送数据到串口??<br>对于接收，触发事件为HAL_DMA_TRIG_URX1/0:USART1/0 RX complete UART中数据接收完成就触发DMA把数据从串口缓存传送到内存空间rxbuf[ ]??<br><span style="color:#ff0000;">——我不敢确定！</span><br>事实上这一步所完成的任务和中断服务程序完成的任务是一样的，发送中断服务函数：把数据从txbuf[]传送到串口UDBUF;接收中断服务函数:把数据从UDBUF传送到rxbuf[ ]；</span></strong></p> 
   <p><strong><span style="color:#339966;">UART接收数据DMA模式流程:(<span style="color:#ff0000;">纯属个人理解，还有很多地方不清楚！<img src="https://yqfile.alicdn.com/img_f920bd60ca63912ceb8ce126fc4a1cb3.gif" alt="协议中UART的两种模式 - 小峰 - happy~">)</span><br><span style="color:#0000ff;">(1)</span><br>ZMain.c调用HalDriverInit()，HalDriverInit调用HalDmaInit()初始化DMA通道01234的地址:</span></strong></p> 
   <p><strong><span style="color:#339966;">&nbsp;&nbsp;&nbsp; halDMADesc_t dmaCh0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; halDMADesc_t dmaCh1234[4];<br>&nbsp;&nbsp;&nbsp; HAL_DMA_SET_ADDR_DESC0( &amp;dmaCh0 );<br>&nbsp;&nbsp;&nbsp; HAL_DMA_SET_ADDR_DESC1234( dmaCh1234 );</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#0000ff;">(2)</span><br>HalUARTInit()函数中对通道2和3进行配置.<br><span style="color:#0000ff;">(3)</span><br>系统主循环函数进入HalUARTPoll()轮询串口，大约每200ms调用一次 pollDMA()???，然后跳回HalUARTPoll()对rxbuf[]中的数据进行处理——&gt;调用回调函数SPIMgr_ProcessZToolData()分析rxbuf[]中每一字节，构造发往系统的消息——&gt;调用osal_msg_send( MT_TaskID, (byte *)SPI_Msg )发送消息——&gt;触发MT任务事件,调用MT任务事件处理函数 MT_ProcessEvent()——&gt;调用MT_ProcessCommand()，根据msg-&gt;hdr.event——&gt;调用MT_ProcessSerialCommand()，根据参数cmd来进行最终处理.</span></strong></p> 
   <p><strong><span style="color:#339966;">DMA模式UART发送的暂不钻了.<br></span><span style="color:#0000ff;">###########################################################################</span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#0000ff;">###########################################################################</span><br></span><span style="color:#ff0000;font-size:x-large;">对于UART的两种方式,实在有好多地方不搞不懂,以上个人记录也肯定有错误之处,希望哪位对这部分内容熟悉的高手能指点一下具体流程,或是在哪里看到相关资料给个链接提示,感激不尽!<img src="https://yqfile.alicdn.com/img_6d1c530cb713dd4c7a97c610f2d1659b.gif" alt="协议中UART的两种模式 - 小峰 - happy~"></span></strong></p> 
   <p><strong><span style="color:#339966;"><span style="color:#0000ff;">###########################################################################</span></span></strong></p> 
   <p><strong><span style="color:#0000ff;">###########################################################################</span></strong></p> 
   <p><span style="color:#ff0000;"><strong>说明：本文作者所记录，以上基本为个人见解，错误之处还请高手指点，本人随时更新，转载请注明出处，谢谢！</strong></span></p> 
   <p><span style="color:#ff0000;"><strong>参考资料：《Z-STACK问题之串口结构uartCfg_t乱说》：</strong><a href="http://hi.baidu.com/dapaopao/blog/item/ccf242900ef2e985a877a48a.html" rel="nofollow"><strong>http://hi.baidu.com/dapaopao/blog/item/ccf242900ef2e985a877a48a.html</strong></a><strong>&nbsp;</strong></span><span style="color:#ff0000;"><strong>&nbsp;已转载.</strong></span></p> 
   <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff0000;"><strong>&nbsp; 2010.5.17&nbsp;&nbsp; ～XF</strong></span></p> 
   <p><strong><span style="color:#0000ff;">最近更新：2010.5.25&nbsp; / 2010.6.05/2010.6.26</span></strong></p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
