<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>linux 串口驱动（二）初始化 【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://blog.chinaunix.net/uid-27717694-id-3493611.html    8250串口的初始化：    （1）定义uart_driver、uart_ops、uart_port等结构体的实例并在适当的地方更具具体的硬件驱动情况初始化他们，当然...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/12/03/weixin_33810302_90127557.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">linux 串口驱动（二）初始化 【转】</h1>
    <p class="post-meta">Dec 3, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p><strong>转自：<a href="http://blog.chinaunix.net/uid-27717694-id-3493611.html" rel="nofollow">http://blog.chinaunix.net/uid-27717694-id-3493611.html</a></strong></p> 
   <p><strong>8250串口的初始化：</strong></p> 
   <p>（1）定义uart_driver、uart_ops、uart_port等结构体的实例并在适当的地方更具具体的硬件驱动情况初始化他们，当然具体设备xxx的驱动可以将这些结构体套在新定义的xxx_uart_driver、xxx_uart_ops、xxx_uart_port之内。</p> 
   <p>（2）在模块初始化调用uart_register()和uart_add_one_port()以注册UART驱动并添加端口，在模块卸载时调用uart_unregister_driver()和uart_remove_one_port()以注销UART驱动以移除端口。</p> 
   <p>（3）根据具体硬件的uart_ops中的成员函数，这些函数的实现成为UART驱动的主体工作。<br>1.串口结构体,他们之间的关系如图所示：</p> 
   <p><img src="https://yqfile.alicdn.com/img_f63e110a77bc34a16d3345967db9530e.jpg" alt="" width="700" height="429"><br>//（1）串口驱动结构体<br>struct uart_driver {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct module&nbsp;&nbsp; *owner; //模块所有者&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; const char&nbsp; *driver_name;&nbsp;&nbsp; //驱动名&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; const char&nbsp; *dev_name;&nbsp; //设备名&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int&nbsp; major; //主设备号&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int&nbsp; minor; //次设备号&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int&nbsp; nr;&nbsp;&nbsp;&nbsp; //支持串口个数&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct console&nbsp; *cons;//控制台设备&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct uart_state&nbsp;&nbsp; *state; //串口状态&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct tty_driver&nbsp;&nbsp; *tty_driver; //tty设备&nbsp;&nbsp;&nbsp;<br>};&nbsp;</p> 
   <p>//（2）串口端口结构体<br>struct uart_port {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; spinlock_t&nbsp; lock;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; iobase; //io端口基地址&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char __iomem&nbsp;&nbsp; *membase; //内存端口基地址&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; (*serial_in)(struct uart_port *, int); //串口读函数&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*serial_out)(struct uart_port *, int, int); //串口写方法<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*set_termios)(struct uart_port *,struct ktermios *new,struct ktermios *old); //串口配置方法函数<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*pm)(struct uart_port *, unsigned int state,unsigned int old);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; irq;&nbsp;&nbsp;&nbsp; //中断号&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; irqflags;&nbsp;&nbsp; //中断标志&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; uartclk;&nbsp;&nbsp; //串口时钟<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; fifosize;&nbsp;&nbsp; //fifo大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; x_char;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; regshift;&nbsp;&nbsp; //寄存器偏移值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; iotype; //io访问类型&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; unused1;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; read_status_mask;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; ignore_status_mask;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct uart_state&nbsp;&nbsp; *state; //uart_state结构体&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct uart_icount&nbsp; icount; //串口使用计数&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct console&nbsp; *cons;&nbsp; //console控制台&nbsp;&nbsp;&nbsp;<br>#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; sysrq;&nbsp;&nbsp;<br>#endif&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; upf_t&nbsp;&nbsp; flags;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; mctrl;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; timeout;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; type; //串口类型&nbsp;<br>&nbsp;&nbsp;&nbsp; const struct uart_ops&nbsp;&nbsp; *ops;&nbsp;&nbsp; //串口操作函数集&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; custom_divisor;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; line;&nbsp;&nbsp; //端口号&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; resource_size_t mapbase; //串口寄存器基地址（物理地址）<br>&nbsp;&nbsp;&nbsp; struct device&nbsp;&nbsp; *dev;&nbsp;&nbsp; //设备文件&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; hub6;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; suspended;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; irq_wake;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; unused[2];&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; *private_data;&nbsp;&nbsp;<br>};&nbsp;</p> 
   <p>//（3）操作函数集<br>struct uart_ops {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; (*tx_empty)(struct uart_port *);&nbsp;&nbsp;&nbsp; //发送缓冲区为空&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*set_mctrl)(struct uart_port *, unsigned int mctrl);&nbsp;&nbsp; //设置串口modem控制模式&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; (*get_mctrl)(struct uart_port *);&nbsp;&nbsp; //获取串口modem控制模式&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*stop_tx)(struct uart_port *); //停止发送&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*start_tx)(struct uart_port *);&nbsp;&nbsp;&nbsp; //开始发送&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*send_xchar)(struct uart_port *, char ch);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*stop_rx)(struct uart_port *); //停止接收&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*enable_ms)(struct uart_port *);&nbsp;&nbsp; //使能modem状态信息&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*break_ctl)(struct uart_port *, int ctl);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int (*startup)(struct uart_port *); //打开串口&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*shutdown)(struct uart_port *);&nbsp;&nbsp;&nbsp; //关闭串口&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*flush_buffer)(struct uart_port *);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*set_termios)(struct uart_port *, struct ktermios *new,struct ktermios *old);&nbsp; //设置串口参数&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*set_ldisc)(struct uart_port *, int new);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*pm)(struct uart_port *, unsigned int state,unsigned int oldstate);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int (*set_wake)(struct uart_port *, unsigned int state);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; const char *(*type)(struct uart_port *);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*release_port)(struct uart_port *);&nbsp;&nbsp;&nbsp; //释放端口&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int (*request_port)(struct uart_port *);&nbsp;&nbsp;&nbsp; //请求端口&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*config_port)(struct uart_port *, int);&nbsp;&nbsp;&nbsp; //配置端口&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int (*verify_port)(struct uart_port *, struct serial_struct *); //校验端口&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int (*ioctl)(struct uart_port *, unsigned int, unsigned long);&nbsp; //控制&nbsp;&nbsp;&nbsp;<br>#ifdef CONFIG_CONSOLE_POLL&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; (*poll_put_char)(struct uart_port *, unsigned char);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int (*poll_get_char)(struct uart_port *);&nbsp;&nbsp;<br>#endif&nbsp;&nbsp;&nbsp;<br>};&nbsp;</p> 
   <p><br>//（4）uart_state<br>struct uart_state {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct tty_port port;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; pm_state;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct circ_buf xmit;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct tasklet_struct&nbsp;&nbsp; tlet;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; struct uart_port&nbsp;&nbsp;&nbsp; *uart_port;//指向对应的串口结构&nbsp;&nbsp;<br>};&nbsp;</p> 
   <p>2.串口初始化<br>static int __init serial8250_init(void)<br>{<br>&nbsp;int ret;</p> 
   <p>&nbsp;if (nr_uarts &gt; UART_NR)//UART_NR =3<br>&nbsp;&nbsp;nr_uarts = UART_NR;//串口数量最多设为3个</p> 
   <p>&nbsp;printk(KERN_INFO "Serial: 8250/16550 driver, ""%d ports, IRQ sharing %sabled\n", nr_uarts,share_irqs ? "en" : "dis");</p> 
   <p>&nbsp;serial8250_reg.nr = UART_NR;//串口数量<br>&nbsp;/*<br>&nbsp;&nbsp;static struct uart_driver serial8250_reg = {<br>&nbsp;&nbsp;.owner&nbsp;&nbsp;&nbsp;= THIS_MODULE,<br>&nbsp;&nbsp;.driver_name&nbsp;&nbsp;= "serial",<br>&nbsp;&nbsp;.dev_name&nbsp;&nbsp;= "ttyS",<br>&nbsp;&nbsp;.major&nbsp;&nbsp;&nbsp;= TTY_MAJOR,//主设备号是4<br>&nbsp;&nbsp;.minor&nbsp;&nbsp;&nbsp;= 64,<br>&nbsp;&nbsp;.cons&nbsp;&nbsp;&nbsp;= SERIAL8250_CONSOLE,//终端<br>&nbsp;};<br>&nbsp;<br>&nbsp;#define SERIAL8250_CONSOLE&nbsp;&amp;serial8250_console<br>&nbsp;<br>&nbsp;static struct console serial8250_console = {<br>&nbsp;&nbsp;.name&nbsp;&nbsp;= "ttyS",<br>&nbsp;&nbsp;.write&nbsp;&nbsp;= serial8250_console_write,<br>&nbsp;&nbsp;.device&nbsp;&nbsp;= uart_console_device,<br>&nbsp;&nbsp;.setup&nbsp;&nbsp;= serial8250_console_setup,//设置串口波特率，也就是设置串口。很重要，里面涉及到平台特性，波特率相关。<br>&nbsp;&nbsp;.early_setup&nbsp;= serial8250_console_early_setup,<br>&nbsp;&nbsp;.flags&nbsp;&nbsp;= CON_PRINTBUFFER | CON_ANYTIME,<br>&nbsp;&nbsp;.index&nbsp;&nbsp;= -1,<br>&nbsp;&nbsp;.data&nbsp;&nbsp;= &amp;serial8250_reg,<br>&nbsp;};<br>&nbsp;*/<br>&nbsp;//函数定义在serial_core.c中<br>&nbsp;//注册uart串口驱动，完善uart_driver结构serial8250_reg的uart_state成员及tty_driver成员，并注册tty驱动<br>&nbsp;ret = uart_register_driver(&amp;serial8250_reg);<br>#endif<br>&nbsp;if (ret)<br>&nbsp;&nbsp;goto out;<br>&nbsp;<br>&nbsp;//创建一个platform_device结构：serial8250_isa_devs<br>&nbsp;serial8250_isa_devs = platform_device_alloc("serial8250",PLAT8250_DEV_LEGACY);<br>&nbsp;if (!serial8250_isa_devs) {<br>&nbsp;&nbsp;ret = -ENOMEM;<br>&nbsp;&nbsp;goto unreg_uart_drv;<br>&nbsp;}<br>&nbsp;<br>&nbsp; //将该结构serial8250_isa_devs注册到总线上<br>&nbsp;ret = platform_device_add(serial8250_isa_devs);<br>&nbsp;if (ret)<br>&nbsp;&nbsp;goto put_dev;<br>&nbsp;&nbsp;<br>&nbsp;//对uart_8250_port结构serial8250_reg[]初始化,即对3个串口的uart_port结构初始化，并添加端口<br>&nbsp;serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);<br>&nbsp;<br>&nbsp;/*<br>&nbsp;static struct platform_driver serial8250_isa_driver = {<br>&nbsp;&nbsp;.probe&nbsp;&nbsp;= serial8250_probe,<br>&nbsp;&nbsp;.remove&nbsp;&nbsp;= __devexit_p(serial8250_remove),<br>&nbsp;&nbsp;.suspend&nbsp;= serial8250_suspend,<br>&nbsp;&nbsp;.resume&nbsp;&nbsp;= serial8250_resume,<br>&nbsp;&nbsp;.driver&nbsp;&nbsp;= {<br>&nbsp;&nbsp;&nbsp;.name&nbsp;= "serial8250",<br>&nbsp;&nbsp;&nbsp;.owner&nbsp;= THIS_MODULE,<br>&nbsp;&nbsp;},<br>&nbsp;};<br>&nbsp;*/<br>&nbsp;//注册设备,会调用serial8250_probe()。怎样调用的serial8250_probe？？？？？？？<br>&nbsp;ret = platform_driver_register(&amp;serial8250_isa_driver);<br>&nbsp;if (ret == 0)<br>&nbsp;&nbsp;goto out;</p> 
   <p>&nbsp;platform_device_del(serial8250_isa_devs);<br>put_dev:<br>&nbsp;platform_device_put(serial8250_isa_devs);<br>unreg_uart_drv:<br>#ifdef CONFIG_SPARC<br>&nbsp;sunserial_unregister_minors(&amp;serial8250_reg, UART_NR);<br>#else<br>&nbsp;uart_unregister_driver(&amp;serial8250_reg);<br>#endif<br>out:<br>&nbsp;return ret;<br>}</p> 
   <p>//注册串口驱动<br>int uart_register_driver(struct uart_driver *drv)<br>{<br>&nbsp;struct tty_driver *normal;<br>&nbsp;int i, retval;</p> 
   <p>&nbsp;BUG_ON(drv-&gt;state);</p> 
   <p>&nbsp;//为串口的uart_driver结构分配要指向的uart_state结构的空间*串口数量<br>&nbsp;drv-&gt;state = kzalloc(sizeof(struct uart_state) * drv-&gt;nr, GFP_KERNEL);<br>&nbsp;if (!drv-&gt;state)<br>&nbsp;&nbsp;goto out;<br>&nbsp;<br>&nbsp;//为uart_driver结构分配要指向的tty_driver结构的空间<br>&nbsp;/*struct tty_driver *alloc_tty_driver(int lines)<br>&nbsp;{<br>&nbsp;&nbsp;struct tty_driver *driver;<br>&nbsp;<br>&nbsp;&nbsp;driver = kzalloc(sizeof(struct tty_driver), GFP_KERNEL);//分配空间<br>&nbsp;&nbsp;if (driver) {<br>&nbsp;&nbsp;&nbsp;kref_init(&amp;driver-&gt;kref);<br>&nbsp;&nbsp;&nbsp;driver-&gt;magic = TTY_DRIVER_MAGIC;//tty_driver的魔数<br>&nbsp;&nbsp;&nbsp;driver-&gt;num = lines;//串口数量3个<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return driver;<br>&nbsp;}*/<br>&nbsp;normal = alloc_tty_driver(drv-&gt;nr);<br>&nbsp;if (!normal)<br>&nbsp;&nbsp;goto out_kfree;</p> 
   <p>&nbsp;drv-&gt;tty_driver = normal;//赋值给uart_driver结构的tty_driver成员<br>&nbsp;//对tty_driver成员指向的结构初始化<br>&nbsp;normal-&gt;owner&nbsp;&nbsp;= drv-&gt;owner;//THIS_MODULE<br>&nbsp;normal-&gt;driver_name&nbsp;= drv-&gt;driver_name;//"serial"<br>&nbsp;normal-&gt;name&nbsp;&nbsp;= drv-&gt;dev_name;//"ttyS"<br>&nbsp;normal-&gt;major&nbsp;&nbsp;= drv-&gt;major;//主设备号：TTY_MAJOR=4<br>&nbsp;normal-&gt;minor_start&nbsp;= drv-&gt;minor;//次设备号：64<br>&nbsp;normal-&gt;type&nbsp;&nbsp;= TTY_DRIVER_TYPE_SERIAL;//#define TTY_DRIVER_TYPE_SERIAL 0x0003<br>&nbsp;normal-&gt;subtype&nbsp;&nbsp;= SERIAL_TYPE_NORMAL;//#define SERIAL_TYPE_NORMAL&nbsp; 1(定义在include/linux/tty_driver.h)<br>&nbsp;normal-&gt;init_termios&nbsp;= tty_std_termios;//终端的标准配置（drivers/tty/tty_io.c）<br>&nbsp;normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;//配置c_cflag<br>&nbsp;normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = 9600;//波特率设为9600<br>&nbsp;normal-&gt;flags&nbsp;&nbsp;= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;<br>&nbsp;normal-&gt;driver_state&nbsp;&nbsp;&nbsp; = drv;//指向相应的uart_driver<br>&nbsp;tty_set_operations(normal, &amp;uart_ops);//将tty_driver结构的normal操作指向uart_ops<br>&nbsp;/*void tty_set_operations(struct tty_driver *driver,const struct tty_operations *op)<br>&nbsp;{<br>&nbsp;&nbsp;driver-&gt;ops = op;<br>&nbsp;};<br>&nbsp;static const struct tty_operations uart_ops = {<br>&nbsp;&nbsp;.open&nbsp;&nbsp;= uart_open,<br>&nbsp;&nbsp;.close&nbsp;&nbsp;= uart_close,<br>&nbsp;&nbsp;.write&nbsp;&nbsp;= uart_write,<br>&nbsp;&nbsp;.put_char&nbsp;= uart_put_char,<br>&nbsp;&nbsp;.flush_chars&nbsp;= uart_flush_chars,<br>&nbsp;&nbsp;.write_room&nbsp;= uart_write_room,<br>&nbsp;&nbsp;.chars_in_buffer= uart_chars_in_buffer,<br>&nbsp;&nbsp;.flush_buffer&nbsp;= uart_flush_buffer,<br>&nbsp;&nbsp;.ioctl&nbsp;&nbsp;= uart_ioctl,<br>&nbsp;&nbsp;.throttle&nbsp;= uart_throttle,<br>&nbsp;&nbsp;.unthrottle&nbsp;= uart_unthrottle,<br>&nbsp;&nbsp;.send_xchar&nbsp;= uart_send_xchar,<br>&nbsp;&nbsp;.set_termios&nbsp;= uart_set_termios,<br>&nbsp;&nbsp;.set_ldisc&nbsp;= uart_set_ldisc,<br>&nbsp;&nbsp;.stop&nbsp;&nbsp;= uart_stop,<br>&nbsp;&nbsp;.start&nbsp;&nbsp;= uart_start,<br>&nbsp;&nbsp;.hangup&nbsp;&nbsp;= uart_hangup,<br>&nbsp;&nbsp;.break_ctl&nbsp;= uart_break_ctl,<br>&nbsp;&nbsp;.wait_until_sent= uart_wait_until_sent,<br>&nbsp;#ifdef CONFIG_PROC_FS<br>&nbsp;&nbsp;.proc_fops&nbsp;= &amp;uart_proc_fops,<br>&nbsp;#endif<br>&nbsp;&nbsp;.tiocmget&nbsp;= uart_tiocmget,<br>&nbsp;&nbsp;.tiocmset&nbsp;= uart_tiocmset,<br>&nbsp;&nbsp;.get_icount&nbsp;= uart_get_icount,<br>&nbsp;#ifdef CONFIG_CONSOLE_POLL<br>&nbsp;&nbsp;.poll_init&nbsp;= uart_poll_init,<br>&nbsp;&nbsp;.poll_get_char&nbsp;= uart_poll_get_char,<br>&nbsp;&nbsp;.poll_put_char&nbsp;= uart_poll_put_char,<br>&nbsp;#endif<br>&nbsp;};<br>&nbsp;*/</p> 
   <p>&nbsp;for (i = 0; i &lt; drv-&gt;nr; i++) {//根据串口数量依次扫描drv-&gt;nr=3<br>&nbsp;&nbsp;struct uart_state *state = drv-&gt;state + i;//找到每个串口的uart_state地址<br>&nbsp;&nbsp;struct tty_port *port = &amp;state-&gt;port;//每个串口有一个tty_port结构<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//初始化每个串口的tty_port结构<br>&nbsp;&nbsp;tty_port_init(port);<br>&nbsp;&nbsp;port-&gt;ops = &amp;uart_port_ops;<br>&nbsp;&nbsp;port-&gt;close_delay&nbsp;&nbsp;&nbsp;&nbsp; = 500;&nbsp;/* .5 seconds */<br>&nbsp;&nbsp;port-&gt;closing_wait&nbsp;&nbsp;&nbsp; = 30000;&nbsp;/* 30 seconds */<br>&nbsp;&nbsp;tasklet_init(&amp;state-&gt;tlet, uart_tasklet_action,(unsigned long)state);<br>&nbsp;}<br>&nbsp;<br>&nbsp;//注册tty驱动<br>&nbsp;retval = tty_register_driver(normal);<br>&nbsp;if (retval &gt;= 0)<br>&nbsp;&nbsp;return retval;</p> 
   <p>&nbsp;put_tty_driver(normal);<br>out_kfree:<br>&nbsp;kfree(drv-&gt;state);<br>out:<br>&nbsp;return -ENOMEM;<br>}</p> 
   <p>//初始化串口的uart_port结构<br>static void __init serial8250_register_ports(struct uart_driver *drv, struct device *dev)<br>{<br>&nbsp;int i;<br>&nbsp;<br>&nbsp;//对uart_8250_port结构的serial8250_ports进行初始化<br>&nbsp;for (i = 0; i &lt; nr_uarts; i++) {//共3个串口<br>&nbsp;&nbsp;struct uart_8250_port *up = &amp;serial8250_ports[i];<br>&nbsp;&nbsp;up-&gt;cur_iotype = 0xFF;//先初始化为0xFF，在set_io_from_upio（）会赋值成uart_port-&gt;iotype（即UPIO_MEM=2）<br>&nbsp;}<br>&nbsp;<br>&nbsp;//对uart_8250_port结构的serial8250_ports[]接着进行初始化,主要是设置uart_port字段ops的操作<br>&nbsp;//由于此函数在初始化console时被调用过，所以现在调用的话会直接返回。即串口的uart_port的ops字段已经赋过值了<br>&nbsp;serial8250_isa_init_ports();</p> 
   <p>&nbsp;for (i = 0; i &lt; nr_uarts; i++) {//共3个串口<br>&nbsp;&nbsp;struct uart_8250_port *up = &amp;serial8250_ports[i];</p> 
   <p>&nbsp;&nbsp;up-&gt;port.dev = dev;//指向相应的struct device结构</p> 
   <p>&nbsp;&nbsp;if (up-&gt;port.flags &amp; UPF_FIXED_TYPE)//因为未进行serial8250_probe(),所以此标志未设置，不进入下边函数<br>&nbsp;&nbsp;&nbsp;serial8250_init_fixed_type_port(up, up-&gt;port.type);//设置串口type=PORT_AR7，即18<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//向设备添加端口,是在uart_driver增加一个port，在未进行serial8250_probe()之前，这个函数的串口配置操作会失败<br>&nbsp;&nbsp;//进行过serial8250_probe()后，还会再调用此函数，那时就可以配置好串口。<br>&nbsp;&nbsp;uart_add_one_port(drv, &amp;up-&gt;port);<br>&nbsp;}<br>}</p> 
   <p>static void __init serial8250_isa_init_ports(void)<br>{<br>&nbsp;struct uart_8250_port *up;<br>&nbsp;static int first = 1;<br>&nbsp;int i, irqflag = 0;</p> 
   <p>&nbsp;if (!first)//静态变量，serial8250_console_init（）第一次进入这个函数，之后serial8250_init()再进入这个函数就会直接返回<br>&nbsp;&nbsp;return;<br>&nbsp;first = 0;<br>&nbsp;<br>&nbsp;//对三个串口的uart_8250_port结构serial8250_ports结构体进行初始化<br>&nbsp;for (i = 0; i &lt; nr_uarts; i++) {<br>&nbsp;&nbsp;struct uart_8250_port *up = &amp;serial8250_ports[i];</p> 
   <p>&nbsp;&nbsp;up-&gt;port.line = i;//0代表串口0,1代表串口1<br>&nbsp;&nbsp;spin_lock_init(&amp;up-&gt;port.lock);</p> 
   <p>&nbsp;&nbsp;init_timer(&amp;up-&gt;timer);//初始化定时器<br>&nbsp;&nbsp;up-&gt;timer.function = serial8250_timeout;//初始化定时器的超时函数</p> 
   <p>&nbsp;&nbsp;//ALPHA_KLUDGE_MCR needs to be killed.<br>&nbsp;&nbsp;up-&gt;mcr_mask = ~ALPHA_KLUDGE_MCR;<br>&nbsp;&nbsp;up-&gt;mcr_force = ALPHA_KLUDGE_MCR;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//初始化uart_8250_port指向的uart_port字段port的操作<br>&nbsp;&nbsp;up-&gt;port.ops = &amp;serial8250_pops;<br>&nbsp;&nbsp;/*<br>&nbsp;&nbsp;static struct uart_ops serial8250_pops = {<br>&nbsp;&nbsp;&nbsp;.tx_empty&nbsp;= serial8250_tx_empty,<br>&nbsp;&nbsp;&nbsp;.set_mctrl&nbsp;= serial8250_set_mctrl,<br>&nbsp;&nbsp;&nbsp;.get_mctrl&nbsp;= serial8250_get_mctrl,<br>&nbsp;&nbsp;&nbsp;.stop_tx&nbsp;= serial8250_stop_tx,<br>&nbsp;&nbsp;&nbsp;.start_tx&nbsp;= serial8250_start_tx,<br>&nbsp;&nbsp;&nbsp;.stop_rx&nbsp;= serial8250_stop_rx,<br>&nbsp;&nbsp;&nbsp;.enable_ms&nbsp;= serial8250_enable_ms,<br>&nbsp;&nbsp;&nbsp;.break_ctl&nbsp;= serial8250_break_ctl,<br>&nbsp;&nbsp;&nbsp;.startup&nbsp;= serial8250_startup,<br>&nbsp;&nbsp;&nbsp;.shutdown&nbsp;= serial8250_shutdown,<br>&nbsp;&nbsp;&nbsp;.set_termios&nbsp;= serial8250_set_termios,<br>&nbsp;&nbsp;&nbsp;.set_ldisc&nbsp;= serial8250_set_ldisc,<br>&nbsp;&nbsp;&nbsp;.pm&nbsp;&nbsp;= serial8250_pm,<br>&nbsp;&nbsp;&nbsp;.type&nbsp;&nbsp;= serial8250_type,<br>&nbsp;&nbsp;&nbsp;.release_port&nbsp;= serial8250_release_port,<br>&nbsp;&nbsp;&nbsp;.request_port&nbsp;= serial8250_request_port,<br>&nbsp;&nbsp;&nbsp;.config_port&nbsp;= serial8250_config_port,<br>&nbsp;&nbsp;&nbsp;.verify_port&nbsp;= serial8250_verify_port,<br>&nbsp;&nbsp;#ifdef CONFIG_CONSOLE_POLL<br>&nbsp;&nbsp;&nbsp;.poll_get_char = serial8250_get_poll_char,<br>&nbsp;&nbsp;&nbsp;.poll_put_char = serial8250_put_poll_char,<br>&nbsp;&nbsp;#endif<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;*/<br>&nbsp;}</p> 
   <p>&nbsp;if (share_irqs)//中断是否共享（这里设置成不共享）<br>&nbsp;&nbsp;irqflag = IRQF_SHARED;<br>&nbsp;<br>&nbsp;//条件不满足，不会进来初始化<br>&nbsp;for (i = 0, up = serial8250_ports;i &lt; ARRAY_SIZE(old_serial_port) &amp;&amp; i &lt; nr_uarts;i++, up++) {<br>/*&nbsp;up-&gt;port.iobase&nbsp;&nbsp; = old_serial_port[i].port;<br>&nbsp;&nbsp;up-&gt;port.irq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = irq_canonicalize(old_serial_port[i].irq);<br>&nbsp;&nbsp;up-&gt;port.irqflags = old_serial_port[i].irqflags;<br>&nbsp;&nbsp;up-&gt;port.uartclk&nbsp; = old_serial_port[i].baud_base * 16;<br>&nbsp;&nbsp;up-&gt;port.flags&nbsp;&nbsp;&nbsp; = old_serial_port[i].flags;<br>&nbsp;&nbsp;up-&gt;port.hub6&nbsp;&nbsp;&nbsp;&nbsp; = old_serial_port[i].hub6;<br>&nbsp;&nbsp;up-&gt;port.membase&nbsp; = old_serial_port[i].iomem_base;<br>&nbsp;&nbsp;up-&gt;port.iotype&nbsp;&nbsp; = old_serial_port[i].io_type;<br>&nbsp;&nbsp;up-&gt;port.regshift = old_serial_port[i].iomem_reg_shift;<br>&nbsp;&nbsp;set_io_from_upio(&amp;up-&gt;port);<br>&nbsp;&nbsp;up-&gt;port.irqflags |= irqflag;<br>&nbsp;&nbsp;if (serial8250_isa_config != NULL)<br>&nbsp;&nbsp;&nbsp;serial8250_isa_config(i, &amp;up-&gt;port, &amp;up-&gt;capabilities);<br>*/<br>&nbsp;}<br>}</p> 
   <p>int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)<br>{<br>&nbsp;struct uart_state *state;<br>&nbsp;struct tty_port *port;<br>&nbsp;int ret = 0;<br>&nbsp;struct device *tty_dev;</p> 
   <p>&nbsp;BUG_ON(in_interrupt());//不能在中断中调用<br>&nbsp;<br>&nbsp;//Uart_port-&gt;line就是对uart设备文件序号.它对应的也就是uart_driver-&gt;state数组中的uart_port-&gt;line项.<br>&nbsp;if (uport-&gt;line &gt;= drv-&gt;nr)//在serial8250_isa_init_ports()已经初始化过，代表端口号，0代表串口0。<br>&nbsp;&nbsp;return -EINVAL;<br>&nbsp;<br>&nbsp;//根据串口号找到每个串口对应的uart_state结构<br>&nbsp;state = drv-&gt;state + uport-&gt;line;<br>&nbsp;port = &amp;state-&gt;port;//通过uart_state结构找到每个串口的tty_port结构</p> 
   <p>&nbsp;mutex_lock(&amp;port_mutex);<br>&nbsp;mutex_lock(&amp;port-&gt;mutex);<br>&nbsp;if (state-&gt;uart_port) {<br>&nbsp;&nbsp;ret = -EINVAL;<br>&nbsp;&nbsp;goto out;<br>&nbsp;}<br>&nbsp;<br>&nbsp;//将uart_state和uart_port结构相关联起来<br>&nbsp;state-&gt;uart_port = uport;&nbsp;<br>&nbsp;state-&gt;pm_state = -1;</p> 
   <p>&nbsp;uport-&gt;cons = drv-&gt;cons;//将uart_driver的serial8250_console成员赋值给uart_port成员<br>&nbsp;uport-&gt;state = state;//uart_port的state成员指向相应的uart_state</p> 
   <p>&nbsp; //If this port is a console, then the spinlock is already initialised.<br>&nbsp; //检查这个串口是否就是终端，并且此终端是否已经注册完毕<br>&nbsp;if (!(uart_console(uport) &amp;&amp; (uport-&gt;cons-&gt;flags &amp; CON_ENABLED))) {<br>&nbsp;&nbsp;spin_lock_init(&amp;uport-&gt;lock);<br>&nbsp;&nbsp;lockdep_set_class(&amp;uport-&gt;lock, &amp;port_lock_key);<br>&nbsp;}<br>&nbsp;<br>&nbsp;//进行port的自动配置，在未进行serial8250_probe()，串口的port-&gt;iobase、port-&gt;mapbase、port-&gt;membase都为空，所以函数进去会立即返回，即未配置成功。<br>&nbsp;//当进行完serial8250_probe()函数时，还会调用uart_add_one_port()，再到这个函数配置时就会配置成功<br>&nbsp;uart_configure_port(drv, state, uport);</p> 
   <p>&nbsp; //然后注册tty_device.如果用户空间运行了udev或者已经配置好了hotplug.就会在/dev下自动生成设备文件了.<br>&nbsp;tty_dev = tty_register_device(drv-&gt;tty_driver, uport-&gt;line, uport-&gt;dev);<br>&nbsp;if (likely(!IS_ERR(tty_dev))) {//设置设备的唤醒状态<br>&nbsp;&nbsp;device_init_wakeup(tty_dev, 1);<br>&nbsp;&nbsp;device_set_wakeup_enable(tty_dev, 0);<br>&nbsp;} else<br>&nbsp;&nbsp;printk(KERN_ERR "Cannot register tty device on line %d\n",uport-&gt;line);</p> 
   <p>&nbsp; //Ensure UPF_DEAD is not set.<br>&nbsp;uport-&gt;flags &amp;= ~UPF_DEAD;</p> 
   <p>&nbsp;out:<br>&nbsp;mutex_unlock(&amp;port-&gt;mutex);<br>&nbsp;mutex_unlock(&amp;port_mutex);</p> 
   <p>&nbsp;return ret;<br>}</p> 
   <p>static void uart_configure_port(struct uart_driver *drv, struct uart_state *state,struct uart_port *port)<br>{<br>&nbsp;unsigned int flags;</p> 
   <p>&nbsp;if (!port-&gt;iobase &amp;&amp; !port-&gt;mapbase &amp;&amp; !port-&gt;membase)//未调用serial8250_probe()之前，会从这里直接返回。<br>&nbsp;&nbsp;return;<br>&nbsp;<br>&nbsp;//调用serial8250_probe()之后，会接着往下进行<br>&nbsp;flags = 0;<br>&nbsp;if (port-&gt;flags &amp; UPF_AUTO_IRQ)//未设置此标志<br>&nbsp;&nbsp;flags |= UART_CONFIG_IRQ;<br>&nbsp;&nbsp;<br>&nbsp;if (port-&gt;flags &amp; UPF_BOOT_AUTOCONF) {//经过probe()函数，此标志已配置<br>&nbsp;&nbsp;if (!(port-&gt;flags &amp; UPF_FIXED_TYPE)) {//已设置该标志，下边的不会进入<br>&nbsp;&nbsp;&nbsp;port-&gt;type = PORT_UNKNOWN;//不会进入<br>&nbsp;&nbsp;&nbsp;flags |= UART_CONFIG_TYPE;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;port-&gt;ops-&gt;config_port(port, flags);//调用设备的自动配置函数，即serial8250_config_port()<br>&nbsp;}</p> 
   <p>&nbsp;if (port-&gt;type != PORT_UNKNOWN) {<br>&nbsp;&nbsp;unsigned long flags;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//打印串口的信息<br>&nbsp;&nbsp;uart_report_port(drv, port);</p> 
   <p>&nbsp;&nbsp;/* Power up port for set_mctrl() */<br>&nbsp;&nbsp;uart_change_pm(state, 0);////改变端口的电源状态，上电</p> 
   <p>&nbsp;&nbsp;spin_lock_irqsave(&amp;port-&gt;lock, flags);<br>&nbsp;&nbsp;port-&gt;ops-&gt;set_mctrl(port, port-&gt;mctrl &amp; TIOCM_DTR);////设置串口modem控制，调用serial8250_set_mctrl()<br>&nbsp;&nbsp;spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</p> 
   <p>&nbsp;&nbsp; //注册终端,配置终端的信息，若此端口有cons字段，并且console的注册不成功。注册成功CON_ENABLED标志为1<br>&nbsp;&nbsp;if (port-&gt;cons &amp;&amp; !(port-&gt;cons-&gt;flags &amp; CON_ENABLED))<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;/*serial8250_console_init()函数会比serial8250_probe()先调用,所以调用register_console的时候,port还没有初始化,所以当<br>&nbsp;&nbsp;&nbsp;&nbsp;register_console调用serial8250_console_setup()设置buad,parity bits的时候,<br>&nbsp;&nbsp;&nbsp;&nbsp;serial8250_console_setup()会检测port-&gt;iobase和port-&gt;membase是否是有效值,如果不是就返回,<br>&nbsp;&nbsp;&nbsp;&nbsp;放弃初始化console,所以实际上,console不是在serial8250_console_init()里边初始化。<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;当serial8250_probe()调用uart_add_one_port-&gt;uart_configure_port:又会调用register_console()，<br>&nbsp;&nbsp;&nbsp;&nbsp;在这里会将真正的console注册掉。<br>&nbsp;&nbsp;&nbsp;&nbsp;该函数会检查console有没有初始化,如果没有初始化,则调用register_console来初始化.<br>&nbsp;&nbsp;&nbsp;&nbsp;所以console放在这里初始化也是比较好一些.<br>&nbsp;&nbsp;&nbsp;*/<br>&nbsp;&nbsp;&nbsp;register_console(port-&gt;cons);//将该console注册到console_drivers链表上,最后调用release_console_sem,将printk缓冲的数据打印到ttyS2上<br>&nbsp;&nbsp;}</p> 
   <p>&nbsp;&nbsp;//检查此串口是否是终端，除了我们使用作为console的串口，其余的进行断电<br>&nbsp;&nbsp;if (!uart_console(port))//#define uart_console(port)&nbsp;((port)-&gt;cons &amp;&amp; (port)-&gt;cons-&gt;index == (port)-&gt;line)<br>&nbsp;&nbsp;&nbsp;uart_change_pm(state, 3);//除了我们使用的console，其余的进行断电<br>&nbsp;}<br>}</p> 
   <p>//注册设备serial8250_isa_driver时，会调用此函数<br>static int __devinit serial8250_probe(struct platform_device *dev)<br>{<br>&nbsp;//传入的参数就是da8xx_serial_device<br>&nbsp;/*struct platform_device da8xx_serial_device = {//platform_device就描述了设备对象。<br>&nbsp;&nbsp;.name&nbsp;= "serial8250",<br>&nbsp;&nbsp;.id&nbsp;= PLAT8250_DEV_PLATFORM,<br>&nbsp;&nbsp;.dev&nbsp;= {<br>&nbsp;&nbsp;&nbsp;.platform_data&nbsp;= da8xx_serial_pdata,//这个platform_device对象的私有数据指成员向一个plat_serial8250_port类型的数组。在这里该数组描述了三个串口接口的基本信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当8250驱动检测到这个platform_device对象后，就分析该对象的私有数据成员指向的那个plat_serial8250_port类型的数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//然后根据该数组的每个成员描述的信息生成一个串口对象设备。<br>&nbsp;&nbsp;},<br>&nbsp;};<br>&nbsp;<br>&nbsp;static struct plat_serial8250_port da8xx_serial_pdata[] = {<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;.mapbase&nbsp;= DA8XX_UART0_BASE,//串口接口寄存器物理地址的基地址,#define DAVINCI_UART0_BASE&nbsp;(IO_PHYS + 0x20000)（见/arch/arm/mach-davinci/include/mach/serial.h）<br>&nbsp;&nbsp;&nbsp;.irq&nbsp;&nbsp;= IRQ_DA8XX_UARTINT0,//该串口接口使用的中断号, #define IRQ_DA8XX_UARTINT0&nbsp; 25,（在/arch/arm/mach-davinci/include/mach/irqs.h）<br>&nbsp;&nbsp;&nbsp;.flags&nbsp;&nbsp;= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_IOREMAP | UPF_FIXED_TYPE,<br>&nbsp;&nbsp;&nbsp;.type&nbsp;&nbsp;= PORT_AR7,//串口0类型<br>&nbsp;&nbsp;&nbsp;.iotype&nbsp;&nbsp;= UPIO_MEM,//成员表示该串口接口寄存器的地址类型，8位的内存地址&nbsp;<br>&nbsp;&nbsp;&nbsp;.regshift&nbsp;= 2,//在访问该串口接口的某个寄存器时，需把该寄存器的号左移多少位然后加基地址（不管是物理或虚拟地址）才能得能到这个寄存器的址址<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;.mapbase&nbsp;= DA8XX_UART1_BASE, //DAVINCI_UART1_BASE&nbsp;(IO_PHYS + 0x20400)<br>&nbsp;&nbsp;&nbsp;.irq&nbsp;&nbsp;= IRQ_DA8XX_UARTINT1, //中断号是53<br>&nbsp;&nbsp;&nbsp;.flags&nbsp;&nbsp;= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |UPF_IOREMAP | UPF_FIXED_TYPE,<br>&nbsp;&nbsp;&nbsp;.type&nbsp;&nbsp;= PORT_AR7,<br>&nbsp;&nbsp;&nbsp;.iotype&nbsp;&nbsp;= UPIO_MEM,<br>&nbsp;&nbsp;&nbsp;.regshift&nbsp;= 2,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;.mapbase&nbsp;= DA8XX_UART2_BASE, //#define DAVINCI_UART2_BASE&nbsp;(IO_PHYS + 0x20800)<br>&nbsp;&nbsp;&nbsp;.irq&nbsp;&nbsp;= IRQ_DA8XX_UARTINT2, //中断号是61<br>&nbsp;&nbsp;&nbsp;.flags&nbsp;&nbsp;= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |UPF_IOREMAP | UPF_FIXED_TYPE,<br>&nbsp;&nbsp;&nbsp;.type&nbsp;&nbsp;= PORT_AR7,<br>&nbsp;&nbsp;&nbsp;.iotype&nbsp;&nbsp;= UPIO_MEM,<br>&nbsp;&nbsp;&nbsp;.regshift&nbsp;= 2,<br>&nbsp;&nbsp;},<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;.flags&nbsp;= 0,<br>&nbsp;&nbsp;},<br>&nbsp;};*/<br>&nbsp;struct plat_serial8250_port *p = dev-&gt;dev.platform_data;<br>&nbsp;struct uart_port port;<br>&nbsp;int ret, i, irqflag = 0;</p> 
   <p>&nbsp;memset(&amp;port, 0, sizeof(struct uart_port));</p> 
   <p>&nbsp;if (share_irqs)<br>&nbsp;&nbsp;irqflag = IRQF_SHARED;<br>&nbsp;&nbsp;<br>&nbsp;// 会 将 dev-&gt;dev.platform_data 所代表的 port 添加到 uart_driver 中<br>&nbsp;for (i = 0; p &amp;&amp; p-&gt;flags != 0; p++, i++) {//遍历三个串口<br>&nbsp;&nbsp;port.iobase&nbsp;&nbsp;= p-&gt;iobase;<br>&nbsp;&nbsp;port.membase&nbsp;&nbsp;= p-&gt;membase;<br>&nbsp;&nbsp;port.irq&nbsp;&nbsp;= p-&gt;irq;//中断号<br>&nbsp;&nbsp;port.irqflags&nbsp;&nbsp;= p-&gt;irqflags;<br>&nbsp;&nbsp;port.uartclk&nbsp;&nbsp;= p-&gt;uartclk;//时钟<br>&nbsp;&nbsp;port.regshift&nbsp;&nbsp;= p-&gt;regshift;//寄存器偏移量 2<br>&nbsp;&nbsp;port.iotype&nbsp;&nbsp;= p-&gt;iotype;//IO类型<br>&nbsp;&nbsp;port.flags&nbsp;&nbsp;= p-&gt;flags;//标志<br>&nbsp;&nbsp;port.mapbase&nbsp;&nbsp;= p-&gt;mapbase;//串口接口寄存器物理地址的基地址<br>&nbsp;&nbsp;port.hub6&nbsp;&nbsp;= p-&gt;hub6;<br>&nbsp;&nbsp;port.private_data&nbsp;= p-&gt;private_data;<br>&nbsp;&nbsp;port.type&nbsp;&nbsp;= p-&gt;type;//PORT_AR7,串口类型<br>&nbsp;&nbsp;port.serial_in&nbsp;&nbsp;= p-&gt;serial_in;<br>&nbsp;&nbsp;port.serial_out&nbsp;&nbsp;= p-&gt;serial_out;<br>&nbsp;&nbsp;port.set_termios&nbsp;= p-&gt;set_termios;<br>&nbsp;&nbsp;port.pm&nbsp;&nbsp;&nbsp;= p-&gt;pm;<br>&nbsp;&nbsp;port.dev&nbsp;&nbsp;= &amp;dev-&gt;dev;<br>&nbsp;&nbsp;port.irqflags&nbsp;&nbsp;|= irqflag;<br>&nbsp;&nbsp;if (p-&gt;clk)<br>&nbsp;&nbsp;&nbsp;serial8250_ports[i].clk = p-&gt;clk;<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//再重新注册串口<br>&nbsp;&nbsp;ret = serial8250_register_port(&amp;port);<br>&nbsp;&nbsp;if (ret &lt; 0) {<br>&nbsp;&nbsp;&nbsp;dev_err(&amp;dev-&gt;dev, "unable to register port at index %d ""(IO%lx MEM%llx IRQ%d): %d\n", i,p-&gt;iobase, (unsigned long long)p-&gt;mapbase,p-&gt;irq, ret);<br>&nbsp;&nbsp;}<br>&nbsp;}<br>&nbsp;return 0;//到这里串口的初始化就结束!!!!<br>}</p> 
   <p>int serial8250_register_port(struct uart_port *port)<br>{<br>&nbsp;struct uart_8250_port *uart;<br>&nbsp;int ret = -ENOSPC;</p> 
   <p>&nbsp;if (port-&gt;uartclk == 0)<br>&nbsp;&nbsp;return -EINVAL;</p> 
   <p>&nbsp;mutex_lock(&amp;serial_mutex);<br>&nbsp;<br>&nbsp;//查找在serial8250_ports[]数组中是否已有记录<br>&nbsp;uart = serial8250_find_match_or_unused(port);<br>&nbsp;if (uart) {//都会查到有记录<br>&nbsp;&nbsp;uart_remove_one_port(&amp;serial8250_reg, &amp;uart-&gt;port);//把原来的串口移除掉，再重新添加<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//串口的uart_port再赋值<br>&nbsp;&nbsp;uart-&gt;port.iobase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;iobase;<br>&nbsp;&nbsp;uart-&gt;port.membase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;membase;<br>&nbsp;&nbsp;uart-&gt;port.irq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;irq;<br>&nbsp;&nbsp;uart-&gt;port.irqflags&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;irqflags;<br>&nbsp;&nbsp;uart-&gt;port.uartclk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;uartclk;<br>&nbsp;&nbsp;uart-&gt;port.fifosize&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;fifosize;<br>&nbsp;&nbsp;uart-&gt;port.regshift&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;regshift;<br>&nbsp;&nbsp;uart-&gt;port.iotype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;iotype;<br>&nbsp;&nbsp;uart-&gt;port.flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;flags | UPF_BOOT_AUTOCONF;<br>&nbsp;&nbsp;uart-&gt;port.mapbase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = port-&gt;mapbase;<br>&nbsp;&nbsp;uart-&gt;port.private_data = port-&gt;private_data;<br>&nbsp;&nbsp;if (port-&gt;dev)<br>&nbsp;&nbsp;&nbsp;uart-&gt;port.dev = port-&gt;dev;</p> 
   <p>&nbsp;&nbsp;if (port-&gt;flags &amp; UPF_FIXED_TYPE)//probe()进行时，此标志已设置<br>&nbsp;&nbsp;&nbsp;serial8250_init_fixed_type_port(uart, port-&gt;type);//设置串口type=PORT_AR7，即18</p> 
   <p>&nbsp;&nbsp;set_io_from_upio(&amp;uart-&gt;port);//设置串口的读写函数<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//如果传进来的参数此成员有值，用原来的。实际时原来此成员变量为空，da8xx_serial_pdata变量中未赋值<br>&nbsp;&nbsp;if (port-&gt;serial_in)<br>&nbsp;&nbsp;&nbsp;uart-&gt;port.serial_in = port-&gt;serial_in;<br>&nbsp;&nbsp;if (port-&gt;serial_out)<br>&nbsp;&nbsp;&nbsp;uart-&gt;port.serial_out = port-&gt;serial_out;<br>&nbsp;&nbsp;if (port-&gt;set_termios)<br>&nbsp;&nbsp;&nbsp;uart-&gt;port.set_termios = port-&gt;set_termios;<br>&nbsp;&nbsp;if (port-&gt;pm)<br>&nbsp;&nbsp;&nbsp;uart-&gt;port.pm = port-&gt;pm;</p> 
   <p>&nbsp;&nbsp;if (serial8250_isa_config != NULL)<br>&nbsp;&nbsp;&nbsp;serial8250_isa_config(0, &amp;uart-&gt;port,&amp;uart-&gt;capabilities);<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;//再重新添加串口，这时配置串口就能成功<br>&nbsp;&nbsp;ret = uart_add_one_port(&amp;serial8250_reg, &amp;uart-&gt;port);<br>&nbsp;&nbsp;if (ret == 0)<br>&nbsp;&nbsp;&nbsp;ret = uart-&gt;port.line;</p> 
   <p>&nbsp;&nbsp;ret = serial8250_cpufreq_register(uart);<br>&nbsp;&nbsp;if (ret &lt; 0)<br>&nbsp;&nbsp;&nbsp;printk(KERN_ERR "Failed to add cpufreq notifier\n");<br>&nbsp;}<br>&nbsp;mutex_unlock(&amp;serial_mutex);</p> 
   <p>&nbsp;return ret;<br>}</p> 
   <p>static void serial8250_config_port(struct uart_port *port, int flags)<br>{<br>&nbsp;struct uart_8250_port *up = (struct uart_8250_port *)port;<br>&nbsp;int probeflags = PROBE_ANY;<br>&nbsp;int ret;</p> 
   <p>&nbsp;if (cpu_is_davinci_da850())//是否为达芬奇平台<br>&nbsp;&nbsp;up-&gt;bugs |= UART_BUG_NOMSR;</p> 
   <p>&nbsp;ret = serial8250_request_std_resource(up);//分配内存资源,IO资源<br>&nbsp;if (ret &lt; 0)<br>&nbsp;&nbsp;return;</p> 
   <p>&nbsp;ret = serial8250_request_rsa_resource(up);//会返回失败<br>&nbsp;if (ret &lt; 0)<br>&nbsp;&nbsp;probeflags &amp;= ~PROBE_RSA;//清除PROBE_RSA标志<br>&nbsp;<br>&nbsp;//up-&gt;cur_iotype在serial8250_register_ports（）设置成0xFF，<br>&nbsp;//而up-&gt;port.iotype在serial8250_isa_init_ports()被设置为UPIO_MEM，即2<br>&nbsp;if (up-&gt;port.iotype != up-&gt;cur_iotype)<br>&nbsp;&nbsp;set_io_from_upio(port);//设置uart_port结构的serial_in函数和serial_out函数</p> 
   <p>&nbsp;if (flags &amp; UART_CONFIG_TYPE)//此标志没有被设置<br>&nbsp;&nbsp;autoconfig(up, probeflags);//不会调用</p> 
   <p>&nbsp;if (up-&gt;port.type == PORT_16550A &amp;&amp; up-&gt;port.iotype == UPIO_AU)<br>&nbsp;&nbsp;up-&gt;bugs |= UART_BUG_NOMSR;</p> 
   <p>&nbsp;if (up-&gt;port.type != PORT_UNKNOWN &amp;&amp; flags &amp; UART_CONFIG_IRQ)//此标志UART_CONFIG_IRQ未设置<br>&nbsp;&nbsp;autoconfig_irq(up);//不会调用<br>&nbsp;<br>&nbsp;//以下不会调用<br>&nbsp;if (up-&gt;port.type != PORT_RSA &amp;&amp; probeflags &amp; PROBE_RSA)<br>&nbsp;&nbsp;serial8250_release_rsa_resource(up);<br>&nbsp;if (up-&gt;port.type == PORT_UNKNOWN)<br>&nbsp;&nbsp;serial8250_release_std_resource(up);<br>}</p> 
   <p>static int serial8250_request_std_resource(struct uart_8250_port *up)<br>{<br>&nbsp;unsigned int size = serial8250_port_size(up);<br>&nbsp;int ret = 0;</p> 
   <p>&nbsp;switch (up-&gt;port.iotype) {//up-&gt;port.iotype == UPIO_MEM<br>&nbsp;case UPIO_AU:<br>&nbsp;case UPIO_TSI:<br>&nbsp;case UPIO_MEM32:<br>&nbsp;case UPIO_MEM:<br>&nbsp;case UPIO_DWAPB:<br>&nbsp;&nbsp;if (!up-&gt;port.mapbase)<br>&nbsp;&nbsp;&nbsp;break;</p> 
   <p>&nbsp;&nbsp;if (!request_mem_region(up-&gt;port.mapbase, size, "serial")) {<br>&nbsp;&nbsp;&nbsp;ret = -EBUSY;<br>&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;}</p> 
   <p>&nbsp;&nbsp;if (up-&gt;port.flags &amp; UPF_IOREMAP) {//如果前边映射过了，UPF_IOREMAP被清零了，这里就不需再映射了<br>&nbsp;&nbsp;&nbsp;up-&gt;port.membase = ioremap_nocache(up-&gt;port.mapbase,size);<br>&nbsp;&nbsp;&nbsp;if (!up-&gt;port.membase) {<br>&nbsp;&nbsp;&nbsp;&nbsp;release_mem_region(up-&gt;port.mapbase, size);<br>&nbsp;&nbsp;&nbsp;&nbsp;ret = -ENOMEM;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;case UPIO_HUB6:<br>&nbsp;case UPIO_PORT:<br>&nbsp;&nbsp;if (!request_region(up-&gt;port.iobase, size, "serial"))<br>&nbsp;&nbsp;&nbsp;ret = -EBUSY;<br>&nbsp;&nbsp;break;<br>&nbsp;}<br>&nbsp;return ret;<br>}</p> 
   <p>static void set_io_from_upio(struct uart_port *p)<br>{<br>&nbsp;struct uart_8250_port *up = (struct uart_8250_port *)p;<br>&nbsp;switch (p-&gt;iotype) {<br>&nbsp;case UPIO_HUB6:<br>&nbsp;&nbsp;p-&gt;serial_in = hub6_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = hub6_serial_out;<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;case UPIO_MEM://p-&gt;iotype=2，采用这里的读写函数<br>&nbsp;&nbsp;p-&gt;serial_in = mem_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = mem_serial_out;<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;case UPIO_RM9000:<br>&nbsp;case UPIO_MEM32:<br>&nbsp;&nbsp;p-&gt;serial_in = mem32_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = mem32_serial_out;<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;case UPIO_AU:<br>&nbsp;&nbsp;p-&gt;serial_in = au_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = au_serial_out;<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;case UPIO_TSI:<br>&nbsp;&nbsp;p-&gt;serial_in = tsi_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = tsi_serial_out;<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;case UPIO_DWAPB:<br>&nbsp;&nbsp;p-&gt;serial_in = mem_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = dwapb_serial_out;<br>&nbsp;&nbsp;break;</p> 
   <p>&nbsp;default:<br>&nbsp;&nbsp;p-&gt;serial_in = io_serial_in;<br>&nbsp;&nbsp;p-&gt;serial_out = io_serial_out;<br>&nbsp;&nbsp;break;<br>&nbsp;}<br>&nbsp;/* Remember loaded iotype */<br>&nbsp;up-&gt;cur_iotype = p-&gt;iotype;//注意要赋值<br>}</p> 
   <p>static inline void uart_report_port(struct uart_driver *drv, struct uart_port *port)<br>{<br>&nbsp;char address[64];</p> 
   <p>&nbsp;switch (port-&gt;iotype) {//port-&gt;iotype == UPIO_MEM<br>&nbsp;case UPIO_PORT:<br>&nbsp;&nbsp;snprintf(address, sizeof(address), "I/O 0x%lx", port-&gt;iobase);<br>&nbsp;&nbsp;break;<br>&nbsp;case UPIO_HUB6:<br>&nbsp;&nbsp;snprintf(address, sizeof(address),"I/O 0x%lx offset 0x%x", port-&gt;iobase, port-&gt;hub6);<br>&nbsp;&nbsp;break;<br>&nbsp;case UPIO_MEM:<br>&nbsp;case UPIO_MEM32:<br>&nbsp;case UPIO_AU:<br>&nbsp;case UPIO_TSI:<br>&nbsp;case UPIO_DWAPB:<br>&nbsp;&nbsp;snprintf(address, sizeof(address), "MMIO 0x%llx", (unsigned long long)port-&gt;mapbase);<br>&nbsp;&nbsp;break;<br>&nbsp;default:<br>&nbsp;&nbsp;strlcpy(address, "*unknown*", sizeof(address));<br>&nbsp;&nbsp;break;<br>&nbsp;}<br>&nbsp;/*打印出的信息如下：<br>&nbsp;serial8250.0: ttyS0 at MMIO 0x1c42000 (irq = 25) is a AR7<br>&nbsp;serial8250.0: ttyS1 at MMIO 0x1d0c000 (irq = 53) is a AR7<br>&nbsp;serial8250.0: ttyS2 at MMIO 0x1d0d000 (irq = 61) is a AR7<br>&nbsp;*/<br>&nbsp;printk(KERN_INFO "%s%s%s%d at %s (irq = %d) is a %s\n",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port-&gt;dev ? dev_name(port-&gt;dev) : "",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; port-&gt;dev ? ": " : "",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drv-&gt;dev_name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drv-&gt;tty_driver-&gt;name_base + port-&gt;line,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; address, port-&gt;irq, uart_type(port));<br>}</p> 
   <p>//下边再次调用register_console()注册serial8250_console真正的console终端<br>void register_console(struct console *newcon)<br>{<br>&nbsp;int i;<br>&nbsp;unsigned long flags;<br>&nbsp;struct console *bcon = NULL;<br>&nbsp;/*<br>&nbsp;现在是注册一个serial8250_console，即<br>&nbsp;static struct console serial8250_console = {<br>&nbsp;&nbsp;.name&nbsp;&nbsp;= "ttyS",<br>&nbsp;&nbsp;.write&nbsp;&nbsp;= serial8250_console_write,//写方法<br>&nbsp;&nbsp;.device&nbsp;&nbsp;= uart_console_device,//tty驱动<br>&nbsp;&nbsp;.setup&nbsp;&nbsp;= serial8250_console_setup,//设置串口波特率，也就是设置串口。很重要，里面涉及到平台特性，波特率相关。<br>&nbsp;&nbsp;.early_setup&nbsp;= serial8250_console_early_setup,<br>&nbsp;&nbsp;.flags&nbsp;&nbsp;= CON_PRINTBUFFER | CON_ANYTIME,<br>&nbsp;&nbsp;.index&nbsp;&nbsp;= -1,<br>&nbsp;&nbsp;.data&nbsp;&nbsp;= &amp;serial8250_reg,<br>&nbsp;};<br>&nbsp;*/<br>&nbsp;if (console_drivers &amp;&amp; newcon-&gt;flags &amp; CON_BOOT) {//注册的是serial8250_console，CON_BOOT没有置位，不是引导控制台。下边不会进去遍历<br>&nbsp;&nbsp;for_each_console(bcon) {////遍历全局console_drivers数组&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;if (!(bcon-&gt;flags &amp; CON_BOOT)) {//判断是否已经有引导控制台了,有了的话就直接退出<br>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO "Too late to register bootconsole %s%d\n",newcon-&gt;name, newcon-&gt;index);<br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;}<br>&nbsp;<br>&nbsp;if (console_drivers &amp;&amp; console_drivers-&gt;flags &amp; CON_BOOT)//如果注册的是引导控制台，serial8250_console不是引导控制台<br>&nbsp;&nbsp;bcon = console_drivers;//这里不执行</p> 
   <p>&nbsp;if (preferred_console &lt; 0 || bcon || !console_drivers)<br>&nbsp;&nbsp;preferred_console = selected_console;//设置preferred_console为uboot命令选择的selected_console(即在Uboot传入的参数“console=ttyS2,115200n8”在console_cmdline[]数组中的索引)&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里preferred_console =0<br>&nbsp;if (newcon-&gt;early_setup)//serial8250_console初始化early_setup字段<br>&nbsp;&nbsp;newcon-&gt;early_setup();//调用serial8250_console_early_setup()</p> 
   <p><br>&nbsp;if (preferred_console &lt; 0) {//由于preferred_console =0，不会进入下边<br>&nbsp;&nbsp;if (newcon-&gt;index &lt; 0)<br>&nbsp;&nbsp;&nbsp;newcon-&gt;index = 0;<br>&nbsp;&nbsp;if (newcon-&gt;setup == NULL ||newcon-&gt;setup(newcon, NULL) == 0) {<br>&nbsp;&nbsp;&nbsp;newcon-&gt;flags |= CON_ENABLED;<br>&nbsp;&nbsp;&nbsp;if (newcon-&gt;device) {<br>&nbsp;&nbsp;&nbsp;&nbsp;newcon-&gt;flags |= CON_CONSDEV;<br>&nbsp;&nbsp;&nbsp;&nbsp;preferred_console = 0;<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;}</p> 
   <p>&nbsp; //传给内核参数:<br>&nbsp; //Kernel command line: console=ttyS2,115200n8 rw root=/dev/ram0 initrd=0xc2000000,20M mem=128M ip=192.168.1.220::192.168.1.1:255.255.255.0::eth0:off<br>&nbsp; //所以这里将根据传参console=ttyS2,115200来配置作为console的ttyS2串口<br>&nbsp;for (i = 0; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[0];i++) {//遍历全局console_cmdline找到匹配的，i=0就是匹配的“ttyS2”<br>&nbsp;&nbsp;if (strcmp(console_cmdline[i].name, newcon-&gt;name) != 0)//比较终端名称“ttyS”<br>&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;if (newcon-&gt;index &gt;= 0 &amp;&amp;newcon-&gt;index != console_cmdline[i].index)//console_cmdline[i].index=2。//比较次设备号&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;continue;<br>&nbsp;&nbsp;if (newcon-&gt;index &lt; 0)<br>&nbsp;&nbsp;&nbsp;newcon-&gt;index = console_cmdline[i].index;//将终端号赋值给serial8250_console-&gt;index，这里是2<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;//console_cmdline[i].options = "115200n8"，对于serial8250_console而言setup字段已初始化<br>&nbsp;&nbsp;if (newcon-&gt;setup &amp;&amp; newcon-&gt;setup(newcon, console_cmdline[i].options) != 0)//调用serial8250_console_setup()对终端进行配置，未probe()前调用不成功，probe()后调用成功。<br>&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;//在这里注册serial8250_console时，调用serial8250_console_setup()由于port-&gt;iobase和port-&gt;membase不是有效值，<br>&nbsp;&nbsp;//故返回错误，这样下边的操作不会执行，直接break跳出，从flag1出跳出函数。即在这里serial8250_console没有注册成功<br>&nbsp;&nbsp;//由于内核在下边的操作队串口进行初始化时，还会调用register_console（）来注册serial8250_console，在那时注册就会成功<br>&nbsp;&nbsp;<br>&nbsp;&nbsp;newcon-&gt;flags |= CON_ENABLED; //设置标志为CON_ENABLE,表示console使能(这个在printk调用中使用到)&nbsp;<br>&nbsp;&nbsp;newcon-&gt;index = console_cmdline[i].index;//设置索引号&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;if (i == selected_console) { //索引号和uboot指定的console的一样&nbsp;<br>&nbsp;&nbsp;&nbsp;newcon-&gt;flags |= CON_CONSDEV;//设置标志CON_CONSDEV(全局console_drivers链表中靠前)&nbsp;<br>&nbsp;&nbsp;&nbsp;preferred_console = selected_console;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;break;<br>&nbsp;}//for循环作用大致是查看注册的console是否是uboot知道的引导console，是则设置相关标志和preferred_console</p> 
   <p>&nbsp; //flag1：<br>&nbsp;if (!(newcon-&gt;flags &amp; CON_ENABLED))//若前边没有设置CON_ENABLED标志，就退出。若进行过probe（）,CON_ENABLED置位，这里就往下接着注册console<br>&nbsp;&nbsp;return;</p> 
   <p>&nbsp;if (bcon &amp;&amp; ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV))//防止重复打印&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;newcon-&gt;flags &amp;= ~CON_PRINTBUFFER;</p> 
   <p>&nbsp;acquire_console_sem();<br>&nbsp;if ((newcon-&gt;flags &amp; CON_CONSDEV) || console_drivers == NULL) {//如果是preferred控制台，此标志CON_CONSDEV在前边已设置过<br>&nbsp;&nbsp;newcon-&gt;next = console_drivers;<br>&nbsp;&nbsp;console_drivers = newcon;//添加进全局console_drivers链表前面位置（printk中会遍历该表调用合适的console的write方法打印信息）<br>&nbsp;&nbsp;if (newcon-&gt;next)<br>&nbsp;&nbsp;&nbsp;newcon-&gt;next-&gt;flags &amp;= ~CON_CONSDEV;<br>&nbsp;} else {//如果不是preferred控制台&nbsp;<br>&nbsp;&nbsp;newcon-&gt;next = console_drivers-&gt;next;<br>&nbsp;&nbsp;console_drivers-&gt;next = newcon; //添加进全局console_drivers链表后面位置<br>&nbsp;}<br>&nbsp;<br>&nbsp;//主册console主要是刷选preferred_console放置在全局console_drivers链表前面,剩下的console放置链表靠后的位置,并设置相应的flags,<br>&nbsp;//console_drivers最终会在printk函数的层层调用中遍历到,并调用console的write方法将信息打印出来</p> 
   <p>&nbsp;if (newcon-&gt;flags &amp; CON_PRINTBUFFER) {<br>&nbsp;&nbsp;spin_lock_irqsave(&amp;logbuf_lock, flags);<br>&nbsp;&nbsp;con_start = log_start;<br>&nbsp;&nbsp;spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br>&nbsp;}<br>&nbsp;release_console_sem();</p> 
   <p>&nbsp;if (bcon &amp;&amp; ((newcon-&gt;flags &amp; (CON_CONSDEV | CON_BOOT)) == CON_CONSDEV)) {<br>&nbsp;&nbsp;printk(KERN_INFO "console [%s%d] enabled, bootconsole disabled\n",newcon-&gt;name, newcon-&gt;index);<br>&nbsp;&nbsp;for_each_console(bcon)<br>&nbsp;&nbsp;&nbsp;if (bcon-&gt;flags &amp; CON_BOOT)<br>&nbsp;&nbsp;&nbsp;&nbsp;unregister_console(bcon);<br>&nbsp;} else {//调用这里<br>&nbsp;&nbsp;printk(KERN_INFO "%sconsole [%s%d] enabled\n",(newcon-&gt;flags &amp; CON_BOOT) ? "boot" : "" ,newcon-&gt;name, newcon-&gt;index);<br>&nbsp;}<br>}</p> 
   <p>//serial8250_console_early_setup()--&gt;serial8250_find_port_for_earlycon()<br>int serial8250_find_port_for_earlycon(void)<br>{<br>&nbsp;struct early_serial8250_device *device = &amp;early_device;//early console初始化时对early_device结构的初始化<br>&nbsp;struct uart_port *port = &amp;device-&gt;port;<br>&nbsp;int line;<br>&nbsp;int ret;</p> 
   <p>&nbsp;if (!device-&gt;port.membase &amp;&amp; !device-&gt;port.iobase)//early_device结构初始化时已经配置好<br>&nbsp;&nbsp;return -ENODEV;<br>&nbsp;//early console注册时不会调用此函数。<br>&nbsp;//当真正的console初始化时，会调用此函数。<br>&nbsp;//真正的console初始化时，会查找early console注册时用的是哪一个串口号，从serial8250_ports[]中根据uart_port-&gt;mapbase地址来比对<br>&nbsp;line = serial8250_find_port(port);//根据uart_port结构找到串口号，比对没有找到串口号，line返回负值<br>&nbsp;if (line &lt; 0)<br>&nbsp;&nbsp;return -ENODEV;//从这里返回，下边的不再执行<br>&nbsp;<br>&nbsp;//若找到early console用的串口号，更新当初传入内核参数使用的console_cmdline[i]，名称改成ttyS。。。。<br>&nbsp;ret = update_console_cmdline("uart", 8250, "ttyS", line, device-&gt;options);<br>&nbsp;if (ret &lt; 0)<br>&nbsp;&nbsp;ret = update_console_cmdline("uart", 0,"ttyS", line, device-&gt;options);</p> 
   <p>&nbsp;return ret;<br>}</p> 
   <p>static int __init serial8250_console_setup(struct console *co, char *options)<br>{<br>&nbsp;struct uart_port *port;<br>&nbsp;int baud = 9600;<br>&nbsp;int bits = 8;<br>&nbsp;int parity = 'n';<br>&nbsp;int flow = 'n';</p> 
   <p>&nbsp;if (co-&gt;index &gt;= nr_uarts)//console的索引，这里是2，即ttyS2<br>&nbsp;&nbsp;co-&gt;index = 0;<br>&nbsp;port = &amp;serial8250_ports[co-&gt;index].port;//找到对应的ttyS2的uart_port结构<br>&nbsp;<br>&nbsp;//由于console_init在注册serial8250_console时调用的register_console()函数调用serial8250_console_setup()<br>&nbsp;//进入这个函数时，由于ttyS2的uart_port结构没有初始化，port-&gt;iobase 和port-&gt;membase值都未设置，所以直接从下边返回<br>&nbsp;//当进行串口初始化时，还会回来注册serial8250_console，再调用到这里，由于设置了ttyS2的uart_port结构，所以下边的配置就会成功<br>&nbsp;if (!port-&gt;iobase &amp;&amp; !port-&gt;membase)//第一次注册时，由于未设置，从这里直接返回<br>&nbsp;&nbsp;return -ENODEV;</p> 
   <p>&nbsp;if (options)//如果options不为空，就将options里的数值写给baud, &amp;parity, &amp;bits, &amp;flow<br>&nbsp;&nbsp;uart_parse_options(options, &amp;baud, &amp;parity, &amp;bits, &amp;flow);<br>&nbsp;//没有配置options，则使用缺省值，否则使用传下来的的参数options里的串口配置<br>&nbsp;return uart_set_options(port, co, baud, parity, bits, flow);<br>}</p> 
   <p>void uart_parse_options(char *options, int *baud, int *parity, int *bits, int *flow)<br>{<br>&nbsp;char *s = options;</p> 
   <p>&nbsp;*baud = simple_strtoul(s, NULL, 10);<br>&nbsp;while (*s &gt;= '0' &amp;&amp; *s &lt;= '9')<br>&nbsp;&nbsp;s++;<br>&nbsp;if (*s)<br>&nbsp;&nbsp;*parity = *s++;<br>&nbsp;if (*s)<br>&nbsp;&nbsp;*bits = *s++ - '0';<br>&nbsp;if (*s)<br>&nbsp;&nbsp;*flow = *s;<br>}</p> 
   <p>int uart_set_options(struct uart_port *port, struct console *co,int baud, int parity, int bits, int flow)<br>{<br>&nbsp;struct ktermios termios;<br>&nbsp;static struct ktermios dummy;<br>&nbsp;int i;</p> 
   <p>&nbsp;//Ensure that the serial console lock is initialised early.<br>&nbsp;spin_lock_init(&amp;port-&gt;lock);<br>&nbsp;lockdep_set_class(&amp;port-&gt;lock, &amp;port_lock_key);</p> 
   <p>&nbsp;memset(&amp;termios, 0, sizeof(struct ktermios));<br>&nbsp;termios.c_cflag = CREAD | HUPCL | CLOCAL;</p> 
   <p>&nbsp;//Construct a cflag setting.<br>&nbsp;for (i = 0; baud_rates[i].rate; i++)<br>&nbsp;&nbsp;if (baud_rates[i].rate &lt;= baud)<br>&nbsp;&nbsp;&nbsp;break;</p> 
   <p>&nbsp;termios.c_cflag |= baud_rates[i].cflag;</p> 
   <p>&nbsp;if (bits == 7)<br>&nbsp;&nbsp;termios.c_cflag |= CS7;<br>&nbsp;else<br>&nbsp;&nbsp;termios.c_cflag |= CS8;</p> 
   <p>&nbsp;switch (parity) {<br>&nbsp;case 'o': case 'O':<br>&nbsp;&nbsp;termios.c_cflag |= PARODD;<br>&nbsp;&nbsp;/*fall through*/<br>&nbsp;case 'e': case 'E':<br>&nbsp;&nbsp;termios.c_cflag |= PARENB;<br>&nbsp;&nbsp;break;<br>&nbsp;}</p> 
   <p>&nbsp;if (flow == 'r')<br>&nbsp;&nbsp;termios.c_cflag |= CRTSCTS;</p> 
   <p>&nbsp;/*<br>&nbsp; * some uarts on other side don't support no flow control.<br>&nbsp; * So we set * DTR in host uart to make them happy<br>&nbsp; */<br>&nbsp;port-&gt;mctrl |= TIOCM_DTR;</p> 
   <p>&nbsp;port-&gt;ops-&gt;set_termios(port, &amp;termios, &amp;dummy);//调用serial8250_set_termios()对串口进行配置</p> 
   <p>&nbsp;//Allow the setting of the UART parameters with a NULL console too:<br>&nbsp;if (co)<br>&nbsp;&nbsp;co-&gt;cflag = termios.c_cflag;</p> 
   <p>&nbsp;return 0;<br>}</p> 
   <p>struct device *tty_register_device(struct tty_driver *driver, unsigned index,struct device *device)<br>{<br>&nbsp;char name[64];<br>&nbsp;dev_t dev = MKDEV(driver-&gt;major, driver-&gt;minor_start) + index;//得到设备号</p> 
   <p>&nbsp;if (index &gt;= driver-&gt;num) {<br>&nbsp;&nbsp;printk(KERN_ERR "Attempt to register invalid tty line number "" (%d).\n", index);<br>&nbsp;&nbsp;return ERR_PTR(-EINVAL);<br>&nbsp;}</p> 
   <p>&nbsp;if (driver-&gt;type == TTY_DRIVER_TYPE_PTY)<br>&nbsp;&nbsp;pty_line_name(driver, index, name);<br>&nbsp;else<br>&nbsp;&nbsp;tty_line_name(driver, index, name);//得到串口设备名称ttyS0，ttyS1，ttyS2<br>&nbsp;<br>&nbsp;return device_create(tty_class, device, dev, NULL, name);//在/dev下创建设备文件<br>}</p> 
   <p>&nbsp;</p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
