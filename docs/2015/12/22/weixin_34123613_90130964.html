<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>【驱动】USB驱动·入门【转】 « NotBeCN</title>
  <meta name="description" content="                  转自：http://www.cnblogs.com/lcw/p/3159371.htmlPreface   USB是目前最流行的系统总线之一。随着计算机周围硬件的不断扩展，各种设备使用不同的总线接口，导致计算机外部总线种类繁多，管理困难。USB总线正是因此而诞生的。USB总线提...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/12/22/weixin_34123613_90130964.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">【驱动】USB驱动·入门【转】</h1>
    <p class="post-meta">Dec 22, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="cnblogs_code"> 
    <pre><span style="color:#000000;">转自：<a href="http://www.cnblogs.com/lcw/p/3159371.html" rel="nofollow">http://www.cnblogs.com/lcw/p/3159371.html</a><br><br>Preface

   USB是目前最流行的系统总线之一。随着计算机周围硬件的不断扩展，各种设备使用不同的总线接口，导致计算机外部总线种类繁多，管理困难。USB总线正是因此而诞生的。

USB总线提供了所有外部设备的统一连接方式，并且支持热插拔，方便了厂商开发设备和用户使用设备。

 

 

USB遵循原则

   USB的设计目标是对现有的PC机体系进行扩充，但是目前不仅是PC机，许多的嵌入式系统都开始支持USB总线和接口标准。USB设计主要遵循下面几个原则：

易于扩充外部设备：USB支持一个接口最多127个设备。

灵活的传输协议： 支持同步和异步数据传输。

设备兼容性好： 可以兼容不同类型的设备。

接口标准统一：不同的设备之间使用相同的设备接口。

 

USB体系概述

   USB接口标准支持主机和外部设备之间进行数据传输。

   在USB体系结构中，主机预定了各种类型外部设备使用的总线带宽。当外部设备和主机在运行时，USB总线允许添加、设置、使用和拆除外设。

   在USB体系结构中，一个USB系统可以分成USB互联、USB设备和USB主机三个部分。

   USB互联是USB设备和USB主机之间进行连接通信的操作，主要包括：

总线拓扑结构：USB主机和USB设备之间的连接方式。

数据流模式：描述USB通信系统中数据如何从产生方传递到使用方。

USB调度：USB总线是一个共享连接，对可以使用的连接进行了调试以支持同步数据传输，并且避免优先级判定的开销。

   USB的物理连接是一个有层次的星形结构。



   在一个节点上连接多个设备需要使用 USB集线器(USB HUB)。

   USB体系结构规定，在一个 USB系统中，只有唯一的一个主机。USB和主机系统的接口称做主机控制器，主机控制器由主机控制器芯片、固件程序和软件共同实现的。

   USB设备包括USB集线器和功能器件。其中USB集线器的作用是扩展总线端点，向总线提供更多的连接点；功能器件是用户使用的外部设备，如键盘，鼠标等。

   USB设备需要支持 USB总线协议，对主机的操作提供反馈并且提供设备性能的描述信息。

 

USB体系工作流程

   USB总线采用轮询方式控制，主机控制设置初始化所有的数据传输。

   USB总线每次执行传输动作最多可以传输三个数据包。每次开始传输时，主机控制器发送一个描述符描述传输动作的种类和方向，这个数据包称作标志数据包（Token Packet）。USB设备收到主机发送的标志数据包后解析出数据自己的数据。

   USB数据传输的方向只有两种：主机到设备或者设备到主机。

   在一个数据传输开始时，由标志包标示数据的传输方向，然后发送端开始发送包含信息的数据。接收端发送一个握手的数据包表明数据是否传送成功。

   在主机和设备之间的USB数据传输可以看做一个通道。USB数据传输有流和消息两种通道。消息是有格式的数据，而流是没有数据格式的。

   USB有一个缺省的控制消息通道，在设备启动的时候被创建，因此设备的设置查询和输入控制信息都可以使用缺省消息控制通道完成。

 

USB驱动程序框架

   Linux内核提供了完整的USB驱动程序框架。

   USB总线采用树形结构，在一条总线上只能有唯一的主机设备。

   Linux内核从主机和设备两个角度观察USB总线结构。

 

Linux内核USB驱动框架



 

 

   左侧是主机驱动结构。

   主机驱动的最底层是 USB主机控制器，提供了 OHCI</span>/EHCI/<span style="color:#000000;">UHCI这3种类型的总线控制功能。

   在USB控制器的上一层是主机控制器的驱动，分别对应OHCI</span>/EHCI/<span style="color:#000000;">UHCI这3种类型的总线接口。

   USB核心部分连接了 USB控制器驱动和设备驱动，是两者之间的转换接口。

   USB设备驱动层提供了各种设备的驱动程序。

   所有类型的 USB设备都是用相同的电气接口，使用的传输协议也基本相同。

   向用户提供某种特定类型的 USB设备时，需要处理 USB总线协议。内核完成所有的 USB总线协议处理，并且向用户提供编程接口。

 

   右侧是设备驱动结构。

   与USB主机类似，USB设备提供了相同的层次结构与之对应。但是在 USB设备一侧使用名为 Gadget API的结构作为核心。

   Gadget API是 Linux内核实现的对应 USB设备的核心结构。Gadget API屏蔽了 USB设备控制器的细节，控制具体的 USB设备实现。

 

设备

   每个 USB设备提供了不同级别的配置信息。

   一个 USB设备可以包含一个或多个配置，不同的配置使设备表现出不同的特点。其中，设备的配置是通过接口组成的。

   Linux内核定义了 USB设备描述结构如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#800080;">17</span>
<span style="color:#800080;">18</span>
<span style="color:#008000;">//</span><span style="color:#008000;">源定义在Usb_ch9.h</span><span style="color:#008000;">
/*</span><span style="color:#008000;"> USB_DT_DEVICE: Device descriptor </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_device_descriptor {
    __u8  bLength;  </span><span style="color:#008000;">//</span><span style="color:#008000;">设备描述符长度</span>
    __u8  bDescriptorType;  <span style="color:#008000;">//</span><span style="color:#008000;">设备类型</span>
    __le16 bcdUSB;  <span style="color:#008000;">//</span><span style="color:#008000;"> USB版本号(使用 BCD编码)</span>
    __u8  bDeviceClass; <span style="color:#008000;">//</span><span style="color:#008000;">  USB设备类型</span>
    __u8  bDeviceSubClass;  <span style="color:#008000;">//</span><span style="color:#008000;">  USB设备子类型</span>
    __u8  bDeviceProtocol;  <span style="color:#008000;">//</span><span style="color:#008000;">  USB设备协议号</span>
    __u8  bMaxPacketSize0;  <span style="color:#008000;">//</span><span style="color:#008000;">传输数据的最大包长</span>
    __le16 idVendor;    <span style="color:#008000;">//</span><span style="color:#008000;">厂商编号</span>
    __le16 idProduct;   <span style="color:#008000;">//</span><span style="color:#008000;">产品编号</span>
    __le16 bcdDevice;   <span style="color:#008000;">//</span><span style="color:#008000;">设备出厂号</span>
    __u8  iManufacturer;    <span style="color:#008000;">//</span><span style="color:#008000;">厂商字符串索引</span>
    __u8  iProduct; <span style="color:#008000;">//</span><span style="color:#008000;">产品字符串索引</span>
    __u8  iSerialNumber;    <span style="color:#008000;">//</span><span style="color:#008000;">产品序列号索引</span>
    __u8  bNumConfigurations;   <span style="color:#008000;">//</span><span style="color:#008000;">最大的配置数量</span>
<span style="color:#000000;">} __attribute__ ((packed));
 

   从 usb_device_descrptor结构定义看出，一个设备描述定义了与 USB设备有关的所有信息。

 

接口

   在 USB体系中，接口是由多个端点组成的。

   一个接口代表一个基本的功能，是 USB设备驱动程序控制的对象。

   一个 USB设备最少有一个接口，功能复杂的 USB设备可以有多个接口。接口描述定义如下：Usb

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#008000;">//</span><span style="color:#008000;">源定义在 Usb_ch9.h</span><span style="color:#008000;">
/*</span><span style="color:#008000;"> USB_DT_INTERFACE: Interface descriptor </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_interface_descriptor {
    __u8  bLength;  </span><span style="color:#008000;">//</span><span style="color:#008000;">描述符长度</span>
    __u8  bDescriptorType;  <span style="color:#008000;">//</span><span style="color:#008000;">描述符类型</span>
    __u8  bInterfaceNumber; <span style="color:#008000;">//</span><span style="color:#008000;">接口编号</span>
    __u8  bAlternateSetting;    <span style="color:#008000;">//</span><span style="color:#008000;">备用接口编号</span>
    __u8  bNumEndpoints;    <span style="color:#008000;">//</span><span style="color:#008000;">端点数量</span>
    __u8  bInterfaceClass;  <span style="color:#008000;">//</span><span style="color:#008000;">接口类型</span>
    __u8  bInterfaceSubClass;   <span style="color:#008000;">//</span><span style="color:#008000;">接口子类型</span>
    __u8  bInterfaceProtocol;   <span style="color:#008000;">//</span><span style="color:#008000;">接口使用的协议</span>
    __u8  iInterface;   <span style="color:#008000;">//</span><span style="color:#008000;">接口索引字符串数值</span>
<span style="color:#000000;">} __attribute__ ((packed));
 

端点

   端点是 USB总线通信的基本形式，每个 USB设备接口可以认为是端点的集合。

   主机只能通过端点与设备通信。

   USB体系结构规定每个端点都有一个唯一的地址，由设备地址和端点号决定端点地址。

   端点还包括了与主机通信用到的属性，如传输方式、总线访问频率、带宽和端点号等。

   端点的通信是单向的，通过端点传输的数据只能是从主机到设备或者从设备到主机。

   端点的定义描述如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#008000;">/*</span><span style="color:#008000;"> USB_DT_ENDPOINT: Endpoint descriptor </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_endpoint_descriptor {
    __u8  bLength;  </span><span style="color:#008000;">//</span><span style="color:#008000;">描述符长度</span>
    __u8  bDescriptorType;  <span style="color:#008000;">//</span><span style="color:#008000;">描述符类型</span>
    __u8  bEndpointAddress; <span style="color:#008000;">//</span><span style="color:#008000;">端点地址</span>
    __u8  bmAttributes; <span style="color:#008000;">//</span><span style="color:#008000;">端点属性</span>
    __le16 wMaxPacketSize;  <span style="color:#008000;">//</span><span style="color:#008000;">端点接收的最大数据包长度</span>
<span style="color:#000000;">    __u8  bInterval;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;"> NOTE:  these two are _only_ in audio endpoints. </span><span style="color:#008000;">*/</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    __u8  bRefresh;
    __u8  bSynchAddress;
} __attribute__ ((packed));
 

配置

   配置是一个接口的集合。

   Linux内核配置的定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_config_descriptor {
    __u8  bLength;  </span><span style="color:#008000;">//</span><span style="color:#008000;">描述符长度</span>
    __u8  bDescriptorType;  <span style="color:#008000;">//</span><span style="color:#008000;">描述符类型</span>
    __le16 wTotalLength;    <span style="color:#008000;">//</span><span style="color:#008000;">配置返回数据长度</span>
    __u8  bNumInterfaces;   <span style="color:#008000;">//</span><span style="color:#008000;">最大接口数</span>
    __u8  bConfigurationValue;  <span style="color:#008000;">//</span><span style="color:#008000;">配置参数值</span>
    __u8  iConfiguration;   <span style="color:#008000;">//</span><span style="color:#008000;">配置描述字符串索引</span>
    __u8  bmAttributes; <span style="color:#008000;">//</span><span style="color:#008000;">供电模式</span>
    __u8  bMaxPower;    <span style="color:#008000;">//</span><span style="color:#008000;">接口的最大电流</span>
<span style="color:#000000;">} __attribute__ ((packed));
 

主机驱动结构

   USB主机控制器有三种类型：

OHCI，英文全称是Open Host Controller Interface。OHCI是用于SiS和Ali芯片组的USB控制器。

UHCI，英文全称是Universal Host Controller Interface。UHCI用于Intel和AMD芯片组的USB控制器。UHCI类型的控制器比OHCI控制器硬件结构要简单，但是需要额外的驱动支持，因此从理论上说速度要慢。

EHCI，USB2.0规范提出的一种控制器标准，可以兼容UHCI和OHCI。

 

USB主机控制器驱动

   Linux内核使用 usb_hcd结构描述 USB主机控制器驱动。

   usb_hcd结构描述了 USB主机控制器的硬件信息、状态和操作函数。定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#800080;">17</span>
<span style="color:#800080;">18</span>
<span style="color:#800080;">19</span>
<span style="color:#800080;">20</span>
<span style="color:#800080;">21</span>
<span style="color:#800080;">22</span>
<span style="color:#800080;">23</span>
<span style="color:#800080;">24</span>
<span style="color:#800080;">25</span>
<span style="color:#800080;">26</span>
<span style="color:#800080;">27</span>
<span style="color:#800080;">28</span>
<span style="color:#800080;">29</span>
<span style="color:#800080;">30</span>
<span style="color:#800080;">31</span>
<span style="color:#800080;">32</span>
<span style="color:#800080;">33</span>
<span style="color:#800080;">34</span>
<span style="color:#800080;">35</span>
<span style="color:#800080;">36</span>
<span style="color:#800080;">37</span>
<span style="color:#800080;">38</span>
<span style="color:#800080;">39</span>
<span style="color:#800080;">40</span>
<span style="color:#800080;">41</span>
<span style="color:#800080;">42</span>
<span style="color:#800080;">43</span>
<span style="color:#800080;">44</span>
<span style="color:#800080;">45</span>
<span style="color:#800080;">46</span>
<span style="color:#800080;">47</span>
<span style="color:#800080;">48</span>
<span style="color:#800080;">49</span>
<span style="color:#800080;">50</span>
<span style="color:#800080;">51</span>
<span style="color:#800080;">52</span>
<span style="color:#800080;">53</span>
<span style="color:#008000;">//</span><span style="color:#008000;">源定义在Hcd.h</span>
<span style="color:#0000ff;">struct</span> usb_hcd {    <span style="color:#008000;">/*</span><span style="color:#008000;"> usb_bus.hcpriv points to this </span><span style="color:#008000;">*/</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;">
     * housekeeping //控制器基本信息
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> usb_bus      self;       <span style="color:#008000;">/*</span><span style="color:#008000;"> hcd is-a bus </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span>      *product_desc;  <span style="color:#008000;">/*</span><span style="color:#008000;"> product/vendor string </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">厂商名称字符串</span>
    <span style="color:#0000ff;">char</span>            irq_descr[<span style="color:#800080;">24</span>];  <span style="color:#008000;">/*</span><span style="color:#008000;"> driver + bus # </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">驱动和总线类型</span>
    <span style="color:#0000ff;">struct</span> timer_list   rh_timer;   <span style="color:#008000;">/*</span><span style="color:#008000;"> drives root-hub polling </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">根 hub轮询时间间隔</span>
    <span style="color:#0000ff;">struct</span> urb      *status_urb;    <span style="color:#008000;">/*</span><span style="color:#008000;"> the current status urb </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">当前 urb状态</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;">
     * hardware info/state  //硬件信息和状态
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">const</span> <span style="color:#0000ff;">struct</span> hc_driver  *driver;    <span style="color:#008000;">/*</span><span style="color:#008000;"> hw-specific hooks </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">控制器驱动使用的回调函数</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> Flags that need to be manipulated atomically </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    unsigned </span><span style="color:#0000ff;">long</span><span style="color:#000000;">       flags;
</span><span style="color:#0000ff;">#define</span> HCD_FLAG_HW_ACCESSIBLE  0x00000001
<span style="color:#0000ff;">#define</span> HCD_FLAG_SAW_IRQ    0x00000002<span style="color:#000000;">
    unsigned        rh_registered:</span><span style="color:#800080;">1</span>;<span style="color:#008000;">/*</span><span style="color:#008000;"> is root hub registered? </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">是否注册根 hub</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> The next flag is a stopgap, to be removed when all the HCDs
     * support the new root-hub polling mechanism. </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    unsigned        uses_new_polling:</span><span style="color:#800080;">1</span>; <span style="color:#008000;">//</span><span style="color:#008000;">是否允许轮询根 hub状态</span>
    unsigned        poll_rh:<span style="color:#800080;">1</span>;  <span style="color:#008000;">/*</span><span style="color:#008000;"> poll for rh status? </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    unsigned        poll_pending:</span><span style="color:#800080;">1</span>; <span style="color:#008000;">/*</span><span style="color:#008000;"> status has changed? </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">状态是否改变</span>
    <span style="color:#0000ff;">int</span>         irq;        <span style="color:#008000;">/*</span><span style="color:#008000;"> irq allocated </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">控制器的中断请求号</span>
    <span style="color:#0000ff;">void</span> __iomem        *regs;      <span style="color:#008000;">/*</span><span style="color:#008000;"> device memory/io </span><span style="color:#008000;">*/</span>  <span style="color:#008000;">//</span><span style="color:#008000;">控制器使用的内存和 I/O</span>
    u64         rsrc_start; <span style="color:#008000;">/*</span><span style="color:#008000;"> memory/io resource start </span><span style="color:#008000;">*/</span>  <span style="color:#008000;">//</span><span style="color:#008000;">控制器使用的内存和 I/O起始地址</span>
    u64         rsrc_len;   <span style="color:#008000;">/*</span><span style="color:#008000;"> memory/io resource length </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">控制器使用的内存和 I/O资源长度</span>
    unsigned        power_budget;   <span style="color:#008000;">/*</span><span style="color:#008000;"> in mA, 0 = no limit </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">#define</span> HCD_BUFFER_POOLS    4
    <span style="color:#0000ff;">struct</span> dma_pool     *<span style="color:#000000;">pool [HCD_BUFFER_POOLS];
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;">         state;
#   define  __ACTIVE        </span><span style="color:#800080;">0x01</span><span style="color:#000000;">
#   define  __SUSPEND       </span><span style="color:#800080;">0x04</span><span style="color:#000000;">
#   define  __TRANSIENT     </span><span style="color:#800080;">0x80</span><span style="color:#000000;">
#   define  HC_STATE_HALT       </span><span style="color:#800080;">0</span><span style="color:#000000;">
#   define  HC_STATE_RUNNING    (__ACTIVE)
#   define  HC_STATE_QUIESCING  (__SUSPEND</span>|__TRANSIENT|<span style="color:#000000;">__ACTIVE)
#   define  HC_STATE_RESUMING   (__SUSPEND</span>|<span style="color:#000000;">__TRANSIENT)
#   define  HC_STATE_SUSPENDED  (__SUSPEND)
</span><span style="color:#0000ff;">#define</span> HC_IS_RUNNING(state) ((state) &amp; __ACTIVE)
<span style="color:#0000ff;">#define</span> HC_IS_SUSPENDED(state) ((state) &amp; __SUSPEND)
    <span style="color:#008000;">/*</span><span style="color:#008000;"> more shared queuing code would be good; it should support
     * smarter scheduling, handle transaction translators, etc;
     * input size of periodic table to an interrupt scheduler.
     * (ohci 32, uhci 1024, ehci 256/512/1024).
     </span><span style="color:#008000;">*/</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> The HC driver's private data is stored at the end of
     * this structure.
     </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    unsigned </span><span style="color:#0000ff;">long</span> hcd_priv[<span style="color:#800080;">0</span><span style="color:#000000;">]
            __attribute__ ((aligned (</span><span style="color:#0000ff;">sizeof</span>(unsigned <span style="color:#0000ff;">long</span><span style="color:#000000;">))));
};
 

OHCI控制器驱动

   usb_hcd结构可以理解为一个通用的 USB控制器描述结构，OHCI主机控制器是 usb_hcd结构的具体实现。

   内核使用 ohci_hcd结构描述 OHCI主机控制器，定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#800080;">17</span>
<span style="color:#800080;">18</span>
<span style="color:#800080;">19</span>
<span style="color:#800080;">20</span>
<span style="color:#800080;">21</span>
<span style="color:#800080;">22</span>
<span style="color:#800080;">23</span>
<span style="color:#800080;">24</span>
<span style="color:#800080;">25</span>
<span style="color:#800080;">26</span>
<span style="color:#800080;">27</span>
<span style="color:#800080;">28</span>
<span style="color:#800080;">29</span>
<span style="color:#800080;">30</span>
<span style="color:#800080;">31</span>
<span style="color:#800080;">32</span>
<span style="color:#800080;">33</span>
<span style="color:#800080;">34</span>
<span style="color:#800080;">35</span>
<span style="color:#800080;">36</span>
<span style="color:#800080;">37</span>
<span style="color:#800080;">38</span>
<span style="color:#800080;">39</span>
<span style="color:#800080;">40</span>
<span style="color:#800080;">41</span>
<span style="color:#800080;">42</span>
<span style="color:#800080;">43</span>
<span style="color:#800080;">44</span>
<span style="color:#800080;">45</span>
<span style="color:#800080;">46</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> ohci_hcd {
    spinlock_t      </span><span style="color:#0000ff;">lock</span><span style="color:#000000;">;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;">
     * I/O memory used to communicate with the HC (dma-consistent)  //用于 HC通信的 I/O内存地址
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> ohci_regs __iomem *<span style="color:#000000;">regs;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;">
     * main memory used to communicate with the HC (dma-consistent)。    //用于 HC 通告的主内存地址
     * hcd adds to schedule for a live hc any time, but removals finish
     * only at the start of the next frame.
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> ohci_hcca    *<span style="color:#000000;">hcca;
    dma_addr_t      hcca_dma;
    </span><span style="color:#0000ff;">struct</span> ed       *ed_rm_list;        <span style="color:#008000;">/*</span><span style="color:#008000;"> to be removed </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">将被移除列表</span>
    <span style="color:#0000ff;">struct</span> ed       *ed_bulktail;       <span style="color:#008000;">/*</span><span style="color:#008000;"> last in bulk list </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">列表最后一项</span>
    <span style="color:#0000ff;">struct</span> ed       *ed_controltail;    <span style="color:#008000;">/*</span><span style="color:#008000;"> last in ctrl list </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">控制列表最后一项</span>
    <span style="color:#0000ff;">struct</span> ed       *periodic [NUM_INTS];   <span style="color:#008000;">/*</span><span style="color:#008000;"> shadow int_table </span><span style="color:#008000;">*/</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;">
     * OTG controllers and transceivers need software interaction;
     * other external transceivers should be software-transparent
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> otg_transceiver  *<span style="color:#000000;">transceiver;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;">
     * memory management for queue data structures  //内存管理队列使用的数据结构
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> dma_pool     *<span style="color:#000000;">td_cache;
    </span><span style="color:#0000ff;">struct</span> dma_pool     *<span style="color:#000000;">ed_cache;
    </span><span style="color:#0000ff;">struct</span> td       *<span style="color:#000000;">td_hash [TD_HASH_SIZE];
    </span><span style="color:#0000ff;">struct</span><span style="color:#000000;"> list_head    pending;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;">
     * driver state
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">int</span><span style="color:#000000;">         num_ports;
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;">         load [NUM_INTS];
    u32             hc_control; </span><span style="color:#008000;">/*</span><span style="color:#008000;"> copy of hc control reg </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;"> HC控制寄存器复制</span>
    unsigned <span style="color:#0000ff;">long</span>       next_statechange;   <span style="color:#008000;">/*</span><span style="color:#008000;"> suspend/resume </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">挂起 恢复</span>
    u32         fminterval;     <span style="color:#008000;">/*</span><span style="color:#008000;"> saved register </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">保存的寄存器</span>
    <span style="color:#0000ff;">struct</span><span style="color:#000000;"> notifier_block   reboot_notifier;
    unsigned </span><span style="color:#0000ff;">long</span>       flags;      <span style="color:#008000;">/*</span><span style="color:#008000;"> for HC bugs </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">#define</span> OHCI_QUIRK_AMD756   0x01            /* erratum #4 */
<span style="color:#0000ff;">#define</span> OHCI_QUIRK_SUPERIO  0x02            /* natsemi */
<span style="color:#0000ff;">#define</span> OHCI_QUIRK_INITRESET    0x04            /* SiS, OPTi, ... */
<span style="color:#0000ff;">#define</span> OHCI_BIG_ENDIAN     0x08            /* big endian HC */
<span style="color:#0000ff;">#define</span> OHCI_QUIRK_ZFMICRO  0x10            /* Compaq ZFMicro chipset*/
    <span style="color:#008000;">//</span><span style="color:#008000;"> there are also chip quirks/bugs in init logic    </span><span style="color:#008000;">//</span><span style="color:#008000;">芯片的初始化逻辑里也同样会有怪异的 Bug</span>
<span style="color:#000000;">};
   OHCI主机控制器是嵌入式系统最常用的一种 USB主机控制器。

 

设备驱动结构

   USB协议规定了许多种USB设备类型。Linux内核实现了音频设备、通信设备、人机接口、存储设备、电源设备、打印设备等几种USB设备类。

 

基本概念

   Linux内核实现的 USB设备驱动都是针对通用的设备类型设计的。

   只要 USB存储设备是按照标准的 USB存储设备规范实现的，就可以直接被内核 USB存储设备驱动。如果一个 USB设备是非标准的，则需要编写对应设备的驱动程序。

 

设备驱动结构

   内核使用 usb_driver结构体描述 USB设备驱动，定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_driver {
    </span><span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span> *<span style="color:#000000;">name;
    </span><span style="color:#0000ff;">int</span> (*probe) (<span style="color:#0000ff;">struct</span> usb_interface *<span style="color:#000000;">intf,
              </span><span style="color:#0000ff;">const</span> <span style="color:#0000ff;">struct</span> usb_device_id *id);  <span style="color:#008000;">//</span><span style="color:#008000;">探测函数</span>
    <span style="color:#0000ff;">void</span> (*disconnect) (<span style="color:#0000ff;">struct</span> usb_interface *intf);    <span style="color:#008000;">//</span><span style="color:#008000;">断开连接函数</span>
    <span style="color:#0000ff;">int</span> (*ioctl) (<span style="color:#0000ff;">struct</span> usb_interface *intf, unsigned <span style="color:#0000ff;">int</span><span style="color:#000000;"> code,
            </span><span style="color:#0000ff;">void</span> *buf); <span style="color:#008000;">//</span><span style="color:#008000;"> I/O控制函数</span>
    <span style="color:#0000ff;">int</span> (*suspend) (<span style="color:#0000ff;">struct</span> usb_interface *intf, pm_message_t message);  <span style="color:#008000;">//</span><span style="color:#008000;">挂起函数</span>
    <span style="color:#0000ff;">int</span> (*resume) (<span style="color:#0000ff;">struct</span> usb_interface *intf); <span style="color:#008000;">//</span><span style="color:#008000;">恢复函数</span>
    <span style="color:#0000ff;">void</span> (*pre_reset) (<span style="color:#0000ff;">struct</span> usb_interface *<span style="color:#000000;">intf);
    </span><span style="color:#0000ff;">void</span> (*post_reset) (<span style="color:#0000ff;">struct</span> usb_interface *<span style="color:#000000;">intf);
    </span><span style="color:#0000ff;">const</span> <span style="color:#0000ff;">struct</span> usb_device_id *<span style="color:#000000;">id_table;
    </span><span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_dynids dynids;
    </span><span style="color:#0000ff;">struct</span><span style="color:#000000;"> device_driver driver;
    unsigned </span><span style="color:#0000ff;">int</span> no_dynamic_id:<span style="color:#800080;">1</span><span style="color:#000000;">;
};
实现一个 USB设备的驱动主要是实现 probe()和 disconnect()函数接口。

probe()函数在插入 USB设备的时候被调用，disconnect()函数在拔出 USB设备的时候被调用。

 

USB请求块

   USB请求块（USB request block，urb）的功能类似于网络设备中的 sk_buff，用于描述 USB设备与主机通信的基本数据结构。

   urb结构在内核中定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#800080;">17</span>
<span style="color:#800080;">18</span>
<span style="color:#800080;">19</span>
<span style="color:#800080;">20</span>
<span style="color:#800080;">21</span>
<span style="color:#800080;">22</span>
<span style="color:#800080;">23</span>
<span style="color:#800080;">24</span>
<span style="color:#800080;">25</span>
<span style="color:#800080;">26</span>
<span style="color:#800080;">27</span>
<span style="color:#800080;">28</span>
<span style="color:#800080;">29</span>
<span style="color:#800080;">30</span>
<span style="color:#800080;">31</span>
<span style="color:#800080;">32</span>
<span style="color:#800080;">33</span>
<span style="color:#008000;">//</span><span style="color:#008000;">源定义在 Usb.h</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> urb
{
    </span><span style="color:#008000;">/*</span><span style="color:#008000;"> private: usb core and host controller only fields in the urb </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> kref kref;       <span style="color:#008000;">/*</span><span style="color:#008000;"> reference count of the URB </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;"> urb引用计数</span>
    spinlock_t <span style="color:#0000ff;">lock</span>;        <span style="color:#008000;">/*</span><span style="color:#008000;"> lock for the URB </span><span style="color:#008000;">*/</span>  <span style="color:#008000;">//</span><span style="color:#008000;"> urb锁</span>
    <span style="color:#0000ff;">void</span> *hcpriv;           <span style="color:#008000;">/*</span><span style="color:#008000;"> private data for host controller </span><span style="color:#008000;">*/</span>  <span style="color:#008000;">//</span><span style="color:#008000;">主机控制器私有数据</span>
    <span style="color:#0000ff;">int</span> bandwidth;          <span style="color:#008000;">/*</span><span style="color:#008000;"> bandwidth for INT/ISO request </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">请求带宽</span>
    atomic_t use_count;     <span style="color:#008000;">/*</span><span style="color:#008000;"> concurrent submissions counter </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">并发传输计数</span>
    u8 reject;          <span style="color:#008000;">/*</span><span style="color:#008000;"> submissions will fail </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">传输即将失败标志</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> public: documented fields in the urb that can be used by drivers </span><span style="color:#008000;">*/</span>  <span style="color:#008000;">//</span><span style="color:#008000;">公有数据，可以被驱动使用</span>
    <span style="color:#0000ff;">struct</span> list_head urb_list;  <span style="color:#008000;">/*</span><span style="color:#008000;"> list head for use by the urb's   //链表头
                     * current owner </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> usb_device *dev;     <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) pointer to associated device </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">关联的 USB设备</span>
    unsigned <span style="color:#0000ff;">int</span> pipe;      <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) pipe information </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">管道信息</span>
    <span style="color:#0000ff;">int</span> status;         <span style="color:#008000;">/*</span><span style="color:#008000;"> (return) non-ISO status </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">当前信息</span>
    unsigned <span style="color:#0000ff;">int</span> transfer_flags;    <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) URB_SHORT_NOT_OK | ...</span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">void</span> *transfer_buffer;      <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) associated data buffer </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">数据缓冲区</span>
    dma_addr_t transfer_dma;    <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) dma addr for transfer_buffer </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">DMA使用的缓冲区</span>
    <span style="color:#0000ff;">int</span> transfer_buffer_length; <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) data buffer length </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">缓冲区大小</span>
    <span style="color:#0000ff;">int</span> actual_length;      <span style="color:#008000;">/*</span><span style="color:#008000;"> (return) actual transfer length </span><span style="color:#008000;">*/</span>   <span style="color:#008000;">//</span><span style="color:#008000;">实际接收或发送数据的长度</span>
    unsigned <span style="color:#0000ff;">char</span> *setup_packet;    <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) setup packet (control only) </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    dma_addr_t setup_dma;       </span><span style="color:#008000;">/*</span><span style="color:#008000;"> (in) dma addr for setup_packet </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">设置数据包缓冲区</span>
    <span style="color:#0000ff;">int</span> start_frame;        <span style="color:#008000;">/*</span><span style="color:#008000;"> (modify) start frame (ISO) </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">等时传输中返回初始帧</span>
    <span style="color:#0000ff;">int</span> number_of_packets;      <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) number of ISO packets </span><span style="color:#008000;">*/</span>    <span style="color:#008000;">//</span><span style="color:#008000;">等时传输中缓冲区数据</span>
    <span style="color:#0000ff;">int</span> interval;           <span style="color:#008000;">/*</span><span style="color:#008000;"> (modify) transfer interval   //轮询的时间间隔
                     * (INT/ISO) </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">int</span> error_count;        <span style="color:#008000;">/*</span><span style="color:#008000;"> (return) number of ISO errors </span><span style="color:#008000;">*/</span> <span style="color:#008000;">//</span><span style="color:#008000;">出错次数</span>
    <span style="color:#0000ff;">void</span> *context;          <span style="color:#008000;">/*</span><span style="color:#008000;"> (in) context for completion </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    usb_complete_t complete;    </span><span style="color:#008000;">/*</span><span style="color:#008000;"> (in) completion routine </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">struct</span> usb_iso_packet_descriptor iso_frame_desc[<span style="color:#800080;">0</span><span style="color:#000000;">];
                    </span><span style="color:#008000;">/*</span><span style="color:#008000;"> (in) ISO ONLY </span><span style="color:#008000;">*/</span><span style="color:#000000;">
};
   内核提供了一组函数 urb类型的结构变量。urb的使用流程如下：

创建 urb。在使用之前，USB设备驱动需要调用 usb_alloc_urb()函数创建一个 urb；内核还提供释放 urb的函数，在不使用 urb的时候（退出驱动种马或者挂起驱动），需要使用 usb_free_urb()函数释放 urb。

初始化 urb。设置 USB设备的端点。使用内核提供的 usb_init_urb()函数设置 urb初始结构。

提交 urb到 USB核心。在分配并设置 urb完毕后，使用 urb_submit_urb()函数把新的 urb提交到 USB核心。

 

USB驱动程序框架

   Linux内核代码driver</span>/usb/usb-<span style="color:#000000;">skeleton.c文件是一个标准的USB设备驱动程序。

   编写一个USB设备的驱动可以参考usb</span>-<span style="color:#000000;">skeleton.c文件，实际上，可以直接修改该文件驱动新的USB设备。

 

基本数据结构

   usb</span>-<span style="color:#000000;">skel设备使用自定义结构 usb_skel记录设备驱动用到的所有描述符，该结构定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#800080;">17</span>
<span style="color:#800080;">18</span>
<span style="color:#008000;">/*</span><span style="color:#008000;"> Structure to hold all of our device specific stuff </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">struct</span><span style="color:#000000;"> usb_skel {
    </span><span style="color:#0000ff;">struct</span> usb_device * udev;           <span style="color:#008000;">/*</span><span style="color:#008000;"> the usb device for this device </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备描述符</span>
    <span style="color:#0000ff;">struct</span> usb_interface *  <span style="color:#0000ff;">interface</span>;      <span style="color:#008000;">/*</span><span style="color:#008000;"> the interface for this device </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> USB接口描述符</span>
    <span style="color:#0000ff;">struct</span> semaphore    limit_sem;      <span style="color:#008000;">/*</span><span style="color:#008000;"> limiting the number of writes in progress </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> 互斥信号量</span>
    unsigned <span style="color:#0000ff;">char</span> *     bulk_in_buffer;     <span style="color:#008000;">/*</span><span style="color:#008000;"> the buffer to receive data </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> 数据接收缓冲区</span>
    size_t          bulk_in_size;       <span style="color:#008000;">/*</span><span style="color:#008000;"> the size of the receive buffer </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> 数据接收缓冲区大小</span>
    __u8            bulk_in_endpointAddr;   <span style="color:#008000;">/*</span><span style="color:#008000;"> the address of the bulk in endpoint </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> 入端点地址</span>
    __u8            bulk_out_endpointAddr;  <span style="color:#008000;">/*</span><span style="color:#008000;"> the address of the bulk out endpoint </span><span style="color:#008000;">*/</span>
        <span style="color:#008000;">//</span><span style="color:#008000;"> 出端点地址</span>
    <span style="color:#0000ff;">struct</span><span style="color:#000000;"> kref     kref;
};
   usb</span>-<span style="color:#000000;">skel设备驱动把 usb_skel结构存放在了 urb结构的 context指针里。通过 urb，设备的所有操作函数都可以访问到 usb_skel结构。

   其中，limit_sem成员是一个信号量，当多个 usb</span>-<span style="color:#000000;">skel类型的设备存在于系统中的时候，需要控制设备之间的数据同步。

 

驱动程序初始化和注销

   与其他所有的 Linux设备驱动程序一样，usb</span>-<span style="color:#000000;">skel驱动使用 module_init()宏设置初始化函数，使用 module_exit()宏设置注销函数。

   usb</span>-<span style="color:#000000;">skel驱动的初始化函数是 usb_skel_init()函数，定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#0000ff;">static</span> <span style="color:#0000ff;">int</span> __init usb_skel_init(<span style="color:#0000ff;">void</span><span style="color:#000000;">)
{
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> result;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;"> register this driver with the USB subsystem </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    result </span>= usb_register(&amp;skel_driver);    <span style="color:#008000;">//</span><span style="color:#008000;">注册 USB设备驱动</span>
    <span style="color:#0000ff;">if</span><span style="color:#000000;"> (result)
        err(</span><span style="color:#800000;">"</span><span style="color:#800000;">usb_register failed. Error number %d</span><span style="color:#800000;">"</span><span style="color:#000000;">, result);
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> result;
}
   usb_skel_init()函数调用内核提供的 usb_register()函数注册了一个 usb_driver类型的结构变量，该变量定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#0000ff;">static</span> <span style="color:#0000ff;">struct</span> usb_driver skel_driver =<span style="color:#000000;"> {
    .name </span>=     <span style="color:#800000;">"</span><span style="color:#800000;">skeleton</span><span style="color:#800000;">"</span>, <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备名称</span>
    .probe =    skel_probe, <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备初始化函数</span>
    .disconnect =   skel_disconnect,    <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备注销函数</span>
    .id_table = skel_table, <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备 ID映射表</span>
<span style="color:#000000;">};
   skel_driver结构变量中，定义了 usb</span>-<span style="color:#000000;">skel设备的名、设备初始化函数、设备注销函数和 USB ID映射表。

   其中 usb</span>-<span style="color:#000000;">skel设备的 USB ID映射表定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#008000;">/*</span><span style="color:#008000;"> table of devices that work with this driver </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">static</span> <span style="color:#0000ff;">struct</span> usb_device_id skel_table [] =<span style="color:#000000;"> {
    { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
    { }                 </span><span style="color:#008000;">/*</span><span style="color:#008000;"> Terminating entry </span><span style="color:#008000;">*/</span><span style="color:#000000;">
};
   skel_table中只有一项，定义了一个默认的 usb</span>-<span style="color:#000000;">skel设备的 ID，其中，USB_SKEL_VENDOR_ID是 USB设备的厂商 ID，USB_SKEL_PRODUCT_ID是 USB设备 ID。

 

设备初始化

   从 skel_driver结构可以知道 usb</span>-<span style="color:#000000;">skel设备的初始化函数是 skel_probe()函数。

设备初始化主要是探测设备类型，分配 USB设备用到的 urb资源，注册 USB设备操作函数等。

skel_class结构变量记录了 usb</span>-<span style="color:#000000;">skel设备信息，定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#008000;">/*</span><span style="color:#008000;">
 * usb class driver info in order to get a minor number from the usb core,
 * and to have the device registered with the driver core
 </span><span style="color:#008000;">*/</span>
<span style="color:#0000ff;">static</span> <span style="color:#0000ff;">struct</span> usb_class_driver skel_class =<span style="color:#000000;"> {
    .name </span>=     <span style="color:#800000;">"</span><span style="color:#800000;">skel%d</span><span style="color:#800000;">"</span>,   <span style="color:#008000;">//</span><span style="color:#008000;">设备名称</span>
    .fops =     &amp;skel_fops, <span style="color:#008000;">//</span><span style="color:#008000;">设备操作函数</span>
    .minor_base =<span style="color:#000000;">   USB_SKEL_MINOR_BASE,
};
   name变量使用 </span>%d通配符表示一个整形变量，当一个 usb-<span style="color:#000000;">skel类型的设备连接到 USB总线后会按照子设备编号自动设置设备名称。

   fops是设备操作函数结构变量，定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#0000ff;">static</span> <span style="color:#0000ff;">struct</span> file_operations skel_fops =<span style="color:#000000;"> {
    .owner </span>=<span style="color:#000000;">    THIS_MODULE,
    .read </span>=     skel_read,  <span style="color:#008000;">//</span><span style="color:#008000;">读操作</span>
    .write =    skel_write, <span style="color:#008000;">//</span><span style="color:#008000;">写操作</span>
    .open =     skel_open,  <span style="color:#008000;">//</span><span style="color:#008000;">打开操作</span>
    .release =  skel_release,   <span style="color:#008000;">//</span><span style="color:#008000;">关闭操作</span>
<span style="color:#000000;">};
   skel_ops定义了 usb</span>-skel设备的操作函数。当在 usb-<span style="color:#000000;">skel设备上发生相关事件时，USB文件系统会调用对应的函数处理。

 

设备注销

   skel_disconnect()函数在注销设备的时候被调用，定义如下：

</span><span style="color:#800080;">1</span>
<span style="color:#800080;">2</span>
<span style="color:#800080;">3</span>
<span style="color:#800080;">4</span>
<span style="color:#800080;">5</span>
<span style="color:#800080;">6</span>
<span style="color:#800080;">7</span>
<span style="color:#800080;">8</span>
<span style="color:#800080;">9</span>
<span style="color:#800080;">10</span>
<span style="color:#800080;">11</span>
<span style="color:#800080;">12</span>
<span style="color:#800080;">13</span>
<span style="color:#800080;">14</span>
<span style="color:#800080;">15</span>
<span style="color:#800080;">16</span>
<span style="color:#800080;">17</span>
<span style="color:#800080;">18</span>
<span style="color:#800080;">19</span>
<span style="color:#800080;">20</span>
<span style="color:#800080;">21</span>
<span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span> skel_disconnect(<span style="color:#0000ff;">struct</span> usb_interface *<span style="color:#0000ff;">interface</span><span style="color:#000000;">)
{
    </span><span style="color:#0000ff;">struct</span> usb_skel *<span style="color:#000000;">dev;
    </span><span style="color:#0000ff;">int</span> minor = <span style="color:#0000ff;">interface</span>-&gt;<span style="color:#000000;">minor;
    </span><span style="color:#008000;">/*</span><span style="color:#008000;"> prevent skel_open() from racing skel_disconnect() </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    lock_kernel();  </span><span style="color:#008000;">//</span><span style="color:#008000;">在操作之前加锁</span>
    dev = usb_get_intfdata(<span style="color:#0000ff;">interface</span>);  <span style="color:#008000;">//</span><span style="color:#008000;">获得 USB设备接口描述</span>
    usb_set_intfdata(<span style="color:#0000ff;">interface</span>, NULL);  <span style="color:#008000;">//</span><span style="color:#008000;">设置 USB设备接口描述无效</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> give back our minor </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    usb_deregister_dev(</span><span style="color:#0000ff;">interface</span>, &amp;skel_class); <span style="color:#008000;">//</span><span style="color:#008000;">注销 USB设备操作供述</span>
    unlock_kernel();    <span style="color:#008000;">//</span><span style="color:#008000;">操作完毕解锁</span>
    <span style="color:#008000;">/*</span><span style="color:#008000;"> decrement our usage count </span><span style="color:#008000;">*/</span><span style="color:#000000;">
    kref_put(</span>&amp;dev-&gt;kref, skel_delete);   <span style="color:#008000;">//</span><span style="color:#008000;">减小引用计数</span>
    info(<span style="color:#800000;">"</span><span style="color:#800000;">USB Skeleton #%d now disconnected</span><span style="color:#800000;">"</span><span style="color:#000000;">, minor);
}
</span><span style="color:#0000ff;">static</span> <span style="color:#0000ff;">struct</span> usb_driver skel_driver =<span style="color:#000000;"> {
    .name </span>=     <span style="color:#800000;">"</span><span style="color:#800000;">skeleton</span><span style="color:#800000;">"</span>, <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备名称</span>
    .probe =    skel_probe, <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备初始化函数</span>
    .disconnect =   skel_disconnect,    <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备注销函数</span>
    .id_table = skel_table, <span style="color:#008000;">//</span><span style="color:#008000;"> USB设备 ID映射表</span>
<span style="color:#000000;">};
   skel_disconnect()函数释放 usb</span>-<span style="color:#000000;">skel设备用到的资源。

   首先获取 USB设备接口描述，之后设置为无效；然后调用 usb_deregister_dev()函数注销 USB设备的操作描述符，注销操作本身需要加锁；注销设备描述符后，更新内核对 usb</span>-skel设备的引用计数。</pre> 
   </div> 
   <p>&nbsp;</p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
