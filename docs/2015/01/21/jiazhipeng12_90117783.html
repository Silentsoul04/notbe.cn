<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>java线程的5个使用技巧 « NotBeCN</title>
  <meta name="description" content="                 Java线程的5个使用技巧    Published:&nbsp;21 Jan 2015&nbsp;Category:&nbsp;java        Java线程有哪些不太为人所知的技巧与用法？    萝卜白菜各有所爱。像我就喜欢Java。学无止境，这也是我喜欢它的一个原因。...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/01/21/jiazhipeng12_90117783.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">java线程的5个使用技巧</h1>
    <p class="post-meta">Jan 21, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="artical-content-bak main-content editor-side-new"> 
   <div class="con editor-preview-side" id="result">
    <h2 class="title" style="font-size:24px;color:rgb(77,77,77);line-height:32px;border-bottom-width:4px;border-bottom-style:double;font-family:Georgia, 'Hiragino Sans GB', '宋体';">Java线程的5个使用技巧</h2>
    <p><span class="info-title" style="color:rgb(136,136,136);vertical-align:middle;"><em class="icon-calendar"></em>Published:&nbsp;</span><span class="info-date" style="color:rgb(86,86,86);vertical-align:middle;">21 Jan 2015</span>&nbsp;<span class="info-title" style="color:rgb(136,136,136);vertical-align:middle;"><em class="icon-folder-open"></em>Category:&nbsp;</span><span class="info-link" style="vertical-align:middle;border-bottom-style:none;"><a href="http://it.deepinmind.com/categories.html#java-ref" rel="nofollow" style="color:rgb(0,153,153);text-decoration:none;">java</a></span></p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;"><img src="http://384uqqh5pka2ma24ild282mv.wpengine.netdna-cdn.com/wp-content/uploads/2015/01/threadfred.jpg" alt="p_w_picpath"></p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;"><strong>Java线程有哪些不太为人所知的技巧与用法？</strong></p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">萝卜白菜各有所爱。像我就喜欢Java。学无止境，这也是我喜欢它的一个原因。日常工作中你所用到的工具，通常都有些你从来没有了解过的东西，比方说某个方法或者是一些有趣的用法。比如说线程。没错，就是线程。或者确切说是Thread这个类。当我们在构建高可扩展性系统的时候，通常会面临各种各样的并发编程的问题，不过我们现在所要讲的可能会略有不同。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">从本文中你将会看到线程提供的一些不太常用的方法及技术。不管你是初学者还是高级用户或者是Java专家，希望都能看一下哪些是你已经知道的，而哪些是刚了解的。如果你认为关于线程还有什么值得分享给大家的，希望能在下面积极回复。那我们就先开始吧。</p>
    <h3 style="font-size:18px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">初学者</h3>
    <h4 style="color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">1.线程名</h4>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">程序中的每个线程都有一个名字，创建线程的时候会给它分配一个简单的Java字符串来作为线程名。默认的名字是"Thread-0", "Thread-1", "Thread-2"等等。现在有趣的事情来了——Thread提供了两种方式来设置线程名：</p>
    <ol style="list-style-type:disc;" class="list-paddingleft-2">
     <li><p>线程构造函数，下面是最简单的一个实现：</p></li>
    </ol>
    <pre style="color:rgb(77,77,77);">class&nbsp;SuchThread&nbsp;extends&nbsp;Thread&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;Public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println&nbsp;("Hi&nbsp;Mom!&nbsp;"&nbsp;+&nbsp;getName());
&nbsp;&nbsp;&nbsp;&nbsp;}}SuchThread&nbsp;wow&nbsp;=&nbsp;new&nbsp;SuchThread("much-name");</pre>
    <ol style="list-style-type:disc;" class="list-paddingleft-2">
     <li><p>线程名setter方法：</p></li>
    </ol>
    <pre style="color:rgb(77,77,77);">wow.setName(“Just&nbsp;another&nbsp;thread&nbsp;name”);</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">没错，线程名是可变的。因此我们可以在运行时修改它的名字，而不用在初始化的时候就指定好。name字段其实就是一个简单的字符串对象。也就是说它能达到231-1个字符那么长（Integer.MAX_VALUE）。这足够用了。注意这个名字并不是一个唯一性的标识，因此不同的线程也可以拥有同样的线程名。还有一点就是，不要把null用作线程名，否则会抛出异常（当然了，"null"还是可以的）。</p>
    <h5 style="font-size:14px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';line-height:22.3999996185303px;">使用线程名来调试问题</h5>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">既然可以设置线程名，那么如果遵循一定的命名规则的话，出了问题的时候排查起来就能更容易一些。“Thread-6″这样的名字看起来就太没心没肺了，肯定有比它更好的名字。在处理用户请求的时候，可以将事务ID追加到线程名后面，这样能显著减少你排查问题的时间。</p>
    <pre style="color:rgb(77,77,77);">“pool-1-thread-1″&nbsp;#17&nbsp;prio=5&nbsp;os_prio=31&nbsp;tid=0x00007f9d620c9800nid=0x6d03&nbsp;in&nbsp;Object.wait()&nbsp;[0x000000013ebcc000]</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">“pool-1-thread-1″，这也太严肃了吧。我们来看下这是什么情况，给它起一个好点的名字：</p>
    <pre style="color:rgb(77,77,77);">Thread.currentThread().setName(Context&nbsp;+&nbsp;TID&nbsp;+&nbsp;Params&nbsp;+&nbsp;current&nbsp;Time,&nbsp;...);</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">现在我们再来运行下jstack，情况便豁然开朗了：</p>
    <pre style="color:rgb(77,77,77);">”Queue&nbsp;Processing&nbsp;Thread,&nbsp;MessageID:&nbsp;AB5CAD,&nbsp;type:AnalyzeGraph,&nbsp;queue:&nbsp;ACTIVE_PROD,&nbsp;Transaction_ID:&nbsp;5678956,Start&nbsp;Time:&nbsp;30/12/2014&nbsp;17:37″&nbsp;#17&nbsp;prio=5&nbsp;os_prio=31&nbsp;tid=0x00007f9d620c9800nid=0x6d03&nbsp;in&nbsp;Object.wait()&nbsp;[0x000000013ebcc000]</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">如果我们能知道线程在做什么，这样当它出问题的时候，至少可以拿到事务ID来开始排查。你可以回溯这个问题，复现它，然后定位问题并搞定它。如果你想知道jstack有什么给力的用法，可以看下<a href="http://blog.takipi.com/supercharged-jstack-how-to-debug-your-servers-at-100mph/" rel="nofollow" style="color:rgb(0,153,153);text-decoration:none;">这篇文章</a>。</p>
    <h3 style="font-size:18px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">2. 线程优先级</h3>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">线程还有一个有意思的属性就是它的优先级。线程的优先级介于1 (MIN<em>PRIORITY)到10 (MAX</em>PRIORITY)之间，主线程默认是5（NORM_PRIORITY）。每个新线程都默认继承父线程的优先级，因此如果你没有设置过的话，所有线程的优先级都是5。这个是通常被忽视的属性，我们可以通过getPriority()与setPriority()方法来获取及修改它的值。线程的构造函数里是没有这个功能的。</p>
    <h4 style="color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">什么地方会用到优先级？</h4>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">当然并不是所有的线程都是平等的，有的线程需要立即引起CPU的重视，而有些线程则只是后台任务而已。优先级就是用来把这些告诉给操作系统的线程调度器的。在Takipi中，这是我们开发的一错误跟踪及排查的工具，负责处理用户异常的线程的优先级是MAX_PRIORITY，而那些只是在上报新的部署情况的线程，它们的优先级就要低一些。你可能会觉得优先级高的线程从JVM的线程调度器那得到的时间会多一些。但其实并都是这样的。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">在操作系统层面，每一个新线程都会对应一个本地线程，你所设置的Java线程的优先级会被转化成本地线程的优先级，这个在各个平台上是不一样的。在Linux上，你可以打开“-XX:+UseThreadPriorities”选项来启用这项功能。正如前面所说的，线程优先级只是你所提供的一个建议。和Linux本地的优先级相比，Java线程的优先级并不能覆盖全所有的级别（Linux共有1到99个优先级，线程的优先级在是-20到20之间）。最大的好处就是你所设定的优先级能在每个线程获得的CPU时间上有所体现，不过完全依赖于线程优先级的做法是不推荐的。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;"><img src="http://384uqqh5pka2ma24ild282mv.wpengine.netdna-cdn.com/wp-content/uploads/2015/01/FredThreads.jpg" alt="p_w_picpath"></p>
    <h3 style="font-size:18px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">进阶篇</h3>
    <h4 style="color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">3.线程本地存储</h4>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">这个和前面提到的两个略有不同。ThreadLocal是在Thread类之外实现的一个功能（java.lang.ThreadLocal），但它会为每个线程分别存储一份唯一的数据。正如它的名字所说的，它为线程提供了本地存储，也就是说你所创建出来变量对每个线程实例来说都是唯一的。和线程名，线程优先级类似，你可以自定义出一些属性，就好像它们是存储在Thread线程内部一样，是不是觉得酷？不过先别<a href="http://www.quickmeme.com/img/6b/6b21ef9c17d96b863db2bd496c0e3b799fb5623ea127273544dc5e4511c01337.jpg" rel="nofollow" style="color:rgb(0,153,153);text-decoration:none;">高兴得太早了</a>，有几句丑话得先说在前头。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">创建ThreadLocal有两种推荐方式：要么是静态变量，要么是单例实例中的属性，这样可以是非静态的。注意，它的作用域是全局的，只不过对访问它的线程而言好像是本地的而已。在下面这个例子中，ThreadLocal里面存储了一个数据结构，这样我们可以很容易地访问到它：</p>
    <pre style="color:rgb(77,77,77);">public&nbsp;static&nbsp;class&nbsp;CriticalData{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;transactionId;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;username;}public&nbsp;static&nbsp;final&nbsp;ThreadLocal&lt;CriticalData&gt;&nbsp;globalData&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;ThreadLocal&lt;CriticalData&gt;();</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">一旦获取到了ThreadLocal对象，就可以通过 globalData.set()和globalData.get()方法来对它进行操作了。</p>
    <h4 style="color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">全局变量？这不是什么好事</h4>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">也尽然。ThreadLocal可以用来存储事务ID。如果代码中出现未捕获异常的时候它就相当有用了。最佳实践是设置一个UncaughtExceptionHandler，这个是Thread类本身就支持的，但是你得自己去实现一下这个接口。一旦执行到了UncaughtExceptionHandler里，就几乎没有任何线索能够知道到底发生了什么事情了。这会儿你能获取到的就只有Thread对象，之前导致异常发生的所有变量都无法再访问了，因为那些栈帧都已经被弹出了。一旦到了UncaughtExceptionHandler里，这个线程就只剩下最后一口气了，唯一能抓住的最后一根稻草就是ThreadLocal。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">我们来试下这么做：</p>
    <pre style="color:rgb(77,77,77);">System.err.println("Transaction&nbsp;ID&nbsp;"&nbsp;+&nbsp;globalData.get().transactionId);</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">我们可以将一些与错误相关的有价值的上下文信息给存储到里面添。ThreadLocal还有一个更有创意的用法，就是用它来分配一块特定的内存，这样工作线程可以把它当作缓存来不停地使用。当然了，这有没有用得看你在CPU和内存之间是怎么权衡的了。没错，ThreadLocal需要注意的就是会造成内存空间的浪费。只要线程还活着，那么它就会一直存在，除非你主动释放否则它是不会被回收的。因此如果使用它的话你最好注意一下，尽量保持简单。</p>
    <h4 style="color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">4. 用户线程及守护线程</h4>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">我们再回到Thread类。程序中的每个线程都会有一个状态，要么是用户状态，要么是守护状态。换句话说，要么是前台线程要么是后台线程。主线程默认是用户线程，每个新线程都会从创建它的线程中继承线程状态。因此如果你把一个线程设置成守护线程，那么它所创建的所有线程都会被标记成守护线程。如果程序中的所有线程都是守护线程的话，那么这个进程便会终止。我们可以通过Boolean .setDaemon(true)和.isDaemon()方法来查看及设置线程状态。</p>
    <h5 style="font-size:14px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';line-height:22.3999996185303px;">什么时候会用到守护线程？</h5>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">如果进程不必等到某个线程结束才能终止，那么这个线程就可以设置成守护线程。这省掉了正常关闭线程的那些麻烦事，可以立即将线程结束掉。换个角度来说，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就应该是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。</p>
    <h3 style="font-size:18px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">专家级</h3>
    <h4 style="color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">5. 处理器亲和性（Processor Affinity）</h4>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">这里要讲的会更靠近硬件，也就是说，当软件遇上了硬件。处理器亲和性使得你能够将线程或者进程绑定到特定的CPU核上。这意味着只要是某个特定的线程，它就肯定只会在某个特定的CPU核上执行。通常来讲如何绑定是由操作系统的线程调度器根据它自己的逻辑来决定的，它很可能会将我们前面提到的线程优先级也一并考虑进来。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">这么做的好处在于CPU缓存。如果某个线程只会在某个核上运行，那么它的数据恰好在缓存里的概率就大大提高了。如果数据正好就在CPU缓存里，那么就没有必要重新再从内存里加载了。你所节省的这几毫秒时间就能用在刀刃上，在这段时间里代码可以马上开始执行，也就能更好地利用所分配给它的CPU时间。当然了，操作系统层面可能会存在某种优化，硬件架构当然也是个很重要的因素，但利用了处理器的亲和性至少能够减小线程切换CPU的机率。</p>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">由于这里掺杂着多种因素，处理器亲和性到底对吞吐量有多大的影响，最好还是通过测试的方式来进行证明。也许这个方法并不是总能显著地提升性能，但至少有一个好处就是吞吐量会相对稳定。亲和策略可以细化到非常细的粒度上，这取决于你具体想要什么。高频交易行业便是这一策略最能大显身手的场景之一。</p>
    <h5 style="font-size:14px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';line-height:22.3999996185303px;">处理器亲和性的测试</h5>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">Java对处理器的亲和性并没有原生的支持，当然了，故事也还没有就此结束。在Linux上，我们可以通过<a href="http://linuxcommand.org/man_pages/taskset1.html" rel="nofollow" style="color:rgb(0,153,153);text-decoration:none;">taskset</a>命令来设置进程的亲和性。假设我们现在有一个Java进程在运行，而我们希望将它绑定到某个特定的CPU上：</p>
    <pre style="color:rgb(77,77,77);">taskset&nbsp;-c&nbsp;1&nbsp;“java&nbsp;AboutToBePinned”</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">如果是一个已经在运行了的进程：</p>
    <pre style="color:rgb(77,77,77);">taskset&nbsp;-c&nbsp;1&nbsp;&lt;PID&gt;</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">要想深入到线程级别还得再加些代码才行。所幸的是，有一个开源库能完成这样的功能：<a href="https://github.com/OpenHFT/Java-Thread-Affinity" rel="nofollow" style="color:rgb(0,153,153);text-decoration:none;">Java-Thread-Affinity</a>。这个库是由OpenHFT的<a href="https://twitter.com/peterlawrey" rel="nofollow" style="color:rgb(0,153,153);text-decoration:none;">Peter Lawrey</a>开发的，实现这一功能最简单直接的方式应该就是使用这个库了。我们通过一个例子来快速看下如何绑定某个线程，关于该库的更多细节请参考它在Github上的文档：</p>
    <pre style="color:rgb(77,77,77);">AffinityLock&nbsp;al&nbsp;=&nbsp;AffinityLock.acquireLock();</pre>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">这样就可以了。关于获取锁的一些更高级的选项——比如说根据不同的策略来选择CPU——在Github上都有详细的说明。</p>
    <h3 style="font-size:18px;color:rgb(77,77,77);font-family:Georgia, 'Hiragino Sans GB', '宋体';">结论</h3>
    <p style="line-height:22.3999996185303px;color:rgb(86,86,86);font-family:Georgia, 'Hiragino Sans GB', '宋体';font-size:14px;">本文我们介绍了关于线程的5点知识：线程名，线程本地存储，优先级，守护线程以及处理器亲和性。希望这能为你日常工作中所用到的内容打开一扇新的窗户，期待你们的反馈！还有什么有关线程处理的方法可以分享给大家的吗，请不吝赐教。</p>
    <p><br></p>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
