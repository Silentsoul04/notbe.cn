<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux驱动总结3- unlocked_ioctl和堵塞（waitqueue）读写函数的实现 【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://blog.chinaunix.net/uid-20937170-id-3033633.html    学习了驱动程序的设计，感觉在学习驱动的同时学习linux内核，也是很不错的过程哦，做了几个实验，该做一些总结，只有不停的作总结才能印象深刻。        我的平台是...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/08/05/weixin_34342905_90136353.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux驱动总结3- unlocked_ioctl和堵塞（waitqueue）读写函数的实现 【转】</h1>
    <p class="post-meta">Aug 5, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://blog.chinaunix.net/uid-20937170-id-3033633.html" rel="nofollow">http://blog.chinaunix.net/uid-20937170-id-3033633.html</a></p> 
   <p>学习了驱动程序的设计，感觉在学习驱动的同时学习linux内核，也是很不错的过程哦，做了几个实验，该做一些总结，只有不停的作总结才能印象深刻。</p> 
   <div>
    我的平台是虚拟机，fedora14，内核版本为2.6.38.1.其中较之前的版本存在较大的差别，具体的实现已经在上一次总结中给出了。今天主要总结的是ioctl和堵塞读写函数的实现。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    <span style="color:#f00000;">一、ioctl函数的实现</span>
   </div> 
   <div>
    首先说明在2.6.36以后ioctl函数已经不再存在了，而是用unlocked_ioctl和compat_ioctl两个函数实现以前版本的ioctl函数。同时在参数方面也发生了一定程度的改变，去除了原来ioctl中的struct inode参数，同时改变了返回值。
   </div> 
   <div>
    但是驱动设计过程中存在的问题变化并不是很大，同样在应用程序设计中我们还是采用ioctl实现访问，而并不是unlocked_ioctl函数，因此我们还可以称之为ioctl函数的实现。
   </div> 
   <div>
    ioctl函数的实现主要是用来实现具体的硬件控制，采用相应的命令控制硬件的具体操作，这样就能使得硬件的操作不再是单调的读写操作。使得硬件的使用更加的方便。
   </div> 
   <div>
    ioctl函数实现主要包括两个部分，首先是命令的定义，然后才是ioctl函数的实现，命令的定义是采用一定的规则。
   </div> 
   <div>
    ioctl的命令主要用于应用程序通过该命令操作具体的硬件设备，实现具体的操作，在驱动中主要是对命令进行解析，通过switch-case语句实现不同命令的控制，进而实现不同的硬件操作。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    ioctl函数的命令定义方法：
   </div> 
   <div> 
    <div>
     <span style="color:#f00000;">int (*unlocked_ioctl)(struct file*filp,unsigned int cmd,unsigned long arg)</span>
    </div> 
   </div> 
   <div> 
    <span style="color:#f00000;">虽然其中没有指针的参数，但是通常采用arg传递指针参数。</span>cmd是一个命令。
    <span style="color:#f00000;">每一个命令由一个整形数据构成（32bits），将一个命令分成四部分，每一部分实现具体的配置，设备类型（幻数）8bits，方向2bits，序号8bits，数据大小13/14bits。</span>命令的实现实质上就是通过简单的移位操作，将各个部分组合起来而已。
   </div> 
   <div>
    一个命令的分布的大概情况如下：
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    |---方向位(31-30)|----数据长度(29-16)----------------|---------设备类型（15-8）------|----------序号（7-0）----------|
   </div> 
   <div>
    |----------------------------------------------------------------------------------------------------------------------------------------|
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    其中方向位主要是表示对设备的操作，比如读设备，写设备等操作以及读写设备等都具有一定的方向，2个bits只有4种方向。
   </div> 
   <div>
    数据长度表示每一次操作（读、写）数据的大小，一般而已每一个命令对应的数据大小都是一个固定的值，不会经常改变，14bits说明可以选择的数据长度最大为16k。
   </div> 
   <div>
    设备类型类似于主设备号（由于8bits，刚好组成一个字节，因此经常采用字符作为幻数，表示某一类设备的命令），用来区别不同的命令类型，也就是特定的设备类型对应特定的设备。序号主要是这一类命令中的具体某一个，类似于次设备号（256个命令），也就是一个设备支持的命令多达256个。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    同时在内核中也存在具体的宏用来定义命令以及解析命令。
   </div> 
   <div>
    但是大部分的宏都只是定义具体的方向，其他的都需要设计者定义。
   </div> 
   <div>
    主要的宏如下：
   </div> 
   <div>
    <span style="color:#f00000;">#include</span>
   </div> 
   <div>
    <span style="color:#f00000;">&nbsp;</span>
   </div> 
   <div>
    <span style="color:#f00000;">_IO(type,nr) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;表示定义一个没有方向的命令，</span>
   </div> 
   <div>
    <span style="color:#f00000;">_IOR(type,nr,size) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;表示定义一个类型为type，序号为nr，数据大小为size的读命令</span>
   </div> 
   <div>
    <span style="color:#f00000;">_IOW(type,nr,size) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 表示定义一个类型为type，序号为nr，数据大小为size的写命令</span>
   </div> 
   <div>
    <span style="color:#f00000;">_IOWR(type,nr,size) &nbsp; &nbsp; &nbsp; &nbsp; 表示定义一个类型为type，序号为nr，数据大小为size的写读命令</span>
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    通常的type可采用某一个字母或者数字作为设备命令类型。
   </div> 
   <div>
    是实际运用中通常采用如下的方法定义一个具体的命令:
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li><span style="color:#f00000;">//头文件</span></li> 
      <li><span style="color:#f00000;">#include</span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">/*定义一系列的命令*/<br></span></li> 
      <li><span style="color:#f00000;">/*幻数，主要用于表示类型*/<br></span></li> 
      <li><span style="color:#f00000;">#define MAGIC_NUM 'k'<br></span></li> 
      <li><span style="color:#f00000;">/*打印命令*/<br></span></li> 
      <li><span style="color:#f00000;">#define MEMDEV_PRINTF _IO(MAGIC_NUM,1)<br></span></li> 
      <li><span style="color:#f00000;">/*从设备读一个int数据*/<br></span></li> 
      <li><span style="color:#f00000;">#define MEMDEV_READ _IOR(MAGIC_NUM,2,int)<br></span></li> 
      <li><span style="color:#f00000;">/*往设备写一个int数据*/<br></span></li> 
      <li><span style="color:#f00000;">#define MEMDEV_WRITE _IOW(MAGIC_NUM,3,int)<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">/*最大的序列号*/<br></span></li> 
      <li><span style="color:#f00000;">#define MEM_MAX_CMD 3</span></li> 
     </ol>
    </div> 
   </div> 
   <div>
    还有对命令进行解析的宏，用来确定具体命令的四个部分（方向，大小，类型，序号）具体如下所示：
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li><span style="color:#f00000;">/*确定命令的方向*/<br></span></li> 
      <li><span style="color:#f00000;">_IOC_DIR(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br></span></li> 
      <li><span style="color:#f00000;">/*确定命令的类型*/<br></span></li> 
      <li><span style="color:#f00000;">_IOC_TYPE(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br></span></li> 
      <li><span style="color:#f00000;">/*确定命令的序号*/<br></span></li> 
      <li><span style="color:#f00000;">_IOC_NR(nr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br></span></li> 
      <li><span style="color:#f00000;">/*确定命令的大小*/<br></span></li> 
      <li> <span style="color:#f00000;">_IOC_SIZE(nr)&nbsp; &nbsp;</span>&nbsp;</li> 
     </ol>
    </div> 
   </div> 
   <div>
    上面的几个宏可以用来命令，实现命令正确性的检查。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    ioctl的实现过程主要包括如下的过程：
   </div> 
   <div>
    1、命令的检测
   </div> 
   <div>
    2、指针参数的检测
   </div> 
   <div>
    3、命令的控制switch-case语句
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    1、命令的检测主要包括类型的检查，数据大小，序号的检测，通过结合上面的命令解析宏可以快速的确定。
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*检查类型，幻数是否正确*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(_IOC_TYPE(cmd)!=MAGIC_NUM)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-EINVAL;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*检测命令序号是否大于允许的最大序号*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(_IOC_NR(cmd)&gt;&nbsp;MEM_MAX_CMD)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-EINVAL;</li> 
     </ol>
    </div> 
   </div> 
   <div>
    2、主要是指针参数的检测。指针参数主要是因为内核空间和用户空间的差异性导致的，因此需要来自用户空间指针的有效性。使用copy_from_user,copy_to_user,get_user,put_user之类的函数时，由于函数会实现指针参量的检测，因此可以省略，但是采用__get_user(),__put_user()之类的函数时一定要进行检测。具体的检测方法如下所示：
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li>if(<span style="color:#f00000;">_IOC_DIR(cmd) &amp; _IOC_READ</span>)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><span style="color:#f00000;">err = !access_ok</span>(<span style="color:#f00000;">VERIFY_WRITE</span>,(void&nbsp;*)args,_IOC_SIZE(cmd));</strong> </li> 
      <li>else&nbsp;i<span style="color:#f00000;">f(_IOC_DIR(cmd) &amp; _IOC_WRITE)</span> </li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp;<strong>&nbsp;<span style="color:#f00000;">err = !access_ok</span>(<span style="color:#f00000;">VERIFY_READ</span>,(void&nbsp;*)args,_IOC_SIZE(cmd));</strong> </li> 
      <li>if(err)/*返回错误*/</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; return&nbsp;-EFAULT;</li> 
     </ol>
    </div> 
   </div> 
   <div>
    <span style="color:#f00000;">当方向是读时，说明是从设备读数据到用户空间，因此要检测用户空间的指针是否可写，采用VERIFY_WRITE，而当方向是写时，说明是往设备中写数据，因此需要检测用户空间中的指针的可读性VERIFY_READ。检查通常采用access_ok()实现检测，第一个参数为读写，第二个为检测的指针，第三个为数据的大小。</span>
   </div> 
   <div>
    3、命名的控制：
   </div> 
   <div>
    命令的控制主要是采用switch和case相结合实现的，这于window编程中的检测各种消息的实现方式是相同的。
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li>/*根据命令执行相应的操作*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(cmd)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;MEMDEV_PRINTF:</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk("&lt;--------CMD MEMDEV_PRINTF Done------------&gt;\n\n");</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;MEMDEV_READ:</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioarg&nbsp;=&nbsp;&amp;mem_devp-&gt;data;</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;__put_user(ioarg,(int&nbsp;*)args);</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioarg&nbsp;=&nbsp;0;</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;MEMDEV_WRITE:</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret&nbsp;=&nbsp;__get_user(ioarg,(int&nbsp;*)args);</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk("&lt;--------CMD MEMDEV_WRITE Done ioarg = %d---------&gt;\n\n",ioarg);&nbsp;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioarg&nbsp;=&nbsp;0;</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ret&nbsp;=&nbsp;-EINVAL;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk("&lt;-------INVAL CMD---------&gt;\n\n");</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li> 
     </ol>
    </div> 
   </div> 
   <div>
    这只是基本的框架结构，实际中根据具体的情况进行修改。这样就实现了基本的命令控制。
   </div> 
   <div>
    文件操作支持的集合如下：
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li>/*添加该模块的基本文件操作支持*/</li> 
      <li>static&nbsp;const&nbsp;struct file_operations mem_fops&nbsp;=</li> 
      <li>{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*结尾不是分号，注意其中的差别*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.owner&nbsp;=&nbsp;THIS_MODULE,</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.llseek&nbsp;=&nbsp;mem_llseek,</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.read&nbsp;=&nbsp;mem_read,</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.write&nbsp;=&nbsp;mem_write,</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.open&nbsp;=&nbsp;mem_open,</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.release&nbsp;=&nbsp;mem_release,</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#f00000;">&nbsp;&nbsp;/*添加新的操作支持*/<br></span> </li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.unlocked_ioctl = mem_ioctl,</span></li> 
      <li>};</li> 
     </ol>
    </div> 
   </div> 
   <div>
    需要注意不是ioctl,而是unlocked_ioctl。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    <span style="color:#f00000;">二、设备的堵塞读写方式实现，通常采用等待队列。</span>
   </div> 
   <div>
    设备的堵塞读写方式，默认情况下的读写操作都是堵塞型的，具体的就是如果需要读数据，当设备中没有数据可读的时候应该等待设备中有设备再读，当往设备中写数据时，如果上一次的数据还没有被读完成，则不应该写入数据，就会导致进程的堵塞，等待数据可读写。但是在应用程序中也可以采用非堵塞型的方式进行读写。只要在打开文件的时候添加一个O_NONBLOCK,这样在不能读写的时候就会直接返回，而不会等待。
   </div> 
   <div>
    因此我们在实际设计驱动设备的同时需要考虑读写操作的堵塞方式。堵塞方式的设计主要是通过等待队列实现，通常是将等待队列（实质就是一个链表）的头作为设备数据结构的一部分。在设备初始化过程中初始化等待队列的头。最后在设备读写操作的实现添加相应的等待队列节点，并进行相应的控制。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    等待队列的操作基本如下：
   </div> 
   <div>
    1、等待队列的头定义并初始化的过程如下：
   </div> 
   <div>
    方法一：
   </div> 
   <div>
    struct wait_queue_head_t mywaitqueue;
   </div> 
   <div>
    init_waitqueue_head(&amp;mywaitqueue);
   </div> 
   <div>
    方法二：
   </div> 
   <div>
    DECLARE_WAIT_QUEUE_HEAD(mywaitqueue);
   </div> 
   <div>
    以上的两种都能实现定义和初始化等待队列头。
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    2、创建、移除一个等待队列的节点，并添加、移除相应的队列。
   </div> 
   <div>
    定义一个等待队列的节点:DECLARE_WAITQUEUE(wait,tsk)
   </div> 
   <div>
    其中tsk表示一个进程，可以采用current当前的进程。
   </div> 
   <div>
    添加到定义好的等待队列头中。
   </div> 
   <div>
    add_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
   </div> 
   <div>
    即：add_wait_queue(&amp;mywaitqueue,&amp;wait);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    移除等待节点
   </div> 
   <div>
    remove_wait_queue(wait_queue_head_t *q,wait_queue_t *wait);
   </div> 
   <div>
    即：remove_wait_queue(&amp;mywaitqueue,&amp;wait);
   </div> 
   <div>
    &nbsp;
   </div> 
   <div>
    3、等待事件
   </div> 
   <div>
    wait_event(queue,condition);当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下不能被信号打断。
   </div> 
   <div>
    wait_event_interruptible(queue,condition);当condition为真时，等待队列头queue对应的队列被唤醒，否则继续堵塞。这种情况下能被信号打断。
   </div> 
   <div>
    4、唤醒等待队列
   </div> 
   <div>
    wait_up(wait_queue_head_t *q),唤醒该等待队列头对应的所有等待。
   </div> 
   <div>
    wait_up_interruptible(wait_queue_head_t *q)唤醒处于TASK_INTERRUPTIBLE的等待进程。
   </div> 
   <div>
    应该成对的使用。即wait_event于wait_up,而wait_event_interruptible与wait_up_interruptible。
   </div> 
   <div> 
    <div class="codeText"> 
     <ol>
      <li><span style="font-family:Simsun;">&nbsp;</span></li> 
      <li>wait_event和wait_event_interruptible的实现都是采用宏的方式，都是一个重新调度的过程，如下所示：</li> 
     </ol>
     <div>
      <ol>
       <li> <span style="color:#5c5c5c;">#define&nbsp;</span><span style="color:#f00000;">wait_event_interruptible</span>(<span style="color:#5c5c5c;">wq</span>,<span style="color:#5c5c5c;">&nbsp;condition</span>)<span style="color:#5c5c5c;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\</li> 
       <li>({&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
       <li>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;__ret&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
       <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(condition))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
       <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_<span style="color:#f00000;">_wait_event_interruptible</span>(<span style="color:#5c5c5c;">wq</span>,<span style="color:#5c5c5c;">&nbsp;condition</span>,<span style="color:#5c5c5c;">&nbsp;__ret</span>);<span style="color:#5c5c5c;">&nbsp;&nbsp;&nbsp;&nbsp;</span>\</li> 
       <li>&nbsp;&nbsp;&nbsp;&nbsp;__ret;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
       <li>})</li> 
      </ol>
     </div> 
     <ol>
      <li>#define __wait_event_interruptible(wq,&nbsp;condition,&nbsp;ret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>do&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp; &nbsp; &nbsp;<span style="color:#f00000;">/*此处存在一个声明等待队列的语句，因此不需要再重新定义一个等待队列节点*/</span> </li> 
      <li> <span style="color:#f00000;">&nbsp; &nbsp; DEFINE_WAIT(__wait);</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<span style="color:#f00000;"><br></span> </li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="color:#f00000;">/*此处就相当于add_wait_queue()操作，具体参看代码如下所示*/</span> </li> 
      <li> <span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prepare_to_wait(&amp;wq, &amp;__wait, TASK_INTERRUPTIBLE);</span>&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(condition)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(<span style="color:#f00000;">!signal_pending(current)</span>)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*此处是调度，丢失CPU，因此需要wake_up函数唤醒当前的进程</li> 
      <li><span class="Apple-tab-span"> 根据定义可知，如果条件不满足，进程就失去CPU,能够跳出for循环的出口只有</span></li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1、当条件满足时2、当signal_pending（current）=1时。</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1、就是满足条件，也就是说wake_up函数只是退出了schedule函数，</li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 而真正退出函数还需要满足条件</li> 
      <li><span class="Apple-tab-span">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2、说明进程可以被信号唤醒。也就是信号可能导致没有满足条件时就唤醒当前的进程。&nbsp;</span></li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这也是后面的代码采用while判断的原因.防止被信号唤醒。 &nbsp;&nbsp;</li> 
      <li><span class="Apple-tab-span"> &nbsp; &nbsp;*/</span></li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#f00000;">&nbsp;schedule();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br></span> </li> 
      <li> <span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;-ERESTARTSYS;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>&nbsp;&nbsp;&nbsp;<span style="color:#f00000;">&nbsp;finish_wait(&amp;wq, &amp;__wait);&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</li> 
      <li>}&nbsp;while&nbsp;(0)</li> 
      <li> </li> 
     </ol>
     <div> 
      <span style="color:#5c5c5c;">#define&nbsp;</span>
      <span style="color:#f00000;">DEFINE_WAIT(</span>
      <span style="color:#5c5c5c;">name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span> 
     </div> 
     <div> 
      <div> 
       <span style="color:#5c5c5c;">#define&nbsp;</span>
       <span style="color:#f00000;">DEFINE_WAIT_FUNC</span>
       <span style="color:#5c5c5c;">(name, function)</span>
       <span class="Apple-tab-span"> <span style="color:#5c5c5c;">\</span></span> 
      </div> 
      <div>
       <span class="Apple-tab-span"> wait_queue_t name = {<span class="Apple-tab-span"> \</span></span>
      </div> 
      <div>
       <span class="Apple-tab-span"> .private<span class="Apple-tab-span"> = current,<span class="Apple-tab-span"> \</span></span></span>
      </div> 
      <div>
       <span class="Apple-tab-span"> .func<span class="Apple-tab-span"> = function,<span class="Apple-tab-span"> \</span></span></span>
      </div> 
      <div>
       <span class="Apple-tab-span"> .task_list<span class="Apple-tab-span"> = LIST_HEAD_INIT((name).task_list),<span class="Apple-tab-span"> \</span></span></span>
      </div> 
      <div>
       <span class="Apple-tab-span"> }</span>
      </div> 
      <div>
       &nbsp;
      </div> 
     </div> 
     <ol>
      <li> <span style="color:#0000cc;">void&nbsp;</span>prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)</li> 
      <li><span style="color:#0000cc;">{</span></li> 
      <li><span style="color:#0000cc;"><span class="Apple-tab-span"> unsigned long flags;</span></span></li> 
      <li><span style="color:#0000cc;">&nbsp;</span></li> 
      <li><span style="color:#0000cc;"><span class="Apple-tab-span"> wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span></span></li> 
      <li><span style="color:#0000cc;"><span class="Apple-tab-span"> spin_lock_irqsave(&amp;q-&gt;lock, flags);</span></span></li> 
      <li><span style="color:#0000cc;"><span class="Apple-tab-span"> if (list_empty(&amp;wait-&gt;task_list))</span></span></li> 
      <li><span style="color:#0000cc;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/*添加节点到等待队列*/</span></li> 
      <li><span class="Apple-tab-span"> <span style="color:#f00000;">__add_wait_queue(q, wait);</span></span></li> 
      <li><span style="color:#0000cc;"><span class="Apple-tab-span"> set_current_state(state);</span></span></li> 
      <li><span style="color:#0000cc;"><span class="Apple-tab-span"> spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span></span></li> 
      <li><span style="color:#0000cc;">}</span></li> 
      <li><span style="color:#0000cc;">唤醒的操作也是类似的。</span></li> 
      <li> <span style="color:#0000cc;">#define wake_up_interruptible(x)</span><span class="Apple-tab-span"> <span style="color:#f00000;">__wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)</span></span> </li> 
     </ol>
     <div>
      <span style="color:#0000cc;">&nbsp;</span>
     </div> 
     <div> 
      <span style="color:#0000cc;">&nbsp;&nbsp;void&nbsp;</span>
      <span style="color:#f00000;">__wake_up</span>
      <span style="color:#0000cc;">(wait_queue_head_t *q, unsigned int mode,</span> 
     </div> 
     <div>
      <span style="color:#0000cc;"><span class="Apple-tab-span"> int nr_exclusive, void *key)</span></span>
     </div> 
     <div>
      <span style="color:#0000cc;">{</span>
     </div> 
     <div>
      <span style="color:#0000cc;"><span class="Apple-tab-span"> unsigned long flags;</span></span>
     </div> 
     <div>
      <span style="color:#0000cc;">&nbsp;</span>
     </div> 
     <div>
      <span style="color:#0000cc;"><span class="Apple-tab-span"> spin_lock_irqsave(&amp;q-&gt;lock, flags);</span></span>
     </div> 
     <div>
      <span class="Apple-tab-span"> <span style="color:#f00000;">__wake_up_common(q, mode, nr_exclusive, 0, key);</span></span>
     </div> 
     <div>
      <span style="color:#0000cc;"><span class="Apple-tab-span"> spin_unlock_irqrestore(&amp;q-&gt;lock, flags);</span></span>
     </div> 
     <div>
      <span style="color:#0000cc;">}</span>
     </div> 
     <div>
      <span style="color:#0000cc;">&nbsp;</span>
     </div> 
     <div> 
      <div> 
       <span style="color:#0000cc;">static void&nbsp;</span>
       <span style="color:#f00000;">__wake_up_common</span>
       <span style="color:#0000cc;">(wait_queue_head_t *q, unsigned int mode,</span> 
      </div> 
      <div>
       <span class="Apple-tab-span"> int nr_exclusive, int wake_flags, void *key)</span>
      </div> 
      <div>
       {
      </div> 
      <div>
       <span class="Apple-tab-span"> wait_queue_t *curr, *next;</span>
      </div> 
      <div>
       &nbsp;
      </div> 
      <div>
       <span class="Apple-tab-span"> <span style="color:#f00000;">list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) {</span></span>
      </div> 
      <div>
       <span style="color:#f00000;"><span class="Apple-tab-span"> unsigned flags = curr-&gt;flags;</span></span>
      </div> 
      <div>
       &nbsp;
      </div> 
      <div>
       <span class="Apple-tab-span"> if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;</span>
      </div> 
      <div>
       <span class="Apple-tab-span"> (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span>
      </div> 
      <div>
       <span class="Apple-tab-span"> break;</span>
      </div> 
      <div>
       <span class="Apple-tab-span"> }</span>
      </div> 
      <div>
       }
      </div> 
     </div> 
    </div> 
   </div> 
   <div>
    等待队列通常用在驱动程序设计中的堵塞读写操作，并不需要手动的添加节点到队列中，直接调用即可实现，具体的实现方法如下：
   </div> 
   <div>
    1、在设备结构体中添加等待队列头，由于读写都需要堵塞，所以添加两个队列头，分别用来堵塞写操作，写操作。
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li>#include&lt;linux/wait.h&gt;</li> 
      <li> </li> 
      <li>struct mem_dev</li> 
      <li>{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*data;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long size;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*添加一个并行机制*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spinlock_t lock;</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#f00000;">&nbsp;/*添加一个等待队列t头*/<br></span> </li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait_queue_head_t rdqueue;<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait_queue_head_t wrqueue;</span></li> 
      <li>};</li> 
     </ol>
    </div> 
   </div> 
   <div>
    2、然后在模块初始化中初始化队列头:
   </div> 
   <div> 
    <div class="codeText">
     <ol>
      <li> </li> 
      <li><span style="color:#0000ff;">/*初始化函数*/</span></li> 
      <li><span style="color:#0000ff;">static int memdev_init(void)</span></li> 
      <li><span style="color:#0000ff;">{</span></li> 
      <li><span style="color:#0000ff;">&nbsp; &nbsp; &nbsp; &nbsp;....</span></li> 
      <li>&nbsp; &nbsp; &nbsp; &nbsp; for(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MEMDEV_NR_DEVS;&nbsp;i)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_devp[i].size&nbsp;=&nbsp;MEMDEV_SIZE;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*对设备的数据空间分配空间*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem_devp[i].data&nbsp;=&nbsp;kmalloc(MEMDEV_SIZE,GFP_KERNEL);</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*问题，没有进行错误的控制*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(mem_devp[i].data,0,MEMDEV_SIZE);</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*初始化定义的互信息量*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化定义的自旋锁ua</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock_init(&amp;(mem_devp[i].lock));</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*初始化两个等待队列头,需要注意必须用括号包含起来，使得优先级正确*/</li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_waitqueue_head(&amp;(mem_devp[i].rdqueue));<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_waitqueue_head(&amp;(mem_devp[i].wrqueue));</span></li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li> 
      <li><span style="color:#0000cc;">&nbsp; &nbsp; &nbsp; ...</span></li> 
      <li><span style="color:#0000cc;">}</span></li> 
     </ol>
    </div> 
   </div> 
   <div>
    <span style="color:#f00000;">3、确定一个具体的条件，比如数据有无，具体的条件根据实际的情况设计。</span>
   </div> 
   <div> 
    <div>
     <span style="color:#f00000;">/*等待条件*/</span>
    </div> 
    <div>
     <span style="color:#f00000;">static bool havedata = false;</span>
    </div> 
   </div> 
   <div>
    <span style="color:#f00000;">&nbsp;</span>
   </div> 
   <div>
    4、在需要堵塞的读函数，写函数中分别实现堵塞，首先定义等待队列的节点，并添加到队列中去，然后等待事件的唤醒进程。但是由于读写操作的两个等待队列都是基于条件havedata的，所以在读完成以后需要唤醒写，写完成以后需要唤醒读操作，同时更新条件havedata，最后还要移除添加的等待队列节点。
   </div> 
   <div> 
    <div class="codeText"> 
     <ol>
      <li>/*read函数的实现*/</li> 
      <li>static ssize_t mem_read(struct file&nbsp;*filp,char __user&nbsp;*buf,&nbsp;size_t size,loff_t&nbsp;*ppos)</li> 
      <li>{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long p&nbsp;=&nbsp;*ppos;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;count&nbsp;=&nbsp;size;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;0;</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct mem_dev&nbsp;*dev&nbsp;=&nbsp;filp-&gt;private_data;</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*参数的检查，首先判断文件位置*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(p&nbsp;&gt;=&nbsp;MEMDEV_SIZE)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*改正文件大小*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(count&nbsp;&gt;&nbsp;MEMDEV_SIZE&nbsp;-&nbsp;p)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;MEMDEV_SIZE&nbsp;-&nbsp;p;</li> 
     </ol>
     <div> 
      <span style="color:#5c5c5c;">&nbsp; &nbsp; &nbsp;&nbsp;</span>
      <span style="color:#f00000;">&nbsp; &nbsp;#if 0</span> 
     </div> 
     <ol>
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#f00000;">&nbsp;&nbsp;/*添加一个等待队列节点到当前进程中*/<br></span> </li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DECLARE_WAITQUEUE(wait_r,current);<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*将节点添加到等待队列中*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_wait_queue(&amp;dev-&gt;rdqueue,&amp;wait_r);<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*添加等待队列，本来采用if即可，但是由于信号等可能导致等待队列的唤醒，因此采用循环，确保不会出现误判*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp; &nbsp; &nbsp; &nbsp; #endif</span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(!havedata)<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*判断用户是否设置为非堵塞模式读,告诉用户再读*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(filp-&gt;f_flags &amp; O_NONBLOCK)<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -EAGAIN;<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*依据条件havedata判断队列的状态，防止进程被信号唤醒*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait_event_interruptible(dev-&gt;rdqueue,havedata);<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;dev-&gt;lock);</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*从内核读数据到用户空间，实质就通过private_data访问设备*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(copy_to_user(buf,(void&nbsp;*)(dev-&gt;data&nbsp;p),count))</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*出错误*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;-EFAULT;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*移动当前文件光标的位置*/</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ppos&nbsp;=&nbsp;count;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO&nbsp;"read %d bytes(s) from %d\n",count,p);</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li> 
      <li>&nbsp; &nbsp; &nbsp;&nbsp;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;dev-&gt;lock);</li> 
     </ol>
     <div>
      <span style="color:#5c5c5c;"><span class="Apple-tab-span"> &nbsp;#if 0</span></span>
     </div> 
     <ol>
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#f00000;">&nbsp;&nbsp;/*将等待队列节点从读等待队列中移除*/<br></span> </li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove_wait_queue(&amp;dev-&gt;rdqueue,&amp;wait_r);<br></span></li> 
      <li><span style="color:#f00000;"><span class="Apple-tab-span"> #endif&nbsp;</span></span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp; &nbsp; &nbsp; &nbsp; /*更新条件havedate*/</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;havedata = false;<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*唤醒写等待队列*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wake_up_interruptible(&amp;dev-&gt;wrqueue);</span></li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;</li> 
      <li>}</li> 
     </ol>
     <div> 
      <div> 
       <div> 
        <div>
         &nbsp;
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div class="codeText"> 
     <ol>
      <li>/*write函数的实现*/</li> 
      <li>static ssize_t mem_write(struct file&nbsp;*filp,const&nbsp;char __user&nbsp;*buf,size_t size,loff_t&nbsp;*ppos)</li> 
      <li>{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long p&nbsp;=&nbsp;*ppos;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;count&nbsp;=&nbsp;size;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;0;</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*获得设备结构体的指针*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct mem_dev&nbsp;*dev&nbsp;=&nbsp;filp-&gt;private_data;</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*检查参数的长度*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(p&nbsp;&gt;=&nbsp;MEMDEV_SIZE)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(count&nbsp;&gt;&nbsp;MEMDEV_SIZE&nbsp;-&nbsp;p)</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;MEMDEV_SIZE&nbsp;-&nbsp;p;</li> 
     </ol>
     <div>
      <span class="Apple-tab-span"> <span style="color:#f00000;">&nbsp; #if 0</span></span>
     </div> 
     <ol>
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*定义并初始化一个等待队列节点，添加到当前进程中*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DECLARE_WAITQUEUE(wait_w,current);<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*将等待队列节点添加到等待队列中*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_wait_queue(&amp;dev-&gt;wrqueue,&amp;wait_w);<br></span></li> 
      <li><span style="color:#f00000;">&nbsp; &nbsp; &nbsp; &nbsp; #endif</span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*添加写堵塞判断*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*为何采用循环是为了防止信号等其他原因导致唤醒*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(havedata)<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*如果是以非堵塞方式*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(filp-&gt;f_flags &amp; O_NONBLOCK)<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -EAGAIN;<br></span></li> 
      <li><span style="color:#f00000;">&nbsp; &nbsp; &nbsp; &nbsp; /*分析源码发现，wait_event_interruptible 中存在DECLARE_WAITQUEUE和add_wait_queue的操作，因此不需要手动添加等待队列节点*/</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait_event_interruptible(&amp;dev-&gt;wrqueue,(!havedata));<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;dev-&gt;lock);</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(copy_from_user(dev-&gt;data&nbsp;p,buf,count))</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;-EFAULT;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*改变文件位置*/</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ppos&nbsp;=&nbsp;count;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;count;</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO&nbsp;"writted %d bytes(s) from %d\n",count,p);</li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;dev-&gt;lock);</li> 
      <li> </li> 
      <li><span class="Apple-tab-span"><span class="Apple-tab-span"> <span style="color:#f00000;">#</span><span style="color:#f00000;">if 0</span></span></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*将该等待节点移除*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove_wait_queue(&amp;dev-&gt;wrqueue,&amp;wait_w);<br></span></li> 
      <li><span style="color:#f00000;"><span class="Apple-tab-span"> #endif&nbsp;</span></span></li> 
      <li><span style="color:#f00000;">&nbsp;</span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*更新条件*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;havedata = true;<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*唤醒读等待队列*/<br></span></li> 
      <li><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wake_up_interruptible(&amp;dev-&gt;rdqueue);</span></li> 
      <li> </li> 
      <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;</li> 
      <li>}</li> 
     </ol>
    </div> 
   </div> 
   <div>
    5、应用程序采用两个不同的进程分别进行读、写，然后检测顺序是否可以调换，检查等待是否正常。
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
