<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>MemCached的telnet命令行参数 « NotBeCN</title>
  <meta name="description" content="                 1、启动Memcache 常用参数    -p &lt;num&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置TCP端口号(默认不设置为: 11211)    -U &lt;num&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UD...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/02/11/jiazhipeng12_90117962.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">MemCached的telnet命令行参数</h1>
    <p class="post-meta">Feb 11, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="artical-content-bak main-content editor-side-new"> 
   <div class="con editor-preview-side" id="result">
    <p style="font-family:Arial;font-size:14px;line-height:26px;"><strong>1、启动Memcache 常用参数</strong></p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-p &lt;num&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置TCP端口号(默认不设置为: 11211)</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-U &lt;num&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP监听端口(默认: 11211, 0 时关闭)&nbsp;</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-l &lt;ip_addr&gt;&nbsp; 绑定地址(默认:所有都允许,无论内外网或者本机更换IP，有安全隐患，若设置为127.0.0.1就只能本机访问)</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以daemon方式运行</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-u &lt;username&gt; 绑定使用指定用于运行进程&lt;username&gt;</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-m &lt;num&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 允许最大内存用量，单位M (默认: 64 MB)</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">-P &lt;file&gt;&nbsp;&nbsp;&nbsp;&nbsp; 将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与-d 一起使用</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;"><br></p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">在linux下：./usr/local/bin/memcached -d -u root&nbsp; -l 192.168.1.197 -m 2048 -p 12121</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">在window下：d:\App_Serv\memcached\memcached.exe -d RunService -l 127.0.0.1 -p 11211 -m 500</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">在<span class="keylink">windows</span>***册为服务后运行：</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">sc.exe create Memcached_srv binpath= “d:\App_Serv\memcached\memcached.exe -d RunService -p 11211 -m 500″start= auto</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">net start Memcached</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;"><strong>2、连接</strong></p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">telnet 127.0.0.1 11211</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;"><strong>3、基本命令&nbsp;</strong><br></p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">您将使用五种基本 memcached 命令执行最简单的操作。这些命令和操作包括：</p>
    <ul style="font-family:Arial;font-size:14px;line-height:26px;" class="list-paddingleft-2">
     <li><p><code>set</code></p></li>
     <li><p><code>add</code></p></li>
     <li><p><code>replace</code></p></li>
     <li><p><code>get</code></p></li>
     <li><p><code>delete</code></p></li>
    </ul>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">&nbsp;</p>
    <p style="font-family:Arial;font-size:14px;line-height:26px;">前三个命令是用于操作存储在 memcached 中的键值对的标准修改命令。它们都非常简单易用，且都使用如下 所示的语法：</p>
    <pre class="displaycode" style="font-size:14px;line-height:26px;">				command&nbsp;&lt;key&gt;&nbsp;&lt;flags&gt;&nbsp;&lt;expiration&nbsp;time&gt;&nbsp;&lt;bytes&gt;
&lt;value&gt;</pre>
    <p>表 1 定义了 memcached 修改命令的参数和用法。</p>
    <p><br></p>
    <p>表 1. memcached 修改命令参数</p>
    <p>参数<span class="Apple-tab-span"> </span>用法</p>
    <p>key<span class="Apple-tab-span"> </span>key 用于查找缓存值</p>
    <p>flags<span class="Apple-tab-span"> </span>可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息</p>
    <p>expiration time<span class="Apple-tab-span"> </span>在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）</p>
    <p>bytes<span class="Apple-tab-span"> </span>在缓存中存储的字节点</p>
    <p>value<span class="Apple-tab-span"> </span>存储的值（始终位于第二行）</p>
    <p>现在，我们来看看这些命令的实际使用。</p>
    <p>3.1 set&nbsp;</p>
    <p>set 命令用于向缓存添加新的键值对。如果键已经存在，则之前的值将被替换。</p>
    <p>注意以下交互，它使用了 set 命令：</p>
    <p>set userId 0 0 5</p>
    <p>12345</p>
    <p>STORED</p>
    <p><br></p>
    <p>如果使用 set 命令正确设定了键值对，服务器将使用单词 STORED 进行响应。本示例向缓存中添加了一个键值对，其键为userId，其值为12345。并将过期时间设置为 0，这将向 memcached 通知您希望将此值存储在缓存中直到删除它为止。</p>
    <p>3.2 add&nbsp;</p>
    <p>仅当缓存中不存在键时，add 命令才会向缓存中添加一个键值对。如果缓存中已经存在键，则之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。</p>
    <p>下面是使用 add 命令的标准交互：</p>
    <p>set userId 0 0 5</p>
    <p>12345</p>
    <p>STORED</p>
    <p><br></p>
    <p>add userId 0 0 5</p>
    <p>55555</p>
    <p>NOT_STORED</p>
    <p><br></p>
    <p>add companyId 0 0 3</p>
    <p>564</p>
    <p>STORED</p>
    <p>3.3 replace&nbsp;</p>
    <p>仅当键已经存在时，replace 命令才会替换缓存中的键。如果缓存中不存在键，那么您将从 memcached 服务器接受到一条 NOT_STORED 响应。</p>
    <p>下面是使用 replace 命令的标准交互：</p>
    <p>replace accountId 0 0 5</p>
    <p>67890</p>
    <p>NOT_STORED</p>
    <p><br></p>
    <p>set accountId 0 0 5</p>
    <p>67890</p>
    <p>STORED</p>
    <p><br></p>
    <p>replace accountId 0 0 5</p>
    <p>55555</p>
    <p>STORED</p>
    <p><br></p>
    <p>最后两个基本命令是 get 和 delete。这些命令相当容易理解，并且使用了类似的语法，如下所示：</p>
    <p>command &lt;key&gt;</p>
    <p><br></p>
    <p>接下来看这些命令的应用。</p>
    <p>3.4 get&nbsp;</p>
    <p>get 命令用于检索与之前添加的键值对相关的值。您将使用 get 执行大多数检索操作。</p>
    <p>下面是使用 get 命令的典型交互：</p>
    <p>set userId 0 0 5</p>
    <p>12345</p>
    <p>STORED</p>
    <p><br></p>
    <p>get userId</p>
    <p>VALUE userId 0 5</p>
    <p>12345</p>
    <p>END</p>
    <p><br></p>
    <p>get bob</p>
    <p>END</p>
    <p><br></p>
    <p>如您所见，get 命令相当简单。您使用一个键来调用 get，如果这个键存在于缓存中，则返回相应的值。如果不存在，则不返回任何内容。</p>
    <p>3.5 delete&nbsp;</p>
    <p>最后一个基本命令是 delete。delete 命令用于删除 memcached 中的任何现有值。您将使用一个键调用delete，如果该键存在于缓存中，则删除该值。如果不存在，则返回一条NOT_FOUND 消息。</p>
    <p>下面是使用 delete 命令的客户机服务器交互：</p>
    <p>set userId 0 0 5</p>
    <p>98765</p>
    <p>STORED</p>
    <p><br></p>
    <p>delete bob</p>
    <p>NOT_FOUND</p>
    <p><br></p>
    <p>delete userId</p>
    <p>DELETED</p>
    <p><br></p>
    <p>get userId</p>
    <p>END</p>
    <p><br></p>
    <p>可以在 memcached 中使用的两个高级命令是 gets 和 cas。gets 和cas 命令需要结合使用。您将使用这两个命令来确保不会将现有的名称/值对设置为新值（如果该值已经更新过）。我们来分别看看这些命令。</p>
    <p>3.6 gets&nbsp;</p>
    <p>gets 命令的功能类似于基本的 get 命令。两个命令之间的差异在于，gets 返回的信息稍微多一些：64 位的整型值非常像名称/值对的 “版本” 标识符。</p>
    <p>下面是使用 gets 命令的客户机服务器交互：</p>
    <p>set userId 0 0 5</p>
    <p>12345</p>
    <p>STORED</p>
    <p><br></p>
    <p>get userId</p>
    <p>VALUE userId 0 5</p>
    <p>12345</p>
    <p>END</p>
    <p><br></p>
    <p>gets userId</p>
    <p>VALUE userId 0 5 4</p>
    <p>12345</p>
    <p>END</p>
    <p><br></p>
    <p>考虑 get 和 gets 命令之间的差异。gets 命令将返回一个额外的值 — 在本例中是整型值 4，用于标识名称/值对。如果对此名称/值对执行另一个set 命令，则gets 返回的额外值将会发生更改，以表明名称/值对已经被更新。清单 6 显示了一个例子：</p>
    <p><br></p>
    <p>清单 6. set 更新版本指示符</p>
    <p><span class="Apple-tab-span"> </span></p>
    <p>set userId 0 0 5</p>
    <p>33333</p>
    <p>STORED</p>
    <p><br></p>
    <p>gets userId</p>
    <p>VALUE userId 0 5 5</p>
    <p>33333</p>
    <p>END</p>
    <p><br></p>
    <p>您看到 gets 返回的值了吗？它已经更新为 5。您每次修改名称/值对时，该值都会发生更改。</p>
    <p>3.7 cas&nbsp;</p>
    <p>cas（check 和 set）是一个非常便捷的 memcached 命令，用于设置名称/值对的值（如果该名称/值对在您上次执行 gets 后没有更新过）。它使用与 set 命令相类似的语法，但包括一个额外的值：gets 返回的额外值。</p>
    <p>注意以下使用 cas 命令的交互：</p>
    <p>set userId 0 0 5</p>
    <p>55555</p>
    <p>STORED</p>
    <p><br></p>
    <p>gets userId</p>
    <p>VALUE userId 0 5 6</p>
    <p>55555</p>
    <p>END</p>
    <p><br></p>
    <p>cas userId 0 0 5 6</p>
    <p>33333</p>
    <p>STORED</p>
    <p><br></p>
    <p>如您所见，我使用额外的整型值 6 来调用 gets 命令，并且操作运行非常顺序。现在，我们来看看清单 7 中的一系列命令：</p>
    <p><br></p>
    <p>清单 7. 使用旧版本指示符的 cas 命令</p>
    <p><span class="Apple-tab-span"> </span></p>
    <p>set userId 0 0 5</p>
    <p>55555</p>
    <p>STORED</p>
    <p><br></p>
    <p>gets userId</p>
    <p>VALUE userId 0 5 8</p>
    <p>55555</p>
    <p>END</p>
    <p><br></p>
    <p>cas userId 0 0 5 6</p>
    <p>33333</p>
    <p>EXISTS</p>
    <p><br></p>
    <p>注意，我并未使用 gets 最近返回的整型值，并且 cas 命令返回 EXISTS 值以示失败。从本质上说，同时使用gets 和cas 命令可以防止您使用自上次读取后经过更新的名称/值对。</p>
    <p>缓存管理命令</p>
    <p>最后两个 memcached 命令用于监控和清理 memcached 实例。它们是 stats 和 flush_all 命令。</p>
    <p>3.8 stats&nbsp;</p>
    <p>stats 命令的功能正如其名：转储所连接的 memcached 实例的当前统计数据。在下例中，执行 stats 命令显示了关于当前 memcached 实例的信息：</p>
    <p>STAT pid 22459 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 进程ID</p>
    <p>STAT uptime 1027046 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器运行秒数</p>
    <p>STAT time 1273043062 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 服务器当前unix时间戳</p>
    <p>STAT version 1.4.4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 服务器版本</p>
    <p>STAT pointer_size 64 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 操作系统字大小(这台服务器是64位的)</p>
    <p>STAT rusage_user 0.040000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;进程累计用户时间</p>
    <p>STAT rusage_system 0.260000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;进程累计系统时间</p>
    <p>STAT curr_connections 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 当前打开连接数</p>
    <p>STAT total_connections 82 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;曾打开的连接总数</p>
    <p>STAT connection_structures 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;服务器分配的连接结构数</p>
    <p>STAT cmd_get 54 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行get命令总数</p>
    <p>STAT cmd_set 34 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行set命令总数</p>
    <p>STAT cmd_flush 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 指向flush_all命令总数</p>
    <p>STAT get_hits 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get命中次数</p>
    <p>STAT get_misses 45 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get未命中次数</p>
    <p>STAT delete_misses 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete未命中次数</p>
    <p>STAT delete_hits 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete命中次数</p>
    <p>STAT incr_misses 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incr未命中次数</p>
    <p>STAT incr_hits 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incr命中次数</p>
    <p>STAT decr_misses 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decr未命中次数</p>
    <p>STAT decr_hits 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decr命中次数</p>
    <p>STAT cas_misses 0 &nbsp; &nbsp;cas未命中次数</p>
    <p>STAT cas_hits 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cas命中次数</p>
    <p>STAT cas_badval 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;使用擦拭次数</p>
    <p>STAT auth_cmds 0</p>
    <p>STAT auth_errors 0</p>
    <p>STAT bytes_read 15785 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;读取字节总数</p>
    <p>STAT bytes_written 15222 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 写入字节总数</p>
    <p>STAT limit_maxbytes 1048576 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;分配的内存数（字节）</p>
    <p>STAT accepting_conns 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 目前接受的链接数</p>
    <p>STAT listen_disabled_num 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
    <p>STAT threads 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 线程数</p>
    <p>STAT conn_yields 0</p>
    <p>STAT bytes 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 存储item字节数</p>
    <p>STAT curr_items 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;item个数</p>
    <p>STAT total_items 34 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;item总数</p>
    <p>STAT evictions 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 为获取空间删除item的总数</p>
    <p><br></p>
    <p>此处的大多数输出都非常容易理解。稍后在讨论缓存性能时，我还将详细解释这些值的含义。至于目前，我们先来看看输出，然后再使用新的键来运行一些 set 命令，并再次运行stats 命令，注意发生了哪些变化。</p>
    <p>3.9 flush_all&nbsp;</p>
    <p>flush_all 是最后一个要介绍的命令。这个最简单的命令仅用于清理缓存中的所有名称/值对。如果您需要将缓存重置到干净的状态，则 flush_all 能提供很大的用处。下面是一个使用 flush_all 的例子：</p>
    <p>set userId 0 0 5</p>
    <p>55555</p>
    <p>STORED</p>
    <p><br></p>
    <p>get userId</p>
    <p>VALUE userId 0 5</p>
    <p>55555</p>
    <p>END</p>
    <p><br></p>
    <p>flush_all</p>
    <p>OK</p>
    <p><br></p>
    <p>get userId</p>
    <p>END</p>
    <p><br></p>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
