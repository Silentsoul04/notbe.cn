<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>java并发 « NotBeCN</title>
  <meta name="description" content="                 并发        Table of Contents    1 什么是并发问题。    2 java中synchronized的用法    3 Java中的锁与排队上厕所。    4 何时释放锁？    5 Lock的使用    6 利用管道进行线程间通信    7 阻塞队列 ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/02/28/jiazhipeng12_90118004.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">java并发</h1>
    <p class="post-meta">Feb 28, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="artical-content-bak main-content editor-side-new"> 
   <div class="con editor-preview-side" id="result">
    <p>并发</p>
    <p><br></p>
    <p>Table of Contents</p>
    <p>1 什么是并发问题。</p>
    <p>2 java中synchronized的用法</p>
    <p>3 Java中的锁与排队上厕所。</p>
    <p>4 何时释放锁？</p>
    <p>5 Lock的使用</p>
    <p>6 利用管道进行线程间通信</p>
    <p>7 阻塞队列</p>
    <p>8 使用Executors、Executor、ExecutorService、ThreadPoolExecutor</p>
    <p>9 并发流程控制</p>
    <p>10 并发3定律</p>
    <p>11 由并发到并行</p>
    <p>1 什么是并发问题。</p>
    <p>多个进程或线程同时(或着说在同一段时间内)访问同一资源会产生并发问题。</p>
    <p>银行两操作员同时操作同一账户就是典型的例子。比如A、B操作员同时读取一余额为1000元的账户，A操作员为该账户增加100元，B操作员同时为该账户减去 50元，A先提交，B后提交。 最后实际账户余额为1000-50=950元，但本该为 1000+100-50=1050。这就是典型的并发问题。如何解决？可以用锁。</p>
    <p>2 java中synchronized的用法</p>
    <p>用法1</p>
    <p>public class Test{</p>
    <p>&nbsp; &nbsp; public synchronized void print(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; ....;</p>
    <p>&nbsp; &nbsp; }&nbsp;</p>
    <p>}</p>
    <p>某线程执行print()方法，则该对象将加锁。其它线程将无法执行该对象的所有synchronized块。</p>
    <p>用法2</p>
    <p>public class Test{</p>
    <p>&nbsp; &nbsp; public void print(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; synchronized(this){//锁住本对象</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }</p>
    <p>}</p>
    <p>同用法1, 但更能体现synchronized用法的本质。</p>
    <p>用法3</p>
    <p>public class Test{</p>
    <p>&nbsp; &nbsp; private String a = "test";</p>
    <p>&nbsp; &nbsp; public void print(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; synchronized(a){//锁住a对象</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; public synchronized void t(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; ...; //这个同步代码块不会因为print()而锁定.</p>
    <p>&nbsp; &nbsp; }</p>
    <p>}</p>
    <p>执行print()，会给对象a加锁，注意不是给Test的对象加锁，也就是说 Test对象的其它synchronized方法不会因为print()而被锁。同步代码块执行完，则释放对a的锁。</p>
    <p>为了锁住一个对象的代码块而不影响该对象其它 synchronized块的高性能写法：</p>
    <p>public class Test{</p>
    <p>&nbsp; &nbsp; private byte[] lock = new byte[0];</p>
    <p>&nbsp; &nbsp; public void print(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; synchronized(lock){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; public synchronized void t(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; ...;&nbsp;</p>
    <p>&nbsp; &nbsp; }</p>
    <p>}</p>
    <p>静态方法的锁</p>
    <p>public class Test{</p>
    <p>&nbsp; &nbsp; public synchronized static void execute(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; ...;</p>
    <p>&nbsp; &nbsp; }</p>
    <p>}</p>
    <p>效果同</p>
    <p>public class Test{</p>
    <p>&nbsp; &nbsp; public static void execute(){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; synchronized(TestThread.class){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }</p>
    <p>}</p>
    <p>3 Java中的锁与排队上厕所。</p>
    <p>锁就是阻止其它进程或线程进行资源访问的一种方式，即锁住的资源不能被其它请求访问。在JAVA中，sychronized关键字用来对一个对象加锁。比如:</p>
    <p>public class MyStack {</p>
    <p>&nbsp; &nbsp; int idx = 0;</p>
    <p>&nbsp; &nbsp; char [] data = new char[6];</p>
    <p><br></p>
    <p>&nbsp; &nbsp; public synchronized void push(char c) {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; data[idx] = c;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; idx++;</p>
    <p>&nbsp; &nbsp; }</p>
    <p><br></p>
    <p>&nbsp; &nbsp; public synchronized char pop() {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; idx--;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; return data[idx];</p>
    <p>&nbsp; &nbsp; }</p>
    <p><br></p>
    <p>&nbsp; &nbsp; public static void main(String args[]){</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; MyStack m = new MyStack();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; /**</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;下面对象m被加锁。严格的说是对象m的所有synchronized块被加锁。</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果存在另一个试图访问m的线程T，那么T无法执行m对象的push和</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop方法。</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; */</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; m.pop();//对象m被加锁。</p>
    <p>&nbsp; &nbsp; }</p>
    <p>}</p>
    <p>Java的加锁解锁跟多个人排队等一个公共厕位完全一样。第一个人进去后顺手把门从里面锁住，其它人只好排队等。第一个人结束后出来时，门才会打开（解锁）。轮到第二个人进去，同样他又会把门从里面锁住，其它人继续排队等待。</p>
    <p>用厕所理论可以很容易明白: 一个人进了一个厕位，这个厕位就会锁住，但不会导致另一个厕位也被锁住，因为一个人不能同时蹲在两个厕位里。对于Java 就是说：Java中的锁是针对同一个对象的，不是针对class的。看下例：</p>
    <p>MyStatck m1 = new MyStack();</p>
    <p>MyStatck m2 = new Mystatck();</p>
    <p>m1.pop();</p>
    <p>m2.pop(); &nbsp;</p>
    <p>m1对象的锁是不会影响m2的锁的，因为它们不是同一个厕位。就是说，假设有 3线程t1,t2,t3操作m1，那么这3个线程只可能在m1上排队等，假设另2个线程 t8,t9在操作m2，那么t8,t9只会在m2上等待。而t2和t8则没有关系，即使m2上的锁释放了，t1,t2,t3可能仍要在m1上排队。原因无它，不是同一个厕位耳。</p>
    <p>Java不能同时对一个代码块加两个锁，这和数据库锁机制不同，数据库可以对一条记录同时加好几种不同的锁，请参见：</p>
    <p>http://hi.baidu.com/dapplehou/blog/item/b341a97744fe6616b151b9a3.html</p>
    <p>4 何时释放锁？</p>
    <p>一般是执行完毕同步代码块（锁住的代码块）后就释放锁，也可以用wait()方式半路上释放锁。wait()方式就好比蹲厕所到一半，突然发现下水道堵住了，不得已必须出来站在一边，好让修下水道师傅(准备执行notify的一个线程）进去疏通马桶，疏通完毕，师傅大喊一声: "已经修好了"(notify)，刚才出来的同志听到后就重新排队。注意啊，必须等师傅出来啊，师傅不出来，谁也进不去。也就是说notify后，不是其它线程马上可以进入封锁区域活动了，而是必须还要等notify代码所在的封锁区域执行完毕从而释放锁以后，其它线程才可进入。</p>
    <p>这里是wait与notify代码示例：</p>
    <p>public synchronized char pop() {</p>
    <p>&nbsp; &nbsp; char c;</p>
    <p>&nbsp; &nbsp; while (buffer.size() == 0) {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; try {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.wait(); //从厕位里出来</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ignore it...</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; c = ((Character)buffer.remove(buffer.size()-1)).</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; charValue();</p>
    <p>&nbsp; &nbsp; return c;</p>
    <p>}</p>
    <p><br></p>
    <p>public synchronized void push(char c) {</p>
    <p>&nbsp; &nbsp; this.notify(); //通知那些wait()的线程重新排队。注意：仅仅是通知它们重新排队。</p>
    <p>&nbsp; &nbsp; Character charObj = new Character(c);</p>
    <p>&nbsp; &nbsp; buffer.addElement(charObj);</p>
    <p>}//执行完毕，释放锁。那些排队的线程就可以进来了。</p>
    <p>再深入一些。</p>
    <p>由于wait()操作而半路出来的同志没收到notify信号前是不会再排队的，他会在旁边看着这些排队的人(其中修水管师傅也在其中）。注意，修水管的师傅不能插队，也得跟那些上厕所的人一样排队，不是说一个人蹲了一半出来后，修水管师傅就可以突然冒出来然后立刻进去抢修了，他要和原来排队的那帮人公平竞争，因为他也是个普通线程。如果修水管师傅排在后面，则前面的人进去后，发现堵了，就wait，然后出来站到一边，再进去一个，再wait，出来，站到一边，只到师傅进去执行notify. 这样，一会儿功夫，排队的旁边就站了一堆人，等着notify.</p>
    <p>终于，师傅进去，然后notify了，接下来呢？</p>
    <p>1. 有一个wait的人（线程）被通知到。</p>
    <p>2. 为什么被通知到的是他而不是另外一个wait的人？取决于JVM.我们无法预先</p>
    <p>&nbsp; &nbsp;判断出哪一个会被通知到。也就是说，优先级高的不一定被优先唤醒，等待</p>
    <p>&nbsp; &nbsp;时间长的也不一定被优先唤醒，一切不可预知！(当然，如果你了解该JVM的</p>
    <p>&nbsp; &nbsp;实现，则可以预知）。</p>
    <p>3. 他（被通知到的线程）要重新排队。</p>
    <p>4. 他会排在队伍的第一个位置吗？回答是：不一定。他会排最后吗？也不一定。</p>
    <p>&nbsp; &nbsp;但如果该线程优先级设的比较高，那么他排在前面的概率就比较大。</p>
    <p>5. 轮到他重新进入厕位时，他会从上次wait()的地方接着执行，不会重新执行。</p>
    <p>&nbsp; &nbsp;恶心点说就是，他会接着拉巴巴，不会重新拉。</p>
    <p>6. 如果师傅notifyAll(). 则那一堆半途而废出来的人全部重新排队。顺序不可知。</p>
    <p>Java DOC 上说，The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object(当前线程释放锁前，唤醒的线程不能去执行）。</p>
    <p>这用厕位理论解释就是显而易见的事。</p>
    <p>5 Lock的使用</p>
    <p>用synchronized关键字可以对资源加锁。用Lock关键字也可以。它是JDK1.5中新增内容。用法如下：</p>
    <p>class BoundedBuffer {</p>
    <p>&nbsp; &nbsp; final Lock lock = new ReentrantLock();</p>
    <p>&nbsp; &nbsp; final Condition notFull &nbsp;= lock.newCondition();&nbsp;</p>
    <p>&nbsp; &nbsp; final Condition notEmpty = lock.newCondition();&nbsp;</p>
    <p><br></p>
    <p>&nbsp; &nbsp; final Object[] items = new Object[100];</p>
    <p>&nbsp; &nbsp; int putptr, takeptr, count;</p>
    <p><br></p>
    <p>&nbsp; &nbsp; public void put(Object x) throws InterruptedException {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; lock.lock();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; try {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (count == items.length)&nbsp;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notFull.await();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items[putptr] = x;&nbsp;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (++putptr == items.length) putptr = 0;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++count;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notEmpty.signal();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; } finally {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.unlock();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }</p>
    <p><br></p>
    <p>&nbsp; &nbsp; public Object take() throws InterruptedException {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; lock.lock();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; try {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (count == 0)&nbsp;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notEmpty.await();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object x = items[takeptr];&nbsp;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (++takeptr == items.length) takeptr = 0;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --count;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notFull.signal();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return x;</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; } finally {</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.unlock();</p>
    <p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
    <p>&nbsp; &nbsp; }&nbsp;</p>
    <p>}</p>
    <p>(注：这是JavaDoc里的例子，是一个阻塞队列的实现例子。所谓阻塞队列，就是一个队列如果满了或者空了，都会导致线程阻塞等待。Java里的 ArrayBlockingQueue提供了现成的阻塞队列，不需要自己专门再写一个了。)</p>
    <p>一个对象的lock.lock()和lock.unlock()之间的代码将会被锁住。这种方式比起synchronize好在什么地方？简而言之，就是对wait的线程进行了分类。用厕位理论来描述，则是那些蹲了一半而从厕位里出来等待的人原因可能不一样，有的是因为马桶堵了，有的是因为马桶没水了。通知(notify)的时候，就可以喊：因为马桶堵了而等待的过来重新排队（比如马桶堵塞问题被解决了），或者喊，因为马桶没水而等待的过来重新排队(比如马桶没水问题被解决了）。这样可以控制得更精细一些。不像synchronize里的wait和notify，不管是马桶堵塞还是马桶没水都只能喊：刚才等待的过来排队！假如排队的人进来一看，发现原来只是马桶堵塞问题解决了，而自己渴望解决的问题（马桶没水）还没解决，只好再回去等待(wait)，白进来转一圈，浪费时间与资源。</p>
    <p>Lock方式与synchronized对应关系：</p>
    <p>Lock<span class="Apple-tab-span"></span>await<span class="Apple-tab-span"></span>signal<span class="Apple-tab-span"></span>signalAll</p>
    <p>synchronized<span class="Apple-tab-span"></span>wait<span class="Apple-tab-span"></span>notify<span class="Apple-tab-span"></span>notifyAll</p>
    <p>注意：不要在Lock方式锁住的块里调用wait、notify、notifyAll</p>
    <h2 style="line-height:1.5em;"><span class="section-number-2">6</span>&nbsp;利用管道进行线程间通信</h2>
    <p>原理简单。两个线程，一个操作PipedInputStream,一个操作 PipedOutputStream。PipedOutputStream写入的数据先缓存在Buffer中,如果 Buffer满，此线程wait。PipedInputStream读出Buffer中的数据，如果Buffer 没数据，此线程wait。</p>
    <p>jdk1.5中的阻塞队列可实现同样功能。</p>
    <ol style="font-size:1em;line-height:1.4em;" class="list-paddingleft-2">
     <li><p>例1 这个例子实际上只是单线程，还谈不上线程间通信，但不妨一看。</p><p><a href="http://hi.baidu.com/ecspell/blog/item/7b02d3133ab555005aaf53f5.html" rel="nofollow" style="color:rgb(16,138,198);">http://hi.baidu.com/ecspell/blog/item/7b02d3133ab555005aaf53f5.html</a></p><pre class="example" style="font-size:1em;">package&nbsp;io;
import&nbsp;java.io.*;
public&nbsp;class&nbsp;PipedStreamTest&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedOutputStream&nbsp;ops=new&nbsp;PipedOutputStream();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedInputStream&nbsp;pis=new&nbsp;PipedInputStream();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ops.connect(pis);//实现管道连接
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Producer(ops).run();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Consumer(pis).run();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}
}

//生产者
class&nbsp;Producer&nbsp;implements&nbsp;Runnable{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;PipedOutputStream&nbsp;ops;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Producer(PipedOutputStream&nbsp;ops)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ops=ops;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ops.write("hell,spell".getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ops.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e.printStackTrace();}
&nbsp;&nbsp;&nbsp;&nbsp;}
}

//消费者
class&nbsp;Consumer&nbsp;implements&nbsp;Runnable{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;PipedInputStream&nbsp;pis;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Consumer(PipedInputStream&nbsp;pis)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pis=pis;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;bu=new&nbsp;byte[100];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len=pis.read(bu);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(new&nbsp;String(bu,0,len));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pis.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e.printStackTrace();}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre></li>
     <li><p>例2 对上面的程序做少许改动就成了两个线程。</p><pre class="example" style="font-size:1em;">package&nbsp;io;
import&nbsp;java.io.*;
public&nbsp;class&nbsp;PipedStreamTest&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedOutputStream&nbsp;ops=new&nbsp;PipedOutputStream();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedInputStream&nbsp;pis=new&nbsp;PipedInputStream();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ops.connect(pis);//实现管道连接
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Producer&nbsp;p&nbsp;=&nbsp;new&nbsp;Producer(ops);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(p).start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Consumer&nbsp;c&nbsp;=&nbsp;new&nbsp;Consumer(pis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Thread(c).start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;}
}

//生产者
class&nbsp;Producer&nbsp;implements&nbsp;Runnable{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;PipedOutputStream&nbsp;ops;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Producer(PipedOutputStream&nbsp;ops)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.ops=ops;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ops.write("hell,spell".getBytes());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ops.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e.printStackTrace();}
&nbsp;&nbsp;&nbsp;&nbsp;}
}

//消费者
class&nbsp;Consumer&nbsp;implements&nbsp;Runnable{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;PipedInputStream&nbsp;pis;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Consumer(PipedInputStream&nbsp;pis)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pis=pis;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;bu=new&nbsp;byte[100];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len=pis.read(bu);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(new&nbsp;String(bu,0,len));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pis.close();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e.printStackTrace();}
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre></li>
     <li><p>例3. 这个例子更加贴进应用</p><pre class="example" style="font-size:1em;">import&nbsp;java.io.*;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
public&nbsp;class&nbsp;PipedIO&nbsp;{&nbsp;//程序运行后将sendFile文件的内容拷贝到receiverFile文件中
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{//构造读写的管道流对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedInputStream&nbsp;pis=new&nbsp;PipedInputStream();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PipedOutputStream&nbsp;pos=new&nbsp;PipedOutputStream();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//实现关联&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos.connect(pis);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//构造两个线程，并且启动。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Sender(pos,"c:\\text2.txt").start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Receiver(pis,"c:\\text3.txt").start();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(IOException&nbsp;e){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pipe&nbsp;Error"+&nbsp;e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//线程发送&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
class&nbsp;Sender&nbsp;extends&nbsp;Thread{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PipedOutputStream&nbsp;pos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//构造方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Sender(PipedOutputStream&nbsp;pos,&nbsp;String&nbsp;fileName){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pos=pos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file=new&nbsp;File(fileName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//线程运行方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//读文件内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream&nbsp;fs=new&nbsp;FileInputStream(file);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((data=fs.read())!=-1){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//写入管道始端&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos.write(data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Sender&nbsp;Error"&nbsp;+e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//线程读&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
class&nbsp;Receiver&nbsp;extends&nbsp;Thread{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;PipedInputStream&nbsp;pis;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//构造方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Receiver(PipedInputStream&nbsp;pis,&nbsp;String&nbsp;fileName){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pis=pis;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file=new&nbsp;File(fileName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//线程运行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//写文件流对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileOutputStream&nbsp;fs=new&nbsp;FileOutputStream(file);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从管道末端读&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while((data=pis.read())!=-1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//写入本地文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.write(data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pis.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch(IOException&nbsp;e){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Receiver&nbsp;Error"&nbsp;+e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</pre></li>
    </ol>
    <h2 style="line-height:1.5em;"><span class="section-number-2">7</span>&nbsp;阻塞队列</h2>
    <p>阻塞队列可以代替管道流方式来实现进水管/排水管模式（生产者/消费者).JDK1.5提供了几个现成的阻塞队列. 现在来看ArrayBlockingQueue的代码如下：</p>
    <p>这里是一个阻塞队列</p>
    <pre class="example" style="font-size:1em;">BlockingQueue&lt;Object&gt;&nbsp;blockingQ&nbsp;=&nbsp;new&nbsp;ArrayBlockingQueue&lt;Object&gt;&nbsp;10;</pre>
    <p>一个线程从队列里取</p>
    <pre class="example" style="font-size:1em;">for(;;){
&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;o&nbsp;=&nbsp;blockingQ.take();//队列为空，则等待（阻塞）
}</pre>
    <p>另一个线程往队列存</p>
    <pre class="example" style="font-size:1em;">for(;;){
&nbsp;&nbsp;&nbsp;&nbsp;blockingQ.put(new&nbsp;Object());//队列满，则等待（阻塞）
}</pre>
    <p><span style="font-family:Helvetica, Tahoma, Arial, sans-serif;font-size:14px;line-height:25.2000007629395px;">可见，阻塞队列使用起来比管道简单。</span></p>
    <h2 style="line-height:1.5em;"><span class="section-number-2">8</span>&nbsp;使用Executors、Executor、ExecutorService、ThreadPoolExecutor</h2>
    <p>可以使用线程管理任务。还可以使用jdk1.5提供的一组类来更方便的管理任务。从这些类里我们可以体会一种面向任务的思维方式。这些类是：</p>
    <ol style="font-size:1em;line-height:1.4em;" class="list-paddingleft-2">
     <li><p>Executor接口。使用方法：</p><pre class="example" style="font-size:1em;">Executor&nbsp;executor&nbsp;=&nbsp;anExecutor;//生成一个Executor实例。
executor.execute(new&nbsp;RunnableTask1());</pre><p>用意：使用者只关注任务执行，不用操心去关注任务的创建、以及执行细节等这些第三方实现者关心的问题。也就是说，把任务的调用执行和任务的实现解耦。</p><p>实际上，JDK1.5中已经有该接口出色的实现。够用了。</p></li>
     <li><p>Executors是一个如同Collections一样的工厂类或工具类，用来产生各种不同接口的实例。</p></li>
     <li><p>ExecutorService接口它继承自Executor. Executor只管把任务扔进 executor()里去执行，剩余的事就不管了。而ExecutorService则不同，它会多做点控制工作。比如：</p><pre class="example" style="font-size:1em;">class&nbsp;NetworkService&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;ServerSocket&nbsp;serverSocket;
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;ExecutorService&nbsp;pool;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;NetworkService(int&nbsp;port,&nbsp;int&nbsp;poolSize)&nbsp;throws&nbsp;IOException&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serverSocket&nbsp;=&nbsp;new&nbsp;ServerSocket(port);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool&nbsp;=&nbsp;Executors.newFixedThreadPool(poolSize);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;serve()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.execute(new&nbsp;Handler(serverSocket.accept()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;ex)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.shutdown();&nbsp;//不再执行新任务
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}

class&nbsp;Handler&nbsp;implements&nbsp;Runnable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;Socket&nbsp;socket;
&nbsp;&nbsp;&nbsp;&nbsp;Handler(Socket&nbsp;socket)&nbsp;{&nbsp;this.socket&nbsp;=&nbsp;socket;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;read&nbsp;and&nbsp;service&nbsp;request
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre><p>ExecutorService(也就是代码里的pool对象）执行shutdown后，它就不能再执行新任务了，但老任务会继续执行完毕，那些等待执行的任务也不再等待了。</p></li>
     <li><p>任务提交者与执行者通讯</p><pre class="example" style="font-size:1em;">public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService&nbsp;executor&nbsp;=&nbsp;Executors.newSingleThreadExecutor();
&nbsp;&nbsp;&nbsp;&nbsp;Callable&lt;String&gt;&nbsp;task&nbsp;=&nbsp;new&nbsp;Callable&lt;String&gt;(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;call()throws&nbsp;Exception{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"test";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;Future&lt;String&gt;&nbsp;f&nbsp;=&nbsp;executor.submit(task);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;result&nbsp;=&nbsp;f.get();//等待（阻塞）返回结果
&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);
&nbsp;&nbsp;&nbsp;&nbsp;executor.shutdown();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p>Executors.newSingleThreadExecutor()取得的Executor实例有以下特性:</p>
      <ol style="list-style-type:lower-alpha;" class="list-paddingleft-2">
       <li><p>任务顺序执行. 比如：</p><pre class="example" style="font-size:1em;">executor.submit(task1);
executor.submit(task2);</pre><p>必须等task1执行完，task2才能执行。</p></li>
       <li><p>task1和task2会被放入一个队列里，由一个工作线程来处理。即：一共有2个线程(主线程、处理任务的工作线程）。</p></li>
      </ol></li>
     <li><p>其它的类请参考Java Doc</p></li>
    </ol>
    <h2 style="line-height:1.5em;"><span class="section-number-2">9</span>&nbsp;并发流程控制</h2>
    <p>本节例子来自温少的Java并发教程，可能会有改动。向温少致敬。</p>
    <ol style="font-size:1em;line-height:1.4em;" class="list-paddingleft-2">
     <li><p>CountDownLatch 门插销计数器</p>
      <ol style="list-style-type:lower-alpha;" class="list-paddingleft-2">
       <li><p>启动线程，然后等待线程结束。即常用的主线程等所有子线程结束后再执行的问题。</p><pre class="example" style="font-size:1em;">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub
&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;int&nbsp;count=10;
&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;CountDownLatch&nbsp;completeLatch&nbsp;=&nbsp;new&nbsp;CountDownLatch(count);//定义了门插销的数目是10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;count;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread&nbsp;=&nbsp;new&nbsp;Thread("worker&nbsp;thread"+i){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;xxxx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completeLatch.countDown();//减少一根门插销
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.start();
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;completeLatch.await();//如果门插销还没减完则等待。
}</pre><p>JDK1.4时，常用办法是给子线程设置状态，主线程循环检测。易用性和效率都不好。</p></li>
       <li><p>启动很多线程，等待通知才能开始</p><pre class="example" style="font-size:1em;">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub
&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;CountDownLatch&nbsp;startLatch&nbsp;=&nbsp;new&nbsp;CountDownLatch(1);//定义了一根门插销

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;thread&nbsp;=&nbsp;new&nbsp;Thread("worker&nbsp;thread"&nbsp;+&nbsp;i)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startLatch.await();//如果门插销还没减完则等待
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;xxxx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread.start();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;startLatch.countDown();//减少一根门插销
}</pre></li>
      </ol></li>
     <li><p>CycliBarrier. 等所有线程都达到一个起跑线后才能开始继续运行。</p><pre class="example" style="font-size:1em;">public&nbsp;class&nbsp;CycliBarrierTest&nbsp;implements&nbsp;Runnable&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;CyclicBarrier&nbsp;barrier;

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;CycliBarrierTest(CyclicBarrier&nbsp;barrier)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.barrier&nbsp;=&nbsp;barrier;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;xxxx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.barrier.await();//线程运行至此会检查是否其它线程都到齐了，没到齐就继续等待。到齐了就执行barrier的run函数体里的内容
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;/**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;args
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//参数2代表两个线程都达到起跑线才开始一起继续往下执行
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CyclicBarrier&nbsp;barrier&nbsp;=&nbsp;new&nbsp;CyclicBarrier(2,&nbsp;new&nbsp;Runnable()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;xxxx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;t1&nbsp;=&nbsp;new&nbsp;Thread(new&nbsp;CycliBarrierTest(barrier));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;t2&nbsp;=&nbsp;new&nbsp;Thread(new&nbsp;CycliBarrierTest(barrier));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1.start();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2.start();
&nbsp;&nbsp;&nbsp;&nbsp;}

}</pre><p>这简化了传统的用计数器+wait/notifyAll来实现该功能的方式。</p></li>
    </ol>
    <h2 style="line-height:1.5em;"><span class="section-number-2">10</span>&nbsp;并发3定律</h2>
    <ol style="font-size:1em;line-height:1.4em;" class="list-paddingleft-2">
     <li><p>Amdahl定律. 给定问题规模，可并行化部分占12%，那么即使把并行运用到极致，系统的性能最多也只能提高1/(1-0.12)=1.136倍。即：并行对提高系统性能有上限。</p></li>
     <li><p>Gustafson定律. Gustafson定律说Amdahl定律没有考虑随着cpu的增多而有更多的计算能力可被使用。其本质在于更改问题规模从而可以把Amdahl定律中那剩下的88%的串行处理并行化，从而可以突破性能门槛。本质上是一种空间换时间。</p></li>
     <li><p>Sun-Ni定律. 是前两个定律的进一步推广。其主要思想是计算的速度受限于存储而不是CPU的速度. 所以要充分利用存储空间等计算资源，尽量增大问题规模以产生更好/更精确的解.</p></li>
    </ol>
    <h2 style="line-height:1.5em;"><span class="section-number-2">11</span>&nbsp;由并发到并行</h2>
    <p>计算机识别物体需要飞速的计算，以至于芯片发热发烫，而人在识别物体时却一目了然，却并不会导致某个脑细胞被烧热烧焦（夸张）而感到不适，是由于大脑是一个分布式并行运行系统，就像google用一些廉价的linux服务器可以进行庞大复杂的计算一样，大脑内部无数的神经元的独自计算，互相分享成果，从而瞬间完成需要单个cpu万亿次运算才能有的效果。试想，如果在并行处理领域有所创建，将对计算机的发展和未来产生不可估量的影响。当然，其中的挑战也可想而知：许多的问题是并不容易轻易就“分割”的了的。</p>
    <pre class="example" style="font-size:1em;">作者：&nbsp;Dapple&nbsp;Hou
Email:mmonkeyer@163.com</pre>
    <p><br></p>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
