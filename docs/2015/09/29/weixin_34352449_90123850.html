<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux内核源码分析--内核启动之(1)zImage自解压过程（Linux-3.0 ARMv7） 【转】 « NotBeCN</title>
  <meta name="description" content="                 转自：    http://blog.chinaunix.net/uid-25909619-id-4938388.html &nbsp;            研究内核源码和内核运行原理的时候，很总要的一点是要了解内核的初始情况，也就是要了解内核启动过程。我在研究内核的内存管理的...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/09/29/weixin_34352449_90123850.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux内核源码分析--内核启动之(1)zImage自解压过程（Linux-3.0 ARMv7） 【转】</h1>
    <p class="post-meta">Sep 29, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="Blog_wz1">
    转自：
    <a href="http://blog.chinaunix.net/uid-25909619-id-4938388.html" rel="nofollow">http://blog.chinaunix.net/uid-25909619-id-4938388.html &nbsp;</a> 
   </div> 
   <div class="Blog_wz1">
    研究内核源码和内核运行原理的时候，很总要的一点是要了解内核的初始情况，也就是要了解内核启动过程。我在研究内核的内存管理的时候，想知道内核启动后的页表的放置，页表的初始化等信息，这促使我这次仔细地研究内核的启动代码。 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp; &nbsp; CPU在bootloader的帮助下将内核载入到了内存中，并开始执行。当然，bootloader必须为zImage做好必要的准备： 
     <table style="width:600px;" border="1">
      <tbody>
       <tr>
        <td>&nbsp;1． CPU 寄存器的设置：</td> 
        <td>R0＝0；<br>R1＝Machine ID(即Machine Type Number，定义在linux/arch/arm/tools/mach-types)；<br>R2＝内核启动参数在 RAM 中起始基地址；</td> 
       </tr>
       <tr>
        <td>&nbsp;2． CPU 模式：</td> 
        <td>必须禁止中断（IRQs和FIQs）；<br>CPU 必须 SVC 模式；</td> 
       </tr>
       <tr>
        <td>&nbsp;3． Cache 和 MMU 的设置：</td> 
        <td>MMU 必须关闭；<br>指令 Cache 可以打开也可以关闭；<br>数据 Cache 必须关闭；</td> 
       </tr>
      </tbody>
     </table>
     <div>
      &nbsp;载自：
      <a href="http://blog.chinaunix.net/space.php?uid=20543672&amp;do=blog&amp;id=94371" rel="nofollow">一、Boot Loader的概念和功能</a> 
     </div> 
     <div>
      &nbsp;
     </div> 
     <div> 
      <div>
       &nbsp; &nbsp; 知道内核zImage生成的朋友一定知道：真正的内核执行映像其实是在编译时生成arch/$(ARCH)/boot/文件夹中的Image文件（bin文件），而zImage其实是将这个可执行文件作为数据段包含在了自身中，而zImage的代码功能就是将这个数据（Image）正确地解压到编译时确定的位置中去，并跳到Image中运行。所以实现bootloader引导的压缩映像zImage的入口是由arch/arm /boot/compressed/vmlinux.lds决定的（这个文件是由vmlinux.lds.in生成的）。所以从vmlinux.lds.in中可以看出压缩映像的入口在哪：
      </div> 
     </div> 
     <div>
      &nbsp;
     </div> 
     <div> 
      <div class="codeText">
       <ol>
        <li>......</li> 
        <li>OUTPUT_ARCH(arm)</li> 
        <li><strong><span style="color:#f00000;">ENTRY(_start)</span></strong></li> 
        <li>SECTIONS</li> 
        <li>{</li> 
        <li>/DISCARD/ : {</li> 
        <li>*(.ARM.exidx*)</li> 
        <li>*(.ARM.extab*)</li> 
        <li>/*</li> 
        <li>* Discard any r/w data - this produces a link error if we have any,</li> 
        <li>* which is required for PIC decompression. Local data generates</li> 
        <li>* GOTOFF relocations, which prevents it being relocated independently</li> 
        <li>* of the text/got segments.</li> 
        <li>*/</li> 
        <li>*(.data)</li> 
        <li>}</li> 
        <li> </li> 
        <li>. = TEXT_START;</li> 
        <li>_text = .;</li> 
        <li> </li> 
        <li>.text : {</li> 
        <li><strong><span style="color:#f00000;">_start = .;</span></strong></li> 
        <li>*(.start)</li> 
        <li>*(.text)</li> 
        <li>......</li> 
       </ol>
      </div> 
     </div> 
     <div> 
      <div>
       <strong><span style="font-size:large;">&nbsp; &nbsp; 我们可以在arch/arm/boot/compressed/head.S找到这个start入口，这样就可以从这里开始用代码分析的方法研究bootloader跳转到压缩内核映像后的自解压启动过程：</span></strong>
      </div> 
     </div> 
     <div>
      &nbsp; &nbsp; 再看到MMU设置的时候，我只研究了armv7的指令。看这些代码，必须对ARM的MMU有一定的了解，建议参考ARMv7的构架手册和网上的一份PDF《ARM MMU中文详解》（就是ARM手册中MMU部分的翻译）
     </div> 
     <div>
      &nbsp;
     </div> 
     <div> 
      <div class="codeText">
       <ol>
        <li>/*</li> 
        <li>* linux/arch/arm/boot/compressed/head.S</li> 
        <li>*</li> 
        <li>* Copyright (C) 1996-2002 Russell King</li> 
        <li>* Copyright (C) 2004 Hyok S. Choi (MPU support)</li> 
        <li>*</li> 
        <li>* This program is free software; you can redistribute it and/or modify</li> 
        <li>* it under the terms of the GNU General Public License version 2 as</li> 
        <li>* published by the Free Software Foundation.</li> 
        <li>*/</li> 
        <li>#include</li> 
        <li> </li> 
        <li>/*</li> 
        <li>* 调试宏</li> 
        <li>*</li> 
        <li>* 注意：这些宏必须不包含那些非100%可重定位的代码</li> 
        <li>* 任何试图这样做的结果是导致程序崩溃</li> 
        <li>* 当打开调试时请选择以下一个使用</li> 
        <li>*/</li> 
        <li>#ifdef DEBUG /* 调试宏-中间层 */</li> 
        <li> </li> 
        <li>#if defined(CONFIG_DEBUG_ICEDCC) /* 使用内部调试协处理器CP14 */</li> 
        <li> </li> 
        <li>#if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_V6K) || defined(CONFIG_CPU_V7)</li> 
        <li>.macro loadsp, rb, tmp</li> 
        <li>.endm</li> 
        <li>.macro writeb, ch, rb</li> 
        <li>mcr p14, 0, \ch, c0, c5, 0</li> 
        <li>.endm</li> 
        <li>#elif defined(CONFIG_CPU_XSCALE)</li> 
        <li>.macro loadsp, rb, tmp</li> 
        <li>.endm</li> 
        <li>.macro writeb, ch, rb</li> 
        <li>mcr p14, 0, \ch, c8, c0, 0</li> 
        <li>.endm</li> 
        <li>#else</li> 
        <li>.macro loadsp, rb, tmp</li> 
        <li>.endm</li> 
        <li>.macro writeb, ch, rb</li> 
        <li>mcr p14, 0, \ch, c1, c0, 0</li> 
        <li>.endm</li> 
        <li>#endif</li> 
        <li> </li> 
        <li>#else /* 使用串口作为调试通道 */</li> 
        <li> </li> 
        <li>#include&nbsp;/* 包含构架相关的的调试宏的汇编文件 调试宏-底层 */</li> 
        <li> </li> 
        <li>.macro writeb, ch, rb</li> 
        <li>senduart \ch, \rb</li> 
        <li>.endm</li> 
        <li> </li> 
        <li>#if defined(CONFIG_ARCH_SA1100)</li> 
        <li>.macro loadsp, rb, tmp</li> 
        <li>mov \rb, #0x80000000 @ physical base address</li> 
        <li>#ifdef CONFIG_DEBUG_LL_SER3</li> 
        <li>add \rb, \rb, #0x00050000 @ Ser3</li> 
        <li>#else</li> 
        <li>add \rb, \rb, #0x00010000 @ Ser1</li> 
        <li>#endif</li> 
        <li>.endm</li> 
        <li>#elif defined(CONFIG_ARCH_S3C2410)</li> 
        <li>.macro loadsp, rb, tmp</li> 
        <li>mov \rb, #0x50000000</li> 
        <li>add \rb, \rb, #0x4000 * CONFIG_S3C_LOWLEVEL_UART_PORT</li> 
        <li>.endm</li> 
        <li>#else</li> 
        <li>.macro loadsp, rb, tmp</li> 
        <li>addruart \rb, \tmp</li> 
        <li>.endm</li> 
        <li>#endif</li> 
        <li>#endif</li> 
        <li>#endif /* DEBUG */</li> 
        <li> </li> 
        <li> </li> 
        <li>/* 调试宏-上层 */</li> 
        <li>.macro kputc,val /* 打印字符 */</li> 
        <li>mov r0, \val</li> 
        <li>bl putc</li> 
        <li>.endm</li> 
        <li> </li> 
        <li>.macro kphex,val,len /* 打印十六进制数 */</li> 
        <li>mov r0, \val</li> 
        <li>mov r1, #\len</li> 
        <li>bl phex</li> 
        <li>.endm</li> 
        <li> </li> 
        <li>.macro debug_reloc_start /* 重定位内核调试宏-开始 */</li> 
        <li>#ifdef DEBUG</li> 
        <li>kputc #'\n'</li> 
        <li>kphex r6, 8 /* 处理器 id */</li> 
        <li>kputc #':'</li> 
        <li>kphex r7, 8 /* 构架 id */</li> 
        <li>#ifdef CONFIG_CPU_CP15</li> 
        <li>kputc #':'</li> 
        <li>mrc p15, 0, r0, c1, c0</li> 
        <li>kphex r0, 8 /* 控制寄存器 */</li> 
        <li>#endif</li> 
        <li>kputc #'\n'</li> 
        <li>kphex r5, 8 /* 解压后的内核起始地址 */</li> 
        <li>kputc #'-'</li> 
        <li>kphex r9, 8 /* 解压后的内核结束地址 */</li> 
        <li>kputc #'&gt;'</li> 
        <li>kphex r4, 8 /* 内核执行地址 */</li> 
        <li>kputc #'\n'</li> 
        <li>#endif</li> 
        <li>.endm</li> 
        <li> </li> 
        <li>.macro debug_reloc_end /* 重定位内核调试宏-结束 */</li> 
        <li>#ifdef DEBUG</li> 
        <li>kphex r5, 8 /* 内核结束地址 */</li> 
        <li>kputc #'\n'</li> 
        <li>mov r0, r4</li> 
        <li>bl memdump /* 打印内核起始处 256 字节 */</li> 
        <li>#endif</li> 
        <li>.endm</li> 
        <li> </li> 
        <li>.section ".start", #alloc, #execinstr</li> 
        <li>/*</li> 
        <li>* 清理不同的调用约定</li> 
        <li>*/</li> 
        <li>.align</li> 
        <li>.arm @ 启动总是进入ARM状态</li> 
        <li><span style="color:#f00000;font-size:medium;"><strong>start:</strong></span></li> 
        <li>.type start,#function</li> 
        <li>.rept 7</li> 
        <li>mov r0, r0</li> 
        <li>.endr</li> 
        <li>ARM( mov r0, r0 )</li> 
        <li>ARM( b 1f )</li> 
        <li>THUMB( adr r12, BSYM(1f) )</li> 
        <li>THUMB( bx r12 )</li> 
        <li> </li> 
        <li>.word 0x016f2818 @ 用于boot loader的魔数</li> 
        <li>.word start @ 加载/运行zImage的绝对地址（编译时确定）</li> 
        <li>.word _edata @ zImage结束地址</li> 
        <li>THUMB( .thumb )</li> 
        <li><strong>1: mov r7, r1 <span style="color:#0000f0;">@ 保存构架ID到r7（此前由bootloader放入r1）</span></strong></li> 
        <li> <strong>&nbsp; &nbsp;mov r8, r2</strong><span style="color:#0000f0;"><strong> @ 保存内核启动参数地址到r8（此前由bootloader放入r2）</strong></span> </li> 
        <li> </li> 
        <li>#ifndef __ARM_ARCH_2__</li> 
        <li>/*</li> 
        <li>* 通过Angel调试器启动 - 必须进入 SVC模式且关闭FIQs/IRQs</li> 
        <li>* (numeric definitions from angel arm.h source).</li> 
        <li>* 如果进入时在user模式下，我们只需要做这些</li> 
        <li>*/</li> 
        <li>mrs r2, cpsr @ 获取当前模式</li> 
        <li>tst r2, #3 @ 判断是否是user模式</li> 
        <li>bne not_angel</li> 
        <li>mov r0, #0x17 @ angel_SWIreason_EnterSVC</li> 
        <li>ARM( swi 0x123456 ) @ angel_SWI_ARM</li> 
        <li>THUMB( svc 0xab ) @ angel_SWI_THUMB</li> 
        <li>not_angel:</li> 
        <li>mrs r2, cpsr @ 关闭中断</li> 
        <li>orr r2, r2, #0xc0 @ 以保护调试器的运作</li> 
        <li>msr cpsr_c, r2</li> 
        <li>#else</li> 
        <li> <strong>teqp pc, #0x0c000003</strong> <span style="color:#0000f0;"><strong>@ 关闭中断（此外bootloader已设置模式为SVC）</strong></span> </li> 
        <li>#endif</li> 
        <li> </li> 
        <li>/*</li> 
        <li>* 注意一些缓存的刷新和其他事务可能需要在这里完成</li> 
        <li>* - is there an Angel SWI call for this?</li> 
        <li>*/</li> 
        <li> </li> 
        <li>/*</li> 
        <li>* 一些构架的特定代码可以在这里被连接器插入，</li> 
        <li>* 但是不应使用 r7（保存构架ID）, r8（保存内核启动参数地址）, and r9.</li> 
        <li>*/</li> 
        <li> </li> 
        <li>.text</li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 此处确定解压后的内核映像的绝对地址（物理地址），保存于r4</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 由于配置的不同可能有的结果</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* （1）定义了CONFIG_AUTO_ZRELADDR</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* &nbsp; &nbsp; &nbsp;ZRELADDR是已解压内核最终存放的物理地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* &nbsp; &nbsp; &nbsp;如果AUTO_ZRELADDR被选择了, 这个地址将会在运行是确定：</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* &nbsp; &nbsp; &nbsp;将当pc值和0xf8000000做与操作，</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* &nbsp; &nbsp; &nbsp;并加上TEXT_OFFSET（内核最终存放的物理地址与内存起始的偏移）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* &nbsp; &nbsp; &nbsp;这里假定zImage被放在内存开始的128MB内</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* （2）没有定义CONFIG_AUTO_ZRELADDR</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* &nbsp; &nbsp; &nbsp;直接使用zreladdr（此值位于arch/arm/mach-xxx/Makefile.boot文件确定）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li>#ifdef CONFIG_AUTO_ZRELADDR</li> 
        <li>@ 确定内核映像地址</li> 
        <li>mov r4, pc</li> 
        <li>and r4, r4, #0xf8000000</li> 
        <li>add r4, r4, #TEXT_OFFSET</li> 
        <li>#else</li> 
        <li><strong><span style="color:#0000f0;">ldr r4, =zreladdr</span></strong></li> 
        <li>#endif</li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">bl cache_on /* 开启缓存（以及MMU） */</span></strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">restart: adr r0, LC0</span></strong></li> 
        <li><strong><span style="color:#0000f0;">ldmia r0, {r1, r2, r3, r6, r10, r11, r12}</span></strong></li> 
        <li><strong><span style="color:#0000f0;">ldr sp, [r0, #28]</span></strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 我们可能运行在一个与编译时定义的不同地址上，</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 所以我们必须修正变量指针</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong><span style="color:#0000f0;">sub r0, r0, r1 @ 计算偏移量</span></strong></li> 
        <li><strong><span style="color:#0000f0;">add r6, r6, r0 @ 重新计算_edata</span></strong></li> 
        <li><strong><span style="color:#0000f0;">add r10, r10, r0 @ 重新获得压缩后的内核大小数据位置</span></strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">内核编译系统将解压后的内核大小数据</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">以小端格式</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">附加在压缩数据的后面(其实是“gzip -f -9”命令的结果)</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 下面代码的作用是将解压后的内核大小数据正确地放入r9中（避免了大小端问题）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>ldrb r9, [r10, #0]</strong></li> 
        <li><strong>ldrb lr, [r10, #1]</strong></li> 
        <li><strong>orr r9, r9, lr, lsl #8</strong></li> 
        <li><strong>ldrb lr, [r10, #2]</strong></li> 
        <li><strong>ldrb r10, [r10, #3]</strong></li> 
        <li><strong>orr r9, r9, lr, lsl #16</strong></li> 
        <li><strong>orr r9, r9, r10, lsl #24</strong></li> 
        <li> </li> 
        <li><span style="color:#0000f0;"><strong>/*</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* 下面代码的作用是将正确的当前执行映像的结束地址放入r10</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>*/</strong></span></li> 
        <li><strong>#ifndef CONFIG_ZBOOT_ROM</strong></li> 
        <li><strong>/* malloc 获取的内存空间位于重定向的栈指针之上 (64k max) */</strong></li> 
        <li><strong>add sp, sp, r0</strong></li> 
        <li><strong>add r10, sp, #0x10000</strong></li> 
        <li><strong>#else</strong></li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 如果定义了 ZBOOT_ROM， bss/stack 是非可重定位的,</strong></li> 
        <li><strong>* 但有些人依然可以将其放在RAM中运行,</strong></li> 
        <li><strong>* 这时我们可以参考 _edata.</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>mov r10, r6</strong></li> 
        <li><strong>#endif</strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 检测我们是否会发生自我覆盖的问题</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r4 = 解压后的内核起始地址（最终执行位置）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r9 = 解压后内核的大小</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r10 = 当前执行映像的结束地址, 包含了 bss/stack/malloc 空间（假设是非XIP执行的）</span></strong></li> 
        <li><strong><span style="color:#f00000;">* 我们的基本需求是:</span></strong></li> 
        <li><strong><span style="color:#f00000;">* （若最终执行位置r4在当前映像之后）r4 - 16k 页目录 &gt;= r10 -&gt; OK</span></strong></li> 
        <li><strong><span style="color:#f00000;">* （若最终执行位置r4在当前映像之前）r4 + 解压后的内核大小 &lt;= 当前位置 (pc) -&gt; OK</span></strong></li> 
        <li><strong><span style="color:#f00000;">* 如果上面的条件不满足，就会自我覆盖，必须先搬运当前映像</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong><span style="color:#0000f0;">add r10, r10, #16384</span></strong></li> 
        <li><strong><span style="color:#0000f0;">cmp r4, r10 &nbsp; &nbsp; &nbsp; &nbsp; @ 假设最终执行位置r4在当前映像之后</span></strong></li> 
        <li><strong><span style="color:#0000f0;">bhs wont_overwrite</span></strong></li> 
        <li><strong><span style="color:#0000f0;">add r10, r4, r9 &nbsp; &nbsp; @ 假设最终执行位置r4在当前映像之前</span></strong></li> 
        <li><strong><span style="color:#0000f0;">ARM( cmp r10, pc ) &nbsp;</span><span style="color:#f00000;">@ r10 = 解压后的内核结束地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">THUMB( mov lr, pc )</span></strong></li> 
        <li><strong><span style="color:#0000f0;">THUMB( cmp r10, lr )</span></strong></li> 
        <li><strong><span style="color:#0000f0;">bls wont_overwrite</span></strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">将当前的映像重定向到解压后的内核之后（会发生自我覆盖时才执行，否则就被跳过）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r6 = _edata（已校正）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r10 = 解压后的内核结束地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*</span><span style="color:#f00000;">&nbsp;因为我们要把当前映像向后移动, 所以我们必须由后往前复制代码，</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">以防原数据和目标数据的重叠</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 将解压后的内核结束地址r10扩展（reloc_code_end - restart），</strong></li> 
        <li><strong>* 并对齐到下一个256B边界。</strong></li> 
        <li><strong>* 这样避免了当搬运的偏移较小时的自我覆盖</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>add r10, r10, #((reloc_code_end - restart + 256) &amp; ~255)</strong></li> 
        <li><strong>bic r10, r10, #255</strong></li> 
        <li> </li> 
        <li><strong>/* 获取需要搬运的当前映像的起始位置r5，并向下做32B对齐. */</strong></li> 
        <li><strong>adr r5, restart</strong></li> 
        <li><strong>bic r5, r5, #31</strong></li> 
        <li> </li> 
        <li><strong>sub r9, r6, r5 @ _edata - restart（已向下对齐）= 需要搬运的大小</strong></li> 
        <li><strong>add r9, r9, #31</strong></li> 
        <li><strong>bic r9, r9, #31 @ 做32B对齐 ，r9 = 需要搬运的大小</strong></li> 
        <li><strong>add r6, r9, r5 @ r6 = 当前映像需要搬运的结束地址</strong></li> 
        <li><strong>add r9, r9, r10 @ r9 = 当前映像搬运的目的地的结束地址</strong></li> 
        <li> </li> 
        <li><strong>/* 搬运当前执行映像，不包含 bss/stack/malloc 空间*/</strong></li> 
        <li><strong>1: ldmdb r6!, {r0 - r3, r10 - r12, lr}</strong></li> 
        <li><strong>cmp r6, r5</strong></li> 
        <li><strong>stmdb r9!, {r0 - r3, r10 - r12, lr}</strong></li> 
        <li><strong>bhi 1b</strong></li> 
        <li> </li> 
        <li><strong>/* 保存偏移量，用来修改sp和实现代码跳转 */</strong></li> 
        <li><strong>sub r6, r9, r6</strong></li> 
        <li> </li> 
        <li><strong>#ifndef CONFIG_ZBOOT_ROM</strong></li> 
        <li><strong>/* cache_clean_flush 可能会使用栈，所以重定向sp指针 */</strong></li> 
        <li><strong>add sp, sp, r6</strong></li> 
        <li><strong>#endif</strong></li> 
        <li> </li> 
        <li><strong>bl cache_clean_flush @ 刷新缓存</strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/* 通过搬运的偏移和当前的实际 restart 地址来实现代码跳转*/</span></strong></li> 
        <li><strong>adr r0, BSYM(restart)</strong></li> 
        <li><strong>add r0, r0, r6</strong></li> 
        <li><strong>mov pc, r0</strong></li> 
        <li><span style="color:#f00000;"><strong>/* 在上面的跳转之后，程序又从restart开始。</strong></span></li> 
        <li><span style="color:#f00000;"><strong>* 但这次在检查自我覆盖的时候，新的执行位置必然满足</strong></span></li> 
        <li><span style="color:#f00000;"><strong>* 最终执行位置r4在当前映像之前，r4 + 压缩后的内核大小 &lt;= 当前位置 (pc)</strong></span></li> 
        <li><span style="color:#f00000;"><strong>* 所以必然直接跳到了下面的wont_overwrite执行</strong></span></li> 
        <li><span style="color:#f00000;"><strong>*/</strong></span></li> 
        <li> </li> 
        <li> </li> 
        <li><strong><span style="color:#f00000;">wont_overwrite:</span></strong></li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 如果delta（当前映像地址与编译时的地址偏移）为0, 我们运行的地址就是编译时确定的地址.</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r0 = delta</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r2 = BSS start（编译值）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r3 = BSS end（编译值）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r4 = 内核最终运行的物理地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r7 = 构架ID(bootlodaer传递值)</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r8 = 内核启动参数指针(bootlodaer传递值)</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r11 = GOT start（编译值）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r12 = GOT end（编译值）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* sp = stack pointer（修正值）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>teq r0, #0 @测试delta值</strong></li> 
        <li><strong>beq not_relocated @如果delta为0，无须对GOT表项和BSS进行重定位</strong></li> 
        <li><strong>add r11, r11, r0 @重定位GOT start</strong></li> 
        <li><strong>add r12, r12, r0 @重定位GOT end</strong></li> 
        <li> </li> 
        <li><strong>#ifndef CONFIG_ZBOOT_ROM</strong></li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 如果内核配置 CONFIG_ZBOOT_ROM = n,</strong></li> 
        <li><strong>* 我们必须修正BSS段的指针</strong></li> 
        <li><strong>* 注意：sp已经被修正</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>add r2, r2, r0 @重定位BSS start</strong></li> 
        <li><strong>add r3, r3, r0 @重定位BSS end</strong></li> 
        <li> </li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 重定位所有GOT表的入口项</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>1: ldr r1, [r11, #0] @ 重定位GOT表的入口项</strong></li> 
        <li><strong>add r1, r1, r0 @ 这个修正了 C 引用</strong></li> 
        <li><strong>str r1, [r11], #4</strong></li> 
        <li><strong>cmp r11, r12</strong></li> 
        <li><strong>blo 1b</strong></li> 
        <li><strong>#else</strong></li> 
        <li> </li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 重定位所有GOT表的入口项.</strong></li> 
        <li><strong>* 我们只重定向在（已重定向后）BSS段外的入口</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>1: ldr r1, [r11, #0] @ 重定位GOT表的入口项</strong></li> 
        <li><strong>cmp r1, r2 @ entry &lt; bss_start ||</strong></li> 
        <li><strong>cmphs r3, r1 @ _end &lt; entry table</strong></li> 
        <li><strong>addlo r1, r1, r0 @ 这个修正了 C 引用</strong></li> 
        <li><strong>str r1, [r11], #4</strong></li> 
        <li><strong>cmp r11, r12</strong></li> 
        <li><strong>blo 1b</strong></li> 
        <li><strong>#endif</strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 至此当前映像的搬运和调整已经完成</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 可以开始真正的工作的</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>not_relocated: mov r0, #0</strong></li> 
        <li><strong>1: str r0, [r2], #4 <span style="color:#0000f0;">@ 清零 bss（初始化BSS段）</span></strong></li> 
        <li><strong>str r0, [r2], #4</strong></li> 
        <li><strong>str r0, [r2], #4</strong></li> 
        <li><strong>str r0, [r2], #4</strong></li> 
        <li><strong>cmp r2, r3</strong></li> 
        <li><strong>blo 1b</strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">C运行时环境已经充分建立.</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">设置一些指针就可以解压内核了.</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r4 = 内核最终运行的物理地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r7 = 构架ID</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r8 = 内核启动参数指针</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 下面对r0～r3的配置是decompress_kernel函数对应参数</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r0 = 解压后的输出位置首地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r1 = 可用RAM空间首地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r2 = 可用RAM空间结束地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r3 = 构架ID</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">就是这个decompress_kernel（C函数）输出了"Uncompressing Linux..."</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">以及" done, booting the kernel.\n"</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>mov r0, r4</strong></li> 
        <li><strong>mov r1, sp @ malloc 获取的内存空间位于栈指针之上</strong></li> 
        <li><strong>add r2, sp, #0x10000 @ 64k max</strong></li> 
        <li><strong>mov r3, r7</strong></li> 
        <li><strong><span style="color:#f00000;">bl decompress_kernel</span></strong></li> 
        <li><strong><span style="color:#f00000;">/*</span></strong></li> 
        <li><strong><span style="color:#f00000;">* decompress_kernel(misc.c)--调用--&gt;</span></strong></li> 
        <li><strong><span style="color:#f00000;">* do_decompress(decompress.c)--调用--&gt;</span></strong></li> 
        <li><strong><span style="color:#f00000;">* decompress(../../../../lib/decompress_xxxx.c根据压缩方式的配置而不同)</span></strong></li> 
        <li><strong><span style="color:#f00000;">*/</span></strong></li> 
        <li> </li> 
        <li><strong><span style="color:#f00000;">/*</span></strong></li> 
        <li><strong><span style="color:#f00000;">* 以下是为跳入解压后的内核，再次做准备（恢复解压前的状态）</span></strong></li> 
        <li><strong><span style="color:#f00000;">*/</span></strong></li> 
        <li><strong><span style="color:#0000f0;">bl cache_clean_flush</span></strong></li> 
        <li><strong><span style="color:#0000f0;">bl cache_off </span><span style="color:#f00000;">@ 数据缓存必须关闭（内核的要求）</span></strong></li> 
        <li><strong><span style="color:#0000f0;">mov r0, #0</span><span style="color:#f00000;"> @ r0必须为0</span></strong></li> 
        <li><strong><span style="color:#0000f0;">mov r1, r7 </span><span style="color:#f00000;">@ 恢复构架ID到r1</span></strong></li> 
        <li><strong><span style="color:#0000f0;">mov r2, r8</span><span style="color:#f00000;"> @ 恢复内核启动参数指针到r2</span></strong></li> 
        <li><strong><span style="color:#0000f0;">mov pc, r4</span><span style="color:#f00000;"> @ 跳入解压后的内核映像(Image)入口（arch/arm/kernel/head.S）</span></strong></li> 
        <li> </li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 以下是为了确定当前运行时的地址和编译时确定的地址偏差，</strong></li> 
        <li><strong>* 而将编译时确定的映像数据保存如下，用于检测对比</strong></li> 
        <li><strong>*/</strong></li> 
        <li>.align 2</li> 
        <li>.type LC0, #object</li> 
        <li>LC0: .word LC0 @ r1</li> 
        <li>.word __bss_start @ r2</li> 
        <li>.word _end @ r3</li> 
        <li>.word _edata @ r6</li> 
        <li>.word input_data_end - 4 @ r10 (inflated size location)</li> 
        <li>.word _got_start @ r11</li> 
        <li>.word _got_end @ ip</li> 
        <li>.word .L_user_stack_end @ sp</li> 
        <li>.size LC0, . - LC0</li> 
        <li> </li> 
        <li>#ifdef CONFIG_ARCH_RPC</li> 
        <li>.globl params</li> 
        <li>params: ldr r0, =0x10000100 @ params_phys for RPC</li> 
        <li>mov pc, lr</li> 
        <li>.ltorg</li> 
        <li>.align</li> 
        <li>#endif</li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 开启缓存.</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">我们必须创建页表（并开启MMU）才可以开启数据和指令缓存。</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">我们把页表（节描述符）放在内核执行地址前16k（0x4000）的空间中,</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">且我们希望没人会去用这段地址空间.</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*&nbsp;</span><span style="color:#f00000;">如果我们使用了,可能会出问题的!</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 进入时,</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r4 = 内核最终运行的物理地址</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r7 = 构架ID</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r8 = 内核启动参数指针</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 退出时,</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r0, r1, r2, r3, r9, r10, r12 被修改</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 此例程必须保护:</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r4, r7, r8</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>.align 5</strong></li> 
        <li><strong>cache_on: mov r3, #8 <span style="color:#0000f0;">@ 调用cache_on 函数</span></strong></li> 
        <li><strong>b call_cache_fn</strong></li> 
        <li> </li> 
        <li>/*</li> 
        <li>* Initialize the highest priority protection region, PR7</li> 
        <li>* to cover all 32bit address and cacheable and bufferable.</li> 
        <li>*/</li> 
        <li>__armv4_mpu_cache_on:</li> 
        <li>mov r0, #0x3f @ 4G, the whole</li> 
        <li>mcr p15, 0, r0, c6, c7, 0 @ PR7 Area Setting</li> 
        <li>mcr p15, 0, r0, c6, c7, 1</li> 
        <li> </li> 
        <li>mov r0, #0x80 @ PR7</li> 
        <li>mcr p15, 0, r0, c2, c0, 0 @ D-cache on</li> 
        <li>mcr p15, 0, r0, c2, c0, 1 @ I-cache on</li> 
        <li>mcr p15, 0, r0, c3, c0, 0 @ write-buffer on</li> 
        <li> </li> 
        <li>mov r0, #0xc000</li> 
        <li>mcr p15, 0, r0, c5, c0, 1 @ I-access permission</li> 
        <li>mcr p15, 0, r0, c5, c0, 0 @ D-access permission</li> 
        <li> </li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c10, 4 @ drain write buffer</li> 
        <li>mcr p15, 0, r0, c7, c5, 0 @ flush(inval) I-Cache</li> 
        <li>mcr p15, 0, r0, c7, c6, 0 @ flush(inval) D-Cache</li> 
        <li>mrc p15, 0, r0, c1, c0, 0 @ read control reg</li> 
        <li>@ ...I .... ..D. WC.M</li> 
        <li>orr r0, r0, #0x002d @ .... .... ..1. 11.1</li> 
        <li>orr r0, r0, #0x1000 @ ...1 .... .... ....</li> 
        <li> </li> 
        <li>mcr p15, 0, r0, c1, c0, 0 @ write control reg</li> 
        <li> </li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c5, 0 @ flush(inval) I-Cache</li> 
        <li>mcr p15, 0, r0, c7, c6, 0 @ flush(inval) D-Cache</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv3_mpu_cache_on:</li> 
        <li>mov r0, #0x3f @ 4G, the whole</li> 
        <li>mcr p15, 0, r0, c6, c7, 0 @ PR7 Area Setting</li> 
        <li> </li> 
        <li>mov r0, #0x80 @ PR7</li> 
        <li>mcr p15, 0, r0, c2, c0, 0 @ cache on</li> 
        <li>mcr p15, 0, r0, c3, c0, 0 @ write-buffer on</li> 
        <li> </li> 
        <li>mov r0, #0xc000</li> 
        <li>mcr p15, 0, r0, c5, c0, 0 @ access permission</li> 
        <li> </li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c0, 0 @ invalidate whole cache v3</li> 
        <li>/*</li> 
        <li>* ?? ARMv3 MMU does not allow reading the control register,</li> 
        <li>* does this really work on ARMv3 MPU?</li> 
        <li>*/</li> 
        <li>mrc p15, 0, r0, c1, c0, 0 @ read control reg</li> 
        <li>@ .... .... .... WC.M</li> 
        <li>orr r0, r0, #0x000d @ .... .... .... 11.1</li> 
        <li>/* ?? this overwrites the value constructed above? */</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c1, c0, 0 @ write control reg</li> 
        <li> </li> 
        <li>/* ?? invalidate for the second time? */</li> 
        <li>mcr p15, 0, r0, c7, c0, 0 @ invalidate whole cache v3</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li><span style="color:#0000f0;"><strong>/*</strong></span></li> 
        <li><strong><span style="color:#f00000;">* 初始化MMU页表</span></strong></li> 
        <li><strong><span style="color:#f00000;">* 内核最终运行的物理地址向下16K的空间</span></strong></li> 
        <li><strong><span style="color:#f00000;">* 存放可以寻址4G空间节描述符</span></strong></li> 
        <li><strong><span style="color:#f00000;">* （16KB/4B=4K个描述符，每个描述符映射1MB空间，4K*1MB = 4GB）</span></strong></li> 
        <li><span style="color:#0000f0;"><strong>* 进入时,</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* r4 = 内核最终运行的物理地址</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* r7 = 构架ID</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* r8 = 内核启动参数指针</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* 退出时,</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* r0, r1, r2, r3, r9, r10 被修改</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* 此例程必须保护:</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>* r4, r7, r8</strong></span></li> 
        <li><span style="color:#0000f0;"><strong>*/</strong></span></li> 
        <li><strong>__setup_mmu: sub r3, r4, #16384 @ 页目录大小为16K</strong></li> 
        <li><strong>bic r3, r3, #0xff @ 页目录指针向下对齐</strong></li> 
        <li><strong>bic r3, r3, #0x3f00 @ 对齐方式-16KB</strong></li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 对于这个对齐，是MMU硬件的要求</strong></li> 
        <li><strong>* 转换表基址寄存器（CP15的寄存器2）保存着第一级转换表基址的物理地址。</strong></li> 
        <li><strong>* 只有bits[31:14]有效，bits[13:0]应该是零（SBZ）。</strong></li> 
        <li><strong>* 所以第一级表必须16KB对齐。</strong></li> 
        <li><strong>*/</strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*</span><span style="color:#f00000;">&nbsp;初始化页表, 仅针对RAM（最大到256MB）开启</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 缓存（cacheable）和缓冲（bufferable）位</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r3 = 页目录基址(内核最终运行的物理地址向下16K的位置)</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>mov r0, r3 @ 页目录指针给r0</strong></li> 
        <li><strong>mov r9, r0, lsr #18</strong></li> 
        <li><strong>mov r9, r9, lsl #18 @ 通过移位清零低18bit，得到RAM基地址（推测值,r9）</strong></li> 
        <li><strong>add r10, r9, #0x10000000 @ 加一个合理的RAM大小（猜测值） = RAM结束地址（猜测值,r10）</strong></li> 
        <li><strong>mov r1, #0x12</strong></li> 
        <li><strong>orr r1, r1, #3 &lt;&lt; 10 @ 初始化节描述符r1 = 0b110000010010(完全访问:0域:XN:节)</strong></li> 
        <li><strong>add r2, r3, #16384 @ r2 = 内核最终运行的物理地址（可能）</strong></li> 
        <li><strong>1: cmp r1, r9 @ if virt &gt; start of RAM（针对RAM开启缓存和缓冲）</strong></li> 
        <li><strong>#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH</strong></li> 
        <li><strong>orrhs r1, r1, #0x08 @ 设置 cacheable</strong></li> 
        <li><strong>#else</strong></li> 
        <li><strong>orrhs r1, r1, #0x0c @ 设置 cacheable, bufferable</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>cmp r1, r10 @ if virt &gt; end of RAM</strong></li> 
        <li><strong>bichs r1, r1, #0x0c @ 清除 cacheable, bufferable</strong></li> 
        <li><strong>str r1, [r0], #4 @ 设置节描述符-1:1 映射（虚拟地址 == 物理地址）</strong></li> 
        <li><strong>add r1, r1, #1048576 @ r1 + 1MB（每节管理的地址长度）下一个节描述符</strong></li> 
        <li><strong>teq r0, r2</strong></li> 
        <li><strong>bne 1b</strong></li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 如果我们在flash中运行, 那么我们一定要为我们当前的代码开启缓存。</strong></li> 
        <li><strong>* 我们映射2MB的代码，</strong></li> 
        <li><strong>* 所以对于多达1MB压缩的内核没有映射重叠的问题？？</strong></li> 
        <li><strong>* 如果我们在RAM中运行, 那么我们只需要完成上面的工作即可，下面重复了.</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>mov r1, #0x1e</strong></li> 
        <li><strong>orr r1, r1, #3 &lt;&lt; 10 @ 初始化节描述符r1 = 0b110000011110(完全访问:0域:XN:cacheable:bufferable:节)</strong></li> 
        <li><strong>mov r2, pc</strong></li> 
        <li><strong>mov r2, r2, lsr #20 @ 当前执行地址的节基址</strong></li> 
        <li><strong>orr r1, r1, r2, lsl #20 @ 生成节描述符</strong></li> 
        <li><strong>add r0, r3, r2, lsl #2 @ 获得页目录中相应的入口</strong></li> 
        <li><strong>str r1, [r0], #4 @ 设置节描述符-1:1 映射（虚拟地址 == 物理地址）</strong></li> 
        <li><strong>add r1, r1, #1048576 @ r1 + 1MB（每节管理的地址长度）下一个节描述符</strong></li> 
        <li><strong>str r1, [r0] @ 设置节描述符（只做2MB映射）</strong></li> 
        <li><strong>mov pc, lr</strong></li> 
        <li><strong>ENDPROC(__setup_mmu)</strong></li> 
        <li> </li> 
        <li>__arm926ejs_mmu_cache_on:</li> 
        <li>#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH</li> 
        <li>mov r0, #4 @ put dcache in WT mode</li> 
        <li>mcr p15, 7, r0, c15, c0, 0</li> 
        <li>#endif</li> 
        <li> </li> 
        <li>__armv4_mmu_cache_on:</li> 
        <li>mov r12, lr</li> 
        <li>#ifdef CONFIG_MMU</li> 
        <li>bl __setup_mmu</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c10, 4 @ drain write buffer</li> 
        <li>mcr p15, 0, r0, c8, c7, 0 @ flush I,D TLBs</li> 
        <li>mrc p15, 0, r0, c1, c0, 0 @ read control reg</li> 
        <li>orr r0, r0, #0x5000 @ I-cache enable, RR cache replacement</li> 
        <li>orr r0, r0, #0x0030</li> 
        <li>#ifdef CONFIG_CPU_ENDIAN_BE8</li> 
        <li>orr r0, r0, #1 &lt;&lt; 25 @ big-endian page tables</li> 
        <li>#endif</li> 
        <li>bl __common_mmu_cache_on</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c8, c7, 0 @ flush I,D TLBs</li> 
        <li>#endif</li> 
        <li>mov pc, r12</li> 
        <li> </li> 
        <li><strong>__armv7_mmu_cache_on:</strong></li> 
        <li><strong>mov r12, lr @保存lr到r12</strong></li> 
        <li><strong>#ifdef CONFIG_MMU</strong></li> 
        <li><strong>mrc p15, 0, r11, c0, c1, 4 @ 读取CP15的ID_MMFR0（内存模块特性）寄存器</strong></li> 
        <li><strong>tst r11, #0xf @ 测试VMSA（虚拟内存系统构架）A8 = 0x3</strong></li> 
        <li><strong>blne __setup_mmu @ 如果VMSA不是0xf，就进入mmu页表初始化（节模式）</strong></li> 
        <li><strong>mov r0, #0</strong></li> 
        <li><strong>mcr p15, 0, r0, c7, c10, 4 @ 数据内存屏障（保证上面的写操作完成才继续）</strong></li> 
        <li><strong>tst r11, #0xf @ 测试VMSA（虚拟内存系统构架）A8 = 0x3</strong></li> 
        <li><strong>mcrne p15, 0, r0, c8, c7, 0 @ flush I,D TLBs缓存</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>mrc p15, 0, r0, c1, c0, 0 @ 读系统控制寄存器</strong></li> 
        <li><strong>orr r0, r0, #0x5000 @ I-cache 使能, RR cache replacement</strong></li> 
        <li><strong>orr r0, r0, #0x003c @ write buffer</strong></li> 
        <li><strong>#ifdef CONFIG_MMU</strong></li> 
        <li><strong>#ifdef CONFIG_CPU_ENDIAN_BE8</strong></li> 
        <li><strong>orr r0, r0, #1 &lt;&lt; 25 @ 大端模式页表</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>orrne r0, r0, #1 @ 设置MMU 开启位</strong></li> 
        <li><strong>movne r1, #-1</strong></li> 
        <li><strong>mcrne p15, 0, r3, c2, c0, 0 @ 载入页表基址到TTBR0</strong></li> 
        <li><strong>mcrne p15, 0, r1, c3, c0, 0 @ 载入域访问控制数据到DACR（所有域都是Manager，所以XN会被忽略）</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>mcr p15, 0, r0, c1, c0, 0 @ 写系统控制寄存器</strong></li> 
        <li><strong>mrc p15, 0, r0, c1, c0, 0 @ 回读系统控制寄存器</strong></li> 
        <li><strong>mov r0, #0</strong></li> 
        <li><strong>mcr p15, 0, r0, c7, c5, 4 @ 指令同步屏障（确保上面指令完成才返回）</strong></li> 
        <li><strong>mov pc, r12 @ 此处返回（此时MMU已启用，RAM缓存已开启）</strong></li> 
        <li> </li> 
        <li>__fa526_cache_on:</li> 
        <li>mov r12, lr</li> 
        <li>bl __setup_mmu</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c7, 0 @ Invalidate whole cache</li> 
        <li>mcr p15, 0, r0, c7, c10, 4 @ drain write buffer</li> 
        <li>mcr p15, 0, r0, c8, c7, 0 @ flush UTLB</li> 
        <li>mrc p15, 0, r0, c1, c0, 0 @ read control reg</li> 
        <li>orr r0, r0, #0x1000 @ I-cache enable</li> 
        <li>bl __common_mmu_cache_on</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c8, c7, 0 @ flush UTLB</li> 
        <li>mov pc, r12</li> 
        <li> </li> 
        <li>__arm6_mmu_cache_on:</li> 
        <li>mov r12, lr</li> 
        <li>bl __setup_mmu</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c0, 0 @ invalidate whole cache v3</li> 
        <li>mcr p15, 0, r0, c5, c0, 0 @ invalidate whole TLB v3</li> 
        <li>mov r0, #0x30</li> 
        <li>bl __common_mmu_cache_on</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c5, c0, 0 @ invalidate whole TLB v3</li> 
        <li>mov pc, r12</li> 
        <li> </li> 
        <li>__common_mmu_cache_on:</li> 
        <li>#ifndef CONFIG_THUMB2_KERNEL</li> 
        <li>#ifndef DEBUG</li> 
        <li>orr r0, r0, #0x000d @ Write buffer, mmu</li> 
        <li>#endif</li> 
        <li>mov r1, #-1</li> 
        <li>mcr p15, 0, r3, c2, c0, 0 @ load page table pointer</li> 
        <li>mcr p15, 0, r1, c3, c0, 0 @ load domain access control</li> 
        <li>b 1f</li> 
        <li>.align 5 @ cache line aligned</li> 
        <li>1: mcr p15, 0, r0, c1, c0, 0 @ load control register</li> 
        <li>mrc p15, 0, r0, c1, c0, 0 @ and read it back to</li> 
        <li>sub pc, lr, r0, lsr #32 @ properly flush pipeline</li> 
        <li>#endif</li> 
        <li> </li> 
        <li>#define PROC_ENTRY_SIZE (4*5)</li> 
        <li> </li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 这里是为不同的处理器提供遵循可重定向缓存支持的函数</strong></li> 
        <li><strong>* 这是一个通用的为 定位入口 和 跳入一个（从块起始处到）特定偏移的指令 的钩子函数。</strong></li> 
        <li><strong>* 请注意这是一个位置无关代码。</strong></li> 
        <li><strong>*</strong></li> 
        <li><strong>* r1 = 被修改</strong></li> 
        <li><strong>* r2 = 被修改</strong></li> 
        <li><strong>* r3 = 相对每个入口的功能函数位置偏移（on:#08|off:#12|flush:#16）</strong></li> 
        <li><strong>* r9 = 被修改</strong></li> 
        <li><strong>* r12 = 被修改</strong></li> 
        <li><strong>*/</strong></li> 
        <li> </li> 
        <li><strong>call_cache_fn: adr r12, proc_types</strong></li> 
        <li><strong>#ifdef CONFIG_CPU_CP15</strong></li> 
        <li><strong>mrc p15, 0, r9, c0, c0 @ 动态获取处理器ID</strong></li> 
        <li><strong>#else</strong></li> 
        <li><strong>ldr r9, =CONFIG_PROCESSOR_ID @ 使用预编译的处理器ID</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>1: ldr r1, [r12, #0] @ 获取ID值</strong></li> 
        <li><strong>ldr r2, [r12, #4] @ 获取对应的掩码</strong></li> 
        <li><strong>eor r1, r1, r9 @ (real ^ match) 检测是否匹配</strong></li> 
        <li><strong>tst r1, r2 @ &amp; mask 将检测结果做掩码</strong></li> 
        <li><strong>ARM( addeq pc, r12, r3 ) @ 如果匹配就调用缓存函数</strong></li> 
        <li><strong>THUMB( addeq r12, r3 )</strong></li> 
        <li><strong>THUMB( moveq pc, r12 ) @ call cache function</strong></li> 
        <li><strong>add r12, r12, #PROC_ENTRY_SIZE @ 如果不匹配就跳过这个入口，进入下个测试</strong></li> 
        <li><strong>b 1b</strong></li> 
        <li> </li> 
        <li>/*</li> 
        <li>* 缓存操作表. 这些是最基本的:</li> 
        <li>* - CPU ID 匹配</li> 
        <li>* - CPU ID 掩码</li> 
        <li>* - 'cache on' 方法代码</li> 
        <li>* - 'cache off' 方法代码</li> 
        <li>* - 'cache flush' 方法代码</li> 
        <li>*</li> 
        <li>* 我们通过这个公式匹配入口: ((real_id ^ match) &amp; mask) == 0</li> 
        <li>*</li> 
        <li>* 写通式缓存一般只需要 'on' 和 'off' 方法</li> 
        <li>* 回写式缓存必须有 flush 方法定义</li> 
        <li>*</li> 
        <li>*/</li> 
        <li>.align 2</li> 
        <li>.type proc_types,#object</li> 
        <li>proc_types:</li> 
        <li>.word 0x41560600 @ ARM6/610</li> 
        <li>.word 0xffffffe0</li> 
        <li>W(b) __arm6_mmu_cache_off @ 可以使用但是较慢</li> 
        <li>W(b) __arm6_mmu_cache_off</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>@ b __arm6_mmu_cache_on @ 未测试</li> 
        <li>@ b __arm6_mmu_cache_off</li> 
        <li>@ b __armv3_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x00000000 @ old ARM ID</li> 
        <li>.word 0x0000f000</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li> </li> 
        <li>.word 0x41007000 @ ARM7/710</li> 
        <li>.word 0xfff8fe00</li> 
        <li>W(b) __arm7_mmu_cache_off</li> 
        <li>W(b) __arm7_mmu_cache_off</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li> </li> 
        <li>.word 0x41807200 @ ARM720T (写通式)</li> 
        <li>.word 0xffffff00</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li> </li> 
        <li>.word 0x41007400 @ ARM74x</li> 
        <li>.word 0xff00ff00</li> 
        <li>W(b) __armv3_mpu_cache_on</li> 
        <li>W(b) __armv3_mpu_cache_off</li> 
        <li>W(b) __armv3_mpu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x41009400 @ ARM94x</li> 
        <li>.word 0xff00ff00</li> 
        <li>W(b) __armv4_mpu_cache_on</li> 
        <li>W(b) __armv4_mpu_cache_off</li> 
        <li>W(b) __armv4_mpu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x41069260 @ ARM926EJ-S (v5TEJ)</li> 
        <li>.word 0xff0ffff0</li> 
        <li>W(b) __arm926ejs_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv5tej_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x00007000 @ ARM7 IDs</li> 
        <li>.word 0x0000f000</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li> </li> 
        <li>@ 以下使用新的 ID 系统.</li> 
        <li> </li> 
        <li>.word 0x4401a100 @ sa110 / sa1100</li> 
        <li>.word 0xffffffe0</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv4_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x6901b110 @ sa1110</li> 
        <li>.word 0xfffffff0</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv4_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x56056900</li> 
        <li>.word 0xffffff00 @ PXA9xx</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv4_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x56158000 @ PXA168</li> 
        <li>.word 0xfffff000</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv5tej_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x56050000 @ Feroceon</li> 
        <li>.word 0xff0f0000</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv5tej_mmu_cache_flush</li> 
        <li> </li> 
        <li>#ifdef CONFIG_CPU_FEROCEON_OLD_ID</li> 
        <li>/* this conflicts with the standard ARMv5TE entry */</li> 
        <li>.long 0x41009260 @ Old Feroceon</li> 
        <li>.long 0xff00fff0</li> 
        <li>b __armv4_mmu_cache_on</li> 
        <li>b __armv4_mmu_cache_off</li> 
        <li>b __armv5tej_mmu_cache_flush</li> 
        <li>#endif</li> 
        <li> </li> 
        <li>.word 0x66015261 @ FA526</li> 
        <li>.word 0xff01fff1</li> 
        <li>W(b) __fa526_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __fa526_cache_flush</li> 
        <li> </li> 
        <li>@ 这些匹配构架ID</li> 
        <li> </li> 
        <li>.word 0x00020000 @ ARMv4T</li> 
        <li>.word 0x000f0000</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv4_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x00050000 @ ARMv5TE</li> 
        <li>.word 0x000f0000</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv4_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x00060000 @ ARMv5TEJ</li> 
        <li>.word 0x000f0000</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv5tej_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x0007b000 @ ARMv6</li> 
        <li>.word 0x000ff000</li> 
        <li>W(b) __armv4_mmu_cache_on</li> 
        <li>W(b) __armv4_mmu_cache_off</li> 
        <li>W(b) __armv6_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0x000f0000 @ new CPU Id</li> 
        <li>.word 0x000f0000</li> 
        <li>W(b) __armv7_mmu_cache_on</li> 
        <li>W(b) __armv7_mmu_cache_off</li> 
        <li>W(b) __armv7_mmu_cache_flush</li> 
        <li> </li> 
        <li>.word 0 @ 未识别类型</li> 
        <li>.word 0</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li>mov pc, lr</li> 
        <li>THUMB( nop )</li> 
        <li> </li> 
        <li>.size proc_types, . - proc_types</li> 
        <li> </li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 如果你获得了一个 "非常量的表达式".如果汇编器从这行返回" 申明"错误</strong></li> 
        <li><strong>* 请检查下你是否偶尔在应该使用“W(b)”的地方写了"b"指令</strong></li> 
        <li><strong>* 这是一个缓存方法跳转表的对齐检查机制</strong></li> 
        <li><strong>* 在写汇编的时候可以借鉴</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>.if (. - proc_types) % PROC_ENTRY_SIZE != 0</strong></li> 
        <li><strong>.error "The size of one or more proc_types entries is wrong."</strong></li> 
        <li><strong>.endif</strong></li> 
        <li> </li> 
        <li><strong><span style="color:#0000f0;">/*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 关闭缓存和MMU. ARMv3不支持控制寄存器的读取，</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 但ARMv4支持.</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 在退出时,</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r0, r1, r2, r3, r9, r12 被篡改</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* 这个例程必须保护:</span></strong></li> 
        <li><strong><span style="color:#0000f0;">* r4, r7, r8</span></strong></li> 
        <li><strong><span style="color:#0000f0;">*/</span></strong></li> 
        <li><strong>.align 5</strong></li> 
        <li><strong>cache_off: mov r3, #12 @ 缓存关闭函数</strong></li> 
        <li><strong>b call_cache_fn</strong></li> 
        <li> </li> 
        <li>__armv4_mpu_cache_off:</li> 
        <li>mrc p15, 0, r0, c1, c0</li> 
        <li>bic r0, r0, #0x000d</li> 
        <li>mcr p15, 0, r0, c1, c0 @ turn MPU and cache off</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c10, 4 @ drain write buffer</li> 
        <li>mcr p15, 0, r0, c7, c6, 0 @ flush D-Cache</li> 
        <li>mcr p15, 0, r0, c7, c5, 0 @ flush I-Cache</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv3_mpu_cache_off:</li> 
        <li>mrc p15, 0, r0, c1, c0</li> 
        <li>bic r0, r0, #0x000d</li> 
        <li>mcr p15, 0, r0, c1, c0, 0 @ turn MPU and cache off</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c0, 0 @ invalidate whole cache v3</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv4_mmu_cache_off:</li> 
        <li>#ifdef CONFIG_MMU</li> 
        <li>mrc p15, 0, r0, c1, c0</li> 
        <li>bic r0, r0, #0x000d</li> 
        <li>mcr p15, 0, r0, c1, c0 @ turn MMU and cache off</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c7 @ invalidate whole cache v4</li> 
        <li>mcr p15, 0, r0, c8, c7 @ invalidate whole TLB v4</li> 
        <li>#endif</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>_<strong>_armv7_mmu_cache_off:</strong> </li> 
        <li><strong>mrc p15, 0, r0, c1, c0 @ 读取系统控制寄存器SCTLR</strong></li> 
        <li><strong>#ifdef CONFIG_MMU</strong></li> 
        <li><strong>bic r0, r0, #0x000d @ 清零MMU和cache使能位</strong></li> 
        <li><strong>#else</strong></li> 
        <li><strong>bic r0, r0, #0x000c @ 清零cache使能位</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>mcr p15, 0, r0, c1, c0 @ 关闭MMU和cache</strong></li> 
        <li><strong>mov r12, lr @ 保存lr到r12</strong></li> 
        <li><strong>bl __armv7_mmu_cache_flush</strong></li> 
        <li><strong>mov r0, #0</strong></li> 
        <li><strong>#ifdef CONFIG_MMU</strong></li> 
        <li><strong>mcr p15, 0, r0, c8, c7, 0 @ 废止整个TLB</strong></li> 
        <li><strong>#endif</strong></li> 
        <li><strong>mcr p15, 0, r0, c7, c5, 6 @ 废止BTC</strong></li> 
        <li><strong>mcr p15, 0, r0, c7, c10, 4 @ 数据同步屏障</strong></li> 
        <li><strong>mcr p15, 0, r0, c7, c5, 4 @ 指令同步屏障（确保上面指令完成才返回）</strong></li> 
        <li><strong>mov pc, r12</strong></li> 
        <li> </li> 
        <li>__arm6_mmu_cache_off:</li> 
        <li>mov r0, #0x00000030 @ ARM6 control reg.</li> 
        <li>b __armv3_mmu_cache_off</li> 
        <li> </li> 
        <li>__arm7_mmu_cache_off:</li> 
        <li>mov r0, #0x00000070 @ ARM7 control reg.</li> 
        <li>b __armv3_mmu_cache_off</li> 
        <li> </li> 
        <li>__armv3_mmu_cache_off:</li> 
        <li>mcr p15, 0, r0, c1, c0, 0 @ turn MMU and cache off</li> 
        <li>mov r0, #0</li> 
        <li>mcr p15, 0, r0, c7, c0, 0 @ invalidate whole cache v3</li> 
        <li>mcr p15, 0, r0, c5, c0, 0 @ invalidate whole TLB v3</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li><strong>/*</strong></li> 
        <li><strong>* 清空和flush缓存以保持一致性</strong></li> 
        <li><strong>*</strong></li> 
        <li><strong>* 退出时,</strong></li> 
        <li><strong>* r1, r2, r3, r9, r10, r11, r12 被篡改</strong></li> 
        <li><strong>* 这个例程必须保护:</strong></li> 
        <li><strong>* r4, r6, r7, r8</strong></li> 
        <li><strong>*/</strong></li> 
        <li><strong>.align 5</strong></li> 
        <li><strong>cache_clean_flush:</strong></li> 
        <li><strong>mov r3, #16</strong></li> 
        <li><strong>b call_cache_fn</strong></li> 
        <li> </li> 
        <li>__armv4_mpu_cache_flush:</li> 
        <li>mov r2, #1</li> 
        <li>mov r3, #0</li> 
        <li>mcr p15, 0, ip, c7, c6, 0 @ invalidate D cache</li> 
        <li>mov r1, #7 &lt;&lt; 5 @ 8 segments</li> 
        <li>1: orr r3, r1, #63 &lt;&lt; 26 @ 64 entries</li> 
        <li>2: mcr p15, 0, r3, c7, c14, 2 @ clean &amp; invalidate D index</li> 
        <li>subs r3, r3, #1 &lt;&lt; 26</li> 
        <li>bcs 2b @ entries 63 to 0</li> 
        <li>subs r1, r1, #1 &lt;&lt; 5</li> 
        <li>bcs 1b @ segments 7 to 0</li> 
        <li> </li> 
        <li>teq r2, #0</li> 
        <li>mcrne p15, 0, ip, c7, c5, 0 @ invalidate I cache</li> 
        <li>mcr p15, 0, ip, c7, c10, 4 @ drain WB</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__fa526_cache_flush:</li> 
        <li>mov r1, #0</li> 
        <li>mcr p15, 0, r1, c7, c14, 0 @ clean and invalidate D cache</li> 
        <li>mcr p15, 0, r1, c7, c5, 0 @ flush I cache</li> 
        <li>mcr p15, 0, r1, c7, c10, 4 @ drain WB</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv6_mmu_cache_flush:</li> 
        <li>mov r1, #0</li> 
        <li>mcr p15, 0, r1, c7, c14, 0 @ clean+invalidate D</li> 
        <li>mcr p15, 0, r1, c7, c5, 0 @ invalidate I+BTB</li> 
        <li>mcr p15, 0, r1, c7, c15, 0 @ clean+invalidate unified</li> 
        <li>mcr p15, 0, r1, c7, c10, 4 @ drain WB</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv7_mmu_cache_flush:</li> 
        <li>mrc p15, 0, r10, c0, c1, 5 @ read ID_MMFR1</li> 
        <li>tst r10, #0xf &lt;&lt; 16 @ hierarchical cache (ARMv7)</li> 
        <li>mov r10, #0</li> 
        <li>beq hierarchical</li> 
        <li>mcr p15, 0, r10, c7, c14, 0 @ clean+invalidate D</li> 
        <li>b iflush</li> 
        <li>hierarchical:</li> 
        <li>mcr p15, 0, r10, c7, c10, 5 @ DMB</li> 
        <li>stmfd sp!, {r0-r7, r9-r11}</li> 
        <li>mrc p15, 1, r0, c0, c0, 1 @ read clidr</li> 
        <li>ands r3, r0, #0x7000000 @ extract loc from clidr</li> 
        <li>mov r3, r3, lsr #23 @ left align loc bit field</li> 
        <li>beq finished @ if loc is 0, then no need to clean</li> 
        <li>mov r10, #0 @ start clean at cache level 0</li> 
        <li>loop1:</li> 
        <li>add r2, r10, r10, lsr #1 @ work out 3x current cache level</li> 
        <li>mov r1, r0, lsr r2 @ extract cache type bits from clidr</li> 
        <li>and r1, r1, #7 @ mask of the bits for current cache only</li> 
        <li>cmp r1, #2 @ see what cache we have at this level</li> 
        <li>blt skip @ skip if no cache, or just i-cache</li> 
        <li>mcr p15, 2, r10, c0, c0, 0 @ select current cache level in cssr</li> 
        <li>mcr p15, 0, r10, c7, c5, 4 @ isb to sych the new cssr&amp;csidr</li> 
        <li>mrc p15, 1, r1, c0, c0, 0 @ read the new csidr</li> 
        <li>and r2, r1, #7 @ extract the length of the cache lines</li> 
        <li>add r2, r2, #4 @ add 4 (line length offset)</li> 
        <li>ldr r4, =0x3ff</li> 
        <li>ands r4, r4, r1, lsr #3 @ find maximum number on the way size</li> 
        <li>clz r5, r4 @ find bit position of way size increment</li> 
        <li>ldr r7, =0x7fff</li> 
        <li>ands r7, r7, r1, lsr #13 @ extract max number of the index size</li> 
        <li>loop2:</li> 
        <li>mov r9, r4 @ create working copy of max way size</li> 
        <li>loop3:</li> 
        <li>ARM( orr r11, r10, r9, lsl r5 ) @ factor way and cache number into r11</li> 
        <li>ARM( orr r11, r11, r7, lsl r2 ) @ factor index number into r11</li> 
        <li>THUMB( lsl r6, r9, r5 )</li> 
        <li>THUMB( orr r11, r10, r6 ) @ factor way and cache number into r11</li> 
        <li>THUMB( lsl r6, r7, r2 )</li> 
        <li>THUMB( orr r11, r11, r6 ) @ factor index number into r11</li> 
        <li>mcr p15, 0, r11, c7, c14, 2 @ clean &amp; invalidate by set/way</li> 
        <li>subs r9, r9, #1 @ decrement the way</li> 
        <li>bge loop3</li> 
        <li>subs r7, r7, #1 @ decrement the index</li> 
        <li>bge loop2</li> 
        <li>skip:</li> 
        <li>add r10, r10, #2 @ increment cache number</li> 
        <li>cmp r3, r10</li> 
        <li>bgt loop1</li> 
        <li>finished:</li> 
        <li>ldmfd sp!, {r0-r7, r9-r11}</li> 
        <li>mov r10, #0 @ swith back to cache level 0</li> 
        <li>mcr p15, 2, r10, c0, c0, 0 @ select current cache level in cssr</li> 
        <li>iflush:</li> 
        <li>mcr p15, 0, r10, c7, c10, 4 @ DSB</li> 
        <li>mcr p15, 0, r10, c7, c5, 0 @ invalidate I+BTB</li> 
        <li>mcr p15, 0, r10, c7, c10, 4 @ DSB</li> 
        <li>mcr p15, 0, r10, c7, c5, 4 @ ISB</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv5tej_mmu_cache_flush:</li> 
        <li>1: mrc p15, 0, r15, c7, c14, 3 @ test,clean,invalidate D cache</li> 
        <li>bne 1b</li> 
        <li>mcr p15, 0, r0, c7, c5, 0 @ flush I cache</li> 
        <li>mcr p15, 0, r0, c7, c10, 4 @ drain WB</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv4_mmu_cache_flush:</li> 
        <li>mov r2, #64*1024 @ default: 32K dcache size (*2)</li> 
        <li>mov r11, #32 @ default: 32 byte line size</li> 
        <li>mrc p15, 0, r3, c0, c0, 1 @ read cache type</li> 
        <li>teq r3, r9 @ cache ID register present?</li> 
        <li>beq no_cache_id</li> 
        <li>mov r1, r3, lsr #18</li> 
        <li>and r1, r1, #7</li> 
        <li>mov r2, #1024</li> 
        <li>mov r2, r2, lsl r1 @ base dcache size *2</li> 
        <li>tst r3, #1 &lt;&lt; 14 @ test M bit</li> 
        <li>addne r2, r2, r2, lsr #1 @ +1/2 size if M == 1</li> 
        <li>mov r3, r3, lsr #12</li> 
        <li>and r3, r3, #3</li> 
        <li>mov r11, #8</li> 
        <li>mov r11, r11, lsl r3 @ cache line size in bytes</li> 
        <li>no_cache_id:</li> 
        <li>mov r1, pc</li> 
        <li>bic r1, r1, #63 @ align to longest cache line</li> 
        <li>add r2, r1, r2</li> 
        <li>1:</li> 
        <li>ARM( ldr r3, [r1], r11 ) @ s/w flush D cache</li> 
        <li>THUMB( ldr r3, [r1] ) @ s/w flush D cache</li> 
        <li>THUMB( add r1, r1, r11 )</li> 
        <li>teq r1, r2</li> 
        <li>bne 1b</li> 
        <li> </li> 
        <li>mcr p15, 0, r1, c7, c5, 0 @ flush I cache</li> 
        <li>mcr p15, 0, r1, c7, c6, 0 @ flush D cache</li> 
        <li>mcr p15, 0, r1, c7, c10, 4 @ drain WB</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>__armv3_mmu_cache_flush:</li> 
        <li>__armv3_mpu_cache_flush:</li> 
        <li>mov r1, #0</li> 
        <li>mcr p15, 0, r1, c7, c0, 0 @ invalidate whole cache v3</li> 
        <li>mov pc, lr</li> 
        <li> </li> 
        <li>/*</li> 
        <li>* Various debugging routines for printing hex characters and</li> 
        <li>* memory, which again must be relocatable.</li> 
        <li>*/</li> 
        <li>#ifdef DEBUG</li> 
        <li>.align 2</li> 
        <li>.type phexbuf,#object</li> 
        <li>phexbuf: .space 12</li> 
        <li>.size phexbuf, . - phexbuf</li> 
        <li> </li> 
        <li>@ phex corrupts {r0, r1, r2, r3}</li> 
        <li>phex: adr r3, phexbuf</li> 
        <li>mov r2, #0</li> 
        <li>strb r2, [r3, r1]</li> 
        <li>1: subs r1, r1, #1</li> 
        <li>movmi r0, r3</li> 
        <li>bmi puts</li> 
        <li>and r2, r0, #15</li> 
        <li>mov r0, r0, lsr #4</li> 
        <li>cmp r2, #10</li> 
        <li>addge r2, r2, #7</li> 
        <li>add r2, r2, #'0'</li> 
        <li>strb r2, [r3, r1]</li> 
        <li>b 1b</li> 
        <li> </li> 
        <li>@ puts corrupts {r0, r1, r2, r3}</li> 
        <li>puts: loadsp r3, r1</li> 
        <li>1: ldrb r2, [r0], #1</li> 
        <li>teq r2, #0</li> 
        <li>moveq pc, lr</li> 
        <li>2: writeb r2, r3</li> 
        <li>mov r1, #0x00020000</li> 
        <li>3: subs r1, r1, #1</li> 
        <li>bne 3b</li> 
        <li>teq r2, #'\n'</li> 
        <li>moveq r2, #'\r'</li> 
        <li>beq 2b</li> 
        <li>teq r0, #0</li> 
        <li>bne 1b</li> 
        <li>mov pc, lr</li> 
        <li>@ putc corrupts {r0, r1, r2, r3}</li> 
        <li>putc:</li> 
        <li>mov r2, r0</li> 
        <li>mov r0, #0</li> 
        <li>loadsp r3, r1</li> 
        <li>b 2b</li> 
        <li> </li> 
        <li>@ memdump corrupts {r0, r1, r2, r3, r10, r11, r12, lr}</li> 
        <li>memdump: mov r12, r0</li> 
        <li>mov r10, lr</li> 
        <li>mov r11, #0</li> 
        <li>2: mov r0, r11, lsl #2</li> 
        <li>add r0, r0, r12</li> 
        <li>mov r1, #8</li> 
        <li>bl phex</li> 
        <li>mov r0, #':'</li> 
        <li>bl putc</li> 
        <li>1: mov r0, #' '</li> 
        <li>bl putc</li> 
        <li>ldr r0, [r12, r11, lsl #2]</li> 
        <li>mov r1, #8</li> 
        <li>bl phex</li> 
        <li>and r0, r11, #7</li> 
        <li>teq r0, #3</li> 
        <li>moveq r0, #' '</li> 
        <li>bleq putc</li> 
        <li>and r0, r11, #7</li> 
        <li>add r11, r11, #1</li> 
        <li>teq r0, #7</li> 
        <li>bne 1b</li> 
        <li>mov r0, #'\n'</li> 
        <li>bl putc</li> 
        <li>cmp r11, #64</li> 
        <li>blt 2b</li> 
        <li>mov pc, r10</li> 
        <li>#endif</li> 
        <li> </li> 
        <li>.ltorg</li> 
        <li>reloc_code_end:</li> 
        <li> </li> 
        <li>.align</li> 
        <li>.section ".stack", "aw", %nobits</li> 
        <li>.L_user_stack: .space 4096</li> 
        <li>.L_user_stack_end:</li> 
       </ol>
      </div> 
     </div> 
     <div>
      &nbsp;
     </div> 
     <div>
      <span style="font-size:medium;"><strong>&nbsp; &nbsp; &nbsp;看了上面的源码，可能就算是分析过了也是比较模糊的，通过下面的一个代码流程图，大家就可以清楚的了解内核自解压的全过程了：</strong></span>
     </div> 
     <div>
      &nbsp;
     </div> 
     <div>
      <a href="https://yqfile.alicdn.com/img_ffcab7fbd0cbe6c6df68dc1d39a2fb7a.jpeg" rel="nofollow"><img src="https://yqfile.alicdn.com/img_ffcab7fbd0cbe6c6df68dc1d39a2fb7a.jpeg" alt=""></a>
     </div> 
     <div>
      &nbsp;
     </div> 
     <div>
      &nbsp;
     </div> 
     <div>
      &nbsp;
     </div> 
    </div> 
   </div> 
   <div class="Blog_con2_1 Blog_con3_2">
    &nbsp;
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
