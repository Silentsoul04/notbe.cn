<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux内核源码分析--内核启动之(3)Image内核启动(C语言部分)（Linux-3.0 ARMv7） 【转】... « NotBeCN</title>
  <meta name="description" content="                  原文地址：Linux内核源码分析--内核启动之(3)Image内核启动(C语言部分)（Linux-3.0 ARMv7）&nbsp;作者：tekkamanninja     &nbsp;转自：http://blog.chinaunix.net/uid-25909619-id-49...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2015/09/29/weixin_34356310_90124151.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux内核源码分析--内核启动之(3)Image内核启动(C语言部分)（Linux-3.0 ARMv7） 【转】...</h1>
    <p class="post-meta">Sep 29, 2015</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="Blog_con3"> 
    <p>原文地址：<a href="http://blog.chinaunix.net/uid-20543672-id-3157283.html" rel="nofollow">Linux内核源码分析--内核启动之(3)Image内核启动(C语言部分)（Linux-3.0 ARMv7）</a>&nbsp;作者：<a href="http://blog.chinaunix.net/uid/20543672.html" rel="nofollow">tekkamanninja</a></p> 
    <p>&nbsp;转自：<a href="http://blog.chinaunix.net/uid-25909619-id-4938390.html" rel="nofollow">http://blog.chinaunix.net/uid-25909619-id-4938390.html</a></p> 
   </div> 
   <div class="Blog_wz1">
    &nbsp; 在构架相关的汇编代码运行完之后，程序跳入了构架无关的内核C语言代码：init/main.c中的start_kernel函数，在这个函数中Linux内核开始真正进入初始化阶段， 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp; &nbsp;下面我就顺这代码逐个函数的解释，但是这里并不会过于深入每个函数，因为这样就会只见树木，不见森林。分析代码首先要从构架上宏观地理解，然后再去考虑细节问题（这和小时候学语文要概括中心思想和段落大意是一个道理）。今后对于每个子系统的初始化，特别是内存子系统，有空都会分析一遍。
     <br>
     <div> 
      <br>
      <div class="codeText"> 
       <ol>
        <li>asmlinkage void __init start_kernel(void)</li> 
        <li>{</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*&nbsp;command_line;</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;<strong><span style="color:#f00000;">extern const struct kernel_param __start___param[], __stop___param[];</span></strong> </li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText"> 
           <ol>
            <li>这里关键是这两个变量的地址是如何确定的。</li> 
            <li>这两个变量为地址指针，<strong><span style="color:#0000f0;">指向内核启动参数处理相关结构体段在内存中的位置</span></strong>（虚拟地址）。</li> 
            <li>这里是外部变量，定义的位置在arch/../../vmlinux.lds.S，而大多数平台是放到kernel\include\asm-generic\vmlinux.lds.h中，定义如下：</li> 
            <li> <br>
             <div> 
              <div class="codeheads"> 
               <p>点击(此处)折叠或打开</p> 
              </div> 
              <div class="codeText">
               <ol>
                <li> </li> 
                <li>362 &nbsp; &nbsp; /*&nbsp;<strong><span style="color:#f00000;">内建模块的参数处理段</span></strong>. */ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</li> 
                <li>363 &nbsp; &nbsp; __param : AT(ADDR(__param) - LOAD_OFFSET) { &nbsp; &nbsp; &nbsp; &nbsp; \ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</li> 
                <li>364 &nbsp; &nbsp; &nbsp; &nbsp; VMLINUX_SYMBOL(__start___param) = .; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li> 
                <li>365 &nbsp; &nbsp; &nbsp; &nbsp; *(__param) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</li> 
                <li>366 &nbsp; &nbsp; &nbsp; &nbsp; VMLINUX_SYMBOL(__stop___param) = .; &nbsp; &nbsp; &nbsp; &nbsp; \ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li> 
                <li>367 &nbsp; &nbsp; }&nbsp;</li> 
               </ol>
              </div> 
             </div> </li> 
            <li>对于ARM平台，似乎位于 kernel\include\asm-generic\vmlinux.lds.h</li> 
            <li> </li> 
            <li>这个段中数据的数据结构：</li> 
            <li>kernel_param结构体的定义是：</li> 
           </ol>
           <div> 
            <div> 
             <div class="codeheads"> 
              <p>点击(此处)折叠或打开</p> 
             </div> 
             <div class="codeText">
              <ol>
               <li>36 struct kernel_param_ops&nbsp;{</li> 
               <li>&nbsp;37 &nbsp; &nbsp; &nbsp;/*&nbsp;Returns 0,&nbsp;or&nbsp;-errno.&nbsp;arg&nbsp;is&nbsp;in&nbsp;kp-&gt;arg.&nbsp;*/</li> 
               <li>&nbsp;38 &nbsp; &nbsp; &nbsp;int&nbsp;(*set)(const&nbsp;char&nbsp;*val,&nbsp;const&nbsp;struct kernel_param&nbsp;*kp);</li> 
               <li>&nbsp;39 &nbsp; &nbsp; &nbsp;/*&nbsp;Returns length written&nbsp;or&nbsp;-errno.&nbsp;Buffer&nbsp;is&nbsp;4k&nbsp;(ie.&nbsp;be&nbsp;*/</li> 
               <li>&nbsp;40 &nbsp; &nbsp; &nbsp;int&nbsp;(*get)(char&nbsp;*buffer,&nbsp;const&nbsp;struct kernel_param&nbsp;*kp);</li> 
               <li>&nbsp;41 &nbsp; &nbsp; &nbsp;/*&nbsp;Optional&nbsp;function&nbsp;to&nbsp;free kp-&gt;arg when module unloaded.&nbsp;*/</li> 
               <li>&nbsp;42 &nbsp; &nbsp; &nbsp;void&nbsp;(*free)(void&nbsp;*arg);</li> 
               <li>&nbsp;43 &nbsp;};</li> 
               <li>&nbsp;44 &nbsp;</li> 
               <li>&nbsp;45 &nbsp;/*&nbsp;Flag bits&nbsp;for&nbsp;kernel_param.flags&nbsp;*/</li> 
               <li>&nbsp;46 &nbsp;#define KPARAM_ISBOOL 2</li> 
               <li>&nbsp;47 &nbsp;</li> 
               <li>&nbsp;48 struct kernel_param&nbsp;{</li> 
               <li>&nbsp;49 &nbsp; &nbsp; &nbsp;const&nbsp;char&nbsp;*name;</li> 
               <li>&nbsp;50 &nbsp; &nbsp; &nbsp;const&nbsp;struct kernel_param_ops&nbsp;*ops;</li> 
               <li>&nbsp;51 &nbsp; &nbsp; &nbsp; u16 perm;</li> 
               <li>&nbsp;52 &nbsp; &nbsp; &nbsp;u16 flags;</li> 
               <li>&nbsp;53 &nbsp; &nbsp; &nbsp;union&nbsp;{</li> 
               <li>&nbsp;54 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;void&nbsp;*arg;</li> 
               <li>&nbsp;55 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const&nbsp;struct kparam_string&nbsp;*str;</li> 
               <li>&nbsp;56 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const&nbsp;struct kparam_array&nbsp;*arr;</li> 
               <li>&nbsp;57 &nbsp; &nbsp; &nbsp;};</li> 
               <li>&nbsp;58&nbsp;};</li> 
               <li>&nbsp;59 &nbsp;</li> 
               <li>&nbsp;60 &nbsp;/*&nbsp;Special one&nbsp;for&nbsp;strings we want&nbsp;to&nbsp;copy into&nbsp;*/</li> 
               <li>&nbsp;61 &nbsp;struct kparam_string&nbsp;{</li> 
               <li>&nbsp;62 &nbsp; &nbsp; &nbsp;unsigned&nbsp;int&nbsp;maxlen;</li> 
               <li>&nbsp;63 &nbsp; &nbsp; &nbsp;char&nbsp;*string;</li> 
               <li>&nbsp;64 &nbsp;};</li> 
               <li>&nbsp;65&nbsp;</li> 
               <li>&nbsp;66 &nbsp;/*&nbsp;Special one&nbsp;for&nbsp;arrays&nbsp;*/</li> 
               <li>&nbsp;67 &nbsp;struct kparam_array</li> 
               <li>&nbsp;68 &nbsp;{</li> 
               <li>&nbsp;69 &nbsp; &nbsp; &nbsp;unsigned&nbsp;int&nbsp;max;</li> 
               <li>&nbsp;70 &nbsp; &nbsp; &nbsp;unsigned&nbsp;int&nbsp;elemsize;</li> 
               <li>&nbsp;71 &nbsp; &nbsp; &nbsp;unsigned&nbsp;int&nbsp;*num;</li> 
               <li>&nbsp;72 &nbsp; &nbsp; &nbsp;const&nbsp;struct kernel_param_ops&nbsp;*ops;</li> 
               <li>&nbsp;73 &nbsp; &nbsp; &nbsp;void&nbsp;*elem;</li> 
               <li>&nbsp;74 &nbsp;};</li> 
              </ol>
             </div> 
            </div> 
           </div> 
           <div>
            &nbsp;
           </div> 
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;smp_setup_processor_id();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>这个函数是针对SMP处理器的，经查阅资料，其作用是获取当前CPU的的硬件ID。</li> 
            <li>如果不是多处理器构架，在其他文件中就不会定义这个函数，此时使用本文件定义的弱引用函数：</li> 
            <li><strong>void __init __weak smp_setup_processor_id(void)</strong></li> 
            <li><strong>{</strong></li> 
            <li><strong>}</strong></li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*</li> 
        <li><strong><span style="color:#0000f0;">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;<span style="color:#0000f0;">必须尽早运行这个程序, 作用是初始化</span></span></strong></li> 
        <li><strong><span style="color:#0000f0;">&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;<span style="color:#0000f0;">lockdep 模块的hash表:</span></span></strong></li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;lockdep_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText"> 
           <ol>
            <li>lockdep是一个内核调试模块，用来检查内核互斥机制（尤其是自旋锁）潜在的死锁问题。</li> 
            <li> </li> 
            <li>由于自旋锁以查询方式等待，不释放处理器，比一般互斥机制更容易死锁，故引入lockdep检查以下几种可能的死锁情况：</li> 
           </ol>
           <ul>
            <li>同一个进程递归地加锁同一把锁；</li> 
            <li>一把锁既在中断（或中断下半部）使能的情况下执行过加锁操作， 又在中断（或中断下半部）里执行过加锁操作。这样该锁有可能在锁定时由于中断发生又试图在同一处理器上加锁；</li> 
            <li>加锁后导致依赖图产生成闭环，这是典型的死锁现象。</li> 
           </ul>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;debug_objects_early_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>在启动早期初始化hash buckets 和链接静态的 pool objects对象到 poll 列表. 在这个调用完成后 object tracker 已经开始完全运作了.</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp; &nbsp;&nbsp;/*</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;初始化栈canary值:</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;boot_init_stack_canary();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>canary值的是用于<span style="color:#f00000;"><strong>防止栈溢出攻击的堆栈的保护字</strong></span>&nbsp;。</li> 
            <li> </li> 
            <li>参考资料：&nbsp;<a href="http://https//www.ibm.com/developerworks/cn/linux/l-cn-gccstack/" rel="nofollow">GCC 中的编译器堆栈保护技术</a> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;cgroup_init_early();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>cgroup: 它的全称为control group.即一组进程的行为控制.</li> 
            <li>该函数主要是做数据结构和其中链表的初始化</li> 
            <li>参考资料：&nbsp;<a href="http://blog.chinaunix.net/space.php?uid=20543183&amp;do=blog&amp;id=1930840" rel="nofollow">Linux cgroup机制分析之框架分析</a> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;local_irq_disable();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>关闭系统总中断（底层调用汇编指令）</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;early_boot_irqs_disabled&nbsp;=&nbsp;true;</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>设置系统中断的关闭标志（bool全局变量）</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>/*</li> 
        <li>&nbsp;*&nbsp;中断依然被禁用。做必要的设置后，</li> 
        <li>&nbsp;*&nbsp;再使能它</li> 
        <li>&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;tick_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化内核时钟系统</li> 
            <li>--&gt;clockevents_register_notifier(&amp;tick_notifier)</li> 
            <li>往内核通知链中注册内核时钟时间的通知函数</li> 
            <li> </li> 
            <li>参考资料：《<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-clocks/index.html" rel="nofollow">Linux 时钟处理机制</a>》&nbsp; 《<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-timerm/index.html?ca=drs-" rel="nofollow">Linux 时钟管理</a>》</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp; &nbsp; boot_cpu_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>激活当前CPU（在内核全局变量中将当前CPU的状态设为激活状态）</li> 
            <li>参考资料：《<a href="http://blog.csdn.net/yunsongice/article/details/6130032" rel="nofollow">激活第一个CPU</a>》</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp; &nbsp; page_address_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>高端内存相关，未定义高端内存的话为空函数</li> 
           </ol>
          </div> 
         </div> </li> 
        <li><strong><span style="color:#f00000;">&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_NOTICE "%s", linux_banner);</span></strong></li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>打印内核版本信息，也就是平时我们在内核启动时在串口中看到的：</li> 
            <li> <br>
             <div class="codeText">
              <ol>
               <li>Linux version 2.6.37+ (tekkaman@tekkaman-desktop) (gcc version 4.3.3 (Sourcery G++ Lite 2009q1-203) ) #40 Tue Mar 20 17:49:58 CST 2012</li> 
              </ol>
             </div> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li><span style="color:#f00000;font-size:large;"><strong><span style="text-decoration:underline;"><em>&nbsp;&nbsp;&nbsp;&nbsp;setup_arch(&amp;command_line);</em></span></strong></span></li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li> <strong><span style="color:#0000f0;">内核构架相关初始化函数,可以说是非常重要的一个初始化步骤</span></strong><span style="color:#0000cc;">。其中包含了处理器相关参数的初始化、</span><span style="color:#f00000;">内核启动参数（tagged list）的获取和前期处理</span><span style="color:#0000cc;">、</span><span style="color:#f00000;"><strong>内存子系统的早期的初始化（bootmem分配器）</strong></span><span style="color:#0000cc;">。</span> </li> 
            <li><span style="color:#0000cc;">对于ARM构架来说，这个函数位于：<span style="text-decoration:underline;">arch/arm/kernel/setup.c</span></span></li> 
            <li>以后会详细分析这个函数。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;mm_init_owner(&amp;init_mm,&nbsp;&amp;init_task);</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;mm_init_cpumask(&amp;init_mm);</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li><strong><span style="color:#f00000;">初始化代表内核本身内存使用的管理结构体init_mm。</span></strong></li> 
            <li><span style="font-size:small;">ps：每一个任务都有一个mm_struct结构以管理内存空间，init_mm是内核的mm_struct，其中：</span></li> 
            <li><span style="font-size:small;">设置成员变量* mmap指向自己，意味着内核只有一个内存管理结构;</span></li> 
            <li><span style="font-size:small;">设置* pgd=swapper_pg_dir，swapper_pg_dir是内核的页目录(在arm体系结构有16k，&nbsp;所以init_mm定义了整个kernel的内存空间)。</span></li> 
            <li><span style="color:#000000;font-family:'AR PL UKai CN';font-size:small;">这些内容涉及到内存管理子系统，以后再仔细分析。</span></li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;setup_command_line(command_line);</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li> <strong>对cmdline进行备份和保存</strong>：</li> 
            <li> </li> 
            <li>&nbsp;/* 为处理的command line备份 (例如eg. 用于 /proc) */</li> 
            <li>&nbsp;char *saved_command_line; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</li> 
            <li>/* 用于参数处理的command line&nbsp;*/</li> 
            <li>static char *static_command_line;</li> 
            <li> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;setup_nr_cpu_ids();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;setup_per_cpu_areas();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;smp_prepare_boot_cpu();&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;arch-specific boot-cpu hooks&nbsp;*/</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>针对SMP处理器的内存初始化函数，如果不是SMP系统则都为空函数。</li> 
            <li>他们的目的是给每个CPU分配内存，并拷贝.data.percpu段的数据。为系统中的每个CPU的per_cpu变量申请空间并为boot CPU设置一些数据。</li> 
            <li>在SMP系统中，在引导过程中使用的CPU称为boot CPU</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;build_all_zonelists(NULL);</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;page_alloc_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>设置内存管理相关的node（节点，每个CPU一个内存节点）和其中的zone（内存域，包含于节点中，如）数据结构,以完成内存管理子系统的初始化，并设置bootmem分配器。</li> 
            <li>page_alloc_init函数暂时不知其目的</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_NOTICE&nbsp;"Kernel command line: %s\n",&nbsp;boot_command_line);</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;parse_early_param();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;parse_args("Booting kernel",&nbsp;static_command_line,&nbsp;__start___param,</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __stop___param&nbsp;-&nbsp;__start___param,</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;unknown_bootoption);</li> 
       </ol>
       <div> 
        <br>
        <div> 
         <div class="codeheads"> 
          <p>点击(此处)折叠或打开</p> 
         </div> 
         <div class="codeText">
          <ol>
           <li>打印从内核启动参数中获取的cmdline字符串。</li> 
           <li>解析cmdline中的启动参数。</li> 
          </ol>
         </div> 
        </div> 
       </div> 
       <ol>
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;使用大量bootmem分配，且必须先于</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;kmem_cache_init()</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>以上注释的含义在于bootmem是内核启动时使用的临时内存分配器。之后由slab接替。</li> 
            <li>kmem_cache_init()初始化了内核高速缓存分配器（slab分配器），这个函数标标志着bootmem的终结，同时内核的内存管理系统正式启用了。</li> 
            <li>所以在kmem_cache_init()之后，bootmem的API不再可用，所以bootmem分配必须先于kmem_cache_init()。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;setup_log_buf(0);</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>使用bootmem分配一个记录启动信息的缓存区</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;pidhash_init();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>使用bootmem分配并初始化PID散列表，由PID分配器管理空闲和已指派的PID</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;vfs_caches_init_early();</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>前期VFS缓存初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;sort_main_extable();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>对内核异常表（ exception table ）按照异常向量号大小进行排序。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;trap_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>对内核陷阱异常进行初始化，在ARM构架中为空函数。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;mm_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化内核内存分配器，其包含6个子函数，作用如下：</li> 
            <li> <strong>1、page_cgroup_init_flatmem();</strong>&nbsp;获取page_cgroup 所需内存</li> 
            <li> <strong>2、mem_init(); 关闭并释放bootmem分配器</strong>，打印内存信息。在内核启动时看到的类似如下信息，就是其子函数mem_init输出的：</li> 
            <li> 
             <div> 
              <div class="codeheads"> 
               <p>点击(此处)折叠或打开</p> 
              </div> 
              <div class="codeText">
               <ol>
                <li>Memory: 86MB 39MB = 125MB total</li> 
                <li>Memory: 120768k/120768k available, 99392k reserved, 0K highmem</li> 
                <li>Virtual kernel memory layout:</li> 
                <li>vector : 0xffff0000 - 0xffff1000 ( 4 kB)</li> 
                <li>fixmap : 0xfff00000 - 0xfffe0000 ( 896 kB)</li> 
                <li>DMA : 0xffc00000 - 0xffe00000 ( 2 MB)</li> 
                <li>vmalloc : 0xde800000 - 0xf8000000 ( 408 MB)</li> 
                <li>lowmem : 0xc0000000 - 0xde400000 ( 484 MB)</li> 
                <li>pkmap : 0xbfe00000 - 0xc0000000 ( 2 MB)</li> 
                <li>modules : 0xbf000000 - 0xbfe00000 ( 14 MB)</li> 
                <li>.init : 0xc0008000 - 0xc003b000 ( 204 kB)</li> 
                <li>.text : 0xc003b000 - 0xc04c0000 (4628 kB)</li> 
                <li>.data : 0xc04c0000 - 0xc0501a80 ( 263 kB)</li> 
               </ol>
              </div> 
             </div> </li> 
            <li>3、<strong>kmem_cache_init();</strong>&nbsp;初始化slab分配器</li> 
            <li>4、<strong>percpu_init_late();</strong>&nbsp;PerCPU变量系统后期初始化</li> 
            <li>5、<strong>pgtable_cache_init();</strong>页表缓存初始化，对于ARM，“介是一个空函数”</li> 
            <li>6、<strong>vmalloc_init();</strong>初始化虚拟内存分配器</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;在开启任何中断(比如定时器中断)前设置调度器<span style="color:#0000cc;">。</span> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;完整的拓扑设置发生在smp_init()中</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-但与此同时，我们仍然有一个正常运作的调度器。</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;sched_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化调度器数据结构，并创建运行队列</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;禁用强占&nbsp;-&nbsp;早期启动时的调度是极为脆弱的，</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;直到cpu_idle()的首次运行。</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;preempt_disable();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!irqs_disabled())&nbsp;{</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_WARNING&nbsp;"start_kernel(): bug: interrupts were "</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"enabled *very* early, fixing it\n");</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_irq_disable();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>在启动的初期关闭抢占和中断。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp; &nbsp; idr_init_cache();</li> 
        <li> 
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>为IDR机制分配缓存，主要是为struct idr_layer结构体分配空间</li> 
            <li>参考资料：<a href="http://blog.sina.com.cn/s/blog_476d8cf30100nhfc.html" rel="nofollow">《浅析linux内核中的idr机制》</a> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;perf_event_init();</li> 
        <li> 
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>CPU性能监视机制初始化</li> 
            <li>此机制包括CPU同一时间执行指令数，cache miss数，分支预测失败次数等性能参数</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp; &nbsp; rcu_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>内核RCU（Read-Copy Update：读取-复制-更新）机制初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;radix_tree_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>内核radix树算法初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;在init_ISA_irqs()之前初始化一些链接&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;early_irq_init();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;init_IRQ();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>硬件中断系统初始化：</li> 
            <li> </li> 
            <li>early_irq_init();前期外部中断描述符初始化，主要初始化数据结构。</li> 
            <li> </li> 
            <li>init_IRQ;对应构架特定的中断初始化函数，在ARM构架中：</li> 
            <li> <br>
             <div> 
              <div class="codeheads"> 
               <p>点击(此处)折叠或打开</p> 
              </div> 
              <div class="codeText">
               <ol>
                <li>void __init init_IRQ(void)</li> 
                <li>{</li> 
                <li>&nbsp; &nbsp;machine_desc-&gt;init_irq();</li> 
                <li>}</li> 
               </ol>
              </div> 
             </div> </li> 
            <li>也就是运行设备描述结构体中的init_irq函数，此函数一般在板级初始化文件（arch/*/mach-*/board-*.c）中定义。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;prio_tree_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化内核基于radix数的优先级搜索树（PST），主要是对其结构体进行初始化。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;init_timers();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;hrtimers_init();</li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;softirq_init();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;timekeeping_init();</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;time_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>以上几个函数主要是初始化内核的软中断及时钟机制：</li> 
            <li> </li> 
            <li>前面几个函数主要是注册一些内核通知函数到cpu和hotcpu通知链，并开启部分软中断（tasklet等）。</li> 
            <li> </li> 
            <li>最后的time_init是构架相关的，旨在开启一个硬件定时器，开始产生系统时钟。对于ARM构架：<br>
             <div> 
              <div class="codeheads"> 
               <p>点击(此处)折叠或打开</p> 
              </div> 
              <div class="codeText">
               <ol>
                <li>void __init time_init(void)</li> 
                <li>{</li> 
                <li>&nbsp;&nbsp;&nbsp;system_timer&nbsp;=&nbsp;machine_desc-&gt;timer;</li> 
                <li>&nbsp;&nbsp;&nbsp;system_timer-&gt;init();</li> 
                <li>#ifdef CONFIG_HAVE_SCHED_CLOCK</li> 
                <li>&nbsp;&nbsp;&nbsp;sched_clock_postinit();</li> 
                <li>#endif</li> 
                <li>}</li> 
               </ol>
              </div> 
             </div> </li> 
            <li> </li> 
            <li>其实就是调用板级初始化文件（arch/arm/mach-*/board-*.c）中定义“设备描述结构体”中的timer成员的初始化函数。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;profile_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化内核profile子系统，她是内核的性能调试工具。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;call_function_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化所有CPU的call_single_queue（具体作用还没搞明白），并注册CPU热插拔通知函数到CPU通知链中。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!irqs_disabled())</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_CRIT&nbsp;"start_kernel(): bug: interrupts were "</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"enabled early\n");</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;early_boot_irqs_disabled&nbsp;=&nbsp;false;</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;local_irq_enable();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>检测硬件中断是否开启，如果开启了就打印出警告。</li> 
            <li>设置启动早期IRQ使能标志，允许IRQ使能。</li> 
            <li>最后<strong><span style="color:#f00000;">开启总中断</span></strong>（ARM构架是这样，其他构架可能也是这个意思）。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;中断已经开启，因此所有GFP分配是安全的<span style="color:#0000cc;">.</span>&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;gfp_allowed_mask&nbsp;=&nbsp;__GFP_BITS_MASK;</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>开启所有GFP分配允许标志</li> 
            <li>GFP(get free page)</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;kmem_cache_init_late();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>slab分配器的后期初始化。如果使用的是slob或slub，则为空函数。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;HACK ALERT! hack警告！这个是早期的。我们在完成PCI设置等工作前</li> 
        <li>&nbsp; &nbsp;* 使能控制台，且console_init()必须意识到这个。</li> 
        <li>&nbsp; &nbsp;* 但是我们的确想要早点输出信息，以防某些错误的发生。</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;console_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化控制台，这样可以早点看到启动信息，避免出错时无法查找原因。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(panic_later)</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panic(panic_later,&nbsp;panic_param);</li> 
        <li> <br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>检查内核恐慌标志。如果出了问题，就打印信息。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;lockdep_info();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>打印lockdep调试模块的信息。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*</li> 
        <li> </li> 
        <li>&nbsp; &nbsp;* 当irq使能的时候必须运行这个函数，因为它也要自检</li> 
        <li>&nbsp; &nbsp;* [hard/soft]-irqs 开/关 锁反转的bug：</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;locking_selftest();</li> 
        <li> </li> 
        <li>#ifdef CONFIG_BLK_DEV_INITRD</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(initrd_start&nbsp;&amp;&amp;&nbsp;!initrd_below_start_ok&nbsp;&amp;&amp;</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp; page_to_pfn(virt_to_page((void&nbsp;*)initrd_start))&nbsp;&lt;&nbsp;min_low_pfn)&nbsp;{</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_CRIT&nbsp;"initrd overwritten (0x%08lx &lt; 0x%08lx) - "</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"disabling it.\n",</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; page_to_pfn(virt_to_page((void&nbsp;*)initrd_start)),</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_low_pfn);</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initrd_start&nbsp;=&nbsp;0;</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;}</li> 
        <li>#endif<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>检查initrd的位置是否符合要求。</li> 
            <li>min_low_pfn是系统可用的最小的pfn（页帧号）。</li> 
            <li>也就是判断传递进来initrd_start对应的物理地址是否正常。如果有误就打印错误信息，并清零initrd_start。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;page_cgroup_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>mem_cgroup是cgroup体系中提供的用于memory隔离的功能，此处对此功能进行初始化。</li> 
            <li>参考资料：<a href="http://hi.baidu.com/_kouu/blog/item/17b06976c6515c04b051b9c7.html" rel="nofollow">《linux内核mem_cgroup浅析》</a> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;enable_debug_pagealloc();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>使能页分配的调试标志。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;debug_objects_mem_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>debug objects机制的内存分配初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;kmemleak_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>内核内存泄漏检测机制初始化；</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;setup_per_cpu_pageset();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>设置每个CPU的页组，并初始化。此前只有启动页组。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;numa_policy_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>非一致性内存访问（NUMA）初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(late_time_init)</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;late_time_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>如果构架存在此函数，就调用后期时间初始化。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;sched_clock_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>对每个CPU，初始化调度时钟。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;calibrate_delay();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>计算BogoMIPS值，他是衡量一个CPU性能的标志。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;pidmap_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>PID分配映射初始化。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;anon_vma_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>匿名虚拟内存域（ anonymous VMA）初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>#ifdef CONFIG_X86</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(efi_enabled)</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;efi_enter_virtual_mode();</li> 
        <li>#endif</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;thread_info_cache_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>获取thread_info缓存空间，大部分构架为空函数（包括ARM）</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;cred_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>任务信用系统初始化。详见：Documentation/credentials.txt</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;fork_init(totalram_pages);<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>进程创建机制初始化。为内核"task_struct"分配空间，计算最大任务数。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;proc_caches_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>初始化进程创建机制所需的其他数据结构，为其申请空间。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;buffer_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>缓存系统初始化，创建缓存头空间，并检查其大小限时。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;key_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>内核密匙管理系统初始化。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;security_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>内核安全框架初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;dbg_late_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>内核调试系统后期初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;vfs_caches_init(totalram_pages);<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>虚拟文件系统（VFS）缓存初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;signals_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>信号管理系统初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;根文件系统的填充可能需要也回写机制&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;page_writeback_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>页回写机制初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>#ifdef CONFIG_PROC_FS</li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;proc_root_init();</li> 
        <li>#endif<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>proc文件系统初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;cgroup_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>control group的正式初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;cpuset_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>CPUSET初始化。</li> 
            <li>参考资料：<a href="http://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm" rel="nofollow">《多核心計算環境—NUMA與CPUSET簡介》</a> </li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;taskstats_init_early();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>任务状态早期初始化函数：为结构体获取高速缓存，并初始化互斥机制。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;delayacct_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>任务延迟机制初始化</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;check_bugs();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>检查CPU BUG的函数，通过软件规避BUG</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;acpi_early_init();&nbsp;/*&nbsp;在 LAPIC&nbsp;<span style="color:#0000ff;">和</span>&nbsp;SMP 前初始化&nbsp;*/<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>ACPI早期初始化函数。</li> 
            <li>ACPI - Advanced Configuration and Power Interface高级配置及电源接口</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>&nbsp; &nbsp; sfi_init_late();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>SFI 初始程序晚期设置函数，</li> 
            <li>SFI - SIMPLE FIRMWARE INTERFACE。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;ftrace_init();<br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>功能跟踪调试机制初始化，ftrace 是 function trace 的简称。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li> </li> 
        <li>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;所剩下的非-__init的初始化,&nbsp;内核现在已经启动了&nbsp;*/</li> 
        <li>&nbsp;&nbsp;&nbsp;<strong><span style="text-decoration:underline;"><em><span style="color:#f00000;font-size:large;">&nbsp;rest_init();</span></em></span></strong><br>
         <div> 
          <div class="codeheads"> 
           <p>点击(此处)折叠或打开</p> 
          </div> 
          <div class="codeText">
           <ol>
            <li>虽然从名字上来说是剩余的初始化。</li> 
            <li>但是这个函数中的初始化包含了很多的内容，后面我回单独写一篇来分析。</li> 
           </ol>
          </div> 
         </div> </li> 
        <li>}</li> 
       </ol>
      </div> 在看完上面的代码之后，你会发现内容很多。但是归纳起来，我认为需要注意的有以下几点：
     </div> 
    </div> 
    <div>
     <ol>
      <li><span style="color:#f00000;font-size:large;"><strong>内核启动参数的获取和处理</strong></span></li> 
      <li><span style="color:#f00000;font-size:large;"><strong>setup_arch(&amp;command_line);函数</strong></span></li> 
      <li><span style="color:#f00000;font-size:large;"><strong>内存管理的初始化（从bootmem到slab）</strong></span></li> 
      <li><span style="color:#f00000;font-size:large;"><strong>rest_init();函数</strong></span></li> 
     </ol>
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     其他的部分都是对内核各个组件的数据结构申请内存，并初始化。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     -----------------------------------------------------------
    </div> 
    <div>
     参考资料：
    </div> 
    <div> 
     <div> 
      <div> 
       <div class="codeText">
        <ol>
         <li> 
          <div> 
           <div>
            <a href="http://www.linuxidc.com/Linux/2011-09/43680.htm" rel="nofollow"><span style="font-size:large;">《ARM Linux系统启动-start_kernel函数》</span></a>
           </div> 
          </div> <span style="font-size:large;">一个很棒的台湾博士生&nbsp;<a href="http://www.formosaos.url.tw/" rel="nofollow">陳育書&nbsp;</a>的<a href="http://www.formosaos.url.tw/linux/kinit.html" rel="nofollow">关于Linux启动分析的博文</a></span> </li> 
         <li><span style="font-size:large;">《深入Linux内核构架》附录D 系统启动</span></li> 
         <li> </li> 
        </ol>
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
