<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>iOS:UIResponser控件的介绍(响应者) « NotBeCN</title>
  <meta name="description" content="                       UIResponser响应者控件              &nbsp;                     知识：                         在iOS中不是任何对象都能处理事件，只有继承了UIResponser的对象才能接收并处理事件。我们...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/04/30/weixin_34404393_90122228.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">iOS:UIResponser控件的介绍(响应者)</h1>
    <p class="post-meta">Apr 30, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:14pt;">UIResponser响应者控件</span>
    </div> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span>
    </div> 
    <div> 
     <div>
      <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">知识：</span>
     </div> 
     <div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">在iOS中不是任何对象都能处理事件，只有继承了UIResponser的对象才能接收并处理事件。我们称之为“响应者对象”</span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIApplication，UIViewController，UIView都继承自UIResponser，因此它们都是响应者对象，都能够接收并处理事件</span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">在以下三种情况下，不能接收事件</span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">–与用户交互的属性设为NO</span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">–hideen设为YES（隐藏）</span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">–alpha=0（透明</span>
      </div> 
     </div> 
     <div> 
      <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">可以重写</span>
      <span style="line-height:1.8;font-size:18px;font-family:arial, helvetica, sans-serif;">hitTest:withEvent:方法设置事件处理的传递链,要么自己处理不往后传递,要么不处理往后传递给其他的view处理,甚至最后UIApplication都不处理就丢弃事件。</span> 
     </div> 
    </div> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span>
    </div> 
    <div>
     <span style="line-height:1.8;color:rgb(249,77,255);font-family:'Hannotate SC';font-size:large;">响应者类：</span>
    </div> 
    <div> 
     <p><span style="line-height:1.8;color:rgb(148,17,0);font-family:'Hannotate SC';font-size:14pt;">@interface UIResponder : NSObject</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,42,28);font-family:'Hannotate SC';font-size:large;">方法：</span></p> 
     <p><span style="line-height:1.8;color:rgb(34,69,255);font-family:'Hannotate SC';font-size:large;">//获取下一个响应者</span></p> 
     <p><span style="line-height:1.8;font-size:large;">- (UIResponder*)nextResponder;</span></p> 
     <p><span style="line-height:1.8;color:rgb(31,74,255);font-size:18px;font-family:'楷体';">//当它放弃对象响应者,可以设置自身成为第一响应者,默认为NO</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (BOOL)canBecomeFirstResponder;&nbsp;&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(27,72,255);font-size:18px;font-family:'楷体';">//设置第一响应者</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (BOOL)becomeFirstResponder;</span></p> 
     <p><span style="line-height:1.8;color:rgb(26,57,255);font-family:'楷体';font-size:18px;">//如果一个对象可以放弃对象响应者就返回YES,默认返回YES</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (BOOL)canResignFirstResponder;&nbsp; &nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(33,66,255);font-family:'楷体';font-size:18px;">//放弃第一响应者</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (BOOL)resignFirstResponder;</span></p> 
     <p><span style="line-height:1.8;color:rgb(31,75,255);font-family:'楷体';font-size:18px;">//是否是第一响应者</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (BOOL)isFirstResponder;</span></p> 
     <p><span style="line-height:1.8;color:rgb(56,75,255);font-family:'楷体';font-size:18px;">//触摸开始</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)touchesBegan:(NSSet&nbsp;*)touches withEvent:(UIEvent&nbsp;*)event;</span></p> 
     <p><span style="line-height:1.8;color:rgb(80,74,255);font-family:'楷体';font-size:18px;">//触摸移动</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)touchesMoved:(NSSet&nbsp;*)touches withEvent:(UIEvent&nbsp;*)event;</span></p> 
     <p><span style="line-height:1.8;color:rgb(40,65,255);font-family:'楷体';font-size:18px;">//触摸结束</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)touchesEnded:(NSSet&nbsp;*)touches withEvent:(UIEvent&nbsp;*)event;</span></p> 
     <p><span style="line-height:1.8;color:rgb(50,81,255);font-family:'楷体';font-size:18px;">//触摸取消</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)touchesCancelled:(NSSet&nbsp;*)touches withEvent:(UIEvent&nbsp;*)event;</span></p> 
     <p><span style="line-height:1.8;color:rgb(54,74,255);font-family:'楷体';font-size:18px;">//运动开始</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent&nbsp;*)event;</span></p> 
     <p><span style="line-height:1.8;color:rgb(58,84,255);font-family:'楷体';font-size:18px;">//运动结束</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent&nbsp;*)event ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(46,75,255);font-family:'楷体';font-size:18px;">//运动取消</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent&nbsp;*)event ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(60,75,255);font-family:'楷体';font-size:18px;">//远程控制接收事件</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)remoteControlReceivedWithEvent:(UIEvent&nbsp;*)event ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(55,72,255);font-family:'楷体';font-size:18px;">//处理命令事件</span></p> 
     <p><span style="line-height:1.8;font-size:large;">- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&nbsp;;</span></p> 
     <p><span style="line-height:1.8;color:rgb(79,80,255);font-family:'楷体';font-size:18px;">//初始化并处理命令事件</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (id)targetForAction:(SEL)action withSender:(id)sender;</span></p> 
     <p>&nbsp;</p> 
     <p><span style="line-height:1.8;color:rgb(255,53,58);font-family:'Hannotate SC';font-size:large;">属性：</span></p> 
     <p><span style="line-height:1.8;color:rgb(40,84,255);font-family:'Hannotate SC';font-size:large;">//公共的事件撤销管理者</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property(nonatomic,readonly)&nbsp;NSUndoManager&nbsp;*undoManager;</span></p> 
     <p>@end</p> 
     <p><span style="line-height:1.8;color:rgb(225,64,31);font-family:'Hannotate SC';font-size:large;">默认情况下，程序的每一个window都有一个undo管理器，它是一个用于管理undo和redo操作的共享对象。然而，响应链上的任何对象的类都可以有自定义undo管理器。例如，UITextField的实例的自定义管理器在文件输入框放弃第一响应者状态时会被清理掉。当需要一个undo管理器时，请求会沿着响应链传递，然后UIWindow对象会返回一个可用的实例。</span></p> 
     <p>&nbsp;</p> 
     <p><span style="line-height:1.8;color:rgb(255,77,255);font-family:'Hannotate SC';font-size:large;">按键调节器枚举(快捷键)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">typedef&nbsp;NS_OPTIONS(NSInteger, UIKeyModifierFlags) {</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; UIKeyModifierAlphaShift , &nbsp; &nbsp; &nbsp; &nbsp;<span style="line-height:1.8;color:rgb(50,71,255);">&nbsp;//Alppha+Shift键</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; UIKeyModifierShift &nbsp; &nbsp; &nbsp; &nbsp;, &nbsp; &nbsp;&nbsp;<span style="line-height:1.8;color:rgb(44,81,255);">&nbsp; &nbsp; //Shift键</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; UIKeyModifierControl&nbsp; &nbsp; , &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="line-height:1.8;color:rgb(59,74,255);">&nbsp;//Control键</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; UIKeyModifierAlternate&nbsp;, &nbsp; &nbsp; &nbsp; &nbsp;<span style="line-height:1.8;color:rgb(78,83,255);">&nbsp;&nbsp;//Alt键</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; UIKeyModifierCommand&nbsp;, &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="line-height:1.8;color:rgb(71,90,255);">&nbsp;//Command键</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; UIKeyModifierNumericPad , &nbsp; &nbsp; &nbsp;<span style="line-height:1.8;color:rgb(70,95,255);">&nbsp;//Num键</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">} ;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,86,255);font-family:'Hannotate SC';font-size:large;">按键命令类：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:14pt;color:rgb(128,0,0);">@interface&nbsp;UIKeyCommand :&nbsp;NSObject&nbsp;&lt;NSCopying,&nbsp;NSSecureCoding&gt;</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,43,0);font-family:'Hannotate SC';font-size:large;">属性：</span></p> 
     <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体';font-size:18px;">//输入字符串</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,readonly)&nbsp;NSString&nbsp;*input;</span></p> 
     <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体';font-size:18px;">//按键调节器</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,readonly)&nbsp;UIKeyModifierFlags&nbsp;modifierFlags;</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,51,55);font-family:'Hannotate SC';font-size:large;">方法：</span></p> 
     <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体';font-size:18px;">//按指定调节器键输入字符串并设置事件</span></p> 
     <p><span style="line-height:1.8;font-size:large;"><span style="line-height:1.8;font-family:'Hannotate SC';">+ (UIKeyCommand *)keyCommandWithInput:(NSString *)input modifierFlags:</span><span style="line-height:1.8;font-size:16px;">(UIKeyModifierFlags) modifierFlags action:(SEL)action;</span></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@end</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(252,81,255);font-family:'Hannotate SC';font-size:large;">响应者类的按键命令类类目：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@interface&nbsp;UIResponder (UIResponderKeyCommands)</span></p> 
     <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体';font-size:18px;">//组合快捷键命令(装有多个按键的数组)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,readonly)&nbsp;NSArray&nbsp;*keyCommands;&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@end</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(251,77,255);font-family:'Hannotate SC';font-size:large;">NSObject类的标准编辑事件响应类类目</span></p> 
     <p><span style="line-height:1.8;color:rgb(148,17,0);font-family:'Hannotate SC';"><span style="line-height:1.8;font-size:14pt;">@interface NSObject(UIResponderStandardEditActions)&nbsp;</span>&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(45,92,255);font-family:'Hannotate SC';font-size:large;">//剪贴</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)cut:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(30,87,255);font-family:'楷体';font-size:18px;">//复制</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)copy:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(39,76,255);font-family:'楷体';font-size:18px;">//粘贴</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)paste:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(42,80,255);font-family:'楷体';font-size:18px;">//选择</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)select:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(36,77,255);font-family:'楷体';font-size:18px;">//选择全部</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)selectAll:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(41,63,255);font-family:'楷体';font-size:18px;">//删除</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)delete:(id)sender;</span></p> 
     <p><span style="line-height:1.8;color:rgb(39,72,255);font-family:'楷体';font-size:18px;">//从左到右写入字符串(居左)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)makeTextWritingDirectionLeftToRight:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(16,74,255);font-family:'楷体';font-size:18px;">//从右到左写入字符串(居右)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)makeTextWritingDirectionRightToLeft:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(39,77,255);font-family:'楷体';font-size:18px;">//切换字体为黑体(粗体)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)toggleBoldface:(id)sender;</span></p> 
     <p><span style="line-height:1.8;color:rgb(49,73,255);font-family:'楷体';font-size:18px;">//切换字体为斜体</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)toggleItalics:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(37,74,255);font-family:'楷体';font-size:18px;">//给文字添加下划线</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)toggleUnderline:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(31,84,255);font-family:'楷体';font-size:18px;">//增加字体大小</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)increaseSize:(id)sender ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(40,64,255);font-family:'楷体';font-size:18px;">//减小字体大小</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)decreaseSize:(id)sender;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@end</span></p> 
     <p>&nbsp;</p> 
     <p><span style="line-height:1.8;color:rgb(254,79,255);font-family:'Hannotate SC';font-size:large;">响应者类的类目:</span></p> 
     <p><span style="line-height:1.8;color:rgb(148,17,0);font-family:'Hannotate SC';font-size:14pt;">@interface UIResponder (UIResponderInputViewAdditions)</span></p> 
     <p><span style="line-height:1.8;color:rgb(225,60,23);font-family:'Hannotate SC';font-size:large;">属性：</span></p> 
     <p><span style="line-height:1.8;color:rgb(44,101,253);font-family:'Hannotate SC';font-size:large;">//键盘输入视图(系统默认的,可以自定义)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;readonly,&nbsp;retain)&nbsp;UIView&nbsp;*inputView;</span></p> 
     <p><span style="line-height:1.8;color:rgb(53,113,253);font-family:'楷体';font-size:18px;">//弹出键盘时附带的视图</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;readonly,&nbsp;retain)&nbsp;UIView&nbsp;*inputAccessoryView;</span></p> 
     <p><span style="line-height:1.8;color:rgb(51,95,253);font-family:'楷体';font-size:18px;">//键盘输入视图控制器</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;readonly,&nbsp;retain)&nbsp;UIInputViewController&nbsp;*inputViewController ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(44,86,253);font-family:'楷体';font-size:18px;">//弹出键盘时附带的视图的视图控制器</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;readonly,&nbsp;retain)&nbsp;UIInputViewController&nbsp;*inputAccessoryViewController;</span></p> 
     <p><span style="line-height:1.8;color:rgb(72,97,253);font-family:'楷体';font-size:18px;">//文本输入模式</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;readonly,&nbsp;retain)&nbsp;UITextInputMode&nbsp;*textInputMode ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(66,93,253);font-family:'楷体';font-size:18px;">//文本输入模式标识</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;readonly,&nbsp;retain)&nbsp;NSString&nbsp;*textInputContextIdentifier;</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,48,22);font-family:'Hannotate SC';font-size:large;">方法：</span></p> 
     <p><span style="line-height:1.8;color:rgb(40,84,253);font-family:'楷体';font-size:18px;">//根据设置的标识清除指定的文本输入模式</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">+ (void)clearTextInputContextIdentifier:(NSString&nbsp;*)identifier;</span></p> 
     <p><span style="line-height:1.8;color:rgb(39,109,253);font-family:'楷体';font-size:18px;">//重新刷新键盘输入视图</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)reloadInputViews;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@end</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;"><span style="line-height:1.8;color:rgb(255,0,0);">注意:</span></span></p> 
     <p><span style="line-height:1.8;color:rgb(255,45,12);font-family:'Hannotate SC';font-size:large;">UITextFields和UITextView有一个inputAccessoryView的属性，当你想在键盘上展示一个自定义的view时，你就可以设置该属性。你设置的view就会自动和键盘keyboard一起显示了。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,45,12);font-family:'Hannotate SC';font-size:large;">需要注意的是，你所自定义的view既不应该处在其他的视图层里，也不应该成为其他视图的子视图。其实也就是说，你所自定义的view只需要赋给属性inputAccessoryView就可以了，不要再做其他多余的操作。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,45,12);font-family:'Hannotate SC';font-size:large;">我们在使用UITextView和UITextField的时候，可以通过它们的inputAccessoryView属性给输入时呼出的键盘加一个附属视图，通常是UIToolBar，用于回收键盘。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,0,0);font-family:'Hannotate SC';font-size:large;">inputView就是显示键盘的view,如果重写这个view则不再弹出键盘，而是弹出自己的view.如果想实现当某一控件变为第一响应者时不弹出键盘而是弹出我们自定义的界面，那么我们就可以通过修改这个inputView来实现，比如弹出一个日期拾取器。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,0,0);font-family:'Hannotate SC';font-size:large;">inputView不会随着键盘出现而出现，设置了InputView只会当UITextField或者UITextView变为第一相应者时显示出来，不会显示键盘了。设置了InputAccessoryView，它会随着键盘一起出现并且会显示在键盘的顶端。InutAccessoryView默认为nil.</span></p> 
     <p><img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009185339096-2104507266.png" alt="" style="border:0px;">&nbsp;</p> 
     <p><span style="line-height:1.8;color:rgb(248,76,255);font-family:'Hannotate SC';font-size:large;">按键输入箭头指向</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIKIT_EXTERN&nbsp;NSString&nbsp;*const&nbsp;UIKeyInputUpArrow &nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIKIT_EXTERN&nbsp;NSString&nbsp;*const&nbsp;UIKeyInputDownArrow &nbsp;&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIKIT_EXTERN&nbsp;NSString&nbsp;*const&nbsp;UIKeyInputLeftArrow&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIKIT_EXTERN&nbsp;NSString&nbsp;*const&nbsp;UIKeyInputRightArrow&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIKIT_EXTERN&nbsp;NSString&nbsp;*const&nbsp;UIKeyInputEscape&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(239,78,255);font-family:'Hannotate SC';font-size:large;">响应者类的类目:</span></p> 
     <p><span style="line-height:1.8;color:rgb(148,17,0);font-family:'Hannotate SC';font-size:14pt;">@interface UIResponder (ActivityContinuation)</span></p> 
     <p><span style="line-height:1.8;color:rgb(60,104,255);font-family:'Hannotate SC';font-size:large;">//用户活动</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property&nbsp;(nonatomic,&nbsp;retain)&nbsp;NSUserActivity&nbsp;*userActivity ;</span></p> 
     <p><span style="line-height:1.8;color:rgb(54,88,255);font-family:'Hannotate SC';font-size:large;">//更新用户活动</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)updateUserActivityState:(NSUserActivity&nbsp;*)activity;</span></p> 
     <p><span style="line-height:1.8;color:rgb(51,89,255);font-family:'Hannotate SC';font-size:large;">//恢复用户活动</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (void)restoreUserActivityState:(NSUserActivity&nbsp;*)activity;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@end</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:large;">注意：</span></p> 
     <h2 style="color:rgb(0,0,0);line-height:1.5;font-size:21px;"><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';">支持User Activities</span></h2> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">从iOS 8起，苹果为我们提供了一个非常棒的功能，即Handoff。使用这一功能，我们可以在一部iOS设备的某个应用上开始做一件事，然后在另一台iOS设备上继续做这件事。Handoff的基本思想是用户在一个应用里所做的任何操作都可以看作是一个Activity，一个Activity可以和一个特定iCloud用户的多台设备关联起来。在编写一个支持Handoff的应用时，会有以下三个交互事件：</span></p> 
     <ol>
      <li style="list-style:decimal;"><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">为将在另一台设备上继续做的事创建一个新的User Activity；</span></li> 
      <li style="list-style:decimal;"><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">当需要时，用新的数据更新已有的User Activity；</span></li> 
      <li style="list-style:decimal;"><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">把一个User Activity传递到另一台设备上。</span></li> 
     </ol>
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">为了支持这些交互事件，在iOS 8后，UIResponder类新增了几个方法，我们在此不讨论这几个方法的实际使用，想了解更多的话，可以参考&nbsp;<a href="http://www.cocoachina.com/ios/20150115/10926.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">iOS 8 Handoff 开发指南</a>&nbsp;。我们在此只是简单描述一下这几个方法。&nbsp;</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">在UIResponder中，已经为我们提供了一个userActivity属性，它是一个NSUserActivity对象。因此我们在UIResponder的子类中不需要再去声明一个userActivity属性，直接使用它就行。其声明如下：</span></p> 
     <pre><code class="language-css"><span style="line-height:1.8;font-size:18px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="at_rule" style="line-height:1.8;"><span style="line-height:1.8;color:rgb(4,1,2);font-family:'Hannotate SC';">@<span class="function" style="line-height:1.8;">property(nonatomic, retain) NSUserActivity *userActivity</span></span></span></code></span></code></pre> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">由UIKit管理的User Activities会在适当的时间自动保存。一般情况下，我们可以重写UIResponder类的updateUserActivityState:方法来延迟添加表示User Activity的状态数据。当我们不再需要一个User Activity时，我们可以设置userActivity属性为nil。任何由UIKit管理的NSUserActivity对象，如果它没有相关的响应者，则会自动失效。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">另外，多个响应者可以共享一个NSUserActivity实例。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">上面提到的updateUserActivityState:是用于更新给定的User Activity的状态。其定义如下：</span></p> 
     <pre class="prettyprint cs"><span style="line-height:1.8;font-size:18px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span style="line-height:1.8;color:rgb(4,1,3);font-family:'Hannotate SC';">- (<span class="keyword" style="line-height:1.8;">void)updateUserActivityState:(NSUserActivity *)activity</span></span></code></span></pre> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">子类可以重写这个方法来按照我们的需要更新给定的User Activity。我们需要使用NSUserActivity对象的addUserInfoEntriesFromDictionary:方法来添加表示用户Activity的状态。</span></p> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">在我们修改了User Activity的状态后，如果想将其恢复到某个状态，则可以使用以下方法：</span></p> 
     <pre class="prettyprint cs"><span style="line-height:1.8;font-size:18px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span style="line-height:1.8;color:rgb(4,0,0);font-family:'Hannotate SC';">- (<span class="keyword" style="line-height:1.8;">void)restoreUserActivityState:(NSUserActivity *)activity</span></span></code></span></pre> 
     <p><span style="line-height:1.8;color:rgb(255,50,8);font-family:'Hannotate SC';font-size:18px;">子类可以重写这个方法来使用给定User Activity的恢复响应者的状态。系统会在接收到数据时，将数据传递给application:continueUserActivity:restorationHandler:以做处理。我们重写时应该使用存储在user activity的userInfo字典中的状态数据来恢复对象。当然，我们也可以直接调用这个方法。</span></p> 
    </div> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span>
    </div> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span>
    </div> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;️️️</span>
    </div> 
    <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UIView类中一些用于触摸事件和手势的常用方法：</span></p> 
    <div> 
     <span style="line-height:1.8;color:rgb(43,67,253);font-family:'楷体';font-size:18px;">//事件响应的测试:hit-test视图链事件处理</span>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;"><br></span> 
     <div> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;&nbsp;</span></p> 
      <p><span style="line-height:1.8;color:rgb(251,77,236);font-family:'Hannotate SC';font-size:large;">注释：</span></p> 
      <p><span style="line-height:1.8;color:rgb(251,77,236);font-family:'Hannotate SC';font-size:large;">1.返回nil，表明对任何事件不做响应</span></p> 
      <p><span style="line-height:1.8;color:rgb(251,77,236);font-family:'Hannotate SC';font-size:large;">2.返回self,对任何事件都响应</span></p> 
      <p><span style="line-height:1.8;color:rgb(251,77,236);font-family:'Hannotate SC';font-size:large;">3.返回一个特定的view,将事件传递给响应者</span></p> 
      <p>&nbsp;</p> 
      <p><span style="line-height:1.8;color:rgb(50,69,253);font-family:'Hannotate SC';font-size:large;">//判断触摸点point在那个区域中</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent&nbsp;*)event;&nbsp;</span></p> 
      <p><span style="line-height:1.8;color:rgb(255,44,68);font-family:'Hannotate SC';font-size:large;">注释：</span></p> 
      <p><span style="line-height:1.8;color:rgb(255,44,68);font-family:'Hannotate SC';font-size:large;">判断点是否被当前视图处理</span></p> 
      <p><span style="line-height:1.8;color:rgb(255,44,68);font-family:'Hannotate SC';font-size:large;">1.返回YES:所有的点全处理</span></p> 
      <p><span style="line-height:1.8;color:rgb(255,44,68);font-family:'Hannotate SC';font-size:large;">2.返回NO：所有的点全部处理</span></p> 
      <p>&nbsp;</p> 
      <p><span style="line-height:1.8;color:rgb(68,88,253);font-family:'Hannotate SC';font-size:large;">//将当前点或当前矩形区域的坐标转换到指定视图的坐标系</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (CGPoint)convertPoint:(CGPoint)point toView:(UIView&nbsp;*)view;</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView&nbsp;*)view;</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (CGRect)convertRect:(CGRect)rect toView:(UIView&nbsp;*)view;</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (CGRect)convertRect:(CGRect)rect fromView:(UIView&nbsp;*)view;</span></p> 
      <p>&nbsp;</p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;color:rgb(128,0,128);">举例验证事件处理的传递链如下：</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">1.在故事板的控制器视图View中拖入三个子控件,它们处于同一层级,顺序依次分别为按钮button和两个视图view1、view2,设置不同的背景颜色，绿色的为view1、深红色的为view2、紫色的为button。</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">此时,对触摸事件的处理传递链依次分别是:</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">view2--&gt;button--&gt;view--&gt;ViewControler--&gt;UIWindow--&gt;Application--&gt;丢弃</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">view1--&gt;view--&gt;ViewControler--&gt;UIWindow--&gt;Application--&gt;丢弃</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">view--&gt;ViewController--&gt;UIWindow--&gt;Application--&gt;丢弃</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;"><img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009192525237-1562600680.png" alt="" style="border:0px;">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009192855971-70476597.png" alt="" style="border:0px;">&nbsp;&nbsp;</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">2.为view1和view2分别创建两个类myView1和myView2,并将它们的控件与类对应,同时给button在控制器类中关联事件。</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;"><img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009193432424-1521979264.png" alt="" style="border:0px;">&nbsp; &nbsp;<img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009193537768-876912627.png" alt="" style="border:0px;"><span style="line-height:1.8;color:rgb(0,0,255);">(view1)&nbsp;</span></span><img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009193458737-861036401.png" alt="" style="border:0px;font-family:'Hannotate SC';font-size:16px;line-height:24px;"><span style="line-height:1.8;color:rgb(0,0,255);">(view2)</span></p> 
      <p><img src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151009193605456-428766683.png" alt="" style="border:0px;"><span style="line-height:1.8;color:rgb(0,0,255);">(button)</span></p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">3.在ViewController.m文件中添加按钮事件的代码以重写触摸开始事件方法</span></p> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(255,0,255);">//按钮事件处理</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre>- (IBAction)buttonClicked:(UIButton *<span style="line-height:1.8;">)sender
{
    NSLog(</span><span style="line-height:1.8;color:rgb(128,0,0);">@"</span><span style="line-height:1.8;color:rgb(128,0,0);">点击了按钮</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">);
}</span></pre>
      </div> 
      <p><span style="line-height:1.8;font-size:16px;font-family:'comic sans ms', sans-serif;color:rgb(255,0,255);">//触摸开始事件处理</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">
{
    NSLog(</span><span style="line-height:1.8;color:rgb(128,0,0);">@"</span><span style="line-height:1.8;color:rgb(128,0,0);">点击了白色的视图</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">);
}</span></pre>
      </div> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">4.在子视图view1对应的类myView1.m文件中重写触摸开始事件处理，同时重写PointInside:withEvent:方法设置view1视图对触摸点事件是否处理。</span></p> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(255,0,255);">//触摸开始事件处理</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">
{
    NSLog(</span><span style="line-height:1.8;color:rgb(128,0,0);">@"</span><span style="line-height:1.8;color:rgb(128,0,0);">点击了绿色的视图</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">);
}</span></pre>
      </div> 
      <p><span style="line-height:1.8;color:rgb(255,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">//设置view1是否处理该触摸点事件</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">
{
    </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span><span style="line-height:1.8;"> NO;
}</span></pre>
      </div> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(51,102,255);">解释：</span><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(51,102,255);">判断点是否被当前视图处理</span></p> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(51,102,255);">1.返回YES:所有的点全处理</span></p> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(51,102,255);">2.返回NO：所有的点全部不处理</span></p> 
      <p>&nbsp;</p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">5、在子视图view2对应的类myView2.m文件中重写触摸开始事件处理，同时重写hitTest:withEvent:方法设置view2视图对触摸点事件处理的传递链。</span></p> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(255,0,255);">//触摸开始事件处理</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">
{
    NSLog(</span><span style="line-height:1.8;color:rgb(128,0,0);">@"</span><span style="line-height:1.8;color:rgb(128,0,0);">点击了红色视图</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">);
}</span></pre>
      </div> 
      <p>/<span style="line-height:1.8;color:rgb(255,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">/设置view2视图对触摸点事件处理的传递链</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
       <div class="cnblogs_code_toolbar">
        <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
       </div> 
       <pre>-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">
{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">查找button</span>
    UIButton *<span style="line-height:1.8;">btn;
    </span><span style="line-height:1.8;color:rgb(0,0,255);">for</span> (UIView *view <span style="line-height:1.8;color:rgb(0,0,255);">in</span><span style="line-height:1.8;"> self.superview.subviews)
    {
        </span><span style="line-height:1.8;color:rgb(0,0,255);">if</span> (view.tag == <span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">)
        {
            btn </span>= (UIButton *<span style="line-height:1.8;">)view;
            </span><span style="line-height:1.8;color:rgb(0,0,255);">break</span><span style="line-height:1.8;">;
        }
    }  
    
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">判断触摸点point在那个区域中
    
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">1.将当前点的坐标转换为按钮btn的坐标系</span>
    CGPoint btnPoint =<span style="line-height:1.8;"> [self convertPoint:point toView:btn];
    
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">2.再判断</span>
    <span style="line-height:1.8;color:rgb(0,0,255);">if</span> ([btn pointInside:btnPoint withEvent:<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">])
    {
        </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span><span style="line-height:1.8;"> btn;
    }
    </span><span style="line-height:1.8;color:rgb(0,0,255);">else</span> <span style="line-height:1.8;color:rgb(0,0,255);">if</span> ([self pointInside:point withEvent:<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">])
    {
        </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span><span style="line-height:1.8;"> self;
    }
    
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">正常的情况下
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">return self.superview;</span>
    <span style="line-height:1.8;color:rgb(0,0,255);">return</span> [super hitTest:point withEvent:<span style="line-height:1.8;color:rgb(0,0,255);">event</span><span style="line-height:1.8;">];
}</span></pre> 
       <div class="cnblogs_code_toolbar">
        <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
       </div> 
      </div> 
      <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">解释：事件响应的测试</span></p> 
      <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">1.返回nil，表明对任何事件不做响应</span></p> 
      <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">2.返回self,对任何事件都响应</span></p> 
      <p><span style="line-height:1.8;color:rgb(0,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">3.返回一个特定的view,将事件传递给响应者</span></p> 
      <p>&nbsp;</p> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:16px;">6.演示结果如下：</span></p> 
      <p><span style="line-height:1.8;font-family:'comic sans ms', sans-serif;font-size:16px;color:rgb(255,0,255);">&lt;1&gt;点击view2红色区域(不与紫色button局域重合的地方)时，view2视图对触摸点事件进行了处理</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre><span style="line-height:1.8;color:rgb(128,0,128);">2015</span>-<span style="line-height:1.8;color:rgb(128,0,128);">10</span>-<span style="line-height:1.8;color:rgb(128,0,128);">09</span> <span style="line-height:1.8;color:rgb(128,0,128);">20</span>:<span style="line-height:1.8;color:rgb(128,0,128);">02</span>:<span style="line-height:1.8;color:rgb(128,0,128);">49.283</span> <span style="line-height:1.8;color:rgb(128,0,128);">04</span>-responser[<span style="line-height:1.8;color:rgb(128,0,128);">5397</span>:<span style="line-height:1.8;color:rgb(128,0,128);">279978</span>] 点击了红色视图</pre>
      </div> 
      <p><span style="line-height:1.8;color:rgb(255,0,255);font-size:16px;font-family:'comic sans ms', sans-serif;">&lt;2&gt;点击button紫色局域(包括重合局域)时,button按钮对触摸点事件都进行了处理。原因：点击button与view2没有重合的按钮局域时,button重写了TouchesBegan: withEvent:方法，它会对此局域的触摸事件做处理；点击button与view2重合的按钮局域时,本来view2视图在button的前面,view2应该先做处理的,但是由于view2类重写了hitTest：withEvent:方法,使得view2不对此局域的事件做处理,而是传递给了指定的视图button做处理。</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre><span style="line-height:1.8;color:rgb(128,0,128);">2015</span>-<span style="line-height:1.8;color:rgb(128,0,128);">10</span>-<span style="line-height:1.8;color:rgb(128,0,128);">09</span> <span style="line-height:1.8;color:rgb(128,0,128);">20</span>:<span style="line-height:1.8;color:rgb(128,0,128);">13</span>:<span style="line-height:1.8;color:rgb(128,0,128);">48.385</span> <span style="line-height:1.8;color:rgb(128,0,128);">04</span>-responser[<span style="line-height:1.8;color:rgb(128,0,128);">5397</span>:<span style="line-height:1.8;color:rgb(128,0,128);">279978</span>] 点击了按钮</pre>
      </div> 
      <p><span style="line-height:1.8;color:rgb(255,0,255);font-family:'comic sans ms', sans-serif;font-size:16px;">&lt;3&gt;点击view1绿色局域和其他的白色局域时,都是当前控制器的视图view做了处理。原因：虽然view1的类重写了TouchesBegan: withEvent:方法用来处理触摸事件,但是又由于它有重写了pointInside：withEvent:方法并且返回值为NO,使自己不再对自己局域的任何触摸点事件做处理,而是把此事件直接向后传递给了它的父类View进行了处理。同时,控制器类的视图空白局域事件也是由View进行处理的,所以输出结果如下所示。</span></p> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre><span style="line-height:1.8;color:rgb(128,0,128);">2015</span>-<span style="line-height:1.8;color:rgb(128,0,128);">10</span>-<span style="line-height:1.8;color:rgb(128,0,128);">09</span> <span style="line-height:1.8;color:rgb(128,0,128);">20</span>:<span style="line-height:1.8;color:rgb(128,0,128);">15</span>:<span style="line-height:1.8;color:rgb(128,0,128);">35.647</span> <span style="line-height:1.8;color:rgb(128,0,128);">04</span>-responser[<span style="line-height:1.8;color:rgb(128,0,128);">5397</span>:<span style="line-height:1.8;color:rgb(128,0,128);">279978</span>] 点击了白色的视图</pre>
      </div> 
      <p>&nbsp;</p> 
      <p>&nbsp;</p> 
     </div> 
    </div> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div class="clear" style="clear:both;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></div> 
   <div> 
    <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     分类:&nbsp;
     <a href="http://www.cnblogs.com/XYQ-208910/category/742527.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">iOS高级</a> 
    </div> 
    <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <br>
    </div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/4865051.html，如需转载请自行联系原作者</span></font>
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
