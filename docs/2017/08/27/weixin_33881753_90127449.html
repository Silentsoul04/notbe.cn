<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>WeakHashMap « NotBeCN</title>
  <meta name="description" content="                             WeakHashMap，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。     code     此例子中声明了两个Map对象，一个是HashMap，一个是WeakHashMap，同时向两个map中放入a、b两个对象，当Ha...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/08/27/weixin_33881753_90127449.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">WeakHashMap</h1>
    <p class="post-meta">Aug 27, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div>
    <br>
   </div> 
   <div> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">WeakHashMap，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p> 
    <h2 style="color:rgb(177,177,177);font-size:21px;line-height:1.5;font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;">code</h2> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">此例子中声明了两个Map对象，一个是HashMap，一个是WeakHashMap，同时向两个map中放入a、b两个对象，当HashMap.remove掉a 并且将a、b都指向null时，WeakHashMap中的a将自动被回收掉。出现这个状况的原因是，对于a对象而言，当HashMap.remove掉并且将a指向null后，除了WeakHashMap中还保存a外已经没有指向a的指针了，所以WeakHashMap会自动舍弃掉a，而对于b对象虽然指向了null，但HashMap中还有指向b的指针，所以WeakHashMap将会保留。</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> Test {  
    </span><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> main(String[] args) <span style="color:rgb(0,0,255);line-height:1.5;">throws</span><span style="line-height:1.5;"> Exception {  
        String a </span>= <span style="color:rgb(0,0,255);line-height:1.5;">new</span> String("a"<span style="line-height:1.5;">);  
        String b </span>= <span style="color:rgb(0,0,255);line-height:1.5;">new</span> String("b"<span style="line-height:1.5;">);  
        Map weakmap </span>= <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> WeakHashMap();  
        Map map </span>= <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> HashMap();  
        map.put(a, </span>"aaa"<span style="line-height:1.5;">);  
        map.put(b, </span>"bbb"<span style="line-height:1.5;">);  
          
        weakmap.put(a, </span>"aaa"<span style="line-height:1.5;">);  
        weakmap.put(b, </span>"bbb"<span style="line-height:1.5;">);  
          
        map.remove(a);  
          
        a</span>=<span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;  
        b</span>=<span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;  
          
        System.gc();  
        Iterator i </span>=<span style="line-height:1.5;"> map.entrySet().iterator();  
        </span><span style="color:rgb(0,0,255);line-height:1.5;">while</span><span style="line-height:1.5;"> (i.hasNext()) {  
            Map.Entry en </span>=<span style="line-height:1.5;"> (Map.Entry)i.next();  
            System.out.println(</span>"map:"+en.getKey()+":"+<span style="line-height:1.5;">en.getValue());  
        }  
  
        Iterator j </span>=<span style="line-height:1.5;"> weakmap.entrySet().iterator();  
        </span><span style="color:rgb(0,0,255);line-height:1.5;">while</span><span style="line-height:1.5;"> (j.hasNext()) {  
            Map.Entry en </span>=<span style="line-height:1.5;"> (Map.Entry)j.next();  
            System.out.println(</span>"weakmap:"+en.getKey()+":"+<span style="line-height:1.5;">en.getValue());  
              
        }  
    }   
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <h2 style="color:rgb(177,177,177);font-size:21px;line-height:1.5;font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;">我是天王盖地虎的分割线</h2> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">WeakHashMap是主要通过expungeStaleEntries这个函数的来实现移除其内部不用的条目从而达到的自动释放内存的目的的.基本上只要对WeakHashMap的内容进行访问就会调用这个函数，从而达到清除其内部不在为外部引用的条目。但是如果预先生成了WeakHashMap，而在GC以前又不曾访问该WeakHashMap,那不是就不能释放内存了吗？</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> WeakHashMapTest1 {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span><span style="line-height:1.5;"> main(String[] args) {
        List</span>&lt;WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt;&gt; maps = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> ArrayList&lt;WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt;&gt;<span style="line-height:1.5;">();
        </span><span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; 1000000; i++<span style="line-height:1.5;">) {
            WeakHashMap</span>&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt; d = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt;<span style="line-height:1.5;">();
            d.put(</span><span style="color:rgb(0,0,255);line-height:1.5;">new</span> <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[1000][1000], <span style="color:rgb(0,0,255);line-height:1.5;">new</span> <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[1000][1000<span style="line-height:1.5;">]);
            maps.add(d);
            System.gc();
            System.err.println(i);
        }
    }
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">该测试跑不了几步循环就内存溢出了。果不其然，WeakHashMap这个时候并没有自动帮我们释放不用的内存。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;"><a href="https://images0.cnblogs.com/blog/587773/201505/031304478965526.png" rel="nofollow" style="color:rgb(153,153,153);text-decoration:none;"><img title="image" src="https://images0.cnblogs.com/blog/587773/201505/031304489905624.png" alt="image" width="480" height="286" style="border:0px;background-image:none;"></a></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> WeakHashMapTest2 {
       </span><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> main(String[] args) <span style="color:rgb(0,0,255);line-height:1.5;">throws</span><span style="line-height:1.5;"> Exception {
              List</span>&lt;WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt;&gt; maps = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> ArrayList&lt;WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt;&gt;<span style="line-height:1.5;">();
              </span><span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; 1000; i++<span style="line-height:1.5;">) {
                     WeakHashMap</span>&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt; d = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][]&gt;<span style="line-height:1.5;">();
                     d.put(</span><span style="color:rgb(0,0,255);line-height:1.5;">new</span> <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[1000][1000], <span style="color:rgb(0,0,255);line-height:1.5;">new</span> <span style="color:rgb(0,0,255);line-height:1.5;">long</span>[1000][1000<span style="line-height:1.5;">]);
                     maps.add(d);
                     System.gc();
                     System.err.println(i);
                     </span><span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> j = 0; j &lt; i; j++<span style="line-height:1.5;">) {
                            System.err.println(j </span>+ " size" +<span style="line-height:1.5;"> maps.get(j).size());
                     }
              }
       }
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;"><a href="https://images0.cnblogs.com/blog/587773/201505/031304499909452.png" rel="nofollow" style="color:rgb(153,153,153);text-decoration:none;"><img title="image" src="https://images0.cnblogs.com/blog/587773/201505/031304509745753.png" alt="image" width="480" height="296" style="border:0px;background-image:none;"></a></p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">这次测试输出正常,不在出现内存溢出问题。<br> 总结来说：WeakHashMap并不是你啥也干他就能自动释放内部不用的对象的，而是在你访问它的内容的时候释放内部不用的对象。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">WeakHashMap实现弱引用，是因为它的Entry&lt;K,V&gt;是继承自WeakReference&lt;K&gt;的。在WeakHashMap$Entry&lt;K,V&gt;的类定义及构造函数里面是这样写的：</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="color:rgb(0,0,255);line-height:1.5;">private</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span> Entry&lt;K,V&gt; <span style="color:rgb(0,0,255);line-height:1.5;">extends</span> WeakReference&lt;K&gt; <span style="color:rgb(0,0,255);line-height:1.5;">implements</span> Map.Entry&lt;K,V&gt; Entry(K key, V value, ReferenceQueue&lt;K&gt; queue,<span style="color:rgb(0,0,255);line-height:1.5;">int</span> hash, Entry&lt;K,V&gt;<span style="line-height:1.5;"> next) { 
       </span><span style="color:rgb(0,0,255);line-height:1.5;">super</span><span style="line-height:1.5;">(key, queue); 
       </span><span style="color:rgb(0,0,255);line-height:1.5;">this</span>.value =<span style="line-height:1.5;"> value; 
       </span><span style="color:rgb(0,0,255);line-height:1.5;">this</span>.hash =<span style="line-height:1.5;"> hash; 
       </span><span style="color:rgb(0,0,255);line-height:1.5;">this</span>.next =<span style="line-height:1.5;"> next; 
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">请注意它构造父类的语句：“super(key, queue);”，传入的是key，因此key才是进行弱引用的，value是直接强引用关联在this.value之中。在System.gc()时，key中的byte数组进行了回收，而value依然保持(value被强关联到entry上,entry又关联在map中,map关联在arrayList中)。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">如何证明key中的byte被回收了呢?可以通过内存溢出时导出的内存镜像进行分析,也可以通过如下的小测试得出结论:</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; 10000; i++<span style="line-height:1.5;">) { 
       WeakHashMap</span>&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], Object&gt; d = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> WeakHashMap&lt;<span style="color:rgb(0,0,255);line-height:1.5;">long</span>[][], Object&gt;<span style="line-height:1.5;">(); 
       d.put(newlong[</span>1000][1000], <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> Object()); 
       maps.add(d);        
       System.gc(); 
       System.err.println(i); 
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(153,153,153);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">上面的代码，即使执行10000次也没有问题，证明key中的long数组确实被回收了。for循环中每次都new一个新的WeakHashMap，在put操作后，虽然GC将WeakReference的key中的long数组回收了，并将事件通知到了ReferenceQueue，但后续却没有相应的动作去触发WeakHashMap 去处理 ReferenceQueue。所以 WeakReference 包装的key依然存在在WeakHashMap中，其对应的value也当然存在。（就是说long被回收掉了，但是new Object没有被回收掉）</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">那value是何时被清除的呢?</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">对两个例子进行分析可知,例子二中的maps.get(j).size()触发了value的回收,那又如何触发的呢.查看WeakHashMap源码可知,<span style="color:rgb(255,0,0);">size方法调用了expungeStaleEntries方法,该方法对vm要回收的的entry(quene中)进行遍历,并将entry的value置空,回收了内存</span>。所以效果是key在GC的时候被清除,value在key清除后访问WeakHashMap被清除。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">疑问:key的quene与map的quene是同一个quene,poll操作会减少一个reference,那问题是key如果先被清除,expungeStaleEntries遍历quene时那个被回收的key对应的entry还能取出来么???</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">关于执行System.GC时,key中的long数据如何被回收了,请见WeakReference referenceQuene<br> WeakHashMap</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
     <pre><span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span> WeakHashMap&lt;K,V&gt; <span style="color:rgb(0,0,255);line-height:1.5;">extends</span> AbstractMap&lt;K,V&gt; <span style="color:rgb(0,0,255);line-height:1.5;">implements</span> Map&lt;K,V&gt;</pre>
    </div> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">以弱键实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。null 值和 null 键都被支持。该类具有与 HashMap 类相似的性能特征,并具有相同的效能参数初始容量 和加载因子。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;"><span style="color:rgb(255,0,0);">像大多数集合类一样，该类是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。</span></p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">该类主要与这样的键对象一起使用，其 equals 方法使用 == 运算符来测试对象标识。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">一旦这种键被丢弃，就永远无法再创建了，所以，过段时间后在 WeakHashMap 中查找此键是不可能的，不必对其项已移除而感到惊讶。该类十分适合与 equals 方法不是基于对象标识的键对象一起使用，比如，String 实例。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">然而，对于这种可重新创建的键对象，键若丢弃，就自动移除 WeakHashMap 条目，这种表现令人疑惑。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">WeakHashMap 类的行为部分取决于垃圾回收器的动作，所以，几个常见的（虽然不是必需的）Map 常量不支持此类。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;"><span style="color:rgb(255,0,0);">因为垃圾回收器在任何时候都可能丢弃键，WeakHashMap 就像是一个被悄悄移除条目的未知线程。</span>特别地，即使对 WeakHashMap 实例进行同步，并且没有调用任何赋值方法，在一段时间后 ,size 方法也可能返回较小的值，对于 isEmpty 方法，可能返回 false，然后返回 true，对于给定的键，containsKey 方法可能返回 true 然后返回 false，对于给定的键，get 方法可能返回一个值，但接着返回 null，对于以前出现在映射中的键，put 方法返回 null，而 remove 方法返回 false，对于键集、值集、项集进行的检查，生成的元素数量越来越少。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">WeakHashMap 中的每个键对象间接地存储为一个弱引用的指示对象。因此，不管是在映射内还是在映射之外，只有在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">实现注意事项：WeakHashMap 中的值对象由普通的强引用保持。因此应该小心谨慎，确保值对象不会直接或间接地强引用其自身的键，因为这会阻止键的丢弃。注意，值对象可以通过 WeakHashMap 本身间接引用其对应的键；这就是说，某个值对象可能强引用某个其他的键对象，而与该键对象相关联的值对象转而强引用第一个值对象的键。处理此问题的一种方法是，在插入前将值自身包装在 WeakReferences 中，如：m.put(key, new WeakReference(value))，然后，分别用 get 进行解包。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;"><span style="color:rgb(255,0,0);"><strong>该类所有“collection 视图方法”返回的迭代器均是快速失败的</strong></span>：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的 remove 或 add 方法,其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常程序的方式是错误的。</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;"><strong>正确做法是：迭代器的快速失败行为应该仅用于检测 bug。<br></strong>注意1:&nbsp;&nbsp; null 值和 null 键都被支持。<br> 注意2：不是线程安全的。<br> 注意3：迭代器的快速失败行为不能得到保证。<br> 注意4：WeakHashMap是无序的。<br> 注意5:&nbsp;&nbsp; 确保值对象不会直接或间接地强引用其自身的键，</p> 
    <p style="line-height:24px;color:rgb(153,153,153);font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;font-size:15px;">因为这会阻止键的丢弃。但是，值对象可以通过 WeakHashMap 本身间接引用其对应的键；这就是说，某个值对象可能强引用某个其他的键对象，而与该键对象相关联的值对象转而强引用第一个值对象的键，这时就形成了环路。处理此问题的一种方法是，在插入前将值自身包装在WeakReferences中，如：m.put(key, new WeakReference(value))，然后，分别用 get 进行解包。</p> 
    <h2 style="color:rgb(177,177,177);font-size:21px;line-height:1.5;font-family:'Comic Sans MS', '微软雅黑', '宋体', Arial;">我是天王盖地虎的分割线</h2> 
    <h2 style="line-height:1.5;"><font color="#b1b1b1"><span style="font-size:21px;"><br></span></font></h2> 
    <h2 style="line-height:1.5;"><font color="#b1b1b1"><span style="font-size:21px;"><br></span></font></h2> 
    <h2 style="line-height:1.5;"><font color="#b1b1b1"><span style="font-size:21px;"><br></span></font></h2> 
    <h2 style="line-height:1.5;"><font color="#b1b1b1"><span style="font-size:21px;">本文转自我爱物联网博客园博客，原文链接：http://www.cnblogs.com/yydcdut/p/4473568.html，如需转载请自行联系原作者</span></font></h2> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
