<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>创新工场面试题 « NotBeCN</title>
  <meta name="description" content="             1，如何删除一个搜索二叉树的结点    解：    情况一：根节点    1&gt;无孩子：则放回空    2&gt;有一个孩子，则放回其孩子    3&gt;有两个孩子，则返回其左孩子，将右孩子作为左子树的最右边的结点的右孩子；或者返回右子树，将左子树作为右子树的最左结点的左孩子。  ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/06/26/weixin_33752045_90118550.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">创新工场面试题</h1>
    <p class="post-meta">Jun 26, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1 style="font-size:28px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;color:rgb(255,0,0);">1，如何删除一个搜索二叉树的结点</span></h1> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">解：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">情况一：根节点</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">1&gt;无孩子：则放回空</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">2&gt;有一个孩子，则放回其孩子</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">3&gt;有两个孩子，则返回其左孩子，将右孩子作为左子树的最右边的结点的右孩子；或者返回右子树，将左子树作为右子树的最左结点的左孩子。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">情况二：非根结点</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">1&gt;无孩子：直接删去</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">2&gt;一个孩子：则将孩子代替自己接入父节点。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">3&gt;两个孩子：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">方法一：如果本身是左孩子，则将左子树接入父节点，将右子树作为左子树最右结点的右孩子。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">如果本身是右孩子，则将右子树接入父节点，将左子树作为右子树最左结点的左孩子。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">方法二：用直接前驱或者后继来代替自己，再删除直接前驱或者后继。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">直接前驱为左子树的最右结点；</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">直接后继为右子树的最左结点。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <h1 style="font-size:28px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;"> <a name="t1"></a><span style="line-height:1.5;color:rgb(255,0,0);">2，如何找到一个数组中的两个数，他们的和为0</span> </h1> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">解：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">先将数组排序，再用两个指针，一个指向数组头，一个指向数组尾，</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">将指向内容相加，如果大于0，则右指针左移，</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">如果小于0，则左指针右移，如果等于0，则放回两个数。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <h1 style="font-size:28px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;"> <a name="t2"></a><span style="line-height:1.5;color:rgb(255,0,0);">3，如何判断两条二维平面上的线段是否相交</span> </h1> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">解：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">如果A,B在CD的同一侧，或者C,D在AB的同一侧，</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">则两线段不相交。否则相交。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">相关知识：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><span style="line-height:1.5;color:#FF0000;">二叉排序树的插入和删除：</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">与次优二叉树相对，二叉排序树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的节点时再进行插入。新插入的结点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">下面引自：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">二叉树：<a href="http://student.zjzk.cn/course_ware/data_structure/web/chazhao/chazhao9.3.1.1.htm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://student.zjzk.cn/course_ware/data_structure/web/chazhao/chazhao9.3.1.1.htm</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">1．二叉树重要性质：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><strong>性质1</strong>&nbsp;<span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">二叉树第</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">i</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">层上的结点数目最多为</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2<sup>i-1</sup>(i≥1)</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">。</span><br><em>证明</em>：用数学归纳法证明：<br> &nbsp;&nbsp;&nbsp; 归纳基础：i=1时，有2<sup>i-1</sup>=2<sup>0</sup>=1。因为第1层上只有一个根结点，所以命题成立。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　归纳假设：假设对所有的j(1≤j&lt;i)命题成立，即第j层上至多有2<sup>j-1</sup>个结点，证明j=i时命题亦成立。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　归纳步骤：根据归纳假设，第i-1层上至多有2<sup>i-2</sup>个结点。由于二叉树的每个结点至多有两个孩子，故第i层上的结点数至多是第i-1层上的最大结点数的2倍。即j=i时，该层上至多有2×2<sup>i-2</sup>=2<sup>i-1</sup>个结点，故命题成立。<br><br><strong>性质2</strong>&nbsp;<span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">深度为</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">k</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">的二叉树至多有</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2<sup>k</sup>-1</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">个结点</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">(k≥1)</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">。</span><br><em>证明</em>：在具有相同深度的二叉树中，仅当每一层都含有最大结点数时，其树中结点数最多。因此利用性质1可得，深度为k的二叉树的结点数至多为：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</span><sup>0</sup>+2<sup>1</sup>+…+2<sup>k-1</sup>=2<sup>k</sup>-1<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>故命题正确。<br><br><strong>性质3</strong>&nbsp;<span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">在任意</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">-</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">棵二叉树中，若终端结点的个数为</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">n<sub>0</sub></span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">，度为</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">的结点数为</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">n<sub>2</sub></span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">，则</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">n<sub>o</sub>=n<sub>2</sub>+1</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">。</span><br><em>证明</em>：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)应等于0度结点数、1度结点(记为n<sub>1</sub>)和2度结点数之和：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n=n</span><sub>o</sub>+n<sub>1</sub>+n<sub>2</sub>&nbsp;(式子1)<br> &nbsp;&nbsp;&nbsp; 另一方面，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n</span><sub>l</sub>+2n<sub>2</sub><br> 树中只有根结点不是任何结点的孩子，故二叉树中的结点总数又可表示为：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n=n</span><sub>1</sub>+2n<sub>2</sub>+1 (式子2)<br> 由式子1和式子2得到：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n</span><sub>o</sub>=n<sub>2</sub>+1</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><strong>满二叉树和完全二叉树是二叉树的两种特殊情形。</strong><br><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">1</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">、满二叉树</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">(FullBinaryTree)&nbsp;</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　一棵深度为k且有2<sup>k</sup>-1个结点的二又树称为满二叉树。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　满二叉树的特点：<br> （1） 每一层上的结点数都达到最大值。即对给定的高度，它是具有最多结点数的二叉树。<br> （2） 满二叉树中不存在度数为1的结点，每个分支结点均有两棵高度相同的子树，且树叶都在最下一层上。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">、完全二叉树</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">(CompleteBinaryTree)&nbsp;</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>若一棵二叉树至多只有最下面的两层上结点的度数可以小于2，并且最下一层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span><strong>特点：</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>（1） 满二叉树是完全二叉树，完全二叉树不一定是满二叉树。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>（2） 在满二叉树的最下一层上，从最右边开始连续删去若干结点后得到的二叉树仍然是一棵完全二叉树。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>（3） 在完全二叉树中，若某个结点没有左孩子，则它一定没有右孩子，即该结点必是叶结点。&nbsp;&nbsp;<br><strong>性质4&nbsp;</strong>&nbsp;具有n个结点的完全二叉树的深度为<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><strong>顺序存储结构<br></strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　该方法是把二叉树的所有结点按照一定的线性次序存储到一片连续的存储单元中。结点在这个序列中的相互位置还能反映出结点之间的逻辑关系。<br><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);"><br></span><strong>1．完全二叉树结点编号</strong><br><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">（</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">1</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">）</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">编号办法</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　在一棵n个结点的完全二叉树中，从树根起，自上层到下层，每层从左至右，给所有结点编号，能得到一个反映整个二叉树结构的线性序列。<br> 【例】如下图所示。&nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;</span><br><br><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">（</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">）</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">编号特点</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;</span>　 完全二叉树中除最下面一层外，各层都充满了结点。每一层的结点个数恰好是上一层结点个数的2倍。从一个结点的编号就可推得其双亲，左、右孩子，兄弟等结点的编号。假设编号为i的结点是k<sub>i</sub>(1≤i≤n)，则有：<br> ①若i&gt;1，则k<sub>i</sub>的双亲编号为&nbsp;&nbsp;；若i=1，则K<sub>i</sub>是根结点，无双亲。<br> ②若2i≤n，则K<sub>i</sub>的左孩子的编号是2i；否则，K<sub>i</sub>无左孩子，即K<sub>i</sub>必定是叶子。因此完全二叉树中编号&nbsp;&nbsp;的结点必定是叶结点。<br><br> ③若2i+1≤n，则K<sub>i</sub>的右孩子的编号是2i+1；否则，K<sub>i</sub>无右孩子。<br> ④若i为奇数且不为1，则K<sub>i</sub>的左兄弟的编号是i-1；否则，K<sub>i</sub>无左兄弟。<br> ⑤若i为偶数且小于n，则K<sub>i</sub>的右兄弟的编号是i+1；否则，K<sub>i</sub>无右兄弟。<br><br><strong><span style="line-height:1.5;background:rgb(235,235,235);">2</span>．完全二叉树的顺序存储</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　将完全二叉树中所有结点按编号顺序依次存储在一个向量bt[0..n]中。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>其中：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; bt[1</span>．．n]用来存储结点<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; bt[0]</span>不用或用来存储结点数目。<br> 【例】表6.1是图6.8所示的完全二叉树的顺序存储结构，bt[0]为结点数目，b[7]的双亲、左右孩子分别是bt[3]、bt[l4]和bt[15]。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span><br><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);"><br></span><strong>3．一般二叉树的顺序存储</strong><br><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">（</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">1</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">）</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">具体方法</span><br> ① 将一般二叉树添上一些 "虚结点"，成为"完全二叉树"<br> ② 为了用结点在向量中的相对位置来表示结点之间的逻辑关系，按完全二叉树形式给结点编号<br> ③ 将结点按编号存入向量对应分量，其中"虚结点"用"∮"表示<br><br> 【例】图6-9中单支树的顺序存储结构如下图<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);"><br></span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">（</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">）</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">优点和缺点</span><br> ① 对完全二叉树而言，顺序存储结构既简单又节省存储空间。<br> ② 一般的二叉树采用顺序存储结构时，虽然简单，但易造成存储空间的浪费。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>　　【例】最坏的情况下，一个深度为k且只有k个结点的右单支树需要2k-1个结点的存储空间。<br> ③在对顺序存储的二叉树做插入和删除结点操作时，要大量移动结点。<br><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);"><br></span><strong>链式存储结构<br> &nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">1</span>．结点的结构</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　二叉树的每个结点最多有两个孩子。用链接方式存储二叉树时，每个结点除了存储结点本身的数据外，还应设置两个指针域lchild和rchild，分别指向该结点的左孩子和右孩子。结点的结构为：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;color:#00FF00;background:rgb(235,235,235);">&nbsp;</span><br><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);"><br></span><strong>2．结点的类型说明</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; typedef char DataType</span>； //用户可根据具体应用定义DataType的实际类型&nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; typedef struct node{</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataType data</span>；&nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Struct node *lchild</span>，*rchild； //左右孩子指针<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }BinTNode</span>； //结点类型<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; typedef BinTNode *BinTree</span>；//BinTree为指向BinTNode类型结点的指针类型<br><br><strong><span style="line-height:1.5;background:rgb(235,235,235);">3</span>．二叉链表（二叉树的常用链式存储结构）</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　在一棵二叉树中，所有类型为BinTNode的结点，再加上一个指向开始结点(即根结点)的BinTree型头指针(即根指针)root，就构成了二叉树的链式存储结构，并将其称为二叉链表。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>【例】下面左图所示二叉树的二叉链表如下面中图所示。&nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);">注意：</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　① 一个二叉链表由根指针root惟一确定。若二叉树为空，则root=NULL；若结点的某个孩子不存在，则相应的指针为空。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　② 具有n个结点的二叉链表中，共有2n个指针域。其中只有n-1个用来指示结点的左、右孩子，其余的n+1个指针域为空。<br><br><strong><span style="line-height:1.5;background:rgb(235,235,235);">4</span>．带双亲指针的二叉链表</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　经常要在二叉树中寻找某结点的双亲时，可在每个结点上再加一个指向其双亲的指针parent，形成一个带双亲指针的二叉链表。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span>【例】上面右图是上面左图所示的二叉树的带双亲指针的二叉链表。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:rgb(235,235,235);">当用线性表作为表的组织形式时，可以有三种查找法。其中以二分查找效率最高。但由于二分查 找要求表中结点按关键字有序，且不能用链表作存储结构，因此，当表的插入或删除操作频繁时，为维护表的有序性，势必要移动表中很多结点。这种由移动结点引 起的额外时间开销，就会抵消二分查找的优点。也就是说，二分查找只适用于静态查找表。若要对动态查找表进行高效率的查找，可采用下面介绍的几种特殊的二叉 树或树作为表的组织形式。不妨将它们统称为树表。下面将分别讨论在这些树表上进行查找和修改操作的方法。<br><span style="line-height:1.5;color:#008000;"><br></span><strong>二叉排序树<br><br> 1、二叉排序树的定义</strong>&nbsp;<span style="line-height:1.5;color:#FF0000;"><br></span>二叉排序树(Binary SortTree)又称二叉查找(搜索)树(Binary SearchTree)。其定义为：二叉排序树或者是空树，或者是满足如下性质的二叉树：<br> ①若它的左子树非空，则左子树上所有结点的值均小于根结点的值；<br> ②若它的右子树非空，则右子树上所有结点的值均大于根结点的值；<br> ③左、右子树本身又各是一棵二叉排序树。<br> 上述性质简称二叉排序树性质(BST性质)，故二叉排序树实际上是满足BST性质的二叉树。<br><span style="line-height:1.5;color:#FF0000;"><br></span><strong>2、二叉排序树的特点</strong><br> 由BST性质可得：<br> （1） 二叉排序树中任一结点x，其左(右)子树中任一结点y(若存在)的关键字必小(大)于x的关键字。<br> （2） 二叉排序树中，各结点关键字是惟一的。<br> &nbsp;&nbsp;<span style="line-height:1.5;color:#FF0000;">注意：</span><br> 实际应用中，不能保证被查找的数据集中各元素的关键字互不相同，所以可将二叉排序树定义中BST性质(1)里的"小于"改为"大于等于"，或将BST性质(2)里的"大于"改为"小于等于"，甚至可同时修改这两个性质。<br> （3） 按中序遍历该树所得到的中序序列是一个递增有序序列。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:rgb(235,235,235);"><strong>3、二叉排序树的存储结构</strong><br> typedef int KeyType； //假定关键字类型为整数<br> typedef struct node { //结点类型<br> &nbsp; KeyType key； //关键字项<br> &nbsp; InfoType otherinfo； //其它数据域，InfoType视应用情况而定，下面不处理它<br> &nbsp; struct node *lchild，*rchild； //左右孩子指针<br> } BSTNode；<br> typedef BSTNode *BSTree； //BSTree是二叉排序树的类型</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:rgb(235,235,235);"><strong>4、二叉排序树上的运算</strong><br><span style="line-height:1.5;color:#0000FF;">（</span><span style="line-height:1.5;color:#0000FF;">1</span><span style="line-height:1.5;color:#0000FF;">）</span><span style="line-height:1.5;color:#0000FF;">二叉排序树的插入和生成</span><br><strong>①二叉排序树插入新结点的过程</strong><br> 在二叉排序树中插入新结点，要保证插入后仍满足BST性质。其插入过程是：<br> (a)若二叉排序树T为空，则为待插入的关键字key申请一个新结点，并令其为根；<br> (b)若二叉排序树T不为空，则将key和根的关键字比较：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　(i)若二者相等，则说明树中已有此关键字key，无须插入。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　(ii)若key&lt;T→key，则将key插入根的左子树中。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　(iii)若key&gt;T→key，则将它插入根的右子树中。<br> 子树中的插入过程与上述的树中插入过程相同。如此进行下去，直到将key作为一个新的叶结点的关键字插入到二叉排序树中，或者直到发现树中已有此关键字为止。<br><br> &nbsp;<span style="line-height:1.5;color:#FF00FF;">&nbsp;</span><strong>②二叉排序树插入新结点的递归算法</strong><span style="line-height:1.5;color:#FF00FF;">&nbsp;</span><span style="line-height:1.5;color:#FF00FF;"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>【参见参考书目】<br><br> &nbsp;&nbsp;<strong>③二叉排序树插入新结点的非递归算法</strong><br> &nbsp;&nbsp;&nbsp; void InsertBST(BSTree *Tptr，KeyTypekey)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { //若二叉排序树*Tptr中没有关键字为key，则插入，否则直接返回<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BSTNode *f，*p=*TPtr； //p的初值指向根结点<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(p){ //查找插入位置<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(p-&gt;key==key)return；//树中已有key，无须插入<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f=p； //f保存当前查找的结点<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p=(key&lt;p-&gt;key)?p-&gt;lchild：p-&gt;rchild；<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //若key&lt;p-&gt;key，则在左子树中查找，否则在右子树中查找<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } //endwhile<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p=(BSTNode *)malloc(sizeof(BSTNode))；<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;key=key； p-&gt;lchild=p-&gt;rchild=NULL； //生成新结点<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(*TPtr==NULL) //原树为空<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Tptr=p； //新插入的结点为新的根<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else //原树非空时将新结点关p作为关f的左孩子或右孩子插入<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(key&lt;f-&gt;key)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f-&gt;lchild=p；<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else f-&gt;rchild=p；<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } //InsertBST<br><br><strong>④二叉排序树的生成</strong><br> 二叉排序树的生成，是从空的二叉排序树开始，每输入一个结点数据，就调用一次插入算法将它插入到当前已生成的二叉排序树中。生成二叉排序树的算法如下：<br> &nbsp; BSTree CreateBST(void)<br> &nbsp;&nbsp; { //输入一个结点序列，建立一棵二叉排序树，将根结点指针返回<br> &nbsp;&nbsp;&nbsp; BSTree T=NULL； //初始时T为空树<br> &nbsp;&nbsp;&nbsp; KeyType key；<br> &nbsp;&nbsp;&nbsp; scanf("％d"，&amp;key)； //读人一个关键字<br> &nbsp;&nbsp;&nbsp; while(key){ //假设key=0是输人结束标志<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InsertBST(&amp;T，key)； //将key插入二叉排序树T<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("％d"，&amp;key)；//读人下一关键字<br> &nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; return T； //返回建立的二叉排序树的根指针<br> &nbsp;&nbsp; } //BSTree<br><br><strong>⑤二叉排序树的生成过程</strong><br> 由输入实例(5，3，7，2，4，8)，根据生成二叉排序树算法生成二叉排序树的过程【<a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchapaixushengcheng.htm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><span style="line-height:1.5;color:rgb(0,0,153);">参见动画演示</span></a>】<br> &nbsp;&nbsp;<span style="line-height:1.5;color:#FF0000;">注意：</span><br> 输入序列决定了二叉排序树的形态。<br> 二叉排序树的中序序列是一个有序序列。所以对于一个任意的关键字序列构造一棵二叉排序树，其实质是对此关键字序列进行排序，使其变为有序序列。"排序 树"的名称也由此而来。通常将这种排序称为树排序(TreeSort)，可以证明这种排序的平均执行时间亦为O(nlgn)。<br> 对相同的输入实例，树排序的执行时间约为堆排序的2至3倍。因此在一般情况下，构造二叉排序树的目的并非为了排序，而是用它来加速查找，这是因为在一个有序的集合上查找通常比在无序集合上查找更快。因此，人们又常常将二叉排序树称为二叉查找树。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">（</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">2</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">）二叉排序树的删除</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　从二叉排序树中删除一个结点，不能把以该结点为根的子树都删去，并且还要保证删除后所得的二叉树仍然满足BST性质。<br><strong><span style="line-height:1.5;background:rgb(235,235,235);"><br></span>①删除操作的一般步骤</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">(1)&nbsp;</span>进行查找<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　查找时，令p指向当前访问到的结点，parent指向其双亲(其初值为NULL)。若树中找不到被删结点则返回，否则被删结点是*p。<br><span style="line-height:1.5;background:rgb(235,235,235);">(2)&nbsp;</span>删去*p。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　删*p时，应将*p的子树(若有)仍连接在树上且保持BST性质不变。按*p的孩子数目分三种情况进行处理。<br><br><strong>②删除*p结点的三种情况</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">(1)*p</span>是叶子(即它的孩子数为0)<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　无须连接*p的子树，只需将*p的双亲*parent中指向*p的指针域置空即可。<br><br><span style="line-height:1.5;background:rgb(235,235,235);">(2)*p</span>只有一个孩子*child<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　只需将*child和*p的双亲直接连接后，即可删去*p。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);">注意：</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　*p既可能是*parent的左孩子也可能是其右孩子，而*child可能是*p的左孩子或右孩子，故共有4种状态，具体【<a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchapaixushanchu.htm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><span style="line-height:1.5;color:rgb(0,0,153);background:rgb(235,235,235);">参见动画演示</span></a>】。<br><br><span style="line-height:1.5;background:rgb(235,235,235);">(3)*p</span>有两个孩子<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　先令q=p，将被删结点的地址保存在q中；然后找*q的中 序后继*p，并在查找过程中仍用parent记住*p的双亲位置。*q的中序后继*p一定是*q的右子树中最左下的结点，它无左子树。因此，可以将删 去*q的操作转换为删去的*p的操作，即在释放结点*p之前将其数据复制到*q中，就相当于删去了*q。具体【<a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchapaixushanchu.htm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><span style="line-height:1.5;color:rgb(0,0,153);background:rgb(235,235,235);">参见动画演示</span></a>】。<br><br><strong>③二叉排序树删除算法</strong>&nbsp;<span style="line-height:1.5;color:#FF00FF;background:rgb(235,235,235);"><br></span>分析：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　上述三种情况都能统一到情况(2)，算法中只需针对情况(2)处理即可。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　注意边界条件：若parent为空，被删结点*p是根，故删去*p后，应将child置为根。<br> 算法：&nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">void DelBSTNode(BSTree *Tptr</span>，KeyType key)<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;{//</span>在二叉排序树*Tptr中删去关键字为key的结点<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; BSTNode *parent=NUll</span>，*p=*Tptr，*q，*child；<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; while(p){ //</span>从根开始查找关键字为key的待删结点<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; if(p-&gt;key==key) break</span>；//已找到，跳出查找循环<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; parent=p</span>； //parent指向*p的双亲<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;p=(key&lt;p-&gt;key)?p-&gt;lchild</span>：p-&gt;rchild； //在关p的左或右子树中继续找<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp; }</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; if(!p) return</span>； //找不到被删结点则返回<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; q=p</span>； //q记住被删结点*p<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; if(q-&gt;lchild&amp;&amp;q-&gt;rchild)//*q</span>的两个孩子均非空，故找*q的中序后继*p<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; for(parent=q</span>，p=q-&gt;rchild； p-&gt;lchild； parent=p，p=p=-&gt;lchild)；<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; //</span>现在情况(3)已被转换为情况(2)，而情况(1)相当于是情况(2)中child=NULL的状况<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;child=(p-&gt;lchild)?p-&gt;lchild</span>：p-&gt;rchild；//若是情况(2)，则child非空；否则child为空<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; if(!parent) //*p</span>的双亲为空，说明*p为根，删*p后应修改根指针<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Tptr=child</span>； //若是情况(1)，则删去*p后，树为空；否则child变为根<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; else{ //*p</span>不是根，将*p的孩子和*p的双亲进行连接，*p从树上被摘下<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(p==parent-&gt;lchild) //*p</span>是双亲的左孩子<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent-&gt;lchild=child</span>； //*child作为*parent的左孩子<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elseparent-&gt;rchild=child</span>； //*child作为 parent的右孩子<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(p!=q) //</span>是情况(3)，需将*p的数据复制到*q<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q-&gt;key=p-&gt;key</span>； //若还有其它数据域亦需复制<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp; } //endif</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; free(p)</span>； /释放*p占用的空间<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; } //DelBSTNode</span><br><br> 二叉排序树的删除运算实例具体参见【<a href="http://student.zjzk.cn/course_ware/data_structure/web/flashhtml/erchapaixushanchu.htm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><span style="line-height:1.5;color:rgb(0,0,153);background:rgb(235,235,235);">动画演示</span></a>】</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">（</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">3</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">）</span><span style="line-height:1.5;color:#0000FF;background:rgb(235,235,235);">二叉排序树上的查找</span><br><strong>①查找递归算法</strong><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　在二叉排序树上进行查找，和二分查找类似，也是一个逐步缩小查找范围的过程。<br> 递归的查找算法：<br><span style="line-height:1.5;background:rgb(235,235,235);">BSTNode *SearchBST(BSTree T</span>，KeyType key)<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp; { //</span>在二叉排序树T上查找关键字为key的结点，成功时返回该结点位置，否则返回NUll<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; if(T==NULL||key==T-&gt;key)//</span>递归的终结条件<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return T</span>； //T为空，查找失败；否则成功，返回找到的结点位置<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; if(key&lt;T-&gt;key)</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnSearchBST(T-&gt;lchild</span>，key)；<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp; else</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnSearchBST(T-&gt;rchild</span>，key)；//继续在右子树中查找<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp; } //SearchBST</span><br><br><strong>②算法分析</strong><br> &nbsp;&nbsp;&nbsp; 在二叉排序树上进行查找时，若查找成功，则是从根结点出发走了一条从根到待查结点的路径。若查找不成功，则是从根结点出发走了一条从根到某个叶子的路径。<br><br><span style="line-height:1.5;background:rgb(235,235,235);">(1)&nbsp;</span>二叉排序树查找成功的平均查找长度<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　在等概率假设下，下面(a)图中二叉排序树查找成功的平均查找长度为<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　在等概率假设下，(b)图所示的树在查找成功时的平均查找长度为：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASL</span><sub>b</sub>=(1+2+3+4+5+6+7+8+9+10)/10=5.5<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;</span><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);">注意：</span><br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　与二分查找类似，和关键字比较的次数不超过树的深度。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">(2)在二叉排序树上进行查找时的平均查找长度和二叉树的形态有关<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　二分查找法查找长度为n的有序表，其判定树是惟一的。含有n个结点的二叉排序树却不惟一。对于含有同样一组结点的表，由于结点插入的先后次序不同，所构成的二叉排序树的形态和深度也可能不同<br> 【例】下图(a)所示的树，是按如下插入次序构成的：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45</span>，24，55，12，37，53，60，28，40，70<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>下图(b)所示的树，是按如下插入次序构成的：<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12</span>，24，28，37，40，45，53，55，60，70</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;&nbsp;&nbsp; 　在二叉排序树上进行查找时的平均查找长度和二叉树的形态有关：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br> ①在最坏情况下，二叉排序树是通过把一个有序表的n个结点依次插入而生成的，此时所得的二叉排序树蜕化为棵深度为n的单支树，它的平均查找长度和单链表上的顺序查找相同，亦是(n+1)/2。<br> ②在最好情况下，二叉排序树在生成的过程中，树的形态比较匀称，最终得到的是一棵形态与二分查找的判定树相似的二叉排序树，此时它的平均查找长度大约是lgn。<br> ③插入、删除和查找算法的时间复杂度均为O(lgn)。<br><br><span style="line-height:1.5;background:rgb(235,235,235);">(3)</span>二叉排序树和二分查找的比较<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　就平均时间性能而言，二叉排序树上的查找和二分查找差不多。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　就维护表的有序性而言，二叉排序树无须移动结点，只需修改 指针即可完成插入和删除操作，且其平均的执行时间均为O(lgn)，因此更有效。二分查找所涉及的有序表是一个向量，若有插入和删除结点的操作，则维护表 的有序性所花的代价是O(n)。当有序表是静态查找表时，宜用向量作为其存储结构，而采用二分查找实现其查找操作；若有序表里动态查找表，则应选择二叉排 序树作为其存储结构。<br><br><span style="line-height:1.5;background:rgb(235,235,235);">(4)</span>平衡二叉树<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　为了保证二叉排序树的高度为lgn，从而保证然二叉排序树 上实现的插入、删除和查找等基本操作的平均时间为O(lgn)，在往树中插入或删除结点时，要调整树的形态来保持树的"平衡。使之既保持BST性质不变又 保证树的高度在任何情况下均为O(lgn)，从而确保树上的基本操作在最坏情况下的时间均为O(lgn)。<br><span style="line-height:1.5;color:#FF0000;background:rgb(235,235,235);">注意：</span><br> &nbsp;&nbsp;&nbsp; ①平衡二叉树(Balanced Binary Tree)是指树中任一结点的左右子树的高度大致相同。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　②任一结点的左右子树的高度均相同(如满二叉树)，则二叉树是完全平衡的。通常，只要二叉树的高度为O(1gn)，就可看作是平衡的。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　③平衡的二叉排序树指满足BST性质的平衡二叉树。<br><span style="line-height:1.5;background:rgb(235,235,235);">&nbsp;&nbsp;&nbsp;&nbsp;</span>　④AVL树中任一结点的左、右子树的高度之差的绝对值不超过1。在最坏情况下，n个结点的AVL树的高度约为1.44lgn。而完全平衡的二叉树度高约为lgn，AVL树是接近最优的。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;">转自：<a href="http://blog.csdn.net/huangxy10/article/details/8082502" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://blog.csdn.net/huangxy10/article/details/8082502</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;background:#FFFFFF;"><br></p> 
   <p style="line-height:1.5;background:#FFFFFF;"><font color="#4b4b4b"><span style="font-size:13px;">本文转自夏雪冬日博客园博客，原文链接：http://www.cnblogs.com/heyonggang/archive/2012/12/13/2817041.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
