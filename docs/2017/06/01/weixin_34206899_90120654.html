<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[web] Get和Post区别,EncType提交数据的格式详解 « NotBeCN</title>
  <meta name="description" content="                  转载自：http://www.cnblogs.com/sunxucool/archive/2012/12/11/2813113.html     1. get是从服务器上获取数据，post是向服务器传送数据。     2. get是把参数数据队列加到提交表单的ACTION属性所...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/06/01/weixin_34206899_90120654.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">[web] Get和Post区别,EncType提交数据的格式详解</h1>
    <p class="post-meta">Jun 1, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(73,73,73);font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:22.4px;"> 
    <p>转载自：<a href="http://www.cnblogs.com/sunxucool/archive/2012/12/11/2813113.html" rel="nofollow" style="color:rgb(73,73,73);line-height:normal;">http://www.cnblogs.com/sunxucool/archive/2012/12/11/2813113.html</a></p> 
    <p>1. get是从服务器上获取数据，post是向服务器传送数据。</p> 
    <p>2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</p> 
    <div>
     3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     4. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     5. get安全性非常低，post安全性较高。
    </div> 
    <div>
     &nbsp;----------------------------------------------
    </div> 
    <div>
     在Form元素的语法中，EncType表明提交数据的格式&nbsp;
    </div> 
    <div>
     用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。&nbsp;
    </div> 
    <div>
     下边是说明：&nbsp;
    </div> 
    <div>
     application/x-www-form-urlencoded： 窗体数据被编码为名称/值对。这是标准的编码格式。&nbsp;
    </div> 
    <div>
     multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。&nbsp;
    </div> 
    <div>
     text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     补充
    </div> 
    <div>
     form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded。&nbsp;
    </div> 
    <div>
     当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2...），然后把这个字串append到url后面，用?分割，加载这个新的url。&nbsp;
    </div> 
    <div>
     当action为post时候，浏览器把form数据封装到http body中，然后发送到server。&nbsp;
    </div> 
    <div>
     如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。&nbsp;
    </div> 
    <div>
     但是如果有type=file的话，就要用到multipart/form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件name)等信息，并加上分割符
    </div> 
    <div>
     &nbsp;
    </div> 
    <div> 
     <h3 style="font-size:16px;line-height:1.5;">在Form元素的语法中，EncType表明提交数据的格式 用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。 下边是说明： application/x-www-form-urlencoded： 窗体数据被编码为名称/值对。这是标准的编码格式。 multipart/form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。 text/plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。<br> &nbsp;补充<br> form的enctype属性为编码方式，常用有两 种：application/x-www-form-urlencoded和multipart/form-data，默认为application /x-www-form-urlencoded。 当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1=value1&amp; amp;name2=value2...），然后把这个字串append到url后面，用?分割，加载这个新的url。 当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有type=file的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有type=file的话，就要用到multipart/form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上 Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件 name)等信息，并加上分割符(boundary)。</h3> 
     <p>&nbsp;</p> 
     <div class="BlogContent"> 
      <p>GET和POST区别详解</p> 
      <p>1、Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据。&nbsp;<br> 2、Get将表单中数据的按照variable=value的形式，添加到action所指向的URL后面，并且两者使用“?”连接，而各个变量之间使用 “&amp;”连接；Post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指向URL。&nbsp;<br> 3、Get是不安全的，因为在传输过程，数据被放在请求的URL中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中， 然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面 前。Post的所有操作对用户来说都是不可见的。&nbsp;<br> 4、Get传输的数据量小，这主要是因为受URL长度限制；而Post可以传输大量的数据，所以在上传文件只能使用Post（当然还有一个原因，将在后面的提到）。&nbsp;<br> 5、Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。默认是用ISO-8859-1编码&nbsp;<br> 6、Get是Form的默认方法。</p> 
      <p>以下的比较非常非常使用：</p> 
      <p>做java的web开发有段日子了，有个问题老是困扰着我，就是乱码问题，基本上是网上查找解决方案（网上资料真的很多），都是一大堆的介绍如何解 决此类的乱码问题，但是没几个把问题的来龙去脉说清楚的，有时候看了些文章后，以为自己懂了，但是在开发中乱码问题又像鬼魂一样出来吓人，真是头大了！这 篇文章是我长时间和乱码做斗争的一些理解的积累，还希望有更多的朋友给出指点和补充。&nbsp;<br> &nbsp; form有2中方法把数据提交给服务器，get和post,分别说下吧。&nbsp;<br> （一）get提交&nbsp;<br> &nbsp; 1.首先说下客户端（浏览器）的form表单用get方法是如何将数据编码后提交给服务器端的吧。&nbsp;<br> &nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 对于get方法来说，都是把数据串联在请求的url后面作为参数，如：<a href="http://localhost:8080/servlet?msg=abc" rel="nofollow" style="color:rgb(73,73,73);line-height:normal;">http://localhost:8080/servlet?msg=abc</a>&nbsp;<br> （很常见的一个乱码问题就要出现了，如果url中出现中文或其它特殊字符的话，如：<a href="http://localhost:8080/" rel="nofollow" style="color:rgb(73,73,73);line-height:normal;">http://localhost:8080</a>&nbsp;/servlet?msg=杭州，服务器端容易得到乱码），url拼接完成后，浏览器会对url进行URL encode，然后发送给服务器，URL encode的过程就是把部分url做为字符，按照某种编码方式（如：utf-8,gbk等）编码成二进制的字节码，然后每个字节用一个包含3个字符的字 符串 "%xy" 表示，其中xy为该字节的两位十六进制表示形式。我这里说的可能不清楚，具体介绍可以看下java.net.URLEncoder类的介绍在这里。了解了 URL encode的过程，我们能看到2个很重要的问题，第一：需要URL encode的字符一般都是非ASCII的字符（笼统的讲），再通俗的讲就是除了英文字母以外的文字（如：中文，日文等）都要进行URL encode，所以对于我们来说，都是英文字母的url不会出现服务器得到乱码问题，出现乱码都是url里面带了中文或特殊字符造成的；第二：URL encode到底按照那种编码方式对字符编码？这里就是浏览器的事情了，而且不同的浏览器有不同的做法，中文版的浏览器一般会默认的使用GBK，通过设置 浏览器也可以使用UTF-8，可能不同的用户就有不同的浏览器设置，也就造成不同的编码方式，所以很多网站的做法都是先把url里面的中文或特殊字符用 javascript做URL encode，然后再拼接url提交数据，也就是替浏览器做了URL encode，好处就是网站可以统一get方法提交数据的编码方式。 完成了URL encode，那么现在的url就成了ASCII范围内的字符了，然后以iso-8859-1的编码方式转换成二进制随着请求头一起发送出去。这里想多说 几句的是，对于get方法来说，没有请求实体，含有数据的url都在请求头里面，之所以用URL encode，我个人觉的原因是：对于请求头来说最终都是要用iso-8859-1编码方式编码成二进制的101010.....的纯数据在互联网上传 送，如果直接将含有中文等特殊字符做iso-8859-1编码会丢失信息，所以先做URL encode是有必要的。&nbsp;<br> &nbsp;&nbsp; 2。服务器端（tomcat）是如何将数据获取到进行解码的。&nbsp;<br> &nbsp;&nbsp; 第一步是先把数据用iso-8859-1进行解码，对于get方法来说，tomcat获取数据的是ASCII范围内的请求头字符，其中的请求url里面带 有参数数据，如果参数中有中文等特殊字符，那么目前还是URL encode后的%XY状态，先停下，我们先说下开发人员一般获取数据的过程。通常大家都是request.getParameter("name")获 取参数数据，我们在request对象或得的数据都是经过解码过的，而解码过程中程序里是无法指定，这里要说下，有很多新手说用 request.setCharacterEncoding("字符集")可以指定解码方式，其实是不可以的，看servlet的官方API说明有对此方 法的解释：Overrides the name of the character encoding used in the body of this request. This method must be called prior to reading request parameters or reading input using getReader().可以看出对于get方法他是无能为力的。那么到底用什么编码方式解码数据的呢，这是tomcat的事情了，默认缺省用的是 iso-8859-1,这样我们就能找到为什么get请求带中文参数为什么在服务器端得到乱码了，原因是在客户端一般都是用UTF-8或GBK对数据 URL encode，这里用iso-8859-1方式URL decoder显然不行，在程序里我们可以直接&nbsp;<br> Java代码</p> 
      <p>&nbsp;&nbsp; 1. new String(request.getParameter("name").getBytes("iso-8859-1"),"客户端指定的URL encode编码方式")&nbsp;</p> 
      <p><br> 还原回字节码，然后用正确的方式解码数据，网上的文章通常是在tomcat里面做个配置&nbsp;<br> Xml代码</p> 
      <p>&nbsp;&nbsp; 1. &lt;Connector port="8080" protocol="HTTP/1.1" maxThreads="150" connectionTimeout="20000" redirectPort="8443" URIEncoding="GBK"/&gt;&nbsp;</p> 
      <p><br> 这样是让tomcat在获取数据后用指定的方式URL decoder，URL decoder的介绍在这里</p> 
      <p><br> （一）post提交&nbsp;<br> 1.客户端（浏览器）的form表单用post方法是如何将数据编码后提交给服务器端的。&nbsp;<br> &nbsp; 在post方法里所要传送的数据也要URL encode，那么他是用什么编码方式的呢？&nbsp;<br> &nbsp;&nbsp; 在form所在的html文件里如果有段&lt;meta http-equiv="Content-Type" content="text/html; charset=字符集（GBK，utf-8等）"/&gt;，那么post就会用此处指定的编码方式编码。一般大家都认为这段代码是为了让浏览器知道用 什么字符集来对网页解释，所以网站都会把它放在html代码的最前端，尽量不出现乱码，其实它还有个作用就是指定form表单的post方法提交数据的 URL encode编码方式。从这里可以看出对于get方法来数，浏览器对数据的URL encode的编码方式是有浏览器设置来决定，（可以用js做统一指定），而post方法，开发人员可以指定。&nbsp;<br> 2。服务器端（tomcat）是如何将数据获取到进行解码的。&nbsp;<br> 如果用tomcat默认缺省设置，也没做过滤器等编码设置，那么他也是用iso-8859-1解码的，但是request.setCharacterEncoding("字符集")可以派上用场。</p> 
      <p>我发现上面说的tomcat所做的事情前提都是在请求头里没有指定编码方式，如果请求头里指定了编码方式将按照这种方式编码。&nbsp;<br> &nbsp;&nbsp; 有2篇文章推荐下，地址分别是&nbsp;<br> 深入浅出URL编码：<a href="http://www.cnblogs.com/yencain/articles/1321386.html" rel="nofollow" style="color:rgb(73,73,73);line-height:normal;">http://www.cnblogs.com/yencain/articles/1321386.html</a>；&nbsp;<br> 表单用post方法提交数据时乱码问题：<a href="http://wanghuan8086.javaeye.com/blog/173869" rel="nofollow" style="color:rgb(73,73,73);line-height:normal;">http://wanghuan8086.javaeye.com/blog/173869</a></p> 
      <p>用post很重要的在form所在的html文件里如果有段&lt;meta http-equiv="Content-Type" content="text/html; charset=字符集（GBK，utf-8等）"/&gt;&nbsp;<br> 强烈建议使用post提交&nbsp;<br> ////////////////////////////////////////////////////////////////////////////////////////////////////<br> /////////////////////////////////////////////////////////////////////////////////////////////////////////<br> GET和POST两种方法都是将数据送到服务器，但你该用哪一种呢？&nbsp;<br> HTTP标准包含这两种方法是为了达到不同的目的。POST用于创建资源，资源的内容会被编入HTTP请示的内容中。例如，处理订货表单、在数据库中加入新数据行等。&nbsp;<br> 当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如在数据库添加数据行），则用POST方法。一个比较实际的问题是：GET方法可能会产生很长的URL，或许会超过某些浏览器与服务器对URL长度的限制。&nbsp;<br> 若符合下列任一情况，则用POST方法：</p> 
      <p>请求的结果有持续性的副作用，例如，数据库内添加新的数据行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> 若使用GET方法，则表单上收集的数据可能让URL过长。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> 要传送的数据不是采用7位的ASCII编码。</p> 
      <p>&nbsp;&nbsp;&nbsp;&nbsp; 若符合下列任一情况，则用GET方法：&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> 请求是为了查找资源，HTML表单数据仅用来帮助搜索。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> 请求结果无持续性的副作用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。</p> 
      <p>表单提交中Get和Post方式的区别<br> 1. get是从服务器上获取数据，post是向服务器传送数据。</p> 
      <p>　　2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到，因此安全性不高。post是通 过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程，安全性比较高。</p> 
      <p>　　3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</p> 
      <p>　　4. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</p> 
      <p>　　5. get安全性非常低，post安全性较高。</p> 
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6. post 页面不能被加入收藏夹中，get页面可以被加入。</p> 
      <p>ContentType和Form中enctype属性的相对应，它是Form用来组织数据的方式，主要包含了两种：<br> 1、application/x-www-form-urlencoded：它是默认内容类型（content type），在结果中我们已经看到了经它编码的数据的效果。编码方法：i.将空格使用“+”代替，非字母和数字字符，是用以%HH表示的该字符的 ASCII代替（汉字就是这种形式）；ii.变量和值使用“=”，各个变量和值对之间使用“&amp;”连接。<br> 2、multipart/form-data：它可以用来传输大量二进制数据或者非ASCII字符的文本，因此在上传文件需设置 enctype="multipart/form-data"，此时method必须为post。它传输的消息包含了一系列的数据块，每一块都代表 Form中的一个变量，并且数据块的顺序和页面上的顺序一致，块与块之间使用特殊字符（boundary）分隔。如果Form中包含file控件，相应的 数据块还会包含一个Content-Type头，用来指定MIME，默认值为text/plain。下面是设置enctype="multipart /form-data"时content的结果：</p> 
     </div> 
    </div> 
    <p>&nbsp;</p> 
   </div> 
   <div class="clear" style="clear:both;color:rgb(73,73,73);font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:22.4px;"></div> 
   <div> 
    <div style="color:rgb(73,73,73);font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:22.4px;">
     分类:&nbsp;
     <a href="http://www.cnblogs.com/0616--ataozhijia/category/643966.html" rel="nofollow" style="color:rgb(73,73,73);line-height:normal;">web</a> 
    </div> 
    <div style="color:rgb(73,73,73);font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:22.4px;">
     本文转自demoblog博客园博客，原文链接http://www.cnblogs.com/0616--ataozhijia/p/4283177.html如需转载请自行联系原作者
    </div> 
    <div style="color:rgb(73,73,73);font-family:Arial, Helvetica, sans-serif;font-size:14px;line-height:22.4px;">
     <br>
    </div> 
    <div> 
     <font color="#494949"><span style="font-size:14px;line-height:22.4px;">demoblog</span></font>
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
