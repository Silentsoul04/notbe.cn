<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>超全！iOS 面试题汇总 « NotBeCN</title>
  <meta name="description" content="                       2015-10-20&nbsp;CocoaChina               作者：Job_Yang      &nbsp;      之前看了很多面试题，感觉要不是不够就是过于冗余，于是我将网上的一些面试题进行了删减和重排，现在分享给大家。（题目来源于网络，侵删...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/05/28/weixin_33738982_90127889.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">超全！iOS 面试题汇总</h1>
    <p class="post-meta">May 28, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div>
     <span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;"><span style="line-height:1.8;">2015-10-20&nbsp;<a id="post-user" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"></a>CocoaChina</span></span>
    </div> 
    <div> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">作者：<a href="http://www.jianshu.com/users/cf7e85326534" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Job_Yang</a><br></span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">之前看了很多面试题，感觉要不是不够就是过于冗余，于是我将网上的一些面试题进行了删减和重排，现在分享给大家。（题目来源于网络，侵删）</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答： Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</span></p> 
     <p>&nbsp;</p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2. #import 跟#include 又什么区别，@class呢, #import&lt;&gt; 跟 #import””又什么区别?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字,使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once;@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含;#import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</span></p> 
     <p>&nbsp;</p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3. 属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1). readwrite 是可读可写特性;需要生成getter方法和setter方法时</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2). readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3). assign 是赋值特性，setter方法将传入参数赋值给实例变量;仅设置变量时;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">4). retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">5). copy 表示赋值特性，setter方法将传入对象复制一份;需要完全一份新的变量时。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">6).nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">4.写一个setter方法用于完成@property (nonatomic,retain)NSString *name,写一个setter方法用于完成@property(nonatomic，copy)NSString *name</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">- (void) setName:(NSString*) str</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">{</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[str retain];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[name release];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">name = str;</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">}</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">- (void)setName:(NSString *)str</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">{</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">id t = [str copy];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[name release];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">name = t;</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">}</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">5.对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答： 编译时是NSString的类型;运行时是NSData类型的对象</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">6.常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别?如：NSInteger和int</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：object-c的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">7.id 声明的对象有什么特性?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：Id 声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">8.Objective-C如何对内存管理的,说说你的看法和解决方法?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1). (Garbage Collection)自动内存计数：这种方式和java类似，在你的程序的执行过程中。始终有一个高人在背后准确地帮你收拾垃圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以iPhone不支持这个功能。所以“Garbage Collection”不是本入门指南的范围，对“Garbage Collection”内部机制感兴趣的同学可以参考一些其他的资料，不过说老实话“Garbage Collection”不大适合适初学者研究。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">解决: 通过alloc – initial方式创建的, 创建后引用计数+1, 此后每retain一次引用计数+1, 那么在程序中做相应次数的release就好了.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2). (Reference Counted)手动内存计数：就是说，从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为0的时候，那么就是释放这段内存的时候。比如说，当在程序A里面一段内存被成功申请完成之后，那么这个计数器就从0变成1(我们把这个过程叫做alloc)，然后程序B也需要使用这个内存，那么计数器就从1变成了2(我们把这个过程叫做retain)。紧接着程序A不再需要这段内存了，那么程序A就把这个计数器减1(我们把这个过程叫做release);程序B也不再需要这段内存的时候，那么也把计数器减1(这个过程还是release)。当系统(也就是Foundation)发现这个计数器变 成员了0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做dealloc)。顺便提一句，如果没有Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">解决:一般是由类的静态方法创建的, 函数名中不会出现alloc或init字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的局部变量. 当然也可以通过retain延长对象的生存期.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3). (NSAutoRealeasePool)内存池：可以通过创建和释放内存池控制内存申请和回收的时机.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">解决:是由autorelease加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像main函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">9. 原子(atomic)跟非原子(non-atomic)属性有什么区别?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1). atomic提供多线程安全。是防止在写未完成的时候被另外一个线程读取，造成数据错误</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2). non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">10. 看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?</span></strong></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">NSMutableArray* ary = [[NSMutableArray array] retain];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>NSString *str = [NSString stringWithFormat:@</code><code>"test"</code><code>];</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[str retain];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[aryaddObject:str];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">NSLog(@”%@%d”,str,[str retainCount]);</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[str retain];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[str release];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[str release];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">NSLog(@”%@%d”,str,[str retainCount]);</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[aryremoveAllObjects];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">NSLog(@”%@%d”,str,[str retainCount]);</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">str的retainCount创建+1，retain+1，加入数组自动+1 3</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">retain+1，release-1，release-1 2</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">数组删除所有对象，所有数组内的对象自动-1 1</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">11. 内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：谁申请，谁释放</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">遵循Cocoa Touch的使用原则;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放，要细心。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">关键字alloc 或new 生成的对象需要手动释放;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">设置正确的property属性，对于retain需要在合适的地方释放，</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">12.如何对iOS设备进行性能测试?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答： Profile-&gt; Instruments -&gt;Time Profiler</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">13. Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">14. MVC设计模式是什么？ 你还熟悉什么设计模式？</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">设计模式：并不是一种新技术，而是一种编码经验，使用比如java中的接口，iphone中的协议，继承关系等基本手段，用比较成熟的逻辑去处理某一种类型的事情，总结为所谓设计模式。面向对象编程中，java已经归纳了23种设计模式。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">mvc设计模式 ：模型，视图，控制器，可以将整个应用程序在思想上分成三大块，对应是的数据的存储或处理，前台的显示，业务逻辑的控制。 Iphone本身的设计思想就是遵循mvc设计模式。其不属于23种设计模式范畴。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用.比如一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东西，代理商从工厂进货.常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广泛应用.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">单例模式：说白了就是一个类不通过alloc方式创建对象，而是用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为，比如想获得[UIApplication sharedApplication];任何地方调用都可以得到 UIApplication的对象，这个对象是全局唯一的。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">观察者模式： 当一个物体发生变化时，会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的对象给这个物体，当这个物体的发生改变，就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">工厂模式：</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">public class Factory{</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">public static Sample creator(int which){</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>if</code>&nbsp;<code>(which==1)</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>return</code>&nbsp;<code>new</code>&nbsp;<code>SampleA();</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>else</code>&nbsp;<code>if</code>&nbsp;<code>(which==2)</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>return</code>&nbsp;<code>new</code>&nbsp;<code>SampleB();</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">}</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">}</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">15 浅复制和深复制的区别?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; &nbsp;&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">深层复制：复制引用对象本身。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">两份独立对象本身。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">用网上一哥们通俗的话将就是：</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">浅复制好比你和你的影子，你完蛋，你的影子也完蛋；</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">16. 类别的作用?继承和类别在实现中有何区别?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改，并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">类别主要有3个作用：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1).将类的实现分散到多个不同文件或多个不同框架中。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2).创建对私有方法的前向引用。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3).向对象添加非正式协议。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">继承可以增加，修改或者删除方法，并且可以增加属性。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">17. 类别和类扩展的区别。</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp; &nbsp; &nbsp; &nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">extensions可以认为是一个私有的Category。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">18. oc中的协议和java中的接口概念有何不同?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">这么看，总觉得类别这玩意儿有点像协议的可选协议。”</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">19. 什么是KVO和KVC?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">KVC:键 – 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">KVO:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">比如我自定义的一个button</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>[self addObserver:self forKeyPath:@</code><code>"highlighted"</code>&nbsp;<code>options:0 context:nil];</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">#pragma mark KVO</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">{</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>if</code>&nbsp;<code>([keyPath isEqualToString:@</code><code>"highlighted"</code><code>] ) {</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[self setNeedsDisplay];</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">}</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">}</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">对于kvc机制如何通过key寻找到value：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量(iVar)，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">来至cocoa，这个说法应该挺有道理。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">可以按照kvc查找的逻辑理解，就说的过去了。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">20. 代理的作用?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">另外一点，代理可以理解为java中的回调监听机制的一种类似。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">21. oc中可修改和不可以修改类型。</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">22. 我们说的oc是动态运行时语言是什么意思?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">这个问题其实浅涉及到两个概念，运行时和多态。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">因此也可以说，运行时机制是多态的基础?~~~</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">23. 通知和协议的不同之处?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：协议有控制链(has-a)的关系，通知没有。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">首先我一开始也不太明白，什么叫控制链(专业术语了~)。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">因此控制链(has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">24. 什么是推送消息?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：推送通知更是一种技术。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">简单点就是客户端获取资源的一种手段。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">普通情况下，都是客户端主动的pull。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">推送则是服务器端主动push。 测试push的实现可以查看该博文。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">25. 关于多态性</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：多态，子类指针可以赋值给父类。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">这个题目其实可以出到一切面向对象语言中，</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">26. 对于单例的理解</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：在objective-c中要实现一个单例类，至少需要做以下四个步骤：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1).为单例对象实现一个静态实例，并初始化，然后设置成nil，</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2).实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3).重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实力的时候不产生一个新实例，</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">4).适当实现allocWitheZone，copyWithZone，release和autorelease。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">27. 说说响应链</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。因为问的太抽象化了，</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">严重怀疑题目出到越后面就越笼统。</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">可以从责任链模式，来讲通过事件响应链处理，其拥有的扩展性</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">28. frame和bounds有什么不同?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答:frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父亲的坐标系统)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">bounds指的是：该view在本身坐标系统中 的位置和大小。(参照点是本身坐标系统)</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">29. 方法和选择器有何不同?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：selector是一个方法的名字，method是一个组合体，包含了名字和实现.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">详情可以看apple文档。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">30. OC的垃圾回收机制?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答： OC2.0有Garbage collection，但是iOS平台不提供。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">但是差了大部分资料，貌似不要和arc机制搞混就好了。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">31. NSOperation queue?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：存放NSOperation的集合类。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">但是转念一想其实可以参考银行的取票和叫号系统。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。</span></p> 
     <p><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">但是后来看到一票关于这操作队列话题的文章，其中有一句提到</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">瞬间觉得这个queue名字有点忽悠人了，还不如pool~。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">32. 什么是延迟加载?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：懒汉模式，只在用到的时候才去初始化。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">也可以理解成延时加载。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">33. 是否在一个视图控制器中嵌入两个tableview控制器?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController那样的感觉。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">34. 一个tableView是否可以关联两个不同的数据源?你会怎么处理?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢?想让列表如何显示，不同的数据源分区块显示?</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">35. 什么时候使用NSMutableArray，什么时候使用NSArray?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：当数组在程序运行时，需要不断变化的，使用NSMutableArray，当数组在初始化后，便不再改变的，使用NSArray。需要指出的是，使用NSArray只表明的是该数组在运行时不发生改变，即不能往NSAarry的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。NSArray是线程安全的，NSMutableArray不是线程安全的，多线程使用到NSMutableArray需要注意。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">36. 给出委托方法的实例，并且说出UITableVIew的Data Source方法</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：CocoaTouch框架中用到了大量委托，其中UITableViewDelegate就是委托机制的典型应用，是一个典型的使用委托来实现适配器模式，其中UITableViewDelegate协议是目标，tableview是适配器，实现UITableViewDelegate协议，并将自身设置为talbeview的delegate的对象，是被适配器，一般情况下该对象是UITableViewController。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">UITableVIew的Data Source方法有- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">37. 在应用中可以创建多少autorelease对象，是否有限制?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答案：无</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">38. 如果我们不创建内存池，是否有内存池提供给我们?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答:界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">39. 什么时候需要在程序中创建内存池?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：用户自己创建的数据线程，则需要创建该线程的内存池</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">40. 类NSObject的那些方法经常被使用?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：NSObject是Objetive-C的基类，其由NSObject类及一系列协议构成。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">其中类方法alloc、class、 description 对象方法init、dealloc、– performSelector:withObject:afterDelay:等经常被使用</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">41. 什么是简便构造方法?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：简便构造方法一般由CocoaTouch框架提供，如NSNumber的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:。</span><span style="line-height:1.5;font-family:'Hannotate SC';font-size:large;">Foundation下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象，并且不需要手动释放。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">42. 如何使用Xcode设计通用应用?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：使用MVC模式设计应用，其中Model层完成脱离界面，即在Model层，其是可运行在任何设备上，在controller层，根据iPhone与iPad(独有UISplitViewController)的不同特点选择不同的viewController对象。在View层，可根据现实要求，来设计，其中以xib文件设计时，其设置其为universal。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">43. UIView的动画效果有那些?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：有很多，如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDown</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">44. 在iPhone应用中如何保存数据?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：有以下几种保存机制：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1).通过web服务，保存在服务器上</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2).通过NSCoder固化机制，将对象保存在文件中</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3).通过SQlite或CoreData保存在文件数据库中</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">45. 什么是coredata?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：coredata是苹果提供一套数据保存框架，其基于SQlite</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">46. 什么是NSManagedObject模型?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：NSManagedObject是NSObject的子类 ，也是coredata的重要组成部分，它是一个通用的类,实现了core data 模型层所需的基本功能，用户可通过子类化NSManagedObject，建立自己的数据模型。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">47. 什么是NSManagedobjectContext?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：NSManagedobjectContext对象负责应用和数据库之间的交互。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">48. 什么是谓词?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：谓词是通过NSPredicate，是通过给定的逻辑条件作为约束条件，完成对数据的筛选。</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-family:'Hannotate SC';font-size:18px;"><code>predicate = [NSPredicate predicateWithFormat:@</code><code>"customerID == %d"</code><code>,n];</code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">a = [customers filteredArrayUsingPredicate:predicate];</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">49. 和coredata一起有哪几种持久化存储机制?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：存入到文件、 存入到NSUserDefaults(系统plist文件中)、存入到Sqlite文件数据库</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">50. 谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：Block是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可以大幅提高应用的执行效率(多核心CPU可直接处理Block指令</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">[UIView transitionWithView:self.view</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">duration:0.2</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">options:UIViewAnimationOptionTransitionFlipFromLeft</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">animations:^{ [[blueViewController view] removeFromSuperview]; [[self view] insertSubview:yellowViewController.view atIndex:0]; }</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">completion:NULL];</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">51. 写出上面代码的Block的定义。</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">typedef void(^animations) (void);</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">typedef void(^completion) (BOOL finished);</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">52. 试着使用+ beginAnimations:context:以及上述Block的定义，写出一个可以完成</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);</span></p> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">操作的函数执行部分</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答案：无</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">53. 做过的项目是否涉及网络访问功能，使用什么对象完成网络功能?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答：ASIHTTPRequest与NSURLConnection</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">54. 简单介绍下NSURLConnection类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并其委托的对象。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">55. 多线程是什么</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: 多线程是个复杂的概念，按字面意思是同步完成多项任务，提高了资源的使用效率，从硬件、操作系统、应用软件不同的角度去看，多线程被赋予不同的内涵，对于硬件，现在市面上多数的CPU都是多核的，多核的CPU运算多线程更为出色;从操作系统角度，是多任务，现在用的主流操作系统都是多任务的，可以一边听歌、一边写博客;对于应用来说，多线程可以让应用有更快的回应，可以在网络下载时，同时响应用户的触摸操作。在iOS应用中，对多线程最初的理解，就是并发，它的含义是原来先做烧水，再摘菜，再炒菜的工作，会变成烧水的同时去摘菜，最后去炒菜。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">56. iOS 中的多线程</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更为方便的使用线程，做过C++的同学可能会对线程有更多的理解，比如线程的创立，信号量、共享变量有认识，Cocoa框架下会方便很多，它对线程做了封装，有些封装，可以让我们创建的对象，本身便拥有线程，也就是线程的对象化抽象，从而减少我们的工程，提供程序的健壮性。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">GCD是(Grand Central Dispatch)的缩写 ，从系统级别提供的一个易用地多线程类库，具有运行时的特点，能充分利用多核心硬件。GCD的API接口为C语言的函数，函数参数中多数有Block，关于Block的使用参看这里，为我们提供强大的“接口”，对于GCD的使用参见本文</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">NSOperation与Queue</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">NSOperation是一个抽象类，它封装了线程的细节实现，我们可以通过子类化该对象，加上NSQueue来同面向对象的思维，管理多线程程序。具体可参看这里：一个基于NSOperation的多线程网络访问的项目。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">NSThread</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">NSThread是一个控制线程执行的对象，它不如NSOperation抽象，通过它我们可以方便的得到一个线程，并控制它。但NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">参看 iOS多线程编程之NSThread的使用</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">其他多线程</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">在Cocoa的框架下，通知、Timer和异步函数等都有使用多线程，(待补充).</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">57. 在项目什么时候选择使用GCD，什么时候选择NSOperation?</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">58. 什么是block</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: 对于闭包(block),有很多定义，其中闭包就是能够读取其它函数内部变量的函数，这个定义即接近本质又较好理解。对于刚接触Block的同学，会觉得有些绕，因为我们习惯写这样的程序main(){ funA();} funA(){funB();} funB(){…..}; 就是函数main调用函数A，函数A调用函数B… 函数们依次顺序执行，但现实中不全是这样的，例如项目经理M，手下有3个程序员A、B、C，当他给程序员A安排实现功能F1时，他并不等着A完成之后，再去安排B去实现F2，而是安排给A功能F1，B功能F2，C功能F3，然后可能去写技术文档，而当A遇到问题时，他会来找项目经理M，当B做完时，会通知M，这就是一个异步执行的例子。在这种情形下，Block便可大显身手，因为在项目经理M，给A安排工作时，同时会告诉A若果遇到困难，如何能找到他报告问题(例如打他手机号)，这就是项目经理M给A的一个回调接口，要回掉的操作，比如接到电话，百度查询后，返回网页内容给A，这就是一个Block，在M交待工作时，已经定义好，并且取得了F1的任务号(局部变量)，却是在当A遇到问题时，才调用执行，跨函数在项目经理M查询百度，获得结果后回调该block。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">59. block 实现原理</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">从计算语言的发展，最早的goto，高级语言的指针，到面向对象语言的block，从机器的思维，一步步接近人的思维，以方便开发人员更为高效、直接的描述出现实的逻辑(需求)。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">使用实例</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">cocoaTouch框架下动画效果的Block的调用</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">使用typed声明block</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">typedef void(^didFinishBlock) (NSObject *ob);</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">这就声明了一个didFinishBlock类型的block，</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">然后便可用</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@property (nonatomic,copy) didFinishBlock finishBlock;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">声明一个blokc对象，注意对象属性设置为copy，接到block 参数时，便会自动复制一份。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">__block是一种特殊类型，</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">使用该关键字声明的局部变量，可以被block所改变，并且其在原函数中的值会被改变。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">60.关于block</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: 面试时，面试官会先问一些，是否了解block，是否使用过block，这些问题相当于开场白，往往是下面一系列问题的开始，所以一定要如实根据自己的情况回答。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">1). 使用block和使用delegate完成委托模式有什么优点?</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">首先要了解什么是委托模式，委托模式在iOS中大量应用，其在设计模式中是适配器模式中的对象适配器，Objective-C中使用id类型指向一切对象，使委托模式更为简洁。了解委托模式的细节：</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">iOS设计模式—-委托模式</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">使用block实现委托模式，其优点是回调的block代码块定义在委托对象函数内部，使代码更为紧凑;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">适配对象不再需要实现具体某个protocol，代码更为简洁。</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2). 多线程与block</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">GCD与Block</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">使用 dispatch_async 系列方法，可以以指定的方式执行block</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">GCD编程实例</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">dispatch_async的完整定义</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">void dispatch_async(</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">dispatch_queue_t queue,</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">dispatch_block_t block);</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">功能：在指定的队列里提交一个异步执行的block，不阻塞当前线程</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">通过queue来控制block执行的线程。主线程执行前文定义的 finishBlock对象</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">dispatch_async(dispatch_get_main_queue(),^(void){finishBlock();});</span></p> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">62.谈谈Object-C的内存管理方式及过程？</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: 1).当你使用new,alloc和copy方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条release或autorelease消息.这样,该对象将在使用寿命结束时被销毁.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">2).当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">3).如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持retain方法和release方法的使用次数相等.</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
     <p><strong><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">63.Object-C有私有方法吗？私有变量呢？</span></strong></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">答: objective-c – 类里面的方法只有两种, 静态方法和实例方法. 这似乎就不是完整的面向对象了,按照OO的原则就是一个对象只暴露有用的东西. 如果没有了私有方法的话, 对于一些小范围的代码重用就不那么顺手了. 在类里面声名一个私有方法</span></p> 
     <blockquote style="background:none;border:2px solid rgb(239,239,239);"> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">@interface Controller : NSObject { NSString *something; }</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">+ (void)thisIsAStaticMethod;</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">– (void)thisIsAnInstanceMethod;</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">@end</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">@interface Controller (private) -</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">(void)thisIsAPrivateMethod;</span></code></span>
      </div> 
      <div>
       <span style="line-height:1.8;font-size:18px;"><code><span style="line-height:1.8;font-family:'Hannotate SC';">@end</span></code></span>
      </div> 
     </blockquote> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">@private可以用来修饰私有变量</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">在Objective‐C中，所有实例变量默认都是私有的，所有实例方法默认都是公有的</span></p> 
     <p><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">&nbsp;</span><span style="line-height:1.8;font-family:'Hannotate SC';font-size:large;">本文未完，余下部分见：<a href="http://www.cocoachina.com/programmer/20151019/13746.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.cocoachina.com/programmer/20151019/13746.html</a></span></p> 
     <p>&nbsp;</p> 
    </div> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
   <div> 
    <font color="#333333"><span style="font-size:14px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/4896814.html，如需转载请自行联系原作者</span></font>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
