<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux Platform驱动模型(二) _驱动方法【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://www.cnblogs.com/xiaojiang1025/archive/2017/02/06/6367910.html         在Linux设备树语法详解和Linux Platform驱动模型(一) _设备信息中我们讨论了设备信息的写法，本文主要讨论平台总...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/09/20/weixin_33724659_90134092.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux Platform驱动模型(二) _驱动方法【转】</h1>
    <p class="post-meta">Sep 20, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://www.cnblogs.com/xiaojiang1025/archive/2017/02/06/6367910.html" rel="nofollow">http://www.cnblogs.com/xiaojiang1025/archive/2017/02/06/6367910.html</a></p> 
   <div class="cnblogs-markdown"> 
    <p>在<a href="http://www.cnblogs.com/xiaojiang1025/p/6131381.html" rel="nofollow">Linux设备树语法详解</a>和<a href="http://www.cnblogs.com/xiaojiang1025/p/6367061.html" rel="nofollow">Linux Platform驱动模型(一) _设备信息</a>中我们讨论了设备信息的写法，本文主要讨论平台总线中另外一部分-驱动方法，将试图回答下面几个问题：</p> 
    <ol>
     <li><span style="text-decoration:underline;">如何填充platform_driver对象？</span></li> 
     <li><span style="text-decoration:underline;">如何将驱动方法对象注册到平台总线中？</span></li> 
    </ol>
    <h2>正文前的一点罗嗦</h2> 
    <p>写驱动也有一段时间了，可以发现，其实驱动本质上只做了两件事：<strong>向上提供接口，向下控制硬件</strong>，当然，这里的<strong>向上</strong>并不是直接提供接口到应用层，而是提供接口给内核再由内核间接的将我们的接口提供给应用层。而写驱动也是有一些套路可寻的，拿到一个硬件，我们大体可以按照下面的流程写一个驱动：</p> 
    <ol>
     <li> <strong>确定驱动架构</strong>：根据硬件连接方式结合分层/分离思想设计驱动的基本结构</li> 
     <li> <strong>确定驱动对象</strong>：内核中的一个驱动/设备就是一个对象，1.定义，2.初始化，3.注册，4.注销</li> 
     <li> <strong>向上提供接口</strong>：根据业务需要确定提供cdev/proc/sysfs哪种接口</li> 
     <li> <strong>向下控制硬件</strong>：1.查看原理图确定引脚和控制逻辑，2.查看芯片手册确定寄存器配置方式，3.进行内存映射，4.实现控制逻辑</li> 
    </ol>
    <h2>认识驱动方法对象</h2> 
    <p>内核用platform_driver结构来表示一个驱动方法对象</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">//include/linux/device.h <span class="hljs-number">173 <span class="hljs-keyword">struct platform_driver { <span class="hljs-number">174 <span class="hljs-keyword">int (*probe)(<span class="hljs-keyword">struct platform_device *); <span class="hljs-number">175 <span class="hljs-keyword">int (*remove)(<span class="hljs-keyword">struct platform_device *); <span class="hljs-number">176 <span class="hljs-keyword">void (*shutdown)(<span class="hljs-keyword">struct platform_device *); <span class="hljs-number">177 <span class="hljs-keyword">int (*suspend)(<span class="hljs-keyword">struct platform_device *, <span class="hljs-keyword">pm_message_t state); <span class="hljs-number">178 <span class="hljs-keyword">int (*resume)(<span class="hljs-keyword">struct platform_device *); <span class="hljs-number">179 <span class="hljs-keyword">struct device_driver driver; <span class="hljs-number">180 <span class="hljs-keyword">const <span class="hljs-keyword">struct platform_device_id *id_table; <span class="hljs-number">181 <span class="hljs-keyword">bool prevent_deferred_probe; <span class="hljs-number">182 };</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
    <p>在这个结构中，我们主要关心以下几个成员</p> 
    <blockquote> 
     <p><strong>struct platform_driver</strong><br> --174--&gt;探测函数，如果驱动匹配到了目标设备，总线会自动回调probe函数，必须实现，<span style="text-decoration:underline;">下面详细讨论</span>。<br> --175--&gt;释放函数，如果匹配到的设备从总线移除了，总线会自动回调remove函数，必须实现<br> --179--&gt;platform_driver的父类，我们接下来讨论<br> --180--&gt;用于C语言写的设备信息，<span style="text-decoration:underline;">下面详细讨论</span>。</p> 
    </blockquote> 
    <p>platform_driver里面有些内容需要在父类driver中实现，</p> 
    <pre><code class="hljs cpp"> <span class="hljs-comment">//include/linux/device.h <span class="hljs-number">228 <span class="hljs-keyword">struct device_driver { <span class="hljs-number">229 <span class="hljs-keyword">const <span class="hljs-keyword">char *name; <span class="hljs-number">230 <span class="hljs-keyword">struct bus_type *bus; <span class="hljs-number">231 <span class="hljs-number">232 <span class="hljs-keyword">struct module *owner; <span class="hljs-number">233 <span class="hljs-keyword">const <span class="hljs-keyword">char *mod_name; <span class="hljs-comment">/* used for built-in modules */ <span class="hljs-number">234 <span class="hljs-number">235 <span class="hljs-keyword">bool suppress_bind_attrs; <span class="hljs-comment">/* disables bind/unbind via sysfs */ <span class="hljs-number">236 <span class="hljs-number">237 <span class="hljs-keyword">const <span class="hljs-keyword">struct of_device_id *of_match_table; <span class="hljs-number">238 <span class="hljs-keyword">const <span class="hljs-keyword">struct acpi_device_id *acpi_match_table; <span class="hljs-number">239 <span class="hljs-number">240 <span class="hljs-keyword">int (*probe) (<span class="hljs-keyword">struct device *dev); <span class="hljs-number">241 <span class="hljs-keyword">int (*remove) (<span class="hljs-keyword">struct device *dev); <span class="hljs-number">242 <span class="hljs-keyword">void (*shutdown) (<span class="hljs-keyword">struct device *dev); <span class="hljs-number">243 <span class="hljs-keyword">int (*suspend) (<span class="hljs-keyword">struct device *dev, <span class="hljs-keyword">pm_message_t state); <span class="hljs-number">244 <span class="hljs-keyword">int (*resume) (<span class="hljs-keyword">struct device *dev); <span class="hljs-number">245 <span class="hljs-keyword">const <span class="hljs-keyword">struct attribute_group **groups; <span class="hljs-number">246 <span class="hljs-number">247 <span class="hljs-keyword">const <span class="hljs-keyword">struct dev_pm_ops *pm; <span class="hljs-number">248 <span class="hljs-number">249 <span class="hljs-keyword">struct driver_private *p; <span class="hljs-number">250 };</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
    <p>下面是我们关心的几个成员</p> 
    <blockquote> 
     <p><strong>struct device_driver</strong><br> --229--&gt;驱动名，如果这个驱动只匹配一个C语言的设备，那么可以通过name相同来匹配<br> --230--&gt;总线类型，这个成员由内核填充<br> --232--&gt;owner，通常就写THIS_MODULE<br> --237--&gt;of_device_id顾名思义就是用来匹配用设备树写的设备信息，<span style="text-decoration:underline;">下面详细讨论</span><br> --249--&gt;私有数据</p> 
    </blockquote> 
    <h2>driver与device的匹配</h2> 
    <p>设备信息有三种表达方式，而一个驱动是可以匹配多个设备的，平台总线中的驱动要具有三种匹配信息的能力，基于这种需求，platform_driver中使用不同的成员来进行相应的匹配。</p> 
    <h3>of_match_table</h3> 
    <p>对于使用设备树编码的设备信息，我们使用其父类device_driver中的of_match_table就是用来匹配</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">//include/linux/mod_devicetable.h <span class="hljs-number">220 <span class="hljs-comment">/* 221 * Struct used for matching a device 222 */ <span class="hljs-number">223 <span class="hljs-keyword">struct of_device_id <span class="hljs-number">224 { <span class="hljs-number">225 <span class="hljs-keyword">char name[<span class="hljs-number">32]; <span class="hljs-number">226 <span class="hljs-keyword">char type[<span class="hljs-number">32]; <span class="hljs-number">227 <span class="hljs-keyword">char compatible[<span class="hljs-number">128]; <span class="hljs-number">228 <span class="hljs-keyword">const <span class="hljs-keyword">void *data; <span class="hljs-number">229 };</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
    <blockquote> 
     <p><strong>struct of_device_id</strong><br> --225--&gt;name[32]设备名<br> --226--&gt;type[32]设备类型<br> --227--&gt;<strong>重点！</strong>compatible[128]用于与设备树compatible属性值匹配的字符串<br> --228--&gt;data驱动私有数据</p> 
    </blockquote> 
    <p>对于一个驱动匹配多个设备的情况，我们使用struct of_device_id tbl[]来表示。</p> 
    <pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct <span class="hljs-title">of_device_id <span class="hljs-title">of_tbl[] = { {.compatible = <span class="hljs-string">"xj4412,demo0",}, {.compatible = <span class="hljs-string">"xj4412,demo1",}, {}, };</span></span></span></span></span></span></code></pre> 
    <h3>id_table</h3> 
    <p>对于使用C语言编码的设备信息，我们用platform_driver对象中的id_table就是用来匹配。我们使用struct platform_device_id ids[]来实现一个驱动匹配多个C语言编码的设备信息。</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">//include/linux/mod_deviceid.h <span class="hljs-number">485 <span class="hljs-keyword">struct platform_device_id { <span class="hljs-number">486 <span class="hljs-keyword">char name[PLATFORM_NAME_SIZE]; <span class="hljs-number">487 <span class="hljs-keyword">kernel_ulong_t driver_data; <span class="hljs-number">488 }; </span></span></span></span></span></span></span></span></code></pre> 
    <blockquote> 
     <p><strong>struct platform_device_id</strong><br> --486--&gt;name就是设备名</p> 
    </blockquote> 
    <p>下面这个例子就是用一个驱动来匹配两个分别叫<strong>"demo0"和"demo1"</strong>的设备，注意，数组最后的<strong>{}</strong>是一定要的，这个是内核判断数组已经结束的标志。</p> 
    <pre><code class="hljs swift"><span class="hljs-keyword">static <span class="hljs-class"><span class="hljs-keyword">struct <span class="hljs-title">platform_device_id <span class="hljs-title">tbl[] = { {<span class="hljs-string">"demo0"}, {<span class="hljs-string">"demo1"}, {}, };</span></span></span></span></span></span></span></code></pre> 
    <h3>name</h3> 
    <p>如果platform_driver和C语言编码的platform_device是一一匹配的，我们还可以使用device_driver中的name来进行匹配</p> 
    <h3>注册设备表</h3> 
    <p>填充完platform_driver结构之后，我们应该将其中用到的设备表注册到内核，虽然不注册也可以工作，但是注册可以将我们表加入到相关文件中，便于内核管理设备。</p> 
    <pre><code class="hljs css"><span class="hljs-selector-tag">MODULE_DEVICE_TABLE(类型, <span class="hljs-selector-tag">ID表); 设备树<span class="hljs-selector-tag">ID表 类型<span class="hljs-selector-pseudo">:of <span class="hljs-selector-tag">C写的<span class="hljs-selector-tag">platform_device的<span class="hljs-selector-tag">ID表 类型<span class="hljs-selector-pseudo">:platform <span class="hljs-selector-tag">C写的<span class="hljs-selector-tag">i2c设备的<span class="hljs-selector-tag">ID表 类型<span class="hljs-selector-pseudo">:i2c <span class="hljs-selector-tag">C写的<span class="hljs-selector-tag">USB设备的<span class="hljs-selector-tag">ID表 类型<span class="hljs-selector-pseudo">:usb</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
    <h3>匹配小结</h3> 
    <p>细心的读者可能会发现，这么多方式都写在一个对象中，那如果我同时注册了三种匹配结构内核该用哪种呢？此时就需要我们搬出平台总线的匹配方式：</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">//drivers/base/platform.c <span class="hljs-number">748 <span class="hljs-function"><span class="hljs-keyword">static <span class="hljs-keyword">int <span class="hljs-title">platform_match<span class="hljs-params">(<span class="hljs-keyword">struct device *dev, <span class="hljs-keyword">struct device_driver *drv) 749 { <span class="hljs-number">750 <span class="hljs-keyword">struct platform_device *pdev = to_platform_device(dev); <span class="hljs-number">751 <span class="hljs-keyword">struct platform_driver *pdrv = to_platform_driver(drv); <span class="hljs-number">752 <span class="hljs-number">753 <span class="hljs-comment">/* Attempt an OF style match first */ <span class="hljs-number">754 <span class="hljs-keyword">if (of_driver_match_device(dev, drv)) <span class="hljs-number">755 <span class="hljs-keyword">return <span class="hljs-number">1; <span class="hljs-number">756 <span class="hljs-number">757 <span class="hljs-comment">/* Then try ACPI style match */ <span class="hljs-number">758 <span class="hljs-keyword">if (acpi_driver_match_device(dev, drv)) <span class="hljs-number">759 <span class="hljs-keyword">return <span class="hljs-number">1; <span class="hljs-number">760 <span class="hljs-number">761 <span class="hljs-comment">/* Then try to match against the id table */ <span class="hljs-number">762 <span class="hljs-keyword">if (pdrv-&gt;id_table) <span class="hljs-number">763 <span class="hljs-keyword">return platform_match_id(pdrv-&gt;id_table, pdev) != <span class="hljs-literal">NULL; <span class="hljs-number">764 <span class="hljs-number">765 <span class="hljs-comment">/* fall-back to driver name match */ <span class="hljs-number">766 <span class="hljs-keyword">return (<span class="hljs-built_in">strcmp(pdev-&gt;name, drv-&gt;name) == <span class="hljs-number">0); <span class="hljs-number">767 }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
    <p>从中不难看出，这几中形式的匹配是有优先级的：<strong>of_match_table&gt;id_table&gt;name</strong>，了解到这点，我们甚至可以构造出同时适应两种设备信息的平台驱动：</p> 
    <pre><code class="hljs cpp"><span class="hljs-keyword">static <span class="hljs-keyword">struct platform_driver drv = { .probe = demo_probe, .remove = demo_remove, .driver = { .name = <span class="hljs-string">"demo", <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef CONFIG_OF .of_match_table = of_tbl, <span class="hljs-meta">#<span class="hljs-meta-keyword">endif }, .id_table = tbl, };</span></span></span></span></span></span></span></code></pre> 
    <p>此外，如果你追一下of_driver_match_device()，就会发现<strong>平台总线的最终的匹配是compatible，name,type三个成员，其中一个为NULL或""时表示任意，所以我们使用平台总线时总是使用compatile匹配设备树，而不是节点路径或节点名</strong>。</p> 
    <h2>probe()</h2> 
    <p>probe即探测函数，如果驱动匹配到了目标设备，总线会自动回调probe函数，下面详细讨论。并把匹配到的设备信息封装策划嗯platform_device对象传入，里面主要完成下面三个工作</p> 
    <ol>
     <li><strong>申请资源</strong></li> 
     <li><strong>初始化</strong></li> 
     <li><strong>提供接口(cdev/sysfs/proc)</strong></li> 
    </ol>
    <p>显然，remove主要完成与probe相反的操作，这两个接口都是我们必须实现的。</p> 
    <p>在probe的工作中，最常见的就是提取设备信息，虽然总线会将设备信息封装成一个platform_device对象并传入probe函数，我们可以很容易的得到关于这个设备的所有信息，但是更好的方法就是直接使用内核API中相关的函数</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">/** * platform_get_resource - 获取资源 * @dev: 平台总线设备 * @type:资源类型，include/linux/ioport.h中有定义 * @num: 资源索引，即第几个此类型的资源，从0开始 */ <span class="hljs-function"><span class="hljs-keyword">struct resource *<span class="hljs-title">platform_get_resource<span class="hljs-params">(<span class="hljs-keyword">struct platform_device *dev,<span class="hljs-keyword">unsigned <span class="hljs-keyword">int type, <span class="hljs-keyword">unsigned <span class="hljs-keyword">int num)</span></span></span></span></span></span></span></span></span></span></code></pre> 
    <p>注意，通过内核API(eg,上下这两个API)获取的resource如果是中断，那么只能是软中断号，而不是芯片手册/C语言设备信息/设备树设备信息中的硬中断号，但是此时获取的resource的flag是可以正确的反映该中断的触发方式的，只需要<code>flag &amp; IRQF_TRIGGER_MASK</code>即可获取该中断的触发方式。</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">/** * platform_get_irq - 获取一个设备的中断号 * @dev: 平台总线设备 * @num: 中断号索引，即想要获取的第几个中断号，从0开始 */ <span class="hljs-function"><span class="hljs-keyword">int <span class="hljs-title">platform_get_irq<span class="hljs-params">(<span class="hljs-keyword">struct platform_device *dev, <span class="hljs-keyword">unsigned <span class="hljs-keyword">int num)</span></span></span></span></span></span></span></span></code></pre> 
    <pre><code class="hljs cpp"><span class="hljs-comment">/** * dev_get_platdata - 获取私有数据 */ <span class="hljs-function"><span class="hljs-keyword">static <span class="hljs-keyword">inline <span class="hljs-keyword">void *<span class="hljs-title">dev_get_platdata<span class="hljs-params">(<span class="hljs-keyword">const <span class="hljs-keyword">struct device *dev){ <span class="hljs-keyword">return dev-&gt;platform_data; }</span></span></span></span></span></span></span></span></span></span></code></pre> 
    <h2>注册/注销platform_driver对象</h2> 
    <p>内核提供了两个API来注册/注销platform_driver对象到内核</p> 
    <pre><code class="hljs cpp"><span class="hljs-comment">/** * platform_driver_register - 注册 */ <span class="hljs-function"><span class="hljs-keyword">int <span class="hljs-title">platform_driver_register<span class="hljs-params">(<span class="hljs-keyword">struct platform_driver *drv);</span></span></span></span></span></span></code></pre> 
    <pre><code class="hljs cpp"><span class="hljs-comment">/** * platform_driver_unregister - 注销 */ <span class="hljs-function"><span class="hljs-keyword">int <span class="hljs-title">platform_driver_unregister<span class="hljs-params">(<span class="hljs-keyword">struct platform_driver *drv);</span></span></span></span></span></span></code></pre> 
    <p>在动态编译的情况下，我们往往在模块初始化函数中注册一个驱动方法对象，而在模块卸载函数中注销一个驱动方法对象，所以我们可以使用内核中如下的宏来提高代码复用</p> 
    <pre><code class="hljs lisp">module_platform_driver(<span class="hljs-name">driver_name)<span class="hljs-comment">;</span></span></code></pre> 
    <h2>实例</h2> 
    <p>这个实例同时使用了设备信息模块和设备树两种设备信息来源，不过最终使用的是设备树，需要注意的是，当我们用设备树的设备信息时，有一个成员platform_device.device.of_node来表示设备的节点，这样就允许我们使用丰富的设备树操作API来操作。</p> 
    <pre><code class="hljs perl">//<span class="hljs-comment">#include "private.h" /* <span class="hljs-regexp">/{ demo{ compatible = "4412,demo0"; reg = &lt;0x5000000 0x2 0x5000008 0x2&gt;; interrupt-parent = &lt;&amp;gic&gt;; interrupts = &lt;0 25 0&gt;, &lt;0 26 0&gt;; intpriv = &lt;0x12345678&gt;; strpriv = "hello world"; }; }; */ struct privatedata { <span class="hljs-keyword">int val; char str[<span class="hljs-number">36]; }; static void getprivdata(struct device_node *np) { struct property *prop; prop = of_find_property(np, <span class="hljs-string">"intpriv", NULL); <span class="hljs-keyword">if(prop) printk(<span class="hljs-string">"private val: %x\n", *((<span class="hljs-keyword">int *)(prop-&gt;value))); prop = of_find_property(np, <span class="hljs-string">"strpriv", NULL); <span class="hljs-keyword">if(prop) printk(<span class="hljs-string">"private str: %s\n", (char *)(prop-&gt;value) ); } static <span class="hljs-keyword">int demo_probe(struct platform_device *pdev) { <span class="hljs-keyword">int irq; struct resource *addr; struct privatedata *priv; printk(KERN_INFO <span class="hljs-string">"%s : %s : %d - entry.\n", __FILE_<span class="hljs-number">_, __func_<span class="hljs-number">_, __LINE_<span class="hljs-number">_); priv = dev_get_platdata(&amp;pdev-&gt;dev); <span class="hljs-keyword">if(priv){ printk(KERN_INFO <span class="hljs-string">"%x : %s \n", priv-&gt;val, priv-&gt;str); }<span class="hljs-keyword">else{ getprivdata(pdev-&gt;dev.of_node); } addr = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">0); <span class="hljs-keyword">if(addr){ printk(KERN_INFO <span class="hljs-string">"0: %x : %d \n", addr-&gt;start, resource_size(addr)); } addr = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">1); <span class="hljs-keyword">if(addr){ printk(KERN_INFO <span class="hljs-string">"1: %x : %d \n", addr-&gt;start, resource_size(addr)); } addr = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">2); <span class="hljs-keyword">if(!addr){ printk(KERN_INFO <span class="hljs-string">"No 2 resource\n"); } irq = platform_get_ir<span class="hljs-string">q(pdev, 0); <span class="hljs-keyword">if(<span class="hljs-number">0 &gt; irq){ <span class="hljs-keyword">return irq; }<span class="hljs-keyword">else{ printk(KERN_INFO <span class="hljs-string">"irq 0: %d \n", irq); } irq = platform_get_ir<span class="hljs-string">q(pdev, 1); <span class="hljs-keyword">if(<span class="hljs-number">0 &gt; irq){ <span class="hljs-keyword">return irq; }<span class="hljs-keyword">else{ printk(KERN_INFO <span class="hljs-string">"irq 0: %d \n", irq); } irq = platform_get_ir<span class="hljs-string">q(pdev, 2); <span class="hljs-keyword">if(<span class="hljs-number">0 &gt; irq){ printk(KERN_INFO <span class="hljs-string">"No 2 irq\n"); } <span class="hljs-keyword">return <span class="hljs-number">0; } static <span class="hljs-keyword">int demo_remove(struct platform_device *pdev) { <span class="hljs-keyword">return <span class="hljs-number">0; } static struct platform_device_id tbl[] = { {<span class="hljs-string">"demo0"}, {<span class="hljs-string">"demo1"}, {}, }; MODULE_DEVICE_TABLE(platform, tbl); <span class="hljs-comment">#ifdef CONFIG_OF struct of_device_id of_tbl[] = { {.compatible = <span class="hljs-string">"4412,demo0",}, {.compatible = <span class="hljs-string">"4412,demo1",}, {}, }; <span class="hljs-comment">#endif //<span class="hljs-number">1. alloc obj static struct platform_driver drv = { .probe = demo_probe, .remove = demo_remove, .driver = { .name = <span class="hljs-string">"demo", <span class="hljs-comment">#ifdef CONFIG_OF .of_match_table = of_tbl, <span class="hljs-comment">#endif }, .id_table = tbl, }; static <span class="hljs-keyword">int __init drv_init(void) { <span class="hljs-regexp">//get command <span class="hljs-keyword">and pid printk(KERN_INFO <span class="hljs-string">"(%s:pid=%d), %s : %s : %d - entry.\n",current-&gt;comm, current-&gt;pid, __FILE_<span class="hljs-number">_, __func_<span class="hljs-number">_, __LINE_<span class="hljs-number">_); <span class="hljs-keyword">return platform_driver_register(&amp;drv); } static void __exit drv_exit(void) { <span class="hljs-regexp">//get command <span class="hljs-keyword">and pid printk(KERN_INFO <span class="hljs-string">"(%s:pid=%d), %s : %s : %d - leave.\n",current-&gt;comm, current-&gt;pid, __FILE_<span class="hljs-number">_, __func_<span class="hljs-number">_, __LINE_<span class="hljs-number">_); platform_driver_unregister(&amp;drv); } module_init(drv_init); module_exit(drv_exit); MODULE_LICENSE(<span class="hljs-string">"GPL");</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
