<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>排列与组合的一些定理 « NotBeCN</title>
  <meta name="description" content="             一，加法原理与乘法原理    加法原理与乘法原理是排列与组合的基础。加法原理本质上是分类，乘法原理本质上是分步。    分类，就是把一个集合(某事物)分成互不相交的若干独立的部分。比如，概率论中的全概率公式就将事件分成”全划分“    分类思想可以简化程序的时间复杂度。比如：最短路径算法...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/09/20/weixin_33935505_90121480.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">排列与组合的一些定理</h1>
    <p class="post-meta">Sep 20, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p><strong><span style="font-family:'Microsoft YaHei';font-size:16px;">一，加法原理与乘法原理</span></strong></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">加法原理与乘法原理是排列与组合的基础。加法原理本质上是分类，乘法原理本质上是分步。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">分类，就是把一个集合(某事物)分成互不相交的若干独立的部分。比如，概率论中的全概率公式就将事件分成”全划分“</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">分类思想可以简化程序的时间复杂度。比如：<a class="postTitle2" id="cb_post_title_url" href="http://www.cnblogs.com/hapjin/p/5445370.html" rel="nofollow">最短路径算法-Dijkstra算法的应用之单词转换(词梯问题)</a></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">分步，就是第一步干嘛，第二步再干嘛……比如A地到D地，第一步：先到达B地；第二步，再到达C地</span></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="font-family:'Microsoft YaHei';font-size:16px;">二，排列</span></strong></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">P(n,r)表示从n个数中选择r个数的一个全排列</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">公式：P(n,r)=P(n-1,r)+p(n-1,r-1)<span style="color:rgb(255,0,0);"><strong>*r</strong></span></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">上面公式用到了分类思想：对于某个元素而言，要么选，要么不选。如果不选它，则在剩下的n-1个元素中选<strong>r</strong>个进行全排列；如果选了它，则在剩下的n-1个元素中只需要选<strong>r-1</strong>个元素进行全排列了。但是选了的那个元素，<span style="color:rgb(255,0,0);">一共有r种位置存放（因为这是排列，同一个元素放在不同的位置 属于不同的排列）故p(n-1,r-1)*r。</span></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">排列一共有三种：①线排列，就是通常的普通排列。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">公式：P(n,r)=n!/(n-r)! </span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">②圆排列，相当于排序的数围成一个圆。比如循环队列的那种实现方式。举个圆排列的例子如下：</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">a b c d四个字母的线排列共有4!=24种。对于其中的一种排列： a b c d ，它对应着四种等价圆排列： </span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">1) a b c d&nbsp;&nbsp; 2) b c d a&nbsp;&nbsp; 3)c d a b&nbsp;&nbsp; 4)d a b c</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">因此，对于给定n个数的所有圆排列，一共有 p(n,r)/r种。 因为，<strong>一个圆排列可以产生r个线排列。</strong></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">③重排列</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">对于线排列而言，某个元素选了之后，就不能再选了（一个元素只能选一次）</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">对于重排列而言，一个元素可以选多次。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">集合{∞·b<sub>1</sub>，∞·b<sub>2</sub>，....，∞·b<sub>n</sub>}的一个r排列个数为：n<sup>r</sup></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">即从b<sub>1</sub>，b<sub>2</sub>...b<sub>n</sub>，共n个元素中选出r个，每个元素<span style="color:rgb(255,0,0);">可选任意多次</span>，一共有种n<sup>r</sup>排列</span></p> 
   <p><strong><span style="font-family:'Microsoft YaHei';font-size:16px;">还有一种重排列是：每个元素最多只能选K次(某个固定的次数)</span></strong></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">{K<sub>1</sub>·b<sub>1</sub>，K<sub>2</sub>·b<sub>2</sub>，....，Kn·b<sub>n</sub>}（ 元素b<sub>1</sub>最多只能选K<sub>1</sub>次）的一个r排列个数为：(K<sub>1</sub>+K<sub>2</sub>+....+K<sub>n</sub>)!/(K<sub>1</sub>!K<sub>2</sub>!...K<sub>n</sub>!)<br></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">上面表示从b<sub>1</sub>，b<sub>2</sub>...b<sub>n</sub>，共n个元素中选出r个进行排列，但是 b<sub>j</sub>最多只能选K<sub>j</sub>次，一共有(K<sub>1</sub>+K<sub>2</sub>+....+K<sub>n</sub>)!/(K<sub>1</sub>!K<sub>2</sub>!...K<sub>n</sub>!)次排列方式。</span></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="font-family:'Microsoft YaHei';font-size:16px;">三，组合</span></strong></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">C(n,r)表示从n个数中选择r个数的一个全组合。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">公式：C(n, r)=[n!/(r!)(n-r)!]=P(n,r)/r!</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">公式：<span style="color:rgb(255,0,0);">C(n,r)=C(n-1,r)+C(n-1,r-1)</span>&nbsp; 这个公式用到了分类思想。对于n个元素的某个元素，要么选，要么不选。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">如果选了，只需在 剩下的n-1 个元素中选 r-1个；如果不选，则在剩下的n-1个元素中选r个（因为一共要选r个啊）。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">这个公式非常有用，这是杨辉三解公式：其中基准条件C(n,0)=1，C(i,i)=1</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">C(0,0)</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">C(1,0)&nbsp;&nbsp; C(1,1)</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">C(2,0)&nbsp;&nbsp; C(2,1)&nbsp;&nbsp; C(2,2)</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">C(3,0)&nbsp;&nbsp; C(3,1)&nbsp;&nbsp; C(3,2)&nbsp;&nbsp; C(3,3)</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">.....&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .....&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .....</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">如果要求解C(n,r)，可以先求解出C(n-1,r) 和 C(n-1,r-1)；再运用公式相加即可。很明显，这是一个与<a href="http://www.cnblogs.com/hapjin/p/5571352.html" rel="nofollow">Fib数列</a>类似的递归计算。只不过求Fib(n)时，只有一个参数，而这里有二个参数而已。当然，上面的程序效率是非常低的，因为它重复计算了很多子问题。代码实现如下：</span></p> 
   <div class="cnblogs_code"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
    <pre><span style="color:rgb(0,128,128);"> 1</span> <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> YanHuiTriangle {
<span style="color:rgb(0,128,128);"> 2</span>     <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">compute C(n,r)</span>
<span style="color:rgb(0,128,128);"> 3</span>     <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">long</span> c(<span style="color:rgb(0,0,255);">int</span> n, <span style="color:rgb(0,0,255);">int</span> r){
<span style="color:rgb(0,128,128);"> 4</span>         <span style="color:rgb(0,0,255);">if</span>(n == 0 || r == 0)
<span style="color:rgb(0,128,128);"> 5</span>             <span style="color:rgb(0,0,255);">return</span> 1;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">base condition</span>
<span style="color:rgb(0,128,128);"> 6</span>         <span style="color:rgb(0,0,255);">if</span>(n == r)
<span style="color:rgb(0,128,128);"> 7</span>             <span style="color:rgb(0,0,255);">return</span> 1;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">base condition</span>
<span style="color:rgb(0,128,128);"> 8</span>         <span style="color:rgb(0,0,255);">else</span>
<span style="color:rgb(0,128,128);"> 9</span>             <span style="color:rgb(0,0,255);">return</span> c(n-1, r-1) + c(n-1, r);
<span style="color:rgb(0,128,128);">10</span>     }
<span style="color:rgb(0,128,128);">11</span> 
<span style="color:rgb(0,128,128);">12</span>     <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">compute c(n,r)</span>
<span style="color:rgb(0,128,128);">13</span>     <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">long</span> c_dp(<span style="color:rgb(0,0,255);">int</span> n ,<span style="color:rgb(0,0,255);">int</span> r){
<span style="color:rgb(0,128,128);">14</span>         <span style="color:rgb(0,0,255);">long</span>[][] dp = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(0,0,255);">long</span>[n+1][r+1];
<span style="color:rgb(0,128,128);">15</span>         
<span style="color:rgb(0,128,128);">16</span>         <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">init</span>
<span style="color:rgb(0,128,128);">17</span>         <span style="color:rgb(0,0,255);">for</span>(<span style="color:rgb(0,0,255);">int</span> i = 0; i &lt;= n; i++)
<span style="color:rgb(0,128,128);">18</span>             dp[i][0] = 1;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">if(n==0)</span>
<span style="color:rgb(0,128,128);">19</span>         <span style="color:rgb(0,0,255);">for</span>(<span style="color:rgb(0,0,255);">int</span> i = 0; i &lt;= r; i++)
<span style="color:rgb(0,128,128);">20</span>             dp[0][i] = 1;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">if(r==0)</span>
<span style="color:rgb(0,128,128);">21</span>         <span style="color:rgb(0,0,255);">for</span>(<span style="color:rgb(0,0,255);">int</span> i = 0; i &lt;= r; i++)<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">Assume r &lt; n</span>
<span style="color:rgb(0,128,128);">22</span>             dp[i][i] = 1;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">if(n==r)</span>
<span style="color:rgb(0,128,128);">23</span>         
<span style="color:rgb(0,128,128);">24</span>         <span style="color:rgb(0,0,255);">for</span>(<span style="color:rgb(0,0,255);">int</span> i = 1; i &lt;= n; i++)
<span style="color:rgb(0,128,128);">25</span>         {
<span style="color:rgb(0,128,128);">26</span>             <span style="color:rgb(0,0,255);">for</span>(<span style="color:rgb(0,0,255);">int</span> j = 1; j &lt;= r; j++)
<span style="color:rgb(0,128,128);">27</span>             {
<span style="color:rgb(0,128,128);">28</span>                 <span style="color:rgb(0,0,255);">if</span>(j &lt; i)
<span style="color:rgb(0,128,128);">29</span>                     dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
<span style="color:rgb(0,128,128);">30</span>                 <span style="color:rgb(0,0,255);">else</span> <span style="color:rgb(0,0,255);">if</span>(j &gt; i)<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">从 i 个元素中选取出 j个元素(j&gt;i 没有意义)</span>
<span style="color:rgb(0,128,128);">31</span>                     dp[i][j] = 0;
<span style="color:rgb(0,128,128);">32</span>             }
<span style="color:rgb(0,128,128);">33</span>         }
<span style="color:rgb(0,128,128);">34</span>         <span style="color:rgb(0,0,255);">return</span> dp[n][r];
<span style="color:rgb(0,128,128);">35</span>     }
<span style="color:rgb(0,128,128);">36</span>     
<span style="color:rgb(0,128,128);">37</span>     <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> main(String[] args) {
<span style="color:rgb(0,128,128);">38</span>         
<span style="color:rgb(0,128,128);">39</span>         <span style="color:rgb(0,0,255);">long</span> start_dp = System.currentTimeMillis();
<span style="color:rgb(0,128,128);">40</span>         System.out.println(c_dp(50, 10));
<span style="color:rgb(0,128,128);">41</span>         <span style="color:rgb(0,0,255);">long</span> end_dp = System.currentTimeMillis();
<span style="color:rgb(0,128,128);">42</span>         System.out.println("dp use time: " + (end_dp - start_dp) + "ms");
<span style="color:rgb(0,128,128);">43</span>         
<span style="color:rgb(0,128,128);">44</span>         <span style="color:rgb(0,0,255);">long</span> start = System.currentTimeMillis();
<span style="color:rgb(0,128,128);">45</span>         System.out.println(c(50,10));
<span style="color:rgb(0,128,128);">46</span>         <span style="color:rgb(0,0,255);">long</span> end = System.currentTimeMillis();
<span style="color:rgb(0,128,128);">47</span>         System.out.println("non dp use time: " + (end - start) + "ms");
<span style="color:rgb(0,128,128);">48</span>     }
<span style="color:rgb(0,128,128);">49</span> }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
   </div> 
   <p>&nbsp;</p> 
   <p><img alt="" src="data:image/png;base64,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"></p> 
   <p>&nbsp;</p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">这个示例完美地证明了DP（<a href="http://www.cnblogs.com/hapjin/p/5573419.html" rel="nofollow">动态规划</a>）实现和递归实现的差距。是学习DP的一个好示例。如何将一个程序从递归改成DP？看上面的示例就会有启示了。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">其次，这也是<a href="http://www.cnblogs.com/hapjin/p/5575109.html" rel="nofollow">0-1背包问题</a>分解的思路，对于某件物品，要么拿走，要么不拿走。因此，<span style="color:rgb(255,0,0);">这个组合公式在DP问题的分析中经常用到</span>。</span></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="font-family:'Microsoft YaHei';font-size:16px;">重组合公式：从集合{∞·b<sub>1</sub>，∞·b<sub>2</sub>，....，∞·b<sub>n</sub>}中选取r个元素，（不考虑次序），一共有多少种组合？</span></strong></p> 
   <p><span style="color:rgb(255,0,0);font-family:'Microsoft YaHei';font-size:16px;">答案是：F(n,r) = C(n+r-1, r)</span></p> 
   <p>&nbsp;</p> 
   <p><strong><span style="font-family:'Microsoft YaHei';font-size:16px;">四，<span style="color:rgb(255,0,0);">二项</span>式定理</span></strong></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">（X+Y）<sup>n</sup> = C(n,0)X<sup>0</sup> Y<sup>n</sup> + C(n,1)X<sup>1</sup> Y<sup>n-1</sup> +.....+ C(n,n)X<sup>n</sup> Y<sup>0</sup></span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;">“二项式”定理嘛，就是有两个项相加求n次幂。。。。。</span></p> 
   <p><span style="font-family:'Microsoft YaHei';font-size:16px;"><br></span></p> 
   <p><font>本文转自hapjin博客园博客，原文链接：http://www.cnblogs.com/hapjin/p/5656632.html</font><span style="font-family:'Microsoft YaHei';">，如需转载请自行联系原作者</span></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
