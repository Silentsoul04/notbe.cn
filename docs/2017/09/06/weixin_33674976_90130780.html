<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Java-Base64工具类 « NotBeCN</title>
  <meta name="description" content="                 /* * Base64 encoding and decoding. * Copyright (C) 2001-2004 Stephen Ostermiller * http://ostermiller.org/contact.pl?regarding=Java+Utilitie...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/09/06/weixin_33674976_90130780.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Java-Base64工具类</h1>
    <p class="post-meta">Sep 6, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="markdown_views">
    <pre class="prettyprint"><code class="hljs java">
<span class="hljs-comment">/* * Base64 encoding and decoding. * Copyright (C) 2001-2004 Stephen Ostermiller * http://ostermiller.org/contact.pl?regarding=Java+Utilities * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * See COPYING.TXT for details. */</span>

<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> gnu.getopt.*;
<span class="hljs-keyword">import</span> java.text.MessageFormat;
<span class="hljs-keyword">import</span> java.util.ResourceBundle;
<span class="hljs-keyword">import</span> java.util.Locale;

<span class="hljs-javadoc">/** * Implements Base64 encoding and decoding as defined by RFC 2045: "Multipurpose Internet * Mail Extensions (MIME) Part One: Format of Internet Message Bodies" page 23. * More information about this class is available from &lt;a target="_top" href= * "http://ostermiller.org/utils/Base64.html"&gt;ostermiller.org&lt;/a&gt;. * * &lt;blockquote&gt; * &lt;p&gt;The Base64 Content-Transfer-Encoding is designed to represent * arbitrary sequences of octets in a form that need not be humanly * readable. The encoding and decoding algorithms are simple, but the * encoded data are consistently only about 33 percent larger than the * unencoded data. This encoding is virtually identical to the one used * in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.&lt;/p&gt; * * &lt;p&gt;A 65-character subset of US-ASCII is used, enabling 6 bits to be * represented per printable character. (The extra 65th character, "=", * is used to signify a special processing function.)&lt;/p&gt; * * &lt;p&gt;NOTE: This subset has the important property that it is represented * identically in all versions of ISO 646, including US-ASCII, and all * characters in the subset are also represented identically in all * versions of EBCDIC. Other popular encodings, such as the encoding * used by the uuencode utility, Macintosh binhex 4.0 [RFC-1741], and * the base85 encoding specified as part of Level 2 PostScript, do no * share these properties, and thus do not fulfill the portability * requirements a binary transport encoding for mail must meet.&lt;/p&gt; * * &lt;p&gt;The encoding process represents 24-bit groups of input bits as output * strings of 4 encoded characters. Proceeding from left to right, a * 24-bit input group is formed by concatenating 3 8bit input groups. * These 24 bits are then treated as 4 concatenated 6-bit groups, each * of which is translated into a single digit in the base64 alphabet. * When encoding a bit stream via the base64 encoding, the bit stream * must be presumed to be ordered with the most-significant-bit first. * That is, the first bit in the stream will be the high-order bit in * the first 8bit byte, and the eighth bit will be the low-order bit in * the first 8bit byte, and so on.&lt;/p&gt; * * &lt;p&gt;Each 6-bit group is used as an index into an array of 64 printable * characters. The character referenced by the index is placed in the * output string. These characters, identified in Table 1, below, are * selected so as to be universally representable, and the set excludes * characters with particular significance to SMTP (e.g., ".", CR, LF) * and to the multipart boundary delimiters defined in RFC 2046 (e.g., * "-").&lt;/p&gt; * &lt;pre&gt; * Table 1: The Base64 Alphabet * * Value Encoding Value Encoding Value Encoding Value Encoding * 0 A 17 R 34 i 51 z * 1 B 18 S 35 j 52 0 * 2 C 19 T 36 k 53 1 * 3 D 20 U 37 l 54 2 * 4 E 21 V 38 m 55 3 * 5 F 22 W 39 n 56 4 * 6 G 23 X 40 o 57 5 * 7 H 24 Y 41 p 58 6 * 8 I 25 Z 42 q 59 7 * 9 J 26 a 43 r 60 8 * 10 K 27 b 44 s 61 9 * 11 L 28 c 45 t 62 + * 12 M 29 d 46 u 63 / * 13 N 30 e 47 v * 14 O 31 f 48 w (pad) = * 15 P 32 g 49 x * 16 Q 33 h 50 y * &lt;/pre&gt; * &lt;p&gt;The encoded output stream must be represented in lines of no more * than 76 characters each. All line breaks or other characters no * found in Table 1 must be ignored by decoding software. In base64 * data, characters other than those in Table 1, line breaks, and other * white space probably indicate a transmission error, about which a * warning message or even a message rejection might be appropriate * under some circumstances.&lt;/p&gt; * * &lt;p&gt;Special processing is performed if fewer than 24 bits are available * at the end of the data being encoded. A full encoding quantum is * always completed at the end of a body. When fewer than 24 input bits * are available in an input group, zero bits are added (on the right) * to form an integral number of 6-bit groups. Padding at the end of * the data is performed using the "=" character. Since all base64 * input is an integral number of octets, only the following cases can * arise: (1) the final quantum of encoding input is an integral * multiple of 24 bits; here, the final unit of encoded output will be * an integral multiple of 4 characters with no "=" padding, (2) the * final quantum of encoding input is exactly 8 bits; here, the final * unit of encoded output will be two characters followed by two "=" * padding characters, or (3) the final quantum of encoding input is * exactly 16 bits; here, the final unit of encoded output will be three * characters followed by one "=" padding character.&lt;/p&gt; * * &lt;p&gt;Because it is used only for padding at the end of the data, the * occurrence of any "=" characters may be taken as evidence that the * end of the data has been reached (without truncation in transit). No * such assurance is possible, however, when the number of octets * transmitted was a multiple of three and no "=" characters are * present.&lt;/p&gt; * * &lt;p&gt;Any characters outside of the base64 alphabet are to be ignored in * base64-encoded data.&lt;/p&gt; * * &lt;p&gt;Care must be taken to use the proper octets for line breaks if base64 * encoding is applied directly to text material that has not been * converted to canonical form. In particular, text line breaks must be * converted into CRLF sequences prior to base64 encoding. The * important thing to note is that this may be done directly by the * encoder rather than in a prior canonization step in some * implementations.&lt;/p&gt; * * &lt;p&gt;NOTE: There is no need to worry about quoting potential boundary * delimiters within base64-encoded bodies within multipart entities * because no hyphen characters are used in the base64 encoding.&lt;/p&gt; * &lt;/blockquote&gt; * *<span class="hljs-javadoctag"> @author</span> Stephen Ostermiller http://ostermiller.org/contact.pl?regarding=Java+Utilities *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base64</span> {</span>

    <span class="hljs-javadoc">/** * Symbol that represents the end of an input stream * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> END_OF_INPUT = -<span class="hljs-number">1</span>;

    <span class="hljs-javadoc">/** * A character that is not a valid base 64 character. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NON_BASE_64 = -<span class="hljs-number">1</span>;

    <span class="hljs-javadoc">/** * A character that is not a valid base 64 character. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NON_BASE_64_WHITESPACE = -<span class="hljs-number">2</span>;

    <span class="hljs-javadoc">/** * A character that is not a valid base 64 character. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NON_BASE_64_PADDING = -<span class="hljs-number">3</span>;

    <span class="hljs-javadoc">/** * This class need not be instantiated, all methods are static. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title">Base64</span>(){
    }

    <span class="hljs-javadoc">/** * Table of the sixty-four characters that are used as * the Base64 alphabet: [A-Za-z0-9+/] * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] base64Chars = {
        <span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>,<span class="hljs-string">'D'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'F'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'H'</span>,
        <span class="hljs-string">'I'</span>,<span class="hljs-string">'J'</span>,<span class="hljs-string">'K'</span>,<span class="hljs-string">'L'</span>,<span class="hljs-string">'M'</span>,<span class="hljs-string">'N'</span>,<span class="hljs-string">'O'</span>,<span class="hljs-string">'P'</span>,
        <span class="hljs-string">'Q'</span>,<span class="hljs-string">'R'</span>,<span class="hljs-string">'S'</span>,<span class="hljs-string">'T'</span>,<span class="hljs-string">'U'</span>,<span class="hljs-string">'V'</span>,<span class="hljs-string">'W'</span>,<span class="hljs-string">'X'</span>,
        <span class="hljs-string">'Y'</span>,<span class="hljs-string">'Z'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>,
        <span class="hljs-string">'g'</span>,<span class="hljs-string">'h'</span>,<span class="hljs-string">'i'</span>,<span class="hljs-string">'j'</span>,<span class="hljs-string">'k'</span>,<span class="hljs-string">'l'</span>,<span class="hljs-string">'m'</span>,<span class="hljs-string">'n'</span>,
        <span class="hljs-string">'o'</span>,<span class="hljs-string">'p'</span>,<span class="hljs-string">'q'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'s'</span>,<span class="hljs-string">'t'</span>,<span class="hljs-string">'u'</span>,<span class="hljs-string">'v'</span>,
        <span class="hljs-string">'w'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,
        <span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span>,<span class="hljs-string">'+'</span>,<span class="hljs-string">'/'</span>,
    };

    <span class="hljs-javadoc">/** * Reverse lookup table for the Base64 alphabet. * reversebase64Chars[byte] gives n for the nth Base64 * character or negative if a character is not a Base64 character. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] reverseBase64Chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0x100</span>];
    <span class="hljs-keyword">static</span> {
        <span class="hljs-comment">// Fill in NON_BASE_64 for all characters to start with</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;reverseBase64Chars.length; i++){
            reverseBase64Chars[i] = NON_BASE_64;
        }
        <span class="hljs-comment">// For characters that are base64Chars, adjust</span>
        <span class="hljs-comment">// the reverse lookup table.</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> i=<span class="hljs-number">0</span>; i &lt; base64Chars.length; i++){
            reverseBase64Chars[base64Chars[i]] = i;
        }
        reverseBase64Chars[<span class="hljs-string">' '</span>] = NON_BASE_64_WHITESPACE;
        reverseBase64Chars[<span class="hljs-string">'\n'</span>] = NON_BASE_64_WHITESPACE;
        reverseBase64Chars[<span class="hljs-string">'\r'</span>] = NON_BASE_64_WHITESPACE;
        reverseBase64Chars[<span class="hljs-string">'\t'</span>] = NON_BASE_64_WHITESPACE;
        reverseBase64Chars[<span class="hljs-string">'\f'</span>] = NON_BASE_64_WHITESPACE;
        reverseBase64Chars[<span class="hljs-string">'='</span>] = NON_BASE_64_PADDING;
    }

    <span class="hljs-javadoc">/** * Version number of this program * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String version = <span class="hljs-string">"1.2"</span>;

    <span class="hljs-javadoc">/** * Locale specific strings displayed to the user. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> ResourceBundle labels = ResourceBundle.getBundle(<span class="hljs-string">"com.Ostermiller.util.Base64"</span>,  Locale.getDefault());

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ACTION_GUESS = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ACTION_ENCODE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ACTION_DECODE = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ARGUMENT_GUESS = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ARGUMENT_STRING = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ARGUMENT_FILE = <span class="hljs-number">2</span>;

    <span class="hljs-javadoc">/** * Converts the line ending on files, or standard input. * Run with --help argument for more information. * *<span class="hljs-javadoctag"> @param</span> args Command line arguments. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        <span class="hljs-comment">// create the command line options that we are looking for</span>
        LongOpt[] longopts = {
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"help.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"version.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"about.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"encode.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'e'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"lines.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'l'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"nolines.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"decode.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'d'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"decodeall.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'a'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"decodegood.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"guess.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'g'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"ext.option"</span>), LongOpt.OPTIONAL_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'x'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"force.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'f'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"quiet.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'q'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"reallyquiet.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'Q'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"verbose.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'v'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"noforce.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">4</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"file.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"string.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"newline.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-string">'n'</span>),
            <span class="hljs-keyword">new</span> LongOpt(labels.getString(<span class="hljs-string">"nonewline.option"</span>), LongOpt.NO_ARGUMENT, <span class="hljs-keyword">null</span>, <span class="hljs-number">9</span>),
        };
        String oneLetterOptions = <span class="hljs-string">"eldagx::fqQvVn"</span>;
        Getopt opts = <span class="hljs-keyword">new</span> Getopt(labels.getString(<span class="hljs-string">"base64"</span>), args, oneLetterOptions, longopts);
        <span class="hljs-keyword">int</span> action = ACTION_GUESS;
        String extension = <span class="hljs-string">"base64"</span>;
        <span class="hljs-keyword">boolean</span> force = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">boolean</span> printMessages = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">boolean</span> printErrors = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">boolean</span> forceDecode = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">boolean</span> lineBreaks = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">int</span> argumentType = ARGUMENT_GUESS;
        <span class="hljs-keyword">boolean</span> decodeEndLine = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> c;
        <span class="hljs-keyword">while</span> ((c = opts.getopt()) != -<span class="hljs-number">1</span>){
            <span class="hljs-keyword">switch</span>(c){
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:{
                    <span class="hljs-comment">// print out the help message</span>
                    String[] helpFlags = <span class="hljs-keyword">new</span> String[]{
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"help.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"version.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"about.option"</span>),
                        <span class="hljs-string">"-g --"</span> + labels.getString(<span class="hljs-string">"guess.option"</span>),
                        <span class="hljs-string">"-e --"</span> + labels.getString(<span class="hljs-string">"encode.option"</span>),
                        <span class="hljs-string">"-l --"</span> + labels.getString(<span class="hljs-string">"lines.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"nolines.option"</span>),
                        <span class="hljs-string">"-d --"</span> + labels.getString(<span class="hljs-string">"decode.option"</span>),
                        <span class="hljs-string">"-a --"</span> + labels.getString(<span class="hljs-string">"decodeall.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"decodegood.option"</span>),
                        <span class="hljs-string">"-x --"</span> + labels.getString(<span class="hljs-string">"ext.option"</span>) + <span class="hljs-string">" &lt;"</span> + labels.getString(<span class="hljs-string">"ext.option"</span>) + <span class="hljs-string">"&gt;"</span>,
                        <span class="hljs-string">"-f --"</span> + labels.getString(<span class="hljs-string">"force.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"noforce.option"</span>),
                        <span class="hljs-string">"-v --"</span> + labels.getString(<span class="hljs-string">"verbose.option"</span>),
                        <span class="hljs-string">"-q --"</span> + labels.getString(<span class="hljs-string">"quiet.option"</span>),
                        <span class="hljs-string">"-Q --"</span> + labels.getString(<span class="hljs-string">"reallyquiet.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"file.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"string.option"</span>),
                        <span class="hljs-string">"-n --"</span> + labels.getString(<span class="hljs-string">"newline.option"</span>),
                        <span class="hljs-string">"--"</span> + labels.getString(<span class="hljs-string">"nonewline.option"</span>),
                    };
                    <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;helpFlags.length; i++){
                        maxLength = Math.max(maxLength, helpFlags[i].length());
                    }
                    maxLength += <span class="hljs-number">2</span>;
                    System.out.println(
                        labels.getString(<span class="hljs-string">"base64"</span>) + <span class="hljs-string">" [-"</span> + StringHelper.replace(oneLetterOptions, <span class="hljs-string">":"</span>, <span class="hljs-string">""</span>) + <span class="hljs-string">"] &lt;"</span> + labels.getString(<span class="hljs-string">"files"</span>) + <span class="hljs-string">"&gt;\n"</span> +
                        labels.getString(<span class="hljs-string">"purpose.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + labels.getString(<span class="hljs-string">"stdin.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">0</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"help.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">1</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"version.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">2</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"about.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">3</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"g.message"</span>) + <span class="hljs-string">" ("</span> + labels.getString(<span class="hljs-string">"default"</span>) + <span class="hljs-string">")\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">4</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"e.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">5</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"l.message"</span>) + <span class="hljs-string">" ("</span> + labels.getString(<span class="hljs-string">"default"</span>) + <span class="hljs-string">")\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">6</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"nolines.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">7</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"d.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">8</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"a.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">9</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"decodegood.message"</span>) + <span class="hljs-string">" ("</span> + labels.getString(<span class="hljs-string">"default"</span>) + <span class="hljs-string">")\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">10</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"x.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">11</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"f.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">12</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"noforce.message"</span>) + <span class="hljs-string">" ("</span> + labels.getString(<span class="hljs-string">"default"</span>) + <span class="hljs-string">")\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">13</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"v.message"</span>) + <span class="hljs-string">" ("</span> + labels.getString(<span class="hljs-string">"default"</span>) + <span class="hljs-string">")\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">14</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"q.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">15</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"Q.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">16</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"file.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">17</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"string.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">18</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"newline.message"</span>) + <span class="hljs-string">"\n"</span> +
                        <span class="hljs-string">" "</span> + StringHelper.postpad(helpFlags[<span class="hljs-number">19</span>] ,maxLength, <span class="hljs-string">' '</span>) + labels.getString(<span class="hljs-string">"nonewline.message"</span>) + <span class="hljs-string">"\n"</span>
                    );
                    System.exit(<span class="hljs-number">0</span>);
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:{
                    <span class="hljs-comment">// print out the version message</span>
                    System.out.println(MessageFormat.format(labels.getString(<span class="hljs-string">"version"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {version}));
                    System.exit(<span class="hljs-number">0</span>);
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:{
                    System.out.println(
                        labels.getString(<span class="hljs-string">"base64"</span>) + <span class="hljs-string">" -- "</span> + labels.getString(<span class="hljs-string">"purpose.message"</span>) + <span class="hljs-string">"\n"</span> +
                        MessageFormat.format(labels.getString(<span class="hljs-string">"copyright"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {<span class="hljs-string">"2001-2002"</span>, <span class="hljs-string">"Stephen Ostermiller (http://ostermiller.org/contact.pl?regarding=Java+Utilities)"</span>}) + <span class="hljs-string">"\n\n"</span> +
                        labels.getString(<span class="hljs-string">"license"</span>)
                    );
                    System.exit(<span class="hljs-number">0</span>);
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'d'</span>:{
                    action = ACTION_DECODE;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span>:{
                    forceDecode = <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:{
                    forceDecode = <span class="hljs-keyword">false</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'e'</span>:{
                    action = ACTION_ENCODE;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'l'</span>:{
                    lineBreaks = <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:{
                    lineBreaks = <span class="hljs-keyword">false</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'g'</span>:{
                    action = ACTION_GUESS;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'x'</span>:{
                    extension = opts.getOptarg();
                    <span class="hljs-keyword">if</span> (extension == <span class="hljs-keyword">null</span>) extension = <span class="hljs-string">""</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:{
                    force = <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:{
                    force = <span class="hljs-keyword">false</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'v'</span>:{
                    printMessages = <span class="hljs-keyword">true</span>;
                    printErrors = <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'q'</span>:{
                    printMessages = <span class="hljs-keyword">false</span>;
                    printErrors = <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'Q'</span>:{
                    printMessages = <span class="hljs-keyword">false</span>;
                    printErrors = <span class="hljs-keyword">false</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: {
                    argumentType = ARGUMENT_FILE;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: {
                    argumentType = ARGUMENT_STRING;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'n'</span>: {
                    decodeEndLine = <span class="hljs-keyword">true</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: {
                    decodeEndLine = <span class="hljs-keyword">false</span>;
                } <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:{
                    System.err.println(labels.getString(<span class="hljs-string">"unknownarg"</span>));
                    System.exit(<span class="hljs-number">1</span>);
                }
            }
        }

        <span class="hljs-keyword">int</span> exitCond = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=opts.getOptind(); i&lt;args.length; i++){
            done = <span class="hljs-keyword">true</span>;
            File source = <span class="hljs-keyword">new</span> File(args[i]);
            <span class="hljs-keyword">if</span> (argumentType == ARGUMENT_STRING || (argumentType == ARGUMENT_GUESS &amp;&amp; !source.exists())){
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">int</span> fileAction = action;
                    <span class="hljs-keyword">if</span> (fileAction == ACTION_GUESS){
                        <span class="hljs-keyword">if</span> (isBase64(args[i])){
                            fileAction = ACTION_DECODE;
                        } <span class="hljs-keyword">else</span> {
                            fileAction = ACTION_ENCODE;
                        }
                    }
                    <span class="hljs-keyword">if</span> (fileAction == ACTION_ENCODE){
                        <span class="hljs-keyword">if</span> (printMessages){
                            System.out.println(labels.getString(<span class="hljs-string">"encodingarg"</span>));
                        }
                        encode(<span class="hljs-keyword">new</span> ByteArrayInputStream(args[i].getBytes()), System.out, lineBreaks);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (printMessages){
                            System.out.println(labels.getString(<span class="hljs-string">"decodingarg"</span>));
                        }
                        decode(<span class="hljs-keyword">new</span> ByteArrayInputStream(args[i].getBytes()), System.out, !forceDecode);
                        <span class="hljs-keyword">if</span> (decodeEndLine) System.out.println();
                    }
                } <span class="hljs-keyword">catch</span> (Base64DecodingException x){
                    <span class="hljs-keyword">if</span>(printErrors){
                        System.err.println(args[i] + <span class="hljs-string">": "</span> + x.getMessage() + <span class="hljs-string">" "</span> + labels.getString(<span class="hljs-string">"unexpectedcharforce"</span>));
                    }
                    exitCond = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">catch</span> (IOException x){
                    <span class="hljs-keyword">if</span>(printErrors){
                        System.err.println(args[i] + <span class="hljs-string">": "</span> + x.getMessage());
                    }
                    exitCond = <span class="hljs-number">1</span>;
                }
            } <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (!source.exists()){
                <span class="hljs-keyword">if</span>(printErrors){
                    System.err.println(MessageFormat.format(labels.getString(<span class="hljs-string">"doesnotexist"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {args[i]}));
                }
                exitCond = <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!source.canRead()){
                <span class="hljs-keyword">if</span>(printErrors){
                    System.err.println(MessageFormat.format(labels.getString(<span class="hljs-string">"cantread"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {args[i]}));
                }
                exitCond = <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">int</span> fileAction = action;
                    <span class="hljs-keyword">if</span> (fileAction == ACTION_GUESS){
                        <span class="hljs-keyword">if</span> (isBase64(source)){
                            fileAction = ACTION_DECODE;
                        } <span class="hljs-keyword">else</span> {
                            fileAction = ACTION_ENCODE;
                        }
                    }
                    String outName = args[i];
                    <span class="hljs-keyword">if</span> (extension.length() &gt; <span class="hljs-number">0</span>){
                        <span class="hljs-keyword">if</span> (fileAction == ACTION_ENCODE){
                            outName = args[i] + <span class="hljs-string">"."</span> + extension;
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">if</span> (args[i].endsWith(<span class="hljs-string">"."</span> + extension)){
                                outName = args[i].substring(<span class="hljs-number">0</span>, args[i].length() - (extension.length() + <span class="hljs-number">1</span>));
                            }
                        }
                    }
                    File outFile = <span class="hljs-keyword">new</span> File(outName);
                    <span class="hljs-keyword">if</span> (!force &amp;&amp; outFile.exists()){
                        <span class="hljs-keyword">if</span>(printErrors){
                            System.err.println(MessageFormat.format(labels.getString(<span class="hljs-string">"overwrite"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {outName}));
                        }
                        exitCond = <span class="hljs-number">1</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(outFile.exists() || outFile.createNewFile()) || !outFile.canWrite()){
                        <span class="hljs-keyword">if</span>(printErrors){
                            System.err.println(MessageFormat.format(labels.getString(<span class="hljs-string">"cantwrite"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {outName}));
                        }
                        exitCond = <span class="hljs-number">1</span>;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (fileAction == ACTION_ENCODE){
                            <span class="hljs-keyword">if</span> (printMessages){
                                System.out.println(MessageFormat.format(labels.getString(<span class="hljs-string">"encoding"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {args[i], outName}));
                            }
                            encode(source, outFile, lineBreaks);
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">if</span> (printMessages){
                                System.out.println(MessageFormat.format(labels.getString(<span class="hljs-string">"decoding"</span>), (Object[])<span class="hljs-keyword">new</span> String[] {args[i], outName}));
                            }
                            decode(source, outFile, !forceDecode);
                        }
                    }
                } <span class="hljs-keyword">catch</span> (Base64DecodingException x){
                    <span class="hljs-keyword">if</span>(printErrors){
                        System.err.println(args[i] + <span class="hljs-string">": "</span> + x.getMessage() + <span class="hljs-string">" "</span> + labels.getString(<span class="hljs-string">"unexpectedcharforce"</span>));
                    }
                    exitCond = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">catch</span> (IOException x){
                    <span class="hljs-keyword">if</span>(printErrors){
                        System.err.println(args[i] + <span class="hljs-string">": "</span> + x.getMessage());
                    }
                    exitCond = <span class="hljs-number">1</span>;
                }
            }
        }
        <span class="hljs-keyword">if</span> (!done){
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">if</span> (action == ACTION_GUESS){
                    <span class="hljs-keyword">if</span>(printErrors){
                        System.err.println(labels.getString(<span class="hljs-string">"cantguess"</span>));
                    }
                    exitCond = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action == ACTION_ENCODE){
                    encode(
                        <span class="hljs-keyword">new</span> BufferedInputStream(System.in),
                        <span class="hljs-keyword">new</span> BufferedOutputStream(System.out),
                        lineBreaks
                    );
                } <span class="hljs-keyword">else</span> {
                    decode(
                        <span class="hljs-keyword">new</span> BufferedInputStream(System.in),
                        <span class="hljs-keyword">new</span> BufferedOutputStream(System.out),
                        !forceDecode
                    );
                    <span class="hljs-keyword">if</span> (decodeEndLine) System.out.println();
                }
            } <span class="hljs-keyword">catch</span> (Base64DecodingException x){
                <span class="hljs-keyword">if</span>(printErrors){
                    System.err.println(x.getMessage() + <span class="hljs-string">" "</span> + labels.getString(<span class="hljs-string">"unexpectedcharforce"</span>));
                }
                exitCond = <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">catch</span> (IOException x){
                <span class="hljs-keyword">if</span>(printErrors){
                    System.err.println(x.getMessage());
                }
                exitCond = <span class="hljs-number">1</span>;
            }
        }
        System.exit(exitCond);
    }

    <span class="hljs-javadoc">/** * Encode a String in Base64. * The String is converted to and from bytes according to the platform's * default character encoding. * No line breaks or other white space are inserted into the encoded data. * *<span class="hljs-javadoctag"> @param</span> string The data to encode. *<span class="hljs-javadoctag"> @return</span> An encoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span>(String string){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(encode(string.getBytes()));
    }

    <span class="hljs-javadoc">/** * Encode a String in Base64. * No line breaks or other white space are inserted into the encoded data. * *<span class="hljs-javadoctag"> @param</span> string The data to encode. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting to and from bytes. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> An encoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span>(String string, String enc) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(encode(string.getBytes(enc)), enc);
    }

    <span class="hljs-javadoc">/** * Encode bytes in Base64. * No line breaks or other white space are inserted into the encoded data. * *<span class="hljs-javadoctag"> @param</span> bytes The data to encode. *<span class="hljs-javadoctag"> @return</span> String with Base64 encoded data. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.04.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encodeToString</span>(<span class="hljs-keyword">byte</span>[] bytes){
        <span class="hljs-keyword">return</span> encodeToString(bytes, <span class="hljs-keyword">false</span>);
    }

    <span class="hljs-javadoc">/** * Encode bytes in Base64. * *<span class="hljs-javadoctag"> @param</span> bytes The data to encode. *<span class="hljs-javadoctag"> @param</span> lineBreaks Whether to insert line breaks every 76 characters in the output. *<span class="hljs-javadoctag"> @return</span> String with Base64 encoded data. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.04.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encodeToString</span>(<span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">boolean</span> lineBreaks){
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(encode(bytes, lineBreaks), <span class="hljs-string">"ASCII"</span>);
        } <span class="hljs-keyword">catch</span> (UnsupportedEncodingException iex){
            <span class="hljs-comment">// ASCII should be supported</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(iex);
        }
    }

    <span class="hljs-javadoc">/** * Encode bytes in Base64. * No line breaks or other white space are inserted into the encoded data. * *<span class="hljs-javadoctag"> @param</span> bytes The data to encode. *<span class="hljs-javadoctag"> @return</span> Encoded bytes. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encode</span>(<span class="hljs-keyword">byte</span>[] bytes){
        <span class="hljs-keyword">return</span> encode(bytes, <span class="hljs-keyword">false</span>);
    }

    <span class="hljs-javadoc">/** * Encode bytes in Base64. * *<span class="hljs-javadoctag"> @param</span> bytes The data to encode. *<span class="hljs-javadoctag"> @param</span> lineBreaks Whether to insert line breaks every 76 characters in the output. *<span class="hljs-javadoctag"> @return</span> Encoded bytes. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.04.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encode</span>(<span class="hljs-keyword">byte</span>[] bytes, <span class="hljs-keyword">boolean</span> lineBreaks){
        ByteArrayInputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);
        <span class="hljs-comment">// calculate the length of the resulting output.</span>
        <span class="hljs-comment">// in general it will be 4/3 the size of the input</span>
        <span class="hljs-comment">// but the input length must be divisible by three.</span>
        <span class="hljs-comment">// If it isn't the next largest size that is divisible</span>
        <span class="hljs-comment">// by three is used.</span>
        <span class="hljs-keyword">int</span> mod;
        <span class="hljs-keyword">int</span> length = bytes.length;
        <span class="hljs-keyword">if</span> ((mod = length % <span class="hljs-number">3</span>) != <span class="hljs-number">0</span>){
            length += <span class="hljs-number">3</span> - mod;
        }
        length = length * <span class="hljs-number">4</span> / <span class="hljs-number">3</span>;
        ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream(length);
        <span class="hljs-keyword">try</span> {
            encode(in, out, lineBreaks);
        } <span class="hljs-keyword">catch</span> (IOException x){
            <span class="hljs-comment">// This can't happen.</span>
            <span class="hljs-comment">// The input and output streams were constructed</span>
            <span class="hljs-comment">// on memory structures that don't actually use IO.</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(x);
        }
        <span class="hljs-keyword">return</span> out.toByteArray();
    }

    <span class="hljs-javadoc">/** * Encode this file in Base64. * Line breaks will be inserted every 76 characters. * *<span class="hljs-javadoctag"> @param</span> fIn File to be encoded (will be overwritten). * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span>(File fIn) <span class="hljs-keyword">throws</span> IOException {
        encode(fIn, fIn, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/** * Encode this file in Base64. * *<span class="hljs-javadoctag"> @param</span> fIn File to be encoded (will be overwritten). *<span class="hljs-javadoctag"> @param</span> lineBreaks Whether to insert line breaks every 76 characters in the output. *<span class="hljs-javadoctag"> @throws</span> IOException if an input or output error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span>(File fIn, <span class="hljs-keyword">boolean</span> lineBreaks) <span class="hljs-keyword">throws</span> IOException {
        encode(fIn, fIn, lineBreaks);
    }

    <span class="hljs-javadoc">/** * Encode this file in Base64. * Line breaks will be inserted every 76 characters. * *<span class="hljs-javadoctag"> @param</span> fIn File to be encoded. *<span class="hljs-javadoctag"> @param</span> fOut File to which the results should be written (may be the same as fIn). *<span class="hljs-javadoctag"> @throws</span> IOException if an input or output error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span>(File fIn, File fOut) <span class="hljs-keyword">throws</span> IOException {
        encode(fIn, fOut, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/** * Encode this file in Base64. * *<span class="hljs-javadoctag"> @param</span> fIn File to be encoded. *<span class="hljs-javadoctag"> @param</span> fOut File to which the results should be written (may be the same as fIn). *<span class="hljs-javadoctag"> @param</span> lineBreaks Whether to insert line breaks every 76 characters in the output. *<span class="hljs-javadoctag"> @throws</span> IOException if an input or output error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span>(File fIn, File fOut, <span class="hljs-keyword">boolean</span> lineBreaks) <span class="hljs-keyword">throws</span> IOException {
        File temp = <span class="hljs-keyword">null</span>;
        InputStream in = <span class="hljs-keyword">null</span>;
        OutputStream out = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(fIn));
            temp = File.createTempFile(<span class="hljs-string">"Base64"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
            out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(temp));
            encode(in, out, lineBreaks);
            in.close();
            in = <span class="hljs-keyword">null</span>;
            out.flush();
            out.close();
            out = <span class="hljs-keyword">null</span>;
            FileHelper.move(temp, fOut, <span class="hljs-keyword">true</span>);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>){
                in.close();
                in = <span class="hljs-keyword">null</span>;
            }
            <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>){
                out.flush();
                out.close();
                out = <span class="hljs-keyword">null</span>;
            }
        }
    }

    <span class="hljs-javadoc">/** * Encode data from the InputStream to the OutputStream in Base64. * Line breaks are inserted every 76 characters in the output. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be encoded. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write encoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if there is a problem reading or writing. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span>(InputStream in, OutputStream out) <span class="hljs-keyword">throws</span> IOException {
        encode(in, out, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/** * Encode data from the InputStream to the OutputStream in Base64. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be encoded. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write encoded data. *<span class="hljs-javadoctag"> @param</span> lineBreaks Whether to insert line breaks every 76 characters in the output. *<span class="hljs-javadoctag"> @throws</span> IOException if there is a problem reading or writing. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span>(InputStream in, OutputStream out, <span class="hljs-keyword">boolean</span> lineBreaks) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-comment">// Base64 encoding converts three bytes of input to</span>
        <span class="hljs-comment">// four bytes of output</span>
        <span class="hljs-keyword">int</span>[] inBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];
        <span class="hljs-keyword">int</span> lineCount = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">while</span> (!done &amp;&amp; (inBuffer[<span class="hljs-number">0</span>] = in.read()) != END_OF_INPUT){
            <span class="hljs-comment">// Fill the buffer</span>
            inBuffer[<span class="hljs-number">1</span>] = in.read();
            inBuffer[<span class="hljs-number">2</span>] = in.read();

            <span class="hljs-comment">// Calculate the out Buffer</span>
            <span class="hljs-comment">// The first byte of our in buffer will always be valid</span>
            <span class="hljs-comment">// but we must check to make sure the other two bytes</span>
            <span class="hljs-comment">// are not END_OF_INPUT before using them.</span>
            <span class="hljs-comment">// The basic idea is that the three bytes get split into</span>
            <span class="hljs-comment">// four bytes along these lines:</span>
            <span class="hljs-comment">// [AAAAAABB] [BBBBCCCC] [CCDDDDDD]</span>
            <span class="hljs-comment">// [xxAAAAAA] [xxBBBBBB] [xxCCCCCC] [xxDDDDDD]</span>
            <span class="hljs-comment">// bytes are considered to be zero when absent.</span>
            <span class="hljs-comment">// the four bytes are then mapped to common ASCII symbols</span>

            <span class="hljs-comment">// A's: first six bits of first byte</span>
            out.write(base64Chars[ inBuffer[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">2</span> ]);
            <span class="hljs-keyword">if</span> (inBuffer[<span class="hljs-number">1</span>] != END_OF_INPUT){
                <span class="hljs-comment">// B's: last two bits of first byte, first four bits of second byte</span>
                out.write(base64Chars [(( inBuffer[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">4</span> ) &amp; <span class="hljs-number">0x30</span>) | (inBuffer[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>) ]);
                <span class="hljs-keyword">if</span> (inBuffer[<span class="hljs-number">2</span>] != END_OF_INPUT){
                    <span class="hljs-comment">// C's: last four bits of second byte, first two bits of third byte</span>
                    out.write(base64Chars [((inBuffer[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3c</span>) | (inBuffer[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">6</span>) ]);
                    <span class="hljs-comment">// D's: last six bits of third byte</span>
                    out.write(base64Chars [inBuffer[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x3F</span>]);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// C's: last four bits of second byte</span>
                    out.write(base64Chars [((inBuffer[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3c</span>)]);
                    <span class="hljs-comment">// an equals sign for a character that is not a Base64 character</span>
                    out.write(<span class="hljs-string">'='</span>);
                    done = <span class="hljs-keyword">true</span>;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// B's: last two bits of first byte</span>
                out.write(base64Chars [(( inBuffer[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">4</span> ) &amp; <span class="hljs-number">0x30</span>)]);
                <span class="hljs-comment">// an equal signs for characters that is not a Base64 characters</span>
                out.write(<span class="hljs-string">'='</span>);
                out.write(<span class="hljs-string">'='</span>);
                done = <span class="hljs-keyword">true</span>;
            }
            lineCount += <span class="hljs-number">4</span>;
            <span class="hljs-keyword">if</span> (lineBreaks &amp;&amp; lineCount &gt;= <span class="hljs-number">76</span>){
                out.write(<span class="hljs-string">'\n'</span>);
                lineCount = <span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-keyword">if</span> (lineBreaks &amp;&amp; lineCount &gt;= <span class="hljs-number">1</span>){
            out.write(<span class="hljs-string">'\n'</span>);
            lineCount = <span class="hljs-number">0</span>;
        }
        out.flush();
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * The String is converted to and from bytes according to the platform's * default character encoding. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decode</span>(String string){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(string.getBytes()));
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting to and from bytes. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decode</span>(String string, String enc) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(string.getBytes(enc)), enc);
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> encIn Character encoding to use when converting input to bytes (should not matter because Base64 data is designed to survive most character encodings) *<span class="hljs-javadoctag"> @param</span> encOut Character encoding to use when converting decoded bytes to output. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decode</span>(String string, String encIn, String encOut) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(string.getBytes(encIn)), encOut);
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * The String is converted to and from bytes according to the platform's * default character encoding. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(String string){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(string.getBytes()));
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting to and from bytes. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(String string, String enc) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(string.getBytes(enc)), enc);
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> encIn Character encoding to use when converting input to bytes (should not matter because Base64 data is designed to survive most character encodings) *<span class="hljs-javadoctag"> @param</span> encOut Character encoding to use when converting decoded bytes to output. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(String string, String encIn, String encOut) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(string.getBytes(encIn)), encOut);
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String to an OutputStream. * Characters that are not part of the Base64 alphabet are ignored * in the input. * The String is converted from bytes according to the platform's * default character encoding. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeToStream</span>(String string, OutputStream out) <span class="hljs-keyword">throws</span> IOException {
        decode(<span class="hljs-keyword">new</span> ByteArrayInputStream(string.getBytes()), out);
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String to an OutputStream. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting to and from bytes. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write decoded data. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeToStream</span>(String string, String enc, OutputStream out) <span class="hljs-keyword">throws</span> UnsupportedEncodingException, IOException {
        decode(<span class="hljs-keyword">new</span> ByteArrayInputStream(string.getBytes(enc)), out);
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * The String is converted from bytes according to the platform's * default character encoding. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @return</span> decoded data. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decodeToBytes</span>(String string){
        <span class="hljs-keyword">return</span> decode(string.getBytes());
    }

    <span class="hljs-javadoc">/** * Decode a Base64 encoded String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> string The data to decode. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting from bytes. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> decoded data. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decodeToBytes</span>(String string, String enc) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> decode(string.getBytes(enc));
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded bytes. * Characters that are not part of the Base64 alphabet are ignored * in the input. * The String is converted to bytes according to the platform's * default character encoding. * *<span class="hljs-javadoctag"> @param</span> bytes The data to decode. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(<span class="hljs-keyword">byte</span>[] bytes){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(bytes));
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded bytes. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> bytes The data to decode. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting to and from bytes. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. *<span class="hljs-javadoctag"> @return</span> A decoded String. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(<span class="hljs-keyword">byte</span>[] bytes, String enc) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decode(bytes), enc);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded bytes. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> bytes The data to decode. *<span class="hljs-javadoctag"> @return</span> Decoded bytes. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decodeToBytes</span>(<span class="hljs-keyword">byte</span>[] bytes){
        <span class="hljs-keyword">return</span> decode(bytes);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded bytes. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> bytes The data to decode. *<span class="hljs-javadoctag"> @return</span> Decoded bytes. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decode</span>(<span class="hljs-keyword">byte</span>[] bytes){
        ByteArrayInputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);
        <span class="hljs-comment">// calculate the length of the resulting output.</span>
        <span class="hljs-comment">// in general it will be at most 3/4 the size of the input</span>
        <span class="hljs-comment">// but the input length must be divisible by four.</span>
        <span class="hljs-comment">// If it isn't the next largest size that is divisible</span>
        <span class="hljs-comment">// by four is used.</span>
        <span class="hljs-keyword">int</span> mod;
        <span class="hljs-keyword">int</span> length = bytes.length;
        <span class="hljs-keyword">if</span> ((mod = length % <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>){
            length += <span class="hljs-number">4</span> - mod;
        }
        length = length * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;
        ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream(length);
        <span class="hljs-keyword">try</span> {
            decode(in, out, <span class="hljs-keyword">false</span>);
        } <span class="hljs-keyword">catch</span> (IOException x){
            <span class="hljs-comment">// This can't happen.</span>
            <span class="hljs-comment">// The input and output streams were constructed</span>
            <span class="hljs-comment">// on memory structures that don't actually use IO.</span>
             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(x);
        }
        <span class="hljs-keyword">return</span> out.toByteArray();
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded bytes to the an OutputStream. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> bytes The data to decode. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(<span class="hljs-keyword">byte</span>[] bytes, OutputStream out) <span class="hljs-keyword">throws</span> IOException {
        ByteArrayInputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);
        decode(in, out, <span class="hljs-keyword">false</span>);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded bytes to the an OutputStream. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> bytes The data to decode. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeToStream</span>(<span class="hljs-keyword">byte</span>[] bytes, OutputStream out) <span class="hljs-keyword">throws</span> IOException {
        ByteArrayInputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);
        decode(in, out, <span class="hljs-keyword">false</span>);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from one file to the other. * Characters in the Base64 alphabet, white space and equals sign are * expected to be in urlencoded data. The presence of other characters * could be a sign that the data is corrupted. * *<span class="hljs-javadoctag"> @param</span> fIn File to be decoded (will be overwritten). *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(File fIn) <span class="hljs-keyword">throws</span> IOException {
        decode(fIn, fIn, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from one file to the other. * Characters in the Base64 alphabet, white space and equals sign are * expected to be in urlencoded data. The presence of other characters * could be a sign that the data is corrupted. * *<span class="hljs-javadoctag"> @param</span> fIn File to be decoded (will be overwritten). *<span class="hljs-javadoctag"> @param</span> throwExceptions Whether to throw exceptions when unexpected data is encountered. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered when throwExceptions is specified. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(File fIn, <span class="hljs-keyword">boolean</span> throwExceptions) <span class="hljs-keyword">throws</span> IOException {
        decode(fIn, fIn, throwExceptions);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from one file to the other. * Characters in the Base64 alphabet, white space and equals sign are * expected to be in urlencoded data. The presence of other characters * could be a sign that the data is corrupted. * *<span class="hljs-javadoctag"> @param</span> fIn File to be decoded. *<span class="hljs-javadoctag"> @param</span> fOut File to which the results should be written (may be the same as fIn). *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(File fIn, File fOut) <span class="hljs-keyword">throws</span> IOException {
        decode(fIn, fOut, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from one file to the other. * Characters in the Base64 alphabet, white space and equals sign are * expected to be in urlencoded data. The presence of other characters * could be a sign that the data is corrupted. * *<span class="hljs-javadoctag"> @param</span> fIn File to be decoded. *<span class="hljs-javadoctag"> @param</span> fOut File to which the results should be written (may be the same as fIn). *<span class="hljs-javadoctag"> @param</span> throwExceptions Whether to throw exceptions when unexpected data is encountered. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered when throwExceptions is specified. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(File fIn, File fOut, <span class="hljs-keyword">boolean</span> throwExceptions) <span class="hljs-keyword">throws</span> IOException {
        File temp = <span class="hljs-keyword">null</span>;
        InputStream in = <span class="hljs-keyword">null</span>;
        OutputStream out = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(fIn));
            temp = File.createTempFile(<span class="hljs-string">"Base64"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
            out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(temp));
            decode(in, out, throwExceptions);
            in.close();
            in = <span class="hljs-keyword">null</span>;
            out.flush();
            out.close();
            out = <span class="hljs-keyword">null</span>;
            FileHelper.move(temp, fOut, <span class="hljs-keyword">true</span>);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>){
                <span class="hljs-keyword">try</span> {
                    in.close();
                } <span class="hljs-keyword">catch</span> (IOException ignore){
                     <span class="hljs-keyword">if</span> (throwExceptions) <span class="hljs-keyword">throw</span> ignore;
                }
                in = <span class="hljs-keyword">null</span>;
            }
            <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>){
                <span class="hljs-keyword">try</span> {
                    out.flush();
                    out.close();
                } <span class="hljs-keyword">catch</span> (IOException ignore){
                     <span class="hljs-keyword">if</span> (throwExceptions) <span class="hljs-keyword">throw</span> ignore;
                }
                out = <span class="hljs-keyword">null</span>;
            }
        }
    }

    <span class="hljs-javadoc">/** * Reads the next (decoded) Base64 character from the input stream. * Non Base64 characters are skipped. * *<span class="hljs-javadoctag"> @param</span> in Stream from which bytes are read. *<span class="hljs-javadoctag"> @param</span> throwExceptions Throw an exception if an unexpected character is encountered. *<span class="hljs-javadoctag"> @return</span> the next Base64 character from the stream or -1 if there are no more Base64 characters on the stream. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO Error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered when throwExceptions is specified. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readBase64</span>(InputStream in, <span class="hljs-keyword">boolean</span> throwExceptions) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">int</span> read;
        <span class="hljs-keyword">int</span> numPadding = <span class="hljs-number">0</span>;
        do {
            read = in.read();
            <span class="hljs-keyword">if</span> (read == END_OF_INPUT) <span class="hljs-keyword">return</span> END_OF_INPUT;
            read = reverseBase64Chars[(<span class="hljs-keyword">byte</span>)read];
            <span class="hljs-keyword">if</span> (throwExceptions &amp;&amp; (read == NON_BASE_64 || (numPadding &gt; <span class="hljs-number">0</span> &amp;&amp; read &gt; NON_BASE_64))){
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Base64DecodingException (
                    MessageFormat.format(
                        labels.getString(<span class="hljs-string">"unexpectedchar"</span>),
                        (Object[])<span class="hljs-keyword">new</span> String[] {
                            <span class="hljs-string">"'"</span> + (<span class="hljs-keyword">char</span>)read + <span class="hljs-string">"' (0x"</span> + Integer.toHexString(read) + <span class="hljs-string">")"</span>
                        }
                    ),
                    (<span class="hljs-keyword">char</span>)read
                );
            }
            <span class="hljs-keyword">if</span> (read == NON_BASE_64_PADDING){
                numPadding++;
            }
        } <span class="hljs-keyword">while</span> (read &lt;= NON_BASE_64);
        <span class="hljs-keyword">return</span> read;
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from the InputStream to a byte array. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be decoded. *<span class="hljs-javadoctag"> @return</span> decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">decodeToBytes</span>(InputStream in) <span class="hljs-keyword">throws</span> IOException {
        ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream();
        decode(in, out, <span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">return</span> out.toByteArray();
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from the InputStream to a String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * Bytes are converted to characters in the output String according to the platform's * default character encoding. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be decoded. *<span class="hljs-javadoctag"> @return</span> decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(InputStream in) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decodeToBytes(in));
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from the InputStream to a String. * Characters that are not part of the Base64 alphabet are ignored * in the input. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be decoded. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting bytes to characters. *<span class="hljs-javadoctag"> @return</span> decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs.Throws: *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.02.16 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decodeToString</span>(InputStream in, String enc) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decodeToBytes(in), enc);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from the InputStream to the OutputStream. * Characters in the Base64 alphabet, white space and equals sign are * expected to be in urlencoded data. The presence of other characters * could be a sign that the data is corrupted. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be decoded. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write decoded data. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(InputStream in, OutputStream out) <span class="hljs-keyword">throws</span> IOException {
        decode(in, out, <span class="hljs-keyword">true</span>);
    }

    <span class="hljs-javadoc">/** * Decode Base64 encoded data from the InputStream to the OutputStream. * Characters in the Base64 alphabet, white space and equals sign are * expected to be in urlencoded data. The presence of other characters * could be a sign that the data is corrupted. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data that needs to be decoded. *<span class="hljs-javadoctag"> @param</span> out Stream to which to write decoded data. *<span class="hljs-javadoctag"> @param</span> throwExceptions Whether to throw exceptions when unexpected data is encountered. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. *<span class="hljs-javadoctag"> @throws</span> Base64DecodingException if unexpected data is encountered when throwExceptions is specified. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span>(InputStream in, OutputStream out, <span class="hljs-keyword">boolean</span> throwExceptions) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-comment">// Base64 decoding converts four bytes of input to three bytes of output</span>
        <span class="hljs-keyword">int</span>[] inBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];

        <span class="hljs-comment">// read bytes unmapping them from their ASCII encoding in the process</span>
        <span class="hljs-comment">// we must read at least two bytes to be able to output anything</span>
        <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">while</span> (!done &amp;&amp; (inBuffer[<span class="hljs-number">0</span>] = readBase64(in, throwExceptions)) != END_OF_INPUT
            &amp;&amp; (inBuffer[<span class="hljs-number">1</span>] = readBase64(in, throwExceptions)) != END_OF_INPUT){
            <span class="hljs-comment">// Fill the buffer</span>
            inBuffer[<span class="hljs-number">2</span>] = readBase64(in, throwExceptions);
            inBuffer[<span class="hljs-number">3</span>] = readBase64(in, throwExceptions);

            <span class="hljs-comment">// Calculate the output</span>
            <span class="hljs-comment">// The first two bytes of our in buffer will always be valid</span>
            <span class="hljs-comment">// but we must check to make sure the other two bytes</span>
            <span class="hljs-comment">// are not END_OF_INPUT before using them.</span>
            <span class="hljs-comment">// The basic idea is that the four bytes will get reconstituted</span>
            <span class="hljs-comment">// into three bytes along these lines:</span>
            <span class="hljs-comment">// [xxAAAAAA] [xxBBBBBB] [xxCCCCCC] [xxDDDDDD]</span>
            <span class="hljs-comment">// [AAAAAABB] [BBBBCCCC] [CCDDDDDD]</span>
            <span class="hljs-comment">// bytes are considered to be zero when absent.</span>

            <span class="hljs-comment">// six A and two B</span>
            out.write(inBuffer[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">2</span> | inBuffer[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>);
            <span class="hljs-keyword">if</span> (inBuffer[<span class="hljs-number">2</span>] != END_OF_INPUT){
                <span class="hljs-comment">// four B and four C</span>
                out.write(inBuffer[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">4</span> | inBuffer[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">2</span>);
                <span class="hljs-keyword">if</span> (inBuffer[<span class="hljs-number">3</span>] != END_OF_INPUT){
                    <span class="hljs-comment">// two C and six D</span>
                    out.write(inBuffer[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">6</span> | inBuffer[<span class="hljs-number">3</span>]);
                } <span class="hljs-keyword">else</span> {
                    done = <span class="hljs-keyword">true</span>;
                }
            } <span class="hljs-keyword">else</span> {
                done = <span class="hljs-keyword">true</span>;
            }
        }
        out.flush();
    }

    <span class="hljs-javadoc">/** * Determines if the byte array is in base64 format. * &lt;p&gt; * Data will be considered to be in base64 format if it contains * only base64 characters and whitespace with equals sign padding * on the end so that the number of base64 characters is divisible * by four. * &lt;p&gt; * It is possible for data to be in base64 format but for it to not * meet these stringent requirements. It is also possible for data * to meet these requirements even though decoding it would not make * any sense. This method should be used as a guide but it is not * authoritative because of the possibility of these false positives * and false negatives. * &lt;p&gt; * Additionally, extra data such as headers or footers may throw * this method off the scent and cause it to return false. * *<span class="hljs-javadoctag"> @param</span> bytes data that could be in base64 format. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBase64</span>(<span class="hljs-keyword">byte</span>[] bytes){
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> isBase64(<span class="hljs-keyword">new</span> ByteArrayInputStream(bytes));
        } <span class="hljs-keyword">catch</span> (IOException x){
            <span class="hljs-comment">// This can't happen.</span>
            <span class="hljs-comment">// The input and output streams were constructed</span>
            <span class="hljs-comment">// on memory structures that don't actually use IO.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
    }

    <span class="hljs-javadoc">/** * Determines if the String is in base64 format. * The String is converted to and from bytes according to the platform's * default character encoding. * &lt;p&gt; * Data will be considered to be in base64 format if it contains * only base64 characters and whitespace with equals sign padding * on the end so that the number of base64 characters is divisible * by four. * &lt;p&gt; * It is possible for data to be in base64 format but for it to not * meet these stringent requirements. It is also possible for data * to meet these requirements even though decoding it would not make * any sense. This method should be used as a guide but it is not * authoritative because of the possibility of these false positives * and false negatives. * &lt;p&gt; * Additionally, extra data such as headers or footers may throw * this method off the scent and cause it to return false. * *<span class="hljs-javadoctag"> @param</span> string String that may be in base64 format. *<span class="hljs-javadoctag"> @return</span> Best guess as to whether the data is in base64 format. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBase64</span>(String string){
        <span class="hljs-keyword">return</span> isBase64(string.getBytes());
    }

    <span class="hljs-javadoc">/** * Determines if the String is in base64 format. * &lt;p&gt; * Data will be considered to be in base64 format if it contains * only base64 characters and whitespace with equals sign padding * on the end so that the number of base64 characters is divisible * by four. * &lt;p&gt; * It is possible for data to be in base64 format but for it to not * meet these stringent requirements. It is also possible for data * to meet these requirements even though decoding it would not make * any sense. This method should be used as a guide but it is not * authoritative because of the possibility of these false positives * and false negatives. * &lt;p&gt; * Additionally, extra data such as headers or footers may throw * this method off the scent and cause it to return false. * *<span class="hljs-javadoctag"> @param</span> string String that may be in base64 format. *<span class="hljs-javadoctag"> @param</span> enc Character encoding to use when converting to bytes. *<span class="hljs-javadoctag"> @return</span> Best guess as to whether the data is in base64 format. *<span class="hljs-javadoctag"> @throws</span> UnsupportedEncodingException if the character encoding specified is not supported. */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBase64</span>(String string, String enc) <span class="hljs-keyword">throws</span> UnsupportedEncodingException {
        <span class="hljs-keyword">return</span> isBase64(string.getBytes(enc));
    }

    <span class="hljs-javadoc">/** * Determines if the File is in base64 format. * &lt;p&gt; * Data will be considered to be in base64 format if it contains * only base64 characters and whitespace with equals sign padding * on the end so that the number of base64 characters is divisible * by four. * &lt;p&gt; * It is possible for data to be in base64 format but for it to not * meet these stringent requirements. It is also possible for data * to meet these requirements even though decoding it would not make * any sense. This method should be used as a guide but it is not * authoritative because of the possibility of these false positives * and false negatives. * &lt;p&gt; * Additionally, extra data such as headers or footers may throw * this method off the scent and cause it to return false. * *<span class="hljs-javadoctag"> @param</span> fIn File that may be in base64 format. *<span class="hljs-javadoctag"> @return</span> Best guess as to whether the data is in base64 format. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBase64</span>(File fIn) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">return</span> isBase64(<span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(fIn)));
    }

    <span class="hljs-javadoc">/** * Reads data from the stream and determines if it is * in base64 format. * &lt;p&gt; * Data will be considered to be in base64 format if it contains * only base64 characters and whitespace with equals sign padding * on the end so that the number of base64 characters is divisible * by four. * &lt;p&gt; * It is possible for data to be in base64 format but for it to not * meet these stringent requirements. It is also possible for data * to meet these requirements even though decoding it would not make * any sense. This method should be used as a guide but it is not * authoritative because of the possibility of these false positives * and false negatives. * &lt;p&gt; * Additionally, extra data such as headers or footers may throw * this method off the scent and cause it to return false. * *<span class="hljs-javadoctag"> @param</span> in Stream from which to read data to be tested. *<span class="hljs-javadoctag"> @return</span> Best guess as to whether the data is in base64 format. *<span class="hljs-javadoctag"> @throws</span> IOException if an IO error occurs. * *<span class="hljs-javadoctag"> @since</span> ostermillerutils 1.00.00 */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBase64</span>(InputStream in) <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-keyword">long</span> numBase64Chars = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> numPadding = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> read;

        <span class="hljs-keyword">while</span> ((read = in.read()) != -<span class="hljs-number">1</span>){
            read = reverseBase64Chars[read];
            <span class="hljs-keyword">if</span> (read == NON_BASE_64){
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (read == NON_BASE_64_WHITESPACE){
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (read == NON_BASE_64_PADDING){
                numPadding++;
                numBase64Chars++;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numPadding &gt; <span class="hljs-number">0</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            } <span class="hljs-keyword">else</span> {
                numBase64Chars++;
            }
        }
        <span class="hljs-keyword">if</span> (numBase64Chars == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (numBase64Chars % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}

</code></pre>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
