<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>一个优秀的Unity3d开发者必备的几种设计模式 « NotBeCN</title>
  <meta name="description" content="                                                                      文章目录[点击展开](?)[+]                   Unity脚本编程                     如何写脚本架构            参考书...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/09/15/weixin_33932129_90125867.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">一个优秀的Unity3d开发者必备的几种设计模式</h1>
    <p class="post-meta">Sep 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div> 
    <div> 
     <div class="post"> 
      <h1><br></h1> 
      <div class="clear"></div> 
      <div class="postBody"> 
       <div style="clear:both;"></div> 
       <div class="cnblogs_toc"> 
        <p><span><a title="系统根据文章中H1到H6标签自动生成文章目录" id="TocTitle" href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#" rel="nofollow">文章目录[点击展开](?)</a></span><a title="展开" id="TocTitleSymbol" href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#" rel="nofollow">[+]</a></p> 
        <ol style="line-height:160%;margin-left:14px;">
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t0" rel="nofollow">Unity脚本编程</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t1" rel="nofollow">如何写脚本架构</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t2" rel="nofollow">参考书籍</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t3" rel="nofollow">设计模式</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t4" rel="nofollow">原则1单一职责原则 </a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t5" rel="nofollow">用一个类描述动物呼吸这个场景</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t6" rel="nofollow">当需求变动</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t7" rel="nofollow">改动量小的方法</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t8" rel="nofollow">隐患</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t9" rel="nofollow">另一种修改方式</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t10" rel="nofollow">遵循单一职责原的优点有</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t11" rel="nofollow">原则2里氏替换原则</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t12" rel="nofollow">名字的由来</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t13" rel="nofollow">定义</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t14" rel="nofollow">继承的风险</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t15" rel="nofollow">运行结果</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t16" rel="nofollow">需求变动</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t17" rel="nofollow">类B运行结果</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t18" rel="nofollow">影响了正常的功能</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t19" rel="nofollow">里氏替换原则通俗的来讲就是</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t20" rel="nofollow">原则3依赖倒置原则</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t21" rel="nofollow">定义</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t22" rel="nofollow">依赖倒置原则核心思想</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t23" rel="nofollow">情景举例</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t24" rel="nofollow">运行结果</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t25" rel="nofollow">需求变动</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t26" rel="nofollow">抽象的接口</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t27" rel="nofollow">运行结果</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t28" rel="nofollow">在实际编程中我们一般需要做到如下3点</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t29" rel="nofollow">原则4接口隔离原则</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t30" rel="nofollow">定义</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t31" rel="nofollow">未遵循接口隔离原则的设计</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t32" rel="nofollow">示例代码</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t33" rel="nofollow">遵循接口隔离原则的设计</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t34" rel="nofollow">示例代码</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t35" rel="nofollow">注意几点</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t36" rel="nofollow">原则5迪米特法则</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t37" rel="nofollow">定义</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t38" rel="nofollow">最少知道原则</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t39" rel="nofollow">违反迪米特法则的设计</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t40" rel="nofollow">修改后的代码</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t41" rel="nofollow">主要的变化</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t42" rel="nofollow">总结</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t43" rel="nofollow">原则6开闭原则</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t44" rel="nofollow">定义</a></li> 
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t45" rel="nofollow">如何遵守</a></li> 
          </ol></li> 
         <li> <a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t46" rel="nofollow">如何去遵守这六个原则</a>
          <ol>
           <li><a href="http://www.cnblogs.com/zhaoqingqing/p/4288454.html#t47" rel="nofollow">说明</a></li>
          </ol></li> 
        </ol>
       </div> 
       <div style="clear:both;">
        <br>
       </div> 
       <div class="blogpost-body"> 
        <h2> <a name="t0"></a><strong>Unity脚本编程</strong> </h2> 
        <p>众所周知，unity的编程属于脚本化，脚本没有一个具体的概念跟架构， 导致在项目过程中，经常出现哪里需要实现什么功能，就随便添加脚本， <br> 结果，就造成了一片混乱，不好管理。 </p> 
        <p><br> 更有甚者，自己的写的代码闲置一段时间后，再去想找某个功能的实现，都要在视图中翻来覆去找半天。 <br> 哎!请容许我在此感叹一声，这还是你写的东西么？<img alt="" src="http://www.unitymanual.com/static/image/smiley/default/20119007.gif"><br> 因此，一个好的设计模式是多么的重要啊， </p> 
        <h3> <a name="t1"></a>如何写脚本架构</h3> 
        <p>那么，我们在使用unity3d开发东西的时候，脚本架构到底应该如何来写？ <br> 呵呵... </p> 
        <p><br> 其实，我也给不了你们具体答案，因为每个人的开发习惯，每个团队的开发模式也各有千秋， <br> so，在此我只做几种设计模式的总结， </p> 
        <h3> <a name="t2"></a>参考书籍</h3> 
        <p>主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章， <br> 但主要内容还是我本人的一些经验以及感悟。 <br> 写出来的目的一方面是系统地整理一下，一方面也与广大的网友分享， <br> 至于你们到底如何使用， <br> 望君斟酌啊!<img alt="" src="http://www.unitymanual.com/static/image/smiley/default/20119000.gif"></p> 
        <h3> <a name="t3"></a>设计模式</h3> 
        <p>设计模式对编程人员来说，的确非常重要。 <br> 当然，如果大家的理解跟我有所不同，欢迎留言，大家共同探讨。 </p> 
        <ul>
         <li>原则1：单一职责 </li> 
         <li>原则2：里氏替换原则（子类扩展但不改变父类功能） </li> 
         <li>原则3：依赖倒置原则 </li> 
         <li>原则4：接口隔离原则 </li> 
         <li>原则5：迪米特法则（最少知道原则） </li> 
         <li>原则6：开闭原则 <h2> <a name="t4"></a><strong>原则1：单一职责原则</strong> </h2> <p>说到单一职责原则，很多人都会不屑一顾。 <br> 因为它太简单了，稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。 <br> 在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。 <br> 而避免出现这一问题的方法便是遵循单一职责原则。 <br> 虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。 <br> 为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责被分化成了更细的职责。 </p> <h3> <a name="t5"></a><strong>用一个类描述动物呼吸这个场景</strong> </h3> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> Animal
{

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> breathe(<span style="color:rgb(0,0,255);">string</span> animal)
    {
        Debug.Log(animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸空气</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    Animal animal = <span style="color:rgb(0,0,255);">new</span> Animal();

    <span style="color:rgb(0,0,255);">void</span> Start()
    {

        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">牛</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">羊</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">猪</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">运行结果：
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">牛呼吸空气
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">羊呼吸空气
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">猪呼吸空气</span></pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h3> <a name="t6"></a>当需求变动</h3> <p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。</p> <p>修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> Terrestrial
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> breathe(String animal)
    {
        Debug.Log(animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸空气</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,0,255);">class</span> Aquatic
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> breathe(String animal)
    {
        Debug.Log(animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸水</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> main(String[] args)
    {
        Terrestrial terrestrial = <span style="color:rgb(0,0,255);">new</span> Terrestrial();
        terrestrial.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">牛</span><span style="color:rgb(128,0,0);">"</span>);
        terrestrial.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">羊</span><span style="color:rgb(128,0,0);">"</span>);
        terrestrial.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">猪</span><span style="color:rgb(128,0,0);">"</span>);

        Aquatic aquatic = <span style="color:rgb(0,0,255);">new</span> Aquatic();
        aquatic.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">鱼</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">运行结果：
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">牛呼吸空气
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">羊呼吸空气
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">猪呼吸空气
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">鱼呼吸水</span></pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h3> <a name="t7"></a>改动量小的方法</h3> <p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。 <br> 而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> Animal
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> breathe(String animal)
    {
        <span style="color:rgb(0,0,255);">if</span> (<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">鱼</span><span style="color:rgb(128,0,0);">"</span> == animal)
        {
            Debug.Log((animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸水</span><span style="color:rgb(128,0,0);">"</span>));
        }
        <span style="color:rgb(0,0,255);">else</span>
        {
            Debug.Log((animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸空气</span><span style="color:rgb(128,0,0);">"</span>));
        }
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> main(String[] args)
    {
        Animal animal = <span style="color:rgb(0,0,255);">new</span> Animal();
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">牛</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">羊</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">猪</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">鱼</span><span style="color:rgb(128,0,0);">"</span>);
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h3> <a name="t8"></a>隐患</h3> <p>可以看到，这种修改方式要简单的多。 <br> 但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼， <br> 则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险， <br> 也许某一天你会发现程序运行的结果变为“牛呼吸水”了。 <br> 这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。 </p> <h3> <a name="t9"></a>另一种修改方式</h3> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> Animal
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> breathe(String animal)
    {
        Debug.Log(animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸空气</span><span style="color:rgb(128,0,0);">"</span>);
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> breathe2(String animal)
    {
        Debug.Log(animal + <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">呼吸水</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> main(String[] args)
    {
        Animal animal = <span style="color:rgb(0,0,255);">new</span> Animal();
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">牛</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">羊</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">猪</span><span style="color:rgb(128,0,0);">"</span>);
        animal.breathe2(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">鱼</span><span style="color:rgb(128,0,0);">"</span>);
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则， <br> 但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点， <br> 那么在实际编程中，采用哪一中呢？ <br> 其实这真的比较难说，需要根据实际情况来确定。 <br> 我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则。 </p> <h3> <a name="t10"></a>遵循单一职责原的优点有</h3> </li> 
         <li><span style="color:rgb(0,0,255);">可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； </span></li> 
         <li><span style="color:rgb(0,0,255);">提高类的可读性，提高系统的可维护性； </span></li> 
         <li> <span style="color:rgb(0,0,255);">变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</span> <p><span style="color:rgb(255,0,0);">需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</span></p> <h2> <a name="t11"></a><strong>原则2：里氏替换原则</strong> </h2> <h3> <a name="t12"></a>名字的由来</h3> <p>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。 <br> 其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。 <br> 简单来说的话，就是当我们使用继承时，遵循里氏替换原则。 </p> <h3> <a name="t13"></a>定义</h3> <p><span style="color:rgb(255,0,0);">注：类B继承类A时，除添加新的方法完成新增功外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 <br></span>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约， <br> 虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改， <br> 就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。 <br> 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。 <br> 比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承， <br> 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后， <br> 所有涉及到子类的功能都有可能会产生故障。 </p> <h3> <a name="t14"></a>继承的风险</h3> <p>那就让我们一起看看继承的风险，如下：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> A
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">int</span> func1(<span style="color:rgb(0,0,255);">int</span> a, <span style="color:rgb(0,0,255);">int</span> b)
    {
        <span style="color:rgb(0,0,255);">return</span> a - b;
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">void</span> Start()
    {
        A a = <span style="color:rgb(0,0,255);">new</span> A();
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">100-50=</span><span style="color:rgb(128,0,0);">"</span> + a.func1(<span style="color:rgb(128,0,128);">100</span>, <span style="color:rgb(128,0,128);">50</span>));
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">100-80=</span><span style="color:rgb(128,0,0);">"</span> + a.func1(<span style="color:rgb(128,0,128);">100</span>, <span style="color:rgb(128,0,128);">80</span>));
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h4> <a name="t15"></a>运行结果</h4> <p>100-50=50 <br> 100-80=20 </p> <h3> <a name="t16"></a>需求变动</h3> <p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。 <br> 即类B需要完成两个功能： <br> 两数相减。 <br> 两数相加，然后再加100。 <br> 由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> B:A
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">int</span> func1(<span style="color:rgb(0,0,255);">int</span> a, <span style="color:rgb(0,0,255);">int</span> b)
    {
        <span style="color:rgb(0,0,255);">return</span> a + b;
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">int</span> func2(<span style="color:rgb(0,0,255);">int</span> a, <span style="color:rgb(0,0,255);">int</span> b)
    {
        <span style="color:rgb(0,0,255);">return</span> func1(a, b) + <span style="color:rgb(128,0,128);">100</span>;
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">void</span> Start()
    {
        B b = <span style="color:rgb(0,0,255);">new</span> B();
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">100-50=</span><span style="color:rgb(128,0,0);">"</span> + b.func1(<span style="color:rgb(128,0,128);">100</span>, <span style="color:rgb(128,0,128);">50</span>));
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">100-80=</span><span style="color:rgb(128,0,0);">"</span> + b.func1(<span style="color:rgb(128,0,128);">100</span>, <span style="color:rgb(128,0,128);">80</span>));
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">100+20+100=</span><span style="color:rgb(128,0,0);">"</span> + b.func2(<span style="color:rgb(128,0,128);">100</span>, <span style="color:rgb(128,0,128);">20</span>));
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h4> <a name="t17"></a>类B运行结果</h4> <p>100-50=150 <br> 100-80=180 <br> 100+20+100=220 </p> <h3> <a name="t18"></a>影响了正常的功能</h3> <p>我们发现原本运行正常的相减功能发生了错误。 <br> 原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。 <br> 在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。 <br> 在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单， <br> 但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。 <br> 如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p> <h3> <a name="t19"></a>里氏替换原则通俗的来讲就是</h3> <p>子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： <br> 1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 <br> 2.子类中可以增加自己特有的方法。 <br> 3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 <br> 4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p> <p><br> 看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。 <br> 所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？ <br> 后果就是：你写的代码出问题的几率将会大大增加。</p> <h2> <a name="t20"></a><strong>原则3：依赖倒置原则</strong> </h2> <h3> <a name="t21"></a>定义</h3> <p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p> <p>以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。 <br> 抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 </p> <h3> <a name="t22"></a>依赖倒置原则核心思想</h3> <p>依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。 </p> <h3> <a name="t23"></a>情景举例</h3> <p>场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> Book
{
    <span style="color:rgb(0,0,255);">public</span> String getContent()
    {
        <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">很久很久以前有一个阿拉伯的故事……</span><span style="color:rgb(128,0,0);">"</span>;
    }
}

<span style="color:rgb(0,0,255);">class</span> Mother
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> narrate(Book book)
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">妈妈开始讲故事</span><span style="color:rgb(128,0,0);">"</span>);
        Debug.Log(book.getContent());
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">void</span> Start()
    {
        Mother mother = <span style="color:rgb(0,0,255);">new</span> Mother();
        mother.narrate(<span style="color:rgb(0,0,255);">new</span> Book());
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h4> <a name="t24"></a>运行结果：</h4> <p>妈妈开始讲故事 <br> 很久很久以前有一个阿拉伯的故事…… </p> <h3> <a name="t25"></a>需求变动</h3> <p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> Newspaper
{
    <span style="color:rgb(0,0,255);">public</span> String getContent()
    {
        <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">林书豪38+7领导尼克斯击败湖人……</span><span style="color:rgb(128,0,0);">"</span>;
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。 <br> 假如以后需求换成杂志呢？换成网页呢？ <br> 还要不断地修改Mother，这显然不是好的设计。 <br> 原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。 </p> <h3> <a name="t26"></a>抽象的接口</h3> <p>我们引入一个抽象的接口IReader。 <br> 读物，只要是带字的都属于读物：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);">
           <pre><span style="color:rgb(0,0,255);">interface</span> IReader
{
    String getContent();
}</pre>
          </div> <p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴， <br> 他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">interface</span> IReader
{
    String getContent();
}

<span style="color:rgb(0,0,255);">class</span> Newspaper : IReader
{
    <span style="color:rgb(0,0,255);">public</span> String getContent()
    {
        <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">林书豪17+9助尼克斯击败老鹰……</span><span style="color:rgb(128,0,0);">"</span>;
    }
}
<span style="color:rgb(0,0,255);">class</span> Book : IReader
{
    <span style="color:rgb(0,0,255);">public</span> String getContent()
    {
        <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">很久很久以前有一个阿拉伯的故事……</span><span style="color:rgb(128,0,0);">"</span>;
    }
}

<span style="color:rgb(0,0,255);">class</span> Mother
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> narrate(IReader reader)
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">妈妈开始讲故事</span><span style="color:rgb(128,0,0);">"</span>);
        Debug.Log(reader.getContent());
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> main(String[] args)
    {
        Mother mother = <span style="color:rgb(0,0,255);">new</span> Mother();
        mother.narrate(<span style="color:rgb(0,0,255);">new</span> Book());
        mother.narrate(<span style="color:rgb(0,0,255);">new</span> Newspaper());
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h4> <a name="t27"></a><em>运行结果</em> </h4> <p><em>妈妈开始讲故事 <br> 很久很久以前有一个阿拉伯的故事…… <br> 妈妈开始讲故事 <br> 林书豪17+9助尼克斯击败老鹰……</em></p> <p><br> 这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。 <br> 这只是一个简单的例子，实际情况中，<span style="color:rgb(255,0,0);">代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。 <br></span>所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 <br> 采用依赖倒置原则给多人并行开发带来了极大的便利，</p> <p><br> 比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。 <br> 修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。 <br> 参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。 <br> 现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p> <h3> <a name="t28"></a>在实际编程中，我们一般需要做到如下3点</h3> <p>1.低层模块尽量都要有抽象类或接口，或者两者都有。 <br> 2.变量的声明类型尽量是抽象类或接口。使用继承时遵循里氏替换原则。 <br> 3.依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p> <h2> <a name="t29"></a>原则4：接口隔离原则</h2> <h3> <a name="t30"></a>定义</h3> <p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 <br> 将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 <br> 举例来说明接口隔离原则：</p> <h3> <a name="t31"></a>未遵循接口隔离原则的设计</h3> <p><a href="https://images0.cnblogs.com/blog/363476/201502/121642244953356.jpg" rel="nofollow"><img width="659" height="364" title="类图1" style="border-width:0px;background-image:none;" alt="类图1" src="https://images0.cnblogs.com/blog/363476/201502/121642263862512.jpg"></a>&nbsp; <br> 这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。 <br> 类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。 <br> 对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。 </p> <h3> <a name="t32"></a>示例代码</h3> <p>对类图不熟悉的可以参照程序代码来理解，代码如下：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">接口</span>
<span style="color:rgb(0,0,255);">interface</span> I
{
    <span style="color:rgb(0,0,255);">void</span> method1();
    <span style="color:rgb(0,0,255);">void</span> method2();
    <span style="color:rgb(0,0,255);">void</span> method3();
    <span style="color:rgb(0,0,255);">void</span> method4();
    <span style="color:rgb(0,0,255);">void</span> method5();
}

<span style="color:rgb(0,0,255);">class</span> A
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend1(I i)
    {
        i.method1();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend2(I i)
    {
        i.method2();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend3(I i)
    {
        i.method3();
    }
}

<span style="color:rgb(0,0,255);">class</span> B : I
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method1()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类B实现接口I的方法1</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method2()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类B实现接口I的方法2</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method3()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类B实现接口I的方法3</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method4() { }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method5() { }
}

<span style="color:rgb(0,0,255);">class</span> C
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend1(I i)
    {
        i.method1();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend2(I i)
    {
        i.method4();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend3(I i)
    {
        i.method5();
    }
}

<span style="color:rgb(0,0,255);">class</span> D : I
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method1()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类D实现接口I的方法1</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method2() { }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method3() { }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method4()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类D实现接口I的方法4</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method5()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类D实现接口I的方法5</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">void</span> Start()
    {
        A a = <span style="color:rgb(0,0,255);">new</span> A();
        a.depend1(<span style="color:rgb(0,0,255);">new</span> B());
       a.depend2(<span style="color:rgb(0,0,255);">new</span> B());
       a.depend3(<span style="color:rgb(0,0,255);">new</span> B());

        C c = <span style="color:rgb(0,0,255);">new</span> C();
      c.depend1(<span style="color:rgb(0,0,255);">new</span> D()));
        c.depend2(<span style="color:rgb(0,0,255);">new</span> D());
        c.depend3(<span style="color:rgb(0,0,255);">new</span> D());
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。 <br> 如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。 </p> <h3> <a name="t33"></a>遵循接口隔离原则的设计</h3> <p>在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示： </p> <a href="https://images0.cnblogs.com/blog/363476/201502/121642275421825.jpg" rel="nofollow"><img width="617" height="311" title="类图2" style="border-width:0px;background-image:none;" alt="类图2" src="https://images0.cnblogs.com/blog/363476/201502/121642286981139.jpg"></a> <h3> <a name="t34"></a>示例代码</h3> <p>照例贴出程序的代码，供不熟悉类图的朋友参考：</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">interface</span> I1
{
     <span style="color:rgb(0,0,255);">void</span> method1();
}

<span style="color:rgb(0,0,255);">interface</span> I2
{
     <span style="color:rgb(0,0,255);">void</span> method2();
     <span style="color:rgb(0,0,255);">void</span> method3();
}

<span style="color:rgb(0,0,255);">interface</span> I3
{
     <span style="color:rgb(0,0,255);">void</span> method4();
     <span style="color:rgb(0,0,255);">void</span> method5();
}

<span style="color:rgb(0,0,255);">class</span> A
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend1(I1 i)
    {
        i.method1();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend2(I2 i)
    {
        i.method2();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend3(I2 i)
    {
        i.method3();
    }
}

<span style="color:rgb(0,0,255);">class</span> B : I1, I2
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method1()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类B实现接口I1的方法1</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method2()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类B实现接口I2的方法2</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method3()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类B实现接口I2的方法3</span><span style="color:rgb(128,0,0);">"</span>);
    }
}

<span style="color:rgb(0,0,255);">class</span> C
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend1(I1 i)
    {
        i.method1();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend2(I3 i)
    {
        i.method4();
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> depend3(I3 i)
    {
        i.method5();
    }
}

<span style="color:rgb(0,0,255);">class</span> D : I1, I3
{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method1()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类D实现接口I1的方法1</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method4()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类D实现接口I3的方法4</span><span style="color:rgb(128,0,0);">"</span>);
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> method5()
    {
        Debug.Log(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">类D实现接口I3的方法5</span><span style="color:rgb(128,0,0);">"</span>);
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 <br> 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 <br> 本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。</p> <p><br> 在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。 <br> 接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 <br> 说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。 <br> 其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。 <br> 其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；</p> <p>而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。 </p> <h3> <a name="t35"></a>注意几点</h3> <p>采用接口隔离原则对接口进行约束时，要注意以下几点： <br> 1.接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 <br> 2.为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 <br> 3.提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 <br> 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p> <p>&nbsp;</p> <h2> <a name="t36"></a>原则5：迪米特法则</h2> <h3> <a name="t37"></a>定义</h3> <p><strong>一个对象应该对其他对象保持最少的了解</strong> <br> 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 <br> 因此，尽量降低类与类之间的耦合。 <br> 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。 <br> 无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。 <br> 低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p> <h3> <a name="t38"></a>最少知道原则</h3> <p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。 <br> 通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，<span style="color:rgb(255,0,0);">对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。 <br></span>迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友： <br> 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。 <br> 耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友， <br> 而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p> <h3> <a name="t39"></a>违反迪米特法则的设计</h3> <p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。 <br> 先来看一下违反迪米特法则的设计。</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">总公司员工</span>
<span style="color:rgb(0,0,255);">class</span> Employee
{
    <span style="color:rgb(0,0,255);">private</span> String id;
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> setId(String id)
    {
        <span style="color:rgb(0,0,255);">this</span>.id = id;
    }
    <span style="color:rgb(0,0,255);">public</span> String getId()
    {
        <span style="color:rgb(0,0,255);">return</span> id;
    }
}

<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">分公司员工</span>
<span style="color:rgb(0,0,255);">class</span> SubEmployee
{
    <span style="color:rgb(0,0,255);">private</span> String id;
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> setId(String id)
    {
        <span style="color:rgb(0,0,255);">this</span>.id = id;
    }
    <span style="color:rgb(0,0,255);">public</span> String getId()
    {
        <span style="color:rgb(0,0,255);">return</span> id;
    }
}

<span style="color:rgb(0,0,255);">class</span> SubCompanyManager
{
    <span style="color:rgb(0,0,255);">public</span> List&lt;SubEmployee&gt; getAllEmployee()
    {
        List&lt;SubEmployee&gt; list = <span style="color:rgb(0,0,255);">new</span> List&lt;SubEmployee&gt;();
        <span style="color:rgb(0,0,255);">for</span> (<span style="color:rgb(0,0,255);">int</span> i = <span style="color:rgb(128,0,128);">0</span>; i &lt; <span style="color:rgb(128,0,128);">100</span>; i++)
        {
            SubEmployee emp = <span style="color:rgb(0,0,255);">new</span> SubEmployee();
            <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">为分公司人员按顺序分配一个ID</span>
            emp.setId(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">分公司</span><span style="color:rgb(128,0,0);">"</span> + i);
            list.Add(emp);
        }
        <span style="color:rgb(0,0,255);">return</span> list;
    }
}

<span style="color:rgb(0,0,255);">class</span> CompanyManager
{

    <span style="color:rgb(0,0,255);">public</span> List&lt;Employee&gt; getAllEmployee()
    {
        List&lt;Employee&gt; list = <span style="color:rgb(0,0,255);">new</span> List&lt;Employee&gt;();
        <span style="color:rgb(0,0,255);">for</span> (<span style="color:rgb(0,0,255);">int</span> i = <span style="color:rgb(128,0,128);">0</span>; i &lt; <span style="color:rgb(128,0,128);">30</span>; i++)
        {
            Employee emp = <span style="color:rgb(0,0,255);">new</span> Employee();
            <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">为总公司人员按顺序分配一个ID</span>
            emp.setId(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">总公司</span><span style="color:rgb(128,0,0);">"</span> + i);
            list.Add(emp);
        }
        <span style="color:rgb(0,0,255);">return</span> list;
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> printAllEmployee(SubCompanyManager sub)
    {
        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();
        <span style="color:rgb(0,0,255);">foreach</span> (SubEmployee e <span style="color:rgb(0,0,255);">in</span> list1)
        {
            Debug.Log(e.getId());
        }


        List&lt;Employee&gt; list2 = <span style="color:rgb(0,0,255);">this</span>.getAllEmployee();
        <span style="color:rgb(0,0,255);">foreach</span> (Employee e <span style="color:rgb(0,0,255);">in</span> list2)
        {
            Debug.Log(e.getId());
        }
    }
}

<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> Client
{
    <span style="color:rgb(0,0,255);">void</span> Start()
    {
        CompanyManager e = <span style="color:rgb(0,0,255);">new</span> CompanyManager();
        e.printAllEmployee(<span style="color:rgb(0,0,255);">new</span> SubCompanyManager());
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信， <br> 而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了， <br> 与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。 </p> <h3> <a name="t40"></a>修改后的代码</h3> <p>按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p> 
          <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);"> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
           <pre><span style="color:rgb(0,0,255);">class</span> SubCompanyManager
{
    <span style="color:rgb(0,0,255);">public</span> List&lt;SubEmployee&gt; getAllEmployee()
    {
        List&lt;SubEmployee&gt; list = <span style="color:rgb(0,0,255);">new</span> List&lt;SubEmployee&gt;();
        <span style="color:rgb(0,0,255);">for</span> (<span style="color:rgb(0,0,255);">int</span> i = <span style="color:rgb(128,0,128);">0</span>; i &lt; <span style="color:rgb(128,0,128);">100</span>; i++)
        {
            SubEmployee emp = <span style="color:rgb(0,0,255);">new</span> SubEmployee();
            <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">为分公司人员按顺序分配一个ID</span>
            emp.setId(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">分公司</span><span style="color:rgb(128,0,0);">"</span> + i);
            list.Add(emp);
        }
        <span style="color:rgb(0,0,255);">return</span> list;
    }
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> printEmployee()
    {
        List&lt;SubEmployee&gt; list = <span style="color:rgb(0,0,255);">this</span>.getAllEmployee();
        <span style="color:rgb(0,0,255);">foreach</span> (SubEmployee e <span style="color:rgb(0,0,255);">in</span> list)
        {
            Debug.Log(e.getId());
        }
    }
}

<span style="color:rgb(0,0,255);">class</span> CompanyManager
{
    <span style="color:rgb(0,0,255);">public</span> List&lt;Employee&gt; getAllEmployee()
    {
        List&lt;Employee&gt; list = <span style="color:rgb(0,0,255);">new</span> List&lt;Employee&gt;();
        <span style="color:rgb(0,0,255);">for</span> (<span style="color:rgb(0,0,255);">int</span> i = <span style="color:rgb(128,0,128);">0</span>; i &lt; <span style="color:rgb(128,0,128);">30</span>; i++)
        {
            Employee emp = <span style="color:rgb(0,0,255);">new</span> Employee();
            <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">为总公司人员按顺序分配一个ID</span>
            emp.setId(<span style="color:rgb(128,0,0);">"</span><span style="color:rgb(128,0,0);">总公司</span><span style="color:rgb(128,0,0);">"</span> + i);
            list.Add(emp);
        }
        <span style="color:rgb(0,0,255);">return</span> list;
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> printAllEmployee(SubCompanyManager sub)
    {
        sub.printEmployee();
        List&lt;Employee&gt; list2 = <span style="color:rgb(0,0,255);">this</span>.getAllEmployee();
        <span style="color:rgb(0,0,255);">foreach</span> (Employee e <span style="color:rgb(0,0,255);">in</span> list2)
        {
            Debug.Log(e.getId());
        }
    }
}</pre> 
           <div class="cnblogs_code_toolbar">
            <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
           </div> 
          </div> <h3> <a name="t41"></a>主要的变化</h3> <p><a href="https://images0.cnblogs.com/blog/363476/201502/121653282293049.png" rel="nofollow"><img width="1200" height="856" title="image" style="border-width:0px;background-image:none;" alt="image" src="https://images0.cnblogs.com/blog/363476/201502/121653292296877.png"></a></p> <p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p> <h3> <a name="t42"></a>总结</h3> <p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。 <br> 但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中， <br> 总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。 <br> 过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。 <br> 所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p> <p>&nbsp;</p> <h2> <a name="t43"></a>原则6：开闭原则</h2> <h3> <a name="t44"></a>定义</h3> <p><strong>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭</strong></p> <p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时， <br> 可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。 <br> 因此，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 <br> 闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了， </p> <p>它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。 <br> 以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。 <br> 在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。 <br> 其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。</p> <h3> <a name="t45"></a>如何遵守</h3> <p>也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”， <br> 前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好； <br> 如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。 <br> 其实，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。 <br> 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。 <br> 而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。 <br> 当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p> <p><span style="line-height:1.5;">&nbsp;</span></p> <h2> <a name="t46"></a><strong>如何去遵守这六个原则</strong> </h2> <p>对这六个原则的遵守并不是 <strong>是和否</strong>的问题，而是<strong>多和少</strong>的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。 <br> 任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。 <br> 对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。 <br> 如果大家对这六项原则的理解跟我有所不同，欢迎指正<img alt="" src="http://www.unitymanual.com/static/image/smiley/default/20119000.gif"></p> <h3> <a name="t47"></a>说明</h3> <p>本文转载自并对其整理目录<a href="http://www.unitymanual.com/thread-22531-1-1.html" rel="nofollow">：[ζއ随风去旅行] Unity3d 一个优秀的程序必备的几种设计模式</a></p> </li> 
        </ul>
       </div> 
       <div>
        <br>
       </div> 
       <div>
        本文转自赵青青博客园博客，原文链接：http://www.cnblogs.com/zhaoqingqing/p/4288454.html，如需转载请自行联系原作者
        <br>
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <a name="!comments"></a> 
   <div> 
    <div></div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
