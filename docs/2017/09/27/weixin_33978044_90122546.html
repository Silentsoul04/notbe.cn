<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++：类型转换 « NotBeCN</title>
  <meta name="description" content="                  5.3.1 系统预定义类型间的转换1. 隐式转换：例如： int x=5,y;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y=3.5+x; //系统会自动先将int型的5转换为double型的5.0，在和3.5进行加法运算。隐...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/09/27/weixin_33978044_90122546.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C++：类型转换</h1>
    <p class="post-meta">Sep 27, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"> 
    <p><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">5.3.1 系统预定义类型间的转换</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">1. 隐式转换：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如： int x=5,y;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y=3.5+x; //系统会自动先将int型的5转换为double型的5.0，在和3.5进行加法运算。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">隐式类型转换的主要规则：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">a.在赋值表达式A=B的情况下，赋值运算符右端B的值需要转换为A的类型后进行赋值。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">b.当char或short类型变量与int类型变量进行运算时，将char或short类型转换为int类型。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">c.当两个操作对象类型不一致时，在算术运算前，级别低的类型自动转换为级别高的类型。&nbsp;</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">2.显示转换：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在C语言中：(类型名)表达式 例如：(int)3.2------&gt;结果就是3</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在C++中: 类型名(表达式) &nbsp; &nbsp; &nbsp; 例如：int 3.2 ------&gt;结果也是3</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">------------------------------------------------------------------------------------------- </span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">5.3.2 类类型与系统预定义类型间的转换</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">方法：（1）通过转换构造函数进行类型转换</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （2）通过类型转化函数进行类型转换</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">1. 转换构造函数</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">转换构造函数也是构造函数的一种，它具有类型转换的作用，它的作用是将一个其他类型的数据转化成它所在类的对象。转换构造函数只有一个形参，用户可以根据需要定义转换构造函数，载寒暑类体中告诉编译系统如何进行类型转换。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如 Complex com2(7.7); //将double类型的7.7转换为名字为com2的Complex类对象&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Complex(7.7); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//将double类型的7.7转换为无名的一个临时的Complex类对象</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">通常，使用转换构造函数将一个指定的数据转换为类的对象方法如下：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（1）先声明一个类(例如Complex)</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（2）在这个类中定义一个只有一个参数，参数是待转换类型的数据，在函数体中指定转换的类型。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Complex(double r) //函数体中转换构造函数&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{real=r;imag=0;}</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（3）可以用以下形式进行类型换</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">类名(待转换类型的数据) 例如：Complex(7.7)</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">这时，C++系统就自动调用转换构造函数，将double类型的7.7转换为Complex类型的无名临时对象，</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">其值为：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">临时对象.real=7.7</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">临时对象.imag=0&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.15 转换构造函数</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream.h&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Complex{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    Complex(){};                </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">不带参数的构造函数 </span>
    Complex(<span style="line-height:1.8;color:rgb(0,0,255);">double</span> r,<span style="line-height:1.8;color:rgb(0,0,255);">double</span> i)  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">带两个参数的构造函数 </span>
<span style="line-height:1.8;">    {
     real </span>=<span style="line-height:1.8;"> r;
     imag </span>=<span style="line-height:1.8;"> i;
    }
    Complex(</span><span style="line-height:1.8;color:rgb(0,0,255);">double</span> r)           <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">转换构造函数</span>
<span style="line-height:1.8;">    {
     real </span>=<span style="line-height:1.8;"> r;
     imag </span>= <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
    } 
    friend Complex </span><span style="line-height:1.8;color:rgb(0,0,255);">operator</span>+(Complex &amp;a,Complex &amp;b) <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义友元运算符+重载函数 </span>
<span style="line-height:1.8;">    {
      Complex temp;
      temp.real</span>= a.real+<span style="line-height:1.8;">b.real;
      temp.imag</span>= a.imag+<span style="line-height:1.8;">b.imag;
      </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span><span style="line-height:1.8;"> temp; 
    }
    </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> print(); 
  </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
    </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> real;
    </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> imag;
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Complex::print()
{
  cout</span>&lt;&lt;<span style="line-height:1.8;">real;
  </span><span style="line-height:1.8;color:rgb(0,0,255);">if</span>(imag&gt;<span style="line-height:1.8;color:rgb(128,0,128);">0</span>) cout&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">+</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
  </span><span style="line-height:1.8;color:rgb(0,0,255);">if</span>(imag!=<span style="line-height:1.8;color:rgb(128,0,128);">0</span>) cout&lt;&lt;imag&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">i\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
} 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Complex com1(</span><span style="line-height:1.8;color:rgb(128,0,128);">1.1</span>,<span style="line-height:1.8;color:rgb(128,0,128);">2.2</span><span style="line-height:1.8;">),com3,total1,total2;
 Complex com2(</span><span style="line-height:1.8;color:rgb(128,0,128);">7.7</span>);   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用转换构造函数，将7.7转换成为对象com2 </span>
 total1 = com1+com2;  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">两个Complex对象相加 </span>
<span style="line-height:1.8;"> total1.print();
 
 com3 </span>= Complex(<span style="line-height:1.8;color:rgb(128,0,128);">7.7</span><span style="line-height:1.8;">);
 total2 </span>= com1+<span style="line-height:1.8;">com3;
 total2.print();

 </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}

</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
说明：（1）转换构造函数也也是一种构造函数，它遵循构造函数的一般规则。转换构造函数
           只有一个参数，作用是将一个其它类型的数据转换为它所在类的对象。但是，有
           一个参数的不一定是转换构造函数，它也可以是普通的构造函数，仅仅是起对象
           初始化的作用。
      （2）转换构造函数不仅可以将一个系统预定义的标准类型数据转换成类的对象，也有
           可以将另一个类的对象转换为构造函数所在的类对象。
           
           如：可以将一个学生类对象转换为教师类对象，可以在Teacher类中写出下面的
           转换构造函数：
           Teacher(Student&amp; s){ num=s.num;strcpy(name, s.name);sex=s.sex; }
           但应注意，对象s中的num，name，sex必须是公用成员，否则不能被类外引用。        
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">2.类型转换函数</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">通过转换构造函数可以将一个指定的类型的数据转换为类的对象。但是不能将一个类的对象转换为其他的类型的数据，例如不能将一个Complex类的对象转换为double类型的数据。为此，C++提供了一个称为类型转换函数来解决这个转换问题。类型转换函数的作用是将一个类的对象转换为另一个类型的数据。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">格式为：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">operator 目标类型()</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp;函数体&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}&nbsp;</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">其中，目标类型为希望转换成的类型，它既可以是预定义的标准数据类型也可以是其他类的类型。类型转换函数的函数名为"operator 目标类型"，在函数名前面不能指定函数类型，也不能有参数。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">通常，其函数体的最后一条语句是return语句，返回值的类型是该函数的目标类型。例如，已经声明一个类Complex，可以在Complex类中定义一个类型转换函数：</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">operator double()</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; return real;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">} </span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">这个类型转换函数函数名是"operator double"，希望转换成的目标类型是double，函数体为return real。这个类型转换的作用是：将一个Complex类对象转换为一个double类型的数据，其值是Complex类中的数据成员real的值。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.16 类型转换函数的应用1</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Complex{
 </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   Complex(</span><span style="line-height:1.8;color:rgb(0,0,255);">double</span> r,<span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> i)
   {
    real </span>=<span style="line-height:1.8;"> r;
    imag </span>=<span style="line-height:1.8;"> i;
   }
   </span><span style="line-height:1.8;color:rgb(0,0,255);">operator</span> <span style="line-height:1.8;color:rgb(0,0,255);">double</span>()          <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">类型转换函数 </span>
<span style="line-height:1.8;">   {
    </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> real;              <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">将Complex类的对象转换为一个double类型的数据 </span>
<span style="line-height:1.8;">   }
 </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
  </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> real;
  </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> imag;
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Complex com(</span><span style="line-height:1.8;color:rgb(128,0,128);">2.2</span>,<span style="line-height:1.8;color:rgb(128,0,128);">4.4</span><span style="line-height:1.8;">);
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">Complex类的对象转换为一个double类型的数据:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(0,0,255);">double</span>(com)&lt;&lt;endl;     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用类型转化函数，将转换后的double类型的数据显示出来 </span>
 
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span>  <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
} 
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
 类型转换函数注意事项：
   （1）类型转换函数只能定义为一个类的成员函数，而不能定义为友元函数。类型转化函数也可以
        在类体中生命函数原型，而将函数体定义在类的外部。
   （2）类型转换函数既没有参数，也不能在函数名前面指定函数类型。
   （3）类型函数中必须有return语句，即必须送回目标类型的数据作为函数的返回值。
   （4）一个类可以定义多个类型转换函数。C++编译器将根据类型转换函数名自动地选择一个合适的
        类型转换函数予以调用。 
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.17 类型转换函数的应用2</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Complex{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    Complex(</span><span style="line-height:1.8;color:rgb(0,0,255);">double</span> r,<span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> i)
    {
     real </span>=<span style="line-height:1.8;"> r;
     imag </span>=<span style="line-height:1.8;"> i;
    } 
    </span><span style="line-height:1.8;color:rgb(0,0,255);">operator</span> <span style="line-height:1.8;color:rgb(0,0,255);">double</span>()  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">类型转换函数,将Complex的对象转换为一个double类型的数据 </span>
<span style="line-height:1.8;">    {
     </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span><span style="line-height:1.8;"> real;
    }
    </span><span style="line-height:1.8;color:rgb(0,0,255);">operator</span> <span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;">()
    {
     </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(0,0,255);">int</span>(real); <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">类型转换函数,将Complex的对象转换为一个int类型的数据 </span>
<span style="line-height:1.8;">    }
  </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
    </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> real;
    </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> imag;
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Complex com1(</span><span style="line-height:1.8;color:rgb(128,0,128);">22.2</span>,<span style="line-height:1.8;color:rgb(128,0,128);">4.4</span><span style="line-height:1.8;">);
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">Complex的对象转换为一个double类型的数据:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(0,0,255);">double</span>(com1)&lt;&lt;endl;<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用类型转换函数 </span>
<span style="line-height:1.8;"> 
 Complex com2(</span><span style="line-height:1.8;color:rgb(128,0,128);">66.6</span>,<span style="line-height:1.8;color:rgb(128,0,128);">4.4</span><span style="line-height:1.8;">); 
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">Complex的对象转换为一个int类型的数据:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(0,0,255);">int</span>(com2)&lt;&lt;endl;   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用类型转换函数</span>
 
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
} 
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
运行结果：
          Complex的对象转换为一个double类型的数据:22.2
          Complex的对象转换为一个int类型的数据:66
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//[例10.10] 包含转换构造函数、运算符重载函数和类型转换函数的程序</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include &lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Complex
{
</span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   Complex( ){real</span>=<span style="line-height:1.8;color:rgb(128,0,128);">0</span>;imag=<span style="line-height:1.8;color:rgb(128,0,128);">0</span>;}  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">默认构造函数</span>
   Complex(<span style="line-height:1.8;color:rgb(0,0,255);">double</span> r){real=r;imag=<span style="line-height:1.8;color:rgb(128,0,128);">0</span>;}<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">转换构造函数</span>
   Complex(<span style="line-height:1.8;color:rgb(0,0,255);">double</span> r,<span style="line-height:1.8;color:rgb(0,0,255);">double</span> i){real=r;imag=i;}<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">实现初始化的构造函数</span>
   friend Complex <span style="line-height:1.8;color:rgb(0,0,255);">operator</span> + (Complex c1,Complex c2); <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">重载运算符“+”的友元函数</span>
   <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> display( );
</span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> real;
   </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> imag;
};
Complex </span><span style="line-height:1.8;color:rgb(0,0,255);">operator</span> + (Complex c1,Complex c2)<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义运算符“+”重载函数</span>
<span style="line-height:1.8;">{
   </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> Complex(c1.real+c2.real, c1.imag+<span style="line-height:1.8;">c2.imag);
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Complex::display( )
{
   cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">(</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;real&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">,</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;imag&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">i)</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;">endl;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main( )
{
   Complex c1(</span><span style="line-height:1.8;color:rgb(128,0,128);">3</span>,<span style="line-height:1.8;color:rgb(128,0,128);">4</span>),c2(<span style="line-height:1.8;color:rgb(128,0,128);">5</span>,-<span style="line-height:1.8;color:rgb(128,0,128);">10</span><span style="line-height:1.8;">),c3;
   c3</span>=c1+<span style="line-height:1.8;color:rgb(128,0,128);">2.5</span>; <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">复数与double数据相加，程序中不必显式地调用类型转换函数，它是自动被调用的，即隐式调用 </span>
   c3.display( );<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">c1+2.5-----&gt;c1+Complex(2.5) </span>
   <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">注意，在Visual C++ 6.0环境下运行时，需将第一行改为#include &lt;iostream.h&gt;，并删去第2行，否则编译不能通过。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">对程序的分析：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">1) 如果没有定义转换构造函数，则此程序编译出错。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">2) 现在，在类Complex中定义了转换构造函数，并具体规定了怎样构成一个复数。由于已重载了算符“+”，</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在处理表达式c1+2.5时，编译系统把它解释为 operator+(c1, 2.5)，</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">由于2.5不是Complex类对象，系统先调用转换构造函数Complex(2.5)，建立一个临时的Complex类对象，</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">其值为(2.5+0i)。上面的函数调用相当于 operator+(c1, Complex(2.5))，</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">将c1与(2.5+0i) 相加，赋给c3。运行结果为 (5.5+4i)</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">3) 如果把“c3=c1+2.5;”改为c3=2.5+c1; 程序可以通过编译和正常运行。过程与前相同。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">从中得到一个重要结论，在已定义了相应的转换构造函数情况下，将运算符“+”函数重载为友元函数，</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在进行两个复数相加时，可以用交换律。</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">如果运算符函数重载为成员函数，它的第一个参数必须是本类的对象。当第一个操作数不是类对象时</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">，不能将运算符函数重载为成员函数。如果将运算符“+”函数重载为类的成员函数，交换律不适用。</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">由于这个原因，一般情况下将双目运算符函数重载为友元函数。单目运算符则多重载为成员函数。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">4) 如果一定要将运算符函数重载为成员函数，而第一个操作数又不是类对象时，只有一个办法能够解决，</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">再重载一个运算符“+”函数，其第一个参数为double型。当然此函数只能是友元函数，函数原型为&nbsp;</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">friend operator+(double, Complex &amp;);</span><span style="line-height:1.8;font-size:18px;font-family:'隶书';">显然这样做不太方便，还是将双目运算符函数重载为友元函数方便些。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">5) 在上面程序的基础上增加类型转换函数：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">operator double( ){return real;}</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">此时Complex类的公用部分为：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">public:</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Complex( ){real=0;imag=0;}</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Complex(double r){real=r;imag=0;} &nbsp; &nbsp; &nbsp; &nbsp; //转换构造函数</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Complex(double r，double i){real=r;imag=i;}</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">operator double( ){return real;} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//类型转换函数</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">friend Complex operator+ (Complex c1，Complex c2); //重载运算符“+”</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">void display( );</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">其余部分不变。程序在编译时出错，原因是出现二义性。</span></p> 
   </div> 
   <div class="clear" style="clear:both;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"></div> 
   <div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;line-height:25.2px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/4912622.html</span></font>
     <span style="font-size:14px;line-height:25.2px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
