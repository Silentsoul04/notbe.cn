<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++：虚函数的详解 « NotBeCN</title>
  <meta name="description" content="                  5.4.2 虚函数详解     1.虚函数的定义虚函数就是在基类中被关键字virtual说明，并在派生类重新定义的函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。     虚函数的定义是在基类中进行的，它是在...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/09/12/weixin_34218579_90123070.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C++：虚函数的详解</h1>
    <p class="post-meta">Sep 12, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">5.4.2 虚函数详解</span></p> 
    <p><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';color:rgb(255,0,0);">1.虚函数的定义</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">虚函数就是在基类中被关键字virtual说明，并在派生类重新定义的函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">虚函数的定义是在基类中进行的，它是在基类中需要定义为虚函数的成员函数的声明中冠以关键字virtual。定义虚函数的格式如下：</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">virtual 函数类型 函数名(形参表)</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp;函数体&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在基类中的某个成员函数声明为虚函数后，此虚函数就可以在一个或多个派生类中被重新定义。在派生类中重新定义时，其函数类型、函数名、参数个数、参数类型的顺序，都必须与基类中的原型完全相同。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例 5.21 虚函数的使用</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> B0{
 </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span> print(<span style="line-height:1.8;color:rgb(0,0,255);">char</span> *p)      <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义基类B0中的虚函数 </span>
<span style="line-height:1.8;">   {
     cout</span>&lt;&lt;p&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">print()</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;">endl;
   }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> B1:<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> B0{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:

    </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span> print(<span style="line-height:1.8;color:rgb(0,0,255);">char</span> *p)     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义基类B0的公有派生类B1中的虚函数</span>
<span style="line-height:1.8;">    {
     cout</span>&lt;&lt;p&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">print()</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;">endl;
    }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> B2:<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> B1{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span> print(<span style="line-height:1.8;color:rgb(0,0,255);">char</span> *p)     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义基类B1的公有派生类B2中的虚函数</span>
<span style="line-height:1.8;">    {
     cout</span>&lt;&lt;p&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">print()</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;">endl;
    }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 B0 ob0,</span>*op;                  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义基类对象ob0和对象指针op </span>
 op=&amp;ob0;op-&gt;print(<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">B0::</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>);   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用基类的B0的print()</span>
 B1 ob1;                      <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义派生类B1的对象ob1 </span>
 op=&amp;ob1;op-&gt;print(<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">B1::</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>);   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用派生类B1的print() </span>
 B2 ob2;                      <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义派生类B2的对象ob2</span>
 op=&amp;ob2;op-&gt;print(<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">B2::</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>);   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用派生类B2的print()</span>
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
} 
 </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
   在程序中，语句op-&gt;print()；
   出现了3次，由于op指向的对象不同，每次出现都执行了相应对象的虚函数print
   
   程序运行结果：
     B0::print()
     B1::print()
     B2::print()</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">说明：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（1）若在基类中，只是声明虚函数原型(需要加上virtual),而在类外定义虚函数时，则不必再加上virtual。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（2）在派生类中重新定义时，其函数类型、函数名、参数个数、参数类型的顺序，都必须与基类中的原型完全相同。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（3）C++规定，当一个成员函数被定义为虚函数后，其派生类中符合重新定义虚函数要求的同名函数都自动称为虚函数。因此，在派生类中重新定义该虚函数时，关键字virtual可写可不写。但是为了程序更加清晰，最好在每一层派生类中定义函数时都加上关键字virtual。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（4）如果在派生类中没有对基类的虚函数重新定义，则公有派生类继承其直接基类的虚函数。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">一个虚函数无论被公有继承多少次。它仍然保持其虚函数的特性。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">class B0{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; ...</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; public:</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; virtual void show(); //在基类中定义show为虚函数&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}; </span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">class B1:public B0{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; ...</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">};</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">若在公有派生类B1中没有重新定义虚函数show，则函数在派生类中被继承，仍然是虚函数。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（5）虚函数必须是其所在类的成员函数，而不能是友元函数，也不能是静态成员函数，因为虚函数的调用要靠特定的对象来决定该激活哪个函数。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（6）虽然使用对象名和点运算符的方式也可以调用虚函数，但是这种调用是在编译时进行的，是静态联编，它没有利用虚函数的特性。只有通过指针访问虚函数时才能获得运行时的多态性。</span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';color:rgb(255,0,0);">&nbsp;2. 虚析构函数</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在C++中，不能声明虚构造函数，但是可以声明虚析构函数。&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.23 虚析构函数的引例</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> B{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span>~<span style="line-height:1.8;">B()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">调用基类B的析构函数\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> D:<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> B{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span>~<span style="line-height:1.8;">D()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">调用派生类D的析构函数\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    }
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 D obj;
 </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}
</span>*/
<span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
运行结果是： 
调用派生类D的析构函数
调用基类B的析构函数

显然本程序的运行结果是符和预想的。但是，如果在主函数中用new运算符建立一个无名对象
和定义了一个基类的对象指针，并将无名的对象的地址赋给这个对象指针。当用delete运算符
撤销无名对象时，系统只执行基类的析构函数，而不执行派生类的析构函数。
例如下面的例子： 
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.24 虚析构函数的引例2</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> B{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span>~<span style="line-height:1.8;">B()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">调用基类B的析构函数\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> D:<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> B{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span>~<span style="line-height:1.8;">D()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">调用派生类D的析构函数\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    }
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 B </span>*p;          <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义指向基类B的指针变量p </span>
 p = <span style="line-height:1.8;color:rgb(0,0,255);">new</span> D;     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用new运算符为派生类的无名对象动态的分配了一个存储空间，并将地址赋给对象指针p </span>
 <span style="line-height:1.8;color:rgb(0,0,255);">delete</span> p;      <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用delete撤销无名对象时，释放动态存储空间 </span>
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
} <br><span style="line-height:1.8;color:rgb(0,128,0);">/* 程序运行结果： 调用基类B的析构函数 程序结果表示，本程序只执行了基类B的析构函数，而没有执行派生类D的析构函数。 原因是:当撤销指针p所指的派生类的无名对象，而调用析构函数时，采用了静态联编方式， 只调用了基类B的析构函数。 那么如何在撤销指针p所指的派生类的无名对象，既调用基类B的析构函数，也调用派生类D的 析构函数呢？ 方法是：可以将基类的析构函数声明为虚析构函数，采用了多态性的动态联编方式。 虚析构函数没有类型，也没有参数，和普通虚函数相比，虚析构函数比较简单。 其声明格式： </span></span><span style="line-height:1.8;color:rgb(0,128,0);">virtual ~类名() 
*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.25 虚析构函数的使用</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> B{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> ~<span style="line-height:1.8;">B()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">调用基类B的析构函数\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> D:<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> B{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    </span>~<span style="line-height:1.8;">D()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">调用派生类D的析构函数\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    }
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 B </span>*p;          <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义指向基类B的指针变量p </span>
 p = <span style="line-height:1.8;color:rgb(0,0,255);">new</span> D;     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用new运算符为派生类的无名对象动态的分配了一个存储空间，并将地址赋给对象指针p </span>
 <span style="line-height:1.8;color:rgb(0,0,255);">delete</span> p;      <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用delete撤销无名对象时，释放动态存储空间 </span>
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
程序运行结果是：
调用派生类D的析构函数
调用基类B的析构函数

   说明：虽然派生类的析构函数与基类的析构函数名字不相同，但是如果将基类的析构函数
         定义为虚函数，则由该基类所派生的所有派生类的析构函数也都自动成为虚函数。 
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span> </pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';color:rgb(255,0,0);">3.虚函数与重载函数的关系</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">在一个派生类中重新定义基类的虚函数是函数重载的另一种形式，但它不同于一般函数重载。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">当普通的函数重载时，其函数的参数或参数类型有所不同，函数的返回类型也可以不同。但是当重载一个虚函数时，也就是说在派生类中重新定义虚函数时，要求函数名、返回类型、参数个数、参数的类型和顺序与基类的虚函数原型完全相同。如果仅仅返回类型不同，其余均相同，系统会给出错误信息；若仅仅函数名相同，而参数的个数、类型或顺序不同，系统将它作为普通的函数重载，这时虚函数的特性将丢失。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例5.26 虚函数与重载函数的关系</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Base{
 </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> func1();
   </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> func2();
   </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> func3();
   </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> func4();   
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> Derived:<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> Base{
 </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span> func1();     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">func1是虚函数，这里可以不写virtual </span>
   <span style="line-height:1.8;color:rgb(0,0,255);">void</span> func2(<span style="line-height:1.8;color:rgb(0,0,255);">int</span> i);        <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">与基类中的func2作为普通函数的重载，虚特性消失 
   </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">char func3();           </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">错误，因为与基类的func3返回类型不同，应删去 </span>
   <span style="line-height:1.8;color:rgb(0,0,255);">void</span> func4();             <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">与基类中的func4是普通函数的重载，不是虚函数 </span>
<span style="line-height:1.8;">};
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Base::func1()
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Base func1--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Base::func2()
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Base func2--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Base::func3()
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Base func3--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Base::func4()
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Base func4--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Derived::func1()
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Derived func1--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span> Derived::func2(<span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> i)
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Derived func2--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> Derived::func4()
{
 cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Derived func4--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Base b,</span>*pt;    <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义基类的对象b和对象指针pt </span>
 Derived d;     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义派生类的对象d </span>
 pt = &amp;d;       <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">基类的指针pt象派生类的对象d </span>
 pt-&gt;func1();   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用的是派生类的fun1，结果是--Derived func1-- (虚函数的特性)</span>
 pt-&gt;func2();   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用的是基类的fun2,结果是--Base func2--(参数表中多了一个参数,变成普通重载函数,丢失虚函数的特性) </span>
 pt-&gt;func4();   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用的是基类的fun4，结果是--Base func4--(基类和派生类中均没有virtual关键字，普通成员函数的重载) </span>
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
程序运行结果是：
--Derived func1--
--Base func2--
--Base func4-- 
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';color:rgb(255,0,0);">4. 多重继承与虚函数&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';color:rgb(0,0,0);">//例5.27 多重继承与虚函数的例子</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Base1{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span> fun()           <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义fun是虚函数 </span>
<span style="line-height:1.8;">   {
    cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Base1--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
   }
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Base2{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">: 
   </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span> fun()                  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义fun是普通的成员函数 </span>
<span style="line-height:1.8;">   {
    cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Base2--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
   }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> Derived:<span style="line-height:1.8;color:rgb(0,0,255);">public</span> Base1,<span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;"> Base2{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> fun()
   {
    cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">--Derived--\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
   }
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Base1 </span>*<span style="line-height:1.8;">ptr1;
 Base2 </span>*<span style="line-height:1.8;">ptr2;
 Derived d;
 ptr1 </span>= &amp;d;  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">基类的指针指向派生类的对象 </span>
 ptr1-&gt;fun();<span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">(*ptr1).fun();</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span>  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用派生类Derived的fun方法，因为它是由Base1派生来的，为虚函数，有虚特性 </span>
 ptr2-&gt;fun();<span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">(*ptr2).fun();</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span>  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用基类Base2的fun方法，派生类的fun方法是由Base2派生类来的，为普通成员重载函数 </span>
<span style="line-height:1.8;"> 

 Derived obj;</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">基类的引用指向派生类的对象</span>
 Base1 &amp;p1 =<span style="line-height:1.8;"> obj;
 Base2 </span>&amp;p2 =<span style="line-height:1.8;"> obj;
 p1.fun();</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用派生类Derived的fun方法，因为它是由Base1派生来的，为虚函数，有虚特性 </span>
 p2.fun();<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用基类Base2的fun方法，派生类的fun方法是由Base2派生类来的，为普通成员重载函数,无虚特性 </span>
 
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.5;color:rgb(255,0,0);font-family:'隶书';font-size:18px;">5.虚函数的综合应用&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';color:rgb(0,0,0);">//例5.28 应用C++的多态性，计算三角形、矩形和圆的面积。</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">#define</span> PI 3.1416
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> Shape{                    <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义一个公共的基类 </span>
   <span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
   </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);"> Shape(){}</span>
    Shape(<span style="line-height:1.8;color:rgb(0,0,255);">double</span> a=<span style="line-height:1.8;color:rgb(128,0,128);">0.0</span>,<span style="line-height:1.8;color:rgb(0,0,255);">double</span> b=<span style="line-height:1.8;color:rgb(128,0,128);">0.0</span>)  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">带默认的构造函数 </span>
<span style="line-height:1.8;">    {
     x </span>=<span style="line-height:1.8;"> a;
     y </span>=<span style="line-height:1.8;"> b;
    }
    </span><span style="line-height:1.8;color:rgb(0,0,255);">virtual</span> <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> area()
    {
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">在基类中定义的虚基类</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">为派生类提供一个公共的接口,</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
     cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">以便派生类根据需要重新定义虚函数</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;">endl;
    }
   </span><span style="line-height:1.8;color:rgb(0,0,255);">protected</span><span style="line-height:1.8;">:
    </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> x;
    </span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> y;    
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> Triangle:<span style="line-height:1.8;color:rgb(0,0,255);">public</span> Shape{     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义一个三角形的派生类 </span>
  <span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
     Triangle(</span><span style="line-height:1.8;color:rgb(0,0,255);">double</span> a,<span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> b):Shape(a,b){}
     </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> area()
     {
       cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">三角形的高是:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;x&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">,</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">底是:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;y&lt;&lt;<span style="line-height:1.8;">endl;    
       cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">三角形面积:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,128);">0.5</span>*x*y&lt;&lt;<span style="line-height:1.8;">endl;
     } 
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> Square:<span style="line-height:1.8;color:rgb(0,0,255);">public</span> Shape{     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义一个矩形的派生类 </span>
  <span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
     Square(</span><span style="line-height:1.8;color:rgb(0,0,255);">double</span> a,<span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> b):Shape(a,b){}
     </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> area()
     {
       cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">矩形的长是:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;x&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">,</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">宽是:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;y&lt;&lt;<span style="line-height:1.8;">endl;        
       cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">矩形面积:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;x*y&lt;&lt;<span style="line-height:1.8;">endl;
     } 
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span> Circle:<span style="line-height:1.8;color:rgb(0,0,255);">public</span> Shape{     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义一个圆的派生类 </span>
  <span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
     Circle(</span><span style="line-height:1.8;color:rgb(0,0,255);">double</span><span style="line-height:1.8;"> a):Shape(a,a){}
     </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> area()
     {
       cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">圆的半径是:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;x/<span style="line-height:1.8;color:rgb(128,0,128);">2</span>&lt;&lt;<span style="line-height:1.8;">endl;    
       cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">圆面积:</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;PI*x*x&lt;&lt;<span style="line-height:1.8;">endl;
     } 
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Shape </span>*p,obj;                     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义基类的对象指针p和对象obj </span>
 p=&amp;obj;                           <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">基类的对象指针p指向基类的对象obj </span>
 p-&gt;area();                        <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用基类的area方法 </span>
 Triangle t(<span style="line-height:1.8;color:rgb(128,0,128);">10.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">6.0</span>);             <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义三角形的对象t </span>
 Square s(<span style="line-height:1.8;color:rgb(128,0,128);">10.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">6.0</span>);               <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义矩形的对象s</span>
 Circle c(<span style="line-height:1.8;color:rgb(128,0,128);">10.0</span>);                   <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义圆形的对象t</span>
 p=&amp;<span style="line-height:1.8;">t;
 p</span>-&gt;area();                        <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">计算三角形的面积 </span>
 p=&amp;<span style="line-height:1.8;">s;
 p</span>-&gt;area();                        <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">计算矩形的面积</span>
 p=&amp;<span style="line-height:1.8;">c;
 p</span>-&gt;area();                        <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">计算圆形的面积</span>
 <span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
} 
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
 程序运行结果:
 在基类中定义的虚基类为派生类提供一个公共的接口,以便派生类根据需要重新定义虚函数
三角形的高是:10,底是:6
三角形面积:30
矩形的长是:10,宽是:6
矩形面积:60
圆的半径是:
圆面积:314.16 
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div class="clear" style="clear:both;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"></div> 
   <div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;line-height:25.2px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/4912639.html</span></font>
     <span style="font-size:14px;line-height:25.2px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
