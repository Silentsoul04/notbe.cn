<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>F#探险之旅（四）：面向对象编程（下） « NotBeCN</title>
  <meta name="description" content="             F#系列随笔索引    类的继承&nbsp; 在前面（面向对象（中））介绍过的对象表达式中，已经涉及到了类的继承，我们可以覆盖类的成员实现，然后创建新类的实例。这一节里，我们来看看常规的继承机制，熟悉C#的开发人员会感到更亲切。                       F# Code...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/14/weixin_34348174_90135386.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">F#探险之旅（四）：面向对象编程（下）</h1>
    <p class="post-meta">Dec 14, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><a href="http://www.cnblogs.com/anderslly/archive/2008/10/archive/2008/10/08/fs-posts-indices.html" rel="nofollow" style="text-decoration:none;color:rgb(61,129,238);border-bottom-width:1px;border-bottom-style:dashed;">F#系列随笔索引</a><strong><br></strong></p> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><strong>类的继承</strong>&nbsp;<br><br> 在前面（<a href="http://www.cnblogs.com/anderslly/archive/2008/10/07/fs-adventure-oop-part-two.html" rel="nofollow" style="text-decoration:none;color:rgb(61,129,238);border-bottom-width:1px;border-bottom-style:dashed;">面向对象（中）</a>）介绍过的对象表达式中，已经涉及到了类的继承，我们可以覆盖类的成员实现，然后创建新类的实例。这一节里，我们来看看常规的继承机制，熟悉C#的开发人员会感到更亲切。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 类的继承</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">#</span><span style="line-height:1.5;">light<br></span><span style="color:rgb(0,0,255);line-height:1.5;">type</span><span style="line-height:1.5;"> Base = </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"><br></span><span style="color:rgb(0,0,255);line-height:1.5;">val</span><span style="line-height:1.5;"> state : </span><span style="color:rgb(0,0,255);line-height:1.5;">int</span><span style="line-height:1.5;"><br></span><span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;">() = { state = </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">}<br></span><span style="color:rgb(0,0,255);line-height:1.5;">end</span><span style="line-height:1.5;"><br><br></span><span style="color:rgb(0,0,255);line-height:1.5;">type</span><span style="line-height:1.5;"> Sub = </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"><br></span><span style="color:rgb(0,0,255);line-height:1.5;">inherit</span><span style="line-height:1.5;"> Base<br></span><span style="color:rgb(0,0,255);line-height:1.5;">val</span><span style="line-height:1.5;"> otherState : </span><span style="color:rgb(0,0,255);line-height:1.5;">int</span><span style="line-height:1.5;"><br></span><span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;">() = { otherState = </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;"> }<br></span><span style="color:rgb(0,0,255);line-height:1.5;">end</span><span style="line-height:1.5;"><br><br></span><span style="color:rgb(0,0,255);line-height:1.5;">let</span><span style="line-height:1.5;"> myObj = </span><span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> Sub()<br><br> printfn </span><span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">myObj.state = %i, myObj.otherState = %i</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="line-height:1.5;"><br> myObj.state<br> myObj.otherState<br><br> System.Console.Read()</span></span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 运行结果为：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Output</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">myObj.state = </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">, myObj.otherState = </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span></span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 这里Base类为基类，有一个字段state，Sub继承了它，并有一个新字段otherState，下面的代码可以看到，此时Sub类继承了Base类的state字段。需要注意的是，这里的<strong>Base必须要有一个无参的构造函数，否则不能通过编译</strong>。其原因是，跟C#一样，在初始化派生类时会调用基类的构造函数，而F#中类没有默认的构造函数，所以必须显式添加构造函数。而如果基类的构造函数带有参数的话，派生类的构造函数写法也有所不同。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 基类具有含参的构造函数</span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 运行结果：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Output</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">Init base </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"><br> Init sub </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"><br> myObj.state = </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">, myObj.otherState = </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span></span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 这个结果说明确实调用了基类的构造函数。Inherit Base(0)则说明，我们必须选择正确的构造函数。<br><br><strong>类的方法&nbsp;</strong><br><br> 定义方法时可以使用4个相关的关键字，即member、override、abstract、default。在C#中，类的方法大体上可分为三种情况。一是在基类中定义，派生类中不能覆盖的；二是在基类中定义，派生类可以覆盖的（使用virtual关键字）；三是抽象方法（或接口方法），派生类需要提供实现的（除非派生类也是抽象类或接口）。对于情况一，可以简单地使用member关键字；情况二，可同时使用abstract和default（或override），abstract说明该方法可以进行覆盖，default则提供了默认实现；情况三，可仅仅使用abstract，同时为类添加特性AbstractClass，说明该方法是抽象类的一个抽象方法，必须在派生类中提供实现。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 类继承时的方法</span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 运行结果为：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Output</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">base </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">: <br></span><span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;"><br></span><span style="color:rgb(128,0,128);line-height:1.5;">4</span><span style="line-height:1.5;"><br> sub </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">: <br></span><span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;"><br></span><span style="color:rgb(128,0,128);line-height:1.5;">1</span></span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 可以看到JiggleState方法继承了Base的实现，而WiggleState则覆盖了Base的默认实现。<br><br><strong>访问基类的成员</strong>&nbsp;<br><br> 如果你曾写过Page类的派生类，那么很可能写过base.OnLoad()这样的代码。“base”用来引用基类中的成员，在F#中稍有不同。就像没有this一样，base也是没有的，需要给它手工指定名称。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 访问基类的成员</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">#</span><span style="line-height:1.5;">light<br></span><span style="color:rgb(0,0,255);line-height:1.5;">open</span><span style="line-height:1.5;"> System<br></span><span style="color:rgb(0,0,255);line-height:1.5;">open</span><span style="line-height:1.5;"> System.Drawing<br></span><span style="color:rgb(0,0,255);line-height:1.5;">open</span><span style="line-height:1.5;"> System.Windows.Forms<br><br></span><span style="color:rgb(0,0,255);line-height:1.5;">type</span><span style="line-height:1.5;"> RectangleForm(color) = </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"><br></span><span style="color:rgb(0,0,255);line-height:1.5;">inherit</span><span style="line-height:1.5;"> Form() </span><span style="color:rgb(0,0,255);line-height:1.5;">as</span><span style="line-height:1.5;"> base<br></span><span style="color:rgb(0,0,255);line-height:1.5;">override</span><span style="line-height:1.5;"> x.OnPaint(e) = <br> e.Graphics.DrawRectangle(color, </span><span style="color:rgb(128,0,128);line-height:1.5;">10</span><span style="line-height:1.5;">, </span><span style="color:rgb(128,0,128);line-height:1.5;">10</span><span style="line-height:1.5;">,<br> x.Width - </span><span style="color:rgb(128,0,128);line-height:1.5;">30</span><span style="line-height:1.5;">, x.Height - </span><span style="color:rgb(128,0,128);line-height:1.5;">50</span><span style="line-height:1.5;">)<br> base.OnPaint(e)<br></span><span style="color:rgb(0,0,255);line-height:1.5;">override</span><span style="line-height:1.5;"> x.OnResize(e) =<br> x.Invalidate()<br> base.OnResize(e)<br></span><span style="color:rgb(0,0,255);line-height:1.5;">end</span><span style="line-height:1.5;"><br><br></span><span style="color:rgb(0,0,255);line-height:1.5;">let</span><span style="line-height:1.5;"> form = </span><span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> RectangleForm(Pens.Blue)<br><br> [&lt;STAThread</span><span style="line-height:1.5;">&gt;]</span><span style="line-height:1.5;"><br></span><span style="color:rgb(0,0,255);line-height:1.5;">do</span><span style="line-height:1.5;"> Application.Run(form)</span></span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 这里定义Form类的派生类RectangleForm，注意在inherit后面的as base，这里的base就是给基类起的名字，这个名字是任意的。在覆盖OnPaint时就调用了基类的OnPaint方法。<br><br><strong>属性和索引器&nbsp;</strong><br><br> 属性（Property）和索引器（Indexer）是.NET中重要的“语法糖”特性，它们使得我们的代码更为直观、简洁，而它们本质上是方法。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 定义属性</span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 在Properties类中定义属性MyProp，这里我们可以看到熟悉的get/set变成了两个方法get/set，参数y就是C#中的value。<br><br> 索引器是一种特殊的属性（又称含参属性）。在C#中，索引器本质上是名为Item的方法。在F#中，我们也可以使用Item之外的名字。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 定义索引器</span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 这里的Indexers类定义了两个索引器：Item和MyString，通过Reflector可以看到，它们的签名相同，都是“public string this[int i] { get; set; }”，在C#中这是不允许的。C#中索引器的默认名称为Item，对于这里的Item来说，可以用两种方式访问它，而MyString就只有一种了。<strong>如果需要考虑同其它语言的兼容性，建议使用Item定义属性</strong>。<br><br><strong>类的静态方法&nbsp;</strong><br><br> 静态方法的定义是实例方法类似，不过要用到static关键字。访问静态方法时，不需要建立类的实例，可以通过类直接访问，如下面的ReverseString方法。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 定义静态方法</span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 运行结果为：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Output</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">Hello world</span></span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br><strong>定义委托</strong>&nbsp;<br><br> 在C#中，通过委托可以像“值”那样去处理方法。显然，在F#中不需要这样，因为函数本来就是当作值来看待的。但是考虑到与其它语言的交互，有时也需要定义委托。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 定义委托</span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 这里myInst是委托MyDelegate的一个实例，我们通过Invoke来调用它。运行结果为：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Output</span><span style="line-height:1.5;"><br><span style="color:rgb(128,0,128);line-height:1.5;">123</span></span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br><strong>定义结构类型&nbsp;</strong><br><br> 结构（struct）与类（class）的区别就是我们常说的值类型和引用类型的区别，在此不再赘述。下面定义的结构IpAddress用于表示IP地址。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 定义结构类型 </span></pre>
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br><strong>定义枚举类型</strong>&nbsp;<br><br> 枚举类型定义了一组符号名称和数值对，本质上讲，<strong>枚举类型就是定义了一组常数字段的结构</strong>。F#中枚举的定义也是很简单的。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
    <pre><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">F# Code - 定义枚举类型</span><span style="line-height:1.5;"><br><span style="line-height:1.5;">#</span><span style="line-height:1.5;">light<br><br></span><span style="color:rgb(0,0,255);line-height:1.5;">type</span><span style="line-height:1.5;"> Season =<br></span><span style="line-height:1.5;">|</span><span style="line-height:1.5;"> Spring<br></span><span style="line-height:1.5;">|</span><span style="line-height:1.5;"> Summer<br></span><span style="line-height:1.5;">|</span><span style="line-height:1.5;"> Autumn<br></span><span style="line-height:1.5;">|</span><span style="line-height:1.5;"> Winter</span></span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(61,129,238);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border-style:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br> 如果你希望定义位标记枚举，可以使用<strong>System.Flags</strong>特性。<br><br><strong>小结</strong>&nbsp;<br><br> 至此，F#中的面向对象编程范式介绍完毕，我们手中的F#也变得更为锐利。本文首先介绍了类的继承、类的方法（虚方法、抽象方法等）、访问基类等跟继承相关的概念；接着是类的属性和索引器、类的静态方法这些类的特殊成员；最后讨论了如何定义委托、结构类型、枚举类型等特殊类型。相信有了这些知识，我们完全可以使用F#代替C#来编写类库了。学习这些知识的过程，也给了我们一个从新的角度了解.NET Framework的机会。在学习了F#的三种主要编程范式之后，下一步该考虑如何在实战中应用它，比如如何组织规模较大的程序，如何建立UI，如何与其它.NET语言进行交互等等，在后续的随笔中将逐步介绍这些内容。</p> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><a href="http://www.cnblogs.com/anderslly/archive/2008/10/archive/2008/10/08/fs-posts-indices.html" rel="nofollow" style="text-decoration:none;color:rgb(61,129,238);border-bottom-width:1px;border-bottom-style:dashed;">F#系列随笔索引</a><strong><br></strong></p> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><strong>注意</strong>：本文中的代码均在F# 1.9.4.17版本下编写，在F# CTP 1.9.6.0版本下可能不能通过编译。</p> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;">参考：<br> 《Foundations of F#》 by Robert Pickering<br> 《.NET框架程序设计》 by Jeffery Richter<br> 《Expert F#》 by Don Syme , Adam Granicz , Antonio Cisternino</p> 
   <p style="line-height:1.8;color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"><br></p> 
   <p style="line-height:1.8;"><font color="#333333"><span style="font-size:14px;">本文转自一个程序员的自省博客园博客，原文链接：http://www.cnblogs.com/anderslly/archive/2008/10/12/fsharp-adventure-oop-part-three.html，如需转载请自行联系原作者。</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
