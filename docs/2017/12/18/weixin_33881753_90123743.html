<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ABP理论学习之依赖注入 « NotBeCN</title>
  <meta name="description" content="             本篇目录         什么是依赖注入            传统方式产生的问题       解决办法       依赖注入框架            ABP中的依赖注入基础设施            注册       解析       其他       ASP.NET MVC和ASP...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/18/weixin_33881753_90123743.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">ABP理论学习之依赖注入</h1>
    <p class="post-meta">Dec 18, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);">本篇目录</h2> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;"> <strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#what" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">什么是依赖注入</a></strong> 
     <ul>
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#problem" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">传统方式产生的问题</a></strong></li> 
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#solution" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">解决办法</a></strong></li> 
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#framework" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">依赖注入框架</a></strong></li> 
     </ul></li> 
    <li style="list-style:disc;"> <strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#infra" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">ABP中的依赖注入基础设施</a></strong> 
     <ul>
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#register" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">注册</a></strong></li> 
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#resolve" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">解析</a></strong></li> 
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#extra" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">其他</a></strong></li> 
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#integration" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">ASP.NET MVC和ASP.NET Web API集成</a></strong></li> 
      <li style="list-style:disc;"><strong><a href="http://www.cnblogs.com/farb/p/ABPDependencyInjection.html#tips" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">最后提示</a></strong></li> 
     </ul></li> 
   </ul>
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="what" style="color:rgb(224,130,131);"></a>什么是依赖注入</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>维基百科说：“依赖注入是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖”。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">不使用依赖注入技巧来管理依赖，并开发一个模块化的，结构友好的应用是非常困难的。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="problem"></a>传统方式产生的问题</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在一个应用中，类相互依赖。假设我们有个应用服务，该应用服务使用了仓储将实体插入数据库。在这种情况下，此应用服务类依赖于仓储类。看下面这个例子：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IPersonRepository _personRepository;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>(<span class="hljs-params"></span>) </span>{
        _personRepository = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PersonRepository();            
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">CreatePerson</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> name, <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> age</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> person = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><strong>PersonAppService</strong>使用了<strong>PersonRepository</strong>将一个&nbsp;<strong>Person</strong>插入到数据库中。此处代码的问题在于：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">PersonAppService在<strong>CreatePerson</strong>方法中使用了<strong>IPersonRepository</strong>的引用，因此该方法依赖于IPersonRepository,而不是具体的PersonRepository类。但是在PersonAppService的构造函数中仍旧依赖于PersonRepository。而组件应该依赖于接口而不是实现，这就是依赖反转原则。</li> 
    <li style="list-style:disc;">如果PersonAppService创建了PersonRepository本身，那么它会依赖于IPersonRepository接口的一个具体实现，这样就造成可能不会和其他实现一起工作。因此，从实现中分离接口就会变得毫无意义。硬依赖使得代码基变得紧耦合，可复用性降低。</li> 
    <li style="list-style:disc;">在未来我们可能需要改变PersonRepository的创建。比如，我们可能想要它是单例的（单一公用的实例而不是每次使用都创建一个对象）。或者我们可能不止会创建实现了IPersonRepository的一个类，也可能想要有条件地创建这些实现类中的一个。这种情况下，我们就要改变依赖IPersonRepository的所有类，这样太不方便了，或者说维护难度太大了。</li> 
    <li style="list-style:disc;">测试方面，有了这么个依赖，对于PersonAppService的单元测试非常难（或者根本不可能）。</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">为了克服这些问题，可以使用工厂模式。因此，仓储类的创建时抽象的。看下面的代码：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IPersonRepository _personRepository;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>(<span class="hljs-params"></span>) </span>{
        _personRepository = PersonRepositoryFactory.Create();            
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">CreatePerson</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> name, <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> age</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> person = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">PersonRepositoryFactory是一个创建并返回一个IPersonRepository的静态类。这就是所谓的<strong>服务定位器模式</strong>。这样创建问题是解决了，因为PersonAppService不知道如何创建一个IPersonRepository的实现，而且它独立于PersonRepository的实现。但是，仍然有下面这些问题：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">这次，PersonAppService依赖于PersonRepositoryFactory。这个较为可接受，但是仍然有硬依赖。</li> 
    <li style="list-style:disc;">为每个仓储或者依赖写一个工厂类或方法太繁琐了。</li> 
    <li style="list-style:disc;">还是不太好测试，因为让PersonAppService使用一些IPersonRepository的伪造实现还是很困难。</li> 
   </ul>
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="solution"></a>解决办法</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">要依赖其他的类有一些最佳实践（模式）。</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">构造函数注入模式</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的例子可以重写为下面的代码：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IPersonRepository _personRepository;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>(<span class="hljs-params">IPersonRepository personRepository</span>) </span>{
        _personRepository = personRepository;
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">CreatePerson</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> name, <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> age</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> person = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Person { Name = name, Age = age };
        _personRepository.Insert(person);
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这就是所谓的<strong>构造函数注入</strong>。现在，PersonAppService不知道哪一个类实现了IPersonRepository,也不知道如何创建的它。谁要使用PersonAppService，首先要创建一个IPersonRepository,并将它传给PersonAppService的构造函数，如下所示：</p> 
   <pre class="c#"><code class="hljs javascript" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> repository = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PersonRepository();
<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> personService = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PersonAppService(repository);
personService.CreatePerson(<span class="hljs-string" style="color:rgb(163,21,21);">"Yunus Emre"</span>, <span class="hljs-number">19</span>);
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">构造函数注入是使类独立于依赖对象创建的一种完美方式，但是，上面的代码存在一些问题：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">创建一个PersonAppService变得更加困难。试想如果它有4个依赖，那么我们必须创建这4个依赖的对象，然后把它们传入PersonAppService的构造函数中。</li> 
    <li style="list-style:disc;">依赖的类可能有其它的依赖（这里，PersonRepository可能有依赖）。因此，我们必须创建PersonAppService的所有依赖，依赖的所有依赖等等。这样的话，我们甚至可能不再创建单一对象，因为依赖图太复杂了。</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">幸运的是，ABP有依赖注入框架自动管理依赖。</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">属性注入模式</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">构造函数注入是提供一个类的依赖的完美模式。用这种方式，你可以不需要提供依赖就能创建一个类的实例，它也是显示声明该类需要满足什么要求才能正确工作的强大方式。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">但在某些情况下，该类依赖于其他的类而且其他的类没有它也能工作。这对于关注度分离（比如日志记录）来说经常是成立的。一个类可以离开logging工作，但如果提供了logger，那它就能记录日志。这种情况下，你可以定义将依赖定义为公共的属性而不是在构造函数中获得这些依赖。试想如果我们要在PersonAppService中记录日志，那么我们可以重写该类为：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> ILogger Logger { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IPersonRepository _personRepository;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>(<span class="hljs-params">IPersonRepository personRepository</span>) </span>{
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">CreatePerson</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> name, <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> age</span>) </span>{
        Logger.Debug(<span class="hljs-string" style="color:rgb(163,21,21);">"Inserting a new person to database with name = "</span> + name);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> person = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug(<span class="hljs-string" style="color:rgb(163,21,21);">"Successfully inserted!"</span>);
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">NullLogger.Instance是一个实现了ILogger的单例对象，但实际上什么都没做（没有记录日志，它使用了空的方法体实现了ILogger）。因此，如果你在创建PersonAppService对象之后，并像下面那样设置了Logger，PersonAppService就可以记录日志了：</p> 
   <pre class="c#"><code class="hljs javascript" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> personService = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PersonAppService(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PersonRepository());
personService.Logger = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Log4NetLogger();
personService.CreatePerson(<span class="hljs-string" style="color:rgb(163,21,21);">"Yunus Emre"</span>, <span class="hljs-number">19</span>);
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">假设Log4NetLogger实现了ILogger并使用Log4Net类库记录日志。这样，PersonAppService实际上就可以记录日志了。如果没有设置Logger，那么它就不会记录日志。因此，我们可以说ILogger是PersonAppService的一个<strong>可选依赖</strong>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">几乎所有的依赖注入框架都支持属性注入模式。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="framework"></a>依赖注入框架</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">有很多自动解析依赖的依赖注入框架。它们能够使用所有的依赖（包括依赖的依赖）创建对象。因此，你只需要使用构造和属性注入模式编写你的类，DI框架会处理剩下的事情。在一个优秀的应用中，你的类甚至独立于DI框架。在整个应用中，有许多显式和DI框架交互的代码行或者类。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">ABP使用Castle Windsor框架处理依赖注入。它是最成熟的DI框架之一。还有很多其他的框架，如Unity，Ninject,StructureMap，Autofac等等。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在依赖注入框架中，你首先要将你的接口或者类注册到其中，然后才可以解析（创建）一个对象。在Castle Windsor中，有点像下面那样：</p> 
   <pre class="c#"><code class="hljs dts" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">var container = new WindsorContainer();

container.Register(
        Component.For<span class="hljs-params">&lt;IPersonRepository&gt;</span>().ImplementedBy<span class="hljs-params">&lt;PersonRepository&gt;</span>().LifestyleTransient(),
        Component.For<span class="hljs-params">&lt;IPersonAppService&gt;</span>().ImplementedBy<span class="hljs-params">&lt;PersonAppService&gt;</span>().LifestyleTransient()
    );

var personService = container.Resolve<span class="hljs-params">&lt;IPersonAppService&gt;</span>();
personService.CreatePerson(<span class="hljs-string" style="color:rgb(163,21,21);">"Yunus Emre"</span>, <span class="hljs-number">19</span>);

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码中，首先创建了<strong>WindsorContainer</strong>，然后使用PersonRepository和PersonAppService的接口注册了它们，再然后我们要求容器创建一个IPersonAppService。容器使用依赖创建了PersonAppService并返回，也许在这个简单的例子中使用DI框架的优势不是很明显，但是想象一下你在一个真实的企业应用中会有很多类和依赖。当然，也会在别的地方使用对象来注册依赖，这个在应用启动时只会做一次。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">注意，我们也将对象的<strong>生命周期</strong>声明为<strong>transient</strong>。这意味着，无论何时解析这些类型的一个对象，都会创建一个新的实例。当然还有很多不同的生命周期（像singleton）。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="infra" style="color:rgb(224,130,131);"></a>ABP中的依赖注入基础设施</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当你通过下面的最佳实践和一些惯例编写你的应用时，ABP几乎让使用DI框架变得不可见了。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="register"></a>注册</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在ABP中，将你的类注册到DI系统有几种不同的方式。大多数情况下，按照惯例注册已经足够了。</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">惯例注册</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">ABP会按照惯例自动注册所有的仓储，领域服务，应用服务，MVC控制器和Web API控制器。比如，你可能有一个IPersonAppService接口和一个实现了该接口的PersonAppService类：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> <span class="hljs-title" style="color:rgb(163,21,21);">IPersonAppService</span> : <span class="hljs-title" style="color:rgb(163,21,21);">IApplicationService</span>
{
    <span class="hljs-comment" style="color:#008000;">//...</span>
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span> : <span class="hljs-title" style="color:rgb(163,21,21);">IPersonAppService</span>
{
    <span class="hljs-comment" style="color:#008000;">//...</span>
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">因为它实现了<strong>IApplicationService</strong>接口（只是一个空接口），所以ABP会自动注册它，并注册为<strong>transient</strong>（每次使用创建一个实例）。当你使用构造函数注入IPersonAppService接口到一个类中时，一个PersonAppService对象会自动地创建并传入该类的构造函数中。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><strong>命名规范</strong>在ABP中非常重要。比如，你可以将PersonAppService更名为MyPersonAppService或是其他包含了“PersonAppService”后缀的名字，因为IPersonAppService接口有这个后缀。但你不能将它命名为PeopleService。如果你没有按照这种命名规范来操作的话，那么IPersonAppService不会自动地注册（但是它已经以自注册的方式注入到DI框架，而不是接口方式），因此如果你想要以接口方式注册的话，那么你应该手动注册。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">ABP按照惯例注册程序集。因此，你应该按照惯例告诉ABP注册你的程序集。这个相当简单：</p> 
   <pre><code class="hljs css" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-selector-tag" style="color:rgb(0,0,255);">IocManager</span><span class="hljs-selector-class">.RegisterAssemblyByConvention</span>(<span class="hljs-selector-tag" style="color:rgb(0,0,255);">Assembly</span><span class="hljs-selector-class">.GetExecutingAssembly</span>());</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">Assembly.GetExecutingAssembly()会获得包含这句代码的程序集的引用。你也可以将其他的程序集传入RegisterAssemblyByConvention 方法中。这个操作通常在你的模块初始化的时候完成的。查看<strong><a href="http://www.cnblogs.com/farb/p/ABPModuleSystem.html" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">《模块系统》</a></strong>博文获得更多信息。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">通过实现<strong>IConventionalRegister</strong>接口和调用<strong>IocManager.AddConventionalRegister</strong>方法，你可以用你的类编写你自己的惯例注册类。你要做的就是在模块的PreInitialize方法中加入它。</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">帮助接口</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">你可能想要注册一个特殊的类，但是它不符合惯例注册的原则。为此，ABP提供了<strong>ITransientDependency</strong>&nbsp;和<strong>ISingletonDependency</strong>接口。比如：</p> 
   <pre class="c#"><code class="hljs typescript" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> IPersonManager
{
    <span class="hljs-comment" style="color:#008000;">//...</span>
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> MyPersonManager : IPersonManager, ISingletonDependency
{
    <span class="hljs-comment" style="color:#008000;">//...</span>
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">用这种方式，你可以轻松地注册MyPersonManager。当需要注入IPersonManager的时候，就会使用MyPersonManager。注意依赖声明为<strong>Singleton</strong>。这样，MyPersonManager的单例就被创建了，并且相同的对象也被传入到所有的类中。只有在第一次使用时才会创建，以后再整个应用的生命周期都会使用相同的实例。</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">自定义/直接注册</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果之前描述的方法还不能满足你，那么你可以直接使用<strong>Castle Windsor</strong>来注册你的类和依赖。这样，你就在Castle Windsor中注册任何东西。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">Castle Windsor有一个为了注册而要实现的接口<strong>IWindsorInstaller</strong>。你可以在应用中创建实现了IWindsorInstaller接口的类：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyInstaller</span> : <span class="hljs-title" style="color:rgb(163,21,21);">IWindsorInstaller</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Install</span>(<span class="hljs-params">IWindsorContainer container, IConfigurationStore store</span>) </span>{
        container.Register(Classes.FromThisAssembly().BasedOn&lt;IMySpecialInterface&gt;().LifestylePerThread().WithServiceSelf());
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">ABP会自动找到并执行这个类。最后，可以使用<strong>IIocManager.IocContainer</strong>属性到达WindsorContainer。获取更多Windsor信息，请查看<strong><a href="http://docs.castleproject.org/Default.aspx?Page=MainPage" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">官方文档</a></strong>。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="resolve"></a>解析</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">注册会将你的类，类的依赖和生命周期通知给IOC（控制反转）容器。接下来，你需要在应用中的某些地方使用IOC容器创建对象。ABP针对依赖的解析提供了很多选项。</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">构造函数&amp;属性注入</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">你可以将使用构造函数和属性注入获得类的依赖作为最佳实践。无论在哪里，你都应该这样做。例如：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> ILogger Logger { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IPersonRepository _personRepository;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">PersonAppService</span>(<span class="hljs-params">IPersonRepository personRepository</span>) </span>{
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">CreatePerson</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> name, <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> age</span>) </span>{
        Logger.Debug(<span class="hljs-string" style="color:rgb(163,21,21);">"Inserting a new person to database with name = "</span> + name);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> person = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug(<span class="hljs-string" style="color:rgb(163,21,21);">"Successfully inserted!"</span>);
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">IPersonRepository从构造函数注入，ILogger使用公共属性注入。这样的话，你的代码根本意识不到依赖注入系统的存在，也就是说，依赖系统对于我们开发者完全是透明的，我们可以不考虑依赖系统内部的实现细节。这是使用DI系统最合适的方式。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">IIocResolver和IIocManager</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">有时，你可能必须要直接解析依赖而不是通过构造函数和属性注入。这种情况要尽可能地避免，但这种情况也是有可能的。ABP提供了很多可以轻松注入并使用的服务。例如：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MySampleClass</span> : <span class="hljs-title" style="color:rgb(163,21,21);">ITransientDependency</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> IIocResolver _iocResolver;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">MySampleClass</span>(<span class="hljs-params">IIocResolver iocResolver</span>) </span>{
        _iocResolver = iocResolver;
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoIt</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//手动解析</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> personService1 = _iocResolver.Resolve&lt;PersonAppService&gt;();
        personService1.CreatePerson(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> CreatePersonInput { Name = <span class="hljs-string" style="color:rgb(163,21,21);">"Yunus"</span>, Surname = <span class="hljs-string" style="color:rgb(163,21,21);">"Emre"</span> });
        _iocResolver.Release(personService1);

        <span class="hljs-comment" style="color:#008000;">//安全地解析并使用</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> personService2 = _iocResolver.ResolveAsDisposable&lt;PersonAppService&gt;())
        {
            personService2.Object.CreatePerson(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> CreatePersonInput { Name = <span class="hljs-string" style="color:rgb(163,21,21);">"Yunus"</span>, Surname = <span class="hljs-string" style="color:rgb(163,21,21);">"Emre"</span> });
        }
    }
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在以上例子中的MySampleClass通过构造函数注入<strong>IIocResolver</strong>并用它来解析和释放对象。<strong>Resolve</strong>方法有许多重载可供使用。<strong>Release</strong>方法用来释放组件（对象）。调用Release来手动解析一个对象是很关键的，否则，应用会有内存泄漏问题。为了确保释放对象，要尽可能使用<strong>ResolveAsDisPosable</strong>(如例子中演示的那样)。在using块的末尾会自动地调用Release。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果你想要直接使用IOC容器（Castle Windor）来解析依赖，那么你可以构造函数注入<strong>IIocManager</strong>并使用IIocManager.IocContainer属性。如果你处于静态上下文或者不能注入IIocManager，那么最后的机会就是，你可以使用单例对象<strong>IocManager.Instance</strong>。但是，这种情况不容易测试。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="extra"></a>其他</h4> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">IShouldInitialize接口</h5> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">某些类在第一次使用前就要初始化。IShouldInitialize接口有一个Initialize方法。如果实现了该接口，那么在创建对象之后（使用前）就会自动地调用Initialize方法。当然，为了使该功能有效，你应该注入/解析该对象。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="integration"></a>ASP.NET MVC和ASP.NET Web API集成</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当然，为了解析依赖图中的根对象，我们必须调用依赖注入系统。在ASP.NET MVC应用中，根对象一般是一个<strong>Controller</strong>类。我们也可以在控制器中使用构造函数注入和属性注入模式。当一个请求到达应用时，IOC容器创建了控制器对象，然后所有的依赖递归地解析出来。那么，谁处理的这个呢？这是ABP通过扩展了ASP.NET MVC默认的控制器工厂自动完成的。相似地，对于ASP.Net Web API也是如此。你不必关心创建和释放对象的事情。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;"> <a name="tips"></a>最后提示</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">只要你遵循规则并使用上面的结构，ABP就能简化并自动化依赖注入的使用。大多数情况下，这些已经够用了。但是，如果你需要的话，你可以直接使用所有Castle Windsor的能力来执行任何任务（如自定义注册，注入钩子，拦截器等等）。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p><font color="#494949"><span style="font-size:15px;line-height:25px;">本文转自tkbSimplest博客园博客，原文链接：http://www.cnblogs.com/farb/p/ABPDependencyInjection.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
