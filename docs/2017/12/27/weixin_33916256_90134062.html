<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Net中的AOP系列之《间接调用——拦截方法》 « NotBeCN</title>
  <meta name="description" content="             本篇目录              方法拦截     PostSharp方法拦截     Castle DynamicProxy方法拦截     现实案例——数据事务     现实案例——线程     .Net线程基础     UI线程和工作线程     使用AOP的声明式线程     ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/27/weixin_33916256_90134062.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Net中的AOP系列之《间接调用——拦截方法》</h1>
    <p class="post-meta">Dec 27, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);">本篇目录</h2> 
   <ul>
    <li style="list-style:disc;"> </li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>方法拦截</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>PostSharp方法拦截</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>Castle DynamicProxy方法拦截</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>现实案例——数据事务</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>现实案例——线程</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>.Net线程基础</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>UI线程和工作线程</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>使用AOP的声明式线程</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>小结</b></span></font></li> 
   </ul>
   <hr style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">本系列的源码本人已托管于Coding上：<strong><a href="https://coding.net/u/farb/p/AbpPractice/git/tree/master/AOPPractice/WeiBoProject" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">点击查看</a></strong>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">本系列的实验环境：VS 2013 Update 5（建议最好使用集成了Nuget的VS版本，VS Express版也够用），安装PostSharp。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇博客覆盖的内容包括：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">什么是方法拦截</li> 
    <li style="list-style:disc;">使用Castle DynamicProxy拦截方法</li> 
    <li style="list-style:disc;">编写数据事务切面</li> 
    <li style="list-style:disc;">使用PostSharp拦截方法</li> 
    <li style="list-style:disc;">编写线程切面</li> 
   </ul>
   <hr style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">第一篇博文中已经宽泛地定义了<strong>连接点和切入点</strong>，将连接点定义为代码之间的任何点，将切入点描述为连接点的集合。这些定义不是很严格的，理论上，切面可以用于代码中的任何位置：比如，可以把一个切面放到一个if语句的内部或者使用一个切面修改for循环，但是在实际应用中，99%的时间都不需要那么做。很多优秀的框架（如PostSharp和Castle DynamicProxy）使得使用预定义的连接点编写切面很容易，并给你有限的能力描述切入点，但是你可仍然可以使用这有限的能力来处理绝大多数的AOP用例。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>剩余1%的时间可以干啥？<br> 很多低级别的工具可以让你深入到指令级别（IL）修改或创建代码，如Mono.Ceil，PostSharp SDK，.Net反射和Reflection.Emit。但是这个系列不是讨论元编程领域的，而是介绍切面的编写。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇我们会看一下方法拦截切面。这些切面可以在调用方法时，代替这些方法来运行代码。本篇会使用两个工具，但是方法拦截基本上是所有AOP框架最通用的功能。使用PostSharp和Castle DynamicProxy可以很容易地编写切面，一旦使用这些框架上手了方法拦截器，那么对任何包括方法拦截的框架都可以应付自如了。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="interception"></a>方法拦截</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">方法拦截切面是这么一个东西：<strong>代替被拦截的方法执行一段代码</strong>。切面会代替方法执行，就像正常的代码执行流程和方法之间有一个中间人一样。为了清楚地说明这个概念，看下图：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/8d77b883-8e6b-40dc-84da-18b981b3edd4.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/003ca31b-1e26-4d76-992d-3b67ee0db7b6.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">通过上面的两张图，我们就可以清楚地明白了方法拦截器的位置以及执行的次序。乍一看，方法拦截器好像另外加了一层，就像在一个事务中加了一个中间人一样，有人就会问，为甚不直接处理呢？但是，存在即合理，也正像生活中的中间人一样，方法拦截确实扮演了很重要的角色。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">拦截器中可以放些什么呢？可以记录即将发送的微博消息，可以验证要发送的字符串，可以修改要发送的字符串。如果发送失败了，可以记录消息发送失败，或者重新发送该消息。不需要修改<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Send</code>方法中的一行代码就可以添加各种各样的行为操作。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><strong>注意，不能完全取代拦截的方法。</strong>大多数情况下，切面会允许执行流继续执行拦截的方法，我们要做的就是在方法执行之前或返回之后执行一些其他的代码段。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="post" style="color:rgb(224,130,131);"></a>PostSharp方法拦截</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，使用上图的例子实现代码，我们这次使用的AOP框架是PostSharp，跟着来敲代码，你也能学会如何编写一个方法拦截切面。创建一个控制台程序，取名<em>WeiBoWithPostSharp</em>,然后对该项目添加PostSharp的引用。<br><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PM&gt; install-package postsharp</code></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这里为了演示，模拟一个微博服务，然后在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Main</code>方法中调用它的方法：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span>  <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">WeiBoClient</span>
 {
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Send</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> msg</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【微博客户端】正在发送消息："</span>+msg);
    }
 }


 <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> weiboService=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> WeiBoClient();
     weiboService.Send(<span class="hljs-string" style="color:rgb(163,21,21);">"hi"</span>);
     Console.WriteLine();
     Console.Read();
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这只是一个简单的程序，没什么好说的。下面要使用PostSharp提供的API创建一个方法拦截器切面：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> [Serializable]
 <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyInterceptorAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">MethodInterceptionAspect</span>
 {
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnInvoke</span>(<span class="hljs-params">MethodInterceptionArgs args</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【拦截器：】，方法执行前拦截到的信息是："</span>+args.Arguments.First());<span class="hljs-comment" style="color:#008000;">//打印出拦截的方法第一个实参</span>
         args.Proceed();<span class="hljs-comment" style="color:#008000;">//Proceed()方法表示继续执行拦截的方法</span>
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【拦截器：】，方法已在成功{0}执行"</span>,DateTime.Now);<span class="hljs-comment" style="color:#008000;">//被拦截方法执行完成之后执行</span>
     }
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">补充一下代码中没有说明的3点：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;"> <strong>[Serializable]</strong>：当使用PostSharp时，必须要确保在切面类上使用了[Serializable]特性，因为PostSharp需要实例化并序列化切面对象，为的是能够在编译后反序列化这些对象使用。</li> 
    <li style="list-style:decimal;"> <strong>MethodInterceptionAspect</strong>：所有的方法拦截切面都必须继承这个类。</li> 
    <li style="list-style:decimal;"> <strong>OnInvoke</strong>:故名思义，就是在拦截方法执行时会调用这个方法，其实准确讲，被拦截的方法会在这个方法里面执行。</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">第一个切面就定义好了，那该怎么用呢？使用PostSharp时，直接将你的拦截方法切面以特性的方式直接标注在要拦截的方法之上即可：</p> 
   <pre class="c#"><code class="hljs cpp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> [MyInterceptorAspect]
 <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Send</span><span class="hljs-params">(<span class="hljs-built_in" style="color:rgb(0,0,255);">string</span> msg)</span> </span>{
     Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【微博客户端】正在发送消息："</span>+msg);
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行，看下效果：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/621a3e19-23cb-4e78-b43b-d6811f48f6cd.png" alt="图片" style="border:0px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="castle" style="color:rgb(224,130,131);"></a>Castle DynamicProxy方法拦截</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，我们使用另一个AOP框架Castle DynamicProxy来编写和上面一样的方法拦截，这两个工具有相似的API，就方法拦截来说，也提供了相似的功能，但是还是有很多不同的。现在，我们只需要记住的是，<strong>PostSharp是在编译后进行工作的，而Castle DynamicProxy是在运行时工作的</strong>。<br> 使用和上面的控制台项目相同的解决方案，另建一个控制台项目，取名<em>WeiBoWithDynamicProxy</em>，因为Castle DynamicProxy是Castle.Core类库的一部分，因此需要安装Castle.Core安装包：<br><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PM&gt; Install-package castle.core</code></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">把之前那个项目的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WeiboClient</code>类拷贝到新项目，Program的Main方法和上面项目保持一致。要使用Castle DynamicProxy创建一个切面，，需要创建一个实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IInterceptor</code>的接口（该接口需要实现方法<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Intercept</code>）:</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyInterceptorAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IInterceptor</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【DynamicProxy拦截器】"</span>);
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，需要告诉DynamicProxy拦截什么代码。使用PostSharp，可以在一个单独的方法上应用拦截器，但是使用DynamicProxy，必须在一个完整的类的对象上使用拦截器（使用DynamicProxy的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IInterceptorSeletor</code>也可以像PostSharp那样定位到单个方法，但是它仍然要为整个类创建一个代理）。使用DynamicProxy，有两个步骤：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ProxyGenerator</code>(代理生成器)。</li> 
    <li style="list-style:decimal;">使用该<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ProxyGenerator</code>应用拦截器。</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用常规的实例化创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ProxyGenerator</code>,然后使用它来应用拦截器，给它传入<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WeiboClient</code>的实例，这里使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ProxyGenerator</code>API的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">CreateClassProxy</code>方法，因为这是演示DynamicProxy最方便的方式，后面我们会探索其他的一些用法：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> proxyGenerator=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ProxyGenerator();<span class="hljs-comment" style="color:#008000;">//创建一个代理生成器</span>
     <span class="hljs-comment" style="color:#008000;">//下面这行代码是为要拦截的类创建代理，第一个泛型参数就是要拦截的类，第二个参数是自定义的切面</span>
      <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> weiboService=proxyGenerator.CreateClassProxy&lt;WeiBoClient&gt;(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyInterceptorAspect());
     weiboService.Send(<span class="hljs-string" style="color:rgb(163,21,21);">"hello"</span>);

     Console.Read();
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">好像这样就应该没问题了是吧，来跑一下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/21f26735-1d9a-4adc-b950-9bbbf5a731f6.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">按理说，应该只显示拦截器中的内容，但这里却输出了微博客户端发出的消息，所以就是说我们的拦截器没拦截到东西。这也就是我要说的，要想成功地拦截方法，被拦截的方法必须使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">virtual</code>关键字修饰，这是很重要的，没有这个关键字，拦截器就不会执行，所以微博客户端代码修改为：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span>  <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">WeiBoClient</span>
  {
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">virtual</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Send</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> msg</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【微博客户端】正在发送消息："</span>+msg);
     }
  }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这样，效果就出来了：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/b6d9759c-a1fe-4caf-96f4-3f5ab32c20bf.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">因为拦截器里只输出了一句话，所以我们也只看到了一句话，如果就这样完事的话，这是不合理的，因为相当于我们把拦截的方法给吃掉了，绝大多数情况下，这样做是没有价值的。如果想继续执行被拦截的方法，就可以使用和PostSharp一样的用法：</p> 
   <pre class="c#"><code class="hljs cpp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span><span class="hljs-params">(IInvocation invocation)</span> </span>{
    Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【DynamicProxy拦截器执行开始：{0}】"</span>,DateTime.Now);
    Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【DynamicProxy拦截器】拦截到的方法传入的实参是："</span>+invocation.Arguments.First());
    invocation.Proceed();
    Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"【DynamicProxy拦截器执行结束：{0}】"</span>,DateTime.Now);
}


</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行效果如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/50c6ea06-2e4f-4b5c-9098-86cacf2effd2.png" alt="图片" style="border:0px;"></p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">Castle DynamicProxy和virtual</h4> 
    <p><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">CreateClassProxy</code>返回的对象类型不是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WeiboClient</code>,而是使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WeiboClient</code>作为基类动态生成的一个类型<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WeiboClientProxy</code>,就是产生了一个继承自原来的对象的代理类（就是一个子类），因此每个要被拦截的方法必须使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">virtual</code>，子类才可以重写父类的方法，也就是代理类才可以正确执行，否则就会出现之前的结果，只执行了WeiboClient中的方法，而根本没有拦截到的情况。对源码感兴趣的可以<strong><a href="https://github.com/castleproject/Core/blob/master/src/Castle.Core/DynamicProxy/ProxyGenerator.cs" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">点击阅读</a></strong>。<br> 如果你用过NHibernate,那么应该熟悉相似的需求，这不仅仅是巧合：因为NHibernate使用了Castle DynamicProxy。<br> 如果你不喜欢这个，那么也不要抱怨，我这里只是为了演示如何拦截一个具体的类。如果我使用的是一个接口的话（IWeiboClient），那么我可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">CreateInterfaceProxyWithTarget</code>的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ProxyGenerator</code>方法代替，并且拦截的接口成员是不需要定义为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">virtual</code>的。请继续关注此系列博客，后面会使用Castle DynamicProxy集合IoC工具<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">StructureMap</code>做一些示例。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然这些例子都不怎么有趣，但这有助你理解方法拦截的根本。PostSharp和Castle DynamicProxy虽然在很多方面不同，但是就方法拦截的本质来说，它们都有相似的API和功能。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在微博的例子告一段落，继续深入一些实际的例子。后面，你会学到使用.Net中最流行的两个AOP框架编写拦截方法切面的基础东西。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="data"></a>现实案例——数据事务</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">事务管理是使用数据库工作很重要的一部分，如果涉及多个数据库操作，经常想要这些操作全部成功或失败，否则就会产生无效的数据或使数据不一致。<br> 可以实现这个目标的一种方式是使用事务，事务的基本组件包括：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">开始【begin】：标记事务开始的地方</li> 
    <li style="list-style:decimal;">执行相关的操作：例如数据库操作，通常是2个即以上操作</li> 
    <li style="list-style:decimal;">提交【commit】：操作完成时，提交表示事务执行完毕</li> 
    <li style="list-style:decimal;">回滚【rollback】：如果操作中发生了错误，就不会提交了，此时会回滚，返回到最初的状态</li> 
    <li style="list-style:decimal;">重试【retry】（可选的）：不强制要求重试，但是事务回滚之后，经常可以尝试一下重试。</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">事务很有用，但是它是个横切关注点，里面可以放一些模板代码，会对你的代码产生噪音。因此，可以把事务方便地放到一个切面中，现在我们就来做这件事。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">使用begin和commit确保数据集成</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">我们暂时假设所有都会成功，只需要begin和commit,而不考虑rollback。这里在原来的解决方案中，再创建一个控制台项目，取名<em>DataTransactionCastle</em>,很明显，我们要使用Castle DynamicProxy,因此需要安装它。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在演示事务之前，先来创建一些值得使用事务的代码。比如创建一个保存发票（invoice）服务类<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InvoiceService</code>,我们会创建3个不同的保存方法：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">Save方法总是成功</li> 
    <li style="list-style:decimal;">SaveRetry方法在重试之后会成功</li> 
    <li style="list-style:decimal;">SaveFail总是失败，即使在重试次数用完时也失败</li> 
   </ol>
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">  <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">InvoiceService</span>
  {
      <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">virtual</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Save</span>(<span class="hljs-params">Invoice invoice</span>) </span>{
          Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"已保存"</span>);
          <span class="hljs-comment" style="color:#008000;">//该方法总是成功</span>
      }

      <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> isRetry;
      <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">virtual</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">SaveRetry</span>(<span class="hljs-params">Invoice invoice</span>) </span>{
          <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!isRetry)
          {
              Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"第一次保存失败"</span>);
              isRetry = <span class="hljs-keyword" style="color:rgb(0,0,255);">true</span>;<span class="hljs-comment" style="color:#008000;">//该方法第一次总是失败，但之后都是成功</span>
              <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> DataException();
          }
          Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"保存成功"</span>);
      }

      <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">virtual</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">SaveFail</span>(<span class="hljs-params">Invoice invoice</span>) </span>{
          Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"保存失败"</span>);
          <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> DataException();<span class="hljs-comment" style="color:#008000;">//该方法总是抛出数据异常</span>
      }
  }

 <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span>  <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Invoice</span>
  {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> Guid Id { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
     <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> DateTime Date { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
     <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt; Items { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
  }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">注意，这些方法都使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">virtual</code>，在Main方法中，输入下面的代码：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> srv=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> InvoiceService();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> invoice=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Invoice
    {
        Id = Guid.NewGuid(),
        Date = DateTime.Now,
        Items = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt;() { <span class="hljs-string" style="color:rgb(163,21,21);">"1"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"2"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"3"</span>}
    };
    srv.Save(invoice);
    <span class="hljs-comment" style="color:#008000;">//srv.SaveRetry(invoice);</span>
    <span class="hljs-comment" style="color:#008000;">//srv.SaveFail(invoice);</span>
    Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"执行结束!"</span>);
    Console.Read();
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">最后三个Save方法要一个一个轮流执行，执行结果很简单，这里不再演示。在实际开发中，这三种情况是在服务类的一个方法中，虽然我们很希望每次都保存成功，但总有意外存在，因此我们必须为其他场景也要做好准备。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">我们可以直接将事务代码添加到服务类中，但是想一下SRP原则，如果我们把事务代码添加到服务类中，那么这个类就会做两件事，所以，应该创建一个分离的拦截器以一种重用的方式来处理所有的事务相关的工作。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">先来创建一个拦截器<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TransactionWithRetries</code>，之前已经假设所有事务操作都会成功了，所以代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TransactionWithRetries</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IInterceptor</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器开始："</span> + DateTime.Now);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> ts = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TransactionScope();<span class="hljs-comment" style="color:#008000;">//创建一个事务范围对象</span>
        ts.Complete();<span class="hljs-comment" style="color:#008000;">//事务完成</span>
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器结束："</span>+DateTime.Now);
    }
}


</code></pre> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">TransactionScope</h4> 
    <p>TransactionScope是System.Transactions中的类，是.NET框架中自带的类。如果TransactionScope如果没有调用Complete方法就被释放（TransactionScope实现了IDisposible接口，建议使用using块）了，那么它会认为操作执行失败并将执行回滚。<br> TransactionScope是一个有用的API，它可以管理周围事务（“周围”意味着支持TransactionScope的数据库可以自动管理事务），大多数主流数据库都支持这个API，当然包括微软自家的MSSQL。<br> 如果你使用的数据库或某些事务相关的系统不支持TransactionScope，那么仍然可以使用拦截器，但是必须修改代码使用合适的支持事务的API（比如，使用BeginTransaction API可以获得数据库provider的IDbTransaction的实现）。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果被拦截的方法没有异常执行完毕了，那么就会调用TransactionScope的Complete方法，表示事务成功执行。在Main方法中使用定义的拦截切面如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
            <span class="hljs-comment" style="color:#008000;">//var srv=new InvoiceService();</span>

            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> proxyGenerator = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ProxyGenerator();
            <span class="hljs-comment" style="color:#008000;">//使用被拦截的类和自定义的切面类创建动态代理</span>
            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> srv = proxyGenerator.CreateClassProxy&lt;InvoiceService&gt;(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TransactionWithRetries());
            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> invoice=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Invoice
            {
                Id = Guid.NewGuid(),
                Date = DateTime.Now,
                Items = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt;() { <span class="hljs-string" style="color:rgb(163,21,21);">"1"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"2"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"3"</span>}
            };
            srv.Save(invoice);<span class="hljs-comment" style="color:#008000;">//使用这个Save方法来测试一下</span>
            <span class="hljs-comment" style="color:#008000;">//srv.SaveRetry(invoice);</span>
            <span class="hljs-comment" style="color:#008000;">//srv.SaveFail(invoice);</span>
            Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"Save successfully!"</span>);<span class="hljs-comment" style="color:#008000;">//输出一句表示执行成功</span>
            Console.Read();
        }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">执行结果没什么好说的：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/ef983965-4909-4138-8059-66713df99adb.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在理论上的场景都覆盖到了，如果报错了会怎样呢？</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">当事务出错时：回滚</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当然，如果事务总是执行成功的话，那就不需要事务了。之所以会有事务的原因就是解决多个操作中有失败的问题的，如果有操作失败就回滚。<br> 因为这里使用的.NET的TransactionScope，没有显式的回滚调用，最接近的等价方式是使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Dispose</code>方法。如果TransactionScope在Complete方法调用之前释放，那么TransactionScope就会执行回滚。因此，需要在事务拦截器切面中添加一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Dispose</code>调用执行回滚。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TransactionWithRetries</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IInterceptor</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器开始："</span> + DateTime.Now);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> ts = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TransactionScope();<span class="hljs-comment" style="color:#008000;">//创建一个事务范围对象</span>
        ts.Complete();<span class="hljs-comment" style="color:#008000;">//事务完成</span>
        ts.Dispose();<span class="hljs-comment" style="color:#008000;">//释放事务范围对象</span>
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器结束："</span>+DateTime.Now);
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在C#中，我们可以使用一种更简洁的语法，借助using块，其实using语句块结束时，会自动帮助我们调用TransactionScope的Dispose方法。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TransactionWithRetries</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IInterceptor</span>
 {
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器开始："</span> + DateTime.Now);
         <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> ts = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TransactionScope())<span class="hljs-comment" style="color:#008000;">//创建一个事务范围对象</span>
         {
             invocation.Proceed();<span class="hljs-comment" style="color:#008000;">//执行被拦截的方法</span>
             ts.Complete();<span class="hljs-comment" style="color:#008000;">//事务完成</span>
         }
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器结束："</span>+DateTime.Now);
     }
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果被拦截的方法没有异常执行完毕，那么就会执行<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ts.Complete();</code>,然后事务就会立即提交。如果被拦截的方法中出现了异常，那么TransactionScope就会在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ts.Complete();</code>之前释放（多亏了using语法和.Net的GC），触发回滚。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，这个切面已经覆盖了理想的场景Save方法，也覆盖了最糟糕的场景SaveFail方法，下一个就是支持SaveRetry方法了。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">事务操作执行失败时：重试</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">前面覆盖了总是成功和总是失败的场景，这次要覆盖的场景是第一次失败时，重试一次，至于重试几次，这个可以自己定，代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">  <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
      Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器开始："</span> + DateTime.Now);
      <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> isSucceeded = <span class="hljs-keyword" style="color:rgb(0,0,255);">false</span>;
      <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> retries = <span class="hljs-number">3</span>;
      <span class="hljs-keyword" style="color:rgb(0,0,255);">while</span> (!isSucceeded)
      {
          <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> ts = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TransactionScope())
          {
              <span class="hljs-keyword" style="color:rgb(0,0,255);">try</span>
              {
                  invocation.Proceed();
                  ts.Complete();
                  isSucceeded = <span class="hljs-keyword" style="color:rgb(0,0,255);">true</span>;
              }
              <span class="hljs-keyword" style="color:rgb(0,0,255);">catch</span> (Exception)
              {
                  <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (retries&gt;=<span class="hljs-number">0</span>)
                  {
                      Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"重试中..."</span>);
                      retries--;
                  }
                  <span class="hljs-keyword" style="color:rgb(0,0,255);">else</span>
                  {
                      <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span>;
                  }
              }

          }
      }
      Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器结束："</span>+DateTime.Now);
  }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个重试逻辑上一篇已经介绍过了，这里再稍微说一下。这里添加了循环进行重试，重试次数为3，如果第一次抛出了异常，那么就会执行catch块中的代码，那么就会输出“重试中...”，然后重试次数递减，再次执行和原来相同的逻辑，最后如果重试次数都用完了还没提交事务，就只能抛出异常。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">保留这个Save<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">srv.SaveRetry(invoice);</code>，注释其他两个Save，看一下执行结果：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/2737cccd-38a3-4acc-bc96-9c538220edd0.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当然，这里稍微优化一下，比如最大重试次数，可以移到构造函数的参数中，这样可以方便配置，如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TransactionWithRetries</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IInterceptor</span>
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> _maxRetries;
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">TransactionWithRetries</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> maxRetries</span>) </span>{
         _maxRetries = maxRetries;
     }
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"拦截器开始："</span> + DateTime.Now);
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> isSucceeded = <span class="hljs-keyword" style="color:rgb(0,0,255);">false</span>;
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> retries = _maxRetries;
        <span class="hljs-comment" style="color:#008000;">//...</span>
        </code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">配置最大重试次数的时候，只需要new的时候传入次数值就可以了。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">此外，我们还可以在提示“重试中...”的时候，具体一点，比如“重试SaveRetry方法中...”,<strong>这里提示大家一点，这个invocation参数里面有很多有趣的上下文信息，请自行查看学习，本系列不可能把每个上下文信息都介绍一遍</strong>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">比如，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">invocation.Method</code>会返回一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodInfo</code>对象，该对象来自System.Reflection命名空间,它代表被拦截的方法，因此，我们可以通过它的Name属性拿到被拦截方法的方法名称：</p> 
   <pre class="c#"><code class="hljs lua" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (retries&gt;=<span class="hljs-number">0</span>)
 {
     Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"重试方法{0}中..."</span>,invocation.Method.Name);
     retries<span class="hljs-comment" style="color:#008000;">--;</span>
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/0abe3b4d-adb0-4e1b-845d-922c66bea9b0.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在已经使用DynamicProxy的API完成了一个有用的拦截器切面，下面我们切换到PostSharp，再看一个现实中的拦截器切面。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="thread"></a>现实案例——线程</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当将一个程序加载到内存并开始执行时，它就是一个进程。CPU会读取该进程的每个指令，一次读一个。有时想要处理多个事情，比如，当等待一个缓慢的web服务时，你可能会通过UI通知用户进度。要完成这件事，你可以使用多线程，它就像很多微处理。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然Web开发者没有像桌面或者移动开发者那么多的机会使用.Net的多线程能力，但是即使对于老练的桌面开发者，多线程可能也是一个痛苦的经历：多线程很难编写、调试、阅读和测试。然而，创建一个可响应的桌面体验，编码时多线程经常是无法避免的。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">事实就是这样，但是这里要将线程引入AOP的原因是：我们可以通过AOP做点事情，使得线程代码编写和阅读稍微有点容易。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="basic" style="color:rgb(224,130,131);"></a>.Net线程基础</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">随着多核心编程变得越来越重要、越来越普遍，编写多线程程序方式的数量也随之更加。微软和其他第三方都提供了许多值得进一步探索的线程选项。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个例子会使用旧式的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Thread</code>类，如果你偏爱其他编写线程代码的方式，那么AOP可以容易地以模块化、封装的方式来编写线程代码，而无需在多个地方横切代码。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">假设有个耗时操作<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DoWork</code>方法，因此，需要在一个工作线程中运行它，这样做是为了能够释放UI，以通知用户当前的状态或者允许用户进行其它操作。要在一个线程中运行<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DoWork</code>，只需要创建一个线程对象，然后开启线程即可：</p> 
   <pre class="c#"><code class="hljs javascript" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> thead=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Thread(DoWork);
thead.Start();
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然这行代码看着很简单，但是Thread类还有很多其他能力：检查线程是否仍然活着，设置线程为后台线程，线程优先级等等。编码时，经常需要<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">System.Threading</code>的其他API，如<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ManualResetEvent , ThreadPool , Mutex</code>，很可能也需要<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">lock</code>关键字。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">多线程不是本篇的重点，就不多言了。现在，我们要做的例子只是使用了多线程中一些基本的东西。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="ui" style="color:rgb(224,130,131);"></a>UI线程和工作线程</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">创建一个WinForm项目，取名<em>WeiboWindow</em>，这个项目使用了线程，但没有使用任何AOP。界面如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/596971a8-f2e5-4482-b4ff-cb04e1dd80a9.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这里的需求是：点击更新按钮，ListBox控件中的内容会更新来自一个web服务的微博消息，当然，微博消息是模拟的：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">WeiboService</span>
 {
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetMessage</span>(<span class="hljs-params"></span>) </span>{
         Thread.Sleep(<span class="hljs-number">3000</span>);<span class="hljs-comment" style="color:#008000;">//模拟一个缓慢的web服务</span>
         <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-string" style="color:rgb(163,21,21);">"消息来自"</span> + DateTime.Now;
     }
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">双击更新按钮，VS会自动帮我们为更新按钮生成一个点击事件，我们可以在这个方法中更新ListBox的内容：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">partial</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Form1</span> : <span class="hljs-title" style="color:rgb(163,21,21);">Form</span><span class="hljs-comment" style="color:#008000;">//这是Form1代码后置类,是个分部类，UI布局代码在另一个分离的类中</span>
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span>  WeiboService _weiboService;
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">Form1</span>(<span class="hljs-params"></span>) </span>{
         InitializeComponent();
     }

     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">protected</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnLoad</span>(<span class="hljs-params">EventArgs e</span>) </span>{
         _weiboService=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> WeiboService();<span class="hljs-comment" style="color:#008000;">//当窗体加载事件触发时，实例化一个服务类</span>
     }

     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">btnUpdate_Click</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>)<span class="hljs-comment" style="color:#008000;">//更新按钮的单击事件</span> </span>{
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> msg = _weiboService.GetMessage();
         listBox.Items.Add(msg);
     }
 }


</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">好了，运行程序，你会发现，当点击了更新按钮之后的3秒内，也就是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">GetMessage</code>方法运行时，UI界面“死掉了”，点击哪里都没任何反应了，移动不了窗体，不能滚动ListBox的滚动条。这是因为这个进程只有一个主线程，当点击更新按钮后，主线程也参与了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">GetMessage</code>方法的执行，从而没时间处理UI界面上的东西，所以给我们的表现是“界面锁死”。<br> 那当请求web服务时不想界面毫无响应怎么办（也许我们会展示一个loading动画等等）？这就需要我们创建一个工作线程来处理<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">GetMessage</code>方法的执行，而原来的主线程（也就是UI线程）来处理其他操作（点击，滚动等等）。修改代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">btnUpdate_Click</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>)<span class="hljs-comment" style="color:#008000;">//更新按钮的单击事件</span> </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> thread=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Thread(GetMsg);<span class="hljs-comment" style="color:#008000;">//初始化一个新的线程来处理GetMsg方法</span>
    thread.Start();<span class="hljs-comment" style="color:#008000;">//开启线程</span>
}

<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetMsg</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> msg = _weiboService.GetMessage();
    listBox.Items.Add(msg);
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在看着好多了，执行一下（Ctrl+F5）,debug模式会报错：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/2b6dfc16-96c5-4fb9-8395-ecc8aab898bf.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，可以连续多次点击更新按钮，并且窗体可以移动，listBox的滚动条也能滚动了。如果是在debug模式下运行的话，当代码向ListBox上添加项时，会报<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InvalidOperationException</code>错误，这是因为在winform应用中，UI控件是线程不安全的。就像数据库事务一样，如果从多个线程操作UI控件的话，会导致UI控件进入不一致的状态。操作来自线程的（非UI线程）控件对象的方法不可取，因为在Debug模式下总是抛异常，在非Debug模式也可能会出现各种错误。<br> 那么如何检查是否运行在UI线程上呢？如果不是的话，如何让代码运行在UI线程上？使用继承自Form基类的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InvokeRequired</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Invoke</code>成员，如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetMsg</span>(<span class="hljs-params"></span>) </span>{
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> msg = _weiboService.GetMessage();
     <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (InvokeRequired)
     {
         Invoke(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Action(() =&gt; { listBox.Items.Add(msg); }));
     }
     <span class="hljs-keyword" style="color:rgb(0,0,255);">else</span>
     {
         listBox.Items.Add(msg);
     }
 }

</code></pre> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">InvokeRequired和Invoke</h4> 
    <p>InvokeRequired用来询问当前的线程是否在UI线程上。如果是true，那么当前的线程就不在UI线程上，这种情况就必须调用Invoke方法执行代码，它可以处理winform控件。<br> 这种模式不受限于winform。检查当前的线程和使用UI线程的特定方式可能根据使用的应用类型而变化。WPF使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Dispatcher.CheckAccess</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Dispatcher.Invoke</code>。其他的UI技术，如Mono for Android,WinPhone和Silverlight可能也有变化。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">代码稍微优化一下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetMsg</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> msg = _weiboService.GetMessage();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (InvokeRequired)

        Invoke(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Action(() =&gt; UpdateListboxItems(msg)));
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">else</span> <span class="hljs-title" style="color:rgb(163,21,21);">UpdateListboxItems</span>(<span class="hljs-params">msg</span>)</span>;
}

<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">UpdateListboxItems</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> msg</span>) </span>{
    listBox.Items.Add(msg);
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在不论是F5的debug模式还是Ctrl+F5的非debug运行模式，都不会报之前的错了。现在这个例子很简单，但是真实项目中涉及线程的代码都是很凌乱的，因此，这里我们展示一下如何使得线程代码更容易阅读和编写。想象一下，如果我们能在Form1类中这样写代码，那么看起来简直太漂亮了：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 使用了AOP版本</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">btnUpdate_Click</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>)<span class="hljs-comment" style="color:#008000;">//更新按钮的单击事件</span> </span>{
    GetMsg();
}

[WorkerThread]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetMsg</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> msg = _weiboService.GetMessage();
    UpdateListboxItems(msg);
}

[UIThread]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">UpdateListboxItems</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> msg</span>) </span>{
    listBox.Items.Add(msg);
}

<span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码主要有三个变化：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">在单击事件中不需要在创建一个Thread对象了，只需要直接调用方法。阅读起来更加清晰，因为没有任何关于开启一个新线程的噪音代码。</li> 
    <li style="list-style:decimal;"> <code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">GetMsg</code>方法有一个WorkerThread特性，声明了它会运行在一个工作线程中，注意方法内的代码没有了之前的InvokeRequired和Invoke噪音代码了，更容易阅读，我们可以更清楚地知道它在做什么了。</li> 
    <li style="list-style:decimal;">UpdateListboxItems方法不变，只是加了一个UIThread特性，表明它运行在UI线程上。</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面设想的代码更短、更具声明式，并且没有包含线程细节。把代码放到一个工作线程上就像使用特性一样简单，而且如果想更改线程细节（比如要使用.Net 4中的Task类），只需要在一个地方处理就行了。我们可以通过AOP写两个小的拦截器切面就可以完成这种声明式线程代码了。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="useaop" style="color:rgb(224,130,131);"></a>使用AOP的声明式线程</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">要解决上面设想的场景，我们需要两个拦截器切面，第一个是把拦截到的方法放到一个工作线程中，另一个是把拦截到的方法放到一个UI线程中。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">动手时间：在刚才建的winform项目里安装postsharp，创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WorkerThread</code>切面，它继承自<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodInterceptionAspect</code>,并重写OnInvoke方法：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">WorkerThread</span>:<span class="hljs-title" style="color:rgb(163,21,21);">MethodInterceptionAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnInvoke</span>(<span class="hljs-params">MethodInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> thread=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Thread(args.Proceed);<span class="hljs-comment" style="color:#008000;">//将被拦截的方法传入线程构造函数</span>
        thread.Start();
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个切面的目的是将被拦截的方法移到一个新的线程中。但是该工作线程要更新UI的话，如果我们没有检查<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InvokeRequired</code>，那么运行还是会出现之前的问题。所以我们还必须创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">UIThread</code>切面：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">UIThread</span> : <span class="hljs-title" style="color:rgb(163,21,21);">MethodInterceptionAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnInvoke</span>(<span class="hljs-params">MethodInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> form = args.Instance <span class="hljs-keyword" style="color:rgb(0,0,255);">as</span> Form;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (form.InvokeRequired)
            form.Invoke(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Action(args.Proceed));
        <span class="hljs-keyword" style="color:rgb(0,0,255);">else</span>
            args.Proceed();
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个切面的目的是检查是否必须调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Invoke</code>。但是如何在独立于Form类的切面类中使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InvokeRequired</code>属性和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Invoke</code>方法呢？幸运的是，我们可以通过<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args</code>参数来 获得正在拦截的方法的实例对象，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.Instance</code>会返回一个类型为object的方法的实例对象，因此在使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InvokeRequired和Invoke</code>之前需要将它转成Form类型。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodInterceptionArgs</code>类型的args参数包含了很多关于被拦截的方法的其他信息：上下文、传入的实参等等。这和Castle DynamicProxy的IInvocation API是一样的，建议读者自行探索所有可用的方法和属性。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用了这两个切面之后，代码就更加可读了，线程也更加容易使用了，此外，我们也把线程细节代码从之前的类中解耦以及封装到它们自己的类了。因此，如果想要切换使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Task</code>类的话，只需要在对应的切面中修改代码就可以了：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnInvoke</span>(<span class="hljs-params">MethodInterceptionArgs args</span>) </span>{
    <span class="hljs-comment" style="color:#008000;">//var thread=new Thread(args.Proceed);//将被拦截的方法传入线程构造函数</span>
    <span class="hljs-comment" style="color:#008000;">//thread.Start();</span>

    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> task=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Task(args.Proceed);
    task.Start();
}



</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">最后，再次强调一下，这篇不是讲多线程的，只是为了演示多线程代码经常会作为横切关注点穿插在UI代码中，使得业务代码和横切关注点之间纠缠交错，而使用切面会将这些横切关注点分离到单独的类中。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="summary"></a>小结</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇覆盖了切面最常见的类型：方法拦截切面。方法拦截切面就像调用者和被调用方法之间的中间人一样，不需要修改被调用方法就可以添加和修改方法的行为，也提供了将横切关注点封装到单独类中的能力，改善了代码的组织和复用性。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">PostSharp，Castle DynamicProxy和其他类似的工具都使得编写切面相当简单，它们的API都允许我们在任何时间执行被拦截的方法，这些API也提供了关于被拦截方法的上下文信息，包括该方法的信息（如方法名），以及该方法在哪个类中，传入方法的实参等等。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p><font color="#494949"><span style="font-size:15px;line-height:25px;">本文转自tkbSimplest博客园博客，原文链接：http://www.cnblogs.com/farb/p/MethodInterception.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
