<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>系统架构技能之设计模式-组合模式 « NotBeCN</title>
  <meta name="description" content="             一、上篇回顾         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们上篇主要讲述了结构型模式中的外观模式，外观模式作为结构型模式中的一个简单又实用的模式，外观模式通过封装细节来提供大粒度的调用，     直接的好处就是，封装细节，提供了应用写程序的可维护性和易...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/12/weixin_33982670_90133415.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">系统架构技能之设计模式-组合模式</h1>
    <p class="post-meta">Dec 12, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">一、上篇回顾</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们上篇主要讲述了结构型模式中的外观模式，外观模式作为结构型模式中的一个简单又实用的模式，外观模式通过封装细节来提供大粒度的调用，</p> 
    <p>直接的好处就是，封装细节，提供了应用写程序的可维护性和易用性。外观模式一般应用在系统架构的服务层中，当我们是多个不同类型的客户端应用程序</p> 
    <p>时，比如一个系统既可以在通过Web的形式访问，也可以通过客户端应用程序的形式时，可能通过外观模式来提供远程服务，让应用程序进行远程调用，</p> 
    <p>这样通过外观形式提供服务，那么不管是什么样的客户端都访问一致的外观服务，那么以后就算是我们的应用服务发生变化，那么我们不需要修改没一个客</p> 
    <p>户端应用的调用，只需要修改相应的外观应用即可。</p> 
    <p>我们主要是讲述了以下的几种情况，使用外观模式可能更适合：</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、我们在使用第三方类库或者API的时候，我们通过本地的API接口的封装，来完成对第三方API接口的粗粒度外观对象，通过这个外观对象可以</p> 
    <p>很容易的完成服务的调用。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2、我们在架构设计的过程中，一次的功能访问可能需要同时的调用很多个对象，那么如果我们在服务调用的时候，能够在应用程序调用中一次就</p> 
    <p>能完成所有要同时调用的对象那该多好啊，外观模式无疑是最好的原则，特别是在分布式应用中，通过远程调用服务，通过外观模式降低应用程序与服务的</p> 
    <p>交互次数，同时可以降低应用程序的复杂性。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">二、摘要</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本文将会讲述结构性模式中的另外一个常用的模式-组合模式，我们平时在面向对象的设计中，我想有一个原则经常被提及就是，我们在设计的时候，</p> 
    <p>对象组合&gt;类的继承，本篇将会将结合简单的实例来说明这方面的优势，并且完成对组合模式的主题思想的掌握。我们这样来简单的理解组合模式，组合模</p> 
    <p>式就是把一些现有的对象或者元素，经过组合后组成新的对象，新的对象提供内部方法，可以让我们很方便的完成这些元素或者内部对象的访问和操作。我</p> 
    <p>们也可以把组合对象理解成一个容器，容器提供各种访问其内部对象或者元素的API，我们只需要使用这些方法就可以操作它了。那么对象组合相比继承的</p> 
    <p>优势有哪些呢？可能具体的优势，也不是一句二句就能表述清楚的，还是我们来看看图形的可视化的描述吧。</p> 
   </blockquote> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p><a style="color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);"><img title="clip_image002" src="https://images.cnblogs.com/cnblogs_com/hegezhou_hot/WindowsLiveWriter/fc3e169511ff_11DE6/clip_image002_1822e783-4e1e-49b0-ab05-1d26e092aeb0.gif" alt="clip_image002" width="647" height="511" style="border:0px;"></a>我们这里设计的是持久化服务写到一个基类中，</p> 
    <p>然后继承自该基类的子类都会拥有内置的持久化方法，可能后续我们又要添加其他的针对某个具体的对象类，有一些个性化的服务，我们通过扩展这个类，</p> 
    <p>进行继承，这样多重继承后，会有一个很大的问题。子类膨胀的问题，而且一般来说继承的重数达到5层左右的时候，性能上可能就会有一定的瓶颈，。也</p> 
    <p>不是好的设计的思路。这时候对象组合可能为我们提供了更好的解决方案。基于组合方式的话，可能我们可以这样来做，换个思路：就像我们的一个负责的</p> 
    <p>对象，可以通过简单的对象来组成的道理差不多，其实。</p> 
   </blockquote> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p><a style="color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);"><img title="clip_image004" src="https://images.cnblogs.com/cnblogs_com/hegezhou_hot/WindowsLiveWriter/fc3e169511ff_11DE6/clip_image004_c5c06f69-78b0-4c5f-972e-407bca801b06.gif" alt="clip_image004" width="712" height="343" style="border:0px;"></a>通过上图，我们知道了，组合对象可以</p> 
    <p>看作是一系列简单的对象组合成负责的对象的一个模式，复杂对象可以看作是简单对象的一个容器。这个复杂对象完成了简单对象的封装，通过这个容器完</p> 
    <p>成对象内部简单对象的访问。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">三、本文大纲</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a、上篇回顾。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b、摘要。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c、本文大纲。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d、组合模式的特点及使用场景。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e、组合模式的经典实现。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f、组合模式的其他方案。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g、原型模式使用总结。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h、系列进度。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i、下篇预告。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">四、组合模式的特点及使用场景</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp; 组合模式是将一系列对象组合成树形结构用来表示整体和部分之间的关系，组合模式的主要目的是达到，访问组合对象和访问单个对象具有一致性。这里的组合对象比较特殊，本身他可以是由其他的对象组合而成，同时，这个组合对象又可以是组成更复杂对象的一个部分。我们来举个例子来说明吧，可能更直观。</p> 
    <p><a style="color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);"><img title="clip_image006" src="https://images.cnblogs.com/cnblogs_com/hegezhou_hot/WindowsLiveWriter/fc3e169511ff_11DE6/clip_image006_faa30409-35da-445d-a952-82c521ede2ba.gif" alt="clip_image006" width="612" height="569" style="border:0px;"></a>这里我们可以理解为一个简单的查询组件可能有要满足</p> 
    <p>上述的几类查询条件的输入类型，将这个组件作为一个容器，那么同事，这个容器又可以作为另外一个容器的组件来运行，那么我们又可以在分页控件中，</p> 
    <p>将这个查询组件包含到其中。以为分页提供相应的查询元素的集成。</p> 
   </blockquote> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>我们一般在如下场景中使用组合模式比较方便：</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1、我们有的时候想用户使用一个复杂对象像使用简单对象一样的方式去访问，并且用户同意使用对象内部的所有的对象时，我们可以考虑使用该模</p> 
    <p>式。这个怎么理解呢？我们使用复杂对象像使用简单对象一样的方式去访问的话，那么我们可以使用组合对象，我们把这些简单的对象进行组合，用组合对</p> 
    <p>象进行包装，并且提供相应的操作组合对象内部的方法。结合上图中的例子，我们可以这样理解，我们把查询组件封装成一个用户控件，然后可以在其他的</p> 
    <p>页面中进行调用。这个时候，我们可能考虑如何分部页面，如何能够动态的维护界面上的控件，是否显示，控件里面显示的文本和值是什么？等等，这些都</p> 
    <p>是我们可以考虑的元素，那么我们如何来做呢？提供下面的几个方法。我还是给出图来说话吧：</p> 
    <p><a style="color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);"><img title="clip_image008" src="https://images.cnblogs.com/cnblogs_com/hegezhou_hot/WindowsLiveWriter/fc3e169511ff_11DE6/clip_image008_ab85da54-84e8-4ff9-add3-b74cc14d2e75.gif" alt="clip_image008" width="542" height="327" style="border:0px;"></a>包含上面的这些元素，那么我们可以通过一些相应的方法来进行访</p> 
    <p>问内部的元素。我们给出简单的示例代码：</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public QueryControl()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeComponent();</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.InitControlList();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public event EventHandler handler;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private Dictionary&lt;string,Control&gt; _controlList = null;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 初始化控件信息&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void InitControlList()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList = new Dictionary&lt;string,Control&gt;();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 返回界面控件中所有的查询条件控件列表&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Dictionary&lt;string,Control&gt; GetControls()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this._controlList;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 添加查询控件到界面中&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="control"&gt;&lt;/param&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool AddControl(string key,Control control)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(this._controlList.ContainsKey(key))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList.Add(key,control);</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 移除指定键值的对象&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="key"&gt;&lt;/param&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool RemoveControl(string key)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this._controlList.ContainsKey(key))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList.Remove(key);</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void OnQuery()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this.handler != null)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler(this, new EventArgs());&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Query(object sender, EventArgs e)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.CreateSQL();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.OnQuery();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 根据选中的条件生成SQL语句&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void CreateSQL()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new NotImplementedException();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;</p> 
    <p>上面的代码很简单就是给出了基本的思路，并不是完整的功能。我们来看其他的可能会用到组合模式的情况</p> 
    <p>2、如果有的时候，我们希望用户不了解自己使用的对象有多复杂，并且组合对象可以的内部可以自由的变化和组合，但是不会影响到客户应用程序使用这</p> 
    <p>个组合对象，如果项目中需要新增一个组合对象的时候，客户调用的程序还是一样，不会因为这个组合对象发生变更而发生变化。组合模式在解决整体和部</p> 
    <p>分之间的问题应用很广泛，也可以降低系统的复杂度，因为我们可以把复杂的组件看作另一个组件的组成部分来处理。就像上面的查询组件，那么我们可以</p> 
    <p>把查询组件作为分页组件的一个部分来处理。我这里就不给出示例代码了通过上面的情况，我们可以大概的知道，组合模式的使用场景。下面我们就要结合</p> 
    <p>实例说明组合模式的用处了。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">五、组合模式的经典实现</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们先来看看使用经典的组合模式来实现我们上面说的查询控件吧，看看和其他的方案有什么样的不同，不过大体的思路都是一致的，把其他的对象</p> 
    <p>进行组合成复杂的对象，然后提供操作内部对象的方法，具体的方式可以很多。我们这里还是以上面的查询组件和分页组件为例来说明具体的实现思路，当</p> 
    <p>然我这里只是给出核心代码，但不是完整的代码：</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们先给出控件内部的完整定义：</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public QueryPanel()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeComponent();</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.InitControlList();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public event EventHandler handler;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private Dictionary&lt;string,Control&gt; _controlList = null;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 初始化控件信息&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void InitControlList()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList = new Dictionary&lt;string,Control&gt;();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 返回界面控件中所有的查询条件控件列表&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Dictionary&lt;string,Control&gt; GetControls()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this._controlList;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 添加查询控件到界面中&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="control"&gt;&lt;/param&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool AddControl(string key,Control control)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(this._controlList.ContainsKey(key))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList.Add(key,control);</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 移除指定键值的对象&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="key"&gt;&lt;/param&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool RemoveControl(string key)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this._controlList.ContainsKey(key))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList.Remove(key);</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void OnQuery()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this.handler != null)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler(this, new EventArgs());&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Query(object sender, EventArgs e)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.CreateSQL();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.OnQuery();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 根据选中的条件生成SQL语句&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void CreateSQL()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new NotImplementedException();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual Control this[string key]&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this._controlList[key];&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._controlList[key] = value;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual IEnumerable&lt;Control&gt; GetControlList()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this._controlList.Count &gt; 0)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (Control control in this._controlList.Values)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (Control item in control.Controls)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield return control;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp; 这时候我们如果想要重写上面的方案，可能有时候我们的查询控件需要基于上面的几个基本的操作方法进行重写，完成自定义的组合对象的操作：</p> 
    <p>&nbsp;&nbsp;&nbsp; public partial class QueryPanelText : QueryPanel&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public QueryPanelText()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeComponent();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override Control this[string key]&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return base.GetControls()[key];&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.GetControls()[key] = value;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 获取集合中的所有控件集合&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override IEnumerable&lt;Control&gt; GetControlList()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return base.GetControlList();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当然我上面并没有改变对象的任何行为，这里定义了公共的行为，有的时候我们需要限制一些对象内部对象的某些行为，这时候我们通过继承公共的</p> 
    <p>对象来重写对象的行为来完成。例如从组合对象衍生出来的某些组合对象，可能不具有父类的某些行为时，我们可以通过重写父类的行为来完成自定义的操</p> 
    <p>作。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">六、组合模式的其他方案</h3> 
   <h4 style="color:rgb(51,51,51);font-size:14px;font-family:Helvetica, Verdana, Arial, sans-serif;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.1、通过过滤器来改进上述方案。</h4> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp; 有的时候，我们可能并不关心对象中的所有的元素，我们只是操作其中的具有同类特征的对象，比如对于上面的查询控件中的对象，我们可能想要获</p> 
    <p>取设置条件的控件项，或者说我们相应控制文本框或者下拉框的样式或者高度等等，这个时候，我们需要对组合对象内的元素就行筛选。这个时候，我们可</p> 
    <p>能可以采用过滤器来实现这样的功能。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于上面的结果，我们可能需要获取界面中所有的文本框，或者下拉框，或者其他类型的控件等，这时候我们可以如下方式来做，通过接口定义，根</p> 
    <p>据传入的不同的过滤器，返回过滤后的结果集合。我们先定义一个过滤器接口：</p> 
    <p>&nbsp;&nbsp;&nbsp; public interface ISelectRule&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool IsMatch(Control control);&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; 我们这里定义一个文本过滤器的实现。</p> 
    <p>&nbsp;&nbsp;&nbsp; public class TextSelect : ISelectRule&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region ISelectRule 成员</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public bool IsMatch(System.Windows.Forms.Control control)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (control is System.Windows.Forms.TextBox)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; 我们来看看具体的查询控件内部的获取内部元素的方法：</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// 获取集合中的所有控件集合&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; IEnumerable&lt;Control&gt; GetControlList(ISelectRule rule)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (Control control in base.GetControls().Values)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rule.IsMatch(control))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield return control;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp; 通过上面的几行代码的改进，我们就可以完成对内部的组合对象的改进，这样就可以完成根据不同的查询规则，来返回不同的内部对象集合。</p> 
    <p>通过上面的迭代器来封装我们的内部组合对象，我们通过迭代器来完成组合对象的过滤。我们还可以通过XML文件来组织我们的对象组合的结构，XML文</p> 
    <p>件先天性的优势就是结构化的语言，特别适合这样的整体与局部关系的结构，所以我们的组合对象也可以通过XML文件来组织，可以将复杂对象设置为一</p> 
    <p>个复杂的节点，该节点下包含多个对象时，我们只需要将每个对象设置为一个节点，通过XPath语言完成查询。</p> 
    <p>6.2XML文件格式的组合模式</p> 
    <p>使用XML文件来完成组合模式有如下优点：</p> 
    <p>1、我们有系统提供的类库自动完成对XML文件的操作和访问。</p> 
    <p>2、XML提供了基于XPath解析的查询语言。</p> 
    <p>也有一些点，就是操作XML文件，调试起来会比较麻烦，而且进行代码编写和测试是个不太方便的事情。</p> 
    <p>我们来看看如果我们把上面的获取迭代器的代码，还原成XML文件的格式该如何书写呢？</p> 
    <p>&lt;?xml version="1.0" encoding="utf-8" ?&gt;&nbsp;<br> &lt;Composite&gt;&nbsp;<br> &nbsp; &lt;QueryPanel&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;DropDownList name="" type=""/&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;DropDownList name="" type=""/&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;DropDownList name="" type=""/&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;TextBox name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;TextBox name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;TextBox name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;ComboBox name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;ComboBox name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;ComboBox name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;Button name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;Button name="" value="" /&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp; &lt;Button name="" value="" /&gt;&nbsp;<br> &nbsp; &lt;/QueryPanel&gt;&nbsp;<br> &lt;/Composite&gt;</p> 
    <p>&nbsp;</p> 
    <p>对于上面的XML文件，那么我们如何获取到这个XML文件中的某些类型的节点呢？比如我如何获取到TextBox呢？这时候我们可以使用Xpath语法来进行</p> 
    <p>选择：</p> 
    <p>&nbsp;&nbsp; public class XMLSelect&nbsp;<br> &nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string xPath = "/Composite/QueryPanel/TextBox";&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private XmlNodeList list = null;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public XmlNodeList GetNodes()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Xml.XmlDocument doc = new XmlDocument();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doc.LoadXml("Composite.xml");</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list = doc.SelectNodes(xPath);</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return list;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public List&lt;Control&gt; GetControls()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;Control&gt; listControls = new List&lt;Control&gt;();</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (XmlNode node in list)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Windows.Forms.TextBox textBox = new TextBox();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; textBox.Name = node.Attributes["name"].Value.ToString();</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listControls.Add(textBox);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return listControls;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp; }</p> 
    <p>基于上面的形式我们也可以完成组合模式的要求，通过上面的讲解，我们应该对组合模式有了一定的了解。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">七、组合模式使用总结</h3> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;background:rgb(255,255,255) none;"> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过上面的简单讲解，我们知道了，组合模式意图是通过整体与局部之间的关系，通过树形结构的形式进行组织复杂对象，屏蔽对象内部的细节，对</p> 
    <p>外展现统一的方式来操作对象，是我们处理更复杂对象的一个手段和方式。本文以查询控件为例，说明了，查询控件内部的组成元素，及如何操作内部的组</p> 
    <p>成元素，包括添加元素，删除和处理相应事件的Handler，当然组合模式的作用远比这些强大，后面我们肯定会在一些实例代码中运用到组合模式的。组合</p> 
    <p>模式如果在条件允许的情况下，我们尽量使用组合模式来处理复杂对象，远比通过继承出来的对象来的有效。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于本人水平有限，加之理解有误，错误之处还请大家批评指出，多谢大伙的支持和关注！</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:Helvetica, Verdana, Arial, sans-serif;">八、系列进度</h3> 
   <p style="font-family:Helvetica, Verdana, Arial, sans-serif;font-size:14px;line-height:21px;">创建型</p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp;1、系统架构技能之设计模式-单件模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 2、系统架构技能之设计模式-工厂模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 3、系统架构技能之设计模式-抽象工厂模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 4、系统架构技能之设计模式-创建者模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 5、系统架构技能之设计模式-原型模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">结构型</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 1、系统架构技能之设计模式-组合模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 2、系统架构技能之设计模式-外观模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 3、系统架构技能之设计模式-适配器模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 4、系统架构技能之设计模式-桥模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 5、系统架构技能之设计模式-装饰模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 6、系统架构技能之设计模式-享元模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 7、系统架构技能之设计模式-代理模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">行为型</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 1、系统架构技能之设计模式-命令模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 2、系统架构技能之设计模式-观察者模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 3、系统架构技能之设计模式-策略模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 4、系统架构技能之设计模式-职责模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 5、系统架构技能之设计模式-模板模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 6、系统架构技能之设计模式-中介者模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 7、系统架构技能之设计模式-解释器模式</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp;</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">九、下篇预告</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">&nbsp; &nbsp; &nbsp; &nbsp; 下篇，我们将会讲述结构性模式中的适配器模式，我想大家对适配器模式应该有不少的了解，因为如果我们经常在项目中使用第三方的或者因为旧的系统与新系</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">统的接口类型不一致，倒置无法进行调用，这时候我们可以通过适配器模式将旧的接口，转化成可以让我们的新系统调用的接口形式，完成调用，很神奇吧！下篇我们</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">将会进行详细的阐述。</span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;"><br></span></font></p> 
   <p><font><span style="font-size:14px;line-height:21px;">本文转自何戈洲博客园博客，原文链接：http://www.cnblogs.com/hegezhou_hot/archive/2010/12/06/1898161.html，如需转载请自行联系原作者</span><br></font></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
