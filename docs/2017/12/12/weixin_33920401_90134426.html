<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Net中的AOP系列之《方法执行前后——边界切面》 « NotBeCN</title>
  <meta name="description" content="             本篇目录              边界切面     PostSharp方法边界     方法边界 VS 方法拦截     ASP.NET HttpModule边界     真实案例——检查是否为移动端用户     真实案例——缓存     小结          本系列的源码本人已托管...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/12/weixin_33920401_90134426.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Net中的AOP系列之《方法执行前后——边界切面》</h1>
    <p class="post-meta">Dec 12, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);">本篇目录</h2> 
   <ul>
    <li style="list-style:disc;"> </li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>边界切面</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>PostSharp方法边界</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>方法边界 VS 方法拦截</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>ASP.NET HttpModule边界</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>真实案例——检查是否为移动端用户</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>真实案例——缓存</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>小结</b></span></font></li> 
   </ul>
   <hr style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">本系列的源码本人已托管于Coding上：<strong><a href="https://coding.net/u/farb/p/AbpPractice/git/tree/master/AOPPractice/BoundaryAspectsPractices" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">点击查看</a></strong>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">本系列的实验环境：VS 2013 Update 5（建议最好使用集成了Nuget的VS版本，VS Express版也够用），安装PostSharp。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇博客覆盖的内容包括：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">什么是方法边界</li> 
    <li style="list-style:disc;">使用PostSharp的边界方法</li> 
    <li style="list-style:disc;">编写ASP.NET HttpModule来检测用户是否是移动端用户</li> 
    <li style="list-style:disc;">方法拦截和方法边界的不同之处</li> 
    <li style="list-style:disc;">使用PostSharp编写缓存切面</li> 
   </ul>
   <hr style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上一篇我们讲了方法切面中最通用的类型<strong><a href="http://www.cnblogs.com/farb/p/MethodInterception.html" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">《方法拦截》</a></strong>，这篇我们讲一下可能用到的另外一种切面：<strong>边界切面</strong>，它里面的代码会在方法的边界运行。首先会使用PostSharp在方法层面上演示一个边界切面，然后也会使用ASP.NET HttpModule演示一个页面层面的边界切面。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇博客的目的是通过多个例子演示来说明什么事边界切面以及边界切面一般是如何工作的，而不是带领大家详细地编写这些例子。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="boundary"></a>边界切面</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">通常意义上的边界指的是两个实体间的任意分割线，比如两个国家之间的地理上的分界线，我国各个省份之间的分界线，当你去临省旅游时，你必须首先穿过你所在省和邻省的分界线，旅行结束返回时，必须再次穿过省份分界线。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">和现实生活一样，编码时也会有很多分界线。就拿最简单的控制台程序来说，当启动一个Main方法时，然后Main方法又调用了另一个方法，当程序进入被调用方法体时也要穿过一个分界线，当被调方法执行完成之后，程序流就会返回到Main方法，这就是我们平时没怎么意识到的边界。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用了AOP，我们就可以把代码放到那些边界上，这些边界代表了一个地方或一个条件，对于放置一些可复用的代码很有用。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="post" style="color:rgb(224,130,131);"></a>PostSharp方法边界</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">创建一个控制台项目，名为“BasketballStatsPostSharp”，解决方案名称为"BoundaryAspectsPractices"，通过Nuget安装PostSharp。这个项目的需求很简单，创建一个服务类，然后根据球员的名字获得该球员的球衣号码，这里为了演示，直接将结果打印到控制台。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">BasketballStatsService</span>
{
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 根据球员的名字返回球员的球衣号码</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="playerName"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetPlayerNumber</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> playerName</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (playerName.Equals(<span class="hljs-string" style="color:rgb(163,21,21);">"Michael Jordan"</span>))
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-number">23.</span>ToString();
        }
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (playerName.Equals(<span class="hljs-string" style="color:rgb(163,21,21);">"Kobe Bryant"</span>))
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-number">24.</span>ToString();
        }
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-number">0.</span>ToString();
    }
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{<span class="hljs-comment" style="color:#008000;">//这个花括号是程序没有执行和开始执行的分界线</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> service=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> BasketballStatsService();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> playName = <span class="hljs-string" style="color:rgb(163,21,21);">"Michael Jordan"</span>;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> no1 = service.GetPlayerNumber(playName);<span class="hljs-comment" style="color:#008000;">//这里是Main方法和GetPlayerNumber方法的分界线</span>
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}的球衣号码是{1}"</span>,playName,no1);
        Console.Read();
    }<span class="hljs-comment" style="color:#008000;">//这个花括号是程序结束前和程序结束后的分界线</span>
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这只是个普通的程序，没什么可言之处，大家很容易看出运行结果，这里就不演示了。<br> 下面我们创建一个边界切面<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MyBoundaryAspect</code>，它继承自PostSharp中的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>，注意使用PostSharp时记得使用Serializable特性。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行前"</span>,args.Method.Name);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行后"</span>, args.Method.Name);
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用的话，很简单，只需要在服务类的方法上加上特性即可，然后运行如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/57da9178-fae4-4116-9f81-c80556c391a6.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个例子和第一篇介绍中的"Hello World"例子差不多，没什么好玩的，别着急，在本文后面会有一个使用边界方法处理缓存的例子。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="vs" style="color:rgb(224,130,131);"></a>方法边界 VS 方法拦截</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">目前，方法边界切面和方法拦截切面我们都看过了，那么接下来对比一下这两者有什么区别。区别肯定是存在的，但这些区别是很微妙的，专一的开发者可能只使用其中一种切面。这节从下面两个方面讨论一下这些区别：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">切面方法间的共享状态</li> 
    <li style="list-style:decimal;">代码清晰度/意图</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下图是PostSharp中<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodInterceptionAspect</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundary</code>切面的基本结构对比：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/7c387d35-773f-4f74-93a8-41a3546539aa.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">概念上讲，可以将一个边界切面转成拦截切面，反之亦然，只需要将左边的代码改为右边格式的代码就好了，但是，如果真那么简单，那么这两者之间的区别是什么呢？很明显，答案肯定不是想象的那么简单。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">切面方法间的共享状态</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">首先看一下共享状态。拦截切面只有一个方法<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnInvoke</code>，因此共享状态不是关心的问题——在方法开始时可以使用的任何变量可以继续在方法的其他地方使用。但是对于边界方法来说就不那么简单了，在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnEntry</code>方法中声明的变量在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSuccess</code>方法中是不可用的，因为它们是分离的方法。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">但使用PostSharp，对于边界方法的共享状态可以变通一下。首先，可以使用类本身的字段：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> [Serializable]
 <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> _sharedState;<span class="hljs-comment" style="color:#008000;">//使用一个全局变量共享方法之间的信息</span>
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
         _sharedState = <span class="hljs-string" style="color:rgb(163,21,21);">"123"</span>;<span class="hljs-comment" style="color:#008000;">//边界方法运行之前，设置一个值</span>
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行前"</span>,args.Method.Name);
     }

     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行后,_sharedState={1}"</span>, args.Method.Name,_sharedState);<span class="hljs-comment" style="color:#008000;">//边界方法运行之后该值不变</span>
     }
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">然而，这种方法有个缺点。在PostSharp中，切面类中的每个边界方法都使用切面类的相同实例。这种切面叫做<em>静态范围切面</em>，这意味着，即使你创建了多个类的实例，PostSharp的切面标记的方法只会创建一个切面实例与那个类对应。如果切面实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IInstanceScopedAspect</code>接口，那么这个切面就是一个<em>实例范围切面</em>。默认行为会在编织之后，在代码中添加少量负担，但是引入的那点复杂度可能不是很明显。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">要演示这个问题，修改一下切面类和Main方法，服务类方法不变，代码修改如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> [Serializable]
 <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> Guid _sharedState;<span class="hljs-comment" style="color:#008000;">//使用一个全局变量共享方法之间的信息</span>

     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>(<span class="hljs-params"></span>) </span>{
         _sharedState = Guid.NewGuid();
     }
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
         <span class="hljs-comment" style="color:#008000;">//_sharedState = "123";//边界方法运行之前，设置一个值</span>
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行前"</span>,args.Method.Name);
     }

     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
         Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行后,_sharedState={1}"</span>, args.Method.Name,_sharedState);<span class="hljs-comment" style="color:#008000;">//边界方法运行之后该值不变</span>
     }
 }


 <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 拦截切面VS边界切面</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> s1=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> BasketballStatsService();
 <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> s2=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> BasketballStatsService();
 s1.GetPlayerNumber(<span class="hljs-string" style="color:rgb(163,21,21);">"Kobe Bryant"</span>);
 s2.GetPlayerNumber(<span class="hljs-string" style="color:rgb(163,21,21);">"Kobe Bryant"</span>);

 <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>
 Console.Read();

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行效果如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/832acacb-23a1-40b3-9d58-81b96c91f5ba.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从结果可以看到，产生的GUID的值是一样的，也就是说，切面实例（每次实例化时都会产生）只产生了一个，也就是说多个服务类的方法共享了相同的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MyBoundaryAspect</code>切面对象。如果又调用了服务类的另外一个方法，那么生成的GUID的值就不同了。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>GUID<br> GUID是Globally Unique Identifier（全局唯一标识符）的简写。GUID是用于唯一标识的128bit的值，通常表现为16进制的8-4-4-4-12形式。<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Guid.NewGuid()</code>会生产一个唯一的Guid（不是从数学角度，而是从实际和统计角度），因此很适合演示产生的实例是不是同一个实例。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">总之，切面的全局字段不是切面方法间沟通的安全方式，因为它不是线程安全的。其他方法可以对这些全局字段更改，因此，PostSharp提供了一个叫做<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.MethodExecutionTag</code>的API来协助共享状态。它是会传入每个边界方法的args对象的属性，该对象对于方法调用时的每次特定时间都是唯一的。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，将<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Guid.NewGuid()</code>移到构造函数的外面的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnEntry</code>方法中，然后在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSuccess</code>方法中使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.MethodExecutionTag</code>方式输出。代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> Guid _sharedState;<span class="hljs-comment" style="color:#008000;">//使用一个全局变量共享方法之间的信息</span>

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>(<span class="hljs-params"></span>) </span>{
       <span class="hljs-comment" style="color:#008000;">// _sharedState = Guid.NewGuid();</span>
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//_sharedState = "123";//边界方法运行之前，设置一个值</span>
        args.MethodExecutionTag = Guid.NewGuid();
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行前，该方法生成的Guid={1}"</span>,args.Method.Name,args.MethodExecutionTag);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//Console.WriteLine("方法{0}执行后,_sharedState={1}", args.Method.Name,_sharedState);//边界方法运行之后该值不变</span>
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行后，该方法生成的Guid={1}"</span>, args.Method.Name, args.MethodExecutionTag);
    }
}


</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行结果如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/832acacb-23a1-40b3-9d58-81b96c91f5ba.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从上面的运行结果看以看出，同一个边界切面中的不同边界方法共享了相同的数据GUID，但是不同的服务类实例调用使用了同一个切面的方法，GUID是不同的。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionTag</code>是一个对象类型，适合存储一些像GUID等简单的类型，如果需要存储更复杂的共享数据，必须在使用时强制转换<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionTag</code>的类型。如果要存储一个包含了多个对象的共享数据，必须创建一个自定义类存储到<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionTag</code>属性中。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">记住，方法拦截切面中不存在这些问题，因为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnInvoke</code>方法是方法拦截切面中唯一的方法，可以在该方法中使用所有的共享数据。上一篇例子中的数据事务就是一个使用了很多共享数据的例子，比如重试次数的数量，事务是否成功执行的标识<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">succeeded</code>都是共享数据。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">那么如何选择何时使用拦截切面还是边界切面呢？方法是：如果你要编写的切面使用了复杂的共享数据，或者使用了很多共享数据，那么最好使用方法拦截切面。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">代码清晰度/意图</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">方法拦截切面在数据共享方法有明显的优势，但没有共享数据或者共享数据很少呢？或者需要在某个单独的边界执行一些代码呢？这些场合，方法边界切面更胜一筹。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面写一个切面，该切面运行在方法完成时的边界（无论方法是否成功）。在PostSharp中需要编写这个边界切面，<br> 需要重写<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnExit</code>方法，它不同于<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSuccess</code>方法，后者只有当方法没有抛出异常执行完毕时才会执行，而前者当方法执行完成时都会运行，不管有没有抛异常都会执行。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-comment" style="color:#008000;">//边界切面的写法</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnExit</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
    Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行完成！"</span>,args.Method.Name);
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果要在拦截切面中写的话，就需要这么写：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyIntercepor</span> : <span class="hljs-title" style="color:rgb(163,21,21);">MethodInterceptionAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnInvoke</span>(<span class="hljs-params">MethodInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">try</span>
        {
            args.Proceed();<span class="hljs-comment" style="color:#008000;">//在边界切面中，这行代码是隐式执行的</span>
        }
        <span class="hljs-keyword" style="color:rgb(0,0,255);">finally</span> <span class="hljs-comment" style="color:#008000;">//C#中的finally指的是，无论try中发生了什么，代码块都会执行</span>
        {
            Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"方法{0}执行完成！"</span>, args.Method.Name);
        }
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面这个例子很简单，但是现实中的项目不可能这么简单，可能try和finally代码块中的代码都很多，那么此时使用拦截切面维护就显得更加费力，因为第一眼看得代码更多，而且代码一多，可能发生的问题更多。而边界切面隐藏了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">try/catch/finally</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Proceed()</code>的细节，我们不需要读写那些代码。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">最后要说的是，虽然你可能偏爱方法拦截，但不要忽略了边界切面，因为它可以改善代码的清晰度和简洁度。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">性能和内存考虑</h4> 
    <p>方法边界切面和方法拦截切面其他的重要区别是性能和内存方面，这些方法的考虑取决于使用的工具的不同而不同。<br> 在PostSharp中，当使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodInterceptionAspect</code>时，所有的参数每次都会从栈中复制到堆中（通过装箱boxing），当使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>时，PostSharp会检测没有使用的参数，不会把这些参数装箱，从而优化了代码。因此，如果编写的切面没有使用方法参数，那么使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>会使用更少的内存，如果在多个地方都使用这个切面，那么这样的做法可能是重要的（注意：该优化功能没有包含在PostSharp的免费版中）。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">方法边界不是使用AOP时唯一有用的边界类型，下面我们会看一个ASP.NET&nbsp;<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpModule</code>的例子，这个例子对于把边界放到web页面上非常有用。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="httpModule" style="color:rgb(224,130,131);"></a>ASP.NET HttpModule边界</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这里为了方便演示，创建一个Asp.Net Web Form项目<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">WebFormHttpModule</code>,新建一个页面<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Demo.aspx</code>，代码如下：</p> 
   <pre class="aspx"><code class="hljs django" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="xml"><span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">%@</span> <span class="hljs-attr" style="color:#FF0000;">Page</span> <span class="hljs-attr" style="color:#FF0000;">Language</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"C#"</span> <span class="hljs-attr" style="color:#FF0000;">AutoEventWireup</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"true"</span> <span class="hljs-attr" style="color:#FF0000;">CodeBehind</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"Demo.aspx.cs"</span> <span class="hljs-attr" style="color:#FF0000;">Inherits</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"WebFormHttpModule.Demo"</span> %&gt;</span> <span class="hljs-meta" style="color:rgb(43,145,175);">&lt;!DOCTYPE html&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">html</span> <span class="hljs-attr" style="color:#FF0000;">xmlns</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"http://www.w3.org/1999/xhtml"</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">head</span> <span class="hljs-attr" style="color:#FF0000;">runat</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"server"</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">form</span> <span class="hljs-attr" style="color:#FF0000;">id</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"form1"</span> <span class="hljs-attr" style="color:#FF0000;">runat</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"server"</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个Demo页面！<span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">form</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">html</span>&gt;</span> </span></code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在浏览器中浏览该文件时，页面上会显示<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">这是一个Demo页面！</code>这句话。对每个ASP.NET 页面的请求都会有一个很复杂的生命周期，但值得注意的是该生命周期中的一部分使用了HttpModule，它允许我们将代码放到ASP.NET页面的边界。要创建一个HttpModule,需要创建一个实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IHttpModule</code>接口的类：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyHttpModule</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IHttpModule</span>
{
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 释放所有的资源和数据库连接</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Dispose</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> NotImplementedException();
    }

    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 当HttpApplication的实例创建时运行</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="context"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Init</span>(<span class="hljs-params">HttpApplication context</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> NotImplementedException();
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">每个模块都必须在ASP.NET的Web.config文件中配置后才可以运行。Web.config的配置可能会根据你使用的web服务器（ IIS6 , IIS7 +, Cassini, IIS Express等等）不同而不同。要想覆盖以上服务器的所有配置，可以像下面那样配置：</p> 
   <pre class="webconfig"><code class="hljs django" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="xml"><span class="hljs-comment" style="color:#008000;">&lt;!--II6和ASP.NET开发服务器会在这里寻找--&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">system.web</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">compilation</span> <span class="hljs-attr" style="color:#FF0000;">debug</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"true"</span> <span class="hljs-attr" style="color:#FF0000;">targetFramework</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"4.5"</span> /&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">httpModules</span>&gt;</span> <span class="hljs-comment" style="color:#008000;">&lt;!--每个模块需要唯一的名字和类型（全命名空间+类名）--&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">add</span> <span class="hljs-attr" style="color:#FF0000;">name</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"MyHttpModule"</span> <span class="hljs-attr" style="color:#FF0000;">type</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"WebFormHttpModule.MyHttpModule"</span>/&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">httpModules</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">system.web</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">system.webServer</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">validation</span> <span class="hljs-attr" style="color:#FF0000;">validateIntegratedModeConfiguration</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"false"</span>/&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">modules</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">add</span> <span class="hljs-attr" style="color:#FF0000;">name</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"MyHttpModule"</span> <span class="hljs-attr" style="color:#FF0000;">type</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"WebFormHttpModule.MyHttpModule"</span>/&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">modules</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">system.webServer</span>&gt;</span> </span></code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">ASP.NET使用了多个工作进程处理即将到来的请求，每个工作进程都会创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpApplication</code>的实例，每个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpApplication</code>实例都会创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpModule</code>，然后运行<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Init</code>方法，现在自定义的Init方法什么都还没写，下面会使用事件句柄设置一些边界：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyHttpModule</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IHttpModule</span>
{
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 释放所有的资源和数据库连接</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Dispose</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> NotImplementedException();
    }

    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 当HttpApplication的实例创建时运行</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="context"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Init</span>(<span class="hljs-params">HttpApplication context</span>) </span>{
        context.BeginRequest += context_BeginRequest;
        context.EndRequest += context_EndRequest;
    }

    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 在所有的其他页面生命周期事件结束之后运行</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="sender"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="e"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">context_EndRequest</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> app = sender <span class="hljs-keyword" style="color:rgb(0,0,255);">as</span> HttpApplication;
        app.Response.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"页面所有的生命周期事件结束之后"</span>);
    }
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 页面处理请求之前运行</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="sender"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="e"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">context_BeginRequest</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> app = sender <span class="hljs-keyword" style="color:rgb(0,0,255);">as</span> HttpApplication;
        app.Response.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"页面请求处理之前"</span>);
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然语法很不同，但是这种感觉很像之前的方法边界切面。浏览一下页面，效果如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/efe950d9-a509-40c7-ad00-3dc45c7e37b6.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">因为在这些边界方法中有一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpApplication</code>对象，因此可以有很大的灵活性和潜能完成很多事情。当检查<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpApplication</code>的属性和事件时，可以看到做许多事情而不仅是输出文本。下一节我们会使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpModule</code>演示一个真实的案例：检测用户是否是移动端用户。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="mobile"></a>真实案例——检查是否为移动端用户</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面再创建一个ASP.NET WebForm 项目演示一个检测用户端是否是移动端的例子。比如，你通过搜索引擎搜索到一个网页，然后打开网页，当然，进入的可能不是首页，也可能是首页。如果当用户进入时，该网站能根据用户的客户端类型，为用户提供更好的服务，那么该用户可能就会发展成为该产品的最终用户。那么问题来了，怎么根据用户的客户端类型为他提供更好的服务呢？请看以下流程图：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160811000251543-1757923348.png" style="border:0px;" alt="577014-20160811000251543-1757923348.png"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">项目目录见下图（源码大家可以通过上面的链接拿到）：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160810235755184-1179802415.png" style="border:0px;" alt="577014-20160810235755184-1179802415.png"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">详细代码就不在这里浪费地方贴出来了，感兴趣的可以去下载源码学习，这里只贴一部分比较核心的代码。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">创建HttpModule</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">首先要创建自己的HttpModule，然后实现IHttpModule接口，默认要实现<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Init</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Dispose</code>方法：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
  <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">DetectMobileModule</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IHttpModule</span>
    {
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Dispose</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> NotImplementedException();
        }

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Init</span>(<span class="hljs-params">HttpApplication context</span>) </span>{
            context.BeginRequest += context_BeginRequest;
        }
   }
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在这个例子中，我们不需要在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Dispose</code>方法中写任何代码，因为我们这个例子没有使用任何要求释放的资源（如FileStream或者SqlConnection等GC没有处理的资源）。ASP.NET HttpModule在每个Http请求都会运行，传入到<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Init</code>方法的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpApplication</code>上下文参数给具体的边界调用提供了一些事件。这个例子中，我们只对<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">BeginRequest</code>边界事件感兴趣，它的代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">context_BeginRequest</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{

}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">context_BeginRequest</code>中的代码会在页面执行之前运行，因此，这也就是我们可以检测用户是否是移动端的地方。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">检测移动端用户</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MobileDetect</code>类，假设APP可用的有3大平台：Android，IOS和Windows 10 Mobile。这里检测用户客户端类型的方式很简单，看<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">UserAgent</code>是否包含确定的关键字即可。代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MobileDetect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> HttpRequest _request;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">MobileDetect</span>(<span class="hljs-params">HttpContext context</span>) </span>{
        _request = context.Request;
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">IsMobile</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _request.Browser.IsMobileDevice&amp;&amp;(IsWindowsMobile()||IsAndroid()||IsApple());
    }
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 检测是否是Windows Mobile手机，本人在调试时发现，Windows 10 Mobile系统的UserAgent同时包含了下面的两个关键字</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">IsWindowsMobile</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _request.UserAgent.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"Windows Phone"</span>) &amp;&amp; _request.UserAgent.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"Android"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">IsApple</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _request.UserAgent.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"iPhone"</span>) || _request.UserAgent.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"iPad"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">IsAndroid</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _request.UserAgent.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"Android"</span>) &amp;&amp; !_request.UserAgent.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"Windows Phone"</span>);
    }

}

</code></pre> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">重定向到插入页</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">接下来，我们要在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">context_BeginRequest</code>事件句柄中使用上面定义的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MobileDetect</code>类了。如果<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MobileDetect</code>类检测到用户的请求来自智能手机，那么他会被重定向到一个插入页<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MobileInterstitial.aspx</code>:</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">context_BeginRequest</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{

    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> context = HttpContext.Current;
    <span class="hljs-comment" style="color:#008000;">//使用当前上下文对象创建一个MobileDetect对象</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mobileDetect=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MobileDetect(context);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (mobileDetect.IsMobile())
    {
        <span class="hljs-comment" style="color:#008000;">//如果用户拒绝下载APP，那么我们需要将他跳转回之前访问的页面</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> url = context.Request.RawUrl;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> encodeUrl = HttpUtility.UrlEncode(url);
        <span class="hljs-comment" style="color:#008000;">//重定向到下载插入页，并带上returnUrl，以防用户需要返回到之前的页面</span>
        context.Response.Redirect(<span class="hljs-string" style="color:rgb(163,21,21);">"MobileInterstitial.aspx?returnUrl="</span> + encodeUrl);
    }
}


</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">插入页效果很简单，如下所示：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160812232718093-572641433.png" style="border:0px;" alt="577014-20160812232718093-572641433.png"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">两个按钮的点击事件如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> “不，谢谢”的按钮点击事件，用户点击了该按钮之后，需要将用户导向之前访问的url</span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="sender"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="e"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">protected</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">btnThanks_Click</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{

            <span class="hljs-comment" style="color:#008000;">//取到上一次请求的url</span>
            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> url = Request.QueryString.Get(<span class="hljs-string" style="color:rgb(163,21,21);">"returnUrl"</span>);
            Response.Redirect(HttpUtility.UrlDecode(url));
        }
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 点击下载按钮之后，跳转到相应的应用市场</span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="sender"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="e"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">protected</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">btnDownload_Click</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{
            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mobileDetect=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MobileDetect(Context);
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (mobileDetect.IsAndroid())
            {
                Response.Redirect(<span class="hljs-string" style="color:rgb(163,21,21);">"http://s1.music.126.net/download/android/CloudMusic_official_3.6.0.143673.apk"</span>);
            }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (mobileDetect.IsApple())
            {
                Response.Redirect(<span class="hljs-string" style="color:rgb(163,21,21);">"https://itunes.apple.com/app/id590338362"</span>);
            }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (mobileDetect.IsWindowsMobile())
            {
                Response.Redirect(<span class="hljs-string" style="color:rgb(163,21,21);">"https://www.microsoft.com/store/apps/9nblggh6g0jf"</span>);
            }
        }

</code></pre> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">添加检查</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">细心的园友可能会发现一个问题，如果按照上面的代码就这样完了，那是会出问题的。用户的每次请求都会经过HttpModule，这么一来，每次请求都会检测用户的客户端类型，然后再次跳转到插入下载页。即使用户点击了“不，谢谢！”按钮，还是会每次都跳转到下载插入页。这会让用户感到很烦人，可能会立即关闭这个网页，因而我们也就失去了一个潜在用户。因此，我们需要在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">context_BeginRequest</code>中添加条件判断：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">context_BeginRequest</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{
     <span class="hljs-comment" style="color:#008000;">//如果上一次请求来自下载插入页或者当前请求就是下载插入页，那么直接返回</span>
     <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (ComingFromMobileInterstitial()||OnMobileInterstitial())
     {
         <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
     }
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> context = HttpContext.Current;
     <span class="hljs-comment" style="color:#008000;">//使用当前上下文对象创建一个MobileDetect对象</span>
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mobileDetect=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MobileDetect(context);
     <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (mobileDetect.IsMobile())
     {
         <span class="hljs-comment" style="color:#008000;">//如果用户拒绝下载APP，那么我们需要将他跳转回之前访问的页面</span>
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> url = context.Request.RawUrl;
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> encodeUrl = HttpUtility.UrlEncode(url);
         <span class="hljs-comment" style="color:#008000;">//重定向到下载插入页，并带上returnUrl，以防用户需要返回到之前的页面</span>
         context.Response.Redirect(<span class="hljs-string" style="color:rgb(163,21,21);">"MobileInterstitial.aspx?returnUrl="</span> + encodeUrl);
     }
 }
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 检查当前请求的前一次请求是否是来自下载插入页</span>
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
 <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">ComingFromMobileInterstitial</span>(<span class="hljs-params"></span>) </span>{
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> request = HttpContext.Current.Request;
     <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (request.UrlReferrer==<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
     {
         <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">false</span>;
     }
     <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> request.UrlReferrer.AbsoluteUri.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"MobileInterstitial.aspx"</span>);
 }
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 判断当前请求是不是包含插入页文件</span>
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
 <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
 <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnMobileInterstitial</span>(<span class="hljs-params"></span>) </span>{
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> request = HttpContext.Current.Request;
     <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> request.RawUrl.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"MobileInterstitial.aspx"</span>);
 }


</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面只是解决了当用户点击拒绝下载之后用户不会再次直接跳转到下载插入页的问题，用户就不会卡在这个死循环了。但是我们还可以做得更好，假设用户不想安装APP，并希望在一个正常的移动端浏览器中查看页面，而且，用户点击了拒绝下载按钮之后，也不要每次请求都要重定向到下载插入页。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">进一步完善</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当用户点击了“不，谢谢！”按钮之后，我们就不要在每次页面请求时都跳转到下载插入页，不要再打扰他们了。一种方式就是当用户点击了该按钮之后，设置一个cookie：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">protected</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">btnThanks_Click</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{
    <span class="hljs-comment" style="color:#008000;">//用户点击拒绝下载按钮之后，设置一个cookie，并根据自己的情况设置一个有效期，这里为了演示，设置为2分钟</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> cookie=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> HttpCookie(<span class="hljs-string" style="color:rgb(163,21,21);">"NoThanks"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"yes"</span>);
    cookie.Expires = DateTime.Now.AddMinutes(<span class="hljs-number">2</span>);
    Response.Cookies.Add(cookie);
    <span class="hljs-comment" style="color:#008000;">//取到上一次请求的url</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> url = Request.QueryString.Get(<span class="hljs-string" style="color:rgb(163,21,21);">"returnUrl"</span>);
    Response.Redirect(HttpUtility.UrlDecode(url));
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">接下来，我们需要在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">context_BeginRequest</code>方法中检查是否具有特定值的Cookie，从而是否将用户重定向到下载插入页：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">context_BeginRequest</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> sender, EventArgs e</span>) </span>{
    <span class="hljs-comment" style="color:#008000;">//如果请求中的Cookie包含NoThanks键或者上一次请求来自下载插入页或者当前请求就是下载插入页，那么直接返回</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (ExistNoThanksCookie()||ComingFromMobileInterstitial()||OnMobileInterstitial())
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
    }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> context = HttpContext.Current;
    <span class="hljs-comment" style="color:#008000;">//使用当前上下文对象创建一个MobileDetect对象</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mobileDetect=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MobileDetect(context);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (mobileDetect.IsMobile())
    {
        <span class="hljs-comment" style="color:#008000;">//如果用户拒绝下载APP，那么我们需要将他跳转回之前访问的页面</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> url = context.Request.RawUrl;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> encodeUrl = HttpUtility.UrlEncode(url);
        <span class="hljs-comment" style="color:#008000;">//重定向到下载插入页，并带上returnUrl，以防用户需要返回到之前的页面</span>
        context.Response.Redirect(<span class="hljs-string" style="color:rgb(163,21,21);">"MobileInterstitial.aspx?returnUrl="</span> + encodeUrl);
    }
}

 <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">ExistNoThanksCookie</span>(<span class="hljs-params"></span>) </span>{
     <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> HttpContext.Current.Request.Cookies.Get(<span class="hljs-string" style="color:rgb(163,21,21);">"NoThanks"</span>) != <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>;
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面楼主将网站发布到IIS，使用Windows 10 Mobile,借助Windows 10 PC RS1版的连接功能，给大家截取动态图演示一下效果，其他类型的手机也可以访问网站并跳转到对应的应用商店，但是楼主这里主要可以借助win10 PC和手机进行投影给大家演示效果。动态图很大的，近1000帧剪辑得还剩100多帧。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160813020542640-1449368772.gif" style="border:0px;" alt="577014-20160813020542640-1449368772.gif"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">Web应用中的HttpModule使用AOP很好地解决了横切关注点的问题，别忘了我们这个系列的目的，是学习AOP的，而不是Web开发中的一些细节知识点，这个例子是页面边界切面的例子，下面我们看一个PostSharp方法边界处理缓存的例子。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="caching"></a>真实案例——缓存</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在web开发中有一种数据库优化的方法，比如，一个页面可能调用了很多次数据库，那么这些调用可以通过优化代码和减少数据库调用来改善性能。但是有时处理的速度不是我们能控制的，比如某些处理过程真的很复杂，需要花费很多时间来处理；有时我们需要依赖外部的处理（数据库，web服务等等），这些我们几乎没有控制权。<br> 重点来了，如果需要的数据处理的很慢，并且这些数据不经常变化，那么我们可以使用缓存来减少等待时间。Caching通常对于多用户的系统是非常有利的，第一次的请求还是很慢的，然后缓存将第一次请求的结果存储到可以迅速读取数据的本地，之后其他的请求就会先去缓存检测是否有需要的数据，如果有的话，就会直接从缓存中取出数据，从而跳过缓慢的处理过程。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">缓存也可以看作是一个横切关注点，对于想要使用缓存的每个方法，可以按照以下步骤来：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">检测缓存中是否含有值；</li> 
    <li style="list-style:decimal;">如果有，直接返回；</li> 
    <li style="list-style:decimal;">如果没有，像以往那样处理；</li> 
    <li style="list-style:decimal;">将处理的结果放到缓存中，以便下次使用。</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">用流程图画一下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160813112409781-1968382193.png" style="border:0px;" alt="577014-20160813112409781-1968382193.png"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的流程在代码中都实现出来的话，可能会导致大量的样板代码，这就暗示我们使用AOP是个不错的主意。下面我们看一个ASP.NET中关于<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Cache</code>对象的例子，并编写一个切面来更有效的工作。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">ASP.NET Cache</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">不同类型的应用可以使用不同的缓存工具，比如NCache,Memcached等。但这里我们关注的是如何使用AOP处理缓存而不是各种缓存工具的使用，下面的例子会使用.Net开发者的老朋友 ASP.NET Cache。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">ASP.NET代码中的缓存就像一个可以使用的字典对象，在ASP.NET WEB Froms中，Cache继承自Page基类，而在ASP.NET MVC中，通过继承自Controller基类的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpContext</code>就可以使用缓存了。如果上面的都无法读取缓存，可以通过<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">HttpContext.Current.Cache</code>获取。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">Cache对象的API很简单，可以把它当作字典来使用，可以从Cache中获取值，也可以往Cache中添加值。如果要获取的值没有存在于缓存中，就会返回null。</p> 
   <pre class="c#"><code class="hljs sql" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
<span class="hljs-keyword" style="color:rgb(0,0,255);">Cache</span>[<span class="hljs-string" style="color:rgb(163,21,21);">"MyCacheKey"</span>] = <span class="hljs-string" style="color:rgb(163,21,21);">"some value"</span>;//使用MyCacheKey作为键存储some value
var myValue = <span class="hljs-keyword" style="color:rgb(0,0,255);">Cache</span>[<span class="hljs-string" style="color:rgb(163,21,21);">"MyCacheKey"</span>];//使用键获取缓存
var myValue = <span class="hljs-keyword" style="color:rgb(0,0,255);">Cache</span>[<span class="hljs-string" style="color:rgb(163,21,21);">"SomeOtherKey"</span>];//如果缓存不存在就会返回null

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">Cache还有很多有用的其他方法，比如<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Add</code>&nbsp;和&nbsp;<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Insert</code>方法，这可以让我们指定缓存的过期时间。此外，也可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Remove</code>方法立即从缓存中移除一个值。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">Cache 有效期</h4> 
    <p>缓存值通常都会设置一个过期时间。比如，如果使用"CacheKey"存储了一个值，并设置过期时间是2小时之后，那么2小时之后，使用"CacheKey"检索那个值时就会返回null。<br> ASP.NET Cache有几个可以使用的过期时间设置：</p> 
    <ol>
     <li style="list-style:decimal;">绝对过期时间：该值会在给定的时间过期。</li> 
     <li style="list-style:decimal;">滑动过期时间：该值会在上次使用之后开始计算时间，如果超过了给定的时间就会过期。</li> 
     <li style="list-style:decimal;">永不过期：该值会一直存在，除非应用结束掉，或者该缓存存储了其他的东西。</li> 
    </ol>
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">关于缓存的一个案例</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这次我们创建一个ASP.NET MVC项目，项目的目录结构如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160814162524125-2007857430.png" style="border:0px;" alt="577014-20160814162524125-2007857430.png"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的其他文件夹Content，Scripts，Controller，Models等等就不用多说了，不懂的话，请去学习ASP.NET MVC。下面在用一张动态图看一下整个网站的效果：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160814163946859-1105492822.gif" style="border:0px;" alt="577014-20160814163946859-1105492822.gif"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个项目是楼主从头搭建起来的，整体布局使用的是法拉利红作为主题色，虽然给自己的定位是<strong>全栈</strong>，但是整个页面的布局还是花了不少时间的，看来自己还得在css和html方面深入学习一下啊。放了三个导航链接，Home页随便找了一辆自己看着还不错的法拉利图片，About放了两张打赏的图片，其实要讲的东西在最后一个Value页面。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160814164728781-448562889.gif" style="border:0px;" alt="577014-20160814164728781-448562889.gif"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">和之前一样，css，html,js代码这里就不贴出来了，感兴趣的可以去看源码，这里只放一些关于AOP的核心代码。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">Value显示页面</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面是点击Value按钮时的Action代码,主要是放了些select中的数据和读取缓存内容：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[HttpGet]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> ActionResult <span class="hljs-title" style="color:rgb(163,21,21);">Value</span>(<span class="hljs-params"></span>) </span>{
    ViewData[<span class="hljs-string" style="color:rgb(163,21,21);">"Cache"</span>]= DisplayCache();<span class="hljs-comment" style="color:#008000;">//显示缓存内容</span>
    <span class="hljs-comment" style="color:#008000;">//制造商数据</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> makes = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectList(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;SelectListItem&gt;
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"法拉利"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"Ferrari"</span>,Selected = <span class="hljs-keyword" style="color:rgb(0,0,255);">true</span>},
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"劳斯莱斯"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"Rolls-Royce"</span>},
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"迈巴赫"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"Maybach"</span>}
    },<span class="hljs-string" style="color:rgb(163,21,21);">"Value"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"Text"</span>);
    <span class="hljs-comment" style="color:#008000;">//年份数据</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> years=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectList(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;SelectListItem&gt;
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"2014年"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"2014"</span>},
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"2015年"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"2015"</span>},
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"2016年"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"2016"</span>,Selected = <span class="hljs-keyword" style="color:rgb(0,0,255);">true</span>}
    },<span class="hljs-string" style="color:rgb(163,21,21);">"Value"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"Text"</span>);
    <span class="hljs-comment" style="color:#008000;">//条件数据</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> conditions=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectList(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;SelectListItem&gt;
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"经济型"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"poor"</span>,Selected = <span class="hljs-keyword" style="color:rgb(0,0,255);">true</span>},
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"舒适型"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"comfort"</span>},
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SelectListItem{Text = <span class="hljs-string" style="color:rgb(163,21,21);">"豪华型"</span>,Value = <span class="hljs-string" style="color:rgb(163,21,21);">"best"</span>}
    },<span class="hljs-string" style="color:rgb(163,21,21);">"Value"</span>,<span class="hljs-string" style="color:rgb(163,21,21);">"Text"</span>);
    ViewData[<span class="hljs-string" style="color:rgb(163,21,21);">"makes"</span>] = makes;
    ViewData[<span class="hljs-string" style="color:rgb(163,21,21);">"years"</span>] = years;
    ViewData[<span class="hljs-string" style="color:rgb(163,21,21);">"conditions"</span>] = conditions;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> View();
}


<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 显示缓存内容</span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
<span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt; <span class="hljs-title" style="color:rgb(163,21,21);">DisplayCache</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> cacheList=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt;();
    <span class="hljs-comment" style="color:#008000;">//Response.Cache.SetCacheability(HttpCacheability.NoCache);</span>
    <span class="hljs-comment" style="color:#008000;">//Response.Cache.SetExpires(DateTime.Now.AddYears(-2));</span>
    <span class="hljs-comment" style="color:#008000;">//ClearAllCache();</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">foreach</span> (DictionaryEntry cache <span class="hljs-keyword" style="color:rgb(0,0,255);">in</span> HttpContext.Cache)
    {
        cacheList.Add(<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.Format(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}-{1}"</span>,cache.Key,cache.Value));
    }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!cacheList.Any())
    {
        cacheList.Add(<span class="hljs-string" style="color:rgb(163,21,21);">"None"</span>);
    }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> cacheList;
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">看到缓存里面有很多不知哪里生成的东西，就写了个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ClearAllCache()</code>方法清除所有的缓存，但是这样就没办法把自己的缓存也清除了，所以这里注释了。这里也不贴实现了，感兴趣的话请看源码。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">获取Value的Action</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">选择好各个条件之后，点击<em>获取Value</em>&nbsp;按钮就会通过ajax异步将选择的条件提交到下面这个action：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
[HttpPost]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> ActionResult <span class="hljs-title" style="color:rgb(163,21,21);">ValuePost</span>(<span class="hljs-params">FormCollection collection</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> years = Convert.ToInt32(Request.Form.Get(<span class="hljs-string" style="color:rgb(163,21,21);">"years"</span>));
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> makes = Request.Form.Get(<span class="hljs-string" style="color:rgb(163,21,21);">"makes"</span>);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> conditions = Request.Form.Get(<span class="hljs-string" style="color:rgb(163,21,21);">"conditions"</span>);
    <span class="hljs-comment" style="color:#008000;">//第二种方式获取form表单的值</span>
    <span class="hljs-comment" style="color:#008000;">//var years2 = Convert.ToInt32(collection.Get("years"));</span>
    <span class="hljs-comment" style="color:#008000;">//var makes2 = collection.Get("makes");</span>
    <span class="hljs-comment" style="color:#008000;">//var conditions2 = collection.Get("conditions");</span>

    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> carValueService=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> CarValueService();
    <span class="hljs-comment" style="color:#008000;">//第一种方式获取汽车价格，不具有健壮性，故不采用</span>
    <span class="hljs-comment" style="color:#008000;">//var value = carValueService.GetValue(years, makes, conditions);</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">value</span> = carValueService.GetValueBetter(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> CarValueArgs
    {
        Condition = conditions,Make = makes,Year = years
    });
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> Content(<span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>.ToString(<span class="hljs-string" style="color:rgb(163,21,21);">"c"</span>));
}
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个action就取到前端传过来的条件参数，然后使用这些参数借助<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">CarValueService</code>服务类获得车辆的价格。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">CarValueService服务类</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面是一个汽车服务类，一般情况下，这些数据是第三方汽车厂商或代理商、分销商等提供的，变化频率不是很高，而且调用一个Web Service可能会很慢，因此，可以用户缓存处理。这里我们使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Thread.Sleep(5000);</code>来模拟一个耗时操作。这里有两个方法，一个是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">GetValue</code>,一个是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">GetValueBetter</code>,上面也已经说了，后面的方法健壮性更好，因为只需要更改服务类方法的参数的属性就够了，而不用修改服务类方法的参数的签名。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">CarValueService</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> Random _ran;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">CarValueService</span>(<span class="hljs-params"></span>) </span>{
        _ran=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Random();
    }

    [CacheAspect]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetValue</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> year,<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> makeId,<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> conditionId</span>) </span>{
        Thread.Sleep(<span class="hljs-number">5000</span>);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _ran.Next(<span class="hljs-number">1000000</span>, <span class="hljs-number">10000000</span>);
    }

    [CacheAspect]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetValueBetter</span>(<span class="hljs-params">CarValueArgs args</span>) </span>{
        Thread.Sleep(<span class="hljs-number">5000</span>);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _ran.Next(<span class="hljs-number">1000000</span>, <span class="hljs-number">10000000</span>);
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">汽车的价格这里是去获取100w到1000w之间的随机数。方法上面都使用了缓存切面<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">CacheAspect</code>特性。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">缓存切面CacheAspect</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">既然是调用第三方不频繁变化的数据，那么就可以把请求的结果缓存起来。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">CacheAspect</span> : <span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 进入方法前执行的边界方法，进入服务类方法前先检测一下缓存中是否有数据，有就直接返回缓存中的数据</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="args"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> key = GetCacheKeyBetter(args);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (HttpContext.Current.Cache[key] == <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;<span class="hljs-comment" style="color:#008000;">//退出OnEntry方法，继续执行服务类方法</span>
        }
        args.ReturnValue = HttpContext.Current.Cache[key];
        args.FlowBehavior = FlowBehavior.Return;<span class="hljs-comment" style="color:#008000;">//这里的Return指的是跳过服务类方法</span>
    }
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 方法成功执行后执行的边界方法，调用第三方服务成功后缓存获取的结果</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="args"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//var key = GetCacheKey(args);</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> key = GetCacheKeyBetter(args);
        HttpContext.Current.Cache[key] = args.ReturnValue;
    }
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 获取Cache键，对应服务类方法有多个参数的版本</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="args"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetCacheKey</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> contactArgs = <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.Join(<span class="hljs-string" style="color:rgb(163,21,21);">"_"</span>, args.Arguments);
        contactArgs = args.Method.Name + <span class="hljs-string" style="color:rgb(163,21,21);">"-"</span> + contactArgs;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> contactArgs;
    }
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 获取Cache键，升级版本，对应服务类方法只有一个对象参数</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="args"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetCacheKeyBetter</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//方法1：通过JsonConvert</span>
        <span class="hljs-comment" style="color:#008000;">//var jsonArr = args.Arguments.Select(JsonConvert.SerializeObject).ToArray();</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> jsonArr = args.Arguments.Select(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> JavaScriptSerializer().Serialize).ToArray();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> args.Method.Name+<span class="hljs-string" style="color:rgb(163,21,21);">"_"</span> + <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.Join(<span class="hljs-string" style="color:rgb(163,21,21);">"_"</span>, jsonArr);
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码已经解释地很清楚了，大家看代码注释就好。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">这里为什么将缓存的键加入Json?</h4> 
    <p>易读。当看到屏幕上缓存的内容时，很清楚知道发生了什么，以及缓存了什么。<br> 轻量。无意冒犯xml粉，但这里真不需要额外的XML头和其他命名空间信息等标签。<br> 易生成。使用JsonConvert类或JavaScriptSerializer就可以轻易搞定。<br> 其实这里选哪种方式序列化无所谓，只要能实现给缓存生成一个唯一的键的目的就行。</p> 
   </blockquote> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="summary"></a>小结</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇博文我们看了一下切面常用的类型：<strong>边界切面</strong>。代码中的边界就像国家之间的分界线一样，它给我们提供了将行为放到代码边界的机会。两个常见的例子就是web页面加载前后和方法调用前后的例子。跟方法拦截切面一样，边界切面提供了封装横切关注点的另一种方式。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">PostSharp提供了编写方法拦截切面的能力，ASP.NET通过HttpModule提供了编写Web页面边界的能力,而且他们的API都提供了上下文信息(比如Http请求和方法的信息)，以及控制程序流的能力（比如重定向页面或立即从方法返回）。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这篇博客还做了好几个示例，希望正在看博客的你能自己动手实践一下。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   <p><font color="#494949"><span style="font-size:15px;line-height:25px;">本文转自tkbSimplest博客园博客，原文链接：http://www.cnblogs.com/farb/p/BoundaryAspects.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
