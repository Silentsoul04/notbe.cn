<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Code First开发系列之管理并发和事务 « NotBeCN</title>
  <meta name="description" content="             本篇目录              理解并发     理解积极并发     理解消极并发     使用EF实现积极并发     EF的默认并发     设计处理字段级别的并发应用     实现RowVersion     理解事务     创建测试环境     EF的默认事务处理    ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/11/weixin_34015566_90127971.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Code First开发系列之管理并发和事务</h1>
    <p class="post-meta">Dec 11, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);">本篇目录</h2> 
   <ul>
    <li style="list-style:disc;"> </li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>理解并发</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>理解积极并发</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>理解消极并发</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>使用EF实现积极并发</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>EF的默认并发</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>设计处理字段级别的并发应用</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>实现RowVersion</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>理解事务</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>创建测试环境</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>EF的默认事务处理</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>使用TransactionScope处理事务</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>使用EF6管理事务</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>使用已存在的事务</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>选择合适的事务管理</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>本章小结</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>自我测试</b></span></font></li> 
   </ul>
   <hr style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">本系列的源码本人已托管于Coding上：<strong><a href="https://coding.net/u/farb/p/AbpPractice/git/tree/master/EFCodeFirstFor8Days/FirstCodeFirstApp/ConcurrencyAndTransactionManagement" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">点击查看</a></strong>，想要注册Coding的可以<strong><a href="https://coding.net/register?key=3ed01333-c6d1-4254-8ed0-9bfbdfec4b38" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">点击该连接注册</a></strong>。<br> 先附上codeplex上EF的源码：<strong><a href="http://www.cnblogs.com/farb/p/entityframework.codeplex.com" rel="nofollow" class="uri" style="color:rgb(65,131,196);text-decoration:none;">entityframework.codeplex.com</a></strong>，此外，本人的实验环境是VS 2013 Update 5，windows 10,MSSQL Server 2008/2012。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="concurrency"></a>理解并发</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">并发管理解决的是允许多个实体同时更新，实际上这意味着允许同时在相同的数据上执行多个数据库操作。并发是在一个数据库上管理多个操作的一种方式，同时遵守了数据库操作的<strong>ACID属性（原子性，一致性，隔离性和持久性）</strong>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">想象一下下面几种可能发生并发的场景：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">用户甲和乙都尝试修改相同的实体</li> 
    <li style="list-style:disc;">用户甲和乙都尝试删除相同的实体</li> 
    <li style="list-style:disc;">用户甲正在尝试修改一个实体时，用户乙已经删除了该实体</li> 
    <li style="list-style:disc;">用户甲已经请求读取一个实体，用户乙读完该实体之后更新了它</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这些场景可能会潜在地产生错误的数据，试想，成百上千的用户同时尝试操作一个相同的实体，这种并发问题将会对系统带来更大的影响。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在处理与并发相关的问题时，一般有两种方法：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;"> <strong>积极并发</strong>：无论何时从数据库请求数据，数据都会被读取并保存到应用内存中。数据库级别没有放置任何显式锁。数据操作会按照数据层接收到的顺序执行。</li> 
    <li style="list-style:disc;"> <strong>消极并发</strong>：无论何时从数据库请求数据，数据都会被读取，然后该数据上就会加锁，因此没有人能访问该数据。这会降低并发相关问题的机会，缺点是加锁是一个昂贵的操作，会降低整个应用程序的性能。EF默认支持积极并发，这样，一旦所有的数据被读取，就会呈现在内存中。当然，也可以配置EF使用消极并发，但是EF不直接支持。</li> 
   </ul>
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="optimistic" style="color:rgb(224,130,131);"></a>理解积极并发</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">前面提到，在积极并发中，无论何时从数据库请求数据，数据都会被读取并保存到应用内存中。数据库级别没有放置任何显式锁。因为这种方法没有添加显式锁，所以比消极并发更具扩展性和灵活性。使用积极并发，重点是如果发生了任何冲突，应用程序要亲自处理它们。最重要的是，使用积极并发控制时，在应用中要有一个冲突处理策略，要让应用程序的用户知道他们的修改是否因为冲突的缘故没有持久化。积极并发本质上是允许冲突发生，然后以一种适当的方式解决该冲突。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面是处理冲突的策略例子。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">忽略冲突/强制更新</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这种策略是让所有的用户更改相同的数据集，然后所有的修改都会经过数据库，这就意味着数据库会显示最后一次更新的值。这种策略会导致潜在的数据丢失，因为许多用户的更改都丢失了，只有最后一个用户的更改是可见的。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">部分更新</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在这种情况中，我们也允许所有的更改，但是不会更新完整的行，只有特定用户拥有的列更新了。这就意味着，如果两个用户更新相同的记录但却不同的列，那么这两个更新都会成功，而且来自这两个用户的更改都是可见的。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">警告/询问用户</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当一个用户尝试更新一个记录时，但是该记录自从他读取之后已经被别人修改了，这时应用程序就会警告该用户该数据已经被某人更改了，然后询问他是否仍然要重写该数据还是首先检查已经更新的数据。</p> 
   <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">拒绝更改</h4> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当一个用户尝试更新一个记录时，但是该记录自从他读取之后已经被别人修改了，此时告诉该用户不允许更新该数据，因为数据已经被某人更新了。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="pessimistic" style="color:rgb(224,130,131);"></a>理解消极并发</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">和积极并发相反，消极并发的目标是永远不让任何冲突发生。这是通过在使用记录之前就在记录上放置显式锁实现的。数据库记录上可以得到两种类型的锁：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">只读锁</li> 
    <li style="list-style:disc;">更新锁</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当把只读锁放到记录上时，应用程序只能读取该记录。如果应用程序要更新该记录，它必须获取到该记录上的更新锁。如果记录上加了只读锁，那么该记录仍然能够被想要只读锁的请求使用。然而，如果需要更新锁，该请求必须等到所有的只读锁释放。同样，如果记录上加了更新锁，那么其他的请求不能再在这个记录上加锁，该请求必须等到已存在的更新锁释放才能加锁。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从前面的描述中，似乎消极并发能解决所有跟并发相关的问题，因为我们不必在应用中处理这些问题。然而，事实上并不是这样的。在使用消极并发管理之前，我们需要记住，使用消极并发有很多问题和开销。下面是使用消极并发面临的一些问题：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">应用程序必须管理每个操作正在获取的所有锁；</li> 
    <li style="list-style:disc;">加锁机制的内存需求会降低应用性能</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">多个请求互相等待需要的锁，会增加死锁的可能性。由于这些原因，EF不直接支持消极并发。如果想使用消极并发的话，我们可以自定义数据库访问代码。此外，当使用消极并发时，LINQ to Entities不会正确工作。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>我们尽可能不要尝试使用消极并发。并发相关的冲突可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TimeStamp</code>字段或者<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">RowVersion</code>类型处理。后面会做介绍。</p> 
   </blockquote> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="EFoptimistic"></a>使用EF实现积极并发</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用EF实现积极并发有很多方法，接下来我们就会看一下这些方法。我这里仍然使用打赏者的例子。<br> 新建一个控制台项目，取名<strong>ConcurrencyAndTransactionManagement</strong>，这次只创建打赏者实体类如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Donator</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> Id { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> Name { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> Amount { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> DateTime DonateDate { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
}

</code></pre> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="EFdefaultConcurrency" style="color:rgb(224,130,131);"></a>EF的默认并发</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">先看一下EF默认是如何处理并发的。现在假设我们的应用程序要更新一个Donator的<strong>Amount</strong>值，那么我们首先需要实现这两个函数<strong>GetDonator()</strong>&nbsp;和&nbsp;<strong>UpdateDonator()</strong>，前者用于获取指定Donator，后者用于更新指定Donator。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> Donator <span class="hljs-title" style="color:rgb(163,21,21);">GetDonator</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> id</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context())
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> db.Donators.Find(id);
    }
}

<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">UpdateDonator</span>(<span class="hljs-params">Donator donator</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context())
    {
        db.Entry(donator).State=EntityState.Modified;
        db.SaveChanges();
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面我们实现这么一种场景：有两个用户甲和乙都读取了同一个Donator实体，然后这两个用户都尝试更新这个实体的不同字段，比如甲更新<strong>Name</strong>字段，乙更新<strong>Amount</strong>字段，代码如下：</p> 
   <pre class="c#"><code class="hljs swift" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-comment" style="color:#008000;">//1.用户甲获取id=1的打赏者</span>
<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator1 = <span class="hljs-type" style="color:rgb(163,21,21);">GetDonator</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment" style="color:#008000;">//2.用户乙也获取id=1的打赏者</span>
<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator2 = <span class="hljs-type" style="color:rgb(163,21,21);">GetDonator</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment" style="color:#008000;">//3.用户甲只更新这个实体的Name字段</span>
donator1.<span class="hljs-type" style="color:rgb(163,21,21);">Name</span> = <span class="hljs-string" style="color:rgb(163,21,21);">"用户甲"</span>;
<span class="hljs-type" style="color:rgb(163,21,21);">UpdateDonator</span>(donator1);
<span class="hljs-comment" style="color:#008000;">//4.用户乙只更新这个实体的Amount字段</span>
donator2.<span class="hljs-type" style="color:rgb(163,21,21);">Amount</span> = 100m;
<span class="hljs-type" style="color:rgb(163,21,21);">UpdateDonator</span>(donator2);

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码尝试模拟了一种并发问题。现在，两个用户都有相同的数据副本，然后尝试更新相同的记录。执行代码前，先看下数据库中的数据：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/b5c54e5a-3ff6-4b70-afc6-2f86baec3a69.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">为了测试，在执行第四步时打一个断点：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/e8d8de46-0e68-4375-ad91-6f6dfc93a2ad.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在断点之后的代码执行之前，去数据库看一下数据，可以看到用户甲的更新已经产生作用了：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/d3a51815-6af2-47e6-9e7b-ce630261113a.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">继续执行代码，再看一下数据库中的数据发生了什么变化：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/4ee4ca8a-2145-4768-93e5-883797abeaed.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从上面的截图可以看出，用户乙的请求成功了，而用户甲的更新丢失了。因此，从上面的代码不难看出，如果我们使用EF更新整条记录，那么最后一个请求总会获取胜利，也就是说，最后一次请求的更新会覆盖之前所有请求的更新。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="designApp" style="color:rgb(224,130,131);"></a>设计处理字段级别并发的应用</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">接下来，我们会看到如何编写处理字段级并发问题的应用代码。这种方式设计应用的思想是，只有更新的字段会在数据库中更改。这个就保证了如果多个用户正在更新不同的字段，所有的更改都会持久化到数据库。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">实现这个的关键是让该应用识别用户正在请求更新的所有列，然后为该用户有选择地更新那些字段。通过以下两个东西来实现：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">一个方法：该方法会给我们一个原始模型的克隆，只有用户请求的属性会更新为新值</li> 
    <li style="list-style:disc;"> <em>更新</em>方法：它会检查原始请求模型的哪个属性值已经更改，然后在数据库中只更新那些值。</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">因此，首先需要创建一个简单的方法，该方法需要模型属性的值，然后会返回一个新的模型，该模型除了用户尝试更新的属性之外，其他的属性值都和原来的模型属性值相同。</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> Donator <span class="hljs-title" style="color:rgb(163,21,21);">GetUpdatedDonator</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> id,<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> name,<span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> amount,DateTime donateDate</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Donator
    {
        Id = id,
        Name = name,
        Amount = amount,
        DonateDate = donateDate
    };
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果用户只想更新<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Amount</code>字段，方法的调用就像下面这样：</p> 
   <pre class="c#"><code class="hljs lisp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">var donator1 = GetDonator(<span class="hljs-number">1</span>)<span class="hljs-comment" style="color:#008000;">;</span>
var donator2 = GetDonator(<span class="hljs-number">1</span>)<span class="hljs-comment" style="color:#008000;">;</span>
var newDonator = GetUpdatedDonator(<span class="hljs-name" style="color:rgb(0,0,255);">donator2</span>.Id, donator1.Name,<span class="hljs-number">100</span>m, donator1.DonateDate)<span class="hljs-comment" style="color:#008000;">;</span>
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在上面的代码中，<em>donator1</em>是用户请求模型的原始对象，100m是打赏金额的新值。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>上面的方法超级简单，它只显示了如何获得具有更新属性值的克隆对象。现实生活中，很少会看到这样的代码。为了更简洁，我们还可以使用映射模块将领域模型映射到数据模型。</p> 
   </blockquote> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下一步，需要更改<strong>更新方法</strong>。该更新方法会实现下面更新数据的算法：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">从数据库中检索最新的模型值</li> 
    <li style="list-style:decimal;">检查原始模型和要更新的模型来找出更改属性的列表</li> 
    <li style="list-style:decimal;">只更新步骤1中检索到的模型发生变化的属性</li> 
    <li style="list-style:decimal;">保存更改</li> 
   </ol>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">该算法的代码大概像下面这个样子：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">UpdateDonatorEnhanced</span>(<span class="hljs-params">Donator originalDonator,Donator newDonator</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context())
    {
        <span class="hljs-comment" style="color:#008000;">//从数据库中检索最新的模型</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator = db.Donators.Find(originalDonator.Id);
        <span class="hljs-comment" style="color:#008000;">//接下来检查用户修改的每个属性</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (originalDonator.Name!=newDonator.Name )
        {
            <span class="hljs-comment" style="color:#008000;">//将新值更新到数据库</span>
            donator.Name = newDonator.Name;
        }
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (originalDonator.Amount != newDonator.Amount)
        {
            <span class="hljs-comment" style="color:#008000;">//将新值更新到数据库</span>
            donator.Amount = newDonator.Amount;
        }
        <span class="hljs-comment" style="color:#008000;">//这里省略其他属性...</span>
        db.SaveChanges();
    }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">接下来，使用这两个方法来更新应用程序代码，并检查结果：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 2.0 设计处理字段级别的并发应用</span>
 <span class="hljs-comment" style="color:#008000;">//1.用户甲读取id=1的打赏者</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator1 = GetDonator(<span class="hljs-number">1</span>);
 <span class="hljs-comment" style="color:#008000;">//2.用户乙同样读取id=1的打赏者</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator2 = GetDonator(<span class="hljs-number">1</span>);
 <span class="hljs-comment" style="color:#008000;">//3.用户甲通过创建一个新的对象来更新打赏金额为100m</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> newDonator1 = GetUpdatedDonator(donator2.Id, donator1.Name,<span class="hljs-number">100</span>m, donator1.DonateDate);
UpdateDonatorEnhanced(donator1,newDonator1);
 <span class="hljs-comment" style="color:#008000;">//4.用户乙通过创建一个新的对象来更新打赏者姓名为“并发测试”</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> newDonator2 = GetUpdatedDonator(donator2.Id, <span class="hljs-string" style="color:rgb(163,21,21);">"并发测试"</span>, donator2.Amount, donator2.DonateDate);
 UpdateDonatorEnhanced(donator1, newDonator2);
 <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>
</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行代码之前，先看下数据库中的数据：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/adafc24a-6718-4908-83ec-44ac1b642547.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在执行第四步时打个断点，运行程序：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/b1efa250-5ece-4191-b84c-af5410aefbf8.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">再次查看数据库中的数据，发现用户甲的操作已经执行了：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/859849b3-8d0e-461a-a1d3-aabfb15520e7.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">继续运行程序，再次查看数据库的数据，发现用户乙的操作也执行了：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/4001435a-751f-41dd-9fb3-f8d70fbb30cc.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从上面的截图看到，两个用户的请求同一个实体的更新值都持久化到数据库中了。因此，如果用户更新不同的字段，该程序可以有效地处理并发更新了。但是如果多个用户同时更新相同的字段，那么这种方法仍然显示的是最后一次请求的值。虽然这种方式减少了一些并发相关的问题，但是这种方法意味着我们必须写大量代码来处理并发问题。后面我们会看到如何使用EF提供的机制来处理并发问题。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="rowVersion" style="color:rgb(224,130,131);"></a>为并发实现RowVersion</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">前面，我们看到了EF默认如何处理并发（最后一次请求获胜），然后看了如果多个用户尝试更新不同的字段时，如何设计应用处理这些问题。接下来，我们看一下当多个用户更新相同的字段时，使用EF如何处理字段级并发。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">EF让我们指定字段级并发，这样如果一个用户更新一个字段的同时，该字段已经被其他人更新过了，就会抛出一个并发相关的异常。使用这种方法，当多个用户尝试更新相同的字段时，我们就可以更有效地处理并发相关的问题。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果我们为多个字段使用了特定字段的并发，那么会降低应用性能，因为生成的Sql会更大，更加有效的方式就是使用<strong>RowVersion</strong>机制。RowVersion机制使用了一种数据库功能，每当更新行的时候，就会创建一个新的行值。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">给Donator实体添加一个属性：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Timestamp]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">byte</span>[] RowVersion { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }

<span class="hljs-comment" style="color:#008000;">//修改上下文</span>

<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">protected</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnModelCreating</span>(<span class="hljs-params">DbModelBuilder modelBuilder</span>) </span>{
    modelBuilder.Entity&lt;Donator&gt;().Property(d =&gt; d.RowVersion).IsRowVersion();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">base</span>.OnModelCreating(modelBuilder);
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">添加一个数据库初始化器，重新生成数据库，数据库模式变为：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/06340c45-0717-4374-9e53-58c278748d89.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">插入两条数据，RowVersion列显示的是<strong>二进制数据</strong>：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/3dfaaa32-8cf8-4622-bed7-1ba2fc7ed6dd.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，EF就会为并发控制追踪RowVersion列值。接下来尝试更新不同的列：</p> 
   <pre class="c#"><code class="hljs swift" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-comment" style="color:#008000;">//1.用户甲获取id=1的打赏者</span>
<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator1 = <span class="hljs-type" style="color:rgb(163,21,21);">GetDonator</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment" style="color:#008000;">//2.用户乙也获取id=1的打赏者</span>
<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> donator2 = <span class="hljs-type" style="color:rgb(163,21,21);">GetDonator</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment" style="color:#008000;">//3.用户甲只更新这个实体的Name字段</span>
donator1.<span class="hljs-type" style="color:rgb(163,21,21);">Name</span> = <span class="hljs-string" style="color:rgb(163,21,21);">"用户甲"</span>;
<span class="hljs-type" style="color:rgb(163,21,21);">UpdateDonator</span>(donator1);
<span class="hljs-comment" style="color:#008000;">//4.用户乙只更新这个实体的Amount字段</span>
donator2.<span class="hljs-type" style="color:rgb(163,21,21);">Amount</span> = 100m;
<span class="hljs-type" style="color:rgb(163,21,21);">UpdateDonator</span>(donator2); 

 </code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行程序，会抛出下面的异常：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/5d362b3f-eb9b-434e-b4c6-308e08b14710.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">其他信息：Entities may have been modified or deleted since entities were loaded.</code></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从抛出的异常信息来看，很明显是抛出了和并发相关的异常<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DbUpdateConcurrencyException</code>，其他信息说明了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">自从实体加载以来，可能已经被修改或删除了</code>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">无论何时一个用户尝试更新一条已经被其他用户更新的记录，都会获得异常<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DbUpdateConcurrencyException</code>。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当实现并发时，我们总要编写异常处理的代码，给用户展示一个更友好的描述信息。比如：</p> 
   <pre class="c#"><code class="hljs cpp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">  <span class="hljs-comment" style="color:#008000;">//4.用户乙只更新这个实体的Amount字段</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">try</span>
 {
     donator2.Amount = <span class="hljs-number">100</span>m;
     UpdateDonator(donator2);
     Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"应该发生并发异常！"</span>);
 }
 <span class="hljs-keyword" style="color:rgb(0,0,255);">catch</span> (DbUpdateConcurrencyException ex)
 {
     Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"异常如愿发生！"</span>);
 }

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">此时，我们应该使用当前的数据库值更新数据，然后重新更改。作为开发者，如果我们想要协助用户的话，可以使用EF的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DbEntityEntry</code>类获取当前的数据库值。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="transaction"></a>理解事务</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">处理以数据为中心的应用时，另一个重要的话题是事务管理。ADO.NET为事务管理提供了一个非常干净和有效的API。因为EF运行在ADO.NET之上，所以EF可以使用ADO.NET的事务管理功能。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当从数据库角度谈论事务时，它意味着一系列操作被当作一个不可分割的操作。所有的操作要么全部成功，要么全部失败。事务的概念是一个可靠的工作单元，事务中的所有数据库操作应该应该被看作一个工作单元。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从应用程序的角度来看，如果我们有多个数据库操作被当作一个工作单元，那么应该将这些操作包裹在一个事务中。为了能够使用事务，应用程序需要执行下面的步骤：</p> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">开始事务；</li> 
    <li style="list-style:decimal;">执行所有的查询，执行所有的数据库操作，这些操作被视为一个工作单元；</li> 
    <li style="list-style:decimal;">如果所有的事务成功了，那么提交事务；</li> 
    <li style="list-style:decimal;">如果任何一个操作失败，就回滚事务。</li> 
   </ol>
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="setup"></a>创建测试环境</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">提到事务，最经典的例子莫过于银行转账了。我们这里也使用这个例子来理解一下和事务相关的概念。为了简单模拟银行转账的情景，假设银行为不同的账户类型使用了不同的表，对应地，我创建了两个实体<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OutputAccount</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InputAccount</code>，实体类代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> [Table(<span class="hljs-string" style="color:rgb(163,21,21);">"OutputAccounts"</span>)]
 <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">OutputAccount</span>
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> Id { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
     [StringLength(<span class="hljs-number">8</span>)]
     <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> Name { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
     <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> Balance { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
 }


[Table(<span class="hljs-string" style="color:rgb(163,21,21);">"InputAccounts"</span>)]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">InputAccount</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> Id { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    [StringLength(<span class="hljs-number">8</span>)]
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> Name { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> Balance { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从应用程序的角度看，无论何时用户将钱从<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OutputAccount</code>转入<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InputAccount</code>，这个操作应该被视为一个工作单元。永远不应该发生<strong>OutputAccount</strong>的金额扣除了，而<strong>InputAccount</strong>的金额没有增加！接下来我们就看一下使用EF如何管理事务。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在给数据库插入数据，让它们的初始金额如下所示：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/ff6f015c-1cc1-4aac-af22-76ab89f5cd38.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，我们尝试使用EF的事务从<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OutputAccount</code>的甲转入1000给<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InputAccount</code>的乙。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>这只是个例子，只为了以一种简单的方式描述涉及到的概念。现实生活中，这个场景的数据库会远比这个更复杂和更优化。</p> 
   </blockquote> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="default"></a>EF的默认事务处理</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">EF的默认行为是，无论何时执行任何涉及<strong>Create，Update或Delete</strong>的查询，都会默认创建事务。当DbContext类上的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SaveChanges()</code>方法被调用时，事务就会提交。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">要实现我们的场景，代码应该是下面这样的：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 4.0 EF默认的事务处理</span>

<span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> outputId = <span class="hljs-number">2</span>,inputId=<span class="hljs-number">1</span>;
<span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> transferAmount = <span class="hljs-number">1000</span>m;
<span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context())
{
    <span class="hljs-comment" style="color:#008000;">//1 检索事务中涉及的账户</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> outputAccount = db.OutputAccounts.Find(outputId);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> inputAccount = db.InputAccounts.Find(inputId);
    <span class="hljs-comment" style="color:#008000;">//2 从输出账户上扣除1000</span>
    outputAccount.Balance -= transferAmount;
    <span class="hljs-comment" style="color:#008000;">//3 从输入账户上增加1000</span>
    inputAccount.Balance += transferAmount;

    <span class="hljs-comment" style="color:#008000;">//4 提交事务</span>
    db.SaveChanges();
}
<span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行程序，结果如下：</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://dn-coding-net-production-pp.qbox.me/ceddb604-a68d-43da-a891-59143c7ffc2d.png" alt="图片" style="border:0px;"></p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">可以看到，甲账户上少了1000，而乙账户上多了1000。因此，这两个操作有效地被包裹在了一个事务中，并作为一个工作单元执行。如果任何一个操作失败，数据就不会发生变化。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>因为把<strong>读</strong>操作放到事务中没有好处，但是却降低了整个应用程序的性能，因此，EF不会对涉及数据库的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Select</code>查询使用事务。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="transactionScope" style="color:rgb(224,130,131);"></a>使用TransactionScope处理事务</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果有一个场景具有多个<strong>DbContext</strong>对象，那么我们想将涉及多个DbContext对象的操作关联为一个工作单元，这时，我们需要在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TransactionScope</code>对象内部包裹<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SaveChanges</code>方法的调用。为了描述这个场景，我们使用DbContext类的两个不同实例来执行扣款和收款：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 5.0 使用TransactionScope处理事务</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> outputId = <span class="hljs-number">2</span>, inputId = <span class="hljs-number">1</span>;
 <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> transferAmount = <span class="hljs-number">1000</span>m;
 <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> ts=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TransactionScope(TransactionScopeOption.Required))
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db1=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context();
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db2=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context();
     <span class="hljs-comment" style="color:#008000;">//1 检索事务中涉及的账户</span>
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> outputAccount = db1.OutputAccounts.Find(outputId);
     <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> inputAccount = db2.InputAccounts.Find(inputId);
     <span class="hljs-comment" style="color:#008000;">//2 从输出账户上扣除1000</span>
     outputAccount.Balance -= transferAmount;
     <span class="hljs-comment" style="color:#008000;">//3 从输入账户上增加1000</span>
     inputAccount.Balance += transferAmount;

     db1.SaveChanges();
     db2.SaveChanges();

     ts.Complete();
 }
 <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码中，我们使用了两个不同的<strong>DbContext</strong>实例执行扣款和收款操作。因此，默认的EF行为不会工作。在调用各自的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SaveChanges()</code>方法时，和上下文相关的各个事务不会提交。相反，因为它们都在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TransactionScope</code>对象的内部，所以，当<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TransactionScope</code>对象的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Complete()</code>方法调用时，事务才会提交。如果任何一个操作失败，就会发生异常，TransactionScope就不会调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Complete()</code>方法，从而回滚更改。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="ef6"></a>使用EF6管理事务</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从EF 6起，EF在DbContext对象上提供了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Database.BeginTransaction()</code>方法，当使用上下文类在事务中执行原生SQL命令时，这个方法特别有用。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">接下来看一下如何使用这个新方法管理事务。这里我们使用原生SQL从<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OutputAccounts</code>中扣款，使用模型类给<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InputAccounts</code>收款：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 6.0 使用EF6管理事务</span>
 <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> outputId = <span class="hljs-number">2</span>, inputId = <span class="hljs-number">1</span>;
 <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> transferAmount = <span class="hljs-number">1000</span>m;
 <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context())
 {
     <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> trans=db.Database.BeginTransaction())
     {
         <span class="hljs-keyword" style="color:rgb(0,0,255);">try</span>
         {
             <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> sql = <span class="hljs-string" style="color:rgb(163,21,21);">"Update OutputAccounts set Balance=Balance-@amountToDebit where id=@outputId"</span>;
             db.Database.ExecuteSqlCommand(sql, <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SqlParameter(<span class="hljs-string" style="color:rgb(163,21,21);">"@amountToDebit"</span>, transferAmount), <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SqlParameter(<span class="hljs-string" style="color:rgb(163,21,21);">"@outputId"</span>,outputId));

             <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> inputAccount = db.InputAccounts.Find(inputId);
             inputAccount.Balance += transferAmount;
             db.SaveChanges();

             trans.Commit();
         }
         <span class="hljs-keyword" style="color:rgb(0,0,255);">catch</span> (Exception ex)
         {
             trans.Rollback();
         }
     }
 }
 <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">稍作解释，首先创建了一个DbContext类的实例，然后使用这个实例通过调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Database.BeginTransaction()</code>方法开始了一个事务。该方法给我们返回了一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DbContextTransaction</code>对象的句柄，使用该句柄可以提交或者回滚事务。然后使用原生SQL从<strong>OutputAccounts</strong>中扣款，使用模型类为&nbsp;<strong>InputAccounts</strong>收款。调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SaveChanges()</code>方法只会影响第二个操作（在事务提交之后影响），但不会提交事务。如果两个操作都成功了，那么就调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DbContextTransaction</code>对象的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Commit()</code>方法，否则，我们就处理异常并调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Rollback()</code>方法回滚事务。</p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
    <p>这种方式只用于EF6，如果是EF6之前的版本，必须依赖<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TransactionScope</code>管理事务。</p> 
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="existing" style="color:rgb(224,130,131);"></a>使用已存在的事务</h3> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">有时，我们想在EF的DbContext类中使用一个已存在的事务。原因可能有这么几个：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">一些操作可能在应用的不同部分完成。</li> 
    <li style="list-style:disc;">对老项目使用了EF，并且这个老项目使用了一个类库，这个类库给我们提供了事务或数据库连接的句柄。</li> 
   </ul>
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">对于这些场景，EF允许我们在DbContext类中使用一个和事务相关联的已存在连接。接下来，写一个简单的函数来模拟老项目的类库提供句柄，该函数使用纯粹的ADO.NET执行扣款操作：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-comment" style="color:#008000;">//模拟老项目的类库</span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> <span class="hljs-title" style="color:rgb(163,21,21);">DebitOutputAccount</span>(<span class="hljs-params">SqlConnection conn, SqlTransaction trans, <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> accountId, <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> amountToDebit</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> affectedRows = <span class="hljs-number">0</span>;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> command = conn.CreateCommand();
    command.Transaction = trans;
    command.CommandType=CommandType.Text;
    command.CommandText = <span class="hljs-string" style="color:rgb(163,21,21);">"Update OutputAccounts set Balance=Balance-@amountToDebit where id=@accountId"</span>;
    command.Parameters.AddRange(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SqlParameter[]
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SqlParameter(<span class="hljs-string" style="color:rgb(163,21,21);">"@amountToDebit"</span>,amountToDebit), 
        <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SqlParameter(<span class="hljs-string" style="color:rgb(163,21,21);">"@accountId"</span>,accountId) 
    });

    <span class="hljs-keyword" style="color:rgb(0,0,255);">try</span>
    {
        affectedRows= command.ExecuteNonQuery();
    }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">catch</span> (Exception ex)
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> ex;
    }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> affectedRows == <span class="hljs-number">1</span>;
}

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">该函数需要四个参数，来自调用者的数据库连接对象和事务对象，以及扣款账户id和扣款金额，知道了这些参数之后就可以执行扣款操作的更新查询。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，假设这个函数以类库的行为提供给我们，很显然，我们什么都不能更改。这种情况，我们不能使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Database.BeginTransaction</code>方法，因为我们需要将<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlConnection</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlTransaction</code>对象传给该函数，并把该函数放到我们的事务里。这样，我们就需要首先创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlConnection</code>，然后开始<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlTransaction</code>。代码如下：</p> 
   <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">    <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 7.0 使用已存在的事务</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">int</span> outputId = <span class="hljs-number">2</span>, inputId = <span class="hljs-number">1</span>;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> transferAmount = <span class="hljs-number">1000</span>m;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> connectionString = ConfigurationManager.ConnectionStrings[<span class="hljs-string" style="color:rgb(163,21,21);">"ConcurrencyAndTransactionManagementConn"</span>].ConnectionString;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> conn=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SqlConnection(connectionString))
    {
        conn.Open();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> trans=conn.BeginTransaction())
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">try</span>
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> result = DebitOutputAccount(conn, trans, outputId, transferAmount);
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!result)
                {
                    <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Exception(<span class="hljs-string" style="color:rgb(163,21,21);">"不能正常扣款！"</span>);
                }
                <span class="hljs-keyword" style="color:rgb(0,0,255);">using</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> db=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Context(conn,contextOwnsConnection:<span class="hljs-keyword" style="color:rgb(0,0,255);">false</span>))
                {
                    db.Database.UseTransaction(trans);
                    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> inputAccount=db.InputAccounts.Find(inputId);
                    inputAccount.Balance += transferAmount;
                    db.SaveChanges();
                }
                trans.Commit();
            }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">catch</span> (Exception ex) 
            {
                trans.Rollback();
            }
        }
    }

    <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>

</code></pre> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">稍作解释，首先创建了一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlConnection</code>,然后使用该连接关联了一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlTransaction</code>。事务开始后，我们就使用连接和事务对象调用老项目中的方法，然后检查了一下调用老项目中的方法是否执行成功！如果失败，我们直接抛出异常，捕获异常后会回滚该事务。如果成功了，我们使用了DbContext类来为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InputAccounts</code>用户添加收款，并提交事务。这里有一句代码值得注意<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">db.Database.UseTransaction(trans);</code>,这句话的意思是，EF执行的操作都在外部传入的事务中执行。还有，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">contextOwnsConnection</code>的值为false，表示上下文和数据库连接没有关系，上下文释放了，数据库连接还没释放；反之为true的话，上下文释放了，数据库连接也就释放了。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="choose"></a>选择合适的事务管理</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">目前，我们已经知道了好几种使用EF处理事务的方法，下面一一对号入座：</p> 
   <ul style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:disc;">如果只有一个DbContext类，那么应该尽力使用EF的默认事务管理。我们总应该将所有的操作组成一个在相同的DbContext对象的作用域中执行的工作单元，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SaveChanges()</code>方法会处理提交事务。</li> 
    <li style="list-style:disc;">如果使用了多个DbContext对象，那么管理事务的最佳方法可能就是把调用放到<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TransactionScope</code>对象的作用域中了。</li> 
    <li style="list-style:disc;">如果要执行原生SQL，并想把这些操作和事务关联起来，那么应该使用EF提供的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Database.BeginTransaction()</code>方法。然而这种方法只支持EF6，不支持之前的版本。</li> 
    <li style="list-style:disc;">如果想为要求<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SqlTransaction</code>的老项目使用EF，那么可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Database.UseTransaction()</code>方法，在EF6中可用。</li> 
   </ul>
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="summary"></a>本章小结</h2> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">首先，我们看了下如何管理EF中并发相关的问题，然后讨论了如何使用EF实现积极并发。我们也看了消极并发的一些基本概念以及为什么EF不支持和不推荐使用消极并发。</p> 
   <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">然后，我们看了如何使用EF管理事务。先是看了EF管理事务的默认实现，然后看了使用EF控制事务管理，最后看到了使用EF实现应用程序需要的大多数信息。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="selftest"></a>自我测试</h2> 
   <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
    <li style="list-style:decimal;">在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">EntityTypeConfiguration</code>类中，需要调用什么方法将一个属性标记为并发属性？</li> 
    <li style="list-style:decimal;">哪一种异常类型表示并发错误？</li> 
   </ol>
   <div>
    <font color="#494949"><span style="font-size:15px;line-height:25px;"><br></span></font>
   </div> 
   <div>
    <font color="#494949"><span style="font-size:15px;line-height:25px;"><br></span></font>
   </div> 
   <div>
    <font color="#494949"><span style="font-size:15px;line-height:25px;"><br></span></font>
   </div> 
   <div>
    <font color="#494949"><span style="font-size:15px;line-height:25px;"><br></span></font>
   </div> 
   <div>
    <font color="#494949"><span style="font-size:15px;line-height:25px;">本文转自tkbSimplest博客园博客，原文链接：http://www.cnblogs.com/farb/p/ConcurrencyAndTransctionManagement.html，如需转载请自行联系原作者</span><br></font>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
