<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Python新手入门教程，从环境准备到掌握基本编程 « NotBeCN</title>
  <meta name="description" content="             Lesson 1 准备好学习Python的环境下载的地址是：www.python.org为了咱们的便当，我在校内作了copy：http://10.1.204.2/tool/compiler&amp;IDE/Python-2.3.2-1.exelinux版本的我就不说了，由于若是你可以使用...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/11/weixin_33912246_90132951.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Python新手入门教程，从环境准备到掌握基本编程</h1>
    <p class="post-meta">Dec 11, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>Lesson 1 准备好学习Python的环境<br>下载的地址是：<br>www.python.org<br>为了咱们的便当，我在校内作了copy：<br><a href="http://10.1.204.2/tool/compiler&amp;IDE/Python-2.3.2-1.exe" rel="nofollow">http://10.1.204.2/tool/compiler&amp;IDE/Python-2.3.2-1.exe</a><br>linux版本的我就不说了，由于若是你可以使用linux并装置好阐明你可以一切自个搞定的。</p> 
   <p>运转环境可以是linux或许是windows：<br>1、linux<br>redhat的linux装置上去之后必定会有python的（有必要的组件），在命令行中输入python回车。这样就可以进入一个</p> 
   <blockquote>
    <blockquote>
     <blockquote>
      <p>的提示符<br>2、windows</p>
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>装置好了python之后，在开端菜单里面找到Python2.3-&gt;IDLE，运转也会进入一个有</p> 
   <blockquote>
    <blockquote>
     <blockquote>
      <p>提示符的窗口</p>
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>开端尝试Python<br>1、输入：<br>welcome = "Hello!"<br>回车<br>然后又回到了&gt;&gt;&gt;<br>2、输入：<br>print welcome<br>回车<br>然后就可以看到你自个输入的问候了。</p> 
   <p>Lesson 2 搞定环境之后的前行<br>Python有一个交互式的命令行，咱们现已看到了吧。所以可以比拟便当的学习和尝试，不用“新建－存档－编译－调试”，十分适合疾速的尝试。</p> 
   <p>一开端从变量开端（其实说变量，更准确的是目标，Python中啥都可以理解为目标）。</p> 
   <p>变量<br>welcome = "hello!"<br>welcome即是变量名，字符串即是变量的类型，hello!即是变量的内容，""表明这个变量是字符串，""中心的是字符串的内容。<br>熟悉其他语言的人，特别是编译类型的语言，觉得没有变量的声明很奇怪。在python中用赋值来表明我要这么一个变量，即使你不知道要放啥内容，仅仅要先弄一个当地来放你的东西，也要这么写：<br>store = ""<br>不过这个还是阐明了store是字符串，由于""的缘故。</p> 
   <p>have a try</p> 
   <p>代码: [复制到剪贴板] <br>tmp_storage = ""<br>welcome = "hello!"<br>tmp_storage = welcome<br>print tmp_storage</p> 
   <p>你会发现相同的问候呈现了。</p> 
   <p>字符串<br>字符串是用""标记的，可是用''也可以（不要说你看不出一个是双引号，一个是单引号），两者之间是有一丁点区别，不过你可以不用理会。其实是差不多的。字符串有很多自个的操作，最常用的是这样的：</p> 
   <p>代码: [复制到剪贴板] <br>welcome = "hello"<br>you = "world!"<br>print welcome+you</p> 
   <p>运转之后就会发现她输出了helloworld!。</p> 
   <p>更多变量<br>变量还有几种类型。<br>数<br>字符串<br>列表<br>字典<br>文件<br>勿庸置疑，这些都是十分十分常用的。关于数字就不用讲了那即是：</p> 
   <p>代码: [复制到剪贴板] <br>radius = 10<br>pi = 3.14<br>area = pi<em>radius</em>*2<br>print "the area is", area</p> 
   <p>下次讲列表和字典</p> 
   <p>Lesson 3 Python中的数学结构<br>数学中你学啥东西最多遍？我想根据我的一点浅薄经验（尽管我是数学系的），学得最多的是调集，无论啥数学书都从调集开端讲起。然后讲函数呢，又必然把映射再讲一遍。可以说，调集和映射是数学中最基本的结构了。</p> 
   <p>Python关于数据结构十分明智的内置了两个，回想我写C的程序，往往是一开端即是用struct拼一个链表出来（重复劳动）。Python中提供了列表（list）和字典（dict）两种数据结构。他们别离对应的原型是调集和映射。这个你应该理解了，仅仅表明方法有一点不相同罢了。</p> 
   <p>列表<br>列表的英文名是list嘛，所以我取一个名字叫</p> 
   <p>代码: [复制到剪贴板] <br>my_list = []<br>这个就发生了一个空的列表。然后给它赋值<br>my_list = [1,2]<br>print my_list<br>my_list.append(3)<br>print my_list</p> 
   <p>十分容易理解的。append前面加了一个点，这个表明append是my_list方法。我实在不想又去给你解说啥是目标，啥是成员方法，然后扯出一大段出来。<br>list是可以索引的：<br>print my_list[1]<br>不过你或许会不理解为啥是2，而不是显示的是1。由于索引从0开端，要输出第一个元素：<br>print my_list[0]</p> 
   <p>字典</p> 
   <p>代码: [复制到剪贴板] <br>contact = {}</p> 
   <p>这个发生了一个空字典，contact。然后往里面填充内容：</p> 
   <p>代码: [复制到剪贴板] <br>contact={}<br>contact["name"]="taowen"<br>contact["phone"]=68942443</p> 
   <p>name即是你查字典的时分要查找的单词，taowen即是查到的内容。不过你如今不是查，而是在写这个字典。同理增加了phone这个词条。<br>如今增加好了，看看contact的内容，怎么查看？自个想方法吧。。。<br>若是你悟性够，就会发现python很多操作是通用的，既然可以print 1, print "", print my_list，那么其他数据类型的变量就没有理由不能用了。</p> 
   <p>结合列表和字典</p> 
   <p>代码: [复制到剪贴板] <br>contact_list=[]<br>contact1={}<br>contact1['name']='taowen'<br>contact1['phone']=68942443<br>contact_list.append(contact1)<br>contact2={}<br>contact2['name']='god'<br>contact2['phone']=44448888<br>contact_list.append(contact2)</p> 
   <p>呵呵，够杂乱的吧。你可以想出我为啥要用两个contact字典呢？。。。</p> 
   <p>Lesson 4 用不一样的方法来操作Python<br>到如今为止，咱们用的都是交互式的命令行来操作的，的却是很便当，是吧？不过，杂乱一些的状况就不那么好使了，来换一种方法来操作Python</p> 
   <p>在IDLE中点击File-&gt;New Window，呈现一个新窗口（关于linux下，你要用vim或许emacs或许pico把文本的源文件写好了）。为了便当，先点击File-&gt;Save，填入my_try.py。这样可以让修改器知道在修改python的源文件，会把你输入的代码进行一点上色的处置。</p> 
   <p>填入下面的代码：</p> 
   <p>代码: [复制到剪贴板] <br>i = 5<br>n = 0<br>while i&gt;0:</p> 
   <pre><code>n = n + i
i = i - 1</code></pre> 
   <p>print n</p> 
   <p>你会发现输入:之后，主动会给缩进。并且也没有在python中发现和C/C++中类似的{}标记也没有pascal中的begin end;，其实缩进即是python中表明一段代码的从属联系的标记方法。表明n=n+1和i=i-1这两句都是while的。程序的运转逻辑应该不用解说了吧。即是运转5+4+3+2+1的结果。</p> 
   <p>运转代码<br>按F5，可以提示你没有存盘，照着办即是了。<br>发挥你的能力，计算从1到10的一切偶数的和（提示，可以没有你幻想的那么智能）。</p> 
   <p>Lesson 5 Python中的输入与判断<br>健全的程序大凡都需求输入的功用，所以要学习一下简略的输入：<br>输入要使用的是raw_input或许input函数，区别是raw_input直接把你的输入作为字符串返回，而input则在raw_input的基础上把字符串转换为数字返回（若是你输入$@#$$怎么办？自个试试看）。咱们就利用这两个输入函数来作一些有趣的事情。</p> 
   <p>代码: [复制到剪贴板] <br>your_name = raw_input("please input your name:")<br>hint = "welcome! %s" % your_name<br>print hint</p> 
   <p>不简略吧，还有%呢。%s表明在这个位置刺进一个字符串，%表明把后面提供的参数“推”入前面的字符串中，所以推的结果是把%s推出去了，把your_name给填入那个当地了。printf知道吧，C中的printf即是相同的嘛。</p> 
   <p>代码: [复制到剪贴板] <br>inputed_num = 0<br>while 1:</p> 
   <pre><code>inputed_num = input("input a number between 1 and 10\n")
if inputed_num &gt;= 10:
    pass
elif inputed_num &lt; 1:
    pass
else:
    break</code></pre> 
   <p>print "hehe, don't follow, won't out"</p> 
   <p>pass即是pass了，过了嘛，啥都不干了。break即是跳出这个while 1（无穷循环，1总是真的，while总是执行）。n是换行，不会全部忘光了吧。</p> 
   <p>Lesson 6 Python余兴节目</p> 
   <p>代码: [复制到剪贴板] <br>from Tkinter import *<br>root = Tk()<br>w = Label(root, text="Hello, world!")<br>w.pack()<br>root.mainloop()</p> 
   <p>呵呵，一次太超前了一点，不过也不是解说不清楚。我干脆也不解说了吧。给咱们增进一点爱好。</p> 
   <p>－－－－－－－－－<br>还是解说一下<br>fromt Tkinter import *<br>是引进一个模块，这个模块用来创立GUI（Graphic User Interface）窗口<br>Tk()创立了一个主窗口<br>Label()创立一个标签<br>Label的第一个参数是root表明Label是在这个主窗口中的。<br>w.pack()是指用缺省的方法把Label放置在主窗口中<br>root.mainloop()开端了一个循环，是等待你的输入的循环。</p> 
   <p>Lesson 7 Python基本语法要素齐动员<br>如今的目的是尽量想出一个用的东西仅限于内置的变量类型和句子的一个综合的例子，我想还是那个联系人表的例子吧</p> 
   <p>代码: [复制到剪贴板]</p> 
   <h1>呵呵，还忘记了讲注释</h1> 
   <h1>第一个算是完好的程序</h1> 
   <p>contact = {}<br>contact_list = []<br>while 1:</p> 
   <pre><code>contact['name'] = raw_input("please input name: ")
contact['phone'] = raw_input("please input phone number: ")
contact_list.append(contact.copy())
go_on = raw_input("continue?\n")
if go_on == "yes":
    pass
elif go_on == "no":
    break
else:
    print "you didn't say no\n"</code></pre> 
   <p>i = 1<br>for contact in contact_list:</p> 
   <pre><code>print "%d: name=%s" % (i, contact['name'])
print "%d: phone=%s" % (i, contact['phone'])
i = i + 1
</code></pre> 
   <p>首先是回忆一下字符串<br>字符串既可以用""也可以用''。然后是很有特色的%操作，起到格式化字符串的作用，前面仅仅在字符串中有一个%s，如今有%d和%s两个，别离代表刺进十进制数值和字符串于%x标记的位置处。</p> 
   <p>然后是列表<br>列表是顺序的序列，用append在后面附加，也能构用索引值索引。所以咱们完全可以用一个变量保存len(contact_list)得到的长度，然后一个个的遍历，不过这里展示了另外一种十分便当的方法。并且值得注意的是append()中的参数，我使用了contact.copy()，你可以尝试着把copy()给去掉，观察结果你就知道了所谓的append是怎么干的了，特别是你对指针之类的东西很有感受的话（可是在Python中是没有指针这个概念的）</p> 
   <p>再来看看字典<br>字典是键（key）和值（value）的对应组合成的无序的序列。所以你存的时分要指明键（name或许phone），并且取的时分也是相同的。</p> 
   <p>接下来是判断<br>if是很好用的，==表明判断两个是不是相等，=表明把右边的赋给左边的。并且可以直接判断字符串是不是相等，这个太便当了，若是你曾经用过strcpy()的话，就知道了。elif是表明else if的意思，若是if不满足就判断elif的条件是不是满足，最终是到else中去。</p> 
   <p>循环是个主体<br>while和for都是循环。不过这里while就没啥说的了，又是很经典的while 1，死循环，然后有必要在里面用break来跳出。for和C中的for是不相同的，for in才是一个完好的句子，指的是从一个可以逐一取值的序列中（比方list），一个一个的取出值赋给for后面指定的变量中，直到取空，循环完毕。其实回想通常用C中的for的经历，也大体如此。并且你还可以用for i in range(1,100)来指定一个规模从多少到多少。可以说for in充分体现了python的体贴周到，用起来很直观，不会绕弯。</p> 
   <p>接下来即是运转了，咱们慢慢调试吧。下次可以是讲异常处置，由于我觉得在深化到使用各种高级的要素之前，先要学会怎么去处置异常。最常见的异常应该是input()，然后你给出的输入是一个无法转换为数字的字符串了，那么咱们就要来处置它。</p> 
   <p>Lesson 8 Python中的过错检测<br>写程序啥最重要？完成功用最重要。可是程序中难免要有用户的输入，关于这些写的时分未可预知的因素中心可以呈现的过错，通常称作异常。关于异常状况的处置，不一样语言有不一样的做法，比方检查函数的返回值之类的，可是那种方法会把代码弄成一团浆糊。Python在这个方面是比拟先进的，咱们从一个例子来看看：</p> 
   <p>代码: [复制到剪贴板] <br>print input()</p> 
   <p>呵呵，看不一样吧。其实input是输入，print是输出。也即是把输入的东西立即输出。可是这个和</p> 
   <p>代码: [复制到剪贴板] <br>print raw_input()</p> 
   <p>有啥不一样呢？<br>不一样的当地是，input()会在raw_input()接纳了“字符串”的输入之后进行一些处置，比方你是输入1+2，然后输出的即是3了，而raw_input即是原原本本的1+2的输出了。用代码表明即是</p> 
   <p>代码: [复制到剪贴板] <br>eval(raw_input())</p> 
   <p>eval是求表达式的值，任何一个简略的python表达式，就像1+2这样的作为字符串送入，就能把值从eval处置之后取出来。<br>如今你实验一下"sdfsdf”之后，你会发现提示你</p> 
   <p>引证:<br>Traceback (most recent call last):<br> File "", line 1, in -toplevel-</p> 
   <pre><code>input()</code></pre> 
   <p>File "", line 0, in -toplevel-<br>NameError: name 'sdfsdf' is not defined</p> 
   <p>若是输入其他稀奇古怪的字符串还可以有其他的犯错提示，咱们如今要做的即是捕捉这种由用户输入引起的过错。这么来作：</p> 
   <p>代码: [复制到剪贴板] <br>try:</p> 
   <pre><code>print input()</code></pre> 
   <p>except:</p> 
   <pre><code>print 'there is an error in your input'
</code></pre> 
   <p>这下你无论怎么输入都不会有啥其他的提示了，即是自个设定的print句子作为提示。如今把try except的组合去掉，回到print input()你再尝试一下：<br>1/0<br>这个显然是一个过错，被零除的过错。那么专门来捕捉一下这个过错：</p> 
   <p>代码: [复制到剪贴板] <br>try:</p> 
   <pre><code>print input()</code></pre> 
   <p>except ZeroDivisionError:</p> 
   <pre><code>print 'can not be divided by zero'
</code></pre> 
   <p>这下你可以捕捉到被零除的过错了。然后你再尝试其他的输入，可以过错就没有被捕捉了。所以再补上：</p> 
   <p>代码: [复制到剪贴板] <br>try:</p> 
   <pre><code>print input()</code></pre> 
   <p>except ZeroDivisionError:</p> 
   <pre><code>print 'can not be divided by zero'</code></pre> 
   <p>except:</p> 
   <pre><code>print 'there is an error in your input'
</code></pre> 
   <p>注意，捕捉一切过错的except有必要放在一切的except的最终一位。理解了？OK</p> 
   <p>还有更多的可以捕捉的过错，自个查手册吧（暂时看不了手册没联系，慢慢来嘛）。以后还可以自个raise（引发）异常呢。不过那都是比拟高级的使用了，关于犯错处置从一开端就有这个印象，并牢记在心中关于以后写大一些的软件很有优点。</p> 
   <p>Lesson 9 走向模块化的第一步<br>大规模的程序设计需求你把一个大的程序拆分红n个模块。然后把模块进行组合，交互变成一个完好的程序。你不可以像如今这样，从顶写到尾。。。<br>那么咱们从函数开端。</p> 
   <p>代码: [复制到剪贴板] <br>def square(x):</p> 
   <pre><code>return x**2</code></pre> 
   <p>print square(5)</p> 
   <p>简略吧，这个是我看过的函数定义中最简洁的。def表明这个开端定义一个函数，x是参数，参数是不需求类型的，由于python是不需求明确指出类型的。return是返回值，返回的值刺进到调用函数的当地。再杂乱一些</p> 
   <p>代码: [复制到剪贴板] <br>def multiply(a, b):</p> 
   <pre><code>return a*b</code></pre> 
   <p>print multiply(1,2)</p> 
   <p>这是两个参数的函数。那么返回两个值呢？</p> 
   <p>代码: [复制到剪贴板] <br>def swap(a, b):</p> 
   <pre><code>return (b,a)</code></pre> 
   <p>print swap(1,2)</p> 
   <p>呵呵，其实这里返回的并不是两个值，而是一个值。怎么说呢。(b, a)即是一个东西，是一个元组（turple），你可以用这样的方法成生一个元组，并使用它。元组是基本的变量类型：</p> 
   <p>代码: [复制到剪贴板] <br>my_turple = (1, 2, 3)<br>my_list = []<br>for i in my_turple:</p> 
   <pre><code>my_list.append(i)</code></pre> 
   <p>print my_list</p> 
   <p>其实元组和列表十分像，可是列表的长度是可以变化的，并且成员是可以改动的。可是元组是啥都不能变的，是只读的。</p> 
   <p>关于高级一点的话题：传递进来的参数是不是可以被修改，这个问题取决于你传递了啥近来。若是是数字或许字符串，是不可以改动的，可是若是是这样的：</p> 
   <p>代码: [复制到剪贴板] <br>def test_func(list_be_passed):</p> 
   <pre><code>list_be_passed[0] = 'towin'</code></pre> 
   <p>my_list = ['taowen']<br>print my_list<br>test_func(my_list)<br>print my_list</p> 
   <p>就可以改动传递近来的参数了，所以处置的时分要小心，必要的时分copy一下再传递。</p> 
   <p>函数简略吧，可是很好用的。想起C中的函数那么那么多麻烦，真是感慨万千啊。下面是应该讲GUI编程呢，还是面向目标呢？思考一下</p> 
   <p>Lesson 10 Python的文件操作<br>文件操作....是一个语言和外界联系的主要方法....如今以txt为例简略的讲一下...</p> 
   <p>首先是建立关联...假定在存在以下文件 c:a.txt</p> 
   <p>代码: [复制到剪贴板] <br>This is line #1<br>This is line #2<br>This is line #3<br>END</p> 
   <p>代码: [复制到剪贴板]</p> 
   <blockquote>
    <blockquote>
     <blockquote>
      <p>xxx = file('c:\a.txt', 'r')</p>
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>关键字的第一有些，是文件路径及称号。注意这里面，路径需求用\<br>第二有些，是对文件的模式或许叫权限，通常有以下3种 "r" (read)， "w" (write)和 "a"(append).</p> 
   <p>之后，就可以利用<br>xxx_content = infile.read()<br>xxx_content = infile.readlines()<br>来读取文件内容了</p> 
   <p>代码: [复制到剪贴板]</p> 
   <blockquote>
    <blockquote>
     <blockquote>
      <p>xxx = file('c:\a.txt', 'r')<br>xxx_content = xxx.read()<br>print xxx_content</p>
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>This is line #1<br>This is line #2<br>This is line #3<br>END</p> 
   <blockquote>
    <blockquote>
     <blockquote> 
      <p>xxx.close()</p> 
      <p>infile = file('c:\a.txt', 'r')<br>xxx = file('c:\a.txt', 'r')<br>for xxx_line in xxx.readlines():</p> 
      <pre><code>    print 'Line:', xxx_line
    </code></pre> 
      <p>Line: This is line #1</p> 
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>Line: This is line #2<br>Line: This is line #3<br>Line: END</p> 
   <blockquote>
    <blockquote>
     <blockquote>
      <p>xxx.close()</p>
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>然后是文件的写入</p> 
   <p>代码: [复制到剪贴板]</p> 
   <blockquote>
    <blockquote>
     <blockquote> 
      <p>xxx=file('c:\test.txt','w')<br>xxx.write('billrice')<br>xxx.write('testtest')<br>xxx.write('entern')<br>xxx.writelines(['billrice','ricerice'])<br>xxx.close()</p> 
      <p>xxx=file('c:\test.txt','r')<br>content=xxx.read()<br>print content</p> 
     </blockquote>
    </blockquote>
   </blockquote> 
   <p>billricetesttestenter<br>billricericerice</p> 
   <blockquote>
    <blockquote></blockquote>
   </blockquote> 
   <p>这里需要注意的是...在xxx.close()之前，c盘下面只有一个空空的test.txt，xxx.close()的作用相当于最终的存盘。</p> 
   <p>Lesson 11 走向模块化的第二步<br>函数上面还能是啥呢？内嵌函数^_^，其实python是撑持的。不过用起来会让你吐血的，LGB称号查找规则。。。（寒）。python是面向目标的，关于面向目标的撑持挺好玩的。</p> 
   <p>代码: [复制到剪贴板] <br>class person:</p> 
   <pre><code>def __init__(self):
    self.name = 'taowen'
    self.id = 20022479
def say_id(self):
    print "%s's id is %d" % (self.name, self.id)
</code></pre> 
   <p>me = person()<br>me.say_id()</p> 
   <p>比拟杂乱了吧。若是不熟悉面向目标的概念的，可以会觉得晕。我来解说一下。所谓面向目标是把数据和操作数据的函数放到同一个类中去，然后用类来创立目标，操作的时分可以比拟便当（很不精确的说法，任何一个OO高手都可以把我骂得屁都不是）。</p> 
   <p>类<br>类是class关键来定义的。class person:即是说定义一个类，名字叫person。</p> 
   <p>目标<br>目标是用类来发生的。所以me即是目标，发生的方法即是像调用函数相同，person()，并且()中是可以放参数的，啥时分要参数，看下面的“初始化函数“</p> 
   <p>初始化函数<br>类可以有自个的初始化函数，每次类被创立的时分（调用person()这样的句子的时分），都会调用它。这个在C++中的称号是构造函数。__init__是有必要的名字，你不能用其他名字来当初始化函数。可是你可以没有初始化函数。</p> 
   <p>类的数据<br>类的数据是一切类发生的目标共享的数据。这里没有用到类的数据，要写的话是这样：</p> 
   <p>代码: [复制到剪贴板] <br>class person:</p> 
   <pre><code>school = 'bit'
def __init__(self):
    self.name = 'taowen'
    self.id = 20022479
def say_id(self):
    print "%s's id is %d" % (self.name, self.id)
</code></pre> 
   <p>me = person()<br>me.say_id()<br>print me.school</p> 
   <p>目标的数据<br>目标的数据是用<br>self.变量名 = 。。。<br>来生成的。这里self.name即是目标的数据。目标的数据和类的数据不一样，由于目标之间的数据是互不共享的，而类的数据是被一切由类生成的目标共享的。</p> 
   <p>目标的函数（类的函数）<br>两个没有区别，是类的即是目标的。其实即是类的（我说的是底层完成，不过不用管，若是关心怎么完成的，等我写Hacking OO吧，还没影呢）。say_id即是目标的函数，你可以调用它。每个目标的函数都需求一个self参数，表明[color]这个目标[/color]。</p> 
   <p>为啥使用面向目标编程<br>除去让人觉得你比拟专业外，当然由切实的优点。比拟粗浅的是你可以表达必定的层次联系，类与类之间可以有包含和继承的联系（当然你如今还不会。。。）。并且目标可以把数据和操作数据的函数放在一起，可以比拟清晰。尽管有所谓的数据躲藏的概念，可是在python中其实即是一个不要直接调用目标中的数据的约定，而要用一个函数作为中转。其实不懂面向目标很正常，其实有的时分即是要在用的中心感悟的。啥时分把用函数编程用牛了，用出个道道来了，说不定你现已感受到了啥是面向目标编程。另外：所谓啥OO，都是一些认为规定，不用语法撑持，只要心中有这个想法（啥想法？自个悟啊），就可以写出OO的代码，不管你用的是啥语言，啥语法。</p> 
   <p>Lesson 12 python to exe<br>about py2exe</p> 
   <p>本文讲述如何将一个python源代码编译成一个exe.....我会的仅仅最初步最基本的.....实际上那个py2exe好像有着更强大的功用</p> 
   <p>1：下载装置py2exe.....from <a href="http://bitunion.org" rel="nofollow">http://twh@bitunion.org</a></p> 
   <p>2：假定你写好了一个python程序....guess_number.py.......存在了c:Python23下面</p> 
   <p>3：再写一个setup.py....也存在c:Python23下面......内容如下</p> 
   <p>代码: [复制到剪贴板]</p> 
   <h1>setup.py</h1> 
   <p>from distutils.core import setup<br>import py2exe<br>setup(name="guess_number",</p> 
   <pre><code>  scripts=["guess_number.py"],</code></pre> 
   <p>)</p> 
   <p>其间name和scripts是需求你到时分具体修改的....</p> 
   <p>4：找到windows的dos模式（命令提示符）.....或许自个做个快捷方法也可以....<br>C:Python23&gt;<br>C:Python23&gt;python setup.py py2exe<br>构造就开端了....<br>几秒钟以后....<br>在你的C:Python23就会呈现两个文件夹build和dist，前面那个里面好像是源程序（这个我不太清楚）....dist里面的即是编译好的.exe了.....ok....</p> 
   <p>btw....等国两天有了实际使用再来翻译这些东西</p> 
   <p>Specifying additional files<br>Some applications need additional files at runtime, this maybe configuration files, fonts, bitmaps, whatever.</p> 
   <p>py2exe can copy these files into subdirectories of distmyscript if they are specified in the setup script with the data_files option. data_files should contain a sequence of (target-dir, files) tuples, where files is a sequence of files to be copied.</p> 
   <p>Here's an example:</p> 
   <p>代码: [复制到剪贴板]</p> 
   <h1>setup.py</h1> 
   <p>from distutils.core import setup<br>import glob<br>import py2exe<br>setup(name="myscript",</p> 
   <pre><code>  scripts=["myscript.py"],
  data_files=[("bitmaps",
               ["bm/large.gif", "bm/small.gif"]),
              ("fonts",
               glob.glob("fonts\\*.fnt"))],</code></pre> 
   <p>)</p> 
   <p>This would create a subdirectory bitmaps in distmyscript, containing the two bitmaps, and a subdirectory fonts, containing all the *.fnt files. </p> 
   <p>相关资料出处....<br><a href="http://starship.python.net/crew/theller/py2exe/" rel="nofollow">http://starship.python.net/crew/theller/py2exe/</a></p> 
   <p>Lesson 13 写一个简略的界面很容易<br>图形界面是十分有吸引力的东西。可是制作出来好像不是那么容易，这个观念关于用C来笨拙写windows的窗口程序来说，是比拟正确的。微软公司出品的windows是一个图形界面的操作系统，这个和dos或许linux这些不相同，他们一开端出来是针对字符界面的，然后再在上面加上一些库来提供图形的功用。windows则不一样，它是包含在自个的最原始的功用之中，而这些图形功用的提供是在user32.dll这样的system目录下的dll文件中以函数导出的形式提供的，可是要使用这些东西有必要使用c语言的函数接口，并且编写麻烦。有一个很大的wndproc中要填入一切的事情处置代码，十分丑陋。而作为脚本语言，所应该有的简洁性，python对这个进行了封装。可是事情不是如你所幻想。中心进程十分杂乱，并且python用的也不是自个的库，还是tcl的一个tk的库再封装了一次。尽管通过层层封装，裹得十分严实，可是除了影响其在比拟高性能的图形场合下的使用之外，并没有带来太大的麻烦。你可以用很少的代码，来完成其他语言+库要很大行代码才能表达的图形样式，尽管十分简陋，不过满足使用。并且python除了自个原包装带的这个tkinter库之外，还有其他的第三方的挑选，比拟丰厚，并且也有可以胜任各种使用的挑选。甚至，还有opengl和directx的库的封装库，可以用来编写2d和3d的游戏，这个十分的诱人哦。可是我不会，</p> 
   <p>图形界面的奥妙其实并不深奥。我相信很多人学习windows编程都是从写一个窗口开端的，并且都是从尝试理解那个音讯和事情驱动的模型下手的。大体的进程是这样的，窗口即是用象素画出来的。你可以把一个窗口幻想成一个窗口，也可以把窗口看成一堆象素的调集。就像有人说看女色不过是皮肉色相相同。并且窗口中的按钮，修改矿，各种图标，无论是啥看起来像一个”物体“的东西，其实本质上都是有使用程序或许是库或许是操作系统调用显卡的驱动，通过显卡的功用在屏幕上绘画一些点出来。而所谓的”物体“有很多称法，在windows中通常变成控件（control）。</p> 
   <p>而关于图形界面的操控通常是通过鼠标和键盘来完成的。鼠标在屏幕上有一个自个的形象，那即是一个箭头（当然你也可以调整这个图形为其他好玩的东西，it is your freedom）。而键盘呢则通常表明为一个虚线的框，表明这个是键盘的”焦点“所在的当地。或许是修改框中闪动的竖杠。这两点中有一个共同点，即是都有一个位置来确定要操作的目标。你点下鼠标的时分，你操作的即是鼠标的箭头尖端指向的那个空间，而键盘按下也是在其焦点所在的控件那儿放声。发生的是啥呢？发生的进程从硬件层面到软件层面之后，最终是被操作系统接纳。操作系统可以知道你是点击的是鼠标还是键盘，在啥一个当地点下的，并且按下的是左键还是右键。操作系统还知道当前窗口遍地摆放的位置。综合各路的信息，操作系统就可以知道把这个”事情“作为”音讯“发送给哪个窗口来处置。从中应该可以理解啥叫事情，而音讯呢则是一个C中的结构体，其间有几个field中心放了有关这个事情的信息，然后就像一封信相同从操作系统投递到了窗口所在的使用程序。然后使用程序有一个事先注册的”窗口进程“，其实即是一个函数，用来接纳这封“信”。其实即是接纳到传过来的参数。然后再进行一些判断，作出必定的响应。这个即是所谓的事情驱动。在没有冗长的代码，和展示一切细节的状况下，若是你真的以前对这个进程一无所知，肯定会觉得十分茫然。这个一笔带过的叙述其实仅仅让你有一个感性的认识。其实在python中使用窗口根本不用管诸葛么多。基本上仅仅把自个要的窗口和控件，给一些位置的参数，一些文字的提示内容的参数就能把窗口摆好，显示出来。然后再通过代码告诉python，当“这个按钮按下的时分执行这个函数”，然后就能让窗口有响应。最终记得给一个退出窗口的方法就一切OK了。其间能省的杂乱度基本上都被库给躲藏掉了。付出的代价是慢一些，可是我就不相信你能感受出来，除非你用的电脑连vcd都看不流畅。所以大可放心的享受这种便当。</p> 
   <p>OK，下面来正式的看看怎么在python中创立一个窗口，然后显示出来。</p> 
   <p>代码: [复制到剪贴板] <br>from Tkinter import *<br>root = Tk()<br>root.mainloop()</p> 
   <p>就3行就可以把主窗口显示出来了。root是一个变量称号，其代表了这个主窗口。以后创立控件的时分指定控件创立在啥窗口之中，就要用这个root来表明了。而Tk()是一个Tkinter库之中的函数（其实是类的构造函数，构造了一个目标）。而mainloop则是主窗口的成员函数，也即是表明让这个root工作起来，开端接纳鼠标的和键盘的操作。你如今就可以通过鼠标缩放以及关闭这个窗口了。注意到窗口的标题是tk，咱们可以进行一些修改</p> 
   <p>root= Tk(className='bitunion')</p> 
   <p>然后窗口的标题就变成了bitunion了。下面要作的是把这个窗口的内容填充一下，让其有一些东西。先参加一个标签，所谓标签即是一行字。</p> 
   <p>代码: [复制到剪贴板] <br>from Tkinter import *<br>root = Tk(className='bitunion')<br>label = Label(root)<br>label['text'] = 'be on your own'<br>label.pack()<br>root.mainloop()</p> 
   <p>咱们很惊讶的发现窗口变小了，可是其间多了一行字。变小了是由于窗口中现已放了东西了，python的Tkinter十分智能，可以根据内容主动缩放，而不用和传统的windows程序相同，手工的指定绝对坐标了。关于label，它还是一个变量罢了。不过这个变量代表了一个标签，也即是那一行字。而这个label的创立是用Label，而Label的参数是root表明了这个控件是root主窗口的成员控件，或许说是子窗口。label['text']表明设置这个标签的text属性为'be on your own'，也即是文字内容了。label.pack和root.mainloop相同隐晦，可是内涵相同深刻。你如今可以简略理解为把label显示出来的功用，由于你把pack去掉，那你就看不到东西了。其实pack是和控件的规划排版有关西的。</p> 
   <p>再增加一个按钮就可以有愈加丰厚的内容了，方法是很类似的。看着吧：</p> 
   <p>代码: [复制到剪贴板] <br>from Tkinter import *<br>root = Tk(className='bitunion')<br>label = Label(root)<br>label['text'] = 'be on your own'<br>label.pack()<br>button = Button(root)<br>button['text'] = 'change it'<br>button.pack()<br>root.mainloop()</p> 
   <p>只不过把button替换了label而Button替换了Label。注意一下Button和Label这些都是Tkinter这些库提供的，而button和Button这样大小写之间的不一样仅仅是巧合，你自己可以随便的给变量命名，可是Button和Label这些则是需求记住的东西，写代码的时分要常常用到的名字。可是点击按钮你会比拟失望，由于并没有啥反应。不过也是当然的事情，你并没有告诉计算机关于这样一个按钮的点击操作需求作出一个啥样的反应来反馈给用户。而这个指定作出啥反应的工作只需求一个行，可是作出具体啥样反应的描绘则需求新建一个函数来进行处置。</p> 
   <p>代码: [复制到剪贴板] <br>from Tkinter import *<br>def on_click():</p> 
   <pre><code>label['text'] = 'no way out'</code></pre> 
   <p>root = Tk(className='bitunion')<br>label = Label(root)<br>label['text'] = 'be on your own'<br>label.pack()<br>button = Button(root)<br>button['text'] = 'change it'<br>button['command'] = on_click<br>button.pack()<br>root.mainloop()</p> 
   <p>button['command'] = on_click表明关于button（按钮）的点击属性用on_click这个函数来处置。而on_click函数也很简洁，仅仅把label的文本重新设置一下。这个完成了一个事情音讯的处置，若是用C来写，需求比这个长愈加不好懂的写法。另外你是不是会对on_click中呈现label这个变量比拟奇怪呢？明明在on_click前面没有定义label这个变量啊。若是我在C中这么写程序，编译器必定会告诉我犯错的。而python是怎么知道label这个变量存在，然后没有报错的呢？其实python在你写的时分根本就不用知道其是不是存在，仅仅要在运转的时分找得到label就可以了。而运转的前后联系，是通过时间来关联的而不是代码上前后行的联系。这里由于label = Label(root)先于on_click执行，所以当on_click执行的时分，label即是一个现已定义的变量。若是没有定义呢？那就陈述犯错喽。</p> 
   <p>最终一个例子：</p> 
   <p>代码: [复制到剪贴板] <br>from Tkinter import *<br>def on_click():</p> 
   <pre><code>label['text'] = text.get()</code></pre> 
   <p>root = Tk(className='bitunion')<br>label = Label(root)<br>label['text'] = 'be on your own'<br>label.pack()<br>text = StringVar()<br>text.set('change to what?')<br>entry = Entry(root)<br>entry['textvariable'] = text<br>entry.pack()<br>button = Button(root)<br>button['text'] = 'change it'<br>button['command'] = on_click<br>button.pack()<br>root.mainloop()</p> 
   <p>这个就比拟杂乱了。里面有一个StringVar。这个代表一个字符串，可是跟通常字符串不相同。通常的这样'dfsdf'的字符串是不可变的，你只能把变量指定为不一样的字符串，可是字符串本身的内容是不可改动的。而StringVar则是可变的字符串。所以了set和get来设置和取得其内容。主要是entry（单行输入框）要求一个这样的属性来设置和接纳其输入框的内容。一开端可以不习惯，可是用多了之后会觉得很便当的，由于只要用这个变量text，就能一直得到当前输入框的内容。当你可以完好的把这个例子看懂的时分，你现已入门了。可是离自个写一个有窗口的使用程序还有必定距离。主要是缺少愈加丰厚的控件和事情响应的处置能力，以及合理排版规划的能力。这个下次再说</p> 
   <p>本文转自博客园知识天地的博客，原文链接：<a href="http://www.cnblogs.com/mfryf/archive/2013/06/07/3125270.html" rel="nofollow">Python新手入门教程，从环境准备到掌握基本编程</a> 转载请自行联系原博主。</p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
