<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>软件研发的-设计模式 « NotBeCN</title>
  <meta name="description" content="             1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 什么是设计模式    设计模式是对在软件设计过程中重复出现的问题提出了一种比较好的解决方案。正如一位专家所说：设计模式是对程序设计人员经常遇到的设计问题的可再现的解决方案（The Smal...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/07/weixin_34100227_90133305.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">软件研发的-设计模式</h1>
    <p class="post-meta">Dec 7, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 什么是设计模式<br></p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">设计模式是对在软件设计过程中重复出现的问题提出了一种比较好的解决方案。正如一位专家所说：设计模式是对程序设计人员经常遇到的设计问题的可再现的解决方案（The Smalltalk Companion）。GOF设计模式通常被认为是其他设计模式的基础，随着业务复杂度的增大，会不断涌现新的设计模式，而这些新的设计模式一般会以GOF模式理论为参照。</p> 
   <h1 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么要学习设计模式</h1> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">从个人职业规划来考虑。一位软件开发工程师随着编码量的增加，开发经验的增加，软件理论理解的加深，会不由自主地想一些方法或者捷径，来提高自己的生产率，而不是面对重复的问题做相同的工作，当你有这种想法的时候，就需要开始学习设计模式，设计模式会给你一些比较好的解决方案，不但解决了问题也提升了自己的能力，同时也是迈向软件设计师和架构师的过度阶段。</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">从软件架构的角度来考虑。经济的快速发展造就了业务越来越复杂，那么如何使软件适应这种复杂的业务变化，在软件设计和架构时，适当地使用设计模式可以解决此问题，也要注意不要过度使用设计模式，否则会使系统变的更加复杂。设计模式也是代码重构的依据和工具，建议在代码的重构时，尽量融入设计模式。</p> 
   <h1 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设计模式原则</h1> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">使用设计模式的根本原因是适用变化，提高代码复用率，使软件更具有可维护性和可扩展性。需要遵循以下几个原则：单一职责原色、开放封闭原则(Open Closed Principal)、依赖倒置原则、里氏代换原则。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">3.1单一职责原则</h2> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">就一个类而言，应该只有一个引起他变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会消弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破会。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">3.2开放封闭原则</h2> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 软件实体（类、模块、函数等）应该可以扩展，但不可以修改。也就是说对扩展是开放的，对修改是封闭的。一般来说，面对需求，对程序的改动是通过添加新代码进行的，而不是更改现有代码。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">3.3依赖倒置原则</h2> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 抽象不应该以来细节，细节应该依赖抽象，也就是提倡的“面对接口编程，而不是面对实现编程”。也可以这样理解：高层模块不应该依赖底层模块，两个都应该抽象；抽象不应该依赖细节，细节应该依赖抽象。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">3.4里氏代换原则</h2> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 子类必须能够替换掉他们的父类型。也就是说，在软件开发过程中，子类替换掉父类，程序的功能行为没有变化。只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也可以在父类的基础上增加新的行为。</p> 
   <h1 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设计模式四个基本要素</h1> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">设计模式使人们可以更加简单方便地复用成功的设计和体系结构，将已证实的技术表述成设计模式也会使新加入的系统开发者更加容易理解其设计思路。设计模式的基本要素包括模式名称、问题、解决方案和效果。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">4.1模式名称</h2> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个助记名称，用来描述设计模式、解决方案和效果。设计模式允许在较高的抽象层次上进行设计。基于一个模式词汇表，开发团队之间可以讨论模式并在编写文档时使用它们。模式名称可以帮助我们思考，便于团队成员交流设计思想及设计结果。找到合适的模式名称也是设计模式编目工作的难点之一。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">&nbsp;4.2问题</h2> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">问题主要描述在何时使用设计模式。它解释了设计问题和问题存在的前因后果、特定的设计问题和怎样用对象表示算法等。通常情况下，模式必须满足的一系列先决条件是问题。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">&nbsp;4.3解决方案</h2> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解决方案描述了设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">4.4效果</h2> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">描述了模式应用的效果及使用模式权衡的问题。尽管描述设计决策时，并不是总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及优势具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p> 
   <h1 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设计模式分类</h1> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">设计模式主要分为创建性模式（&nbsp;Creational Patterns）、结构性模式（Structural Patterns）、行为性模式（Behavioral Patterns）。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.1创建性模式（&nbsp;Creational Patterns）</h2> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.1.1&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/06/1640026.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之简单工厂模式(Simple Factory Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">简单工厂模式（Simple Factory Pattern）的优点是，工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.1.2&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/08/1641825.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之抽象工厂模式(Abstract Factory Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或者相互依赖对象的接口，而无需制定他们的具体类。抽象工厂模式的典型应用就是，使用抽象工厂+反射+配置文件实现数据访问层程序</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.1.3&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/13/1646009.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之单例模式( Singleton Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">单例模式（Singleton Pattern）,保证一个类只有一个实例，并提供一个访问它的全局访问点。单例模式因为Singleton封装它的唯一实例，它就可以严格地控制客户怎样访问它以及何时访问它。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.1.4&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/11/1643753.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之建造者模式(Builder Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">建造者模式（Builder Pattern），将一个复杂对象的构建与它的表示分离，使的同样的构建过程可以创建不同的表示。建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.1.5&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/12/1644550.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之原型模式( Prototype Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">原型模式(Prototype Pattern)：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype。</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;"><strong>浅复制与深复制区别：</strong></p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">浅复制，被复制的所有变量都还有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。深复制，把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">Net命名空间System提供了一个IConeable接口，此接口只有一个方法Clone()，只需要实现这个接口就可以实现原型模式（Prototype Pattern）了</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2结构性模式（Structural Patterns）</h2> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.1&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/14/1647864.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之适配器模式（Adapter Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">适配器模式，将一个类装换成客户期望的另外一个接口。Adapter模式统一了不兼容对象的接口，使的原本由于接口不兼容而不能工作的那些类可以一起工作。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.2&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/15/1648280.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之桥接模式( Bridge Pattern)</a> </h3> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">桥接模式（Bridge Pattern），将抽象部分与它的实现部分分离，使的抽象和实现都可以独立地变化。Decouple an abstraction from its implementation so that the two can vary independently.。</p> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;"><strong>什么是聚合</strong><strong>/</strong><strong>组合：</strong></p> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;"><strong>聚合</strong><strong>(Aggregation)</strong>，当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚合关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.3<a href="http://www.cnblogs.com/ywqu/archive/2010/01/18/1650351.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之组合模式（Composite Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。解决整合与部分可以被一致对待问题。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.4&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/19/1651212.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之装饰者模式（Decorator Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">装饰模式，给一个对象动态添加额外职责，这些职责需要由用户决定加入的方式和时机。装饰模式提供了“即插即用”的方式，在运行期间决定何时增加何种功能。就增加功能来说，装饰模式比生成子类更加灵活。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.5&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/20/1652108.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之外观模式（Façade Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">外观模式，为子系统的一组接口提供一个统一的界面，此模式定义了一个高层接口，这一个高层接口使的子系统更加容易使用。外观模式可以解决层结构分离、降低系统耦合度和为新旧系统交互提供接口功能。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.6&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/21/1653087.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之享元模式( Flyweight Pattern)</a> </h3> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">享元模式（Flyweight Pattern）,运用共享技术有效支持大量细粒度的对象。Use sharing to support large numbers of fine-grained objects efficiently. 享元模式可以避免大量非常相似类的开销。在程序设计中有时需要生成大量细粒度的类实例来表示数据。如果发现这些实例除了几个参数外基本伤都是相同的，有时就能够受大幅度第减少需要实例化的类的数量。如果能把这些参数移到类实例外面，在方法调用时将他们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;"><strong>享元对象的内部状态与外部状态：</strong></p> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">内部状态，在享元对象的内部并且不会随环境改变而改变的共享部分。</p> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">外部状态，随环境改变而改变的，不可以共享的状态。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.2.7&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/22/1653875.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之代理模式（Proxy Pattern）</a> </h3> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">代理模式（Proxy Pattern）对其他对象提供一种代理以控制对这个对象的访问。</p> 
   <h2 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3行为性模式（Behavioral Patterns）</h2> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">Net设计模式实例之职责链模式（Chain Of Responsibility）</h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">后期补此节</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.1<a href="http://www.cnblogs.com/ywqu/archive/2010/01/29/1658988.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之命令模式(Command Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">命令模式（Command Pattern）将请求封装为一个对象，从而使你用不同的请求对客户进行参数化，对请求排队或纪录请求日志，以及支持可撤销的操作。当需要有撤销或者恢复操作时，可以考虑使用命令模式.</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.2<a href="http://www.cnblogs.com/ywqu/archive/2010/02/02/1661462.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之解释器模式（Interpreter Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">解释器模式（Interpreter Pattern），给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象的语法树时，可以考虑使用解释器模式。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.3&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/02/08/1665670.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之迭代器模式（Iterator Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">迭代器模式（Iterator Pattern），提供一种方法顺序访问一个聚合对象中元素，而不暴露改集合对象的内部表示。迭代器模式就是分离了集合对想的遍历行为，抽象出一个迭代器类来负责，这样即可以不暴露集合的内部机构，又可让外部代码透明地访问集合内部的数据.</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.4&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/02/09/1666196.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之中介者模式（Mediator Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">中介者模式（Mediator Pattern），定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互。中介者模式一般应用于一组对象以定义良好但是复杂的方法进行通信的场合，以及想定制一个分布在多个类中的行为，而不想生成太多的子类的场合.</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.5&nbsp;<a href="http://www.cnblogs.com/ywqu/archive/2010/01/25/1655581.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之备忘录模式(Memento Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">备忘录模式（Memento Pattern），在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以就该对象恢复到原先保存的状态。</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">当系统功能比较复杂，而且需要记录历史属性以便当需要时做恢复动作。Originator可以根据保存的Memento信息还原到前一状态。</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.6<a href="http://www.cnblogs.com/ywqu/archive/2010/01/05/1639295.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之观察者模式（Observer Pattern）</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化的时，会通知所有观察者对象，使他们能够自动更新自己。解决的是“当一个对象的改变需要同时改变其他对象的时候”问题。最后以股票实例进一步阐述了观察者模式。&nbsp;</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.7<a href="http://www.cnblogs.com/ywqu/archive/2010/01/26/1656418.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之状态模式(State Pattern)</a> </h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">状态模式（State Pattern），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。当一个对象行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了.</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">Net设计模式实例之策略模式（<a href="http://www.dofactory.com/Patterns/PatternStrategy.aspx" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Strategy</a>&nbsp;Pattern）</h3> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">后期补此节</p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.8<a href="http://www.cnblogs.com/ywqu/archive/2010/01/27/1657177.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之模板方法模式(Template Mothed Pattern)</a> </h3> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">模板方法模式(Template Method Pattern),定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可以重定义算法的某些特定步骤。模板方法模式把不变行为搬移到超类，从而去除子类中的重复代码，实际上模板方法模式就是提供了一个代码复用平台。</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要完成在某一细节上层次一致的一个过程或一系列步骤，但个别步骤在更详细的层次上实现不同时，可以使用模版方法模式解决问题。</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;"><strong>&nbsp;</strong></p> 
   <h3 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">5.3.9<a href="http://www.cnblogs.com/ywqu/archive/2010/01/28/1658028.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">Net设计模式实例之访问者模式（Visitor Pattern）</a> </h3> 
   <p align="left" style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">访问者模式表示一个作用于某对象结构中的个元素操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作. 访问者模式的目的是要把处理从数据结构分离出来</p> 
   <h1 style="color:rgb(255,255,255);font-size:17px;line-height:25px;font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(41,129,162) none repeat scroll 0px 0px;">6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设计模式总结</h1> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">Net设计模式系列文章介绍了GOF 23个模式，从模式的设计理念、设计框架、框架的代码介绍了设计模式，并且每个模式配有模式实例，UML设计及其C#代码。使用的设计工具是EA：Enterprise Architect.主要参考的书籍有《Head First 设计模式》《大话设计模式》《Net与设计模式》《C# 3.0 Design Pattern》及其国外一些文章的实例，在此对这些书的作者感谢，在阅读此系列文章之前，建议大家先阅读《<a class="entrylistItemTitle" href="http://www.cnblogs.com/ywqu/archive/2009/12/29/1634804.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">UML建模系列文章总结</a>》</p> 
   <p style="line-height:24px;color:rgb(51,51,51);font-family:'comic sans ms';font-size:15px;">至此，Net设计模式实例系列文章已经写完，由于个人能力有限，不免有些问题阐述的不清楚或者不是非常正确，望高手指点。再此感谢</p> 
   <p style="line-height:24px;"><font color="#333333"><span style="font-size:15px;">本文转自博客园张占岭（仓储大叔）的博客，原文链接：<a href="http://www.cnblogs.com/lori/archive/2010/03/15/1686462.html" rel="nofollow">软件研发的-设计模式</a></span></font><span style="font-size:15px;color:rgb(51,51,51);font-family:'comic sans ms';">，如需转载请自行联系原博主。</span></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
