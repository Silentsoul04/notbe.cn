<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>STL之二分查找 (Binary search in STL) « NotBeCN</title>
  <meta name="description" content="             Section I 正确区分不同的查找算法count,find,binary_search,lower_bound,upper_bound,equal_range&nbsp; 本文是对Effective STL第45条的一个总结，阐述了各种查找算法的异同以及使用他们的时机。    首先可...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/17/weixin_34351321_90135630.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">STL之二分查找 (Binary search in STL)</h1>
    <p class="post-meta">Dec 17, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">Section I<br> 正确区分不同的查找算法count,find,binary_search,lower_bound,upper_bound,equal_range&nbsp;<br> 本文是对Effective STL第45条的一个总结，阐述了各种查找算法的异同以及使用他们的时机。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">首先可供查找的算法大致有count,find,binary_search,lower_bound,upper_bound,equal_range。带有判别式的如count_if,find_if或者binary_search的派别式版本，其用法大致相同，不影响选择，所以不作考虑。<br> 注意这些查找算法需要序列式容器，或者数组。关联容器有相应的同名成员函数except binary_search。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">首先,选择查找算法时，区间是否排序是一个至关重要的因素。<br> 可以按是否需要排序区间分为两组:<br> &nbsp;A. count,find<br> &nbsp;B. binary_search,lower_bound,upper_bound,equal_range<br> A组不需排序区间， B组需要排序区间。<br> 当一个区间被排序，优先选择B组，因为他们提供对数时间的效率。而A则是线性时间。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">另外A组B组所依赖的查找判断法则不同，A使用相等性法则(查找对象需要定义operator==), B使用等价性法则(查找对象需要定义operator&lt;,必须在相等时返回false)。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">A组的区别<br> count:计算对象区间中的数目。<br> find:返回第一个对象的位置。<br> 查找成功的话，find会立即返回，count不会立即返回（直到查找完整个区间），此时find效率较高。<br> 因此除非是要计算对象的数目，否则不考虑count。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">B组的区别 {1，3，4，5，6}<br> binary_search：判断是否存在某个对象<br> lower_bound: 返回&gt;=对象的第一个位置，lower_bound(2)=3, lower_bound(3)=3<br> &nbsp;目标对象存在即为目标对象的位置,不存在则为后一个位置.<br> upper_bound: 返回&gt;对象的第一个位置, upper_bound(2)=3,upper_bound(3)=4<br> &nbsp;无论是否存在都为后一个位置.<br> equal_bound: 返回由lower_bound和upper_bound返回值构成的pair,也就是所有等价元素区间。<br> equal_bound有两个需要注意的地方:<br> &nbsp;1. 如果返回的两个迭代器相同，说明查找区间为空，没有这样的值<br> &nbsp;2. 返回迭代器间的距离与迭代器中对象数目是相等的，对于排序区间，他完成了count和find的双重任务</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">Section II binary search in STL&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">如果在C++ STL容器中包含了有序的序列，STL提供了四个函数进行搜索，他们是利用二分查找实现的(Binary search).<br> 其中：<br> 假定相同值的元素可能有多个<br> lower_bound 返回第一个符合条件的元素位置<br> upper_bound 返回最后一个符合条件的元素位置<br> equal_range 返回所有等于指定值的头/尾元素的位置，其实就是lower_bound和upper_bound<br> binary_search 返回是否有需要查找的元素。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">Section II Effect STL #45</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">条款45：注意count、find、binary_search、lower_bound、upper_bound和equal_range的区别</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">你要寻找什么，而且你有一个容器或者你有一个由迭代器划分出来的区间——你要找的东西就在里面。你要怎么完成搜索呢？你箭袋中的箭有这些：count、count_if、find、find_if、binary_search、lower_bound、upper_bound和equal_range。面对着它们，你要怎么做出选择？</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">简单。你寻找的是能又快又简单的东西。越快越简单的越好。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">暂时，我假设你有一对指定了搜索区间的迭代器。然后，我会考虑到你有的是一个容器而不是一个区间的情况。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">要选择搜索策略，必须依赖于你的迭代器是否定义了一个有序区间。如果是，你就可以通过binary_search、lower_bound、upper_bound和equal_range来加速（通常是对数时间——参见条款34）搜索。如果迭代器并没有划分一个有序区间，你就只能用线性时间的算法count、count_if、find和find_if。在下文中，我会忽略掉count和find是否有_if的不同，就像我会忽略掉binary_search、lower_bound、upper_bound和equal_range是否带有判断式的不同。你是依赖默认的搜索谓词还是指定一个自己的，对选择搜索算法的考虑是一样的。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">如果你有一个无序区间，你的选择是count或着find。它们分别可以回答略微不同的问题，所以值得仔细去区分它们。count回答的问题是：“是否存在这个值，如果有，那么存在几份拷贝？”而find回答的问题是：“是否存在，如果有，那么它在哪儿？”</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">假设你想知道的东西是，是否有一个特定的Widget值w在list中。如果用count，代码看起来像这样：<br></span></p> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <div> 
     <img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">
     <span>list</span>
     <span>&lt;</span>
     <span>Widget</span>
     <span>&gt;</span>
     <span>&nbsp;lw;&nbsp;&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;Widget的list</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>Widget&nbsp;w;&nbsp;&nbsp;&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;特定的Widget值</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>...<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span>
     <span>if</span>
     <span>&nbsp;(count(lw.begin(),&nbsp;lw.end(),&nbsp;w))&nbsp;</span>
     <span><span>{<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;...&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;w在lw中</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span>
     <span>&nbsp;</span>
     <span>else</span>
     <span>&nbsp;</span>
     <span><span>{<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;...&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;不在</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span> 
    </div> 
   </div> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这里示范了一种惯用法：把count用来作为是否存在的检查。count返回零或者一个正数，所以我们把非零转化为true而把零转化为false。如果这样能使我们要做的更加显而易见：<br> if (count(lw.begin(), lw.end(), w) != 0) ...</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">而且有些程序员这样写，但是使用隐式转换则更常见，就像最初的例子。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">和最初的代码比较，使用find略微更难懂些，因为你必须检查find的返回值和list的end迭代器是否相等：<br> if (find(lw.begin(), lw.end(), w) != lw.end()) {<br> &nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;// 找到了<br> } else {<br> &nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;// 没找到<br> }</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">如果是为了检查是否存在，count这个惯用法编码起来比较简单。但是，当搜索成功时，它的效率比较低，因为当找到匹配的值后find就停止了，而count必须继续搜索，直到区间的结尾以寻找其他匹配的值。对大多数程序员来说，find在效率上的优势足以证明略微增加复杂度是合适的。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">通常，只知道区间内是否有某个值是不够的。取而代之的是，你想获得区间中的第一个等于该值的对象。比如，你可能想打印出这个对象，你可能想在它前面插入什么，或者你可能想要删除它（但当迭代时删除的引导参见条款9）。当你需要知道的不止是某个值是否存在，而且要知道哪个对象（或哪些对象）拥有该值，你就得用find：<br> list&lt;Widget&gt;::iterator i = find(lw.begin(), lw.end(), w);<br> if (i != lw.end()) {<br> &nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;// 找到了，i指向第一个<br> } else {<br> &nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;// 没有找到<br> }</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">对于有序区间，你有其他的选择，而且你应该明确的使用它们。count和find是线性时间的，但有序区间的搜索算法（binary_search、lower_bound、upper_bound和equal_range）是对数时间的。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">从无序区间迁移到有序区间导致了另一个迁移：从使用相等来判断两个值是否相同到使用等价来判断。条款19由一个详细地讲述了相等和等价的区别，所以我在这里不会重复。取而代之的是，我会简单地说明count和find算法都用相等来搜索，而binary_search、lower_bound、upper_bound和equal_range则用等价。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">要测试在有序区间中是否存在一个值，使用binary_search。不像标准C库中的（因此也是标准C++库中的）bsearch，binary_search只返回一个bool：这个值是否找到了。binary_search回答这个问题：“它在吗？”它的回答只能是是或者否。如果你需要比这样更多的信息，你需要一个不同的算法。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这里有一个binary_search应用于有序vector的例子（你可以从条款23中知道有序vector的优点）：<br></span></p> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <div> 
     <img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">
     <span>vector</span>
     <span>&lt;</span>
     <span>Widget</span>
     <span>&gt;</span>
     <span>&nbsp;vw;&nbsp;&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;建立vector，放入</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>...&nbsp;&nbsp;&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;数据，</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>sort(vw.begin(),&nbsp;vw.end());&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;把数据排序</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>Widget&nbsp;w;&nbsp;&nbsp;&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;要找的值</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>...<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span>
     <span>if</span>
     <span>&nbsp;(binary_search(vw.begin(),&nbsp;vw.end(),&nbsp;w))&nbsp;</span>
     <span><span>{<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;...&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;w在vw中</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span>
     <span>&nbsp;</span>
     <span>else</span>
     <span>&nbsp;</span>
     <span><span>{<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;...&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;不在</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span> 
    </div> 
   </div> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">如果你有一个有序区间而且你的问题是：“它在吗，如果是，那么在哪儿？”你就需要equal_range，但你可能想要用lower_bound。我会很快讨论equal_range，但首先，让我们看看怎么用lower_bound来在区间中定位某个值。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">当你用lower_bound来寻找一个值的时候，它返回一个迭代器，这个迭代器指向这个值的第一个拷贝（如果找到的话）或者到可以插入这个值的位置（如果没找到）。因此lower_bound回答这个问题：“它在吗？如果是，第一个拷贝在哪里？如果不是，它将在哪里？”和find一样，你必须测试lower_bound的结果，来看看它是否指向你要寻找的值。但又不像find，你不能只是检测lower_bound的返回值是否等于end迭代器。取而代之的是，你必须检测lower_bound所标示出的对象是不是你需要的值。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">很多程序员这么用lower_bound：<br></span></p> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <div> 
     <img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">
     <span>vector</span>
     <span>&lt;</span>
     <span>Widget</span>
     <span>&gt;</span>
     <span>::iterator&nbsp;i&nbsp;</span>
     <span>=</span>
     <span>&nbsp;lower_bound(vw.begin(),&nbsp;vw.end(),&nbsp;w);<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span>
     <span>if</span>
     <span>&nbsp;(i&nbsp;</span>
     <span>!=</span>
     <span>&nbsp;vw.end()&nbsp;</span>
     <span>&amp;&amp;</span>
     <span>&nbsp;</span>
     <span>*</span>
     <span>i&nbsp;</span>
     <span>==</span>
     <span>&nbsp;w)&nbsp;</span>
     <span><span>{&nbsp;</span><span>//</span><span>&nbsp;保证i指向一个对象；<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;也就保证了这个对象有正确的值。<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;这是个bug！&nbsp;</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;"></span><span>&nbsp;...&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;找到这个值，i指向<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;第一个等于该值的对象</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span>
     <span>&nbsp;</span>
     <span>else</span>
     <span>&nbsp;</span>
     <span><span>{<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;...&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;没找到</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span> 
    </div> 
   </div> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">大部分情况下这是行得通的，但不是真的完全正确。再看一遍检测需要的值是否找到的代码：<br> if (i != vw.end() &amp;&amp; *i == w) ...</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这是一个相等的测试，但lower_bound搜索用的是等价。大部分情况下，等价测试和相等测试产生的结果相同，但就像条款19论证的，相等和等价的结果不同的情况并不难见到。在这种情况下，上面的代码就是错的。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">要完全完成，你就必须检测lower_bound返回的迭代器指向的对象的值是否和你要寻找的值等价。你可以手动完成（条款19演示了你该怎么做，当它值得一做时条款24提供了一个例子），但可以更狡猾地完成，因为你必须确认使用了和lower_bound使用的相同的比较函数。一般而言，那可以是一个任意的函数（或函数对象）。如果你传递一个比较函数给lower_bound，你必须确认和你的手写的等价检测代码使用了相同的比较函数。这意味着如果你改变了你传递给lower_bound的比较函数，你也得对你的等价检测部分作出修改。保持比较函数同步不是火箭发射，但却是另一个要记住的东西，而且我想你已经有很多需要你记的东西了。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这儿有一个简单的方法：使用equal_range。equal_range返回一对迭代器，第一个等于lower_bound返回的迭代器，第二个等于upper_bound返回的（也就是，等价于要搜索值区间的末迭代器的下一个）。因此，equal_range，返回了一对划分出了和你要搜索的值等价的区间的迭代器。一个名字很好的算法，不是吗？（当然，也许叫equivalent_range会更好，但叫equal_range也非常好。）</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">对于equal_range的返回值，有两个重要的地方。第一，如果这两个迭代器相同，就意味着对象的区间是空的；这个只没有找到。这个结果是用equal_range来回答“它在吗？”这个问题的答案。你可以这么用：<br></span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <div> 
     <img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">
     <span>vector</span>
     <span>&lt;</span>
     <span>Widget</span>
     <span>&gt;</span>
     <span>&nbsp;vw;<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">...<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">sort(vw.begin(),&nbsp;vw.end());<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">typedef&nbsp;vector</span>
     <span>&lt;</span>
     <span>Widget</span>
     <span>&gt;</span>
     <span>::iterator&nbsp;VWIter;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;方便的typedef</span>
     <span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span>
     <span>typedef&nbsp;pair</span>
     <span>&lt;</span>
     <span>VWIter,&nbsp;VWIter</span>
     <span>&gt;</span>
     <span>&nbsp;VWIterPair;<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;">VWIterPair&nbsp;p&nbsp;</span>
     <span>=</span>
     <span>&nbsp;equal_range(vw.begin(),&nbsp;vw.end(),&nbsp;w);<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span>
     <span>if</span>
     <span>&nbsp;(p.first&nbsp;</span>
     <span>!=</span>
     <span>&nbsp;p.second)&nbsp;</span>
     <span><span>{&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;如果equal_range不返回<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;空的区间...</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;"></span><span>&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;说明找到了，p.first指向<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;第一个而p.second<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;指向最后一个的下一个</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockStart.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span>
     <span>&nbsp;</span>
     <span>else</span>
     <span>&nbsp;</span>
     <span><span>{<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;没找到，p.first和<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/InBlock.gif" alt="" align="top" style="border:0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>//</span><span>&nbsp;p.second都指向搜索值</span><span><br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/ExpandedBlockEnd.gif" alt="" align="top" style="border:0px;"></span><span>}</span></span>
     <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
     <span>//</span>
     <span>&nbsp;的插入位置<br><img src="http://images.csdn.net/syntaxhighlighting/OutliningIndicators/None.gif" alt="" align="top" style="border:0px;"></span> 
    </div> 
   </div> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这段代码只用等价，所以总是正确的。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">第二个要注意的是equal_range返回的东西是两个迭代器，对它们作distance就等于区间中对象的数目，也就是，等价于要寻找的值的对象。结果，equal_range不光完成了搜索有序区间的任务，而且完成了计数。比如说，要在vw中找到等价于w的Widget，然后打印出来有多少这样的Widget存在，你可以这么做：<br> VWIterPair p = equal_range(vw.begin(), vw.end(), w);<br> cout &lt;&lt; "There are " &lt;&lt; distance(p.first, p.second)<br> &nbsp;&nbsp;&lt;&lt; " elements in vw equivalent to w.";</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">到目前为止，我们所讨论的都是假设我们要在一个区间内搜索一个值，但是有时候我们更感兴趣于在区间中寻找一个位置。比如，假设我们有一个Timestamp类和一个Timestamp的vector，它按照老的timestamp放在前面的方法排序：<br> class Timestamp { ... };<br> bool operator&lt;(const Timestamp&amp; lhs,&nbsp;&nbsp;// 返回在时间上lhs<br> &nbsp;const Timestamp&amp; rhs);&nbsp;&nbsp;// 是否在rhs前面<br> vector&lt;Timestamp&gt; vt;&nbsp;&nbsp;&nbsp;// 建立vector，填充数据，<br> ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 排序，使老的时间<br> sort(vt.begin(), vt.end());&nbsp;&nbsp;&nbsp;// 在新的前面</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">现在假设我们有一个特殊的timestamp——ageLimit，而且我们从vt中删除所有比ageLimit老的timestamp。在这种情况下，我们不需要在vt中搜索和ageLimit等价的Timestamp，因为可能不存在任何等价于这个精确值的元素。 取而代之的是，我们需要在vt中找到一个位置：第一个不比ageLimit更老的元素。这是再简单不过的了，因为lower_bound会给我们答案的：<br> Timestamp ageLimit;<br> ...<br> vt.erase(vt.begin(), lower_bound(vt.begin(),&nbsp;// 从vt中排除所有<br> &nbsp;vt.end(),&nbsp;&nbsp;&nbsp;&nbsp;// 排在ageLimit的值<br> &nbsp;ageLimit));&nbsp;&nbsp;&nbsp;// 前面的对象</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">如果我们的需求稍微改变了一点，我们要排除所有至少和ageLimit一样老的timestamp，也就是我们需要找到第一个比ageLimit年轻的timestamp的位置。这是一个为upper_bound特制的任务：<br> vt.erase(vt.begin(), upper_bound(vt.begin(),&nbsp;// 从vt中除去所有<br> &nbsp;vt.end(),&nbsp;&nbsp;&nbsp;&nbsp;// 排在ageLimit的值前面<br> &nbsp;ageLimit));&nbsp;&nbsp;&nbsp;// 或者等价的对象</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">如果你要把东西插入一个有序区间，而且对象的插入位置是在有序的等价关系下它应该在的地方时，upper_bound也很有用。比如，你可能有一个有序的Person对象的list，对象按照name排序：<br> class Person {<br> public:<br> &nbsp;...<br> &nbsp;const string&amp; name() const;<br> &nbsp;...<br> };</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">struct PersonNameLess:<br> public binary_function&lt;Person, Person, bool&gt; {&nbsp;// 参见条款40<br> &nbsp;bool operator()(const Person&amp; lhs, const Person&amp; rhs) const<br> &nbsp;{<br> &nbsp;&nbsp;return lhs.name() &lt; rhs.name();<br> &nbsp;}<br> };</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">list&lt;Person&gt; lp;<br> ...<br> lp.sort(PersonNameLess());&nbsp;&nbsp;&nbsp;// 使用PersonNameLess排序lp</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">要保持list仍然是我们希望的顺序（按照name，插入后等价的名字仍然按顺序排列），我们可以用upper_bound来指定插入位置：<br> Person newPerson;<br> ...<br> lp.insert(upper_bound(lp.begin(),&nbsp;&nbsp;// 在lp中排在newPerson<br> &nbsp;lp.end(),&nbsp;&nbsp;&nbsp;&nbsp;// 之前或者等价<br> &nbsp;newPerson,&nbsp;&nbsp;&nbsp;// 的最后一个<br> &nbsp;PersonNameLess()),&nbsp;&nbsp;&nbsp;// 对象后面<br> &nbsp;newPerson);&nbsp;&nbsp;&nbsp;// 插入newPerson</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这工作的很好而且很方便，但很重要的是不要被误导——错误地认为upper_bound的这种用法让我们魔术般地在一个list里在对数时间内找到了插入位置。我们并没有——条款34解释了因为我们用了list，查找花费线性时间，但是它只用了对数次的比较。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">一直到这里，我都只考虑我们有一对定义了搜索区间的迭代器的情况。通常我们有一个容器，而不是一个区间。在这种情况下，我们必须区别序列和关联容器。对于标准的序列容器（vector、string、deque和list），你应该遵循我在本条款提出的建议，使用容器的begin和end迭代器来划分出区间。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">这种情况对标准关联容器（set、multiset、map和multimap）来说是不同的，因为它们提供了搜索的成员函数，它们往往是比用STL算法更好的选择。条款44详细说明了为什么它们是更好的选择，简要地说，是因为它们更快行为更自然。幸运的是，成员函数通常和相应的算法有同样的名字，所以前面的讨论推荐你使用的算法count、find、equal_range、lower_bound或upper_bound，在搜索关联容器时你都可以简单的用同名的成员函数来代替。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">调用binary_search的策略不同，因为这个算法没有提供对应的成员函数。要测试在set或map中是否存在某个值，使用count的惯用方法来对成员进行检测：<br> set&lt;Widget&gt; s;&nbsp;&nbsp;// 建立set，放入数据&nbsp;<br> ...<br> Widget w;&nbsp;&nbsp;&nbsp;// w仍然是保存要搜索的值<br> ...<br> if (s.count(w)) {<br> &nbsp;...&nbsp;&nbsp;// 存在和w等价的值<br> } else {<br> &nbsp;...&nbsp;&nbsp;// 不存在这样的值<br> }</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">要测试某个值在multiset或multimap中是否存在，find往往比count好，因为一旦找到等于期望值的单个对象，find就可以停下了，而count，在最遭的情况下，必须检测容器里的每一个对象。（对于set和map，这不是问题，因为set不允许重复的值，而map不允许重复的键。）</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">但是，count给关联容器计数是可靠的。特别，它比调用equal_range然后应用distance到结果迭代器更好。首先，它更清晰：count 意味着“计数”。第二，它更简单；不用建立一对迭代器然后把它的组成（译注：就是first和second）传给distance。第三，它可能更快一点。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">要给出所有我们在本条款中所考虑到的，我们的从哪儿着手？下面的表格道出了一切。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;width:587px;">
    <tbody>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">你想知道的&nbsp;</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">在无序区间</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">在有序区间&nbsp;</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">在set或map上</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">在multiset或multimap上</span></td> 
     </tr>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">期望值是否存在？</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">binary_search&nbsp;</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">count</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find</span></td> 
     </tr>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">期望值是否存在？如果有，第一个等于这个值的对象在哪里？</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find&nbsp;</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">equal_range&nbsp;</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find&nbsp;</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find或lower_bound（参见下面）</span></td> 
     </tr>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">第一个不在期望值之前的对象在哪里？</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find_if</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">lower_bound</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">lower_bound</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">lower_bound</span></td> 
     </tr>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">第一个在期望值之后的对象在哪里？</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find_if</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">upper_bound</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">upper_bound</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">upper_bound</span></td> 
     </tr>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">有多少对象等于期望值？</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">count</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">equal_range，然后distance</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">count</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">count</span></td> 
     </tr>
     <tr>
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">等于期望值的所有对象在哪里？</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">find（迭代）</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">equal_range</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">equal_range</span></td> 
      <td style="font-family:Verdana, Helvetica, Arial;line-height:1.5;font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="font-family:Verdana;font-size:small;">equal_range</span></td> 
     </tr>
    </tbody>
   </table>
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;<br></span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">&nbsp;</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">上表总结了要怎么操作有序区间，equal_range的出现频率可能令人吃惊。当搜索时，这个频率因为等价检测的重要性而上升了。对于lower_bound和upper_bound，它很容易在相等检测中退却，但对于equal_range，只检测等价是很自然的。在第二行有序区间，equal_range打败了find还因为一个理由：equal_range花费对数时间，而find花费线性时间。</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">对于multiset和multimap，当你在搜索第一个等于特定值的对象的那一行，这个表列出了find和lower_bound两个算法作为候选。 已对于这个任务find是通常的选择，而且你可能已经注意到在set和map那一列里，这项只有find。但是对于multi容器，如果不只有一个值存在，find并不保证能识别出容器里的等于给定值的第一个元素；它只识别这些元素中的一个。如果你真的需要找到等于给定值的第一个元素，你应该使用lower_bound，而且你必须手动的对第二部分做等价检测，条款19的内容可以帮你确认你已经找到了你要找的值。（你可以用equal_range来避免作手动等价检测，但是调用equal_range的花费比调用lower_bound多得多。）</span></p> 
   <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><span style="font-family:Verdana;font-size:small;">在count、find、binary_search、lower_bound、upper_bound和equal_range中做出选择很简单。当你调用时，选择算法还是成员函数可以给你需要的行为和性能，而且是最少的工作。按照这个建议做（或参考那个表格），你就不会再有困惑。</span></p> 
   <p><span><font color="#4b4b4b">本文转自博客园知识天地的博客，原文链接：<a href="http://www.cnblogs.com/mfryf/archive/2012/09/05/2672700.html" rel="nofollow">STL之二分查找 (Binary search in STL)</a>，如需转载请自行联系原博主。</font><br></span></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
