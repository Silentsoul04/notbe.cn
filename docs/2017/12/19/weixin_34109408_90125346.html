<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Net中的AOP系列之《单元测试切面》 « NotBeCN</title>
  <meta name="description" content="                 返回《.Net中的AOP》系列学习总目录                      本篇目录           使用NUnit编写测试           编写和运行NUnit测试           切面的测试策略           Castle DynamicProxy测...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/19/weixin_34109408_90125346.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Net中的AOP系列之《单元测试切面》</h1>
    <p class="post-meta">Dec 19, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div>
    返回《.Net中的AOP》系列学习总目录
   </div> 
   <div>
    <br>
   </div> 
   <div>
    本篇目录
   </div> 
   <div>
    使用NUnit编写测试
   </div> 
   <div>
    编写和运行NUnit测试
   </div> 
   <div>
    切面的测试策略
   </div> 
   <div>
    Castle DynamicProxy测试
   </div> 
   <div>
    测试一个拦截器
   </div> 
   <div>
    注入依赖
   </div> 
   <div>
    PostSharp测试
   </div> 
   <div>
    对PostSharp切面进行单元测试
   </div> 
   <div>
    注入依赖
   </div> 
   <div>
    PostSharp和测试的问题
   </div> 
   <div>
    小结
   </div> 
   <div> 
    <div>
     本节的源码本人已托管于Coding上：点击查看。
    </div> 
    <div>
     <br>
    </div> 
    <div>
     本系列的实验环境：VS 2013 Update 5（建议最好使用集成了Nuget的VS版本，VS Express版也够用）。
     <span style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这节我们说说AOP中的单元测试。单元测试对于保障一款产品的质量还是很重要的，当你写了一个开源的东西，最好要对它进行单元测试通过后再分享，不然别人如何知道你的东西最后会不会出问题；楼主现在从事的一家互联网金融公司也是需要做单元测试的，而且还做了自动化测试（楼主目前主导从事AT这块，以后会分享关于AT的文章），毕竟这都是和大笔资金有关的，不确保产品的质量就上线是不行的，不做测试有时上线产品也是没有自信的，谁也无法确保自己写的代码不出bug,而单元测试和自动化测试都通过后，就会信心十足，虽然还是会出bug。如果你们做的是TDD（测试驱动开发），毫无疑问要写单元测试，这样才能驱动编码的设计和架构。好了，关于测试的话题，以后有机会分享，现在切入今天的正题当使用了AOP后，如何进行单元测试？</span> 
    </div> 
    <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="nunit"></a>使用NUnit编写测试</h2> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果你写过单元测试（UT），那么这篇博客说的东西你应该很熟悉。这儿使用一个.Net单元测试常见的工具<strong>NUnit</strong>来复习一下单元测试。如果你更喜欢其它的测试工具或框架也是没问题的，仍然可以继续阅读，重要的是思想。</p> 
    <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
     <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">NUnit</h4> 
     <p>NUit是免费开源的，而且具有良好的文档说明，因而收到很多人喜爱。除了NUnit之外，其它的测试框架如MSTest，MSpec，xUnit.net 等都是一些好的测试框架。因此，你喜欢哪个或者使用哪个更顺手就选择哪个吧。</p> 
    </blockquote> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果你还没有编写UT的习惯，或者从来都没谢过UT，建议你最好尽快学会这门技术，迟早派的上用场的。UT是一个大的话题，因此一篇博客不可能全部覆盖到，因此，建议之后自己阅读一下测试的书籍。</p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="run" style="color:rgb(224,130,131);"></a>编写和运行NUnit测试</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">首先创建一个<strong>类库项目</strong>，取名&nbsp;<strong>UnitTestDemo</strong>，之后创建一个string的扩展类MyStringExtension,具体代码如下：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyStringExtension</span>
{
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> 创建一个反转字符串的方法，比如 输入hello，返回olleh</span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;/summary&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;param name="str"&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/param&gt;</span></span>
    <span class="hljs-comment" style="color:#008000;"><span class="hljs-doctag" style="color:#808080;">///</span> <span class="hljs-doctag" style="color:#808080;">&lt;returns&gt;</span><span class="hljs-doctag" style="color:#808080;">&lt;/returns&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> str</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> str;<span class="hljs-comment" style="color:#008000;">//现在暂时直接返回，为了看看测试的效果</span>
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在应该准备测试的工具了，使用Nuget安装<strong>NUnit</strong>:<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PM&gt; Install-Package NUnit</code>。安装之后，第一步是写一个Test Fixture（测试装备），它是一个包含了Test的类（可能也包含setup/teardown代码）。使用NUnit编写Test Fixture很简单，只需要在一个类上使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">TestFixture</code>特性就可以了：</p> 
    <pre class="c#"><code class="hljs swift" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[<span class="hljs-type" style="color:rgb(163,21,21);">TestFixture</span>]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyStringExtensionTest</span> </span>{
}
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在这个Test Fixture里面，写一个简单的测试验证一下<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Reverse</code>方法是否和自己预想的一样。测试一般遵循3A模式，即<strong>Arrange(准备阶段)</strong>，&nbsp;<strong>Act(执行阶段)</strong>，&nbsp;<strong>Assert（断言阶段）</strong>。</p> 
    <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
     <li style="list-style:decimal;">Arrange：创建一个被测类的新实例；</li> 
     <li style="list-style:decimal;">Act：给Reverse方法传入一个字符串并获得返回结果；</li> 
     <li style="list-style:decimal;">Assert：检查字符串是否按预期的那样反转了。</li> 
    </ol>
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">按照3A模式，写出的代码如下：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestFixture]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyStringExtensionTest</span>
{
    [Test]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse_Test</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myStrObj=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyStringExtension();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> reversedStr = myStrObj.Reverse(<span class="hljs-string" style="color:rgb(163,21,21);">"hello"</span>);
        Assert.That(reversedStr,Is.EqualTo(<span class="hljs-string" style="color:rgb(163,21,21);">"olleh"</span>));<span class="hljs-comment" style="color:#008000;">//断言语法根据使用的工具和爱好不同可以有很多写法</span>
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">因为我们还没有正确实现Reverse方法，所以测试应该是失败的。如果你已经安装了Resharp或者TestDriven.net，那么可以使用这些工具运行测试，楼主已经安装了Resharp，所以可以直接运行测试。当然你可以安装NUnit的一些测试工具。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902100823918-1289606889.png" style="border:0px;" alt="577014-20160902100823918-1289606889.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">测试失败的截图如下：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160831002030136-1785873365.png" style="border:0px;" alt="577014-20160831002030136-1785873365.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">正确实现Reverse方法：</p> 
    <pre class="c#"><code class="hljs cpp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-built_in" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse</span><span class="hljs-params">(<span class="hljs-built_in" style="color:rgb(0,0,255);">string</span> str)</span> </span>{
    <span class="hljs-comment" style="color:#008000;">//return str;//现在暂时直接返回，为了看看测试的效果</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-built_in" style="color:rgb(0,0,255);">string</span>(str.Reverse().ToArray());
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">通过的单元测试截图如下：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160831003927808-1899133368.png" style="border:0px;" alt="577014-20160831003927808-1899133368.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这时你就开始考虑更多的情况了，比如，如果传入的是null，就返回null，因为Reverse方法没有对null做检查，因此会抛出<strong>NullReferenceException</strong>，因此我们先写测试用例：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
[Test]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">ReverseWithNull_Test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myStrObj=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyStringExtension();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> reversedStr = myStrObj.Reverse(<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>);
    Assert.IsNull(reversedStr);
}
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">测试结果失败：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902104027902-1991855919.png" style="border:0px;" alt="577014-20160902104027902-1991855919.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在Reverse方法中加入null判断：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> str</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.IsNullOrEmpty(str))
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>;
    }
    <span class="hljs-comment" style="color:#008000;">//return str;//现在暂时直接返回，为了看看测试的效果</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>(str.Reverse().ToArray());
}
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">再次执行测试用例，通过：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902104257652-1020950301.png" style="border:0px;" alt="577014-20160902104257652-1020950301.png"></p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="strategy" style="color:rgb(224,130,131);"></a>切面的测试策略</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">谈到测试切面时，一般要测两个东西：一是切面是否用在了正确的地方（测试切入点），二是切面是否完成了预期的事情（测试通知）。.Net中的AOP工具通常通过特性使用切面，我们在PostSharp和MVC ActionFilter中看到过了。要测试特性是否用在了正确的地方，只需要测试特性是否用在了我们期望的类和方法上即可。<br> 回忆一下，当在VS中创建了一个 ASP.NET MVC 项目时，会自动创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">AccountController</code>,该控制器中的一些方法使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ValidateAntiForgeryToken</code>特性（这就是一个ActionFilter）。创建项目时，同时勾选创建单元测试项目复选框时，也会为我们创建一个单元测试的项目，默认使用的微软VS自带的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Microsoft.VisualStudio.QualityTools.UnitTestFramework</code>测试框架。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902171103043-497639444.png" style="border:0px;" alt="577014-20160902171103043-497639444.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">默认在测试项目中帮我们生成了一个测试Home控制器的类：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902171453871-1593155750.png" style="border:0px;" alt="577014-20160902171453871-1593155750.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">假如我们要测试一下那些特性是否处于正确的地方，比如测试一下使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ValidateAntiForgeryToken</code>特性的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LogOff</code>方法：</p> 
    <pre class="c#"><code class="hljs cpp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"> <span class="hljs-comment" style="color:#008000;">// POST: /Account/LogOff</span>
 [HttpPost]
 [ValidateAntiForgeryToken]
 <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> ActionResult <span class="hljs-title" style="color:rgb(163,21,21);">LogOff</span><span class="hljs-params">()</span> </span>{
  AuthenticationManager.SignOut(DefaultAuthenticationTypes.ApplicationCookie);
   <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> RedirectToAction(<span class="hljs-string" style="color:rgb(163,21,21);">"Index"</span>, <span class="hljs-string" style="color:rgb(163,21,21);">"Home"</span>);
}</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在VS帮我们创建的测试项目中新建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">AccountControllerTest</code>单元测试类，创建测试用例如下：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestMethod]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">LogOff</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> classUnderTest = <span class="hljs-keyword" style="color:rgb(0,0,255);">typeof</span> (AccountController);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> allMethods = classUnderTest.GetMethods();<span class="hljs-comment" style="color:#008000;">//获得所有方法</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> methodUnderTest = allMethods.Where(m =&gt; m.Name == <span class="hljs-string" style="color:rgb(163,21,21);">"LogOff"</span>);<span class="hljs-comment" style="color:#008000;">//获得LogOff方法</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">foreach</span> (MethodInfo methodInfo <span class="hljs-keyword" style="color:rgb(0,0,255);">in</span> methodUnderTest)
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> attribute = Attribute.GetCustomAttribute(methodInfo, <span class="hljs-keyword" style="color:rgb(0,0,255);">typeof</span> (ValidateAntiForgeryTokenAttribute));<span class="hljs-comment" style="color:#008000;">//寻找方法上的ValidateAntiForgeryTokenAttribute特性</span>
        Assert.IsNotNull(attribute);<span class="hljs-comment" style="color:#008000;">//如果存在，测试通过</span>
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">通过微软自带的测试框架写的测试类，在测试项目生成之后，会在测试资源管理器中出现所有可以运行的测试方法：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902175958855-2117293213.png" style="border:0px;" alt="577014-20160902175958855-2117293213.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行测试用例，通过：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160902191209199-1751032043.png" style="border:0px;" alt="577014-20160902191209199-1751032043.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">System.Reflection</code>来获取类，方法，方法上的特性，然后断言特性是否为null。注意，这个测试不是为了测试<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ValidateAntiForgeryTokenAttribute</code>特性做了什么，而是它是否出现在正确的地方。<br> 有些人可能认为这样做太冗余了或者这样做过犹不及，他们也都有似乎合理的理由，但是在一个大的团队或者项目中，有时很难跟踪应该使用哪些切面，并且这些很容易忘记，所以这些类型的测试也是很有用的。<br> 对于像使用了IoC容器而不是特性的DynamicProxy来说，测试切面是否存在稍微有些不同。如果你已经编写了测试来验证选择的IoC工具是否初始化正确，那么也应该同时测试动态代理。<br> 对切面编写测试可能因工具选择的不同而不同，因开发者、框架不同而不同，因此变化可能很大，本系列教程主要使用Castle DynamicProxy和PostSharp来讲解。</p> 
    <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="castle"></a>Castle DynamicProxy测试</h2> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用Castle DynamicProxy写的切面只实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IInterceptor</code>接口，其它方面，就像一个普通的类：编译、实例化、在运行时执行（这和PostSharp切面不同，后者在编译时实例化，并在编译时执行部分代码）。因此，测试使用Castle DynamicProxy的切面就像测试POCO类一样简单。<br> 首先看一下如何测试一个最简单切面，该切面是自我包含的且没有任何依赖。然后看一下如何测试使用DI解析依赖的简单切面。如果你熟悉DI在单元测试中扮演的角色，那么测试DynamicProxy类应该很熟悉。</p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="testInterceptor" style="color:rgb(224,130,131);"></a>测试一个拦截器</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">假设有个拦截器，使用了静态的Log类在方法执行前后输出一些信息。首先创建一个静态Log类存储字符串，如下：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Log</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt; _messages=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt;();

    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> List&lt;<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>&gt; Messages
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _messages; }
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Write</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> message</span>) </span>{
        _messages.Add(message);
    }
}
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下一步，写一个使用了这个类的拦截器。并在拦截的方法执行前后输出一些信息：</p> 
    <pre class="c#"><code class="hljs fortran" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> MyInterceptor:IInterceptor
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> void Intercept(IInvocation invocation)
    {
        <span class="hljs-built_in" style="color:rgb(0,0,255);">Log</span>.<span class="hljs-built_in" style="color:rgb(0,0,255);">Write</span>(invocation.Method.<span class="hljs-keyword" style="color:rgb(0,0,255);">Name</span>+<span class="hljs-string" style="color:rgb(163,21,21);">"执行前"</span>);
        invocation.Proceed();
        <span class="hljs-built_in" style="color:rgb(0,0,255);">Log</span>.<span class="hljs-built_in" style="color:rgb(0,0,255);">Write</span>(invocation.Method.<span class="hljs-keyword" style="color:rgb(0,0,255);">Name</span>+<span class="hljs-string" style="color:rgb(163,21,21);">"执行后"</span>);
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">之前已经看到过使用Castle DynamicProxy写的切面了，但如何测试呢？既然拦截器是一个常规的类，那就可以实例化一个对象，然后调用它的Intercept方法，然后检查一下记录的日志是否和预期的一样。顺着这个思路，写出的代码如下：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestFixture]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyInterceptorTest</span>
{
    [Test]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestIntercept</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myInterceptor=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyInterceptor();
        IInvocation invocation;<span class="hljs-comment" style="color:#008000;">//这里先不赋值，下面接着说</span>
        myInterceptor.Intercept(invocation);
        Assert.IsTrue(Log.Messages.Contains(invocation.Method.Name+<span class="hljs-string" style="color:rgb(163,21,21);">"执行前"</span>));
        Assert.IsTrue(Log.Messages.Contains(invocation.Method.Name+<span class="hljs-string" style="color:rgb(163,21,21);">"执行后"</span>));
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">因为上面的invocation变量没有赋值，所以编译是不通过的。如果你之前做过单元测试的话，那么你也应该知道单元测试中有这么一个概念：<strong>伪造【mocking】</strong>。<br> 当拦截器在程序中运行时，DynamicProxy会创建<em>invocation</em>对象，它对于测试来说是隔离的，因此我们必须伪造一个对象来模拟真正的<strong>invocation</strong>对象，伪造的目的仅仅是为了测试。为了达到这个目的，这里使用了一个伪造工具<strong>Moq</strong>，虽然还有很多可以用，但是这里使用Moq作为示例。使用Nuget安装Moq：<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PM&gt; Install-Package Moq</code>。<br> 现在，创建一个实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IInvocation</code>接口的伪造对象，然后将它传给<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Intercept</code>方法，因为Intercept方法只关心<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">invocation.Method.Name</code>,所以只需要给那个伪造对象定义那个属性就可以了，Moq会给其它属性设置默认值：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Test]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestIntercept</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myInterceptor=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyInterceptor();
    <span class="hljs-comment" style="color:#008000;">//IInvocation invocation;//这里先不赋值，下面接着说</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mockedInvocation=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Mock&lt;IInvocation&gt;();
    mockedInvocation.Setup(m =&gt; m.Method.Name).Returns(<span class="hljs-string" style="color:rgb(163,21,21);">"MyMethod"</span>);<span class="hljs-comment" style="color:#008000;">//Arrange:将被拦截的方法的Name属性设置为MyMethod</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> invocation = mockedInvocation.Object;<span class="hljs-comment" style="color:#008000;">//使用Object属性获得要传入的真实对象</span>
    myInterceptor.Intercept(invocation);
    Assert.IsTrue(Log.Messages.Contains(invocation.Method.Name+<span class="hljs-string" style="color:rgb(163,21,21);">"执行前"</span>));
    Assert.IsTrue(Log.Messages.Contains(invocation.Method.Name+<span class="hljs-string" style="color:rgb(163,21,21);">"执行后"</span>));
}


</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在可以编译运行了，当运行该测试时，测试应该通过。如果进一步看一下Moq的话，你就会发现Moq本身使用了DynamicProxy。因此，在一定程度上，我们使用了DynamicProxy切面测试其它的DynamicProxy切面，这是没有任何问题的，因为我们不是在测试框架本身而是使用框架生成的代码。测试结果如下：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160903234706764-884564869.png" style="border:0px;" alt="577014-20160903234706764-884564869.png"></p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="DI" style="color:rgb(224,130,131);"></a>注入依赖</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">真实项目中，使用上面的静态Log类会造成Log类和任何用到它的地方之间紧耦合，因此，应该使用logging接口，并隐藏实现细节。和写切面是一样的：你想将依赖传入<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MyInterceptor</code>类中。切面和其它模块是一样的，应该遵守<strong>依赖反转原则</strong>，应该依赖抽象而不是实现。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">加入IoC</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">IoC工具在一个复杂点的例子里会实用点，因此下面创建一个比之前复杂的例子。见下面的案例图：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201609/577014-20160905134736488-236807995.png" style="border:0px;" alt="577014-20160905134736488-236807995.png"></p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">实现服务</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">创建一个控制台项目CastleDynamicProxyUT，添加<strong>NUnit，Castle.Core,StructureMap</strong>。注意这里安装的StructureMap版本是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Install-Package structuremap -Version 2.6.4.1</code>。<br> 下面，按照上图从下到上实现，创建接口IServiceTwo和它的实现ServiceTwo，里面添加一个方法<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DoWorkTwo</code>,这里仅仅作为演示，具体该方法中有什么代码不重要。</p> 
    <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
     <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">命名惯例</h4> 
     <p>这里使用的是ServiceName和IServiceName的命名惯例，因为这是StructureMap使用的默认惯例。当配置依赖时，只要遵守了这个惯例，就不必显式列出每个接口/实现对。</p> 
    </blockquote> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> <span class="hljs-title" style="color:rgb(163,21,21);">IServiceTwo</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoWorkTwo</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">ServiceTwo</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IServiceTwo</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoWorkTwo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> System.NotImplementedException();
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下一步，创建LoggingService的实现和接口。真实项目中，这个服务都会使用NLog，log4net等等，但这里为了简单演示，只将日志输出到控制台，这个日志服务可能会用在项目中的任何地方，但是通过logging切面使用的。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> <span class="hljs-title" style="color:rgb(163,21,21);">ILoggingService</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Write</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> message</span>)</span>;
}
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingService</span> : <span class="hljs-title" style="color:rgb(163,21,21);">ILoggingService</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Write</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> message</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"Logging:"</span>+message);
    }
}
</code></pre> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">编写Logging切面</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">该切面依赖LoggingService，通过构造函数注入可以获得ILoggingService依赖。在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Intercept</code>方法中，它在拦截的方法执行前后分别输出“Log start”和“Log end”：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IInterceptor</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> ILoggingService _loggingService;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect</span>(<span class="hljs-params">ILoggingService loggingService</span>) </span>{
        _loggingService = loggingService;
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Intercept</span>(<span class="hljs-params">IInvocation invocation</span>) </span>{
        _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>);
        invocation.Proceed();
        _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>);
    }
}

</code></pre> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">对切面进行单元测试</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的切面不像之前的测试那样简单，因为这个切面多个依赖。我们只想测试切面，不想测试依赖，因此需要使用伪造工具创建一个代替对象传入<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LoggingAspect</code>构造函数，这样就可以独立地测试切面了,记得要安装Moq。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestFixture]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspectTest</span>
{
    [Test]
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestIntercept</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mockedLoggingService=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Mock&lt;ILoggingService&gt;();<span class="hljs-comment" style="color:#008000;">//为ILoggingService创建一个伪造对象</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> loggingAspect=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> LoggingAspect(mockedLoggingService.Object);<span class="hljs-comment" style="color:#008000;">//使用伪造对象的Object属性实例化LoggingAspect</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mockedInvocation=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Mock&lt;IInvocation&gt;();<span class="hljs-comment" style="color:#008000;">//为IInvoation对象创建一个伪造对象</span>
        loggingAspect.Intercept(mockedInvocation.Object);
        mockedLoggingService.Verify(x=&gt;x.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>));<span class="hljs-comment" style="color:#008000;">//使用伪造对象的Verify验证Write方法是否像期待的那样执行</span>
        mockedLoggingService.Verify(x=&gt;x.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>));
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">测试DynamicProxy的切面是很容易的，但我们还没有看到全局，因此，继续按照示意图完成其它依赖的代码。这个切面需要拦截ServiceOne的任何调用。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">创建ServiceOne</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">创建ServiceOne实现和接口。这个服务没有做太多的事情，只是输出到控制台，示意图上说明它会依赖ServiceTwo接口，因此在构造函数中要确保它传入，虽然传入了依赖，但为了演示目的，这里并没有真正使用该依赖：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> <span class="hljs-title" style="color:rgb(163,21,21);">IServiceOne</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoWorkOne</span>(<span class="hljs-params"></span>)</span>;
}
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">ServiceOne</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IServiceOne</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">ServiceOne</span>(<span class="hljs-params">IServiceTwo serviceTwo</span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//虽然没有使用IServiceTwo依赖，但是没有它，ServiceOne是不能实例化的</span>
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoWorkOne</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"ServiceOne's DoWorkOne finished the execution!"</span>);
    }
}


</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">随着例子越来越复杂，StructureMap就会派上用场了。在没使用StructureMap之前，先来看看没有IoC工具时程序如何使用ServiceOne。要在Main方法中使用ServiceOne，因为它依赖ServiceTwo，所以必须先要实例化ServiceTwo：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
        <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 1.0 不使用StructureMap的情况</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> service2=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ServiceTwo();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> service1=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ServiceOne(service2);
        service1.DoWorkOne();
        <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行程序的话，就会在控制台看到“ServiceOne's DoWorkOne finished the execution!”。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">使用IOC工具管理依赖</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">代码执行结果看起来没问题，但是在Main方法中依赖了特定的实现<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">new ServiceTwo(),new ServiceOne(service2)</code>违反了依赖反转原则，这会造成这两个服务类和Program类紧耦合。从架构设计的角度来说这是一个设计缺陷，而且想象一下如果有一个更复杂的依赖关系图呢：每次调用一个服务上的一个方法时，你可能都要花费5行以上的代码实例化所有的对象。<br> 对于这种情况，我们应该使用StructureMap管理依赖，并实例化正确的服务。这样，就不用来new特定的实现了，只需要命令StructureMap完成某个接口的实现就可以了。下面看一下使用默认惯例的StructureMap的基本配置：</p> 
    <pre class="c#"><code class="hljs php" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-comment" style="color:#008000;">#region 2.0 使用StructureMap</span>
ObjectFactory.Initialize(config =&gt;<span class="hljs-comment" style="color:#008000;">//不同的IOC工具初始化代码是不同的</span>
{
    config.Scan(scanner =&gt;
    {
        scanner.TheCallingAssembly();
        scanner.WithDefaultConventions();<span class="hljs-comment" style="color:#008000;">//使用默认的惯例</span>
    });
});

<span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> service1 = ObjectFactory.GetInstance&lt;IServiceOne&gt;();
service1.DoWorkOne();

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行程序，会看到和之前一样的输出，但是这次StructureMap会帮我们处理依赖图中的所有依赖连接。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">DynamicProxy和StructureMap结合</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">前面已经知道，需要使用ProxyGenerator可以将一个DynamicProxy切面应用到一个类上。前面几篇博客中，我们都是在StructureMap的配置中处理的，但是ServceOne有一个依赖，因此比之前更复杂了。</p> 
    <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
     <p>StructureMap自带的拦截<br> 如果你熟悉StructureMap，那么你应该知道它有自己的拦截能力，比如<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">InstanceInterceptor</code>接口。对于确定类型的装饰器，这个工具够用了，但是DynamicProxy有个更强大的拦截工具，所以这里不使用StructureMap的InstanceInterceptor。</p> 
    </blockquote> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">一种方法是实例化切面和它的依赖，实例化服务类和它的依赖，这样就可以将切面应用到服务上了：</p> 
    <pre class="c#"><code class="hljs php" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
ObjectFactory.Initialize(config =&gt;<span class="hljs-comment" style="color:#008000;">//不同的IOC工具初始化代码是不同的</span>
{
    config.Scan(scanner =&gt;
    {
        scanner.TheCallingAssembly();
        scanner.WithDefaultConventions();<span class="hljs-comment" style="color:#008000;">//使用默认的惯例</span>
    });
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> proxyGenerator = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ProxyGenerator();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> aspect = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> LoggingAspect(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> LoggingService());
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> service = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ServiceOne(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ServiceTwo());
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> result = proxyGenerator.CreateInterfaceProxyWithTargetInterface(typeof(IServiceOne), service, aspect);<span class="hljs-comment" style="color:#008000;">//应用切面</span>
    config.<span class="hljs-keyword" style="color:rgb(0,0,255);">For</span>&lt;IServiceOne&gt;().<span class="hljs-keyword" style="color:rgb(0,0,255);">Use</span>((IServiceOne) result);<span class="hljs-comment" style="color:#008000;">//告诉StructureMap使用产生的动态代理</span>
});

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这种方法有几个问题：</p> 
    <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
     <li style="list-style:decimal;">首先最明显的就是美观问题：将一个切面应用到一个服务类上要写很多的代码。</li> 
     <li style="list-style:decimal;">应该使用一种方法让StructureMap处理依赖而不是大量的new。</li> 
     <li style="list-style:decimal;">可能不太明显，如果想使用一个切面多次呢？如果继续使用这种方法，StructureMap初始化可能会变得非常凌乱。</li> 
    </ol>
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">使用EnrichWith重构</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">幸运的是，我们可以结合一个helper类和StructureMap的叫做<strong>EnrichWith</strong>的功能来精简代码。StructureMap的EnrichWith方法可以用于注册一个方法来代替正常服务的对象，就像注入一个拦截器的最佳地方。下面将大部分的凌乱代码放到EnrichWith语句中：</p> 
    <pre class="c#"><code class="hljs php" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-comment" style="color:#008000;">#region 3.0 使用EnrichWith重构</span>
ObjectFactory.Initialize(config =&gt;
{
    config.Scan(scanner =&gt;
    {
        scanner.TheCallingAssembly();
        scanner.WithDefaultConventions();
    });
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> proxyGenerator = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ProxyGenerator();
    config.<span class="hljs-keyword" style="color:rgb(0,0,255);">For</span>&lt;IServiceOne&gt;().<span class="hljs-keyword" style="color:rgb(0,0,255);">Use</span>&lt;ServiceOne&gt;().EnrichWith(svc =&gt;
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> aspect = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> LoggingAspect(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> LoggingService());
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> result = proxyGenerator.CreateInterfaceProxyWithTargetInterface(typeof(IServiceOne), svc, aspect);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> result;
    });
});

<span class="hljs-comment" style="color:#008000;">#endregion</span>


</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">比之前的代码好多了，但是每次使用一个切面仍然要输入很多东西。进一步优化，我们可以把<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">EnrichWith</code>里的代码尽可能多地封装到可复用的代理创建类里，最好像下面的代码那样：</p> 
    <pre class="c#"><code class="hljs php" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ObjectFactory.Initialize(config =&gt;
{
    config.Scan(scanner =&gt;
    {
        scanner.TheCallingAssembly();
        scanner.WithDefaultConventions();
    });
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> proxyHelper = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ProxyHelper();
    <span class="hljs-comment" style="color:#008000;">//注意Proxify方法本身以实参传入EnrichWith方法</span>
    config.<span class="hljs-keyword" style="color:rgb(0,0,255);">For</span>&lt;IServiceOne&gt;().<span class="hljs-keyword" style="color:rgb(0,0,255);">Use</span>&lt;ServiceOne&gt;().EnrichWith(proxyHelper.Proxify&lt;IServiceOne, LoggingAspect&gt;);
});
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码更加简洁，使用EnrichWith方法只用到了proxyHelper的Proxify方法，服务接口和切面类。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">使用ProxyHelper</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面我们已经看到了这个类，只需要将代理生成器中的代码放到这个类中就可以了。在这个帮助类中，会使用ObjectFactory来解析拦截器对象。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">ProxyHelper</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> ProxyGenerator _proxyGenerator;
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">ProxyHelper</span>(<span class="hljs-params"></span>) </span>{
        _proxyGenerator = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> ProxyGenerator();<span class="hljs-comment" style="color:#008000;">//ProxyGenerator移到helper类中</span>
    }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> Proxify&lt;I, A&gt;(<span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> obj) <span class="hljs-keyword" style="color:rgb(0,0,255);">where</span> A : IInterceptor<span class="hljs-comment" style="color:#008000;">//约束A只允许IInterceptor类型实参</span>
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> interceptor = (IInterceptor) ObjectFactory.GetInstance&lt;A&gt;();<span class="hljs-comment" style="color:#008000;">//StructureMap处理切面的依赖</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> result = _proxyGenerator.CreateInterfaceProxyWithTargetInterface(<span class="hljs-keyword" style="color:rgb(0,0,255);">typeof</span> (I),obj,interceptor);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> result;
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这小节的主题是对使用DynamicProxy写的切面进行单元测试，所以关于IOC的知识及优化大家可以自己去研究。研究出来的结果就是对使用DynamicProxy写的切面进行单元测试并不是很难。下面一节，我们会对使用PostSharp写的切面进行单元测试。</p> 
    <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="postSharp"></a>PostSharp测试</h2> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">使用PostSharp编写的切面继承自抽象基类，比如<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>。它们也是特性，存储在元数据中，因此，没有PostSharp这个postcompiler（后编译，就是代码编译之后再加工）工具，这些特性什么都不会做，也不会执行。该后编译工具会在编译时实例化切面类，序列化，然后再反序列化。因此，直接测试这些切面类是很困难的，在某些情况下，由于后编译编织的本质和PostSharp框架写入的方式直接进行测试根本是行不通的。</p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="postSharpUT" style="color:rgb(224,130,131);"></a>对PostSharp切面进行单元测试</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">之前我们创建了一个静态的Log类，这次也一样，但切面类是不同的：它继承自PostSharp的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>基类。这次会重写<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnEntry</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSuccess</code>方法，并在这两个方法内输出日志：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyBoundaryAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
       Log.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Before:"</span>+args.Method.Name);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        Log.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"After:"</span> + args.Method.Name);
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">对于上面类的单元测试和之前的很相似，如下，我们不需要使用Moq，可以直接实例化一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionArgs</code>对象，该对象的构造函数期望一个实例对象和一个参数列表，但因为这里<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MyBoundaryAspect</code>用不到这些，我们分别使用null和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Arguments.Empty</code>代替。切面类使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Method</code>属性，因此我们需要将它设置为实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodBase</code>的某个对象，通过使用System.Reflection提供的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DynamicMethod</code>对象，可以很方便地达到目的。对于测试，这里只关心方法名，因此返回类型和参数类型可以设置为null。<br> 接下来就该写执行了，这里实例化一个切面对象，并先后调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnEntry</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSuccess</code>方法，模拟在运行时切面被使用的时候发生了什么。<br> 最后，会输出两个断言，看看预期的和实际的日志信息是否相同。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestFixture]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestMyLoggerCrossCutConcern</span>
{
    [Test]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestMyBoundaryAspect</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//Arrange 准备阶段</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> args = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MethodExecutionArgs(<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>, Arguments.Empty);
        args.Method = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> DynamicMethod(<span class="hljs-string" style="color:rgb(163,21,21);">"Farb"</span>, <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>, <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>);
        <span class="hljs-comment" style="color:#008000;">//Act 执行阶段</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> aspect = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyBoundaryAspect();
        aspect.OnEntry(args);
        aspect.OnSuccess(args);
        <span class="hljs-comment" style="color:#008000;">//Assert 断言阶段</span>
        Assert.IsTrue(Log.Messages.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"Before:"</span> + args.Method.Name));
        Assert.IsTrue(Log.Messages.Contains(<span class="hljs-string" style="color:rgb(163,21,21);">"After:"</span> + args.Method.Name));
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当然，也可以使用伪造工具创建一个代替<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionArgs</code>的对象，但因为它不是一个接口或抽象类，所以必须使用一个更高级的伪造工具，如<strong>TypeMock</strong>，Moq不能实现这个。下面复习一下DynamicProxy中的复杂例子，看看使用PostSharp会有什么不同。</p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="postSharpDI" style="color:rgb(224,130,131);"></a>注入依赖</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">之前的例子使用了StructureMap结合DynamicProxy，依赖通过构造函数注入，使用了PostSharp，切面构造函数会在编译时调用，这个过程在StructureMap初始化之前。因此，构造函数注入是没用的，这就意味着测试更加困难。为了解决这个问题，这里用到了服务定位器模式。<br> 服务定位器是依赖反转的一种形式，与通过构造函数传入服务相反，它会去寻找服务。有时人们认为服务定位模式是反模式，但是，它确实好于压根不用依赖反转。<br> 这一小节，创建一个控制台项目<strong>PostSharpUT</strong>，安装PostSharp和NUnit，StructureMap，复习一下和之前一样复杂的依赖。</p> 
    <pre class="c#"><code class="hljs haskell" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-type" style="color:rgb(163,21,21);">Program</span> { static void <span class="hljs-type" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-title" style="color:rgb(163,21,21);">string</span>[] <span class="hljs-title" style="color:rgb(163,21,21);">args</span>) { <span class="hljs-type" style="color:rgb(163,21,21);">ObjectFactory</span>.<span class="hljs-type" style="color:rgb(163,21,21);">Initialize</span>(<span class="hljs-title" style="color:rgb(163,21,21);">x</span> =&gt; { <span class="hljs-title" style="color:rgb(163,21,21);">x</span>.<span class="hljs-type" style="color:rgb(163,21,21);">Scan</span>(<span class="hljs-title" style="color:rgb(163,21,21);">scan</span> =&gt; { <span class="hljs-title" style="color:rgb(163,21,21);">scan</span>.<span class="hljs-type" style="color:rgb(163,21,21);">TheCallingAssembly</span>(); scan.<span class="hljs-type" style="color:rgb(163,21,21);">WithDefaultConventions</span>(); }); }); var myObj = <span class="hljs-type" style="color:rgb(163,21,21);">ObjectFactory</span>.<span class="hljs-type" style="color:rgb(163,21,21);">GetInstance</span>&lt;<span class="hljs-type" style="color:rgb(163,21,21);">IServiceOne</span>&gt;(); myObj.<span class="hljs-type" style="color:rgb(163,21,21);">DoWorkOne</span>(); } } </span></code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">服务类和接口与之前的保持不变，IServiceOne , ServiceOne ,<br> IServiceTwo , ServiceTwo , ILoggingService ,LoggingService直接使用之前项目中的。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">LoggingAspect现在继承了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>基类，而不是Castle的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IInterceptor</code>接口，里面使用了ILoggingService的实现，因此应该使用一个私有字段：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> ILoggingService _loggingService;

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect</span>(<span class="hljs-params">ILoggingService loggingService</span>) </span>{
            _loggingService = loggingService;
        }

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
            _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
            _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>);
        }

    }
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">PostSharp构造器只能以特性的形式使用，C#特性构造器只接受静态值，因此不能像上面那样注入LoggingService依赖。但是可以使用还没有提到的一个PostSharp API，这就是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">RuntimeInitialize</code>方法。PostSharp会在运行时执行该方法，但是在运行时方法如<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnEntry</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSuccess</code>方法之前（对<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LocationInterceptionAspect</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodInterceptionAspect</code>也适用）。重写该方法，在方法中使用StructureMap作为服务定位器来初始化<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">_loggingService</code>。也需要将_loggingService使用特性标记为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">NonSerialized</code>，因为直到该切面反序列化之后它才会被初始化。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    [NonSerialized]
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span>  ILoggingService _loggingService;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">RuntimeInitialize</span>(<span class="hljs-params">MethodBase method</span>) </span>{
        _loggingService = ObjectFactory.GetInstance&lt;ILoggingService&gt;();
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>);
    }

}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在这个切面就可用了，然后，将这个切面以特性的形式用在<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ServiceOne</code>的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DoWorkOne</code>上：</p> 
    <pre class="c#"><code class="hljs cpp" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">   [LoggingAspect]
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoWorkOne</span><span class="hljs-params">()</span> </span>{
            Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"ServiceOne's DoWorkOne finished the execution!"</span>);
        }
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">执行结果：</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201610/577014-20161022181504029-659687262.png" style="border:0px;" alt="577014-20161022181504029-659687262.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">对上面的代码进行单元测试就需要多做点工作了。创建一个测试类和测试方法，和之前一样，在测试中，需要创建<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ILoggingService</code>的一个Mock对象（如果没有安装Moq先要使用Nuget安装Moq）。再创建一个要传入的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionArgs</code>对象，它不需要有Method属性，因为我们这次没有用到它：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestFixture]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyLoggingAspectTest</span>
{
    [Test]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestIntercept</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mockedLoggingService=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Mock&lt;ILoggingService&gt;();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> args=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MethodExecutionArgs(<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>,Arguments.Empty);
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果使用的是Castle，我们接下来就要实例化切面对象，然后将mockedLoggingAspect对象传给构造函数，但如果使用了PostSharp，就不能那么做了。做法是必须将mockedLoggingAspect对象传给StructureMap，让它实例化切面对象，然后执行<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">RuntimeInitialize</code>方法，它会向StructureMap请求ILoggingService对象：</p> 
    <pre class="c#"><code class="hljs php" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[TestFixture]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyLoggingAspectTest</span> </span>{
    [Test]
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> void TestIntercept()
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mockedLoggingService = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Mock&lt;ILoggingService&gt;();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> args=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MethodExecutionArgs(<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>,Arguments.<span class="hljs-keyword" style="color:rgb(0,0,255);">Empty</span>);
        ObjectFactory.Initialize(x =&gt;
        x.<span class="hljs-keyword" style="color:rgb(0,0,255);">For</span>&lt;ILoggingService&gt;().<span class="hljs-keyword" style="color:rgb(0,0,255);">Use</span>(mockedLoggingService.Object));
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> loggingAspect=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> LoggingAspect();
        loggingAspect.RuntimeInitialize(<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>);
        loggingAspect.OnEntry(args);
        loggingAspect.OnSuccess(args);
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当OnEntry方法执行时，我们期望loggingService调用Write方法，并输出含有“Log Start”的信息。同样，当执行OnSuccess方法时，我们期望输出含有“Log end”的信息。下面根据单元测试的3A法则，应该验证我们的预期和实际是否相符了：</p> 
    <pre class="c#"><code class="hljs fortran" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">mockedLoggingService.<span class="hljs-built_in" style="color:rgb(0,0,255);">Verify</span>(x=&gt;x.<span class="hljs-built_in" style="color:rgb(0,0,255);">Write</span>(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>));
mockedLoggingService.<span class="hljs-built_in" style="color:rgb(0,0,255);">Verify</span>(x=&gt;x.<span class="hljs-built_in" style="color:rgb(0,0,255);">Write</span>(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>));
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">执行该测试，测试会通过。这次我们也实现了和之前使用Castle DynamicProxy相似级别的测试，只不过做的事情多了些罢了。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">别急，好戏还在下面。</p> 
    <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="postSharpAndTest" style="color:rgb(224,130,131);"></a>PostSharp和测试的问题</h3> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当对PostSharp切面做单元测试时，你会面临很多问题。<br> 第一个问题是PostSharp在编译时编织。对后来会修改的代码测试变得复杂。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">编译时编织</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">考虑下面的代码段：</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyStringExtension</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> str</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>(str.Reverse().ToArray());
    }
}

 [TestFixture]
 <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyStringExtensionTest</span>
 {
     [Test]
     <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse_Test</span>(<span class="hljs-params"></span>) </span>{
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myStrObj=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyStringExtension();
         <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> reversedStr = myStrObj.Reverse(<span class="hljs-string" style="color:rgb(163,21,21);">"hello"</span>);
         Assert.That(reversedStr,Is.EqualTo(<span class="hljs-string" style="color:rgb(163,21,21);">"olleh"</span>));
     }
 }
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这是本文开头的例子，传入字符串变量“hello”，然后返回反转后的字符串“olleh”。现在，思考相同的PostSharp切面<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LoggingAspect</code>应用到该方法会怎样。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyStringExtension</span>
{
    [LoggingAspect]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> str</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>(str.Reverse().ToArray());
    }
}
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在运行时执行的Reverse方法现在会在LoggingAspect类的代码中执行。因此，RuntimeInitialize方法会被执行，然后切面使用StructureMap获得ILoggingService的依赖。现在，Reverse_Test就会变得有点复杂了。我们需要再次伪造ILoggingService，并且初始化StructureMap来获得可代替的对象，因为这是个单元测试，我们对测试logging不感兴趣，只对<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Reverse</code>方法感兴趣。</p> 
    <pre class="c#"><code class="hljs php" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Test]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> void Reverse_Test()
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> mockloggingService=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Mock&lt;ILoggingService&gt;();
    ObjectFactory.Initialize(x=&gt;
        x.<span class="hljs-keyword" style="color:rgb(0,0,255);">For</span>&lt;ILoggingService&gt;().<span class="hljs-keyword" style="color:rgb(0,0,255);">Use</span>(mockloggingService.Object));
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myStrObj=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyStringExtension();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> reversedStr = myStrObj.Reverse(<span class="hljs-string" style="color:rgb(163,21,21);">"hello"</span>);
    Assert.That(reversedStr,Is.EqualTo(<span class="hljs-string" style="color:rgb(163,21,21);">"olleh"</span>));
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然已经使用了切面完成了漂亮的关注点分离（反转字符串的类和logging类），但运行单元测试时，它们仍然是紧耦合的，因此仍然需要做些额外的工作来分离测试中的伪造对象。此外，编写UT时，需要伪造的服务类是不明显的，因为它不是唯一要实例化切面的。如果忘了一个，那么测试就会失败，因为StructureMap会抛异常。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">最后一个是服务定位器的问题，在这个demo中，直接把<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ObjectFactory.Initialize</code>放在单元测试中不是问题，因为只有一个UT，但是如果这是个静态方法，当写多个UT时，就必须关心共享状态。比如，当在ObjectFactory中初始化ILoggingService的伪造对象时，该伪造对象会为每个UT保持注册。解决方案就是在你的代码（单元测试，RuntimeInitialize）和StructureMap之间添加一层处理逻辑。这会让UT花费更多功夫。<br> 总之，当编写涉及PostSharp的UT时，很困难。虽然收获了将横切关注点分离到不同的类中的好处，但UT必须做些特殊的处理代码。使用Castle DynamicProxy时不会出现这个问题。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">关闭PostSharp的变通方法</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">PostSharp可以通过VS中的项目属性设置进行关闭，可以临时关闭PostSharp,运行单元测试，然后当测试通过后再打开即可。这种方法几乎不理想，感兴趣的，你可以试试。<br> 另一种变通是使用编译器宏指令。比如，你自定义了一个指令<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">UnitTesting</code>,就可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">#if</code>语句包裹切面代码，如果<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">UnitTesting</code>指定定义了的话，就会编译一个空切面，这就是说，你可以不需要额外的伪造就可以运行UT了。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">define</span> UnitTesting</span>
    [Serializable]
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
    {
       <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">if</span> !UnitTesting</span>
        [NonSerialized]
        <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span>  ILoggingService _loggingService;

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">RuntimeInitialize</span>(<span class="hljs-params">MethodBase method</span>) </span>{
            _loggingService = ObjectFactory.GetInstance&lt;ILoggingService&gt;();
        }

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
            _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>);
        }

        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
            _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>);
        }  
    <span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endif</span></span>
    }
}

 [Test]
        <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse_Test</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myStrObj=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyStringExtension();<span class="hljs-comment" style="color:#008000;">//这个UT就不需要关心伪造对象了</span>
            <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> reversedStr = myStrObj.Reverse(<span class="hljs-string" style="color:rgb(163,21,21);">"hello"</span>);
            Assert.That(reversedStr,Is.EqualTo(<span class="hljs-string" style="color:rgb(163,21,21);">"olleh"</span>));
        }
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个办法也几乎不理想，你必须通过定义<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">UnitTesting</code>指定来打开和关闭PostSharp（或者至少找到一种自动化方式）。还有，必须用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">#if/#end</code>来包围切面类的所有代码。<br> 一个相似的选择是定义一个全局变量来指示切面代码是否应该运行。这个变量默认是true，但在UT中，可以设置为false。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">AspectSettings</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">bool</span> On = <span class="hljs-keyword" style="color:rgb(0,0,255);">true</span>;
}

[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LoggingAspect2</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    [NonSerialized]
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span>  ILoggingService _loggingService;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">RuntimeInitialize</span>(<span class="hljs-params">MethodBase method</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span>(!AspectSettings.On) <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
        _loggingService = ObjectFactory.GetInstance&lt;ILoggingService&gt;();
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!AspectSettings.On) <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
        _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log start"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!AspectSettings.On) <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
        _loggingService.Write(<span class="hljs-string" style="color:rgb(163,21,21);">"Log end"</span>);
    }

}

[Test]
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse_Test</span>(<span class="hljs-params"></span>) </span>{
    AspectSettings.On = <span class="hljs-keyword" style="color:rgb(0,0,255);">false</span>;<span class="hljs-comment" style="color:#008000;">//关闭设置</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> myStrObj=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> MyStringExtension();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> reversedStr = myStrObj.Reverse(<span class="hljs-string" style="color:rgb(163,21,21);">"hello"</span>);
    Assert.That(reversedStr,Is.EqualTo(<span class="hljs-string" style="color:rgb(163,21,21);">"olleh"</span>));
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这种变通可能是最简单的方法了，因为不必担心伪造、共享状态，服务定位器问题或者其他问题了。当测试时，切面会关闭。这仍然不方便，因为必须切面的设置，以确保所有的UT都关闭了切面。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">不可访问的构造函数</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果上面所有的问题你觉得都不是问题，那么还有一个问题。<br> 本文的例子中，使用的是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnMethodBoundaryAspect</code>。使用的参数类是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MethodExecutionArgs</code>,幸运地是它有一个公共的构造函数。另外两个PostSharp切面基类（位置拦截和方法拦截）使用了LocationInterceptionArgs和MethodInterceptionArgs，它们都没有公共的构造函数。这使得创建伪造或者可代替的对象更加困难，你可以使用更高级的伪造工具，如TypeMock（不免费）。</p> 
    <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">间接测试PostSharp</h4> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">该说的都说了，该做的也都做了，可能不值得花费精力直接测试PostSharp切面类。应该做的就是保持切面中的代码最小化。切面可能只包含实例化和执行其他类的代码，也就是说，你可以在PostSharp切面类和执行横切关注点的代码之间创建一个间接层。下图展示了PostSharp的例子，但相同的原则也可以用于DynamicProxy或任何其他的切面框架。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201610/577014-20161022232518998-191376652.png" style="border:0px;" alt="577014-20161022232518998-191376652.png"></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">一定程度上，这种方式和MVP模式很相似。View是PostSharp切面本身，Presenter是处理工作的分离的类（logging之前，logging之后等等）。切面中的代码极少，因为已经将它的工作委托给一个横切关注点对象（concern）。该横切关注点对象是一个POCO，比如，一个没有继承自PostSharp基类的对象更容易测试。</p> 
    <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyNormalCode</span>
{
    [MyThinAspect]
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> <span class="hljs-title" style="color:rgb(163,21,21);">Reverse</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> content</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>(content.Reverse().ToArray());
    }
}

[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyThinAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">OnMethodBoundaryAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IMyCrossCuttingConcern _concern;<span class="hljs-comment" style="color:#008000;">//该切面只有一个StructureMap提供的IMyCrossCuttingConcern依赖</span>
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">RuntimeInitialize</span>(<span class="hljs-params">MethodBase method</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span>(!AspectSettings.On) <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
        _concern = ObjectFactory.GetInstance&lt;IMyCrossCuttingConcern&gt;();
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnEntry</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!AspectSettings.On) <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
        _concern.BeforeMethod(<span class="hljs-string" style="color:rgb(163,21,21);">"before"</span>);<span class="hljs-comment" style="color:#008000;">//委托给BeforeMethod方法</span>
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSuccess</span>(<span class="hljs-params">MethodExecutionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (!AspectSettings.On) <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>;
        _concern.AfterMethod(<span class="hljs-string" style="color:rgb(163,21,21);">"after"</span>);<span class="hljs-comment" style="color:#008000;">//委托给AfterMethod方法</span>
    }
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> <span class="hljs-title" style="color:rgb(163,21,21);">IMyCrossCuttingConcern</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">BeforeMethod</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> logMsg</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">AfterMethod</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> logMsg</span>)</span>;
}
</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">所有通知代码可以放到<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IMyCrossCuttingConcern</code>的实现中：</p> 
    <pre><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyCrossCuttingConcern</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IMyCrossCuttingConcern</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> ILoggingService _loggingService;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyCrossCuttingConcern</span>(<span class="hljs-params">ILoggingService loggingService</span>) </span>{
        _loggingService = loggingService;
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">BeforeMethod</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> logMsg</span>) </span>{
        _loggingService.Write(logMsg);
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">AfterMethod</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> logMsg</span>) </span>{
        _loggingService.Write(logMsg);
    }
}

</code></pre> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">MyCrossCuttingConcern很容易测试，因为它和任何AOP框架都不是紧耦合的，构造函数注入再次变得可行。</p> 
    <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="summary"></a>小结</h2> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">谈到UT时，Castle DynamicProxy有明显优势，PostSharp的UT至少处于中级难度并且要求更多的代码。<br> 好的软件架构绝大多数都知道做出正确的权衡，并且基于软件的类型和开发目标变化也很灵活。<br> 如果你认为UT很重要，那么不要完全依赖PostSharp。后面，我们还会看一下PostSharp可以提供一些运行时编织工具不能提供的测试形式。PostSharp提供了编译时验证和架构验证，这些都是在编译时发生的。比如，可以使用PostSharp在架构级验证代码（这样，确保所有的NHibernate实体属性都正确地定义为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">virtual</code>）。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">本文开始暴露的一点是运行时编织工具（Castle DynamicProxy）和后编译时编织工具（PostSharp）有很大的不同。如果只看本文的开头部分，你会看到PostSharp更强大、更灵活，但是最后涉及到UT时，你会看到它这么强大和灵活所付出的代价。</p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
    <p><font color="#494949"><span style="font-size:15px;line-height:25px;">本文转自tkbSimplest博客园博客，原文链接：http://www.cnblogs.com/farb/p/UnitTestAspects.html，如需转载请自行联系原作者</span></font><br></p> 
    <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
