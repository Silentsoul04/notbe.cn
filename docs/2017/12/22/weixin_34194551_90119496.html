<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux 内核进程管理之进程ID【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://www.cnblogs.com/hazir/p/linux_kernel_pid.html               Linux 内核使用&nbsp;task_struct&nbsp;数据结构来关联所有与进程有关的数据和结构，Linux 内核所有涉及到进程和程序的所...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/22/weixin_34194551_90119496.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux 内核进程管理之进程ID【转】</h1>
    <p class="post-meta">Dec 22, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://www.cnblogs.com/hazir/p/linux_kernel_pid.html" rel="nofollow">http://www.cnblogs.com/hazir/p/linux_kernel_pid.html</a></p> 
   <div class="blogpost-body"> 
    <div> 
     <p>Linux 内核使用&nbsp;<code>task_struct</code>&nbsp;数据结构来关联所有与进程有关的数据和结构，Linux 内核所有涉及到进程和程序的所有算法都是围绕该数据结构建立的，是内核中最重要的数据结构之一。该数据结构在内核文件&nbsp;<code>include/linux/sched.h</code>&nbsp;中定义，在Linux 3.8 的内核中，该数据结构足足有 380 行之多，在这里我不可能逐项去描述其表示的含义，本篇文章只关注该数据结构如何来组织和管理进程ID的。</p> 
     <h2>进程ID类型</h2> 
     <p>要想了解内核如何来组织和管理进程ID，先要知道进程ID的类型：</p> 
     <ul>
      <li> <strong>PID</strong>：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。</li> 
      <li> <strong>TGID</strong>：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。</li> 
      <li> <strong>PGID</strong>：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。</li> 
      <li> <strong>SID</strong>：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。</li> 
     </ul>
     <h2>PID 命名空间</h2> 
     <p>命名空间是为操作系统层面的虚拟化机制提供支撑，目前实现的有六种不同的命名空间，分别为mount命名空间、UTS命名空间、IPC命名空间、用户命名空间、PID命名空间、网络命名空间。命名空间简单来说提供的是对全局资源的一种抽象，将资源放到不同的容器中（不同的命名空间），各容器彼此隔离。命名空间有的还有层次关系，如PID命名空间，图1 为命名空间的层次关系图。<br><img src="https://yqfile.alicdn.com/img_37892af81133515fc749f5aec46c1272.png" alt=""></p> 
     <p><em>图1 命名空间的层次关系</em></p> 
     <p>在上图有四个命名空间，一个父命名空间衍生了两个子命名空间，其中的一个子命名空间又衍生了一个子命名空间。以PID命名空间为例，由于各个命名空间彼此隔离，所以每个命名空间都可以有 PID 号为 1 的进程；但又由于命名空间的层次性，父命名空间是知道子命名空间的存在，因此子命名空间要映射到父命名空间中去，因此上图中 level 1 中两个子命名空间的六个进程分别映射到其父命名空间的PID 号5~10。</p> 
     <p>命名空间增大了 PID 管理的复杂性，对于某些进程可能有多个PID——在其自身命名空间的PID以及其父命名空间的PID，凡能看到该进程的命名空间都会为其分配一个PID。因此就有：</p> 
     <ul>
      <li> <strong>全局ID</strong>：在内核本身和初始命名空间中唯一的ID，在系统启动期间开始的 init 进程即属于该初始命名空间。系统中每个进程都对应了该命名空间的一个PID，叫全局ID，保证在整个系统中唯一。</li> 
      <li> <strong>局部ID</strong>：对于属于某个特定的命名空间，它在其命名空间内分配的ID为局部ID，该ID也可以出现在其他的命名空间中。</li> 
     </ul>
     <h2>进程ID管理数据结构</h2> 
     <p>Linux 内核在设计管理ID的数据结构时，要充分考虑以下因素：</p> 
     <ol>
      <li>如何快速地根据进程的 task_struct、ID类型、命名空间找到局部ID</li> 
      <li>如何快速地根据局部ID、命名空间、ID类型找到对应进程的 task_struct</li> 
      <li>如何快速地给新进程在可见的命名空间内分配一个唯一的 PID</li> 
     </ol>
     <p>如果将所有因素考虑到一起，将会很复杂，下面将会由简到繁设计该结构。</p> 
     <h3>一个PID对应一个task_struct</h3> 
     <p>如果先不考虑进程之间的关系，不考虑命名空间，仅仅是一个PID号对应一个task_struct，那么我们可以设计这样的数据结构：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="k">struct <span class="n">task_struct <span class="p">{ <span class="c1">//... <span class="k">struct <span class="n">pid_link <span class="n">pids<span class="p">; <span class="c1">//... <span class="p">}; <span class="k">struct <span class="n">pid_link <span class="p">{ <span class="k">struct <span class="n">hlist_node <span class="n">node<span class="p">; <span class="k">struct <span class="n">pid <span class="o">*<span class="n">pid<span class="p">; <span class="p">}; <span class="k">struct <span class="n">pid <span class="p">{ <span class="k">struct <span class="n">hlist_head <span class="n">tasks<span class="p">; <span class="c1">//指回 pid_link 的 node <span class="kt">int <span class="n">nr<span class="p">; <span class="c1">//PID <span class="k">struct <span class="n">hlist_node <span class="n">pid_chain<span class="p">; <span class="c1">//pid hash 散列表结点 <span class="p">}; </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <p>每个进程的 task_struct 结构体中有一个指向 pid 结构体的指针，pid 结构体包含了 PID 号。结构示意图如图2。</p> 
     <p><a href="https://github-camo.global.ssl.fastly.net/76235511d022f45a4e5d16653309774a3d3ed6b4/687474703a2f2f692e696d6775722e636f6d2f6461676f376f4c2e706e67" rel="nofollow"><img src="https://github-camo.global.ssl.fastly.net/76235511d022f45a4e5d16653309774a3d3ed6b4/687474703a2f2f692e696d6775722e636f6d2f6461676f376f4c2e706e67" alt=""></a></p> 
     <p><em>图2 一个task_struct对应一个PID</em></p> 
     <p>图中还有两个结构上面未提及：</p> 
     <ul>
      <li>pid_hash[]: 这是一个hash表的结构，根据 pid 的 nr 值哈希到其某个表项，若有多个 pid 结构对应到同一个表项，这里解决冲突使用的是散列表法。这样，就能解决开始提出的第2个问题了，根据PID值怎样快速地找到task_struct结构体： 
       <ul>
        <li>首先通过 PID 计算 pid 挂接到哈希表 pid_hash[] 的表项</li> 
        <li>遍历该表项，找到 pid 结构体中 nr 值与 PID 值相同的那个 pid</li> 
        <li>再通过该 pid 结构体的 tasks 指针找到 node</li> 
        <li>最后根据内核的 container_of 机制就能找到 task_struct 结构体</li> 
       </ul></li> 
      <li>pid_map：这是一个位图，用来唯一分配PID值的结构，图中灰色表示已经分配过的值，在新建一个进程时，只需在其中找到一个为分配过的值赋给 pid 结构体的 nr，再将pid_map 中该值设为已分配标志。这也就解决了上面的第3个问题——如何快速地分配一个全局的PID。</li> 
     </ul>
     <p>至于上面的第1个问题就更加简单，已知 task_struct 结构体，根据其 pid_link 的 pid 指针找到 pid 结构体，取出其 nr 即为 PID 号。</p> 
     <h3>进程ID有类型之分</h3> 
     <p>如果考虑进程之间有复杂的关系，如线程组、进程组、会话组，这些组均有组ID，分别为 TGID、PGID、SID，所以原来的 task_struct 中pid_link 指向一个 pid 结构体需要增加几项，用来指向到其组长的 pid 结构体，相应的 struct pid 原本只需要指回其 PID 所属进程的task_struct，现在要增加几项，用来链接那些以该 pid 为组长的所有进程组内进程。数据结构如下：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="k">enum <span class="n">pid_type <span class="p">{ <span class="n">PIDTYPE_PID<span class="p">, <span class="n">PIDTYPE_PGID<span class="p">, <span class="n">PIDTYPE_SID<span class="p">, <span class="n">PIDTYPE_MAX <span class="p">}; <span class="k">struct <span class="n">task_struct <span class="p">{ <span class="c1">//... <span class="kt">pid_t <span class="n">pid<span class="p">; <span class="c1">//PID <span class="kt">pid_t <span class="n">tgid<span class="p">; <span class="c1">//thread group id <span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">group_leader<span class="p">; <span class="c1">// threadgroup leader <span class="k">struct <span class="n">pid_link <span class="n">pids<span class="p">[<span class="n">PIDTYPE_MAX<span class="p">]; <span class="c1">//... <span class="p">}; <span class="k">struct <span class="n">pid_link <span class="p">{ <span class="k">struct <span class="n">hlist_node <span class="n">node<span class="p">; <span class="k">struct <span class="n">pid <span class="o">*<span class="n">pid<span class="p">; <span class="p">}; <span class="k">struct <span class="n">pid <span class="p">{ <span class="k">struct <span class="n">hlist_head <span class="n">tasks<span class="p">[<span class="n">PIDTYPE_MAX<span class="p">]; <span class="kt">int <span class="n">nr<span class="p">; <span class="c1">//PID <span class="k">struct <span class="n">hlist_node <span class="n">pid_chain<span class="p">; <span class="c1">// pid hash 散列表结点 <span class="p">}; </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <p>上面 ID 的类型 PIDTYPE_MAX 表示 ID 类型数目。之所以不包括线程组ID，是因为内核中已经有指向到线程组的 task_struct 指针 group_leader，线程组 ID 无非就是 group_leader 的PID。</p> 
     <p>假如现在有三个进程A、B、C为同一个进程组，进程组长为A，这样的结构示意图如图3。</p> 
     <p><a href="https://github-camo.global.ssl.fastly.net/0e046752d838c084e797bb6a4874eace1e488369/687474703a2f2f692e696d6775722e636f6d2f384b6a676c51332e706e67" rel="nofollow"><img src="https://github-camo.global.ssl.fastly.net/0e046752d838c084e797bb6a4874eace1e488369/687474703a2f2f692e696d6775722e636f6d2f384b6a676c51332e706e67" alt=""></a></p> 
     <p><em>图3 增加ID类型的结构</em></p> 
     <p>关于上图有几点需要说明：</p> 
     <ul>
      <li>图中省去了 pid_hash 以及 pid_map 结构，因为第一种情况类似；</li> 
      <li>进程B和C的进程组组长为A，那么 pids[PIDTYPE_PGID] 的 pid 指针指向进程A的 pid 结构体；</li> 
      <li>进程A是进程B和C的组长，进程A的 pid 结构体的 tasks[PIDTYPE_PGID] 是一个散列表的头，它将所有以该pid 为组长的进程链接起来。</li> 
     </ul>
     <p>再次回顾本节的三个基本问题，在此结构上也很好去实现。</p> 
     <h3>增加进程PID命名空间</h3> 
     <p>若在第二种情形下再增加PID命名空间，一个进程就可能有多个PID值了，因为在每一个可见的命名空间内都会分配一个PID，这样就需要改变 pid 的结构了，如下：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="k">struct <span class="n">pid <span class="p">{ <span class="kt">unsigned <span class="kt">int <span class="n">level<span class="p">; <span class="cm">/* lists of tasks that use this pid */ <span class="k">struct <span class="n">hlist_head <span class="n">tasks<span class="p">[<span class="n">PIDTYPE_MAX<span class="p">]; <span class="k">struct <span class="n">upid <span class="n">numbers<span class="p">[<span class="mi">1<span class="p">]; <span class="p">}; <span class="k">struct <span class="n">upid <span class="p">{ <span class="kt">int <span class="n">nr<span class="p">; <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">; <span class="k">struct <span class="n">hlist_node <span class="n">pid_chain<span class="p">; <span class="p">}; </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <p>在 pid 结构体中增加了一个表示该进程所处的命名空间的层次level，以及一个可扩展的 upid 结构体。对于struct upid，表示在该命名空间所分配的进程的ID，ns指向是该ID所属的命名空间，pid_chain 表示在该命名空间的散列表。</p> 
     <p>举例来说，在level 2 的某个命名空间上新建了一个进程，分配给它的 pid 为45，映射到 level 1 的命名空间，分配给它的 pid 为 134；再映射到 level 0 的命名空间，分配给它的 pid 为289，对于这样的例子，如图4所示为其表示：</p> 
     <p><a href="https://github-camo.global.ssl.fastly.net/33008f72003c92c23874cd781e750e65b5474772/687474703a2f2f692e696d6775722e636f6d2f39775368626a422e706e67" rel="nofollow"><img src="https://github-camo.global.ssl.fastly.net/33008f72003c92c23874cd781e750e65b5474772/687474703a2f2f692e696d6775722e636f6d2f39775368626a422e706e67" alt=""></a></p> 
     <p><em>图4 增加PID命名空间之后的结构图</em></p> 
     <p>图中关于如果分配唯一的 PID 没有画出，但也是比较简单，与前面两种情形不同的是，这里分配唯一的 PID 是有命名空间的容器的，在PID命名空间内必须唯一，但各个命名空间之间不需要唯一。</p> 
     <p>至此，已经与 Linux 内核中数据结构相差不多了。</p> 
     <h2>进程ID管理函数</h2> 
     <p>有了上面的复杂的数据结构，再加上散列表等数据结构的操作，就可以写出我们前面所提到的三个问题的函数了：</p> 
     <h3>获得局部ID</h3> 
     <p>根据进程的 task_struct、ID类型、命名空间，可以很容易获得其在命名空间内的局部ID：</p> 
     <ol>
      <li> <p>获得与task_struct 关联的pid结构体。辅助函数有 task_pid、task_tgid、task_pgrp和task_session，分别用来获取不同类型的ID的pid 实例，如获取 PID 的实例：</p> 
       <div class="highlight highlight-c"> 
        <pre><span class="k">static <span class="kr">inline <span class="k">struct <span class="n">pid <span class="o">*<span class="nf">task_pid<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">task<span class="p">) <span class="p">{ <span class="k">return <span class="n">task<span class="o">-&gt;<span class="n">pids<span class="p">[<span class="n">PIDTYPE_PID<span class="p">].<span class="n">pid<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
       </div> <p>获取线程组的ID，前面也说过，TGID不过是线程组组长的PID而已，所以：</p> 
       <div class="highlight highlight-c"> 
        <pre><span class="k">static <span class="kr">inline <span class="k">struct <span class="n">pid <span class="o">*<span class="nf">task_tgid<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">task<span class="p">) <span class="p">{ <span class="k">return <span class="n">task<span class="o">-&gt;<span class="n">group_leader<span class="o">-&gt;<span class="n">pids<span class="p">[<span class="n">PIDTYPE_PID<span class="p">].<span class="n">pid<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
       </div> <p>而获得PGID和SID，首先需要找到该线程组组长的task_struct，再获得其相应的 pid：</p> 
       <div class="highlight highlight-c"> 
        <pre><span class="k">static <span class="kr">inline <span class="k">struct <span class="n">pid <span class="o">*<span class="nf">task_pgrp<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">task<span class="p">) <span class="p">{ <span class="k">return <span class="n">task<span class="o">-&gt;<span class="n">group_leader<span class="o">-&gt;<span class="n">pids<span class="p">[<span class="n">PIDTYPE_PGID<span class="p">].<span class="n">pid<span class="p">; <span class="p">} <span class="k">static <span class="kr">inline <span class="k">struct <span class="n">pid <span class="o">*<span class="nf">task_session<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">task<span class="p">) <span class="p">{ <span class="k">return <span class="n">task<span class="o">-&gt;<span class="n">group_leader<span class="o">-&gt;<span class="n">pids<span class="p">[<span class="n">PIDTYPE_SID<span class="p">].<span class="n">pid<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
       </div> </li> 
      <li> <p>获得 pid 实例之后，再根据 pid 中的numbers 数组中 uid 信息，获得局部PID。</p> 
       <div class="highlight highlight-c"> 
        <pre><span class="kt">pid_t <span class="nf">pid_nr_ns<span class="p">(<span class="k">struct <span class="n">pid <span class="o">*<span class="n">pid<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">) <span class="p">{ <span class="k">struct <span class="n">upid <span class="o">*<span class="n">upid<span class="p">; <span class="kt">pid_t <span class="n">nr <span class="o">= <span class="mi">0<span class="p">; <span class="k">if <span class="p">(<span class="n">pid <span class="o">&amp;&amp; <span class="n">ns<span class="o">-&gt;<span class="n">level <span class="o">&lt;= <span class="n">pid<span class="o">-&gt;<span class="n">level<span class="p">) <span class="p">{ <span class="n">upid <span class="o">= <span class="o">&amp;<span class="n">pid<span class="o">-&gt;<span class="n">numbers<span class="p">[<span class="n">ns<span class="o">-&gt;<span class="n">level<span class="p">]; <span class="k">if <span class="p">(<span class="n">upid<span class="o">-&gt;<span class="n">ns <span class="o">== <span class="n">ns<span class="p">) <span class="n">nr <span class="o">= <span class="n">upid<span class="o">-&gt;<span class="n">nr<span class="p">; <span class="p">} <span class="k">return <span class="n">nr<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
       </div> <p>这里值得注意的是，由于PID命名空间的层次性，父命名空间能看到子命名空间的内容，反之则不能，因此，函数中需要确保当前命名空间的level 小于等于产生局部PID的命名空间的level。<br>除了这个函数之外，内核还封装了其他函数用来从 pid 实例获得 PID 值，如 pid_nr、pid_vnr 等。在此不介绍了。</p> </li> 
     </ol>
     <p>结合这两步，内核提供了更进一步的封装，提供以下函数：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="kt">pid_t <span class="nf">task_pid_nr_ns<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">tsk<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">); <span class="kt">pid_t <span class="nf">task_tgid_nr_ns<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">tsk<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">); <span class="kt">pid_t <span class="nf">task_pigd_nr_ns<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">tsk<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">); <span class="kt">pid_t <span class="nf">task_session_nr_ns<span class="p">(<span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">tsk<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <p>从函数名上就能推断函数的功能，其实不外于封装了上面的两步。</p> 
     <h3>查找进程task_struct</h3> 
     <p>根据局部ID、以及命名空间，怎样获得进程的task_struct结构体呢？也是分两步：</p> 
     <ol>
      <li> <p>获得 pid 实体。根据局部PID以及命名空间计算在 pid_hash 数组中的索引，然后遍历散列表找到所要的 upid， 再根据内核的 container_of 机制找到 pid 实例。代码如下：</p> 
       <div class="highlight highlight-c"> 
        <pre><span class="k">struct <span class="n">pid <span class="o">*<span class="nf">find_pid_ns<span class="p">(<span class="kt">int <span class="n">nr<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">) <span class="p">{ <span class="k">struct <span class="n">hlist_node <span class="o">*<span class="n">elem<span class="p">; <span class="k">struct <span class="n">upid <span class="o">*<span class="n">pnr<span class="p">; <span class="c1">//遍历散列表 <span class="n">hlist_for_each_entry_rcu<span class="p">(<span class="n">pnr<span class="p">, <span class="n">elem<span class="p">, <span class="o">&amp;<span class="n">pid_hash<span class="p">[<span class="n">pid_hashfn<span class="p">(<span class="n">nr<span class="p">, <span class="n">ns<span class="p">)], <span class="n">pid_chain<span class="p">) <span class="c1">//pid_hashfn() 获得hash的索引 <span class="k">if <span class="p">(<span class="n">pnr<span class="o">-&gt;<span class="n">nr <span class="o">== <span class="n">nr <span class="o">&amp;&amp; <span class="n">pnr<span class="o">-&gt;<span class="n">ns <span class="o">== <span class="n">ns<span class="p">) <span class="c1">//比较 nr 与 ns 是否都相同 <span class="k">return <span class="n">container_of<span class="p">(<span class="n">pnr<span class="p">, <span class="k">struct <span class="n">pid<span class="p">, <span class="c1">//根据container_of机制取得pid 实体 <span class="n">numbers<span class="p">[<span class="n">ns<span class="o">-&gt;<span class="n">level<span class="p">]); <span class="k">return <span class="nb">NULL<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
       </div> </li> 
      <li> <p>根据ID类型取得task_struct 结构体。</p> 
       <div class="highlight highlight-c"> 
        <pre><span class="k">struct <span class="n">task_struct <span class="o">*<span class="nf">pid_task<span class="p">(<span class="k">struct <span class="n">pid <span class="o">*<span class="n">pid<span class="p">, <span class="k">enum <span class="n">pid_type <span class="n">type<span class="p">) <span class="p">{ <span class="k">struct <span class="n">task_struct <span class="o">*<span class="n">result <span class="o">= <span class="nb">NULL<span class="p">; <span class="k">if <span class="p">(<span class="n">pid<span class="p">) <span class="p">{ <span class="k">struct <span class="n">hlist_node <span class="o">*<span class="n">first<span class="p">; <span class="n">first <span class="o">= <span class="n">rcu_dereference_check<span class="p">(<span class="n">hlist_first_rcu<span class="p">(<span class="o">&amp;<span class="n">pid<span class="o">-&gt;<span class="n">tasks<span class="p">[<span class="n">type<span class="p">]), <span class="n">lockdep_tasklist_lock_is_held<span class="p">()); <span class="k">if <span class="p">(<span class="n">first<span class="p">) <span class="n">result <span class="o">= <span class="n">hlist_entry<span class="p">(<span class="n">first<span class="p">, <span class="k">struct <span class="n">task_struct<span class="p">, <span class="n">pids<span class="p">[(<span class="n">type<span class="p">)].<span class="n">node<span class="p">); <span class="p">} <span class="k">return <span class="n">result<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
       </div> </li> 
     </ol>
     <p>内核还提供其它函数用来实现上面两步：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="k">struct <span class="n">task_struct <span class="o">*<span class="nf">find_task_by_pid_ns<span class="p">(<span class="kt">pid_t <span class="n">nr<span class="p">, <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">); <span class="k">struct <span class="n">task_struct <span class="o">*<span class="nf">find_task_by_vpid<span class="p">(<span class="kt">pid_t <span class="n">vnr<span class="p">); <span class="k">struct <span class="n">task_struct <span class="o">*<span class="nf">find_task_by_pid<span class="p">(<span class="kt">pid_t <span class="n">vnr<span class="p">); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <p>具体函数实现的功能也比较简单。</p> 
     <h3>生成唯一的PID</h3> 
     <p>内核中使用下面两个函数来实现分配和回收PID的：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="k">static <span class="kt">int <span class="nf">alloc_pidmap<span class="p">(<span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">pid_ns<span class="p">); <span class="k">static <span class="kt">void <span class="nf">free_pidmap<span class="p">(<span class="k">struct <span class="n">upid <span class="o">*<span class="n">upid<span class="p">); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <p>在这里我们不关注这两个函数的实现，反而应该关注分配的 PID 如何在多个命名空间中可见，这样需要在每个命名空间生成一个局部ID，函数 alloc_pid 为新建的进程分配PID，简化版如下：</p> 
     <div class="highlight highlight-c"> 
      <pre><span class="k">struct <span class="n">pid <span class="o">*<span class="nf">alloc_pid<span class="p">(<span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">ns<span class="p">) <span class="p">{ <span class="k">struct <span class="n">pid <span class="o">*<span class="n">pid<span class="p">; <span class="k">enum <span class="n">pid_type <span class="n">type<span class="p">; <span class="kt">int <span class="n">i<span class="p">, <span class="n">nr<span class="p">; <span class="k">struct <span class="n">pid_namespace <span class="o">*<span class="n">tmp<span class="p">; <span class="k">struct <span class="n">upid <span class="o">*<span class="n">upid<span class="p">; <span class="n">tmp <span class="o">= <span class="n">ns<span class="p">; <span class="n">pid<span class="o">-&gt;<span class="n">level <span class="o">= <span class="n">ns<span class="o">-&gt;<span class="n">level<span class="p">; <span class="c1">// 初始化 pid-&gt;numbers[] 结构体 <span class="k">for <span class="p">(<span class="n">i <span class="o">= <span class="n">ns<span class="o">-&gt;<span class="n">level<span class="p">; <span class="n">i <span class="o">&gt;= <span class="mi">0<span class="p">; <span class="n">i<span class="o">--<span class="p">) <span class="p">{ <span class="n">nr <span class="o">= <span class="n">alloc_pidmap<span class="p">(<span class="n">tmp<span class="p">); <span class="c1">//分配一个局部ID <span class="n">pid<span class="o">-&gt;<span class="n">numbers<span class="p">[<span class="n">i<span class="p">].<span class="n">nr <span class="o">= <span class="n">nr<span class="p">; <span class="n">pid<span class="o">-&gt;<span class="n">numbers<span class="p">[<span class="n">i<span class="p">].<span class="n">ns <span class="o">= <span class="n">tmp<span class="p">; <span class="n">tmp <span class="o">= <span class="n">tmp<span class="o">-&gt;<span class="n">parent<span class="p">; <span class="p">} <span class="c1">// 初始化 pid-&gt;task[] 结构体 <span class="k">for <span class="p">(<span class="n">type <span class="o">= <span class="mi">0<span class="p">; <span class="n">type <span class="o">&lt; <span class="n">PIDTYPE_MAX<span class="p">; <span class="o">++<span class="n">type<span class="p">) <span class="n">INIT_HLIST_HEAD<span class="p">(<span class="o">&amp;<span class="n">pid<span class="o">-&gt;<span class="n">tasks<span class="p">[<span class="n">type<span class="p">]); <span class="c1">// 将每个命名空间经过哈希之后加入到散列表中 <span class="n">upid <span class="o">= <span class="n">pid<span class="o">-&gt;<span class="n">numbers <span class="o">+ <span class="n">ns<span class="o">-&gt;<span class="n">level<span class="p">; <span class="k">for <span class="p">( <span class="p">; <span class="n">upid <span class="o">&gt;= <span class="n">pid<span class="o">-&gt;<span class="n">numbers<span class="p">; <span class="o">--<span class="n">upid<span class="p">) <span class="p">{ <span class="n">hlist_add_head_rcu<span class="p">(<span class="o">&amp;<span class="n">upid<span class="o">-&gt;<span class="n">pid_chain<span class="p">, <span class="o">&amp;<span class="n">pid_hash<span class="p">[<span class="n">pid_hashfn<span class="p">(<span class="n">upid<span class="o">-&gt;<span class="n">nr<span class="p">, <span class="n">upid<span class="o">-&gt;<span class="n">ns<span class="p">)]); <span class="n">upid<span class="o">-&gt;<span class="n">ns<span class="o">-&gt;<span class="n">nr_hashed<span class="o">++<span class="p">; <span class="p">} <span class="k">return <span class="n">pid<span class="p">; <span class="p">} </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre> 
     </div> 
     <hr>
     <p><strong>参考资料</strong></p> 
     <ul>
      <li>深入Linux 内核架构（以前不觉得这本书写得多好，现在倒发现还不错，本文很多都是照抄上面的）</li> 
      <li>周徐达师弟的PPT（让我受益匪浅的一次讨论，周由浅入深告诉我们该数据结构是如何设计出来的，本文主思路就是按照该PPT，在此&nbsp;<strong>特别感谢</strong>！）</li> 
     </ul>
    </div> 
   </div> 
   <div> 
    <p align="center"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow"><img style="border-width:0;" src="https://yqfile.alicdn.com/img_80fb4a8b9dd7c600afda07b3d3c5efa4.png" alt="Creative Commons License"></a></p> 本博客的内容如果没有标注转载字样，均属个人原创！欢迎学习交流，如果觉得有价值，欢迎转载，转载请注明出处，谢谢！
    <hr>
    <p>邮箱：<a href="mailto:haifenglinying@yahoo.cn" rel="nofollow">haifenglinying#yahoo.cn (#-&gt;@) </a></p> 
    <p>个人主页：<a href="http://www.hazirguo.com" rel="nofollow">www.hazirguo.com</a></p> 
    <a href="http://weibo.com/u/1678478585?s=6uyXnP" rel="nofollow"><img src="https://yqfile.alicdn.com/img_24d61374d512e2af8e440245790e7f09.png" alt=""></a> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
