<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Net中的AOP系列之《拦截位置》 « NotBeCN</title>
  <meta name="description" content="             本篇目录              位置拦截     .Net中的字段和属性     PostSharp位置拦截     真实案例——懒加载     .Net中的懒加载     使用AOP实现懒加载     如何懒加载字段？     真实案例——INotifyPropertyChange...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/13/weixin_34087503_90134930.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Net中的AOP系列之《拦截位置》</h1>
    <p class="post-meta">Dec 13, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);">本篇目录</h2> 
   <ul>
    <li style="list-style:disc;"> </li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>位置拦截</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>.Net中的字段和属性</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>PostSharp位置拦截</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>真实案例——懒加载</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>.Net中的懒加载</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>使用AOP实现懒加载</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>如何懒加载字段？</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>真实案例——INotifyPropertyChanged</b></span></font></li> 
    <li style="list-style:disc;"><font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b>小结</b></span></font></li> 
    <li style="list-style:disc;"> <font color="#4183c4"><span style="font-size:15px;line-height:25px;"><b> </b></span></font><p style="color:rgb(73,73,73);font-weight:normal;"><b>本节的源码本人已托管于Coding上：<strong><a href="https://coding.net/u/farb/p/AbpPractice/git/tree/master/AOPPractice/LocationInterception/LocationInterception" rel="nofollow" style="color:rgb(65,131,196);text-decoration:none;">点击查看</a></strong>。</b></p> <b> </b><p style="color:rgb(73,73,73);font-weight:normal;"><b>本系列的实验环境：VS 2013 Update 5（建议最好使用集成了Nuget的VS版本，VS Express版也够用），安装了PostSharp。</b></p> <b> </b> </li> 
    <li style="list-style:disc;"> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">至今，我们的关注点都是集中在方法上，本节，就看一下位置，这里的位置指的是字段或属性。位置拦截是AOP框架不太通用的功能，因此，本节大多数的例子都是使用支持位置的PostSharp框架，此外，这节还会看到一个特殊的AOP工具（与常见的AOP框架截然不同），叫做<strong>PropertyChanged.Fody</strong>。</p> <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="locationInterception"></a>位置拦截</h2> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">也许很多人没有听过C#中有位置这一说，其实，一个字段或者一个属性都是一个位置。字段和属性是OOP中常见的东西，它们为<strong>类</strong>提供数据和结构。下面简单复习一下，觉得没问题的同学可以直接跳过，记住：属性只是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">getter/setter</code>方法的语法糖。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="fields" style="color:rgb(224,130,131);"></a>.Net中的字段和属性</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">字段是类的成员。它们可以声明为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">public,private,protected,internal</code>等等，这样就可以限制访问级别了（默认是private）。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">通常，如果封装很重要的话，就不会使用public字段，因此，字段通常被设置成private，然后通过访问器方法在类外面使用该字段。如果有一个private的_balance（余额）字段，那么只能通过其它对象调用Deposit（存款）或者Withdrawal（取款）方法来改变这个字段的值：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">BankAccount</span> {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> _balance;
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">SetBalance</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> amount</span>) </span>{
        _balance = amount;
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> <span class="hljs-title" style="color:rgb(163,21,21);">GetBalance</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> amount</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _balance;
    }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在C#中，我们可以使用属性语法（get 和set ）来减少代码量，下面的代码中，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Balance</code>属性封装了一个私有字段<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">_balance</code>:</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">BankAccount</span> {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> _balance;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">decimal</span> Balance {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _balance;
        }
        <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span> {
            _balance = <span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>;
        }
    }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">get 和set</code>都是可选的：如果不需要设置一个字段的值，那么就不需要写setter，getter同样如此。但是，这后面，.Net编译器帮我们创建了方法，如果使用反编译工具如ILSpy看一下IL代码，就会发现编译器创建了一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">decimal get_Balance()</code>方法和一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">void set_Balance(decimal)</code>方法：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">.class <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> auto ansi beforefieldinit MyBankingProject.BankAccount
    extends [mscorlib]System.Object
{
    .field <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> valuetype [mscorlib]System.Decimal _balance
    .method <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> hidebysig specialname
        instance valuetype [mscorlib]System.<span class="hljs-function">Decimal <span class="hljs-title" style="color:rgb(163,21,21);">get_Balance</span> (<span class="hljs-params"></span>) cil managed </span>{
              <span class="hljs-comment" style="color:#008000;">//此处省略若干IL代码</span>
            }
    .<span class="hljs-function">method <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> hidebysig specialname instance <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">set_Balance</span> (<span class="hljs-params"> valuetype [mscorlib]System.Decimal <span class="hljs-string" style="color:rgb(163,21,21);">'value'</span> </span>) cil managed </span>{
           <span class="hljs-comment" style="color:#008000;">//此处省略若干IL代码</span>
            }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">自动属性是在C#2.0中引入的，这个工具让语法糖变得更甜了，我们甚至不需要显式创建字段就可以创建一个属性，如下：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyClass</span> {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> MyProperty {<span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>;}
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当使用自动属性时，必须同时使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">get和set</code>,但是可以使用不同的访问级别。比如，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">get</code>可以设置成公共的，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">set</code>可以设置成私有的。<br> 对于我们.Net开发者来说，这并不是什么新鲜事儿，因为我们几乎每天都会使用这些，但是越是最常用的东西，通常你也认为最理所当然，因此，在深入涉及位置拦截的AOP代码之前有必要重温一下细节问题。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="postsharp" style="color:rgb(224,130,131);"></a>PostSharp位置拦截</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">之前的教程我们知道了，AOP工具可以拦截方法，那么从上面我们又知道，属性的底层就是方法，因此，我们可以猜想可以在属性上使用方法拦截切面。事实上这是可行的，可以使用PostSharp或Castle DynamicProxy在属性上创建方法拦截。下面就是一个使用PostSharp在属性上创建方法拦截的控制台例子：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestClass</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> TestProperty
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>;
        [MyMethodAspect]
        <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>;<span class="hljs-comment" style="color:#008000;">//在一个属性的setter上使用方法拦截切面</span>
    }
}

[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyMethodAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">MethodInterceptionAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnInvoke</span>(<span class="hljs-params">MethodInterceptionArgs args</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"这条语句来自自定义方法拦截切面"</span>);
        args.Proceed();
    }
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> test=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TestClass();
        test.TestProperty = <span class="hljs-string" style="color:rgb(163,21,21);">"测试属性"</span>;<span class="hljs-comment" style="color:#008000;">//这里会调用属性的setter方法</span>

        Console.Read();
    }
}


</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">效果如下：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160825002902370-389343008.png" style="border:0px;" alt="577014-20160825002902370-389343008.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">但是这样使用有几个问题：</p> 
     <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
      <li style="list-style:decimal;">笨拙。可能必须写两个切面，一个给setter，一个给getter。</li> 
      <li style="list-style:decimal;">只能给属性使用切面，字段的底层不是方法，所以行不通。</li> 
     </ol><p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">没关系，PostSharp给我们提供了一个更方便的方法，只需要写一个类就可以处理getting和setting，还允许为字段和属性编写切面。这就是PostSharp中的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LocationInterceptionAspect</code>,下面的例子和上面的一样，只是这次使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LocationInterceptionAspect</code>:</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyLocationAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">LocationInterceptionAspect</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnGetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"这条语句来自位置拦截的{0}方法"</span>,MethodBase.GetCurrentMethod());
        args.ProceedGetValue();
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"这条语句来自位置拦截的{0}方法"</span>, MethodBase.GetCurrentMethod());
        args.ProceedSetValue();
    }
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">TestClass2</span>
{
    [MyLocationAspect]
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> TestProperty
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
    <span class="hljs-comment" style="color:#008000;">//var test=new TestClass();</span>
    <span class="hljs-comment" style="color:#008000;">//test.TestProperty = "测试属性";</span>

    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> test2=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> TestClass2();
    test2.TestProperty = <span class="hljs-string" style="color:rgb(163,21,21);">"位置拦截测试"</span>;
    Console.WriteLine(test2.TestProperty);
    Console.Read();
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">Main方法中，先是给属性赋值，所以会被<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MyLocationAspect</code>的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSetValue</code>方法拦截到，然后打印<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">test2.TestProperty</code>时会被<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnGetValule</code>方法拦截，因此运行结果如下：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160825004226308-321332668.png" style="border:0px;" alt="577014-20160825004226308-321332668.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这里新出现的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.ProceedSetValue();</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.ProceedGetValue();</code>和之前的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.Proceed();</code>是一样的道理，是继续执行属性方法（属性的本质就是方法）的意思。</p> <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="lazyLoad"></a>真实案例——懒加载</h2> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">懒加载的目的就是延迟一些耗时操作的执行，相反，预加载的目的是一个或多个操作在得到结果前每次都要执行，以防需要这些操作。NHibernate和EF都是用在持久层的数据库工具，当使用懒加载从DB中检索实体时，它们只会拉取你需要的实体而不会拉取相关实体，相反，使用预加载，它们就会把你需要的实体（比如A），和该实体相关的实体（B），以及和B相关的实体（C）等等都会加载出来。此时，就需要在性能和方便之间进行权衡了。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="netLazyLoad" style="color:rgb(224,130,131);"></a>.Net中的懒加载</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">懒加载的一种方式是使用具有字段的属性来实现。当首次使用get时，会创建一个新对象，后续再使用字段时都会像以往那样返回字段。如下所示：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor _myProperty;
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> SlowConstructor MyProperty {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_myProperty == <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
     _myProperty = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SlowConstructor();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _myProperty;
    }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">细心的你可能会发现这不是线程安全的代码，如果这是一个关注点的话，就需要放一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">lock</code>语句。这里使用双重检查的锁机制再合适不过了，因为在第一次检查和lock之间可能会发生<strong>竞争情况</strong>（race condition）：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _syncRoot = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span>();
SlowConstructor _myProperty;
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> SlowConstructor MyProperty {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_myProperty == <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>) 
          <span class="hljs-keyword" style="color:rgb(0,0,255);">lock</span>(_syncRoot)
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_myProperty == <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
              _myProperty = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SlowConstructor();<span class="hljs-comment" style="color:#008000;">//在第一次if检查和lock之间可能有另一个线程正在给字段赋值</span>
        <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _myProperty;
    }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这样，就可以使用懒加载了。你可以像平时那样访问属性，如果不用它的话，那么SlowConstructor永远都不会运行。也可以使用工厂或者IoC工具代替new来实例化对象。但无论怎样，lock，两次if检查和字段都始终是保持不变的。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从.NET 4.0开始，.Net Framework提供了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">System.Lazy&lt;T&gt;</code>,它是一个方便类，可以使用更少的代码完成和上面相同的事情。代码如下：</p> <pre class="c#"><code class="hljs coffeescript" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">var lazy = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> Lazy&lt;SlowConstructor&gt;(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SlowConstructor());
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">工厂代码是以Lambda表达式（匿名函数）传入的，这就告诉<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Lazy</code>首次访问时使用这个代码来实例化对象，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">System.Lazy&lt;T&gt;</code>默认也是线程安全的，因此它封装了所有的lock代码。但是，跟前面那个例子不同的是，这样字段就成了Lazy类型，而不是SlowConstructor类型，要使用SlowConstructor对象的话，还要多个步骤：<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor c = MyProperty.Value;</code>。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，想要使用懒加载时有两种选择，第一种有许多样板代码和字段，第二种使用Lazy，所有的样板代码是没有了，但是必须通过Value属性来获得懒加载对象。下面使用AOP来结合一下这两种方法的优点。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="aopLazyLoad" style="color:rgb(224,130,131);"></a>使用AOP实现懒加载</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">结合上面两种方法的优点，那就是可以直接访问属性（不需要通过Value属性），而且也没有很多的样板代码，就像下面这个样子：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[LazyLoadGetter]<span class="hljs-comment" style="color:#008000;">//使用特性告诉PostSharp这个属性是懒加载属性</span>
<span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> SlowConstructor MyProperty {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span>(<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SlowConstructor() ); }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">get</code>方法体内包含了懒加载的工厂，直到get执行时才会调用，后续的get调用也会使用首次操作的结果。<br> 下面传创建一个控制台应用，命名为<strong>LazyLoadingDemo</strong>，安装PostSharp。定义一个模拟耗时的操作<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>(比如一个调用了一个很慢的web service等)：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">SlowConstructor</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">SlowConstructor</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"正在初始化SlowConstructor,请稍等..."</span>);
        Thread.Sleep(<span class="hljs-number">5000</span>);<span class="hljs-comment" style="color:#008000;">//睡5秒，模拟耗时操作</span>
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoSomething</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}:正在处理一些业务..."</span>,DateTime.Now);
    }
}
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在Main方法种定义该类的一个属性，并连续调用该类的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DoSomething</code>方法：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">Program</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> SlowConstructor SlowService
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SlowConstructor();}
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
        SlowService.DoSomething();
        SlowService.DoSomething();

        Console.Read();
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这样写代码的话就应该优化了，因为每次调用属性的get方法时都会重新实例化<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>对象。<br> 执行结果很明显，如下：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160827110410429-1803257901.png" style="border:0px;" alt="577014-20160827110410429-1803257901.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">但我们这里计划的是懒加载这个属性，不需要添加所有的字段、双重检查锁，或切换使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Lazy&lt;T&gt;</code>，这里我们可以创建一个切面，该切面继承PostSharp的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LocationInterceptionAspect</code>,然后把自定义的切面当作特性用在需要懒加载的属性上即可：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyLazyLoadingGetterAspect</span> : <span class="hljs-title" style="color:rgb(163,21,21);">LocationInterceptionAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _backingField;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _syncRoot = <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span>();
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnGetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_backingField == <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">lock</span> (_syncRoot)
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_backingField == <span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
                {
                    args.ProceedGetValue();<span class="hljs-comment" style="color:#008000;">//继续像往常那样执行get</span>
                    _backingField = args.Value;<span class="hljs-comment" style="color:#008000;">//将get获得的属性值保存到支持字段中</span>
                }
            }
            args.Value = _backingField;<span class="hljs-comment" style="color:#008000;">//因为支持字段中已经有值了，直接赋值即可</span>
        }

    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然切面中的代码和之前的原始代码很类似，但这是在切面里面，切面可以用在很多不同的地方，在需要使用的地方只需要像特性那样使用就可以了，很方便。<br> 首次调用get时，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnGetValue</code>会被调用，一开始支持字段<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">_backingField=null</code>,因此需要像之前那样加锁并双重检查，然后<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.ProceedGetValue()</code>告诉PostSharp继续运行get中的代码，这时，就会创建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>的实例，然后，就会使用get执行的结果填充<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.Value</code>。然后我们把该值存入支持字段中，方便下次使用。<br> 之后，每个后续调用，PostSharp都会将支持字段的值设置给<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.Value</code>，因此<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.ProceedGetValue()</code>只会在首次调用，这样，就不需要每次都实例化类了。有了这个切面，我们就有了和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Lazy&lt;T&gt;</code>类似的语法了，而且可以直接访问属性。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">直接在需要懒加载的属性上以特性的方式使用：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[MyLazyLoadingGetterAspect]
<span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> SlowConstructor SlowService
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> SlowConstructor();}
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">执行结果如下：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160827121425069-819832734.png" style="border:0px;" alt="577014-20160827121425069-819832734.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">从上面的运行结果可以看出，只创建了1个实例，因而，大大提高了性能。<br> 我们都知道，字段没有<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">get</code>，因此对字段进行懒加载稍微有点不同。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;"> <a name="lazyLoadField" style="color:rgb(224,130,131);"></a>如何懒加载字段？</h3> <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">使用反射的Activator</h4> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">字段是类级别的变量，这就意味着我们不能找到一种方法显式指定应该如何懒加载一个字段。假设我们以隐式的方式懒加载指定的字段，首先，编写代码如下，这次用的不是属性，而是字段：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 2.0 懒加载字段</span>

<span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> SlowConstructor SlowService;
<span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
    SlowService.DoSomething();
    SlowService.DoSomething();

    Console.Read();
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">最简单的做法就是使用反射的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Activator</code>创建字段类型的实例，下面我们创建一个继承了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LocationInterceptionAspect</code>的切面，然后用于该字段：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 2.0 懒加载字段</span>
[MyLazyLoadingFieldAspect]
<span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> SlowConstructor SlowService;
<span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
    SlowService.DoSomething();
    SlowService.DoSomething();

    Console.Read();
}

[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">sealed</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyLazyLoadingFieldAspect</span> : <span class="hljs-title" style="color:rgb(163,21,21);">LocationInterceptionAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _backingField;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _syncRoot=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span>();
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnGetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_backingField==<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">lock</span> (_syncRoot)
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_backingField==<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
                {
                    _backingField = Activator.CreateInstance(args.Location.LocationType);<span class="hljs-comment" style="color:#008000;">//Activator会使用位置的类型创建一个新对象</span>
                }
            }
        }
        args.Value = _backingField;
    }

}
</code></pre> 
     <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
      <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);">反射之Activator</h4> 
      <p>反射是位于<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">System.Reflection</code>命名空间下的一系列工具，它允许我们编写一些在程序运行时进行读取或者生成代码的代码。<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Activator</code>可以创建运行时中对象的新实例，这在直到运行时才知道该实例化哪种类型的对象时很有用。上面的切面可以在任何类型的字段上重复使用，但是这种灵活性也带来了性能损耗，因此，确保必要的时候才使用反射。</p> 
     </blockquote> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">上面的代码和之前懒加载属性切面的代码很相似，但是我们这里应该注意的是不同点，比如，这里没有使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.ProceedGetValue()</code>,而是使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Activator.CreateInstance()</code>。PostSharp的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.Location.LocationType</code>可以告诉我们被拦截位置的类型<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Type</code>(字段和属性都可以),有了这个信息，我们就可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">System.Activator</code>创建那个类型的实例了。和之前一样，将结果存到支持字段_backingField中。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这种方法适用面很窄，更加现实的方式是使用工厂，服务定位器或者IoC容器取代<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Activator</code>。比如，如果使用的是<strong>StructureMap</strong>（一个流行的.Net IoC工具），那么可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ObjectFactory.GetInstance</code>代替<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Activator</code>，这种方法可以让我们对更复杂的依赖（即，没有无参构造函数的类）使用懒加载。</p> <h4 style="font-size:14px;color:rgb(205,73,0);border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgb(205,73,0);font-family:'Microsoft Yahei', Simsun, Arial;line-height:25px;">使用IoC工具</h4> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">假设<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>只有一个构造函数，并且该构造函数有一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IMyService</code>参数，修改之后的代码如下：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">SlowConstructor</span>
{
    <span class="hljs-comment" style="color:#008000;">//public SlowConstructor()</span>
    <span class="hljs-comment" style="color:#008000;">//{</span>
    <span class="hljs-comment" style="color:#008000;">// Console.WriteLine("正在初始化SlowConstructor,请稍等...");</span>
    <span class="hljs-comment" style="color:#008000;">// Thread.Sleep(5000);</span>
    <span class="hljs-comment" style="color:#008000;">//}</span>
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> IMyService _myService;
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">SlowConstructor</span>(<span class="hljs-params">IMyService myService</span>)<span class="hljs-comment" style="color:#008000;">//只有一个构造函数，并且需要一个参数</span> </span>{
        _myService = myService;
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"正在初始化SlowConstructor,请稍等..."</span>);
        Thread.Sleep(<span class="hljs-number">5000</span>);
    }
    <span class="hljs-comment" style="color:#008000;">//public void DoSomething()</span>
    <span class="hljs-comment" style="color:#008000;">//{</span>
    <span class="hljs-comment" style="color:#008000;">// Console.WriteLine("{0}:正在处理一些业务...",DateTime.Now);</span>
    <span class="hljs-comment" style="color:#008000;">//}</span>

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoSomething</span>(<span class="hljs-params"></span>) </span>{
        _myService.DoSomething();
    }
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">interface</span> <span class="hljs-title" style="color:rgb(163,21,21);">IMyService</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoSomething</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MyService</span>:<span class="hljs-title" style="color:rgb(163,21,21);">IMyService</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">DoSomething</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}:正在处理一些业务..."</span>, DateTime.Now);
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在切面中，仍然可以使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Activator</code>创建对象，但是同时必须创建该对象依赖的对象，在上面的代码中就是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MySevice</code>,在一个真实应用中，依赖链可能会更长或更复杂，因此，一般都会把这个任务交给一个工具，比如<strong>StructureMap</strong>。下面的代码是如何在控制台的Main方法中初始化<strong>StructureMap</strong>，其它的IoC工具都是类似的【下一个系列教程就是关于DI/IoC的】：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">region</span> 2.0 懒加载字段</span>
<span class="hljs-comment" style="color:#008000;">//[MyLazyLoadingFieldAspect]</span>
[LazyLoadStructureMapAspect]
<span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> SlowConstructor SlowService;
<span class="hljs-meta" style="color:rgb(43,145,175);">#<span class="hljs-meta-keyword">endregion</span></span>
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">Main</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] args</span>) </span>{
    <span class="hljs-comment" style="color:#008000;">//ObjectFactory.Initialize告诉StructureMap使用哪个实现</span>
    ObjectFactory.Initialize(cfg =&gt;
    {
        cfg.For&lt;IMyService&gt;().Use&lt;MyService&gt;();<span class="hljs-comment" style="color:#008000;">//当调用IMyService的构造函数时，使用MyService作为实现</span>
        cfg.For&lt;SlowConstructor&gt;().Use&lt;SlowConstructor&gt;();<span class="hljs-comment" style="color:#008000;">//这行代码可选，StructureMap会自动绑定</span>
    });
    SlowService.DoSomething();
    SlowService.DoSomething();

    Console.Read();
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在依赖配置好了，并且给字段添加了新的特性切面。这里简单介绍一下StructureMap的依赖配置，下一个系列教程会详细讲解哦！首先使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ObjectFactory.Initialize</code>【已经过时了，在新版本已经不建议使用这种方式】指定依赖，如果StructureMap请求<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">IMyService</code>的实现，那么就会返回<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">MyService</code>对象，如果请求的是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>,那么就会使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>。更重要的是，当创建<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">SlowConstructor</code>的实例时，它会识别出SlowConstructor的构造函数有一个IMyService类型的参数，因此会自动使用配置的依赖并传给该构造函数MyService的新实例。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">下面我们需要创建一个新切面，和之前使用Activator的例子看起来很像，但是这次使用了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">ObjectFactory.GetInstance</code>而不是Activator，这样StructureMap会自动提供需要的对象：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">LazyLoadStructureMapAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">LocationInterceptionAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _backingField;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">readonly</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> _syncRoot=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">object</span>();
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnGetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_backingField==<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">lock</span> (_syncRoot)
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_backingField==<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
                {
                    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> locationType = args.Location.PropertyInfo.PropertyType;
                    _backingField= ObjectFactory.GetInstance(locationType);
                }

            }
        }
        args.Value = _backingField;
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">执行结果和之前的一样，只不过这次的例子更加具有现实意义，因为类有关于接口的依赖，配置这些依赖使用了IoC工具。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160827194028429-1887984468.png" style="border:0px;" alt="577014-20160827194028429-1887984468.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">适当的使用懒加载可以改善耗时操作的性能，AOP通过拦截访问的字段和属性以及将样板代码移到单独的切面类中使得对位置进行懒加载不再那么痛苦。字段或属性可能会遇到样板代码问题的其它地方在可响应的GUI。</p> <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="INotifyPropertyChanged"></a>真实案例——INotifyPropertyChanged</h2> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">在桌面应用中使用INotifyPropertyChanged</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">首先创建一个WPF应用，搭建的界面如下图所示：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160828223708012-86253325.png" style="border:0px;" alt="577014-20160828223708012-86253325.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">需求是，当输入进行输入时，需要将姓和名两个文本框中的内容连接起来填充到姓名那行所在的Label控件上。在WPF中一种普遍的做法是创建一个封装数据（姓和名）和导出数据（姓名）的视图模型。创建视图模型<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">NameViewModel</code>如下：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NameViewModel</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FirstName { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> LastName { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FullName
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.Format(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}{1}"</span>, FirstName, LastName); }
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">还需要做以下几步才能实现需求：</p> 
     <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
      <li style="list-style:decimal;">将该视图模型的一个实例绑定到WPF窗体的数据上下文<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DataContext</code>上，这可以在xaml的代码后置类中对窗体的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">DataContext</code>属性赋值；</li> 
      <li style="list-style:decimal;">将该视图模型的每个属性分别绑定到各自的文本框和Label控件上，这可以通过分别将视图模型的属性绑定TextBox和Label控件的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Text</code>和<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Content</code>属性上完成；</li> 
      <li style="list-style:decimal;">告诉两个文本框，无论何时文本框内容变化时，都应该触发一个更新，因此，修改<strong>姓和名</strong>所对应的文本框，指定Binding中的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">UpdateSourceTriger</code>为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PropertyChanged</code>，目的是当用户输入时，告诉它们更新源数据。</li> 
      <li style="list-style:decimal;">让视图模型类NameViewModel实现<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">INotifyPropertyChanged</code>,实现这个接口需要做的唯一一件事就是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PropertyChangedEventHandler</code>类型的事件。由于已经将绑定添加到了文本框上，WPF会自动寻找要触发的事件，这意味着我们必须在每个属性的setter方法中编码来触发该属性名所对应的事件。</li> 
     </ol><p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">第一步：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">partial</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">MainWindow</span> : <span class="hljs-title" style="color:rgb(163,21,21);">Window</span>
{
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">MainWindow</span>(<span class="hljs-params"></span>) </span>{
        InitializeComponent();
        DataContext=<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> NameViewModel();
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">第二步,第三步：</p> <pre class="xaml"><code class="hljs django" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="xml"><span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr" style="color:#FF0000;">Orientation</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"Horizontal"</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr" style="color:#FF0000;">Content</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"姓："</span> <span class="hljs-attr" style="color:#FF0000;">Width</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"100"</span>/&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr" style="color:#FF0000;">Height</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"23"</span> <span class="hljs-attr" style="color:#FF0000;">Width</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"200"</span> <span class="hljs-attr" style="color:#FF0000;">Text</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"{Binding Path=FirstName,UpdateSourceTrigger=PropertyChanged}"</span> /&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr" style="color:#FF0000;">Orientation</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"Horizontal"</span>&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">Label</span> <span class="hljs-attr" style="color:#FF0000;">Content</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"名："</span> <span class="hljs-attr" style="color:#FF0000;">Width</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"100"</span>/&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr" style="color:#FF0000;">Height</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"23"</span> <span class="hljs-attr" style="color:#FF0000;">Width</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"200"</span> <span class="hljs-attr" style="color:#FF0000;">Text</span>=<span class="hljs-string" style="color:rgb(163,21,21);">"{Binding Path=LastName,UpdateSourceTrigger=PropertyChanged}"</span> /&gt;</span> <span class="hljs-tag" style="color:rgb(0,0,255);">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span> </span></code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">第四步：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NameViewModel</span>:<span class="hljs-title" style="color:rgb(163,21,21);">INotifyPropertyChanged</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">event</span> PropertyChangedEventHandler PropertyChanged;

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnPropertyChanged</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> propertyName</span>) </span>{
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (PropertyChanged!=<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
            {
                PropertyChanged(<span class="hljs-keyword" style="color:rgb(0,0,255);">this</span>,<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PropertyChangedEventArgs(propertyName));
            }
        }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> _firstName;

    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FirstName
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _firstName; }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>!=_firstName)
                {
                    _firstName = <span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>;
                    OnPropertyChanged(<span class="hljs-string" style="color:rgb(163,21,21);">"FirstName"</span>);
                    OnPropertyChanged(<span class="hljs-string" style="color:rgb(163,21,21);">"FullName"</span>);
                }
            }
        }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> _lastName;

    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> LastName
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _lastName; }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>!=_lastName)
                {
                    _lastName = <span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>;
                    OnPropertyChanged(<span class="hljs-string" style="color:rgb(163,21,21);">"LastName"</span>);
                    OnPropertyChanged(<span class="hljs-string" style="color:rgb(163,21,21);">"FullName"</span>);
                }
            }
        }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FullName
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.Format(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}{1}"</span>, FirstName, LastName); }
    }

   
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果你对WPF熟悉的话，那么上面的代码没什么可说的：无论何时在这些属性上使用了set，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PropertyChanged</code>事件都会被触发。比如，在姓的文本框上输入了A，那么就会导致FirstName的属性值被设置set。在set期间，触发了两次PropertyChanged：一次是宣布FirstName属性修改了，然后是宣布FullName属性修改了。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">编译、运行程序，结果如下：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160828235329975-1338920479.png" style="border:0px;" alt="577014-20160828235329975-1338920479.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然这个例子不是很复杂，但是在真实的WPF应用中，可能会有更多的字段以及这些字段之间关系更复杂，如果熟悉MVVM（Model-View-ViewModel）模式的话，那么这种类型的绑定对于实现那种模式很重要。此外，虽然这只是一个简单的示例，但是NameViewModel从一个只有自动属性的小类变得越来越大，代码越来越多，有了支持字段，而且每个set方法中还要逻辑。虽然可以在View和ViewModel之间进行干净的分离，但是使用INotifyPropertyChanged会面临很多陷阱和问题。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">使用INotifyPropertyChanged的问题和约束</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">虽然使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">INotifyPropertyChanged</code>有很多好处，但是也有很多弊端，比如，潜在产生了样板代码，脆弱的代码以及可能维护起来困难的代码。<br> 产生的样板代码很明显，因为从最原始的只有三个自动属性的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">NameViewModel</code>类现在体积已经膨胀了好几倍，有了显式的支持字段，setter里面也有了逻辑，因此，这里有很多重复，可以使用AOP减少重复。<br> 其次，要触发<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PropertyChanged</code>事件，就需要有一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PropertyChangedEventArgs</code>对象，它需要一个字符串来识别已经改变的属性。因此，当每次调用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnPropertyChanged</code>时，需要传一个和属性名称对应的字符串，如果不小心手误输错了，就会导致触发事件失败。<br> 最后，使用<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">INotifyPropertyChanged</code>很难维护。因为它使用了字符串，如果更改了属性名，就必须记得也要修改字符串（安装了ReSharp等重构工具时，如果重命名属性，ReSharp可以帮我们完成这件事）。还要注意，因为我们有一个导出属性（FullName），所以要记得当发送关于其它属性更改的消息时要包括该属性。</p> 
     <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
      <p>使用ReSharp重构<br> 虽然属性名FirstName和字符串“FirstName”对于我们人类来说看起来是相同的，但是对于编译器它们是不同的符号，如果更改了一个符号，编译器不会聪明到也能意识到其它相关的符号，当运行代码时最终会报错。<br> 一些重构工具比如ReSharp，Telerik JustCode等都会尝试使用智能分析和演绎找出相关的符号。比如，当使用ReSharp重命名FirstName属性时，它可能会询问你是否想要更改“FirstName”字符串的值。</p> 
     </blockquote> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">不使用AOP也可以缓解这些问题，比如可以写单元测试或者防御性编程，它们可以验证所有将会发送的正确通知。虽然可以使用发射使得这件事简单些，但是会潜在产生很多代码。（比如可以使用反射可以循环遍历类的所有属性，获得属性名称，进而确保当事件触发时属性名称时匹配的）。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">如果使用了.NET 4.5，那么可以使用一个叫做<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">CallMemberName</code>的新工具来处理<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">INotifyPropertyChanged</code>,CallMemberName是一个特性，可以使用它将一个参数设置成调用的属性的名称。这里我们可以使用它来减少<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">NameViewModel</code>类中字符串的依赖，代码如下：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NameViewModel2</span>:<span class="hljs-title" style="color:rgb(163,21,21);">INotifyPropertyChanged</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">event</span> PropertyChangedEventHandler PropertyChanged;

  

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnPropertyChanged</span>(<span class="hljs-params">[CallerMemberName]<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> propertyName=<span class="hljs-string" style="color:rgb(163,21,21);">""</span></span>) </span>{
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (PropertyChanged!=<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
            {
                PropertyChanged(<span class="hljs-keyword" style="color:rgb(0,0,255);">this</span>,<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PropertyChangedEventArgs(propertyName));
            }
        }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> _firstName;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FirstName
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _firstName; }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span> {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>!=_firstName)
                {
                    _firstName = <span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>;
                    OnPropertyChanged();<span class="hljs-comment" style="color:#008000;">//这里就可以移除“FirstName”了</span>
                    OnPropertyChanged(<span class="hljs-string" style="color:rgb(163,21,21);">"FullName"</span>);
                }
            }
        }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> _lastName;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> LastName
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span> { <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> _lastName; }
            <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">value</span> != _firstName)
                {
                    _lastName = <span class="hljs-keyword" style="color:rgb(0,0,255);">value</span>;
                    OnPropertyChanged();<span class="hljs-comment" style="color:#008000;">//这里就可以移除“LastName”了</span>
                    OnPropertyChanged(<span class="hljs-string" style="color:rgb(163,21,21);">"FullName"</span>);
                }
            }
        }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FullName
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>
            {
                <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>.Format(<span class="hljs-string" style="color:rgb(163,21,21);">"{0} {1}"</span>, _firstName, _lastName);
            }
        }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这是一种改善，重命名属性FirstName和LastName不再是问题了，因为.Net Framework会帮我们填充空白。拼写失误也不是问题了，因为CallMemberName只会使用属性的名称，但是还必须通知FullName更改了，因为它是一个导出属性。而且仍然有很多样板代码，包括显式支持字段和许多setter中的代码。<br> 我们可以使用AOP来处理这些问题，下面我们就使用一个新的AOP工具来协助处理INotifyPropertyChanged。</p> <h3 style="font-size:16px;line-height:1.5;color:rgb(111,168,51);border-left-width:13px;border-left-style:solid;border-left-color:rgb(111,168,51);font-family:'Microsoft Yahei', Simsun, Arial;">使用AOP减少样板代码</h3> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">之前已经使用PostSharp和Castle Dynamic这两个AOP框架演示了很多例子，现在再引入一个新的框架，这个框架之前叫<strong>INotifyPropertyWeaver</strong>,是专为INotifyPropertyChanged而生的，然而，现在这个框架已经弃用了，在网上基本找不到关于它的消息了，然而，他的作者将它集成到了Fody项目中，而且它现在的名字叫<strong>PropertyChanged.Fody</strong>，安装时，直接在Nuget控制台输入<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">Install-Package PropertyChanged.Fody</code>即可。<br> 安装好之后，我们只需要定义一个原始的NameViewModel类：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NameViewModel</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FirstName { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }
    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> LastName { <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>; <span class="hljs-keyword" style="color:rgb(0,0,255);">set</span>; }

    <span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> FullName
    {
        <span class="hljs-keyword" style="color:rgb(0,0,255);">get</span>
        {
            <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> String.Format(<span class="hljs-string" style="color:rgb(163,21,21);">"{0}{1}"</span>, FirstName, LastName);
        }
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">然后，神奇的地方来了，只需要在这个类的上方添加一个特性<strong>ImplementPropertyChanged</strong>即可，当然前面的数据绑定的步骤还是要做的：</p> <pre class="c#"><code class="hljs swift" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[<span class="hljs-type" style="color:rgb(163,21,21);">ImplementPropertyChanged</span>]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NameViewModel</span> </span>{
</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">运行程序，如下：</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><img src="https://images2015.cnblogs.com/blog/577014/201608/577014-20160829225255902-1319356837.png" style="border:0px;" alt="577014-20160829225255902-1319356837.png"></p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">简直太方便了，只需要加一个特性就把之前要写那么多代码的事情完成了。事实上，这个特性做的就是这件事，代码编译之后的效果和我们写那么多代码是一样的。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当然，这个工具里面还要很多其它特性，感兴趣的同学可以去Github上去学习，链接在此：<a href="https://github.com/Fody/PropertyChanged/wiki" rel="nofollow" class="uri" style="color:#000000;">https://github.com/Fody/PropertyChanged/wiki</a>。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">PropertyChanged.Fody帮我们填充了所有的间隙，它很聪明，可以探测出导出属性，从而填充通知间隙。PostSharp也以PostSharp Ultimate的形式提供了类似的功能。</p> 
     <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6;color:rgb(51,51,51);font-size:15px;font-family:'Microsoft Yahei';clear:both;background:rgb(223,255,163) url(&quot;//files.cnblogs.com/files/farb/o_title.gif&quot;) no-repeat 9px 50%;"> 
      <p>PostSharp Ultimate<br> PostSharp Ultimate收集了很多现成的开源切面，包括的现成切面如下：</p> 
      <ul>
       <li style="list-style:disc;">多线程</li> 
       <li style="list-style:disc;">诊断（logging）</li> 
       <li style="list-style:disc;">有限的INotifyPropertyChanged切面<br> 这些工具都是免费的，但是它们要求PostSharp是全商业版本。这些工具的优势是可以获得AOP的所有优势来解决特定的问题，不需要从零开始编写切面。当然，我们也可以使用开源免费的Fody代替。</li> 
      </ul>
     </blockquote> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">接下来我们使用PostSharp来实现和上面使用ProperyChanged.Fody相同的功能。先安装Postsharp,再创建一个叫做<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">NotifyPropertyChangedAspect</code>切面类，它继承于<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">LocationIntercetionAspect</code>:</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NotifyPropertyChangedAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">LocationInterceptionAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] _derivedProperties;
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">NotifyPropertyChangedAspect</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">params</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] derived</span>)<span class="hljs-comment" style="color:#008000;">//构造函数参数为可变长参数，用于接收导出属性</span> </span>{
        _derivedProperties = derived;
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        <span class="hljs-comment" style="color:#008000;">//base.OnSetValue(args);</span>
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">回忆一下，之前我们一开始实现<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">INotifyPropertyChanged</code>时，困难的工作都放到setter中了，因此，这里需要重写<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">OnSetValue</code>方法，这个方法会在使用属性的setter时运行，而且它会代替setter运行。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">在OnSetValue里面，需要做2件事：</p> 
     <ol style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">
      <li style="list-style:decimal;">比较新值和旧值，如果不等，那么应该允许set操作通过（使用PostSharp的args.ProceedSetValue方法）；</li> 
      <li style="list-style:decimal;">需要通知已经改变的属性（包括构造函数中指定的任何导出属性）。创建可以重复使用的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">RaisePropertyChanged</code>方法，对指定的所有导出属性进行循环遍历，并调用RaisePropertyChanged方法。代码如下：</li> 
     </ol><pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">[Serializable]
<span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> <span class="hljs-title" style="color:rgb(163,21,21);">NotifyPropertyChangedAspect</span>:<span class="hljs-title" style="color:rgb(163,21,21);">LocationInterceptionAspect</span>
{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] _derivedProperties;
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-title" style="color:rgb(163,21,21);">NotifyPropertyChangedAspect</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">params</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span>[] derived</span>)<span class="hljs-comment" style="color:#008000;">//构造函数参数为可变长参数，用于接收导出属性</span> </span>{
        _derivedProperties = derived;
    }
    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">public</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">override</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">OnSetValue</span>(<span class="hljs-params">LocationInterceptionArgs args</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> oldValue = args.GetCurrentValue();
        <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> newValue = args.Value;
        <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (oldValue!=newValue)
        {
            args.ProceedSetValue();
            RaisePropertyChanged(args.Instance, args.LocationName);<span class="hljs-comment" style="color:#008000;">//只要属性执行了setter，就触发RaisePropertyChanged事件</span>
            <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (_derivedProperties!=<span class="hljs-keyword" style="color:rgb(0,0,255);">null</span>)
            {
                <span class="hljs-comment" style="color:#008000;">//对每个导出属性触发事件</span>
                <span class="hljs-keyword" style="color:rgb(0,0,255);">foreach</span> (<span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> derivedProperty <span class="hljs-keyword" style="color:rgb(0,0,255);">in</span> _derivedProperties)
                {
                    RaisePropertyChanged(args.Instance,derivedProperty);
                }
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">RaisePropertyChanged</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> p1, <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> p2</span>) </span>{
        <span class="hljs-keyword" style="color:rgb(0,0,255);">throw</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> NotImplementedException();
    }
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">RaisePropertyChanged</code>待会再实现。先来学习一下之前没有碰到过的PostSharp的API。<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.GetCurrentValue</code>获取当前的位置值，但是它还没有把值value放到args.Value。因此，这里把它存储在oldValue变量中再合适不过了。args.Value返回即将到来的位置值。<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.ProceedSetValue</code>指示PostSharp允许继续set操作。<br> 如果属性值发生了变化，那么我们就触发属性改变的事件。看一下传入的实参，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.Instance</code>返回的是属性所在的对象（比如，NameViewModel类的实例），它应该是一个实现了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">INotifyPropertyChanged</code>的类。<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">args.LocationName</code>返回被拦截的属性名，比如可能是FirstName或LastName。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">当属性更改的通知发出之后，遍历所有指定的导出属性（如FullName），并为这些属性调用RaisePropertyChanged方法。下面我们完成最后这个切面并写完<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">RaisePropertyChanged</code>方法。在该方法中，你期望找到传入的实例对象上的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">PropertyChanged</code>事件，并使用传入的位置名触发那个事件。然而，只有纯粹的一个对象object传入，所以必须借助反射来处理：</p> <pre class="c#"><code class="hljs cs" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;font-size:12px;border:1px solid rgb(204,204,204);">
<span class="hljs-function"><span class="hljs-keyword" style="color:rgb(0,0,255);">private</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">void</span> <span class="hljs-title" style="color:rgb(163,21,21);">RaisePropertyChanged</span>(<span class="hljs-params"><span class="hljs-keyword" style="color:rgb(0,0,255);">object</span> instance, <span class="hljs-keyword" style="color:rgb(0,0,255);">string</span> propertyName</span>) </span>{
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> type = instance.GetType();
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> propertyChanged = type.GetField(<span class="hljs-string" style="color:rgb(163,21,21);">"PropertyChanged"</span>, BindingFlags.Instance|BindingFlags.NonPublic);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">var</span> handler = propertyChanged.GetValue(instance) <span class="hljs-keyword" style="color:rgb(0,0,255);">as</span> PropertyChangedEventHandler;
    handler(instance,<span class="hljs-keyword" style="color:rgb(0,0,255);">new</span> PropertyChangedEventArgs(propertyName));
}

</code></pre> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这个方法中没使用任何PostSharp API，只有反射的API。反射会检索实例instance的类型，从该类型中可以找到PropertyChanged事件字段。使用那个字段可以调用事件。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这里使用发射，是因为从类外面触发事件的唯一方式就是反射了。这样做并不好，因为反射是一个缓慢的过程，这样编写切面的话意味着属性每次改变时都会执行反射。此外，如果这个切面用在一个没有PropertyChanged事件的类上，那么就会报错。（解决办法请关注后面的教程，特别是PostSharp的<strong>CompileTimeValidate</strong>功能）</p> <h2 style="font-size:21px;line-height:1.5;color:rgb(255,255,255);font-family:'微软雅黑', '宋体', '黑体', Arial;background:rgb(111,168,51);"> <a name="summary"></a>小结</h2> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这节我们覆盖了一个新的拦截类型：拦截属性和字段（位置）。和拦截方法一样，位置拦截切面扮演着getter/setter和处理getting/setting代码之间的中间人。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">C#中的属性提供了简明的方式编写getter/setter方法，可以拦截方法的工具也可以拦截属性（比如Castle DynamicProxy）。但PostSharp为位置提供了一个特殊的类，该API可以同时为属性和字段服务。和方法拦截一样，我们可以继续执行get/setca操作，也可以获得关于位置的信息（比如字段名和属性名），实例对象等等。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">这节也引入了一个新的AOP工具——PropertyChanged.Fody,这个工具很专一，只做一件事，不像PostSharp和Castle DynamicProxy是通用框架。</p> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;">现在，我们已经可以编写拦截方法、边界方法、拦截位置的切面了。但是学习AOP不仅仅是数量（可以少写代码），而且还有质量。下一篇我们看下如何将单元测试和切面结合起来。</p> </li> 
    <li style="list-style:disc;"> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> </li> 
    <li style="list-style:disc;"> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> </li> 
    <li style="list-style:disc;"> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> </li> 
    <li style="list-style:disc;"> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> </li> 
    <li style="list-style:disc;"> <p style="color:rgb(73,73,73);font-family:'Microsoft Yahei', Simsun, Arial;font-size:15px;line-height:25px;"><br></p> </li> 
    <li style="list-style:disc;"> <p><font color="#494949"><span style="font-size:15px;line-height:25px;">本文转自tkbSimplest博客园博客，原文链接：http://www.cnblogs.com/farb/p/LocationInterception.html，如需转载请自行联系原作者</span></font><br></p> </li> 
   </ul>
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
