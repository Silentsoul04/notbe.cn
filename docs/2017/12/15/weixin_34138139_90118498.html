<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>用户空间与内核空间数据交换的方式(9)------netlink【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://www.cnblogs.com/hoys/archive/2011/04/10/2011722.html         Netlink 是一种特殊的 socket，它是 Linux 所特有的，类似于 BSD 中的AF_ROUTE 但又远比它的功能强大，目前在最新的 ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/12/15/weixin_34138139_90118498.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">用户空间与内核空间数据交换的方式(9)------netlink【转】</h1>
    <p class="post-meta">Dec 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://www.cnblogs.com/hoys/archive/2011/04/10/2011722.html" rel="nofollow">http://www.cnblogs.com/hoys/archive/2011/04/10/2011722.html</a></p> 
   <div class="blogpost-body"> 
    <p>Netlink 是一种特殊的 socket，它是 Linux 所特有的，类似于 BSD 中的AF_ROUTE 但又远比它的功能强大，目前在最新的 Linux 内核（2.6.14）中使用netlink 进行应用与内核通信的应用很多，包括：<br>路由 daemon（NETLINK_ROUTE），<br>1-wire 子系统（NETLINK_W1），<br>用户态 socket 协议（NETLINK_USERSOCK），<br>防火墙（NETLINK_FIREWALL），<br>socket 监视（NETLINK_INET_DIAG），<br>netfilter 日志（NETLINK_NFLOG），<br>ipsec 安全策略（NETLINK_XFRM），<br>SELinux 事件通知（NETLINK_SELINUX），<br>iSCSI 子系统（NETLINK_ISCSI），<br>进程审计（NETLINK_AUDIT），<br>转发信息表查询（NETLINK_FIB_LOOKUP）， <br>netlink connector(NETLINK_CONNECTOR),<br>netfilter 子系统（NETLINK_NETFILTER），<br>IPv6 防火墙（NETLINK_IP6_FW），<br>DECnet 路由信息（NETLINK_DNRTMSG），<br>内核事件向用户态通知（NETLINK_KOBJECT_UEVENT），<br>通用 netlink（NETLINK_GENERIC）。</p> 
    <p>Netlink 是一种在内核与用户应用间进行双向数据传输的非常好的方式，用户态应用使用标准的 socket API 就可以使用 netlink 提供的强大功能，内核态需要使用专门的内核 API 来使用 netlink。</p> 
    <p>Netlink 相对于系统调用，ioctl 以及 /proc 文件系统而言具有以下优点：</p> 
    <p>1，为了使用 netlink，用户仅需要在 include/linux/netlink.h 中增加一个新类型的 netlink 协议定义即可，如 #define NETLINK_MYTEST 17 然后，内核和用户态应用就可以立即通过 socket API 使用该 netlink 协议类型进行数据交换。但系统调用需要增加新的系统调用，ioctl 则需要增加设备或文件， 那需要不少代码，proc 文件系统则需要在 /proc 下添加新的文件或目录，那将使本来就混乱的 /proc 更加混乱。</p> 
    <p>2. netlink是一种异步通信机制，在内核与用户态应用之间传递的消息保存在socket缓存队列中，发送消息只是把消息保存在接收者的socket的接 收队列，而不需要等待接收者收到消息，但系统调用与 ioctl 则是同步通信机制，如果传递的数据太长，将影响调度粒度。</p> 
    <p>3．使用 netlink 的内核部分可以采用模块的方式实现，使用 netlink 的应用部分和内核部分没有编译时依赖，但系统调用就有依赖，而且新的系统调用的实现必须静态地连接到内核中，它无法在模块中实现，使用新系统调用的应用在编译时需要依赖内核。</p> 
    <p>4．netlink 支持多播，内核模块或应用可以把消息多播给一个netlink组，属于该neilink 组的任何内核模块或应用都能接收到该消息，内核事件向用户态的通知机制就使用了这一特性，任何对内核事件感兴趣的应用都能收到该子系统发送的内核事件，在后面的文章中将介绍这一机制的使用。</p> 
    <p>5．内核可以使用 netlink 首先发起会话，但系统调用和 ioctl 只能由用户应用发起调用。</p> 
    <p>6．netlink 使用标准的 socket API，因此很容易使用，但系统调用和 ioctl则需要专门的培训才能使用。</p> 
    <p>用户态使用 netlink</p> 
    <p>用户态应用使用标准的socket APIs， socket(), bind(), sendmsg(), recvmsg() 和 close() 就能很容易地使用 netlink socket，查询手册页可以了解这些函数的使用细节，本文只是讲解使用 netlink 的用户应该如何使用这些函数。注意，使用 netlink 的应用必须包含头文件 linux/netlink.h。当然 socket 需要的头文件也必不可少，sys/socket.h。</p> 
    <p>为了创建一个 netlink socket，用户需要使用如下参数调用 socket():</p> 
    <p>socket(AF_NETLINK, SOCK_RAW, netlink_type)<br>&nbsp;</p> 
    <p>第一个参数必须是 AF_NETLINK 或 PF_NETLINK，在 Linux 中，它们俩实际为一个东西，它表示要使用netlink，第二个参数必须是SOCK_RAW或SOCK_DGRAM， 第三个参数指定netlink协议类型，如前面讲的用户自定义协议类型NETLINK_MYTEST， NETLINK_GENERIC是一个通用的协议类型，它是专门为用户使用的，因此，用户可以直接使用它，而不必再添加新的协议类型。内核预定义的协议类型有：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_ROUTE 0 /* Routing/device hook */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_W1 1 /* 1-wire subsystem */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_USERSOCK 2 /* Reserved for user mode socket protocols */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_FIREWALL 3 /* Firewalling hook */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_INET_DIAG 4 /* INET socket monitoring */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_NFLOG 5 /* netfilter/iptables ULOG */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_XFRM 6 /* ipsec */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_SELINUX 7 /* SELinux event notifications */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_ISCSI 8 /* Open-iSCSI */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_AUDIT 9 /* auditing */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_FIB_LOOKUP 10<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_CONNECTOR 11<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_NETFILTER 12 /* netfilter subsystem */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_IP6_FW 13<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_DNRTMSG 14 /* DECnet routing messages */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_KOBJECT_UEVENT 15 /* Kernel messages to userspace */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NETLINK_GENERIC 16</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p><br>&nbsp;</p> 
    <p>对于每一个netlink协议类型，可以有多达 32多播组，每一个多播组用一个位表示，netlink 的多播特性使得发送消息给同一个组仅需要一次系统调用，因而对于需要多拨消息的应用而言，大大地降低了系统调用的次数。</p> 
    <p>函数 bind() 用于把一个打开的 netlink socket 与 netlink 源 socket 地址绑定在一起。netlink socket 的地址结构如下：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#000000;"> <span style="color:#0000ff;">struct<span style="color:#000000;"> sockaddr_nl<br>{<br> sa_family_t nl_family;<br> unsigned <span style="color:#0000ff;">short<span style="color:#000000;"> nl_pad;<br> __u32 nl_pid;<br> __u32 nl_groups;<br>};</span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p>字段 nl_family 必须设置为 AF_NETLINK 或着 PF_NETLINK，字段 nl_pad 当前没有使用，因此要总是设置为 0，字段 nl_pid 为接收或发送消息的进程的 ID，如果希望内核处理消息或多播消息，就把该字段设置为 0，否则设置为处理消息的进程 ID。字段 nl_groups 用于指定多播组，bind 函数用于把调用进程加入到该字段指定的多播组，如果设置为 0，表示调用者不加入任何多播组。</p> 
    <p>传递给 bind 函数的地址的 nl_pid 字段应当设置为本进程的进程 ID，这相当于 netlink socket 的本地地址。但是，对于一个进程的多个线程使用 netlink socket 的情况，字段 nl_pid 则可以设置为其它的值，如：</p> 
    <p>pthread_self() &lt;&lt; 16 | getpid();</p> 
    <p>因此字段 nl_pid 实际上未必是进程 ID,它只是用于区分不同的接收者或发送者的一个标识，用户可以根据自己需要设置该字段。函数 bind 的调用方式如下：</p> 
    <p>bind(fd, (struct sockaddr*)&amp;nladdr, sizeof(struct sockaddr_nl));</p> 
    <p>fd为前面的 socket 调用返回的文件描述符，参数 nladdr 为 struct sockaddr_nl 类型的地址。 为了发送一个 netlink 消息给内核或其他用户态应用，需要填充目标 netlink socket 地址 ，此时，字段 nl_pid 和 nl_groups 分别表示接收消息者的进程 ID 与多播组。如果字段 nl_pid 设置为 0，表示消息接收者为内核或多播组，如果 nl_groups为 0，表示该消息为单播消息，否则表示多播消息。 使用函数 sendmsg 发送 netlink 消息时还需要引用结构 struct msghdr、struct nlmsghdr 和 struct iovec，结构 struct msghdr 需如下设置：</p> 
    <div class="cnblogs_code"> 
     <div>
      <span style="color:#0000ff;">struct<span style="color:#000000;"> msghdr msg;<br>memset(<span style="color:#000000;">&amp;<span style="color:#000000;">msg, <span style="color:#800080;">0<span style="color:#000000;">, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(msg));<br>msg.msg_name <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)<span style="color:#000000;">&amp;<span style="color:#000000;">(nladdr);<br>msg.msg_namelen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#0000ff;">sizeof<span style="color:#000000;">(nladdr);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
    </div> 
    <p><br>&nbsp;<br>其中 nladdr 为消息接收者的 netlink 地址。</p> 
    <p>struct nlmsghdr 为 netlink socket 自己的消息头，这用于多路复用和多路分解 netlink 定义的所有协议类型以及其它一些控制，netlink 的内核实现将利用这个消息头来多路复用和多路分解已经其它的一些控制，因此它也被称为netlink 控制块。因此，应用在发送 netlink 消息时必须提供该消息头。</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr<br>{<br> __u32 nlmsg_len; <span style="color:#008000;">/*<span style="color:#008000;"> Length of message <span style="color:#008000;">*/<span style="color:#000000;"><br> __u16 nlmsg_type; <span style="color:#008000;">/*<span style="color:#008000;"> Message type<span style="color:#008000;">*/<span style="color:#000000;"><br> __u16 nlmsg_flags; <span style="color:#008000;">/*<span style="color:#008000;"> Additional flags <span style="color:#008000;">*/<span style="color:#000000;"><br> __u32 nlmsg_seq; <span style="color:#008000;">/*<span style="color:#008000;"> Sequence number <span style="color:#008000;">*/<span style="color:#000000;"><br> __u32 nlmsg_pid; <span style="color:#008000;">/*<span style="color:#008000;"> Sending process PID <span style="color:#008000;">*/<span style="color:#000000;"><br>};</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p><br>&nbsp;</p> 
    <p>字段 nlmsg_len 指定消息的总长度，包括紧跟该结构的数据部分长度以及该结构的大小，字段 nlmsg_type 用于应用内部定义消息的类型，它对 netlink 内核实现是透明的，因此大部分情况下设置为 0，字段 nlmsg_flags 用于设置消息标志，可用的标志包括：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#008000;">/*<span style="color:#008000;"> Flags values <span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_REQUEST 1 /* It is request message. */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_MULTI 2 /* Multipart message, terminated by NLMSG_DONE */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_ACK 4 /* Reply with ack, with zero or error code */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_ECHO 8 /* Echo this request */<span style="color:#000000;"><br><br><span style="color:#008000;">/*<span style="color:#008000;"> Modifiers to GET request <span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_ROOT 0x100 /* specify tree root */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_MATCH 0x200 /* return all matching */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_ATOMIC 0x400 /* atomic GET */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_DUMP (NLM_F_ROOT|NLM_F_MATCH)<span style="color:#000000;"><br><br><span style="color:#008000;">/*<span style="color:#008000;"> Modifiers to NEW request <span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_REPLACE 0x100 /* Override existing */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_EXCL 0x200 /* Do not touch, if it exists */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_CREATE 0x400 /* Create, if it does not exist */<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLM_F_APPEND 0x800 /* Add to end of list */</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p><br>&nbsp;</p> 
    <p>标志NLM_F_REQUEST用于表示消息是一个请求，所有应用首先发起的消息都应设置该标志。</p> 
    <p>标志NLM_F_MULTI 用于指示该消息是一个多部分消息的一部分，后续的消息可以通过宏NLMSG_NEXT来获得。</p> 
    <p>宏NLM_F_ACK表示该消息是前一个请求消息的响应，顺序号与进程ID可以把请求与响应关联起来。</p> 
    <p>标志NLM_F_ECHO表示该消息是相关的一个包的回传。</p> 
    <p>标志NLM_F_ROOT 被许多 netlink 协议的各种数据获取操作使用，该标志指示被请求的数据表应当整体返回用户应用，而不是一个条目一个条目地返回。有该标志的请求通常导致响应消息设置 NLM_F_MULTI标志。注意，当设置了该标志时，请求是协议特定的，因此，需要在字段 nlmsg_type 中指定协议类型。</p> 
    <p>标志 NLM_F_MATCH 表示该协议特定的请求只需要一个数据子集，数据子集由指定的协议特定的过滤器来匹配。</p> 
    <p>标志 NLM_F_ATOMIC 指示请求返回的数据应当原子地收集，这预防数据在获取期间被修改。</p> 
    <p>标志 NLM_F_DUMP 未实现。</p> 
    <p>标志 NLM_F_REPLACE 用于取代在数据表中的现有条目。</p> 
    <p>标志 NLM_F_EXCL_ 用于和 CREATE 和 APPEND 配合使用，如果条目已经存在，将失败。</p> 
    <p>标志 NLM_F_CREATE 指示应当在指定的表中创建一个条目。</p> 
    <p>标志 NLM_F_APPEND 指示在表末尾添加新的条目。</p> 
    <p>内核需要读取和修改这些标志，对于一般的使用，用户把它设置为 0 就可以，只是一些高级应用（如 netfilter 和路由 daemon 需要它进行一些复杂的操作），字段 nlmsg_seq 和 nlmsg_pid 用于应用追踪消息，前者表示顺序号，后者为消息来源进程 ID。下面是一个示例：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#0000ff;">#define<span style="color:#000000;"> MAX_MSGSIZE 1024<span style="color:#000000;"><br><br><span style="color:#0000ff;">char<span style="color:#000000;"> buffer[] <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800000;">"<span style="color:#800000;">An example message<span style="color:#800000;">"<span style="color:#000000;">;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr nlhdr;<br>nlhdr <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">)malloc(NLMSG_SPACE(MAX_MSGSIZE));<br>strcpy(NLMSG_DATA(nlhdr),buffer);<br>nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len <span style="color:#000000;">=<span style="color:#000000;"> NLMSG_LENGTH(strlen(buffer));<br>nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_pid <span style="color:#000000;">=<span style="color:#000000;"> getpid(); <span style="color:#008000;">/*<span style="color:#008000;"> self pid <span style="color:#008000;">*/<span style="color:#000000;"><br>nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_flags <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p><br>&nbsp;<br>结构 struct iovec 用于把多个消息通过一次系统调用来发送，下面是该结构使用示例：</p> 
    <div class="cnblogs_code"> 
     <div>
      <span style="color:#0000ff;">struct<span style="color:#000000;"> iovec iov;<br>iov.iov_base <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)nlhdr;<br>iov.iov_len <span style="color:#000000;">=<span style="color:#000000;"> nlh<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len;<br>msg.msg_iov <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#000000;">&amp;<span style="color:#000000;">iov;<br>msg.msg_iovlen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">1<span style="color:#000000;">; </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
    </div> 
    <p>在完成以上步骤后，消息就可以通过下面语句直接发送：</p> 
    <p>sendmsg(fd, &amp;msg, 0);<br>&nbsp;</p> 
    <p>应用接收消息时需要首先分配一个足够大的缓存来保存消息头以及消息的数据部分，然后填充消息头，添完后就可以直接调用函数 recvmsg() 来接收。</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#0000ff;">#define<span style="color:#000000;"> MAX_NL_MSG_LEN 1024<span style="color:#000000;"><br><br><span style="color:#0000ff;">struct<span style="color:#000000;"> sockaddr_nl nladdr;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> msghdr msg;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> iovec iov;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;"> nlhdr;<br>nlhdr <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">)malloc(MAX_NL_MSG_LEN);<br>iov.iov_base <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)nlhdr;<br>iov.iov_len <span style="color:#000000;">=<span style="color:#000000;"> MAX_NL_MSG_LEN;<br>msg.msg_name <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)<span style="color:#000000;">&amp;<span style="color:#000000;">(nladdr);<br>msg.msg_namelen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#0000ff;">sizeof<span style="color:#000000;">(nladdr);<br>msg.msg_iov <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#000000;">&amp;<span style="color:#000000;">iov;<br>msg.msg_iovlen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">1<span style="color:#000000;">;<br>recvmsg(fd, <span style="color:#000000;">&amp;<span style="color:#000000;">msg, <span style="color:#800080;">0<span style="color:#000000;">); </span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p><br>&nbsp;</p> 
    <p>注意：fd为socket调用打开的netlink socket描述符。</p> 
    <p>在消息接收后，nlhdr指向接收到的消息的消息头，nladdr保存了接收到的消息的目标地址，宏NLMSG_DATA(nlhdr)返回指向消息的数据部分的指针。</p> 
    <p>在linux/netlink.h中定义了一些方便对消息进行处理的宏，这些宏包括：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_ALIGNTO 4<span style="color:#000000;"><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_ALIGN(len)用于得到不小于len且字节对齐的最小数值<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) &amp; ~(NLMSG_ALIGNTO-1) )<span style="color:#000000;"><br><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_LENGTH(len)用于计算数据部分长度为len时实际的消息长度。它一般用于分配消息缓存<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(sizeof(struct nlmsghdr)))<span style="color:#000000;"><br><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_SPACE(len)返回不小于NLMSG_LENGTH(len)且字节对齐的最小数值，它也用于分配消息缓存<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))<span style="color:#000000;"><br><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_DATA(nlh)用于取得消息的数据部分的首地址，设置和读取消息数据部分时需要使用该宏<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_DATA(nlh) ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))<span style="color:#000000;"><br><br><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_NEXT(nlh,len)用于得到下一个消息的首地址，同时len也减少为剩余消息的总长度，该宏一般</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div>
      <span style="color:#008000;">在一个消息被分成几个部分发送或接收时使用<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_NEXT(nlh,len) ((len) -= NLMSG_ALIGN((nlh)-&gt;nlmsg_len), \<span style="color:#000000;"><br><br> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr<span style="color:#000000;">*<span style="color:#000000;">)(((<span style="color:#0000ff;">char<span style="color:#000000;">*<span style="color:#000000;">)(nlh)) <span style="color:#000000;">+<span style="color:#000000;"> NLMSG_ALIGN((nlh)<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len)))<br><br><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_OK(nlh,len)用于判断消息是否有len这么长<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_OK(nlh,len) ((len) &gt;= (int)sizeof(struct nlmsghdr) &amp;&amp; \<span style="color:#000000;"><br><br> (nlh)<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len <span style="color:#000000;">&gt;=<span style="color:#000000;"> <span style="color:#0000ff;">sizeof<span style="color:#000000;">(<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr) <span style="color:#000000;">&amp;&amp;<span style="color:#000000;"> \<br><br> (nlh)<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len <span style="color:#000000;">&lt;=<span style="color:#000000;"> (len))<br><br><br><span style="color:#008000;">/*<span style="color:#008000;">宏NLMSG_PAYLOAD(nlh,len)用于返回payload的长度<span style="color:#008000;">*/<span style="color:#000000;"><br><span style="color:#0000ff;">#define<span style="color:#000000;"> NLMSG_PAYLOAD(nlh,len) ((nlh)-&gt;nlmsg_len - NLMSG_SPACE((len)))<span style="color:#000000;"><br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p>函数close用于关闭打开的netlink socket。</p> 
    <p>netlink内核API</p> 
    <p>netlink的内核实现在.c文件net/core/af_netlink.c中，内核模块要想使用netlink，也必须包含头文件 linux/netlink.h。内核使用netlink需要专门的API，这完全不同于用户态应用对netlink的使用。如果用户需要增加新的 netlink协议类型，必须通过修改linux/netlink.h来实现，当然，目前的netlink实现已经包含了一个通用的协议类型 NETLINK_GENERIC以方便用户使用，用户可以直接使用它而不必增加新的协议类型。前面讲到，为了增加新的netlink协议类型，用户仅需增 加如下定义到linux/netlink.h就可以：</p> 
    <p>#define NETLINK_MYTEST&nbsp; 17<br>&nbsp;</p> 
    <p>只要增加这个定义之后，用户就可以在内核的任何地方引用该协议。</p> 
    <p>在内核中，为了创建一个netlink socket用户需要调用如下函数：</p> 
    <p>struct sock *</p> 
    <p>netlink_kernel_create(int unit, void (*input)(struct sock *sk, int len));<br>&nbsp;</p> 
    <p>参数unit表示netlink协议类型，如NETLINK_MYTEST，参数input则为内核模块定义的netlink消息处理函数，当有消 息到达这个netlink socket时，该input函数指针就会被引用。函数指针input的参数sk实际上就是函数netlink_kernel_create返回的 struct sock指针，sock实际是socket的一个内核表示数据结构，用户态应用创建的socket在内核中也会有一个struct sock结构来表示。下面是一个input函数的示例：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#0000ff;">void<span style="color:#000000;"> input (<span style="color:#0000ff;">struct<span style="color:#000000;"> sock <span style="color:#000000;">*<span style="color:#000000;">sk, <span style="color:#0000ff;">int<span style="color:#000000;"> len)<br>{<br><span style="color:#0000ff;">struct<span style="color:#000000;"> sk_buff <span style="color:#000000;">*<span style="color:#000000;">skb;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">nlh <span style="color:#000000;">=<span style="color:#000000;"> NULL;<br> u8 <span style="color:#000000;">*<span style="color:#000000;">data <span style="color:#000000;">=<span style="color:#000000;"> NULL;<br><span style="color:#0000ff;">while<span style="color:#000000;"> ((skb <span style="color:#000000;">=<span style="color:#000000;"> skb_dequeue(<span style="color:#000000;">&amp;<span style="color:#000000;">sk<span style="color:#000000;">-&gt;<span style="color:#000000;">receive_queue)) <span style="color:#000000;">!=<span style="color:#000000;"> NULL) <br> {<br><span style="color:#008000;">/*<span style="color:#008000;"> process netlink message pointed by skb-&gt;data <span style="color:#008000;">*/<span style="color:#000000;"><br> nlh <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">)skb<span style="color:#000000;">-&gt;<span style="color:#000000;">data;<br> data <span style="color:#000000;">=<span style="color:#000000;"> NLMSG_DATA(nlh);<br><span style="color:#008000;">/*<span style="color:#008000;"> process netlink message with header pointed by <br> * nlh and data pointed by data<br><span style="color:#008000;">*/<span style="color:#000000;"><br> } <br>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p>函数input()会在发送进程执行sendmsg()时被调用，这样处理消息比较及时，但是，如果消息特别长时，这样处理将增加系统调用 sendmsg()的执行时间，对于这种情况，可以定义一个内核线程专门负责消息接收，而函数input的工作只是唤醒该内核线程，这样sendmsg将 很快返回。</p> 
    <p>函数skb = skb_dequeue(&amp;sk-&gt;receive_queue)用于取得socket sk的接收队列上的消息，返回为一个struct sk_buff的结构，skb-&gt;data指向实际的netlink消息。</p> 
    <p>函数skb_recv_datagram(nl_sk)也用于在netlink socket nl_sk上接收消息，与skb_dequeue的不同指出是，如果socket的接收队列上没有消息，它将导致调用进程睡眠在等待队列nl_sk- &gt;sk_sleep，因此它必须在进程上下文使用，刚才讲的内核线程就可以采用这种方式来接收消息。</p> 
    <p>下面的函数input就是这种使用的示例：</p> 
    <div class="cnblogs_code"> 
     <div>
      <span style="color:#0000ff;">void<span style="color:#000000;"> input (<span style="color:#0000ff;">struct<span style="color:#000000;"> sock <span style="color:#000000;">*<span style="color:#000000;">sk, <span style="color:#0000ff;">int<span style="color:#000000;"> len)<br>{<br> wake_up_interruptible(sk<span style="color:#000000;">-&gt;<span style="color:#000000;">sk_sleep);<br>}</span></span></span></span></span></span></span></span></span></span>
     </div> 
    </div> 
    <p><br>&nbsp;</p> 
    <p>当内核中发送netlink消息时，也需要设置目标地址与源地址，而且内核中消息是通过struct sk_buff来管理的， linux/netlink.h中定义了一个宏：</p> 
    <p>#define NETLINK_CB(skb)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*(struct netlink_skb_parms*)&amp;((skb)-&gt;cb))<br>&nbsp;</p> 
    <p>来方便消息的地址设置。下面是一个消息地址设置的例子：</p> 
    <div class="cnblogs_code"> 
     <div>
      <span style="color:#000000;">NETLINK_CB(skb).pid <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br><br>NETLINK_CB(skb).dst_pid <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br><br>NETLINK_CB(skb).dst_group <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">1<span style="color:#000000;">;</span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
    </div> 
    <p><br>&nbsp;</p> 
    <p>字段pid表示消息发送者进程ID，也即源地址，对于内核，它为 0， dst_pid 表示消息接收者进程 ID，也即目标地址，如果目标为组或内核，它设置为 0，否则 dst_group 表示目标组地址，如果它目标为某一进程或内核，dst_group 应当设置为 0。</p> 
    <p>在内核中，模块调用函数 netlink_unicast 来发送单播消息：</p> 
    <p>int netlink_unicast(struct sock *sk, struct sk_buff *skb, u32 pid, int nonblock);<br>&nbsp;</p> 
    <p>参数sk为函数netlink_kernel_create()返回的socket，参数skb存放消息，它的data字段指向要发送的 netlink消息结构，而skb的控制块保存了消息的地址信息，前面的宏NETLINK_CB(skb)就用于方便设置该控制块， 参数pid为接收消息进程的pid，参数nonblock表示该函数是否为非阻塞，如果为1，该函数将在没有接收缓存可利用时立即返回，而如果为0，该函 数在没有接收缓存可利用时睡眠。</p> 
    <p>内核模块或子系统也可以使用函数netlink_broadcast来发送广播消息：</p> 
    <p>void netlink_broadcast(struct sock *sk, struct sk_buff *skb, u32 pid, u32 group, int allocation);<br>&nbsp;</p> 
    <p>前面的三个参数与netlink_unicast相同，参数group为接收消息的多播组，该参数的每一个代表一个多播组，因此如果发送给多个多播组，就把该参数设置为多个多播组组ID的位或。参数allocation为内核内存分配类型，一般地为GFP_ATOMIC或GFP_KERNEL， GFP_ATOMIC用于原子的上下文（即不可以睡眠），而GFP_KERNEL用于非原子上下文。</p> 
    <p>在内核中使用函数sock_release来释放函数netlink_kernel_create()创建的netlink socket：</p> 
    <p>void sock_release(struct socket * sock);<br>&nbsp;</p> 
    <p>注意函数netlink_kernel_create()返回的类型为struct sock，因此函数sock_release应该这种调用：</p> 
    <p>sock_release(sk-&gt;sk_socket);<br>&nbsp;</p> 
    <p>sk为函数netlink_kernel_create()的返回值。</p> 
    <p>在源代码包中 给出了一个使用 netlink 的示例，它包括一个内核模块 netlink-exam-kern.c 和两个应用程序 netlink-exam-user-recv.c, netlink-exam-user-send.c。内核模块必须先插入到内核，然后在一个终端上运行用户态接收程序，在另一个终端上运行用户态发送程序，发送程序读取参数指定的文本文件并把它作为 netlink 消息的内容发送给内核模块，内核模块接受该消息保存到内核缓存中，它也通过proc接口出口到 procfs，因此用户也能够通过 /proc/netlink_exam_buffer 看到全部的内容，同时内核也把该消息发送给用户态接收程序，用户态接收程序将把接收到的内容输出到屏幕上。</p> 
    <p>&nbsp;示例： </p> 
    <p>内核模块 netlink-exam-kern.c：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#008000;">//<span style="color:#008000;">kernel module: netlink-exam-kern.c<span style="color:#008000;"><br><span style="color:#000000;">#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">config.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">module.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">netlink.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">sched.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">net<span style="color:#000000;">/<span style="color:#000000;">sock.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">proc_fs.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br><br><span style="color:#0000ff;">#define<span style="color:#000000;"> BUF_SIZE 16384<span style="color:#000000;"><br><span style="color:#0000ff;">static<span style="color:#000000;"> <span style="color:#0000ff;">struct<span style="color:#000000;"> sock <span style="color:#000000;">*<span style="color:#000000;">netlink_exam_sock;<br><span style="color:#0000ff;">static<span style="color:#000000;"> unsigned <span style="color:#0000ff;">char<span style="color:#000000;"> buffer[BUF_SIZE];<br><span style="color:#0000ff;">static<span style="color:#000000;"> unsigned <span style="color:#0000ff;">int<span style="color:#000000;"> buffer_tail <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br><span style="color:#0000ff;">static<span style="color:#000000;"> <span style="color:#0000ff;">int<span style="color:#000000;"> exit_flag <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br><span style="color:#0000ff;">static<span style="color:#000000;"> DECLARE_COMPLETION(exit_completion);<br><br><span style="color:#0000ff;">static<span style="color:#000000;"> <span style="color:#0000ff;">void<span style="color:#000000;"> recv_handler(<span style="color:#0000ff;">struct<span style="color:#000000;"> sock <span style="color:#000000;">*<span style="color:#000000;"> sk, <span style="color:#0000ff;">int<span style="color:#000000;"> length)<br>{<br> wake_up(sk<span style="color:#000000;">-&gt;<span style="color:#000000;">sk_sleep);<br>}<br><br><span style="color:#0000ff;">static<span style="color:#000000;"> <span style="color:#0000ff;">int<span style="color:#000000;"> process_message_thread(<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;"> data)<br>{<br><span style="color:#0000ff;">struct<span style="color:#000000;"> sk_buff <span style="color:#000000;">*<span style="color:#000000;"> skb <span style="color:#000000;">=<span style="color:#000000;"> NULL;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;"> nlhdr <span style="color:#000000;">=<span style="color:#000000;"> NULL;<br><span style="color:#0000ff;">int<span style="color:#000000;"> len;<br> DEFINE_WAIT(wait);<br><br> daemonize(<span style="color:#800000;">"<span style="color:#800000;">mynetlink<span style="color:#800000;">"<span style="color:#000000;">);<br><br><span style="color:#0000ff;">while<span style="color:#000000;"> (exit_flag <span style="color:#000000;">==<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">) {<br> prepare_to_wait(netlink_exam_sock<span style="color:#000000;">-&gt;<span style="color:#000000;">sk_sleep, <span style="color:#000000;">&amp;<span style="color:#000000;">wait, TASK_INTERRUPTIBLE);<br> schedule();<br> finish_wait(netlink_exam_sock<span style="color:#000000;">-&gt;<span style="color:#000000;">sk_sleep, <span style="color:#000000;">&amp;<span style="color:#000000;">wait); <br><br><span style="color:#0000ff;">while<span style="color:#000000;"> ((skb <span style="color:#000000;">=<span style="color:#000000;"> skb_dequeue(<span style="color:#000000;">&amp;<span style="color:#000000;">netlink_exam_sock<span style="color:#000000;">-&gt;<span style="color:#000000;">sk_receive_queue))<br><span style="color:#000000;">!=<span style="color:#000000;"> NULL) {<br> nlhdr <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">)skb<span style="color:#000000;">-&gt;<span style="color:#000000;">data;<br><span style="color:#0000ff;">if<span style="color:#000000;"> (nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len <span style="color:#000000;">&lt;<span style="color:#000000;"> <span style="color:#0000ff;">sizeof<span style="color:#000000;">(<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr)) {<br> printk(<span style="color:#800000;">"<span style="color:#800000;">Corrupt netlink message.\n<span style="color:#800000;">"<span style="color:#000000;">);<br><span style="color:#0000ff;">continue<span style="color:#000000;">;<br> }<br> len <span style="color:#000000;">=<span style="color:#000000;"> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len <span style="color:#000000;">-<span style="color:#000000;"> NLMSG_LENGTH(<span style="color:#800080;">0<span style="color:#000000;">);<br><span style="color:#0000ff;">if<span style="color:#000000;"> (len <span style="color:#000000;">+<span style="color:#000000;"> buffer_tail <span style="color:#000000;">&gt;<span style="color:#000000;"> BUF_SIZE) {<br> printk(<span style="color:#800000;">"<span style="color:#800000;">netlink buffer is full.\n<span style="color:#800000;">"<span style="color:#000000;">);<br> }<br><span style="color:#0000ff;">else<span style="color:#000000;"> {<br> memcpy(buffer <span style="color:#000000;">+<span style="color:#000000;"> buffer_tail, NLMSG_DATA(nlhdr), len);<br> buffer_tail <span style="color:#000000;">+=<span style="color:#000000;"> len;<br> }<br> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_pid <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_flags <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br> NETLINK_CB(skb).pid <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0; NETLINK_CB(skb).dst_pid = 0; NETLINK_CB(skb).dst_group = 1; netlink_broadcast(netlink_exam_sock, skb, 0, 1, GFP_KERNEL); } } complete(&amp;exit_completion); return 0;}static int netlink_exam_readproc(char *page, char **start, off_t off, int count, int *eof, void *data){ int len; if (off &gt;= buffer_tail) { * eof = 1; return 0; } else { len = count; if (count &gt; PAGE_SIZE) { len = PAGE_SIZE; } if (len &gt; buffer_tail - off) { len = buffer_tail - off; } memcpy(page, buffer + off, len); *start = page; return len; }}static int __init netlink_exam_init(void){ netlink_exam_sock = netlink_kernel_create(NETLINK_GENERIC, 0, recv_handler, THIS_MODULE); if (!netlink_exam_sock) { printk("Fail to create netlink socket.\n"); return 1; } kernel_thread(process_message_thread, NULL, CLONE_KERNEL); create_proc_read_entry("netlink_exam_buffer", 0444, NULL, netlink_exam_readproc, 0); return 0;}static void __exit netlink_exam_exit(void){ exit_flag = 1; wake_up(netlink_exam_sock-&gt;sk_sleep); wait_for_completion(&amp;exit_completion); sock_release(netlink_exam_sock-&gt;sk_socket);}module_init(netlink_exam_init);module_exit(netlink_exam_exit);MODULE_LICENSE("GPL");</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p>netlink-exam-user-send.c：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#008000;">//<span style="color:#008000;">application sender: netlink-exam-user-send.c<span style="color:#008000;"><br><span style="color:#000000;">#include <span style="color:#000000;">&lt;<span style="color:#000000;">stdio.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">sys<span style="color:#000000;">/<span style="color:#000000;">types.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">sys<span style="color:#000000;">/<span style="color:#000000;">socket.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">netlink.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br><br><span style="color:#0000ff;">#define<span style="color:#000000;"> MAX_MSGSIZE 1024<span style="color:#000000;"><br><br><br><span style="color:#0000ff;">int<span style="color:#000000;"> main(<span style="color:#0000ff;">int<span style="color:#000000;"> argc, <span style="color:#0000ff;">char<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;"> argv[])<br>{<br> FILE <span style="color:#000000;">*<span style="color:#000000;"> fp;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> sockaddr_nl saddr, daddr;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">nlhdr <span style="color:#000000;">=<span style="color:#000000;"> NULL;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> msghdr msg;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> iovec iov;<br><span style="color:#0000ff;">int<span style="color:#000000;"> sd;<br><span style="color:#0000ff;">char<span style="color:#000000;"> text_line[MAX_MSGSIZE];<br><span style="color:#0000ff;">int<span style="color:#000000;"> ret <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#000000;">-<span style="color:#800080;">1<span style="color:#000000;">;<br><br><span style="color:#0000ff;">if<span style="color:#000000;"> (argc <span style="color:#000000;">&lt;<span style="color:#000000;"> <span style="color:#800080;">2<span style="color:#000000;">) {<br> printf(<span style="color:#800000;">"<span style="color:#800000;">Usage: %s atextfilename\n<span style="color:#800000;">"<span style="color:#000000;">, argv[<span style="color:#800080;">0<span style="color:#000000;">]);<br> exit(<span style="color:#800080;">1<span style="color:#000000;">);<br> }<br><br><span style="color:#0000ff;">if<span style="color:#000000;"> ((fp <span style="color:#000000;">=<span style="color:#000000;"> fopen(argv[<span style="color:#800080;">1<span style="color:#000000;">], <span style="color:#800000;">"<span style="color:#800000;">r<span style="color:#800000;">"<span style="color:#000000;">)) <span style="color:#000000;">==<span style="color:#000000;"> NULL) {<br> printf(<span style="color:#800000;">"<span style="color:#800000;">File %s dosen't exist.\n<span style="color:#800000;">"<span style="color:#000000;">);<br> exit(<span style="color:#800080;">1<span style="color:#000000;">);<br> }<br><br> sd <span style="color:#000000;">=<span style="color:#000000;"> socket(AF_NETLINK, SOCK_RAW,NETLINK_GENERIC);<br> memset(<span style="color:#000000;">&amp;<span style="color:#000000;">saddr, <span style="color:#800080;">0<span style="color:#000000;">, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(saddr));<br> memset(<span style="color:#000000;">&amp;<span style="color:#000000;">daddr, <span style="color:#800080;">0<span style="color:#000000;">, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(daddr));<br><br> saddr.nl_family <span style="color:#000000;">=<span style="color:#000000;"> AF_NETLINK; <br> saddr.nl_pid <span style="color:#000000;">=<span style="color:#000000;"> getpid();<br> saddr.nl_groups <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br> bind(sd, (<span style="color:#0000ff;">struct<span style="color:#000000;"> sockaddr<span style="color:#000000;">*<span style="color:#000000;">)<span style="color:#000000;">&amp;<span style="color:#000000;">saddr, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(saddr));<br><br> daddr.nl_family <span style="color:#000000;">=<span style="color:#000000;"> AF_NETLINK;<br> daddr.nl_pid <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br> daddr.nl_groups <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br><br> nlhdr <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">)malloc(NLMSG_SPACE(MAX_MSGSIZE));<br><br><span style="color:#0000ff;">while<span style="color:#000000;"> (fgets(text_line, MAX_MSGSIZE, fp)) {<br> memcpy(NLMSG_DATA(nlhdr), text_line, strlen(text_line));<br> memset(<span style="color:#000000;">&amp;<span style="color:#000000;">msg, <span style="color:#800080;">0<span style="color:#000000;"> ,<span style="color:#0000ff;">sizeof<span style="color:#000000;">(<span style="color:#0000ff;">struct<span style="color:#000000;"> msghdr));<br><br> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len <span style="color:#000000;">=<span style="color:#000000;"> NLMSG_LENGTH(strlen(text_line));<br> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_pid <span style="color:#000000;">=<span style="color:#000000;"> getpid(); <span style="color:#008000;">/*<span style="color:#008000;"> self pid <span style="color:#008000;">*/<span style="color:#000000;"><br> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_flags <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">;<br><br> iov.iov_base <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)nlhdr;<br> iov.iov_len <span style="color:#000000;">=<span style="color:#000000;"> nlhdr<span style="color:#000000;">-&gt;<span style="color:#000000;">nlmsg_len;<br> msg.msg_name <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)<span style="color:#000000;">&amp;<span style="color:#000000;">daddr;<br> msg.msg_namelen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#0000ff;">sizeof<span style="color:#000000;">(daddr);<br> msg.msg_iov <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#000000;">&amp;<span style="color:#000000;">iov;<br> msg.msg_iovlen <span style="color:#000000;">=<span style="color:#000000;"> 1; ret = sendmsg(sd, &amp;msg, 0); if (ret == -1) { perror("sendmsg error:"); } } close(sd);}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p>netlink-exam-user-recv.c：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
     <div>
      <span style="color:#008000;">//<span style="color:#008000;">application receiver: netlink-exam-user-recv.c<span style="color:#008000;"><br><span style="color:#000000;">#include <span style="color:#000000;">&lt;<span style="color:#000000;">stdio.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">sys<span style="color:#000000;">/<span style="color:#000000;">types.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">sys<span style="color:#000000;">/<span style="color:#000000;">socket.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br>#include <span style="color:#000000;">&lt;<span style="color:#000000;">linux<span style="color:#000000;">/<span style="color:#000000;">netlink.h<span style="color:#000000;">&gt;<span style="color:#000000;"><br><br><span style="color:#0000ff;">#define<span style="color:#000000;"> MAX_MSGSIZE 1024<span style="color:#000000;"><br><br><br><span style="color:#0000ff;">int<span style="color:#000000;"> main(<span style="color:#0000ff;">void<span style="color:#000000;">)<br>{<br><span style="color:#0000ff;">struct<span style="color:#000000;"> sockaddr_nl saddr, daddr;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">nlhdr <span style="color:#000000;">=<span style="color:#000000;"> NULL;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> msghdr msg;<br><span style="color:#0000ff;">struct<span style="color:#000000;"> iovec iov;<br><span style="color:#0000ff;">int<span style="color:#000000;"> sd;<br><span style="color:#0000ff;">int<span style="color:#000000;"> ret <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">1<span style="color:#000000;">;<br><br> sd <span style="color:#000000;">=<span style="color:#000000;"> socket(AF_NETLINK, SOCK_RAW,NETLINK_GENERIC);<br> memset(<span style="color:#000000;">&amp;<span style="color:#000000;">saddr, <span style="color:#800080;">0<span style="color:#000000;">, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(saddr));<br> memset(<span style="color:#000000;">&amp;<span style="color:#000000;">daddr, <span style="color:#800080;">0<span style="color:#000000;">, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(daddr));<br><br> saddr.nl_family <span style="color:#000000;">=<span style="color:#000000;"> AF_NETLINK; <br> saddr.nl_pid <span style="color:#000000;">=<span style="color:#000000;"> getpid();<br> saddr.nl_groups <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">1<span style="color:#000000;">;<br> bind(sd, (<span style="color:#0000ff;">struct<span style="color:#000000;"> sockaddr<span style="color:#000000;">*<span style="color:#000000;">)<span style="color:#000000;">&amp;<span style="color:#000000;">saddr, <span style="color:#0000ff;">sizeof<span style="color:#000000;">(saddr));<br><br> nlhdr <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">struct<span style="color:#000000;"> nlmsghdr <span style="color:#000000;">*<span style="color:#000000;">)malloc(NLMSG_SPACE(MAX_MSGSIZE));<br><br><span style="color:#0000ff;">while<span style="color:#000000;"> (<span style="color:#800080;">1<span style="color:#000000;">) {<br> memset(nlhdr, <span style="color:#800080;">0<span style="color:#000000;">, NLMSG_SPACE(MAX_MSGSIZE));<br><br> iov.iov_base <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)nlhdr;<br> iov.iov_len <span style="color:#000000;">=<span style="color:#000000;"> NLMSG_SPACE(MAX_MSGSIZE);<br> msg.msg_name <span style="color:#000000;">=<span style="color:#000000;"> (<span style="color:#0000ff;">void<span style="color:#000000;"> <span style="color:#000000;">*<span style="color:#000000;">)<span style="color:#000000;">&amp;<span style="color:#000000;">daddr;<br> msg.msg_namelen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#0000ff;">sizeof<span style="color:#000000;">(daddr);<br> msg.msg_iov <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#000000;">&amp;<span style="color:#000000;">iov;<br> msg.msg_iovlen <span style="color:#000000;">=<span style="color:#000000;"> <span style="color:#800080;">1<span style="color:#000000;">;<br><br> ret <span style="color:#000000;">=<span style="color:#000000;"> recvmsg(sd, <span style="color:#000000;">&amp;<span style="color:#000000;">msg, <span style="color:#800080;">0<span style="color:#000000;">);<br><span style="color:#0000ff;">if<span style="color:#000000;"> (ret <span style="color:#000000;">==<span style="color:#000000;"> <span style="color:#800080;">0<span style="color:#000000;">) {<br> printf(<span style="color:#800000;">"<span style="color:#800000;">Exit.\n<span style="color:#800000;">"<span style="color:#000000;">);<br> exit(<span style="color:#800080;">0<span style="color:#000000;">);<br> }<br><span style="color:#0000ff;">else<span style="color:#000000;"> <span style="color:#0000ff;">if<span style="color:#000000;"> (ret <span style="color:#000000;">==<span style="color:#000000;"> <span style="color:#000000;">-<span style="color:#800080;">1<span style="color:#000000;">) {<br> perror(<span style="color:#800000;">"<span style="color:#800000;">recvmsg:<span style="color:#800000;">"<span style="color:#000000;">);<br> exit(<span style="color:#800080;">1<span style="color:#000000;">);<br> }<br> printf(<span style="color:#800000;">"<span style="color:#800000;">%s<span style="color:#800000;">"<span style="color:#000000;">, NLMSG_DATA(nlhdr));<br> }<br><br> close(sd);<br>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><a title="复制代码"><img src="https://yqfile.alicdn.com/img_51e409b11aa51c150090697429a953ed.gif" alt="复制代码"></a></span>
     </div> 
    </div> 
    <p>以上九篇均转自：<a href="http://blogold.chinaunix.net/u3/94916/showart_1915146.html" rel="nofollow">http://blogold.chinaunix.net/u3/94916/showart_1915146.html</a></p> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
