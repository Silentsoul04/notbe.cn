<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[书籍推荐]C# In Depth-深入理解C# « NotBeCN</title>
  <meta name="description" content="             昨天在查看邮箱的时候看到china-pub发给我的新书推荐邮件，浏览了一下，看到了这本书，不过这本书的中文版还未上市预计在5月上市（英文版的已经在2008年4月21日上市了，在本文的最后已经附了下载链接英文好的可以下载了看下），现在在china-pub已经提供了ebook的现在浏览了（可...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/04/weixin_34107955_90125894.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">[书籍推荐]C# In Depth-深入理解C#</h1>
    <p class="post-meta">Oct 4, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">昨天在查看邮箱的时候看到china-pub发给我的新书推荐邮件，浏览了一下，看到了这本书，不过这本书的中文版还未上市预计在5月上市（英文版的已经在2008年4月21日上市了，在本文的最后已经附了下载链接英文好的可以下载了看下），现在在china-pub已经提供了ebook的现在浏览了（可以<a href="http://www.china-pub.com/196689#ml" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">点此</a>查看），我看了下，讲解的很好，不像其他的书像教科书一样先讲一大堆的概念然后再用大堆大堆的“案例”来轰炸，从C#1讲到目前的3，如果想深入学习下C#的可以到时买本回去看下。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">附目录：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">第一部分 基础知识&nbsp;<br> 第1章 C#开发的进化史 2&nbsp;<br> 1.1 实战演变：变化的代码 3&nbsp;<br> 1.1.1 定义产品类型 3&nbsp;<br> 1.1.2 按名称对产品进行排序 7&nbsp;<br> 1.1.3 查询集合 9&nbsp;<br> 1.1.4 表示未知的价格 11&nbsp;<br> 1.1.5 LINQ和查询表达式 12&nbsp;<br> 1.2 C#（及相关技术）简史 16&nbsp;<br> 1.2.1 C#问世前的世界 16&nbsp;<br> 1.2.2 C#和.NET降生 17&nbsp;<br> 1.2.3 .NET 1.1的小幅更新和第一次重要跨越：.NET 2.0 18&nbsp;<br> 1.2.4 “下一代”产品 19&nbsp;<br> 1.2.5 历史回顾和争夺开发者之战 20&nbsp;<br> 1.3 .NET平台 22&nbsp;<br> 1.3.1 区分语言、运行时和库 22&nbsp;<br> 1.3.2 解开版本号的谜团 23&nbsp;<br> 1.4 采用代码段形式的全能代码 25&nbsp;<br> 1.4.1 代码段及其扩展形式 25&nbsp;<br> 1.4.2 Snippy介绍 27</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">.1.5 小结 28&nbsp;<br> 第2章 C# 1所搭建的核心基础 29&nbsp;<br> 2.1 委托 30&nbsp;<br> 2.1.1 简单委托的构成 30&nbsp;<br> 2.1.2 合并和删除委托 35&nbsp;<br> 2.1.3 对事件的简单讨论 36&nbsp;<br> 2.1.4 委托小结 37&nbsp;<br> 2.2 类型系统的特征 38&nbsp;<br> 2.2.1 C#在类型系统世界中的位置 38&nbsp;<br> 2.2.2 C# 1的类型系统在什么时候不够用 40&nbsp;<br> 2.2.3 C# 1的类型系统在什么时候会碍事 43&nbsp;<br> 2.2.4 类型系统特征总结 43&nbsp;<br> 2.3 值类型和引用类型 44&nbsp;<br> 2.3.1 现实世界中的值和引用 44&nbsp;<br> 2.3.2 值类型和引用类型基础知识 45&nbsp;<br> 2.3.3 走出误区 46&nbsp;<br> 2.3.4 装箱和拆箱 47&nbsp;<br> 2.3.5 值类型和引用类型小结 48&nbsp;<br> 2.4 C# 2和3：构建于坚实基础之上的新特性 49&nbsp;<br> 2.4.1 与委托有关的特性 49&nbsp;<br> 2.4.2 与类型系统有关的特性 51&nbsp;<br> 2.4.3 与值类型有关的特性 52&nbsp;<br> 2.5 小结 53&nbsp;<br> 第二部分 C# 2：解决C# 1的问题&nbsp;<br> 第3章 用泛型实现参数化类型 56&nbsp;<br> 3.1 为什么需要泛型 56&nbsp;<br> 3.2 日常使用的简单泛型 58&nbsp;<br> 3.2.1 通过例子来学习：泛型字典 58&nbsp;<br> 3.2.2 泛型类型和类型参数 60&nbsp;<br> 3.2.3 泛型方法和判读泛型声明 63&nbsp;<br> 3.3 深化与提高 66&nbsp;<br> 3.3.1 类型约束 66&nbsp;<br> 3.3.2 泛型方法类型实参的类型推断 70&nbsp;<br> 3.3.3 实现泛型 71&nbsp;<br> 3.4 高级泛型 75&nbsp;<br> 3.4.1 静态字段和静态构造函数 76&nbsp;<br> 3.4.2 JIT编译器如何处理泛型 77&nbsp;<br> 3.4.3 泛型迭代 79&nbsp;<br> 3.4.4 反射和泛型 82&nbsp;<br> 3.5 .NET 2.0中的泛型集合类 85&nbsp;<br> 3.5.1 List[T] 85&nbsp;<br> 3.5.2 Dictionary[TKey,TValue] 88&nbsp;<br> 3.5.3 Queue[T]和Stack[T] 89&nbsp;<br> 3.5.4 SortedList[TKey,TValue]和SortedDictionary[TKey,TValue] 90&nbsp;<br> 3.5.5 LinkedList[T] 90&nbsp;<br> 3.6 泛型在C#和其他语言中的限制 91&nbsp;<br> 3.6.1 协变性和逆变性的缺乏 91&nbsp;<br> 3.6.2 缺乏操作符约束或者“数值”约束 95&nbsp;<br> 3.6.3 缺乏泛型属性、索引器和其他成员类型 96&nbsp;<br> 3.6.4 同C++模板的对比 97&nbsp;<br> 3.6.5 和Java泛型的对比 98&nbsp;<br> 3.7 小结 99&nbsp;<br> 第4章 可空类型 101&nbsp;<br> 4.1 没有值时怎么办 101&nbsp;<br> 4.1.1 为什么值类型的变量不能是&nbsp;<br> null 102&nbsp;<br> 4.1.2 在C# 1中表示空值的模式 102&nbsp;<br> 4.2 System.Nullable[T]和System.Nullable 104&nbsp;<br> 4.2.1 Nullable[T]简介 104&nbsp;<br> 4.2.2 装箱和拆箱 106&nbsp;<br> 4.2.3 Nullable[T]实例的相等性 107&nbsp;<br> 4.2.4 来自非泛型Nullable类的支持 108&nbsp;<br> 4.3 C# 2为可空类型提供的语法糖 109&nbsp;<br> 4.3.1 ?修饰符 109&nbsp;<br> 4.3.2 使用null进行赋值和比较 110&nbsp;<br> 4.3.3 可空转换和操作符 112&nbsp;<br> 4.3.4 可空逻辑 115&nbsp;<br> 4.3.5 空接合操作符 116&nbsp;<br> 4.4 可空类型的新奇用法 118&nbsp;<br> 4.4.1 尝试一个不使用输出参数的操作 119&nbsp;<br> 4.4.2 空接合操作符让比较不再痛苦 121&nbsp;<br> 4.5 小结 123&nbsp;<br> 第5章 进入快速通道的委托 124&nbsp;<br> 5.1 向笨拙的委托语法说拜拜 125&nbsp;<br> 5.2 方法组转换 126&nbsp;<br> 5.3 协变性和逆变性 127&nbsp;<br> 5.4 使用匿名方法的内联委托操作 130&nbsp;<br> 5.4.1 从简单的开始：处理一个参数 131&nbsp;<br> 5.4.2 匿名方法的返回值 133&nbsp;<br> 5.4.3 忽略委托参数 134&nbsp;<br> 5.5 在匿名方法中捕捉变量 136&nbsp;<br> 5.5.1 定义闭包和不同的变量类型 136&nbsp;<br> 5.5.2 测试被捕获的变量的行为 137&nbsp;<br> 5.5.3 捕获变量到底有什么用处 138&nbsp;<br> 5.5.4 捕获变量的延长生存期 139&nbsp;<br> 5.5.5 局部变量实例化 140&nbsp;<br> 5.5.6 共享和非共享的变量混合使用 142&nbsp;<br> 5.5.7 捕获变量的使用规则和小结 143&nbsp;<br> 5.6 小结 144&nbsp;<br> 第6章 实现迭代器的捷径 146&nbsp;<br> 6.1 C# 1：手写迭代器的痛苦 147&nbsp;<br> 6.2 C# 2：利用yield语句简化迭代器 149&nbsp;<br> 6.2.1 迭代器块和yield return简介 150&nbsp;<br> 6.2.2 观察迭代器的工作流程 151&nbsp;<br> 6.2.3 进一步了解迭代器执行流程 153&nbsp;<br> 6.2.4 具体实现中的奇特之处 156&nbsp;<br> 6.3 真实的例子：迭代范围值 157&nbsp;<br> 6.3.1 迭代时刻表中的日期 157&nbsp;<br> 6.3.2 定义Range类的作用域 158&nbsp;<br> 6.3.3 使用迭代器块的实现代码 159&nbsp;<br> 6.4 使用CCR实现伪同步代码 162&nbsp;<br> 6.5 小结 164&nbsp;<br> 第7章 结束C# 2的讲解：最后的一些特性 166&nbsp;<br> 7.1 分部类型 167&nbsp;<br> 7.1.1 在多个文件中创建一个类型 167&nbsp;<br> 7.1.2 分部类型的使用 169&nbsp;<br> 7.1.3 C# 3独有的分部方法 170&nbsp;<br> 7.2 静态类型 172&nbsp;<br> 7.3 独立的取值方法/赋值方法属性访问器 174&nbsp;<br> 7.4 命名空间别名 175&nbsp;<br> 7.4.1 限定的命名空间别名 176&nbsp;<br> 7.4.2 全局命名空间别名 177&nbsp;<br> 7.4.3 外部别名 178&nbsp;<br> 7.5 Pragma指令 179&nbsp;<br> 7.5.1 警告pragma 179&nbsp;<br> 7.5.2 校验和pragma 180&nbsp;<br> 7.6 非安全代码中的固定大小的缓冲区 180&nbsp;<br> 7.7 把内部成员暴露给选定的程序集 182&nbsp;<br> 7.7.1 在简单情况下的友元程序集 182&nbsp;<br> 7.7.2 为什么使用InternalsVisibleTo 184&nbsp;<br> 7.7.3 InternalsVisibleTo和签名程序集 184&nbsp;<br> 7.8 小结 185&nbsp;<br> 第三部分 C# 3——革新写代码的方式&nbsp;<br> 第8章 用智能的编译器来防错 188&nbsp;<br> 8.1 自动实现的属性 189&nbsp;<br> 8.2 隐式类型的局部变量 191&nbsp;<br> 8.2.1 用var声明局部变量 191&nbsp;<br> 8.2.2 隐式类型的限制 192&nbsp;<br> 8.2.3 隐式类型的优缺点 193&nbsp;<br> 8.2.4 建议 194&nbsp;<br> 8.3 简化的初始化 194&nbsp;<br> 8.3.1 定义示例类型 195&nbsp;<br> 8.3.2 设置简单属性 196&nbsp;<br> 8.3.3 为嵌入对象设置属性 197&nbsp;<br> 8.3.4 集合初始化列表 198&nbsp;<br> 8.3.5 初始化特性的应用 200&nbsp;<br> 8.4 隐式类型的数组 201&nbsp;<br> 8.5 匿名类型 202&nbsp;<br> 8.5.1 第一次邂逅匿名类型 202&nbsp;<br> 8.5.2 匿名类型的成员 204&nbsp;<br> 8.5.3 投影初始化列表 205&nbsp;<br> 8.5.4 重点何在 206&nbsp;<br> 8.6 小结 207&nbsp;<br> 第9章 Lambda表达式和表达式树 208&nbsp;<br> 9.1 作为委托的Lambda表达式 209&nbsp;<br> 9.1.1 准备工作：Func[...]委托类型简介 209&nbsp;<br> 9.1.2 第一次转换成Lambda表达式 210&nbsp;<br> 9.1.3 用一个简单表达式作为主体 211&nbsp;<br> 9.1.4 隐式类型的参数列表 211&nbsp;<br> 9.1.5 单一参数的快捷语法 212&nbsp;<br> 9.2 使用List[T]和事件的简单例子 213&nbsp;<br> 9.2.1 对列表进行筛选、排序并设置其他操作 213&nbsp;<br> 9.2.2 在事件处理程序中进行记录 214&nbsp;<br> 9.3 表达式树 216&nbsp;<br> 9.3.1 在程序中构建表达式树 216&nbsp;<br> 9.3.2 将表达式树编译成委托 217&nbsp;<br> 9.3.3 将C# Lambda表达式转换成表达式树 218&nbsp;<br> 9.3.4 位于LINQ核心的表达式树 221&nbsp;<br> 9.4 类型推断和重载决策发生的改变 222&nbsp;<br> 9.4.1 改变的起因：精简泛型方法调用 222&nbsp;<br> 9.4.2 推断匿名函数的返回类型 223&nbsp;<br> 9.4.3 分两个阶段进行的类型推断 225&nbsp;<br> 9.4.4 选择正确的被重载的方法 227&nbsp;<br> 9.4.5 类型推断和重载决策 229&nbsp;<br> 9.5 小结 229&nbsp;<br> 第10章 扩展方法 231&nbsp;<br> 10.1 未引入扩展方法之前的状态 231&nbsp;<br> 10.2 扩展方法的语法 233&nbsp;<br> 10.2.1 声明扩展方法 234&nbsp;<br> 10.2.2 调用扩展方法 235&nbsp;<br> 10.2.3 扩展方法是怎样被发现的 236&nbsp;<br> 10.2.4 在空引用上调用方法 237&nbsp;<br> 10.3 .NET 3.5中的扩展方法 238&nbsp;<br> 10.3.1 从Enumerable开始起步 238&nbsp;<br> 10.3.2 用Where筛选并将方法调用链接到一起 240&nbsp;<br> 10.3.3 用Select方法和匿名类型进行投影 241&nbsp;<br> 10.3.4 用OrderBy方法进行排序 242&nbsp;<br> 10.3.5 涉及链接的实际例子 243&nbsp;<br> 10.4 使用思路和原则 244&nbsp;<br> 10.4.1 “扩展世界”和使接口更丰富 245&nbsp;<br> 10.4.2 流畅接口 245&nbsp;<br> 10.4.3 理智使用扩展方法 247&nbsp;<br> 10.5 小结 248&nbsp;<br> 第11章 查询表达式和LINQ to Object 249&nbsp;<br> 11.1 LINQ介绍 250&nbsp;<br> 11.1.1 这个名称中有什么 250&nbsp;<br> 11.1.2 LINQ中的基础概念 251&nbsp;<br> 11.1.3 定义示例数据模型 254&nbsp;<br> 11.2 简单的开始：选择元素 256&nbsp;<br> 11.2.1 以数据源作为开始，以选择作为结束 256&nbsp;<br> 11.2.2 作为查询表达式基础的编译&nbsp;<br> 器转换 257&nbsp;<br> 11.2.3 范围变量和重要的投影 259&nbsp;<br> 11.2.4 Cast、OfType和显式类型的范围变量 261&nbsp;<br> 11.3 对序列进行过滤和排序 262&nbsp;<br> 11.3.1 使用where子句进行过滤 263&nbsp;<br> 11.3.2 退化的查询表达式 264&nbsp;<br> 11.3.3 使用orderby子句进行排序 264&nbsp;<br> 11.4 let子句和透明标识符 266&nbsp;<br> 11.4.1 用let来进行中间计算 266&nbsp;<br> 11.4.2 透明标识符 267&nbsp;<br> 11.5 联接 268&nbsp;<br> 11.5.1 使用join子句的内联接 269&nbsp;<br> 11.5.2 使用join...into子句进行分组联接 272&nbsp;<br> 11.5.3 使用多个from子句进行交叉联接 274&nbsp;<br> 11.6 分组和延续 277&nbsp;<br> 11.6.1 使用group...by子句进行分组 277&nbsp;<br> 11.6.2 查询延续 280&nbsp;<br> 11.7 小结 283&nbsp;<br> 第12章 超越集合的LINQ 284&nbsp;<br> 12.1 LINQ to SQL 285&nbsp;<br> 12.1.1 创建缺陷数据库和实体 285&nbsp;<br> 12.1.2 用示例数据填充数据库 287&nbsp;<br> 12.1.3 用查询表达式访问数据库 288&nbsp;<br> 12.1.4 更新数据库 293&nbsp;<br> 12.1.5 LINQ to SQL小结 294&nbsp;<br> 12.2 用IQueryable和IQueryProvider进行转换 294&nbsp;<br> 12.2.1 IQueryable[T]和相关接口的介绍 295&nbsp;<br> 12.2.2 模拟接口实现来记录调用 296&nbsp;<br> 12.2.3 把表达式粘合在一起：Queryable的扩展方法 298&nbsp;<br> 12.2.4 模拟实际运行的查询提供器 300&nbsp;<br> 12.2.5 包装IQueryable 301&nbsp;<br> 12.3 LINQ to DataSet 302&nbsp;<br> 12.3.1 处理非类型化数据集 302&nbsp;<br> 12.3.2 处理类型化数据集 303&nbsp;<br> 12.4 LINQ to XML 306&nbsp;<br> 12.4.1 XElement和XAttribute 306&nbsp;<br> 12.4.2 把示例缺陷数据转换为XML 307&nbsp;<br> 12.4.3 在LINQ to XML中进行查询 309&nbsp;<br> 12.4.4 LINQ to XML小结 311&nbsp;<br> 12.5 超越.NET 3.5的LINQ 311&nbsp;<br> 12.5.1 第三方LINQ 312&nbsp;<br> 12.5.2 未来的微软LINQ技术 315&nbsp;<br> 12.6 小结 317&nbsp;<br> 第13章 新时代的优雅代码 319&nbsp;<br> 13.1 语言特性 320&nbsp;<br> 13.1.1 更重视函数化 320&nbsp;<br> 13.1.2 静态、动态、隐式、显式或混合 321&nbsp;<br> 13.2 把委托作为实现继承的新方式 321&nbsp;<br> 13.3 易读的结果高于实现 322&nbsp;<br> 13.4 并行宇宙中的生活 323&nbsp;<br> 13.5 再见 324&nbsp;<br> 附录A LINQ标准查询操作符 325</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">下载地址：<a href="http://www.ppurl.com/2010/03/c-in-depth-2.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">英文下载地址</a></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p><font color="#333333"><span style="font-size:14px;">本文转自kyo-yo博客园博客，原文链接：http://www.cnblogs.com/kyo-yo/archive/2010/05/15/CSharp-In-Depth.html，如需转载请自行联系原作者</span></font></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
