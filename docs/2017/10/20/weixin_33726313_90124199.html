<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>iOS:iOS开发系列–打造自己的“美图秀秀”(上) « NotBeCN</title>
  <meta name="description" content="                  来源：&nbsp;KenshinCui &nbsp;&nbsp;     链接：http://www.cnblogs.com/kenshincui/p/3959951.html     概述     在iOS中可以很容易的开发出绚丽的界面效果，一方面得益于成功系统的设计，另一方...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/20/weixin_33726313_90124199.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">iOS:iOS开发系列–打造自己的“美图秀秀”(上)</h1>
    <p class="post-meta">Oct 20, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">来源：&nbsp;KenshinCui &nbsp;&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">链接：<a href="http://www.cnblogs.com/kenshincui/p/3959951.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">http://www.cnblogs.com/kenshincui/p/3959951.html</a></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>概述</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在iOS中可以很容易的开发出绚丽的界面效果，一方面得益于成功系统的设计，另一方面得益于它强大的开发框架。今天我们将围绕iOS中两大图形、图像绘图框架进行介绍：Quartz 2D绘制2D图形和Core Image中强大的滤镜功能。</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>Quartz 2D</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在iOS中常用的绘图框架就是Quartz 2D，Quartz 2D是Core Graphics框架的一部分，是一个强大的二维图像绘制引擎。Quartz 2D在UIKit中也有很好的封装和集成，我们日常开发时所用到的UIKit中的组件都是由Core Graphics进行绘制的。不仅如此，当我们引入UIKit框架时系统会自动引入Core Graphics框架，并且为了方便开发者使用在UIKit内部还对一些常用的绘图API进行了封装。</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在iOS中绘图一般分为以下几个步骤：</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">1.获取绘图上下文</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">2.创建并设置路径</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">3.将路径添加到上下文</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">4.设置上下文状态</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">5.绘制路径</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">6.释放路径</span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">图形上下文CGContextRef代表图形输出设备（也就是绘制的位置），包含了绘制图形的一些设备信息，Quartz 2D中的所有对象最终都必须绘制到图形上下文。这样一来，我们在绘制图形时就不必关心具体的设备信息，统一了代码编写方式（在Quartz 2D中的绘图上下文可以是位图Bitmap、PDF、窗口Window、层Layer、打印对象Printer）。</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>基本图形绘制</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在UIKit中默认已经为我们准备好了一个图形上下文对象，在UI控件的drawRect:方法（这个方法在loadView、viewDidLoad方法后执行）中我们可以通过UIKit封装函数UIGraphicsGetCurrentContext()方法获得这个图形上下文(注意在其他UI控件方法中无法取得这个对象)，然后我们只要按照绘图步骤一步步执行即可。下面自定义一个KCView继承自UIView，重写drawRect:方法绘制两条直线说明上面绘图的步骤：</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">*
 基本绘图
 </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span>
 
<span style="line-height:1.8;color:rgb(0,0,255);">#import</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">KCView.h</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>
 
<span style="line-height:1.8;color:rgb(0,0,255);">@implementation</span><span style="line-height:1.8;"> KCView
 
</span><span style="line-height:1.8;color:rgb(128,0,0);">#pragma mark 绘图</span>
<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘图只能在此方法中调用，否则无法得到当前图形上下文</span>
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawRect:(CGRect)rect{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">1.取得图形上下文对象</span>
    CGContextRef context =<span style="line-height:1.8;"> UIGraphicsGetCurrentContext();
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">2.创建路径对象</span>
    CGMutablePathRef path =<span style="line-height:1.8;"> CGPathCreateMutable();
    CGPathMoveToPoint(path, nil, </span><span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">移动到指定位置（设置路径起点）</span>
    CGPathAddLineToPoint(path, nil, <span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制直线（从起始位置开始）</span>
    CGPathAddLineToPoint(path, nil, <span style="line-height:1.8;color:rgb(128,0,128);">300</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制另外一条直线（从上一直线终点开始绘制）
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">3.添加路径到图形上下文</span>
<span style="line-height:1.8;">    CGContextAddPath(context, path);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">4.设置图形上下文状态属性</span>
    CGContextSetRGBStrokeColor(context, <span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">1</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置笔触颜色</span>
    CGContextSetRGBFillColor(context, <span style="line-height:1.8;color:rgb(128,0,128);">0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">1</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置填充色</span>
    CGContextSetLineWidth(context, <span style="line-height:1.8;color:rgb(128,0,128);">2.0</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置线条宽度</span>
    CGContextSetLineCap(context, kCGLineCapRound);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置顶点样式,（20,50）和（300,100）是顶点</span>
    CGContextSetLineJoin(context, kCGLineJoinRound);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置连接点样式，(20,100)是连接点</span>
    <span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">设置线段样式
    phase:虚线开始的位置
    lengths:虚线长度间隔（例如下面的定义说明第一条线段长度8，然后间隔3重新绘制8点的长度线段，当然这个数组可以定义更多元素）
    count:虚线数组元素个数
    </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGFloat lengths[</span><span style="line-height:1.8;color:rgb(128,0,128);">2</span>] = { <span style="line-height:1.8;color:rgb(128,0,128);">18</span>, <span style="line-height:1.8;color:rgb(128,0,128);">9</span><span style="line-height:1.8;"> };
    CGContextSetLineDash(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">0</span>, lengths, <span style="line-height:1.8;color:rgb(128,0,128);">2</span><span style="line-height:1.8;">);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">设置阴影
    context:图形上下文
    offset:偏移量
    blur:模糊度
    color:阴影颜色
    </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGColorRef color </span>= [UIColor grayColor].CGColor;<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">颜色转化，由于Quartz 2D跨平台，所以其中不能使用UIKit中的对象，但是UIkit提供了转化方法</span>
    CGContextSetShadowWithColor(context, CGSizeMake(<span style="line-height:1.8;color:rgb(128,0,128);">2</span>, <span style="line-height:1.8;color:rgb(128,0,128);">2</span>), <span style="line-height:1.8;color:rgb(128,0,128);">0.8</span><span style="line-height:1.8;">, color);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">5.绘制图像到指定图形上下文</span>
    <span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">CGPathDrawingMode是填充方式,枚举类型
    kCGPathFill:只有填充（非零缠绕数填充），不绘制边框
    kCGPathEOFill:奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充）
    kCGPathStroke:只有边框
    kCGPathFillStroke：既有边框又有填充
    kCGPathEOFillStroke：奇偶填充并绘制边框
    </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGContextDrawPath(context, kCGPathFillStroke);</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">最后一个参数是填充类型
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">6.释放对象</span>
<span style="line-height:1.8;">    CGPathRelease(path);
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">@end</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在视图控制器创建KCView并添加到根视图中：</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>- (<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)viewDidLoad {
    [super viewDidLoad];
 
    KCView </span>*view=<span style="line-height:1.8;">[[KCView alloc]initWithFrame:[UIScreen mainScreen].bounds];
    view.backgroundColor</span>=<span style="line-height:1.8;">[UIColor whiteColor];
    [self.view addSubview:view];
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318102525881-1533835128.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>简化绘图方式</strong></span><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">上面的绘图方式未免显得有些麻烦，其实Core Graphics 内部对创建对象添加到上下文这两步操作进行了封装，可以一步完成。另外前面也说过UIKit内部其实封装了一些以“UI”开头的方法帮助大家进行图形绘制。就拿前面的例子来说我们改进一些绘制方法：</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawLine2{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">1.获得图形上下文</span>
    CGContextRef context=<span style="line-height:1.8;">UIGraphicsGetCurrentContext();
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">2.绘制路径（相当于前面创建路径并添加路径到图形上下文两步操作）</span>
    CGContextMoveToPoint(context, <span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span><span style="line-height:1.8;">);
    CGContextAddLineToPoint(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100</span><span style="line-height:1.8;">);
    CGContextAddLineToPoint(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">300</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100</span><span style="line-height:1.8;">);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">封闭路径:a.创建一条起点和终点的线,不推荐
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">CGPathAddLineToPoint(path, nil, 20, 50);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">封闭路径:b.直接调用路径封闭方法</span>
<span style="line-height:1.8;">    CGContextClosePath(context);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">3.设置图形上下文属性</span>
    [[UIColor redColor]setStroke];<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置红色边框</span>
    [[UIColor greenColor]setFill];<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置绿色填充
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">[[UIColor blueColor]set];</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">同时设置填充和边框色
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">4.绘制路径</span>
<span style="line-height:1.8;">    CGContextDrawPath(context, kCGPathFillStroke);
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">上面的操作相比前面的方法应该说已经简化了不少，除了路径之外其他矩形、椭圆等都有对应的创建方法。另外上面我们也演示了封闭路径的方法，大家可以运行看一下效果。</span><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>其他图形绘制</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">相信大家了解了上面的绘制步骤其他图形绘制并不麻烦，下面以一个例子简单演示一下其他图形的绘制，包括文字和图像的绘制。</span><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>绘制矩形</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在下面的方法中还可以看到UIKit对绘图方法的封装，使用起来更加简单。</span></p> 
    <p>&nbsp;</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(128,0,0);">#pragma mark 绘制矩形</span>
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawRectWithContext:(CGContextRef)context{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">添加矩形对象</span>
    CGRect rect=CGRectMake(<span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span>, <span style="line-height:1.8;color:rgb(128,0,128);">280.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50.0</span><span style="line-height:1.8;">);
    CGContextAddRect(context,rect);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置属性</span>
    [[UIColor blueColor]<span style="line-height:1.8;color:rgb(0,0,255);">set</span><span style="line-height:1.8;">];
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制</span>
<span style="line-height:1.8;">    CGContextDrawPath(context, kCGPathFillStroke);
}
 
</span><span style="line-height:1.8;color:rgb(128,0,0);">#pragma mark 绘制矩形（利用UIKit的封装方法）</span>
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawRectByUIKitWithContext:(CGContextRef)context{
    CGRect rect</span>= CGRectMake(<span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">150</span>, <span style="line-height:1.8;color:rgb(128,0,128);">280.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50.0</span><span style="line-height:1.8;">);
    CGRect rect2</span>=CGRectMake(<span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">250</span>, <span style="line-height:1.8;color:rgb(128,0,128);">280.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50.0</span><span style="line-height:1.8;">);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置属性</span>
    [[UIColor yellowColor]<span style="line-height:1.8;color:rgb(0,0,255);">set</span><span style="line-height:1.8;">];
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制矩形,相当于创建对象、添加对象到上下文、绘制三个步骤</span>
    UIRectFill(rect);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制矩形（只有填充）</span>
<span style="line-height:1.8;"> 
    [[UIColor redColor]setStroke];
    UIRectFrame(rect2);</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制矩形(只有边框)</span>
<span style="line-height:1.8;">}
</span><span style="line-height:1.8;color:rgb(0,0,255);">@end</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318102753084-343169955.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>绘制椭圆</strong></span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(0,0,255);">#pragma</span> mark 绘制椭圆
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawEllipse:(CGContextRef)context{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">添加对象,绘制椭圆（圆形）的过程也是先创建一个矩形</span>
    CGRect rect=CGRectMake(<span style="line-height:1.8;color:rgb(128,0,128);">50</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span>, <span style="line-height:1.8;color:rgb(128,0,128);">220.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">200.0</span><span style="line-height:1.8;">);
    CGContextAddEllipseInRect(context, rect);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置属性</span>
    [[UIColor purpleColor]<span style="line-height:1.8;color:rgb(0,0,255);">set</span><span style="line-height:1.8;">];
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制</span>
<span style="line-height:1.8;">    CGContextDrawPath(context, kCGPathFillStroke);
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">@end</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:16px;">运行效果：</span></p> 
    <p>&nbsp;</p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318103839037-1006569496.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>绘制弧形</strong></span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawArc:(CGContextRef)context{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">添加弧形对象
     x:中心点x坐标
     y:中心点y坐标
     radius:半径
     startAngle:起始弧度
     endAngle:终止弧度
     closewise:是否逆时针绘制，0则顺时针绘制
    </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGContextAddArc(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">160</span>, <span style="line-height:1.8;color:rgb(128,0,128);">160</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100.0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">0.0</span>, M_PI_2, <span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置属性</span>
    [[UIColor yellowColor]<span style="line-height:1.8;color:rgb(0,0,255);">set</span><span style="line-height:1.8;">];
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制</span>
<span style="line-height:1.8;">    CGContextDrawPath(context, kCGPathFillStroke);
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:16px;">运行效果：</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:16px;"><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318103932334-832653149.png" alt="" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>绘制贝塞尔曲线</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">要绘制规则图形在iOS中相当简单，但是不规则图形怎么绘制呢？此时就要利用路径。前面我们绘制了直线，它和曲线绘制都属于路径绘制。和直线绘制相比曲线绘制就要复杂一些，但是路径作为高级动画的基础又是我们必须掌握的，因此这里我们就一起来熟悉一下曲线绘制。在Quartz 2D中曲线绘制分为两种：二次贝塞尔曲线和三次贝塞尔曲线。二次曲线只有一个控制点，而三次曲线有两个控制点，如下图所示：</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104018849-1633352426.png" alt="" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">当然，在iOS中两种曲线分别对应两种方法：</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y);&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">CGContextAddCurveToPoint(context, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y);</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">下面就演示一下这两种曲线的绘制方法</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(128,0,0);">#pragma mark 绘制贝塞尔曲线</span>
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawCurve:(CGContextRef)context{
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制曲线</span>
    CGContextMoveToPoint(context, <span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">移动到起始位置</span>
    <span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制二次贝塞尔曲线
     c:图形上下文
     cpx:控制点x坐标
     cpy:控制点y坐标
     x:结束点x坐标
     y:结束点y坐标
    </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGContextAddQuadCurveToPoint(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">160</span>, <span style="line-height:1.8;color:rgb(128,0,128);">0</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span>, <span style="line-height:1.8;color:rgb(128,0,128);">100</span><span style="line-height:1.8;">);
 
    CGContextMoveToPoint(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">500</span><span style="line-height:1.8;">);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制三次贝塞尔曲线
     c:图形上下文
     cp1x:第一个控制点x坐标
     cp1y:第一个控制点y坐标
     cp2x:第二个控制点x坐标
     cp2y:第二个控制点y坐标
     x:结束点x坐标
     y:结束点y坐标
    </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGContextAddCurveToPoint(context, </span><span style="line-height:1.8;color:rgb(128,0,128);">80</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span>, <span style="line-height:1.8;color:rgb(128,0,128);">240</span>, <span style="line-height:1.8;color:rgb(128,0,128);">500</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span><span style="line-height:1.8;">);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置图形上下文属性</span>
<span style="line-height:1.8;">    [[UIColor yellowColor]setFill];
    [[UIColor redColor]setStroke];
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制路径</span>
<span style="line-height:1.8;">    CGContextDrawPath(context, kCGPathFillStroke);
 
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104122568-321123105.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">备注:贝塞尔曲线是由法国数学家“贝塞尔”发现的，他发现：任何一条曲线都能够由和它相切的直线的两个端点来描述，这种曲线表示方式后来被广泛应用到计算机中，称为“贝塞尔曲线”。</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>文字绘制</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">除了绘制图形还可以绘制文本内容。</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawText:(CGContextRef)context{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制到指定的区域内容</span>
    NSString *str=<span style="line-height:1.8;color:rgb(128,0,0);">@"</span><span style="line-height:1.8;color:rgb(128,0,0);">Star Walk is the most beautiful stargazing app you’ve ever seen on a mobile device. It will become your go-to interactive astro guide to the night sky, following your every movement in real-time and allowing you to explore over 200, 000 celestial bodies with extensive information about stars and constellations that you find.</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
    CGRect rect</span>= CGRectMake(<span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span>, <span style="line-height:1.8;color:rgb(128,0,128);">280</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span><span style="line-height:1.8;">);
    UIFont </span>*font=[UIFont systemFontOfSize:<span style="line-height:1.8;color:rgb(128,0,128);">18</span>];<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">设置字体</span>
    UIColor *color=[UIColor redColor];<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">字体颜色</span>
    NSMutableParagraphStyle *style=[[NSMutableParagraphStyle alloc]init];<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">段落样式</span>
    NSTextAlignment align=NSTextAlignmentLeft;<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">对齐方式</span>
    style.alignment=<span style="line-height:1.8;">align;
    [str drawInRect:rect withAttributes:@{NSFontAttributeName:font,NSForegroundColorAttributeName:color,NSParagraphStyleAttributeName:style}];
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104217537-1034571366.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>图像绘制</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">Quartz 2D还可以将图像绘制到图形上下文。</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawImage:(CGContextRef)context{
    UIImage </span>*image=[UIImage imageNamed:<span style="line-height:1.8;color:rgb(128,0,0);">@"</span><span style="line-height:1.8;color:rgb(128,0,0);">image2.jpg</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">];
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">从某一点开始绘制</span>
    [image drawAtPoint:CGPointMake(<span style="line-height:1.8;color:rgb(128,0,128);">10</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span><span style="line-height:1.8;">)];
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制到指定的矩形中，注意如果大小不合适会会进行拉伸
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">    [image drawInRect:CGRectMake(10, 50, 300, 450)];
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">平铺绘制
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">    [image drawAsPatternInRect:CGRectMake(0, 0, 320, 568)];</span>
}</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104301849-722785377.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>绘制渐变填充</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">从前面的示例中我们可以看到如何设置填充颜色，事实上很多时候纯色的填充并不能满足我们的需求，例如有时候我们要绘制一些图形可能需要设置一个漂亮的背景，这个时候我们可能就会选择渐变填充方式。Quartz 2D的渐变方式分为两种：</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">a.线性渐变线：渐变色以直线方式从开始位置逐渐向结束位置渐变</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">b.径向渐变：以中心点为圆心从起始渐变色向四周辐射，直到终止渐变色</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">要做渐变则必须先设置从开始位置到结束位置的渐变颜色，做过photoshop的朋友相信对于渐变色设置并不陌生，只要在指定位置指定不同的颜色，剩下的事情交给系统处理即可，如下图在起始位置、3/10位置、结束位置指定了三种颜色就形成由三种颜色组成的渐变色：</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104343646-597014412.png" alt="" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">另外，在iOS中绘制渐变还需要注意一点就是指定颜色空间，所谓颜色空间就是不同颜色在不同的维度上取值最终组成一种颜色的过程。就拿RGB来说，如果将红色、绿色、蓝色看成是x、y、z轴坐标系，那么在三个坐标上分别取0~255范围内的不同值则可以组成各类颜色。当然，不同颜色空间的“坐标系”也是不同的（也就是说颜色表示的方式是不同的），常用的颜色空间除了RGB还有CMYK（印刷业常用这种颜色模式）、Gray。</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">在使用Quartz 2D绘图时我们的颜色除了使用常规的方法（如何前面CGContextSetRGBFillColor(CGContextRef context, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)方法）设置RGB和透明度外，有时还会遇到颜色参数是一个数组情况。如使用颜色空间填充时用到的CGContextSetFillColor(CGContextRef context, const CGFloat *components)方法，这个时候components数组中具体是如何存储颜色就要根据颜色空间而定，如果颜色空间使用RGB则数组中的元素四个为一组，分别是red（红）、green（绿）、blue（蓝）、alpha（透明度）；如果使用CMYK颜色空间，那么数组中的元素五个为一组，分别是cyan（青）、magenta（洋红）、yellow（黄）、black（黑）、alpha（透明度）。</span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">下面的代码分别演示了两种渐变方式，具体渐变绘制函数参数代码中已经注释的很清楚了：</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(0,0,255);">#import</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">KCView3.h</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span>
 
<span style="line-height:1.8;color:rgb(0,0,255);">@implementation</span><span style="line-height:1.8;"> KCView3
 
</span>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawRect:(CGRect)rect{
    CGContextRef context</span>=<span style="line-height:1.8;">UIGraphicsGetCurrentContext();
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">    [self drawLinearGradient:context];</span>
<span style="line-height:1.8;">    [self drawRadialGradient:context];
}
 
</span><span style="line-height:1.8;color:rgb(128,0,0);">#pragma mark 线性渐变</span>
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawLinearGradient:(CGContextRef)context{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">使用rgb颜色空间</span>
    CGColorSpaceRef colorSpace=<span style="line-height:1.8;">CGColorSpaceCreateDeviceRGB();
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">指定渐变色
     space:颜色空间
     components:颜色数组,注意由于指定了RGB颜色空间，那么四个数组元素表示一个颜色（red、green、blue、alpha），
                如果有三个颜色则这个数组有4*3个元素
     locations:颜色所在位置（范围0~1），这个数组的个数不小于components中存放颜色的个数
     count:渐变个数，等于locations的个数
     </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGFloat compoents[</span><span style="line-height:1.8;color:rgb(128,0,128);">12</span>]=<span style="line-height:1.8;">{
        </span><span style="line-height:1.8;color:rgb(128,0,128);">248.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">86.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">86.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">,
        </span><span style="line-height:1.8;color:rgb(128,0,128);">249.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">127.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">127.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">,
        </span><span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span><span style="line-height:1.8;">
    };
    CGFloat locations[</span><span style="line-height:1.8;color:rgb(128,0,128);">3</span>]={<span style="line-height:1.8;color:rgb(128,0,128);">0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">0.3</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span><span style="line-height:1.8;">};
    CGGradientRef gradient</span>= CGGradientCreateWithColorComponents(colorSpace, compoents, locations, <span style="line-height:1.8;color:rgb(128,0,128);">3</span><span style="line-height:1.8;">);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制线性渐变
     context:图形上下文
     gradient:渐变色
     startPoint:起始位置
     endPoint:终止位置
     options:绘制方式,kCGGradientDrawsBeforeStartLocation 开始位置之前就进行绘制，到结束位置之后不再绘制，
             kCGGradientDrawsAfterEndLocation开始位置之前不进行绘制，到结束点之后继续填充
     </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGContextDrawLinearGradient(context, gradient, CGPointZero, CGPointMake(</span><span style="line-height:1.8;color:rgb(128,0,128);">320</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span><span style="line-height:1.8;">), kCGGradientDrawsAfterEndLocation);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">释放颜色空间</span>
<span style="line-height:1.8;">    CGColorSpaceRelease(colorSpace);
}
 
</span><span style="line-height:1.8;color:rgb(128,0,0);">#pragma mark 径向渐变</span>
-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawRadialGradient:(CGContextRef)context{
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">使用rgb颜色空间</span>
    CGColorSpaceRef colorSpace=<span style="line-height:1.8;">CGColorSpaceCreateDeviceRGB();
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">指定渐变色
     space:颜色空间
     components:颜色数组,注意由于指定了RGB颜色空间，那么四个数组元素表示一个颜色（red、green、blue、alpha），
     如果有三个颜色则这个数组有4*3个元素
     locations:颜色所在位置（范围0~1），这个数组的个数不小于components中存放颜色的个数
     count:渐变个数，等于locations的个数
     </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGFloat compoents[</span><span style="line-height:1.8;color:rgb(128,0,128);">12</span>]=<span style="line-height:1.8;">{
        </span><span style="line-height:1.8;color:rgb(128,0,128);">248.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">86.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">86.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">,
        </span><span style="line-height:1.8;color:rgb(128,0,128);">249.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">127.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">127.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">,
        </span><span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span><span style="line-height:1.8;">
    };
    CGFloat locations[</span><span style="line-height:1.8;color:rgb(128,0,128);">3</span>]={<span style="line-height:1.8;color:rgb(128,0,128);">0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">0.3</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span><span style="line-height:1.8;">};
    CGGradientRef gradient</span>= CGGradientCreateWithColorComponents(colorSpace, compoents, locations, <span style="line-height:1.8;color:rgb(128,0,128);">3</span><span style="line-height:1.8;">);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">绘制径向渐变
     context:图形上下文
     gradient:渐变色
     startCenter:起始点位置
     startRadius:起始半径（通常为0，否则在此半径范围内容无任何填充）
     endCenter:终点位置（通常和起始点相同，否则会有偏移）
     endRadius:终点半径（也就是渐变的扩散长度）
     options:绘制方式,kCGGradientDrawsBeforeStartLocation 开始位置之前就进行绘制，但是到结束位置之后不再绘制，
             kCGGradientDrawsAfterEndLocation开始位置之前不进行绘制，但到结束点之后继续填充
     </span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span><span style="line-height:1.8;">
    CGContextDrawRadialGradient(context, gradient, CGPointMake(</span><span style="line-height:1.8;color:rgb(128,0,128);">160</span>, <span style="line-height:1.8;color:rgb(128,0,128);">284</span>),<span style="line-height:1.8;color:rgb(128,0,128);">0</span>, CGPointMake(<span style="line-height:1.8;color:rgb(128,0,128);">165</span>, <span style="line-height:1.8;color:rgb(128,0,128);">289</span>), <span style="line-height:1.8;color:rgb(128,0,128);">150</span><span style="line-height:1.8;">, kCGGradientDrawsAfterEndLocation);
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">释放颜色空间</span>
<span style="line-height:1.8;">    CGColorSpaceRelease(colorSpace);
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">@end</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104509459-1358695174.png" alt="" style="border:0px;">&nbsp;<img src="https://images2015.cnblogs.com/blog/791499/201603/791499-20160318104515303-657879365.png" alt="" style="border:0px;"></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;"><strong>扩展–渐变填充</strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';font-size:18px;">上面我们只是绘制渐变到图形上下文，实际开发中有时候我们还需要填充对应的渐变色，例如现在绘制了一个矩形，如何填充成渐变色呢？在此可以利用渐变裁切来完成（当然利用层CALayer更加方便但这不在今天的话题讨论范围内），特别说明一下区域裁切并不仅仅适用于渐变填充，对于其他图形绘制仍然适用，并且注意裁切只能限于矩形裁切。</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>-(<span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;">)drawRectWithLinearGradientFill:(CGContextRef)context{
    CGColorSpaceRef colorSpace</span>=<span style="line-height:1.8;">CGColorSpaceCreateDeviceRGB();
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">裁切处一块矩形用于显示，注意必须先裁切再调用渐变
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">CGContextClipToRect(context, CGRectMake(20, 50, 280, 300));
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">裁切还可以使用UIKit中对应的方法</span>
    UIRectClip(CGRectMake(<span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span>, <span style="line-height:1.8;color:rgb(128,0,128);">280</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span><span style="line-height:1.8;">));
 
    CGFloat compoents[</span><span style="line-height:1.8;color:rgb(128,0,128);">12</span>]=<span style="line-height:1.8;">{
        </span><span style="line-height:1.8;color:rgb(128,0,128);">248.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">86.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">86.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">,
        </span><span style="line-height:1.8;color:rgb(128,0,128);">249.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">127.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">127.0</span>/<span style="line-height:1.8;color:rgb(128,0,128);">255.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1</span><span style="line-height:1.8;">,
        </span><span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span><span style="line-height:1.8;">
    };
    CGFloat locations[</span><span style="line-height:1.8;color:rgb(128,0,128);">3</span>]={<span style="line-height:1.8;color:rgb(128,0,128);">0</span>,<span style="line-height:1.8;color:rgb(128,0,128);">0.3</span>,<span style="line-height:1.8;color:rgb(128,0,128);">1.0</span><span style="line-height:1.8;">};
    CGGradientRef gradient</span>= CGGradientCreateWithColorComponents(colorSpace, compoents, locations, <span style="line-height:1.8;color:rgb(128,0,128);">3</span><span style="line-height:1.8;">);
 
    CGContextDrawLinearGradient(context, gradient, CGPointMake(</span><span style="line-height:1.8;color:rgb(128,0,128);">20</span>, <span style="line-height:1.8;color:rgb(128,0,128);">50</span>), CGPointMake(<span style="line-height:1.8;color:rgb(128,0,128);">300</span>, <span style="line-height:1.8;color:rgb(128,0,128);">300</span><span style="line-height:1.8;">), kCGGradientDrawsAfterEndLocation);
 
    </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">释放颜色空间</span>
<span style="line-height:1.8;">    CGColorSpaceRelease(colorSpace);
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div class="clear" style="clear:both;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"></div> 
   <div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;line-height:25.2px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/5291033.html</span></font>
     <span style="font-size:14px;line-height:25.2px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
