<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>使用Xamarin.Forms的企业应用程序模式（电子书）--容器化微服务 « NotBeCN</title>
  <meta name="description" content="              开发客户端 - 服务器应用程序的重点是建立在每个层中使用特定技术的分层应用程序。这样的应用通常被称为单片应用，并且被封装在用于峰值负载预分配的硬件上。这种开发方法的主要缺点是每个层级组件之间的紧密耦合，各个组件不能轻易缩放，并且测试成本。一个简单的更新可能对该层的其余部分产生不可预见的...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/10/weixin_33698043_90120925.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">使用Xamarin.Forms的企业应用程序模式（电子书）--容器化微服务</h1>
    <p class="post-meta">Oct 10, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>开发客户端</span> - 服务器应用程序的重点是建立在每个层中使用特定技术的分层应用程序。这样的应用通常被称为单片应用，并且被封装在用于峰值负载预分配的硬件上。这种开发方法的主要缺点是每个层级组件之间的紧密耦合，各个组件不能轻易缩放，并且测试成本。一个简单的更新可能对该层的其余部分产生不可预见的影响，因此更改应用程序组件需要对其整个层进行重新测试并重新部署。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>特别是在云时代，个别组件不能轻松扩展。单片应用程序包含域特定的功能，通常由前端，业务逻辑和数据存储等功能层划分。通过将整个应用程序克隆到多台机器上来整合单片应用程序，如图</span>8-1所示。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_27189e151d02aabeb200cf42de6e6ec8.png" alt="" height="466" width="288"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';"><span>图</span>8-1<span>：单片应用程序缩放方法</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <h1> <a name="_Toc495413698"></a><b><span style="font-family:'宋体';font-weight:bold;font-size:22pt;"><span>微服务</span></span></b><b><span style="font-family:Calibri;font-weight:bold;font-size:22pt;"></span></b> </h1> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>微服务提供了不同的应用程序开发和部署方法，这种方法适合现代云应用的敏捷性，规模和可靠性要求。微服务应用程序被分解成独立的组件，它们一起工作以提供应用程序的整体功能。微服务术语强调，应用程序应由足够小的服务组成，以反映独立的关注点，以便每个微服务器实现单个功能。此外，每个微服务都具有明确的合同，以便其他微服务器可以与其进行通信和共享数据。微服务的典型例子包括购物车，库存处理，采购子系统和支付处理。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>相比之下，微型服务可以独立扩展，而不是大规模集成应用。这意味着需要更多处理能力或网络带宽来支持需求的特定功能区域可以被缩放而不是不必要地缩小应用程序的其他区域。图</span>8-2说明了这种方法，其中微服务部署和独立扩展，创建跨机器服务的实例。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_71cc06077e32052c7adee66a5c353c6e.png" alt="" height="429" width="531"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>图</span>8-2：微服务应用程序缩放方法</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>微服务横向扩展可以几乎瞬时，允许应用程序适应变化的负载。例如，应用程序面向</span>Web的功能中的单个微服务器可能是应用程序中唯一需要扩展以处理其他传入流量的微服务器。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>应用程序可扩展性的经典模型是具有负载均衡的无状态层，其中包含共享外部数据存储以存储持久数据。有状态的微服务管理自己的持久性数据，通常将其存储在其所在的服务器上，以避免网络访问的开销和跨服务操作的复杂性。这样可以最快地处理数据，并可以消除对缓存系统的需求。此外，可扩展的状态微服务通常在其实例之间分配数据，以便管理数据大小和传输吞吐量，超过单个服务器可以支持的数据量。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;">Microservices还支持独立更新。微服务之间的松散耦合提供了快速可靠的应用演进。它们独立的分布式特性支持滚动更新，只有一个微服务器的实例的一个子集在任何给定的时间才能更新。因此，如果检测到问题，则可以在所有实例使用故障代码或配置进行更新之前回滚错误更新。类似地，微服务通常使用模式版本控制，以便客户端在应用更新时看到一致的版本，无论与哪个微服务器实例进行通信。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>因此，微服务应用程序与单片应用程序有很多好处：</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>每个微服务器相对较小，易于管理和演进。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>可以独立于其他服务开发和部署每个微服务器。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>每个微服务都可以独立扩展。例如，目录服务或购物篮服务可能需要比订购服务进行扩展。因此，所产生的基础架构将在扩展时更有效地消耗资源。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>每个微服务器隔离任何问题。例如，如果服务中存在问题，则仅影响该服务。其他服务可以继续处理请求。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>每个微服务器都可以使用最新的技术。由于微服务是自主的，并行运行，所以可以使用最新的技术和框架，而不是被迫使用可能被单片应用程序使用的旧框架。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>然而，基于微服务的解决方案也有潜在的缺点：</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>选择如何将应用程序分割成微服务器可能具有挑战性，因为每个微服务器必须是完全自主的，端到端的，包括对其数据源的责任。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>开发人员必须实施业务间通信，这增加了应用程序的复杂性和延迟。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>多个微服务器之间的原子交易通常是不可能的。因此，业务需求必须包含微服务之间的最终一致性。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>在生产中，部署和管理许多独立服务受损害的系统存在操作复杂性。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>直接的客户端与微服务器的通信可能难以重构微服务的合同。例如，随着时间的推移，系统如何划分为服务可能需要改变。单个服务可能会分为两个或更多服务，两个服务可能会合并。当客户端直接与微服务器通信时，此重构工作可能会破坏与客户端应用的兼容性。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <h1> <a name="_Toc495413699"></a><b><span style="font-family:'宋体';font-weight:bold;font-size:22pt;"><span>容器化</span></span></b><b><span style="font-family:Calibri;font-weight:bold;font-size:22pt;"></span></b> </h1> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>容器化是软件开发的一种方法，其中将应用程序及其版本化依赖关系集以及其环境配置抽象为部署清单文件，作为容器映像打包在一起，作为一个单元进行测试，并部署到主机操作系统。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>容器是一个独立的资源控制和便携式操作环境，应用程序可以在不触及其他容器或主机的资源的情况下运行。</span> <span>因此，容器看起来像新安装的物理计算机或虚拟机。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>容器和虚拟机之间有很多相似之处，如图</span>8-3所示。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_7f3d59d97132eedac289c29ef3837d3c.png" alt="" height="946" width="1200"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';"><span>图</span>8-3<span>：虚拟机和容器的比较</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>容器运行操作系统，具有文件系统，并且可以通过网络访问，就像它是物理机或虚拟机一样。然而，容器使用的技术和概念与虚拟机非常不同。虚拟机包括应用程序，所需的依赖关系以及完整的客户机操作系统。容器包括应用程序及其依赖关系，但与其他容器共享操作系统，作为主机操作系统上的隔离进程运行（除了每个容器的专用虚拟机内运行的</span>Hyper-V容器之外）。因此，容器共享资源，并且通常比虚拟机需要更少的资源。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>面向容器的开发和部署方法的优点在于它消除了环境设置不一致以及与之相关的问题所产生的大多数问题。此外，</span></span><span style="font-family:'宋体';font-size:12pt;"><span>容器</span></span><span style="font-family:'宋体';font-size:12pt;"><span>允许通过根据需要实施新的容器来快速应用放大功能。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>创建和使用容器时的关键概念是：</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>容器主机：配置为托管容器的物理或虚拟机。容器主机将运行一个或多个容器。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>容器镜像：图像由堆叠在一起的分层文件系统的联合组成，并且是容器的基础。镜像没有状态，它不会随着部署到不同的环境而改变。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>容器：容器是图像的运行时实例。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>容器操作系统映像：从映像部署容器。容器操作系统映像是构成容器的潜在许多图像层中的第一层。容器操作系统是不可变的，不能修改。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p style="margin-left:36pt;text-indent:-18pt;text-align:left;"> <span style="font-family:Symbol;font-size:10pt;"><span>·<span>&nbsp;</span></span></span><span style="font-family:'宋体';font-size:10.5pt;"><span>容器存储库：每次创建容器映像时，映像及其依赖项都存储在本地存储库中。这些图像可以在容器主机上重复使用多次。容器映像也可以存储在公共或私有注册表（如</span></span><span><a href="https://hub.docker.com/" rel="nofollow"><u><span style="font-family:'宋体';color:#0000FF;text-decoration:underline;">Docker Hub</span></u></a></span><span style="font-family:'宋体';font-size:10.5pt;"><span>）中，以便它们可以在不同容器主机之间使用。</span></span><span style="font-family:Calibri;font-size:10.5pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>企业在实施基于微服务的应用程序时越来越多地采用</span></span><span style="font-family:'宋体';font-size:12pt;"><span>容器</span></span><span style="font-family:'宋体';font-size:12pt;"><span>，而</span>Docker已经成为大多数软件平台和云供应商采用的标准容器实现。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;">eShopOnContainers参考应用程序使用Docker来托管四个</span><span style="font-family:'宋体';font-size:12pt;"><span>容器</span></span><span style="font-family:'宋体';font-size:12pt;"><span>式后端微服务器，如图</span>8-4所示。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_73c5453f4b95c2a8636fb8f13b1e71a7.png" alt="" height="682" width="678"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>图</span>8-4：eShopOnContainers参考应用后端微服务</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>参考应用程序中后端服务的体系结构以协作微服务和容器的形式分解为多个自主子系统。</span> <span>每个微服务提供单一功能区域：身份服务，目录服务，订购服务和篮子服务。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>每个微服务器都有自己的数据库，允许它与其他微服务器完全分离。</span> <span>必要时，使用应用程序级事件实现来自不同微服务器的数据库之间的一致性。</span> <span>有关更多信息，请参阅</span></span><span><a href="#communication_between_microservices" rel="nofollow"><u><span style="font-family:'宋体';color:#0000FF;text-decoration:underline;"><span>微服务之间的通信</span></span></u></a></span><span style="font-family:'宋体';font-size:12pt;"><span>。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>有关参考应用程序的更多信息，请参阅</span></span><span><a href="https://aka.ms/microservicesebook" rel="nofollow"><u><span style="font-family:'宋体';color:#0000FF;text-decoration:underline;">.NET Microservices<span>：集成化</span><span>.NET</span><span>应用程序的体系结构</span></span></u></a></span><span style="font-family:'宋体';font-size:12pt;"><span>。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <h1> <a name="communication_between_client_and_microse"></a><span style="font-family:'宋体';"><a name="_Toc495413700"></a><span>客户与微服务之间的通信</span></span><b><span style="font-family:Calibri;font-weight:bold;font-size:22pt;"></span></b> </h1> 
   <p> <span style="font-family:'宋体';font-size:12pt;">eShopOnContainers移动应用程序使用直接的客户端到微服务器通信与容器化的后端微服务进行通信，如图8-5所示。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_65643e2bb93d901a8911e0a3827151dd.png" alt="" height="346" width="579"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>图</span>8-5：直接的客户端到微服务器通信</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>通过直接的客户端到微服务器通信，移动应用程序通过其公共端点直接向每个微服务器发出请求，每个微服务器具有不同的</span>TCP端口。 在生产中，端点通常映射到微服务器的负载均衡器，该平衡器在可用实例之间分配请求。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'Segoe UI Symbol';font-size:12pt;"><span>?</span></span><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span><span style="font-family:'宋体';font-size:12pt;"><span>提示：考虑使用</span>API网关通信。 当构建基于大型和复杂的基于微服务的应用程序时，直接的客户端到微服务器通信可能具有缺点，但是对于小型应用程序来说，这是足够的。 当设计具有数十个微服务器的大型基于微服务的应用程序时，请考虑使用API网关通信。 有关更多信息，请参阅</span><span><a href="https://aka.ms/microservicesebook" rel="nofollow"><u><span style="font-family:'宋体';color:#0000FF;text-decoration:underline;">.NET Microservices<span>：集群化</span><span>.NET</span><span>应用程序的体系结构</span></span></u></a></span><span style="font-family:'宋体';font-size:12pt;"><span>。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <h1> <a name="communication_between_microservices"></a><span style="font-family:'宋体';"><a name="_Toc495413701"></a><span>微服务之间的通信</span></span><b><span style="font-family:Calibri;font-weight:bold;font-size:22pt;"></span></b> </h1> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>基于微服务的应用程序是分布式系统，可能运行在多台机器上。每个服务实例通常是一个进程。因此，服务必须使用诸如</span>HTTP，TCP，高级消息队列协议（AMQP）或二进制协议之类的进程间通信协议进行交互，这取决于每个服务的性质。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>微服务到微服务通信的两种常见方法是在查询数据时进行基于</span>HTTP的REST通信，以及在跨多个微服务器通信更新时的轻量级异步消息传递。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>当跨多个微服务传播更改时，基于异步消息传递的事件驱动通信至关重要。通过这种方法，当一个值得注意的事件发生时，一个微服务器发布一个事件，例如当它更新一个业务实体时。其他微服务订阅这些事件。然后，当微服务器收到一个事件时，它会更新自己的业务实体，这可能会导致更多的事件被发布。这种发布订阅功能通常通过事件总线实现。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>事件总线允许微服务之间的发布</span> - 订阅通信，而不需要组件彼此明确地识别，如图8-6所示。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_9e2bc1a00e1bbddc524011b3b38d65c4.png" alt="" height="284" width="703"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>图</span>8-6：发布订阅事件总线</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>从应用的角度来看，事件总线只是一个通过接口公开的发布订阅通道。</span> <span>然而，事件总线的实现方式可能会有所不同。</span> <span>例如，事件总线实现可以使用</span>RabbitMQ，Azure服务总线或其他服务总线，如NServiceBus和MassTransit。 图8-7显示了eShopOnContainers参考应用程序中事件总线的使用方法。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_6f01456018397d22cd904cd7372c6dc1.png" alt="" height="909" width="1200"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>图</span>8-7：参考应用中的异步事件驱动通信</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>使用</span>RabbitMQ实现的eShopOnContainers事件总线提供一对多异步发布订阅功能。 这意味着在发布事件之后，可以有多个订阅者监听相同的事件。 图8-9说明了这种关系。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <img src="https://yqfile.alicdn.com/img_7f54b4f8544aaa392e7e4e05fd364117.png" alt="" height="526" width="1200"><span style="font-family:'宋体';font-size:12pt;">&nbsp;</span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>图</span>8-9：一对多通信</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>这种一对多通信方法使用事件来实现跨越多个服务的业务事务，确保服务之间的最终一致性。</span> <span>最终一致的事务由一系列分布式步骤组成。</span> <span>因此，当用户简档微服务器接收到</span>UpdateUser命令时，它会更新用户在其数据库中的详细信息，并将UserUpdated事件发布到事件总线。 篮子微服务器和订购微服务器已订阅接收该事件，并且响应于在其各自的数据库中更新其买方信息。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>注意：使用</span>RabbitMQ实现的eShopOnContainers事件总线仅用作概念证明。 对于生产系统，应考虑替代事件总线实现。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>有关事件总线实现的信息，请参阅</span></span><span><a href="https://aka.ms/microservicesebook" rel="nofollow"><u><span style="font-family:'宋体';color:#0000FF;text-decoration:underline;">.NET Microservices<span>：集群化</span><span>.NET</span><span>应用程序的体系结构</span></span></u></a></span><span style="font-family:'宋体';font-size:12pt;"><span>。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <h1> <a name="_Toc495413702"></a><b><span style="font-family:'宋体';font-weight:bold;font-size:22pt;"><span>概要</span></span></b><b><span style="font-family:Calibri;font-weight:bold;font-size:22pt;"></span></b> </h1> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>微服务提供了适用于现代云应用的敏捷性，规模和可靠性要求的应用程序开发和部署方法。</span> <span>微服务的主要优点之一是可以独立扩展，这意味着可以对特定的功能区进行扩展，这需要更多的处理能力或网络带宽来支持需求，而不会不必要地缩放没有经历的应用程序区域</span> <span>需求增加。</span></span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
   <p> <span style="font-family:'宋体';font-size:12pt;"><span>容器是一个独立的资源控制和便携式操作环境，应用程序可以在不触及其他容器或主机的资源的情况下运行。</span> <span>企业在实施基于微服务的应用程序时越来越多地采用</span></span><span style="font-family:'宋体';font-size:12pt;"><span>容器</span></span><span style="font-family:'宋体';font-size:12pt;"><span>，而</span>Docker已经成为大多数软件平台和云供应商采用的标准容器实现。</span><span style="font-family:'宋体';font-size:12pt;"></span> </p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
