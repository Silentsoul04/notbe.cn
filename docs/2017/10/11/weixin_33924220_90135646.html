<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>各种排序算法的总结 « NotBeCN</title>
  <meta name="description" content="             都是基于内存的排序算法，包括插入排序、希尔排序、冒泡排序、快速排序、简单选择排序、堆排序、归并排序    14年在网易Blog上写的，现把它放到这里。    &nbsp;    &nbsp; 一，直接插入排序 &nbsp; &nbsp; &nbsp; &nbsp; 总体思路：位于表中后面...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/11/weixin_33924220_90135646.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">各种排序算法的总结</h1>
    <p class="post-meta">Oct 11, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>都是基于内存的排序算法，包括插入排序、希尔排序、冒泡排序、快速排序、简单选择排序、堆排序、归并排序</p> 
   <p>14年在网易Blog上写的，现把它放到这里。</p> 
   <p>&nbsp;</p> 
   <p><strong><strong>&nbsp; 一，直接插入排序</strong><br> &nbsp; &nbsp; &nbsp; &nbsp; </strong>总体思路：位于表中后面的元素依次与表中前面的元素比较，若比之小，则还需继续和更前面的元素比较，直至遇到一个比它大的元素或者比较到第一个元素(哨兵)了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①先将第一个元素视为有序，第二个元素与第一个元素比较，若比第一个元素小，则插入到第一个元素之前。第三个元素依次与第二个元素、第一个元素比较（前三 个元素有序）；第四个元素依次与第三个、第二个、第一个元素比较，插入到合适位置以形成一个有序表（即此时前四个元素有序）因此，直接插入排序算法是逐步 地形成一个有序序列的。也即在表的前头形成一个局部有序序列。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②不论初始序列如何，总需要 N－1 趟排序，第一趟是第二个元素与第一个元素比，第二趟是第三个元素与前二个元素比，第三趟是第四个元素与前三个元素比……<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③当初始序列有序时，第一趟只需比较一次，第二趟只需比较一次，第三趟也只需比较一次……总共只需比较 N－1 次即可完成排序。当初始序列逆序时，第一趟比较一次，第二趟比较二次，……第 N－1 趟比较 N－1 次。总共比较 n(n-1)/2 次。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ④直接插入排列是基于明确的相邻位置的两个元素的比较，因此该算法是稳定的。排序过程的比较次数与待排序列的初始状态有关。每进行一趟排列并不能唯一地确定下一个元素的最终位置。<br><strong><strong><br> 二，希尔排序</strong><br><br> &nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp; ①希尔排序算法也属于插入排序，它是基于以下因素提出来的：当待排序列不是很大时，用直接插入排序并不怎么复杂。同时，当初始序列基本有序时，直接插入只需经过少量的比较即可完成排序。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②希尔排序将待排序列按照某个增量分成若干个子序列，分别对每个子序列用直接插入排序算法时行排序。增量的选取对希尔排序算法的时间复杂度影响很大。进行 完一趟排序之后，增量就缩小一下。因此，希尔排序也称缩小增量排序。最后一趟排序时，增量缩小为 1 ，即最后一趟排序相当于直接插入排序。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③希尔排序是不稳定的，因为元素之间的比较是各个子序列中的元素比较。相对于整个待排序列而言，某一个元素可能会跳跃性地移动。<br><br><strong>三，冒泡排序</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 冒泡排序的思想是：相邻两个元素的比较，将小的调到前头。因此，进行完第一趟排序，就会唯一确定出最大元素，进行完第二趟排序，就会唯一确定出次最大元素……<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①由于它是基于相邻两个元素之间的比较，因此算法是稳定的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②当元素初始序列有序时，在一趟冒泡过程中只需进行 N－1 次比较，没有进行交换操作即可完成排序。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③当初始序列逆序时，第一趟比较 N－1 次选出最大元素，第二趟比较 N－2 次选出 次最大元素……冒泡法的平均时间复杂度为 O（n^2）。<br><strong><br><strong>四，快速排序算法</strong><br> &nbsp;&nbsp; </strong><br> &nbsp;&nbsp;&nbsp;&nbsp; 基本思路：快排中设置了三个指针，low、high、pivot。low 指向第一个元素，high 指向最后一个元素，pivot 指向枢轴元素。首先，从high 指针所指的元素开始，若它比枢轴元素要小，则与枢轴元素交换，否则 high－－ 继续与枢轴元素比较；若 high 所指元素与枢轴元素交换后，则接着将 low 所指元素与枢轴元素比较，若它比枢轴元素小则 low＋＋，否则将 low 所指元素与枢轴元素交换。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①快排的一个关键因素是选好枢轴，它进行一趟排序后，枢轴元素在表中的位置被唯一确定下来，且枢轴元素将待排序列分成两个子序列，左边的序列中的元素都比 枢轴元素小，右边的序列都比枢轴元素大。然后，分别在左右序列中选择枢轴元素再开始排序，因而，快排中包含了递归。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②当待排的元素初始有序时，快排的性能大大地下降。因为此时枢轴划分的子序列严重地不对称（一般选择第一个元素作为枢轴记录），快排退化为冒泡排序。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③快排是不稳定的，因为在排序过程中，设置了两个指针 low 和 high 。首先从high 开始自减，寻找第一个比枢轴小的元素，并将之与枢轴记录进行交换，这种跳跃式的交换可能会造成元素的相对位置的改变。<br> &nbsp;&nbsp;&nbsp;&nbsp; ④对于快排而言，元素的初始序列与排序的趟数和比较次数是有关的。但是，平均情况下，对于内部排序而言，快排的性能是最好。平均时间复杂度为 O（n^2)，空间复杂度为O（logn）。<br><strong><strong><br> 五，简单选择排序</strong><br></strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基本思路：第一趟从待排序列中选取最小的元素与放在第一个位置的元素交换，第二趟选择次最小的元素与第二个位置的元素交换……这样，每趟中元素的比较次数与待排序列的初始状态无关。同时，每进行一趟排序只进行一次交换。<br> &nbsp;&nbsp;&nbsp; ①比较次数及排序趟数与序列的初始状态无关。<br> &nbsp;&nbsp;&nbsp; ②简单选择排序是不稳定的，因为它进行交换时会造成元素的位置跳跃式地变化。<strong><br><br><strong>六，堆排序</strong><br> &nbsp; <br> &nbsp;&nbsp;&nbsp; &nbsp;</strong> ①在简单选择排序中，并没有充分利用前面比较过程中得出的一些相关信息。而在堆排序中，则将前面的比较信息也利用起来。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②讨论堆排序，应分成两步：第一步，将待排元素进行建堆过程。第二步，堆排序过程。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③建堆过程的思想（小顶堆）<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将待排序列视为一棵完全二叉树，画出该完全二叉树之后，寻找完全二叉树中的最后一个非叶子结点（第 n/2个结点），从该结点开始调整。将该结点的孩子中较小的结点与该结点交换，然后再继续调整倒数第二个非叶子结点，……注意在这个调整过程中，比如你调 整到了第 i 个非叶子结点了，将第 i 个非叶子结点的值与它的左右孩子结点值比较，将其中较小的值与第 i 个非叶子结点交换。交换了之后，可能造成以第 i 个非叶子结点为根的子树失去了堆的特征。此时，应对该子树继续进行堆调整，直至其成为一个堆为止。然后才能再去调整第 i－1 个非叶子结点。<strong><br><br> &nbsp;</strong>&nbsp;&nbsp; ④对于一个小顶堆而言，堆顶元素一定是序列中元素值最小的元素。因此，直接输出它，便得到了有序序列中的第一个元素值。此时，将堆中的最后一个元素与堆顶 元素置换，并删除堆中最后一个元素。此时，破坏了堆的定义，因为需要从堆顶元素起开始向下调整，使之重新变成一个堆。<br><br> &nbsp;&nbsp;&nbsp; ⑤对于堆而言，插入一个元素时，先将之插入在堆对应的完全二叉树中的最后一个位置处，然后进行由下而上的堆调整操作。删除时，总是删除堆顶元素，并用堆中最后一个元素置换堆顶元素，并进行由上而下的调整。<br> &nbsp;&nbsp;&nbsp; ⑥堆排序的时间复杂度为 O（logn）。空间复杂度为 O（1）。堆排序是不稳定。进行一趟堆排序可以唯一地确定下来一个元素的位置（原因有点不懂）。<strong><br><br><strong>七，归并排序</strong><br><br> &nbsp;&nbsp;</strong>&nbsp;&nbsp;&nbsp; 排序过程如下（二路归并）：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①第一趟，将待排序列中的第一个元素与第二个元素归结为一组，将第三个元素与第四个元素归结为一组……将第 n－1 个元素与第 n 个元素归结为一组，然后将每一组里面的元素有序排列。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②第二趟，将待排序列中的第一、二、三、四个元素归结为一组，第五、六、七、八个元素归结为一组……同样，将每一组里面的元素有序排序。<br> ……&nbsp; ……&nbsp; 直至所有的元素有序排列。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ③归并排序的时间复杂度为 O（logn），空间复杂度为 O（n）。但是它是稳定的排序算法，因为两两的归并，它们之间是基于相邻元素之间的比较。</p> 
   <p><br></p> 
   <p>本文转自hapjin博客园博客，原文链接：http://www.cnblogs.com/hapjin/p/5517682.html，如需转载请自行联系原作者<br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
