<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>log翻硬币 « NotBeCN</title>
  <meta name="description" content="             若果有一组硬币,（假定有十个）,每一个硬币仅仅有两个面，正面用以表示。反面用零表示.    给定目标（初始状态）1111100000 正正正正正反反反反反    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbs...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/11/weixin_33991418_90133267.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">log翻硬币</h1>
    <p class="post-meta">Oct 11, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">若果有一组硬币,（假定有十个）,每一个硬币仅仅有两个面，正面用以表示。反面用零表示.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">给定目标（初始状态）1111100000 正正正正正反反反反反</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (目标状态)&nbsp;&nbsp; 1000011101 正反反反反正正正反正<br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">规定每次仅仅能够翻转相邻的两个硬币（他们各自成为原来的对立面）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">问题，至少用多少次就能够达到目的.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">将每一种状态标记为，每一次的硬币翻动（1-9）状态i。都会使。当前状态变为还有一种状态状态i+1，假设在状态</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">i+1的位置，翻动和对应的位置，则会，回到状态i，因此推断是（状态与状态之间的转换）能够互相进行.以此推断图的搜索.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">此处採索，</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">方法一</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">分析.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">每一个硬币翻转后都会（且必须）影响一硬币，硬币个数大于一</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">考虑每次翻转都会有两个硬币翻转到相反状态，假设目标与初始有基数个不同样。就不能达到目标状态.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">我们尽可能的是硬币当前硬币接近给定状态</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">因此从左向右，假设i号硬币与目标同样，跳过。否则翻转i,i+1号硬币.(i&lt;n)，翻转次数加一.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">当到i==n是假设i号与目标同样则得到翻转次数.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">否则不能通过有该翻转规则得到,由于有一个不同(1。是基数而该规则是，每次改变两个硬币).</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">问题是怎样证明最有性.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">一个硬币假设被翻转偶数次相当与没有翻转</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">若被翻转多次，如果硬币i被翻转n次,相当于n%2次</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">那麽i-1,被翻转x次(相当于x%2),i+1被翻转了n-x次((n-x)%2)</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">x为偶数。n-x为奇数 n为奇数 翻转i和i+1<br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">x为偶数 n-x为偶数 n也为偶数 相当于没有不论什么硬币被翻转</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">x为奇数 n-x为偶数 n为基数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 相当于值翻转i-1,i</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">x为基数n-x为基数翻转了i-1,i+1.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">通过上述四种情况我们发现能够对一个硬币有两种操作</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">1.翻转左右各一次（多次效果同样次数增多不是问题的解）使得相距一个的硬币翻转</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">2.翻转左边一次或者右边一次，效果都是使得相邻的硬币发生翻转</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">以以下情况举例说明2覆盖1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">a.假如 要是0 0 0 翻转到 1 0 1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">第一种翻转方法翻转两边使得达到结果次数为2</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">另外一种方法翻转1,2,使得达到效果结果次数为2</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">b.要是0 0 0 变为 1 1 0</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">第一种方式不能达到，而另外一种方式仅仅要翻转1。影响2(翻转2,影响1)就可以结果为1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">由情况a,b能够看出要改变一个硬币仅仅需改变他和他相邻的硬币就可以.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">相邻的有两边。那麽要改变硬币i，究竟要硬向那边,能够从第一个開始来推断是否i号须要被改变，那麽左边的都是完毕改变的，因此仅仅需顾虑右边就好了.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">那可能会有疑问了，会不会从右边開始结果更少呢？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">从两边開始结果一样的</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">非常明确的知道。全部翻转的点是与目标不同的点.如今有m个（m是偶数）由于已经证明结论基数个不同样硬币是不可能相邻翻转来改变是指同样。此时设有0&lt;=i&lt;j&lt;=n;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">a[i],a[j]都与目标不同样,此时从左向右还是从右翻转都是j-i次,那麽原硬币中有m个与终于结果不同样,此时可将这m开做k(o..m/2)的ik..jk.不同样的亮亮对，他们翻转操作次数</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">都是k(1...m/2) 求和ij-ik,因此偶数（可通过翻转到达的情况是从左到右从右到左是同样的).</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">比如记i号硬币起始情况与终于情况同样为1,否则为零那麽对以下的情况用上面的结论来计算结果.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">1 0 1 0 0 0 1 0&nbsp;1 0&nbsp;&nbsp;<br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">从左向右（4-2）+ （6-5）+ （10 -8)= 5次</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">从右向左 (10-8) + (6-5) + (4-2) =5次</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">上面规律应征名，全部这杨m为偶数结果，从左向右，从右向左都同样。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">以下解法即从左向右.<br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);"></span></p> 
   <pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main(){
        int count=0,i;
        int a[10];
        int b[10];
        for(i=0;i&lt;10;i++){
                scanf("%d",&amp;a[i]);
        }
        for(i=0;i&lt;10;i++){
                scanf("%d",&amp;b[i]);
        }
        for(i=0;i&lt;9;i++){
                if(a[i]!=b[i]){
                        a[i]=!a[i];
                        a[i+1]=!a[i+1];
                        count++;
                }
        }
        printf("%d\n",a[i]==b[i]?
</code></pre> 
   <p></p> 
   <p>count:-1); return 0; }</p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">方法二</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">採取bfs,搜素状态树就可以.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">要点两个:</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">1.状态的保存（判反复节点）.若果节点反复则不应打开（去遍历他所相应的节点间）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);">2.状态的表示，该题目的状态的表示，使用简单的哈希相应关系.</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:rgb(9,61,37);"></span></p> 
   <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
const int size = 1000000+100;  
typedef int state[10];
state st[size];
int vis[size]={0};   
int dis[size]={0};   
int getkey(state &amp;s)
{
 int i,adder=0;
 for(i=0;i&lt;10;i++){
   adder=adder*2+s[i];
  }
 return adder;
}
int isvis(state &amp;s){
 int key=getkey(s);
 if(vis[key])
 return 1;
 else {
   vis[key]=1;
   return 0;
  }
}
int bfs(int front,int rear,state goal)
{
 int i,j,k;
 while(front!=rear){
   state &amp;s=st[front];
   if(memcmp(goal,s,sizeof(s))==0)
   return dis[front];
   else{
      for(i=0;i&lt;9;i++){
          state &amp;t=st[rear];
          
          memcpy(&amp;t,&amp;s,sizeof(s));
          t[i]=!t[i];
          t[i+1]=!t[i+1];
          dis[rear]=dis[front]+1;
          if(!isvis(t))
          rear++; 
         }
     }
   front++;
  }
 return -1;
}
int main()
{
 int front=1,rear=2,i,j,k;
 state goal;
 int distance=-1;
 for(i=0;i&lt;10;i++){
   cin&gt;&gt;st[front][i];
  }
 for(i=0;i&lt;10;i++){
   cin&gt;&gt;goal[i];
  }
 distance=bfs(front,rear,goal);
 cout&lt;&lt;distance&lt;&lt;endl;
 return 0;
}</code></pre> 
   <p><span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">给出10个硬币初始状态，和终于状态得到最短反转步数.</span></p> 
   <p><span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></span></p> 
   <p><span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></span></p> 
   <p><span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></span></p> 
   <p><span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></span></p> 
   <p><span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></span></p> 
   <p><font color="#333333"><span style="font-size:14px;"><br></span></font></p> 
   <p></p> 
   <p><font color="#333333"><span><span style="font-size:14px;">本文转自mfrbuaa博客园博客，原文链接：http://www.cnblogs.com/mfrbuaa/p/5159959.html，如需转载请自行联系原作者</span></span></font></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
