<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>云计算和虚拟机基础梳理 « NotBeCN</title>
  <meta name="description" content="                  &nbsp;     云计算介绍 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算资源共享池，（资源包括网络、服务器、存储、应用软件、服务），这些资源能够被快速提供，需要投入很少的管理工作，或与服务供应商进行很少的交互。     1）...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/11/weixin_33918114_90126691.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">云计算和虚拟机基础梳理</h1>
    <p class="post-meta">Oct 11, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;"> 
    <p style="line-height:1.5;">&nbsp;</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;font-size:18px;">云计算介绍</span><br> 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算资源共享池，（资源包括网络、服务器、存储、应用软件、服务），这些资源能够被快速提供，需要投入很少的管理工作，或与服务供应商进行很少的交互。</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,0,255);">1）云计算之前的使用模式</span><br> IDC 托管<br> IDC 租用<br> 虚拟主机（买空间）<br> VPS：虚拟专用主机<br><span style="line-height:1.5;color:rgb(0,0,255);">2）传统数据中心面临的问题</span><br> 资源使用率低<br> 资源分配不均<br> 自动化能力差<br><span style="line-height:1.5;color:rgb(0,0,255);">3）云计算的优势</span><br> 云计算是一种使用模式，不是一种技术<br> 云计算的使用方式：通过网络访问<br> 云计算的优势：弹性计算、按需计费<br><span style="line-height:1.5;color:rgb(0,0,255);">4）云计算的特点</span><br> 资源池化<br> 无处不在的网络访问<br> 可随时调节的自助服务<br> 可测量的服务量<br> 快速的变化伸缩<br><span style="line-height:1.5;color:rgb(0,0,255);">5）云计算的服务模式</span></p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,0,255);"><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161226170756617-1116402093.png" alt="" style="border:0px;"></span></p> 
    <p style="line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161226173021179-754435480.png" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(255,102,0);">1--支撑服务</span><br> 由支撑网络来提供，云计算模式实现的使用的方式。<br><span style="line-height:1.5;color:rgb(255,102,0);">2--IaaS基础设施即服务</span><br> 消费者通过支撑网络可以从完善的计算机基础设施获得服务。这类服务称为基础设施即服务，基于 Internet 的服务（如存储和数据库）是 IaaS的一部分。<br><span style="line-height:1.5;color:rgb(255,102,0);">3--PaaS平台即服务</span><br> PaaS（Platform-as-a-Service：平台即服务）是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。<br><span style="line-height:1.5;color:rgb(255,102,0);">4--SaaS</span><br> 它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。用户不用再购买软件，而改用向提供商租用基于Web的软件，来管理企业经营活动，且无需对软件进行维护，服务提供商会全权管理和维护软件，软件厂商在向客户提供互联网应用的同时，也提供软件的离线操作和本地数据存储，让用户随时随地都可以使用其定购的软件和服务。对于许多小型企业来说，SaaS是采用先进技术的最好途径，它消除了企业购买、构建和维护基础设施和应用程序的需要。<br><span style="line-height:1.5;color:rgb(0,0,255);">6）云计算的类型</span><br><span style="line-height:1.5;color:rgb(255,102,0);">1--公有云</span><br> 公有云通常指第三方提供商为用户提供的能够使用的云，公有云一般可通过 Internet 使用，可能是免费或成本低廉的，公有云的核心属性是共享资源服务。这种云有许多实例，可在当今整个开放的公有网络中提供服务。例如：阿里云、腾讯云、青云、百度云、盛大云、迅达云、等等。<br><span style="line-height:1.5;color:rgb(255,102,0);">2--私有云</span><br> 私有云(Private Clouds)是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式。私有云可部署在企业数据中心的防火墙内，也可以将它们部署在一个安全的主机托管场所，私有云的核心属性是专有资源。<br><span style="line-height:1.5;color:rgb(255,102,0);">3--混合云</span><br> 混合云融合了公有云和私有云，是近年来云计算的主要模式和发展方向。我们已经知道私企业主要是面向企业用户，出于安全考虑，企业更愿意将数据存放在私有云中，但是同时又希望可以获得公有云的计算资源，在这种情况下混合云被越来越多的采用，它将公有云和私有云进行混合和匹配，以获得最佳的效果，这种个性化的解决方案，达到了既省钱又安全的目的。</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;font-size:18px;">虚拟化介绍</span><br> 拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。<br> 虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的动态分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。<br><span style="line-height:1.5;color:rgb(0,0,255);">1）虚拟化的分类</span><br><span style="line-height:1.5;color:rgb(128,0,0);">全虚拟化:直接使用底层的硬件 比如：KVM</span><br><span style="line-height:1.5;color:rgb(128,0,0);">半虚拟化:通过一个中间件，来调用底层的硬件 比如：xen</span><br> 平台虚拟化<br> 硬件虚拟化（Inter vt-x/EPT） (AMD AMD-v /RVI)<br> 软件虚拟化<br> 桌面虚拟化<br> 应用虚拟化<br> 存储虚拟化<br> 网络虚拟化<br><span style="line-height:1.5;color:rgb(0,0,255);">2）虚拟化的优势</span><br> 虚拟化可以虚拟出不同的虚拟操作系统。<br> 虚拟机之间是相互独立互不影响的。<br> 支持异构。<br> 支持快照、克隆、还原等操作<br> 云计算与虚拟化的区别与联系</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;font-size:18px;">云计算与虚拟化的区别与联系</span><br> 1）虚拟化是一种技术，云计算是一种使用模式。<br> 2）虚拟化是指将物理的实体，通过软件模式，形成若干虚拟存在的系统，其实真是运作还是在实体上，只是划分了若干区域或者时域划分。<br> 3）云计算的基础是虚拟化，但虚拟化只是云计算的一部分，云计算其实就是在虚拟化出若干资源池以后的应用，但虚拟化并不是只对应云计算的。</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;font-size:18px;">KVM虚拟化</span><br> KVM是开源软件，全称是kernel-based virtual machine（基于内核的虚拟机）。<br> KVM是x86架构且硬件支持虚拟化技术（如 intel VT 或 AMD-V）的Linux全虚拟化解决方案。<br> 它包含一个为处理器提供底层虚拟化 可加载的核心模块kvm.ko（kvm-intel.ko或kvm-AMD.ko）。<br> KVM还需要一个经过修改的QEMU软件（qemu-kvm），作为虚拟机上层控制和界面。<br> KVM能在不改变linux或windows镜像的情况下同时运行多个虚拟机，（它的意思是多个虚拟机使用同一镜像）并为每一个虚拟机配置个性化硬件环境（网卡、磁盘、图形适配器……）。<br><span style="line-height:1.5;color:rgb(0,0,255);">1）KVM的优势</span><br> 嵌入到Linux的Kernel中 （提高兼容性）<br> 代码级资源调用（提高性能）<br> 虚拟机就是一个进程<br> 直接支持MUMA技术（NUMA（Non Uniform Memory Access Architecture）技术可以使众多服务器像单一系统那样运转，同时保留小系统便于编程和管理的优点。<br><span style="line-height:1.5;color:rgb(0,0,255);">2）KVM安装前提</span><br> CPU要支持虚拟化，服务器上默认一般是开启的，虚拟机要自己启动VT-EPT技术<br> [root@oldboy-node1 ~]# grep -E "(vmx|svm)" /proc/cpuinfo<br> Inter处理器对应：VMX<br> AMD处理器对应：SVM<br><span style="line-height:1.5;color:rgb(0,0,255);">3）KVM虚拟机安装</span><br><span style="line-height:1.5;color:rgb(0,128,0);">查看系统版本</span><br> [root@linux-node1~]# cat /etc/redhat-release&nbsp;<br> CentOSLinux release 7.1.1503 (Core)</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,128,0);">安装KVM相关的组件</span><br> [root@oldboy-node1 ~]# yum -y install qemu-kvm qemu-kvm-tools virt-manager libvirt virt-install<br> kvm：linux内核中的一个模块，不需要安装只要加载就行，通过用户态进程来管理。<br> qemu：虚拟化软件，支持多种架构，可扩展，可移植<br> qemu-kvm：用户态管理KVM，网卡、声卡、PCI设备等的管理<br> libvirt：是一个虚拟化 API 和虚拟机(VMs)管理后台，支持远程或本地访问，支持多种虚拟化后端 (QEMU/KVM， VirtualBox， Xen，等等) 。</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,128,0);">检查KVM是否加载</span><br> [root@oldboy-node1 ~]# lsmod | grep kvm<br> kvm_intel 148081 0<br> kvm 461126 1 kvm_intel</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,128,0);">启动并设置开机启动libvirt</span><br> [root@linux-node1~]# systemctl enable libvirtd.service&nbsp;<br> [root@linux-node1~]# systemctl start libvirtd.service<br> [root@oldboy-node1 ~]# systemctl status libvirtd.service</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,128,0);">创建虚拟机</span><br><span style="line-height:1.5;color:rgb(255,102,0);">1--虚拟机的创建命令</span><br> –virt-type:指定虚拟机类型(kvm、qemu、xen)<br> –name:指定虚拟机的名称<br> –raw:指定内存大小<br> –cpu:指定cpu的核数(默认为1)<br> –cdrom:指定镜像<br> –disk:指定磁盘路径(即上文创建的虚拟磁盘)<br> –network:指定网络类</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(255,102,0);">2--创建硬盘（创建虚拟磁盘,-f指定格式,路径/opt/CentOS-7.1-x86_64.raw，大小10G）</span><br> [root@oldboy-node1 ~]# qemu-img create -f raw /opt/CentOS-7.1-x86_64.raw 10G<br> Formatting '/opt/CentOS-7.1-x86_64.raw', fmt=raw size=10737418240<br><span style="line-height:1.5;color:rgb(255,102,0);">3--镜像的拷贝</span><br> [root@oldboy-node1 ~]# dd if=/dev/cdrom of=/opt/CentOS-7.1.iso<br><span style="line-height:1.5;color:rgb(255,102,0);">4--虚拟机的创建</span><br> [root@oldboy-node1 ~]# virt-install --name CentOS-7.1-x86_64 --virt-type kvm --ram 1024 --cdrom=/opt/CentOS-7.1.iso --disk path=/opt/CentOS-7.1-x86_64.raw --network network=default --graphics vnc,listen=0.0.0.0 --noautoconsole<br><span style="line-height:1.5;color:rgb(255,102,0);">5--使用VNC连接虚拟机</span><br> 使用VNC客户端连接虚拟机 物理机的地址:5900 默认是从5900开始，以此类推。也可以通过端口grep vnc查看。<br><span style="line-height:1.5;color:rgb(255,102,0);">6--修改网卡的名称</span><br> 因为CentOS7以后，网卡的命名发生改变。可以在安装的时候就做出修改</p> 
    <p style="line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161226171744289-480698257.png" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">按下Tab键，然后在quiet后面添加 net.ifnames=0 biosdevname=0<br> 至此，一台KVM虚拟机安装成功。</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,128,0);">KVM的日常应用管理</span><br><span style="line-height:1.5;color:rgb(255,102,0);">1--虚拟机的查看</span><br> # 当前正在运行中的虚拟机<br> [root@linux-node1 opt]# virsh list&nbsp;<br> Id Name State<br> —————————————————-<br> 1 CentOS-7-x86_64running<br> # 当前物理机中的所有的虚拟机<br> [root@linux-node1 opt]# virsh list --all<br> 也可以在物理机进程中查看，KVM虚拟机就是一个KVM进程在运行<br><span style="line-height:1.5;color:rgb(255,102,0);">2--虚拟机的开关</span><br> 关闭虚拟机<br> [root@oldboy-node1 ~]# virsh shudown CentOS-7.1-x86_64(主机名)<br> [root@oldboy-node1 ~]# virsh destroy CentOS-7.1-x86_64(主机名)<br> 打开虚拟机<br> [root@oldboy-node1 ~]# virsh start CentOS-7.1-x86_64<br> 删除虚拟机<br> [root@oldboy-node1 ~]# virsh undefine CentOS-7.1-x86_64<br> 挂起<br> [root@oldboy-node1 ~]# virsh suspended CentOS-7.1-x86_64<br> 恢复<br> [root@oldboy-node1 ~]# virsh resume CentOS-7.1-x86_64<br> 3--虚拟机CPU的扩容<br> 编辑虚拟机<br> virsh edit CentOS-7.1-x86_64<br> # 为了实现CPU的热添加，就需要更改Cpu的最大值,当然热添加值不能超过最大值<br> # 当前为1，自动扩容最大为4<br> [root@linux-node1 opt]# virsh edit CentOS-7-x86_64&nbsp;<br> &lt;vcpu placement=’auto’ current=”1″&gt;4&lt;/vcpu&gt;&nbsp;<br> # 热修改为2个cpu(不知减少),高版本自动激活<br> [root@linux-node1 opt]# virsh setvcpus CentOS-7-x86_64 2 –live&nbsp;<br> # 通过vnc登录KVM虚拟机查看是否扩容成功<br> [root@KVM]# grep processor /proc/cpuinfo |wc -l&nbsp;<br> # 在创建虚拟机时指定cpu<br> [root@linux-node1 ~]# virt-install –help|grep vcpus<br> –vcpus VCPUS&nbsp;<br> """<br> 为虚拟机配置的 vcpus 数。<br> 例如：<br> –vcpus 5<br> –vcpus 5,maxcpus=10,cpuset=1-4,6,8<br> –vcpus sockets=2,cores=4,threads=2,<br> """<br><span style="line-height:1.5;color:rgb(255,102,0);">4--内存热膨胀和压缩</span><br> # 查看当前KVM内存大小<br> [root@linux-node1 ~]# virsh qemu-monitor-command CentOS-7-x86_64 –hmp –cmd info balloon&nbsp;<br> balloon: actual=1024<br> # 热添加600M<br> [root@linux-node1 ~]# virsh qemu-monitor-command CentOS-7.1-x86_64 –hmp –cmd balloon 600<br> # 在配置文件中修改<br> [root@linux-node1 network-scripts]# virsh edit CentOS-7.1-1-x86_64<br> 最大内存&lt;memory unit='KiB'&gt;4048576&lt;/memory&gt;<br> 当前内存&lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;<br><span style="line-height:1.5;color:rgb(255,102,0);">5--硬盘的模式</span><br> 生产中不建议对线上的服务器的硬盘进行更改，因此直接不对此赘述。<br> 硬盘格式：<br><span style="line-height:1.5;color:rgb(128,0,128);">RAW：全镜像格式：设置多大就是多大，写入速度快，可以随便转换成其他的格式。性能最优。但是占用空间大。</span><br><span style="line-height:1.5;color:rgb(128,0,128);">QCOW2：稀疏格式：支持写时拷贝（Cow,copy-on-write）压缩，快照，镜像，更小的存储空间。（用多少给多少）可选择基于Zlib的压缩方式，可以选择AES加密</span><br> 创建qcow2和raw文件<br> [root@linux-node1 ~]# qemu-img create -f qcow2 test.qcow2 10G<br> Formatting 'test.qcow2', fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off<br> [root@linux-node1 ~]# qemu-img create -f raw test.raw 10G<br> Formatting 'test.raw', fmt=raw size=10737418240<br> 空间使用情况对比<br> [root@linux-node1 ~]# ll -sh test.*<br> 200K -rw-r--r-- 1 qiaoliyong qiaoliyong 193K 5 月 6 10:29 test.qcow2<br> 0 -rw-r--r-- 1 qiaoliyong qiaoliyong 10G 5 月 6 10:28 test.raw<br> [root@linux-node1 ~]# stat test.raw<br> 文件："test.raw"<br> 大小：10737418240 块：0 IO 块：4096 普通文件<br> [root@linux-node1 ~]# stat test.qcow2<br> 文件："test.qcow2"<br> 大小：197120 块：400 IO 块：4096 普通文件</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(255,102,0);">6--网卡的配置</span><br> # 先建立一个虚拟网卡，名称为br0（可以看做是一个逻辑网段，也可以看做是一个VLAN名称）<br> [root@linux-node1~]# brctl addbr br0&nbsp;<br> # 查看网卡信息<br> [root@linux-node1 ~]# brctl show&nbsp;<br> bridge<br> name bridge id STP enabled interfaces<br> br0 8000.000000000000 no<br> virbr0 8000.5254009f0311 yes virbr0-nic<br> # 把eth0加入网桥,使用桥接模式,给br0设置ip段，添加路由网关,关闭防火墙<br> [root@linux-node1 ~]# brctl addif br0 eth0 &amp;&amp; ip addr del dev eth0 192.168.56.111/24 &amp;&amp; ifconfig br0 192.168.56.111/24 up &amp;&amp; route add default gw192.168.56.2 &amp;&amp; iptables -F&nbsp;<br> # 查看网桥的IP<br> [root@linux-node1~]# ifconfig br0&nbsp;<br> br0:flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500<br> inet 192.168.56.111 netmask 255.255.255.0 broadcast 192.168.56.255<br> inet6 fe80::20c:29ff:fe5d:cc27 prefixlen 64scopeid 0x20&lt;link&gt;<br> ether 00:0c:29:5d:cc:27 txqueuelen 0(Ethernet)<br> RX packets 4813 bytes 472527 (461.4 KiB)<br> RX errors 0 dropped 0overruns 0 frame 0<br> TX packets 2705 bytes 510369 (498.4 KiB)<br> TX errors 0 dropped 0 overruns 0 carrier 0collisions 0<br> # 编辑虚拟机的网络配置使用br0网桥模式<br> [root@linux-node1 ~]# virsh edit CentOS-7-x86_64&nbsp;<br> &lt;interface type=’bridge’&gt; &nbsp; &nbsp; &nbsp; &nbsp;#虚拟机网络连接方式<br> &lt;mac address=’52:54:00:22:04:0f’/&gt; &nbsp; &nbsp; &nbsp; &nbsp;#为虚拟机分配MAC地址,务必唯一,如果是dhcp获得同样IP会引起冲突<br> &lt;source bridge=’br0’/&gt; &nbsp; &nbsp; &nbsp; &nbsp;#当前主机网桥名称<br> # 重启虚拟机<br> # 关闭KVM虚拟机<br> [root@linux-node1 opt]# virsh shutdown CentOS-7-x86_64&nbsp;<br> Domain CentOS-7-x86_64 is being shutdown<br> # 启动KVM虚拟机<br> [root@linux-node1 opt]# virsh start CentOS-7-x86_64&nbsp;<br> Domain CentOS-7-x86_64 started<br> # 然后配置静态IP地址,重启网卡,即可以通过xshell连接上KVM虚拟机了。</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;font-size:18px;">KVM性能优化</span><br><span style="line-height:1.5;color:rgb(0,0,255);">1）CPU的优化</span><br> Inter的cpu运行级别，按权限级别高低Ring3-&gt;Ring1-&gt;Ring0（Ring2和Ring1暂时不使用）Ring3为用户态；Ring0为内核态</p> 
    <p style="line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161226172314242-1766304726.png" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">Ring3的用户态是没有权限管理硬件的，需要切换到内核态Ring0，这样的切换（系统调用）称为上下文切换，物理机到虚拟机多次的上下文切换，势必会导致性能出现问题。对于全虚拟化，inter实现了技术VT-x，在CPU硬件上实现了加速转换，CentOS7默认是不需要开启的。<br><span style="line-height:1.5;color:rgb(0,0,255);">2）CPU缓存绑定</span><br> [root@linux-node1 ~]# lscpu|grep cache<br> L1d cache: 32K<br> L1i cache: 32K<br> L2 cache: 256K<br> L3 cache: 3072K</p> 
    <p style="line-height:1.5;">L1是静态缓存，造价高。<br> L2,L3是动态缓存，通过脉冲的方式写入0和1，造价较低。<br> cache解决了cpu处理快，内存处理慢的问题，类似于memcaced和数据库。<br> 如果cpu调度器把进程随便调度到其他cpu上，而不是当前L1,L2,L3的缓存cpu上，缓存就不生效了，就会产生miss，为了减少cache miss，需要把KVM进程绑定到固定的cpu上。<br> 可以使用taskset把某一个进程绑定（cpu亲和力绑定,可以提高20%的性能）在某一个cpu上，例如：taskset -cp 125718（1指的是cpu1,也可以绑定到多个cpu上，25718是指的pid）.<br> cpu绑定的优点：提高性能，20%以上<br> cpu绑定的缺点：不方便迁移，灵活性差<br><span style="line-height:1.5;color:rgb(0,0,255);">3）内存优化</span><br><span style="line-height:1.5;color:rgb(255,0,255);">原本实现方式：</span><br> 虚拟机的虚拟内存===&gt;虚拟机的物理内存<br> 宿主机的虚拟内存===&gt;宿主机的物理内存</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(255,0,255);">现在实现方式：EPT（inter）</span><br> 虚拟机的虚拟内存=====EPT=====宿主机的物理内存<br> VMM通过采用影子列表解决内存转换的问题，影子页表是一种比较成熟的纯软件的内存虚拟化方式，但影子页表固有的局限性，影响了VMM的性能，例如，客户机中有多个CPU，多个虚拟CPU之间同步页面数据将导致影子页表更新次数幅度增加，测试页表将带来异常严重的性能损失。如下图1-1为影子页表的原理图：</p> 
    <p style="line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161226172441898-91081904.png" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">在此之际，Inter在最新的Core I7系列处理器上集成了EPT技术（对应AMD的为RVI技术），以硬件辅助的方式完成客户物理内存到机器物理内存的转换，完成内存虚拟化，并以有效的方式弥补了影子页表的缺陷，该技术默认是开启的，如下图1-2为EPT技术的原理。</p> 
    <p style="line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/907596/201612/907596-20161226172500851-992804882.png" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(51,102,255);">KSM内存合并</span><br> 宿主机上默认会开启ksmd进程，该进程作为内核中的守护进程存在，它定期执行页面扫描，识别副本页面并合并副本，释放这些页面以供它用，CentOS7默认是开启状态<br> [root@linux-node1 ~]# ps aux |grep ksmd<br> root 280 0.0 0.0 0 0 ? SN 20:37 0:00 [ksmd]</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(51,102,255);">大页内存</span><br> Linux默认的内存页面大小都是4K，HugePage进程会将默认的每个内存页面可以调整为2M，CentOS7默认开启的<br> [root@linux-node1 ~]# cat /sys/kernel/mm/transparent_hugepage/enabled<br> [always] madvise never<br> [root@linux-node1 ~]# ps aux|grep hugepage|grep -v grep<br> root 2810.0 0.0 00 ? SN 04:220:03 [khugepaged]</p> 
    <p style="line-height:1.5;"><span style="line-height:1.5;color:rgb(0,0,255);">4）磁盘IO优化</span><br> IO调度算法，也叫电梯算法，详情请看赵班长博客：http://www.unixhot.com/article/4<br><span style="line-height:1.5;color:rgb(255,102,0);">1--Noop Scheduler</span>：简单的FIFO队列，最简单的调度算法，由于会产生读IO的阻塞，一般使用在SSD硬盘，此时不需要调度，IO效果非常好<br><span style="line-height:1.5;color:rgb(255,102,0);">2--Anticipatory IO Scheduler（as scheduler）</span>适合大数据顺序顺序存储的文件服务器，如ftp server和web server，不适合数据库环境，DB服务器不要使用这种算法。<br><span style="line-height:1.5;color:rgb(255,102,0);">3--Deadline Schedler</span>：按照截止时间的调度算法，为了防止出现读取被饿死的现象，按照截止时间进行调整，默认的是读期限短于写期限，就不会产生饿死的状况，一般应用在数据库<br><span style="line-height:1.5;color:rgb(255,102,0);">4--Complete Fair Queueing Schedule</span>：完全公平的排队的IO调度算法，保证每个进程相对特别公平的使用IO<br> # 查看本机Centos7默认所支持的调度算法<br> [root@linux-node1 ~]# dmesg|grep -i “scheduler”&nbsp;<br> [ 1.332147] io scheduler noop registered<br> [ 1.332151] io scheduler deadline registered (default)<br> [ 1.332190] io scheduler cfq registered<br> # 临时更改某个磁盘的IO调度算法，将deadling模式改为cfq模式<br> [root@linux-node1 ~]# cat /sys/block/sda/queue/scheduler<br> noop [deadline] cfq<br> [root@linux-node1 ~]# echo cfq &gt;/sys/block/sda/queue/scheduler&nbsp;<br> [root@linux-node1 ~]# cat /sys/block/sda/queue/scheduler<br> noop deadline [cfq]<br> # 使更改的IO调度算法永久生效，需要更改内核参数<br> [root@linux-node1 ~]# vim /boot/grub/menu.lst&nbsp;<br> kernel /boot/vmlinuz-3.10.0-229.el7 ro root=LABEL=/ elevator=deadline rhgb quiet</p> 
   </div> 
   <div style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;">
    ***************当你发现自己的才华撑不起野心时，就请安静下来学习吧***************
   </div> 
   <div class="clear" style="clear:both;font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;line-height:19.5px;"></div> 
   <div> 
    <div> 
     <font><span style="font-size:13px;line-height:19.5px;">本文转自散尽浮华博客园博客，原文链接：http://www.cnblogs.com/kevingrace/p/5252903.html</span></font>
     <span style="font-size:13px;line-height:19.5px;font-family:Verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
