<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++：对象的赋值和复制 « NotBeCN</title>
  <meta name="description" content="                  3.6.1 对象赋值语句     如同基本类型赋值语句一样，同类型的对象之间也可以进行赋值，即一个对象的值可以赋给另一个对象。这里所指的对象的赋值是指对其中的数据成员赋值，而不对成员函数赋值。例如：A和B是同一类的两个对象，那么下述对象赋值语句B=A；就能把对象A的数据成员的值...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/13/weixin_33834628_90117677.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C++：对象的赋值和复制</h1>
    <p class="post-meta">Oct 13, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">3.6.1 对象赋值语句</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">如同基本类型赋值语句一样，同类型的对象之间也可以进行赋值，即一个对象的值可以赋给</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">另一个对象。这里所指的对象的赋值是指对其中的数据成员赋值，而不对成员函数赋值。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如：A和B是同一类的两个对象，那么下述对象赋值语句</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">B=A；</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">就能把对象A的数据成员的值逐位复制给对象B</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">例3.24 对象赋值语句示例</span>
#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Myclass{
 </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
       </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span> <span style="line-height:1.8;color:rgb(0,0,255);">set</span>(<span style="line-height:1.8;color:rgb(0,0,255);">int</span> i,<span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> j)
       {
        a </span>=<span style="line-height:1.8;"> i;
        b </span>=<span style="line-height:1.8;"> j;
       }
       </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> show()
       {
        cout</span>&lt;&lt;a&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;b&lt;&lt;<span style="line-height:1.8;">endl;
       }
 </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
       </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> a,b;       
}; 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Myclass o1,o2;
 o1.</span><span style="line-height:1.8;color:rgb(0,0,255);">set</span>(<span style="line-height:1.8;color:rgb(128,0,128);">20</span>,<span style="line-height:1.8;color:rgb(128,0,128);">5</span><span style="line-height:1.8;">);
 o2 </span>= o1;          <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">将对象o1的值赋给对象o2 </span>
<span style="line-height:1.8;"> o1.show();
 o2.show();
 </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;
}
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
 该程序中，语句：
   o2 = o1;
 等价于语句：
   o2.a = o1.a;
   o2.b = o1.b;   
 因此，运行此程序将显示：
   20 5
   20 5
  说明：
  1、在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如对象的类型不同，
     编译时将出错。
  2、两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。例如
     本例对象后，再调用o1.set()设置o1的值，不会影响o2的值。
  3、对象赋值是通过默认赋值运算符函数实现的
  4、将一个对象的值赋给另一个对象时，多数情况下都是成功的，但当类中存在指针时，可能
     会产生错误。              
</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">3.6.2 拷贝构造函数</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。拷贝构造函数的作用</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">是，在建立一个新对象时，使用一个已经存在的对象去初始化这个新对象。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如： Point p2(p1)；</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">其作用是：在建立新对象p2时，用已经存在的对象p1去初始化对象p2，在这个过程中就要</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">调用拷贝构造函数。</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">拷贝构造函数具有以下特点：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（1）因为该函数也是一种构造函数，所以其函数名与类名相同，并且该函数也没有返回值</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">类型。</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（2）该函数只有一个参数，并且是同类对象的引用</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（3）每一个类都必须有一个拷贝构造函数。程序员可以自定义拷贝构造函数，用于按照需要</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">初始化新对象。如果程序员没有定义类的拷贝构造函数，系统就会自动生成产生一个默认的拷贝</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">构造函数，用于复制出数据成员值完全相同的新对象。</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">1. 自定义拷贝构造函数</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">一般格式： 类名::类名(const 类名 &amp;对象名)</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp;//拷贝构造函数的函数体&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}&nbsp;</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">下面是一个用户自定义的拷贝构造函数：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">class Point{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;public:</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">　　　　 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Point(int a,int b) //构造函数&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x = a;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y = b;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">　　　　　　 &nbsp;&nbsp;}</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Point(const Point &amp;p) //拷贝构造函数&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = 2*p.x;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y = 2*p.y;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.....</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private:</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int x;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int y; </span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">};&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">假如p1为类Point的一个对象，则下述语句可以在建立新对象p2时调用拷贝构造函数初始化p2；</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Point p2(p1);</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">//例3.25 自定义拷贝构造函数的使用。</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Point{
       </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
             Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span> a,<span style="line-height:1.8;color:rgb(0,0,255);">int</span> b)  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">普通构造函数 </span>
<span style="line-height:1.8;">             {
               x </span>=<span style="line-height:1.8;"> a;
               y </span>=<span style="line-height:1.8;"> b;
             }
             Point::Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">const</span> Point &amp;p) <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">自定义的拷贝构造函数 </span>
<span style="line-height:1.8;">             {
               x </span>= <span style="line-height:1.8;color:rgb(128,0,128);">2</span>*<span style="line-height:1.8;">p.x;
               y </span>= <span style="line-height:1.8;color:rgb(128,0,128);">2</span>*<span style="line-height:1.8;">p.y;
             }
             </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> print()
             {
              cout</span>&lt;&lt;x&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;y&lt;&lt;<span style="line-height:1.8;">endl; 
             }
       </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
               </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> x;
               </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> y;         
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
 Point p1(</span><span style="line-height:1.8;color:rgb(128,0,128);">30</span>,<span style="line-height:1.8;color:rgb(128,0,128);">40</span>);       <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义对象p1，调用了普通的构造函数</span>
 Point p2(p1);          <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用拷贝构造函数，用对象p1初始化对象p2 </span>
<span style="line-height:1.8;"> p1.print();
 p2.print();
 </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">; 
} 
</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">  本例中定义对象p2时，调用了自定义拷贝构造函数。程序运行结果如下：
        30 40 
        60 80
    
    调用拷贝构造函数的一般形式为：
    类名 对象2(对象1);
    
    上面的这种拷贝构造函数的方法称为“代入法”。除了用代入法调用拷贝构造函数外，
还可以采用"赋值法"调用拷贝构造函数,与基本类型的变量初始化类似.这种调用方的一般格式为：
    类名 对象2=对象1;
    当然，这种方法可以在一个语句中进行多个对象的复制。如
    Point p2=p1,p3=p1; 
    
如将例3.25主函数main改为如下形式：
int main()
{
 Point p1(10,20);
 Point p2=p1;  //以赋值法调用拷贝构造函数 
 p1.print();
 p2.print();
 return 0; 
}     </span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">2. 默认的拷贝构造函数(程序员没有定义，系统会自动生成)</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">// 例3.26 默认的拷贝构造函数</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Point{
 </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
        Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span> a,<span style="line-height:1.8;color:rgb(0,0,255);">int</span> b) <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">普通的构造函数 </span>
<span style="line-height:1.8;">        {
         x </span>=<span style="line-height:1.8;"> a;
         y </span>=<span style="line-height:1.8;"> b;
        }
        
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">        Point::Point(const Point &amp;p)</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">不用写，系统会默认存在（需要用时直接调用） 
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">        {
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">         x = p.x;
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">         y = p.y;
</span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">        }</span>
    
        <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> print()
        {
         cout</span>&lt;&lt;x&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;y&lt;&lt;<span style="line-height:1.8;">endl;
        } 
 </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
        </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> x;
        </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> y;
};
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
        Point p1(</span><span style="line-height:1.8;color:rgb(128,0,128);">30</span>,<span style="line-height:1.8;color:rgb(128,0,128);">40</span>);  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用普通构造函数 </span>
        Point p2(p1);     <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用代入法调用默认的拷贝构造函数,用对象p1初始化对象p2 </span>
        Point p3=p1;      <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用赋值法调用默认的拷贝构造函数,用对象p1初始化对象p3</span>
<span style="line-height:1.8;">        p1.print();
        p2.print();
        p3.print();
        </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;          
} 

</span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);">
   调用拷贝构造函数的方法有两种：代入法、赋值法
   
   代入法：Point p2(p1)

   赋值法：Point p2=p1 

</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">3.调用拷贝构造函数的三种情况</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（1）当用类的一个对象去初始化另一个对象时，拷贝构造函数将会被调用，</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">如例3.26主函数中的下属语句</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Point p2(p1); //用代入法调用默认的拷贝构造函数,用对象p1初始化对象p2&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">Point p3=p1; //用赋值法调用默认的拷贝构造函数,用对象p1初始化对象p3</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（2）当函数的形参是类的对象，在调用函数进行形参和实参结合时，拷贝构造函数将会被调用</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如：</span></p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'隶书';">void fun1(Point p) //形参是类Point的对象p</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;p.print();&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">int main()</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;point p1(10,20);</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;fun1(p1); //调用函数fun1时，实参p1是类Point的对象&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;//将调用拷贝构造函数，初始化形参对象p&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;return 0;&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">理解：在main函数内，执行语句“fun1(p1)”,便是这种情况。在调用这个函数时，对象p1是实参</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">用它来初始化被调用函数的形参p时，需要调用拷贝构造函数。这时，如果类Point中有自定义</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">的拷贝构造函数时，就调用拷贝的构造函数，否则就调用系统自动生成的默认拷贝构造函数</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">（3）当函数的 返回值是类的对象，在函数调用完毕将返回值（对象）带回调用处时。此时将会</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">调用拷贝构造函数，将此对象赋值给一个临时对象并传到该函数的调用处。</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">例如： Point fun2() //函数fun2()的返回值类型是Point类类型&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; Point p1(10,30); //定义类Point的对象p1&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp; return p1; // 函数的返回值是Point类的对象&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">int main()</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">{</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;Point p2; //定义类Point的对象p1&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;p2=fun2(); //函数执行完成，返回调用者时，调用拷贝构造函数(赋值法)&nbsp;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">&nbsp; &nbsp;return 0;</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">}&nbsp;</span><br><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">理解：</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">由于对象p1是函数fun2中定义的，在调用函数fun2结束时，p1的生命周期结束了，因此在</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">函数fun2结束之前，执行语句"return p1"时，将会调用拷贝构造函数将p1的值复制到一个</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">临时对象中，这个临时对象是系统在主程序中临时创建的。函数运行结束时，p1对象消失，</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">但是临时对象将会通过语句"p2=fun2()"将它的值赋给对象p2，执行完这个语句后，临时对</span><br><span style="line-height:1.8;font-size:18px;font-family:'隶书';">象变自动消失了。</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">例3.27  演示调用拷贝构造函数的3中情况</span>
<span style="line-height:1.8;">
#include</span>&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Point{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
          Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span> a=<span style="line-height:1.8;color:rgb(128,0,128);">0</span>,<span style="line-height:1.8;color:rgb(0,0,255);">int</span> b=<span style="line-height:1.8;color:rgb(128,0,128);">0</span>); <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">声明构造函数</span>
          Point::Point(<span style="line-height:1.8;color:rgb(0,0,255);">const</span> Point &amp;p); <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">声明拷贝构造函数</span>
        <span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> print()
        {
          cout</span>&lt;&lt;x&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;y&lt;&lt;<span style="line-height:1.8;">endl; 
        } 
  </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
        </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> x,y;
}; 
Point::Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span> a,<span style="line-height:1.8;color:rgb(0,0,255);">int</span> b)  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义构造函数 </span>
<span style="line-height:1.8;">{
   x </span>=<span style="line-height:1.8;"> a;
   y </span>=<span style="line-height:1.8;"> b;
   cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">Using normal constructor\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">;
}
Point::Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">const</span> Point &amp;p)<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义拷贝构造函数 </span>
<span style="line-height:1.8;">{
   x </span>= <span style="line-height:1.8;color:rgb(128,0,128);">2</span> *<span style="line-height:1.8;"> p.x;
   y </span>= <span style="line-height:1.8;color:rgb(128,0,128);">2</span> *<span style="line-height:1.8;"> p.y;
   cout</span>&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;color:rgb(128,0,0);">Using copy constructor\n</span><span style="line-height:1.8;color:rgb(128,0,0);">"</span><span style="line-height:1.8;">; 
} 
</span><span style="line-height:1.8;color:rgb(0,0,255);">void</span> fun1(Point p)    <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">形参是类Point的对象p</span>
<span style="line-height:1.8;">{
   p.print(); 
}
Point fun2()  </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">函数fun2()的返回值类型是Point类类型 </span>
<span style="line-height:1.8;">{
   Point p4(</span><span style="line-height:1.8;color:rgb(128,0,128);">10</span>,<span style="line-height:1.8;color:rgb(128,0,128);">30</span>);  <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义类Point的对象p4 </span>
   <span style="line-height:1.8;color:rgb(0,0,255);">return</span> p4;        <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);"> 函数的返回值是Point类的对象 </span>
<span style="line-height:1.8;">} 
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
   Point p1(</span><span style="line-height:1.8;color:rgb(128,0,128);">30</span>,<span style="line-height:1.8;color:rgb(128,0,128);">40</span>);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">定义对象p1时，第1次调用普通的构造函数 </span>
<span style="line-height:1.8;">   p1.print();      
   
   Point p2(p1); </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用带入法，用对象p1为对象p2进行初始化。此时会第1次调用拷贝构造函数 </span>
<span style="line-height:1.8;">   p2.print();
   
   Point p3</span>=p1; <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">用赋值法，用对象p1为对象p3进行初始化。此时会第2次调用拷贝构造函数 </span>
<span style="line-height:1.8;">   p3.print();
   
   fun1(p1);  </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">在调用fun1函数，实参和形参结合时， 此时会第3次调用拷贝构造函数 </span>
<span style="line-height:1.8;">   
   p2</span>=fun2(); <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">在调用fun2函数，在函数内部第2次调用普通构造函数。而且，当调用fun2函数结束时,
              </span><span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">还是用赋值法，用返回的对象p4为对象p2进行赋值，会第4次调用拷贝构造函数 </span>
<span style="line-height:1.8;">   p2.print();
   
   </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span> <span style="line-height:1.8;color:rgb(128,0,128);">0</span><span style="line-height:1.8;">;  
} 

运行结果：
          Using normal constructor 
          </span><span style="line-height:1.8;color:rgb(128,0,128);">30</span>    <span style="line-height:1.8;color:rgb(128,0,128);">40</span><span style="line-height:1.8;"> 
          Using Cpy constructor 
          </span><span style="line-height:1.8;color:rgb(128,0,128);">60</span>    <span style="line-height:1.8;color:rgb(128,0,128);">80</span><span style="line-height:1.8;"> 
          Using Cpy constructor 
          </span><span style="line-height:1.8;color:rgb(128,0,128);">60</span>    <span style="line-height:1.8;color:rgb(128,0,128);">80</span><span style="line-height:1.8;"> 
          Using Cpy constructor 
          </span><span style="line-height:1.8;color:rgb(128,0,128);">60</span>    <span style="line-height:1.8;color:rgb(128,0,128);">80</span><span style="line-height:1.8;"> 
          Using normal constructor
          Using Cpy constructor
          </span><span style="line-height:1.8;color:rgb(128,0,128);">20</span>    <span style="line-height:1.8;color:rgb(128,0,128);">60</span><span style="line-height:1.8;">
          
          
当没有自定义的拷贝构造函数时的运行结果:
        Using normal constructor 
          </span><span style="line-height:1.8;color:rgb(128,0,128);">30</span>    <span style="line-height:1.8;color:rgb(128,0,128);">40</span> 
          <span style="line-height:1.8;color:rgb(128,0,128);">30</span>    <span style="line-height:1.8;color:rgb(128,0,128);">40</span> 
          <span style="line-height:1.8;color:rgb(128,0,128);">30</span>    <span style="line-height:1.8;color:rgb(128,0,128);">40</span>  
          <span style="line-height:1.8;color:rgb(128,0,128);">30</span>    <span style="line-height:1.8;color:rgb(128,0,128);">40</span><span style="line-height:1.8;"> 
          Using normal constructor
          </span><span style="line-height:1.8;color:rgb(128,0,128);">10</span>    <span style="line-height:1.8;color:rgb(128,0,128);">30</span>         </pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p><span style="line-height:1.8;font-size:18px;">//再举一个实例为：</span></p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>#include&lt;iostream&gt;
<span style="line-height:1.8;color:rgb(0,0,255);">using</span> <span style="line-height:1.8;color:rgb(0,0,255);">namespace</span><span style="line-height:1.8;"> std;
</span><span style="line-height:1.8;color:rgb(0,0,255);">class</span><span style="line-height:1.8;"> Point{
  </span><span style="line-height:1.8;color:rgb(0,0,255);">public</span><span style="line-height:1.8;">:
    Point(</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span> a,<span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> b)
     {
       x </span>=<span style="line-height:1.8;"> a;
       y </span>=<span style="line-height:1.8;"> b;
     }
     </span><span style="line-height:1.8;color:rgb(0,128,0);">/*</span><span style="line-height:1.8;color:rgb(0,128,0);"> Point::</span><span style="line-height:1.8;color:rgb(0,128,0);">*/</span>Point(<span style="line-height:1.8;color:rgb(0,0,255);">const</span> Point &amp;p) <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">拷贝构造函数(用初始化过的对象为没有初始化过的对象进行初始化) </span>
<span style="line-height:1.8;">     {
       x </span>= <span style="line-height:1.8;color:rgb(128,0,128);">2</span> *<span style="line-height:1.8;"> p.x;
       y </span>= <span style="line-height:1.8;color:rgb(128,0,128);">2</span> *<span style="line-height:1.8;"> p.y;
     }
     Point</span>&amp; <span style="line-height:1.8;color:rgb(0,0,255);">operator</span> = (<span style="line-height:1.8;color:rgb(0,0,255);">const</span> Point &amp;p)<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">赋值运算符重载函数(用初始化过的对象为初始化过的对象进行赋值) </span>
<span style="line-height:1.8;">     {
       x </span>=<span style="line-height:1.8;"> p.x;
       y </span>=<span style="line-height:1.8;"> p.y;
     }
     Point fun();
     </span><span style="line-height:1.8;color:rgb(0,0,255);">void</span><span style="line-height:1.8;"> print()
     {
       cout</span>&lt;&lt;x&lt;&lt;<span style="line-height:1.8;color:rgb(128,0,0);">"</span> <span style="line-height:1.8;color:rgb(128,0,0);">"</span>&lt;&lt;y&lt;&lt;<span style="line-height:1.8;">endl;
     }
   </span><span style="line-height:1.8;color:rgb(0,0,255);">private</span><span style="line-height:1.8;">:
        </span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> x,y;     
};
Point::Point fun(Point p4)
{
    </span><span style="line-height:1.8;color:rgb(0,0,255);">return</span><span style="line-height:1.8;"> p4; 
}
</span><span style="line-height:1.8;color:rgb(0,0,255);">int</span><span style="line-height:1.8;"> main()
{
  Point p1(</span><span style="line-height:1.8;color:rgb(128,0,128);">10</span>,<span style="line-height:1.8;color:rgb(128,0,128);">20</span><span style="line-height:1.8;">);
  Point p3(</span><span style="line-height:1.8;color:rgb(128,0,128);">15</span>,<span style="line-height:1.8;color:rgb(128,0,128);">15</span><span style="line-height:1.8;">);
  
  p3</span>=p1;<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用赋值运算符重载函数 </span>
<span style="line-height:1.8;">  p3.print();
  
  Point p2 </span>= fun(p1);<span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);">调用fun函数时，实参和形参结合，会第1次调用拷贝构造函数；调用fun函数结束时，</span>
   p2.print() ;         <span style="line-height:1.8;color:rgb(0,128,0);">//</span><span style="line-height:1.8;color:rgb(0,128,0);"> 返回的对象p4为未初始化的p2进行初始化，会第2次调用拷贝构造函数 </span>
}</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div class="clear" style="clear:both;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"></div> 
   <div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;line-height:25.2px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/4912150.html</span></font>
     <span style="font-size:14px;line-height:25.2px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
    </div> 
    <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;">
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
