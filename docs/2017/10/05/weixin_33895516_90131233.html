<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>技术分享之八大排序算法（均已以升序为例） « NotBeCN</title>
  <meta name="description" content="                  一、排序名称          内部排序：指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。其中快速排序的是目前排序方法中被认为是最好的方法。     1、插入排序：直接插入排序、(shell)希尔排序     2、交换排序：冒泡排序、快速排序     3、选择...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/05/weixin_33895516_90131233.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">技术分享之八大排序算法（均已以升序为例）</h1>
    <p class="post-meta">Oct 5, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"> 
    <p><strong><span style="line-height:1.8;font-size:18px;font-family:'楷体';">一、排序名称</span></strong></p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529113023977-1530758265.png" alt="" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">内部排序：指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。其中<a href="http://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">快速排序</a>的是目前排序方法中被认为是最好的方法。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">1、插入排序：直接插入排序、(shell)希尔排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">2、交换排序：冒泡排序、快速排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">3、选择排序：简单选择排序、堆排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">4、归并排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">5、基数排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">外部排序：指的是大文件的排序，即待排序的记录存储在<a href="http://baike.baidu.com/item/%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">外存储器</a>(硬盘…)上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">例如：将原文件分解成多个能够一次性装入内存的部分分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序。内存才2G，外存有1000G待排序文件 = 500个 x 2G，然后每2G转入内存进行排序，排完序写入外存， 最后将500个排好序的文件进行归并排序。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;</span></p> 
    <p><strong><span style="line-height:1.8;font-size:18px;font-family:'楷体';">二、性能元素</span></strong></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">1、稳定性&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。例如：{ 2 5 3&nbsp;<span style="line-height:1.8;">7</span>&nbsp;10&nbsp;<span style="line-height:1.8;">7</span>&nbsp;9} —&gt;&nbsp; { 2 3 5&nbsp;<span style="line-height:1.8;">7</span>&nbsp;<span style="line-height:1.8;">7</span>&nbsp;9 10} ，一次排序后，红色的"7"还是在绿色的"7"前面。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序在高位也相同时是不会改变的。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp; &nbsp; &nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">2、时间复杂度 T(n)=O(f(n))</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）算法的时间复杂度O(n)是一个问题规模n函数，没有严格的定义，它定量描述了该算法的运行所需要的时间。衡量一个算法的效率，如果以每条代码的实际执行次数，虽然精确，但十分烦琐。因此人们设计了用数量级的方法来衡量算法效率，如甲程序的执行次数为2n(n为数据量个数),乙为 3n+2,则当 n 很大时,认为甲乙是等数量级的,是等效率的</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）时间频度不同(一个算法中的语句执行次数称为语句频度或时间频度。记为T(n))，但时间复杂度可能相同。如：T(n)=n^2+3n与T(n)=n^2+4n它们的频度不同，但时间复杂度相同，都为O(n^2)。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（3）时间复杂度比较简单的计算方法是：看看有几重for循环，没有循环时间复杂度为O(1)，只有一重则时间复杂度为O(n)，二重则为O(n^2)，依此类推，如果有二分则为O(logn)，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为O(nlogn)。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">3、空间复杂度 S(n)=O(f(n))</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）它也是问题规模n的函数，S(n)定义为一个算法在运行过程中临时占用辅助存储空间大小的量度。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）算法的空间复杂度一般也以数量级的形式给出。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;&nbsp; 当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;&nbsp; 当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)；</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;&nbsp; 当一个算法的空间复杂度与n成线性比例关系时，可表示为O(n)。</span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-family:'楷体';"><strong><span style="line-height:1.8;font-size:18px;">三、性能总结</span></strong></span></p> 
    <p><span style="line-height:1.8;font-family:'楷体';"><strong><span style="line-height:1.8;font-size:18px;"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529113542852-1797005859.png" alt="" width="706" height="409" style="border:0px;"></span></strong></span></p> 
    <p>&nbsp;</p> 
    <p>&nbsp;</p> 
    <p><strong><span style="line-height:1.8;font-size:18px;font-family:'楷体';">四、分别介绍</span></strong></p> 
    <p><span style="line-height:1.8;color:rgb(255,0,0);"><strong><span style="line-height:1.8;font-size:16px;font-family:'楷体';">1、简单选择排序</span></strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp; &nbsp;一句话概括就是依次按位置挑选出适合此位置的元素来填充。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）暂定第一个元素为最小元素，往后遍历，逐个与最小元素比较，若发现更小者，与先前的"最小元素"交换位置。达到更新最小元素的目的。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）一趟遍历完成后，能确保刚刚完成的这一趟遍历中，最的小元素已经放置在前方了。然后缩小排序范围，新一趟排序从数组的第二个元素开始。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（3）在新一轮排序中重复第1、2步骤，直到范围不能缩小为止，排序完成。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">以下为选择排序的存储状态，其中大括号内为无序区，大括号外为有序序列：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">初始序列：<strong>{</strong>49 27 65 97 76 12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第1趟：12与49索引交换：12&nbsp;<strong>{</strong>27 65 97 76 49 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第2趟：27不动　： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 27&nbsp;<strong>{</strong>65 97 76 49 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第3趟：65与38索引交换：12 27 38&nbsp;&nbsp;<strong>{</strong>97 76 49 65<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第4趟：97与49索引交换：12 27 38 49 &nbsp;&nbsp;<strong>{</strong>76 97 65<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第5趟：76与65索引交换：12 27 38 49 65 &nbsp;&nbsp;<strong>{</strong>97 76<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第6趟：97与76索引交换：12 27 38 49 65 76 97 完成</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529113637649-203223413.png" alt="" width="744" height="420" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;color:rgb(255,0,0);"><strong><span style="line-height:1.8;font-size:16px;font-family:'楷体';">2、冒泡排序</span></strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp; &nbsp; 一句话概括就是将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，浮在上面，较大的元素往下沉。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）在一趟遍历中，不断地对相邻的两个元素进行排序，小的在前大的在后，这样会造成大值不断沉底的效果，当一趟遍历完成时，最大的元素会被排在后方正确的位置上。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）然后缩小排序范围，即去掉最后方位置正确的元素，对前方数组进行新一轮遍历，重复第1步骤。直到范围不能缩小为止，排序完成。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">以下为选择排序的存储状态，其中大括号内为无序区，大括号外为有序序列：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">初始序列：<strong>{</strong>49 27 65 97 76 12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第1趟：97沉底：<strong>{ 49&nbsp;</strong>27 65 76 12 38<strong>}&nbsp;</strong>97</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第2趟：76沉底：<strong>{ 49&nbsp;</strong>27 65 12<strong>&nbsp;38 }&nbsp;</strong>76<strong>&nbsp;97</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第3趟：65沉底：<strong>{ 49&nbsp;</strong>27 12<strong>&nbsp;38 }&nbsp;</strong>65 76&nbsp;<strong>97</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第4趟：<strong>49沉底</strong>：<strong>{&nbsp;</strong>27 12<strong>&nbsp;38 } 49&nbsp;</strong>65 76&nbsp;<strong>97</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第5趟：38沉底：<strong>{&nbsp;</strong>27 12<strong>&nbsp;} 38 49&nbsp;</strong>65 76&nbsp;<strong>97</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第6趟：27沉底：<strong>{</strong>&nbsp;12<strong>&nbsp;}&nbsp;</strong>27&nbsp;<strong>38 49&nbsp;</strong>65 76&nbsp;<strong>97</strong></span></p> 
    <p>&nbsp; &nbsp; &nbsp;&nbsp;<span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';">第7趟：12沉底：12<strong>&nbsp;&nbsp;</strong>27&nbsp;<strong>38 49&nbsp;</strong>65 76&nbsp;<strong>97 完成</strong></span><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114120039-348597709.png" alt="" width="751" height="325" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'楷体';color:rgb(255,0,0);">3、直接插入排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">插入排序是从一个乱序的数组中依次取值，插入到一个已经排好序的数组中，比较的两个记录跨度为1。可以想象一下打扑克牌插牌时的情景。这看起来好像要两个数组才能完成，但如果只想在同一个数组内排序，也是可以的。此时需要想象出两个区域：前方有序区和后方乱序区。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">某些情况下效率很高：1、记录本身基本有序 &nbsp; 2、记录数比较少</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）分区。开始时前方有序区只有一个元素，就是数组的第一个元素。然后把从第二个元素开始直到结尾的数组作为乱序区。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）从乱序区取第一个元素，把它正确插入到前方有序区中。把它与前方有序区的最后一个元素比较，亦即与它的前一个元素比较。</span></p> 
    <ul>
     <li style="list-style:disc;"><span style="line-height:1.8;font-size:16px;font-family:'楷体';">如果比前一个元素要大，则不需要交换，这时有序区扩充一格，乱序区往后缩减一格，相当于直接拼在有序区末尾。</span></li> 
     <li style="list-style:disc;"><span style="line-height:1.8;font-size:16px;font-family:'楷体';">如果和前一个元素相等，则继续和前二元素比较、再和前三元素比较......如果往前遍历到头了，发现前方所有元素值都一样，那也可以不需要交换，这时有序区扩充一格，乱序区往后缩减一格，相当于直接拼在有序区末尾。</span></li> 
     <li style="list-style:disc;"><span style="line-height:1.8;font-size:16px;font-family:'楷体';">如果比前一个元素小，则交换它们的位置。交换完后，继续比较取出元素和它此时的前一个元素，若更小就交换，若相等就比较前一个，直到遍历完成。</span></li> 
     <li style="list-style:disc;"><span style="line-height:1.8;font-size:16px;font-family:'楷体';">至此，把乱序区第一个元素正确插入到前方有序区中。</span></li> 
    </ul>
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（3）往后缩小乱序区范围，继续取缩小范围后的第一个元素，重复第2步骤。直到范围不能缩小为止，排序完成。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">以下为选择排序的存储状态，其中大括号内为无序区，大括号外为有序序列：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">初始序列：<strong>{</strong>49 27 65 97 76 12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第1趟：无序区的27添加到有序区49的前面 {27 49}<strong>&nbsp;{</strong>&nbsp;65 97 76 12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第2趟：无序区的65添加到有序区49的后面 {27 49 65}<strong>&nbsp;{</strong>&nbsp;97 76 12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第3趟：无序区的97添加到有序区65的后面 {27 49 65 97}<strong>&nbsp;{</strong>&nbsp;76 12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第4趟：无序区的65添加到有序区97的前面,49的后面 {27 49 65 76 97}<strong>&nbsp;{</strong>&nbsp;12 38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第5趟：无序区的76添加到有序区97的前面,65的后面 {12 27 49 65 76 97}<strong>&nbsp;{</strong>&nbsp;38<strong>}</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">　　第6趟：无序区的12添加到到有序区27的前面 {12 27 49 65 76 97}<strong>&nbsp;{</strong>38<strong>}</strong></span></p> 
    <p>&nbsp; &nbsp; &nbsp;&nbsp;<span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';">第7趟：无序区的38添加到到有序区49的前面,27的后面&nbsp; {12 27 38 49 65 76 97}<strong>&nbsp;完成</strong></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114333602-1633772539.png" alt="" width="759" height="398" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';color:rgb(255,0,0);">4、快速排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114502727-1082805524.png" alt="" width="748" height="541" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">上图中，演示了快速排序的处理过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">初始状态为一组无序的数组：2、4、5、1、3。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">经过以上操作步骤后，完成了第一次的排序，得到新的数组：1、2、5、4、3。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">新的数组中，以2为分割点，左边都是比2小的数，右边都是比2大的数。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">因为2已经在数组中找到了合适的位置，所以不用再动。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">2左边的数组只有一个元素1，所以显然不用再排序，位置也被确定。（注：这种情况时，left指针和right指针显然是重合的。因此在代码中，我们可以通过设置判定条件<strong>left</strong>必须小于<strong>right</strong>，如果不满足，则不用排序了）。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">而对于2右边的数组5、4、3，设置left指向5，right指向3，开始继续重复图中的一、二、三、四步骤，对新的数组进行排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114646930-241103545.png" alt="" width="762" height="559" style="border:0px;">&nbsp;</span></p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114719696-1627438863.png" alt="" width="764" height="435" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';color:rgb(255,0,0);">5、堆排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">堆：堆是一棵顺序存储的完全二叉树。</span></p> 
    <p><span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';">其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。</span></p> 
    <p><span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';">其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。</span></p> 
    <p><span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';">举例来说，对于n个元素的序列{R0,&nbsp;R1, ... ,&nbsp;Rn}当且仅当满足下列关系之一时，称之为堆：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">(<strong>1</strong>)<strong>&nbsp;Ri&nbsp;&lt;= R2i+1&nbsp;</strong>且<strong>&nbsp;Ri&nbsp;&lt;= R2i+2&nbsp;</strong>(小根堆)</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">(<strong>2</strong>)<strong>&nbsp;Ri&nbsp;&gt;= R2i+1&nbsp;</strong>且<strong>&nbsp;Ri&nbsp;&gt;= R2i+2&nbsp;</strong>(大根堆)</span></p> 
    <p><span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';">其中i=1,2,…,n/2向下取整;&nbsp;</span></p> 
    <p><span class="Apple-tab-span" style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114826008-72035028.png" alt="" width="763" height="366" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想（最大堆进行升序排序）：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">① 初始化堆：将数列a[1...n]构造成最大堆。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">② 交换数据：将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。整个过程就是：创建堆—堆排序—创建堆—堆排序......堆排序（Heap Sort）只需要一个记录元素大小的辅助空间（供交换用），每个待排序的记录仅占有一个存储空间。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大），按层倒着选择非叶节点去比较。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。&nbsp;当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1)构建堆</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;&nbsp; 无序序列{ 1 , 3, 4, 5, 2, 6, 9,&nbsp; 7,&nbsp; 8,&nbsp; 0}</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529114933883-1658846146.png" alt="" width="735" height="519" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">&nbsp;&nbsp;(2)堆排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115028383-1989289907.png" alt="" width="736" height="702" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115134368-1606393668.png" alt="" width="736" height="569" style="border:0px;">&nbsp;</span></p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115156993-99742225.png" alt="" width="735" height="450" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';color:rgb(255,0,0);">6、希尔排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">又称为缩小增量排序，它也是一种插入排序。不过它是直接插入排序算法的一种威力加强版。把记录按步长<strong>&nbsp;gap</strong>&nbsp;分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到&nbsp;<strong>1</strong>&nbsp;时，整个数据合成为一组，构成一组有序记录，则完成排序。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">初始时，有一个大小为 10 的无序序列。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">接下来，按照直接插入排序的方法对每个组进行排序。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">按照直接插入排序的方法对每个组进行排序。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">需要注意一下的是，图中有两个相等数值的元素&nbsp;<strong>5</strong>&nbsp;和&nbsp;<strong>5</strong>&nbsp;。我们可以清楚的看到，在排序过程中，两个元素位置交换了。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115355618-191627974.png" alt="" width="763" height="638" style="border:0px;"></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115424008-1241854302.png" alt="" width="763" height="522" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';color:rgb(255,0,0);">7、归并排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">理解：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（<strong>Divide and Conquer</strong>）的一个非常典型的应用。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">将待排序序列R[0...n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">归并排序其实要做两件事：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（1）“分解”——将序列每次折半划分。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">（2）“合并”——将划分后的序列段两两合并后排序。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">1、先考虑第二步，如何合并？</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">在每次合并过程中，都是对两个有序的序列段进行合并，然后排序。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">这两个有序序列段分别为 R[low, mid] 和 R[mid+1, high]。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">先将他们合并到一个局部的暂存数组R2中，待合并完成后再将R2复制回R中。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">为了方便描述，我们称 R[low, mid] 第一段，R[mid+1, high] 为第二段。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">每次从两个段中取出一个记录进行关键字的比较，将较小者放入R2中。最后将各段中余下的部分直接复制到R2中。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">经过这样的过程，R2已经是一个有序的序列，再将其复制回R中，一次合并排序就完成了。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">2、其次，掌握了合并的方法，接下来，让我们来了解如何分解？其实就是折半划分，直到每一个有序序列长度为1结束。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115554399-1008972401.png" alt="" width="550" height="410" style="border:0px;"></span></p> 
    <p>&nbsp;</p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115610196-944018221.png" alt="" width="834" height="472" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115710071-797555015.png" alt="" width="839" height="812" style="border:0px;"></span></p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115737868-419750641.png" alt="" width="840" height="483" style="border:0px;"></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';color:rgb(255,0,0);">8、基数排序</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">思想：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">基数排序与本系列前面讲解的七种排序方法都不同，它不需要比较关键字的大小。它是根据关键字中各位的值，通过对排序的N个元素进行若干趟“分配”与“收集”来实现排序的。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">过程：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">通过一个具体的实例来展示一下，基数排序是如何进行的。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以0~9来表示的。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">所以我们不妨把0~9视为10个桶。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是0，将这个数存入编号为0的桶中。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">分类后，我们在从各个桶中，将这些数按照从编号0到编号9的顺序依次将所有数取出来。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">这时，得到的序列就是个位数上呈递增趋势的序列。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。位数不够的，在数字前面补充0后，再填桶。&nbsp;</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">示例：</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';"><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115911711-913302007.png" alt="" width="597" height="457" style="border:0px;"></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">{50, 123, 543, 187, 49, 30, 0, 2, 11, 100}</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">50 30 0 100 11 2 123 543 187 49&nbsp; 个位</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">0 100 2 11 123 30 543 49 50 187&nbsp; 十位</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">0 2 11 30 49 50 100 123 187 543&nbsp; 百位</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">核心代码：</span></p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529115936664-1027214107.png" alt="" width="864" height="781" style="border:0px;">&nbsp;</p> 
    <p><img src="https://images2015.cnblogs.com/blog/791499/201705/791499-20170529120002805-1419251031.png" alt="" width="864" height="96" style="border:0px;"></p> 
    <p>&nbsp;</p> 
    <p><span style="line-height:1.8;font-size:18px;font-family:'楷体';">五、参考地址</span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">稳定性：<a href="http://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">http://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html</a></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">iOS演示：<a href="http://www.jianshu.com/p/70619984fbc6?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">http://www.jianshu.com/p/70619984fbc6?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends</a></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">Java排序总结：<a href="http://www.jianshu.com/p/7d037c332a9d?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">http://www.jianshu.com/p/7d037c332a9d?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends</a></span></p> 
    <p><span style="line-height:1.8;font-size:16px;font-family:'楷体';">堆排序：<a href="http://www.cnblogs.com/skywang12345/p/3602162.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51,51,51);">http://www.cnblogs.com/skywang12345/p/3602162.html</a></span></p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div class="clear" style="clear:both;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25.2px;"></div> 
   <div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;line-height:25.2px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/6917708.html</span></font>
     <span style="font-size:14px;line-height:25.2px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
