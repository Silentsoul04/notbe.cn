<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>归纳一下:C#线程同步的几种方法 « NotBeCN</title>
  <meta name="description" content="             　我们在编程的时候，有时会使用多线程来解决问题，比如你的程序需要在后台处理一大堆数据，但还要使用户界面处于可操作状态；或者你的程序需要访问一些外部资源如数据库或网络文件等。这些情况你都可以创建一个子线程去处理，然而，多线程不可避免地会带来一个问题，就是线程同步的问题。如果这个问题处理不好...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/16/weixin_33737774_90125205.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">归纳一下:C#线程同步的几种方法</h1>
    <p class="post-meta">Oct 16, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　我们在编程的时候，有时会使用多线程来解决问题，比如你的程序需要在后台处理一大堆数据，但还要使用户界面处于可操作状态；或者你的程序需要访问一些外部资源如数据库或网络文件等。这些情况你都可以创建一个子线程去处理，然而，多线程不可避免地会带来一个问题，就是线程同步的问题。如果这个问题处理不好，我们就会得到一些非预期的结果。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　在网上也看过一些关于线程同步的文章，其实线程同步有好几种方法，下面我就简单的做一下归纳。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>一、volatile关键字</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　volatile是最简单的一种同步方法，当然简单是要付出代价的。它只能在变量一级做同步，volatile的含义就是告诉处理器， 不要将我放入工作内存， 请直接在主存操作我。（【转自<a href="http://www.bitscn.com/" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;">www.bitsCN.com</a>&nbsp;】）因此，当多线程同时访问该变量时，都将直接操作主存，从本质上做到了变量共享。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　能够被标识为volatile的必须是以下几种类型：（摘自MSDN）</p> 
   <ul style="margin-left:30px;font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">
    <li style="list-style-type:disc;">Any reference type.</li> 
    <li style="list-style-type:disc;">Any pointer type (in an unsafe context).</li> 
    <li style="list-style-type:disc;">The types sbyte, byte, short, ushort, int, uint, char, float, bool.</li> 
    <li style="list-style-type:disc;">An enum type with an enum base type of byte, sbyte, short, ushort, int, or uint.</li> 
   </ul>
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　如：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;">&nbsp;
    <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span>&nbsp;
    <br>
    <span style="line-height:1.5;">public</span>&nbsp;
    <span style="line-height:1.5;">class</span>&nbsp;
    <span style="line-height:1.5;">A<br> {<br></span>
    <span style="line-height:1.5;">private</span>&nbsp;
    <span style="line-height:1.5;">volatile</span>&nbsp;
    <span style="line-height:1.5;">int</span>&nbsp;
    <span style="line-height:1.5;">_i;<br></span>
    <span style="line-height:1.5;">public</span>&nbsp;
    <span style="line-height:1.5;">int</span>&nbsp;
    <span style="line-height:1.5;">I<br> {<br></span>
    <span style="line-height:1.5;">get</span>&nbsp;
    <span style="line-height:1.5;">{&nbsp;</span>
    <span style="line-height:1.5;">return</span>&nbsp;
    <span style="line-height:1.5;">_i; }<br></span>
    <span style="line-height:1.5;">set</span>&nbsp;
    <span style="line-height:1.5;">{ _i&nbsp;</span>
    <span style="line-height:1.5;">=</span>&nbsp;
    <span style="line-height:1.5;">value; }<br> }<br> }</span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　但volatile并不能实现真正的同步，因为它的操作级别只停留在变量级别，而不是原子级别。如果是在单处理器系统中，是没有任何问题的，变量在主存中没有机会被其他人修改，因为只有一个处理器，这就叫作processor Self-Consistency。但在多处理器系统中，可能就会有问题。&nbsp;每个处理器都有自己的data cach，而且被更新的数据也不一定会立即写回到主存。所以可能会造成不同步，但这种情况很难发生，因为cach的读写速度相当快，flush的频率也相当高，只有在压力测试的时候才有可能发生，而且几率非常非常小。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>二、lock关键字</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　lock是一种比较好用的简单的线程同步方式，它是通过为给定对象获取互斥锁来实现同步的。它可以保证当一个线程在关键代码段的时候，另一个线程不会进来，它只能等待，等到那个线程对象被释放，也就是说线程出了临界区。用法：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;">&nbsp;
    <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span>&nbsp;
    <br>
    <span style="line-height:1.5;">public</span>&nbsp;
    <span style="line-height:1.5;">void</span>&nbsp;
    <span style="line-height:1.5;">Function()&nbsp;<br> {<br></span>
    <span style="line-height:1.5;">object</span>&nbsp;
    <span style="line-height:1.5;">lockThis&nbsp;</span>
    <span style="line-height:1.5;">=</span>&nbsp;
    <span style="line-height:1.5;">new</span>&nbsp;
    <span style="line-height:1.5;">object</span>&nbsp;
    <span style="line-height:1.5;">();&nbsp;<br></span>
    <span style="line-height:1.5;">lock</span>&nbsp;
    <span style="line-height:1.5;">(lockThis)<br> {<br></span>
    <span style="line-height:1.5;">//</span>&nbsp;
    <span style="line-height:1.5;">Access thread-sensitive resources.</span>&nbsp;
    <span style="line-height:1.5;"><br></span>
    <span style="line-height:1.5;">}<br> }</span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">&nbsp;</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">&nbsp;</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">&nbsp;</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　lock的参数必须是基于引用类型的对象，不要是基本类型像bool,int什么的，这样根本不能同步，原因是lock的参数要求是对象，如果传入int，势必要发生装箱操作，这样每次lock的都将是一个新的不同的对象。最好避免使用public类型或不受程序控制的对象实例，因为这样很可能导致死锁。特别是不要使用字符串作为lock的参数，因为字符串被CLR“暂留”，就是说整个应用程序中给定的字符串都只有一个实例，因此更容易造成死锁现象。建议使用不被“暂留”的私有或受保护成员作为参数。其实某些类已经提供了专门用于被锁的成员，比如Array类型提供SyncRoot，许多其它集合类型也都提供了SyncRoot。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">&nbsp;</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　所以，使用lock应该注意以下几点：　</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　１、如果一个类的实例是public的，最好不要lock(this)。因为使用你的类的人也许不知道你用了lock，如果他new了一个实例，并且对这个实例上锁，就很容易造成死锁。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　２、如果MyType是public的，不要lock(typeof(MyType))</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　３、永远也不要lock一个字符串</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>三、System.Threading.Interlocked</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　对于整数数据类型的简单操作，可以用&nbsp;Interlocked&nbsp;类的成员来实现线程同步，存在于System.Threading命名空间。Interlocked类有以下方法：Increment&nbsp;,&nbsp;Decrement&nbsp;,&nbsp;Exchange&nbsp;和CompareExchange&nbsp;。使用Increment&nbsp;和Decrement&nbsp;可以保证对一个整数的加减为一个原子操作。Exchange&nbsp;方法自动交换指定变量的值。CompareExchange&nbsp;方法组合了两个操作：比较两个值以及根据比较的结果将第三个值存储在其中一个变量中。比较和交换操作也是按原子操作执行的。如：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;">&nbsp;
    <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span>&nbsp;
    <br>
    <span style="line-height:1.5;">int</span>&nbsp;
    <span style="line-height:1.5;">i&nbsp;</span>
    <span style="line-height:1.5;">=</span>&nbsp;
    <span style="line-height:1.5;">0</span>&nbsp;
    <span style="line-height:1.5;">;<br> System.Threading.Interlocked.Increment(</span>&nbsp;
    <span style="line-height:1.5;">ref</span>&nbsp;
    <span style="line-height:1.5;">i);<br> Console.WriteLine(i);<br> System.Threading.Interlocked.Decrement(</span>&nbsp;
    <span style="line-height:1.5;">ref</span>&nbsp;
    <span style="line-height:1.5;">i);<br> Console.WriteLine(i);<br> System.Threading.Interlocked.Exchange(</span>&nbsp;
    <span style="line-height:1.5;">ref</span>&nbsp;
    <span style="line-height:1.5;">i,&nbsp;</span>
    <span style="line-height:1.5;">100</span>&nbsp;
    <span style="line-height:1.5;">);<br> Console.WriteLine(i);<br> System.Threading.Interlocked.CompareExchange(</span>&nbsp;
    <span style="line-height:1.5;">ref</span>&nbsp;
    <span style="line-height:1.5;">i,&nbsp;</span>
    <span style="line-height:1.5;">10</span>&nbsp;
    <span style="line-height:1.5;">,&nbsp;</span>
    <span style="line-height:1.5;">100</span>&nbsp;
    <span style="line-height:1.5;">);</span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">Output:</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><img src="https://pic002.cnblogs.com/img/michaelxu/200809/2008091920515229.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>四、Monitor</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　Monitor类提供了与lock类似的功能,不过与lock不同的是,它能更好的控制同步块,当调用了Monitor的Enter(Object o)方法时,会获取o的独占权,直到调用Exit(Object o)方法时,才会释放对o的独占权,可以多次调用Enter(Object o)方法,只需要调用同样次数的Exit(Object o)方法即可,Monitor类同时提供了TryEnter(Object o,[int])的一个重载方法,该方法尝试获取o对象的独占权,当获取独占权失败时,将返回false。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　但使用&nbsp;<strong>lock</strong>&nbsp;通常比直接使用&nbsp;<strong>Monitor</strong>&nbsp;更可取，一方面是因为&nbsp;<strong>lock</strong>&nbsp;更简洁，另一方面是因为&nbsp;<strong>lock</strong>&nbsp;确保了即使受保护的代码引发异常，也可以释放基础监视器。这是通过&nbsp;<strong>finally</strong>&nbsp;中调用Exit来实现的。事实上，<strong>lock</strong>&nbsp;就是用&nbsp;Monitor&nbsp;类来实现的。下面两段代码是等效的：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <span style="line-height:1.5;"><img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;">&nbsp;<span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span>&nbsp;<br><span style="line-height:1.5;">lock</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">(x)<br> {<br> DoSomething();<br> }</span></span>
    <pre></pre> 
    <span style="line-height:1.5;"><span style="line-height:1.5;">等效于<br><br></span><span style="line-height:1.5;">object</span>&nbsp;<span style="line-height:1.5;">obj&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">(</span>&nbsp;<span style="line-height:1.5;">object</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">)x;<br> System.Threading.Monitor.Enter(obj);<br></span><span style="line-height:1.5;">try</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">{<br> DoSomething();<br> }<br></span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">finally</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">{<br> System.Threading.Monitor.Exit(obj);<br> }</span></span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">&nbsp;</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">关于用法，请参考下面的代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <span style="line-height:1.5;"><img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;">&nbsp;<span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span>&nbsp;<br><span style="line-height:1.5;">private</span>&nbsp;<span style="line-height:1.5;">static</span>&nbsp;<span style="line-height:1.5;">object</span>&nbsp;<span style="line-height:1.5;">m_monitorObject&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">object</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">();<br> [STAThread]<br></span><span style="line-height:1.5;">static</span>&nbsp;<span style="line-height:1.5;">void</span>&nbsp;<span style="line-height:1.5;">Main(</span>&nbsp;<span style="line-height:1.5;">string</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">[] args)<br> {<br> Thread thread&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">Thread(</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">ThreadStart(Do));<br> thread.Name&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">Thread1</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> Thread thread2&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">Thread(</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">ThreadStart(Do));<br> thread2.Name&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">Thread2</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> thread.Start();<br> thread2.Start();<br> thread.Join();<br> thread2.Join();<br> Console.Read();<br> }<br></span><span style="line-height:1.5;">static</span>&nbsp;<span style="line-height:1.5;">void</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">Do()<br> {<br></span><span style="line-height:1.5;">if</span>&nbsp;<span style="line-height:1.5;">(</span>&nbsp;<span style="line-height:1.5;">!</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">Monitor.TryEnter(m_monitorObject))<br> {<br> Console.WriteLine(</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">Can't visit Object&nbsp;</span><span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">+</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">Thread.CurrentThread.Name);<br></span><span style="line-height:1.5;">return</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> }<br></span><span style="line-height:1.5;">try</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">{<br> Monitor.Enter(m_monitorObject);<br> Console.WriteLine(</span></span>
    <span style="line-height:1.5;">&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">Enter Monitor&nbsp;</span><span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">+</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">Thread.CurrentThread.Name);<br> Thread.Sleep(</span>&nbsp;<span style="line-height:1.5;">5000</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> }<br></span><span style="line-height:1.5;">finally</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">{<br> Monitor.Exit(m_monitorObject);<br> }<br> }</span></span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　当线程1获取了m_monitorObject对象独占权时，线程2尝试调用TryEnter(m_monitorObject)，此时会由于无法获取独占权而返回false，输出信息如下：<br><img src="https://pic002.cnblogs.com/img/michaelxu/200809/2008091921111423.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　另外，Monitor还提供了三个静态方法Monitor.Pulse(Object o)，Monitor.PulseAll(Object o)和Monitor.Wait(Object o ) ，用来实现一种唤醒机制的同步。关于这三个方法的用法，可以参考MSDN，这里就不详述了。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>五、Mutex</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　在使用上,Mutex与上述的Monitor比较接近，不过Mutex不具备Wait，Pulse，PulseAll的功能，因此，我们不能使用Mutex实现类似的唤醒的功能。不过Mutex有一个比较大的特点，Mutex是跨进程的，因此我们可以在同一台机器甚至远程的机器上的多个进程上使用同一个互斥体。尽管Mutex也可以实现进程内的线程同步，而且功能也更强大，但这种情况下，还是推荐使用Monitor，因为Mutex类是win32封装的，所以它所需要的互操作转换更耗资源。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>六、ReaderWriterLock</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　在考虑资源访问的时候,惯性上我们会对资源实施lock机制,但是在某些情况下,我们仅仅需要读取资源的数据,而不是修改资源的数据,在这种情况下获取资源的独占权无疑会影响运行效率,因此.Net提供了一种机制,使用ReaderWriterLock进行资源访问时,如果在某一时刻资源并没有获取写的独占权,那么可以获得多个读的访问权,单个写入的独占权,如果某一时刻已经获取了写入的独占权,那么其它读取的访问权必须进行等待,参考以下代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <span style="line-height:1.5;"><img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;"><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span><br><span style="line-height:1.5;">private</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;ReaderWriterLock m_readerWriterLock&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">new</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;ReaderWriterLock();<br></span><span style="line-height:1.5;">private</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">int</span><span style="line-height:1.5;">&nbsp;m_int&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">0</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> [STAThread]<br></span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">void</span><span style="line-height:1.5;">&nbsp;Main(</span><span style="line-height:1.5;">string</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">[] args)<br> {<br> Thread readThread&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">new</span><span style="line-height:1.5;">&nbsp;Thread(</span><span style="line-height:1.5;">new</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;ThreadStart(Read));<br> readThread.Name&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">ReadThread1</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> Thread readThread2&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">new</span><span style="line-height:1.5;">&nbsp;Thread(</span><span style="line-height:1.5;">new</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;ThreadStart(Read));<br> readThread2.Name&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">ReadThread2</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> Thread writeThread&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">new</span><span style="line-height:1.5;">&nbsp;Thread(</span><span style="line-height:1.5;">new</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;ThreadStart(Writer));<br> writeThread.Name&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">WriterThread</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">;<br> readThread.Start();<br> readThread2.Start();<br> writeThread.Start();<br> readThread.Join();<br> readThread2.Join();<br> writeThread.Join();<br><br> Console.ReadLine();&nbsp;<br> }<br></span><span style="line-height:1.5;">private</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">void</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;Read()<br> {<br></span><span style="line-height:1.5;">while</span><span style="line-height:1.5;">&nbsp;(</span><span style="line-height:1.5;">true</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">)<br> {<br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">ThreadName&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">+</span><span style="line-height:1.5;">&nbsp;Thread.CurrentThread.Name&nbsp;</span><span style="line-height:1.5;">+</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;AcquireReaderLock</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> m_readerWriterLock.AcquireReaderLock(</span><span style="line-height:1.5;">10000</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> Console.WriteLine(String.Format(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">ThreadName : {0} m_int : {1}</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">, Thread.CurrentThread.Name, m_int));<br> m_readerWriterLock.ReleaseReaderLock();<br> }<br> }<br><br></span><span style="line-height:1.5;">private</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">void</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;Writer()<br> {<br></span><span style="line-height:1.5;">while</span><span style="line-height:1.5;">&nbsp;(</span><span style="line-height:1.5;">true</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">)<br> {<br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">ThreadName&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">+</span><span style="line-height:1.5;">&nbsp;Thread.CurrentThread.Name&nbsp;</span><span style="line-height:1.5;">+</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;AcquireWriterLock</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> m_readerWriterLock.AcquireWriterLock(</span><span style="line-height:1.5;">1000</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> Interlocked.Increment(</span><span style="line-height:1.5;">ref</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;m_int);<br> Thread.Sleep(</span><span style="line-height:1.5;">5000</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> m_readerWriterLock.ReleaseWriterLock();<br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">ThreadName&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">+</span><span style="line-height:1.5;">&nbsp;Thread.CurrentThread.Name&nbsp;</span><span style="line-height:1.5;">+</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;ReleaseWriterLock</span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> }<br> }</span></span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">在程序中,我们启动两个线程获取m_int的读取访问权,使用一个线程获取m_int的写入独占权,执行代码后,输出如下：</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><img src="https://pic002.cnblogs.com/img/michaelxu/200809/2008092003495611.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">可以看到，当WriterThread获取到写入独占权后，任何其它读取的线程都必须等待，直到WriterThread释放掉写入独占权后，才能获取到数据的访问权，应该注意的是，上述打印信息很明显显示出，可以多个线程同时获取数据的读取权，这从ReadThread1和ReadThread2的信息交互输出可以看出。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>七、SynchronizationAttribute</strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　当我们确定某个类的实例在同一时刻只能被一个线程访问时，我们可以直接将类标识成Synchronization的，这样，CLR会自动对这个类实施同步机制,实际上，这里面涉及到同步域的概念，当类按如下设计时，我们可以确保类的实例无法被多个线程同时访问<br> 1).&nbsp;在类的声明中,添加System.Runtime.Remoting.Contexts.SynchronizationAttribute属性。<br> &nbsp;&nbsp;&nbsp;&nbsp;2). 继承至System.ContextBoundObject<br> &nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，要实现上述机制，类必须继承至System.ContextBoundObject，换句话说,类必须是上下文绑定的。<br> &nbsp;&nbsp;&nbsp;&nbsp;一个示范类代码如下：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <span style="line-height:1.5;"><img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;"><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span><br></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">[System.Runtime.Remoting.Contexts.Synchronization]<br></span><span style="line-height:1.5;">public</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">class</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;SynchronizedClass : System.ContextBoundObject<br> {<br><br> }</span></span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">&nbsp;</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　<strong>八、<span class="fixed">MethodImplAttribute</span></strong></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　如果临界区是跨越整个方法的，也就是说，整个方法内部的代码都需要上锁的话，使用MethodImplAttribute属性会更简单一些。这样就不用在方法内部加锁了，只需要在方法上面加上 [MethodImpl(MethodImplOptions.Synchronized)] 就可以了，MehthodImpl和MethodImplOptions都在命名空间System.Runtime.CompilerServices&nbsp;里面。但要注意这个属性会使整个方法加锁，直到方法返回，才释放锁。因此，使用上不太灵活。如果要提前释放锁，则应该使用Monitor或lock。我们来看一个例子：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <span style="line-height:1.5;"><img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;">&nbsp;<span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span>&nbsp;<br></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">[MethodImpl(MethodImplOptions.Synchronized)]<br></span><span style="line-height:1.5;">public</span>&nbsp;<span style="line-height:1.5;">void</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">DoSomeWorkSync()<br> {<br> Console.WriteLine(</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">DoSomeWorkSync() -- Lock held by Thread&nbsp;</span><span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">+</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">Thread.CurrentThread.GetHashCode());<br> Thread.Sleep(</span></span>
    <span style="line-height:1.5;">&nbsp;<span style="line-height:1.5;">1000</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> Console.WriteLine(</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">DoSomeWorkSync() -- Lock released by Thread&nbsp;</span><span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">+</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">Thread.CurrentThread.GetHashCode());<br> }<br></span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">public</span>&nbsp;<span style="line-height:1.5;">void</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">DoSomeWorkNoSync()<br> {<br> Console.WriteLine(</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">DoSomeWorkNoSync() -- Entered Thread is&nbsp;</span><span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">+</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">Thread.CurrentThread.GetHashCode());<br> Thread.Sleep(</span></span>
    <span style="line-height:1.5;">&nbsp;<span style="line-height:1.5;">1000</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> Console.WriteLine(</span>&nbsp;<span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">DoSomeWorkNoSync() -- Leaving Thread is&nbsp;</span><span style="line-height:1.5;">"</span>&nbsp;<span style="line-height:1.5;">+</span>&nbsp;</span>
    <span style="line-height:1.5;"><br><span style="line-height:1.5;">Thread.CurrentThread.GetHashCode());<br> }<br><br> [STAThread]<br></span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">static</span>&nbsp;<span style="line-height:1.5;">void</span>&nbsp;<span style="line-height:1.5;">Main(</span>&nbsp;<span style="line-height:1.5;">string</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">[] args)<br> {<br> MethodImplAttr testObj&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">MethodImplAttr();<br> Thread t1&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">Thread(</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">ThreadStart(testObj.DoSomeWorkNoSync));<br> Thread t2&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">Thread(</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">ThreadStart(testObj.DoSomeWorkNoSync));<br> t1.Start();<br> t2.Start();<br> Thread t3&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">Thread(</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">ThreadStart(testObj.DoSomeWorkSync));<br> Thread t4&nbsp;</span><span style="line-height:1.5;">=</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;<span style="line-height:1.5;">Thread(</span>&nbsp;<span style="line-height:1.5;">new</span>&nbsp;</span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">ThreadStart(testObj.DoSomeWorkSync));<br> t3.Start();<br> t4.Start();<br><br> Console.ReadLine();&nbsp;<br> }</span></span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">这里，我们有两个方法，我们可以对比一下，一个是加了属性MethodImpl的DoSomeWorkSync()，一个是没加的DoSomeWorkNoSync()。在方法中Sleep(1000)是为了在第一个线程还在方法中时，第二个线程能够有足够的时间进来。对每个方法分别起了两个线程，我们先来看一下结果：</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><img src="https://pic002.cnblogs.com/img/michaelxu/200809/2008091921453276.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">可以看出，对于线程１和２，也就是调用没有加属性的方法的线程，当线程２进入方法后，还没有离开，线程１有进来了，这就是说，方法没有同步。我们再来看看线程３和４，当线程３进来后，方法被锁，直到线程３释放了锁以后，线程４才进来。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><span class="fixed">　　<strong>九、同步事件和等待句柄</strong></span></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　用lock和Monitor可以很好地起到线程同步的作用，但它们无法实现线程之间传递事件。如果要实现线程同步的同时，线程之间还要有交互，就要用到同步事件。同步事件是有两个状态（终止和非终止）的对象，它可以用来激活和挂起线程。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　同步事件有两种：AutoResetEvent和&nbsp;ManualResetEvent。它们之间唯一不同的地方就是在激活线程之后，状态是否自动由终止变为非终止。AutoResetEvent自动变为非终止，就是说一个AutoResetEvent只能激活一个线程。而ManualResetEvent要等到它的Reset方法被调用，状态才变为非终止，在这之前，ManualResetEvent可以激活任意多个线程。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　可以调用WaitOne、WaitAny或WaitAll来使线程等待事件。它们之间的区别可以查看MSDN。当调用事件的&nbsp;Set方法时，事件将变为终止状态，等待的线程被唤醒。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">　　来看一个例子，这个例子是MSDN上的。因为事件只用于一个线程的激活，所以使用&nbsp;<strong>AutoResetEvent</strong>&nbsp;或&nbsp;<strong>ManualResetEvent</strong>&nbsp;类都可以。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:12px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <span style="line-height:1.5;"><img src="https://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif" alt="" width="11" height="16" align="top" style="border:0px;"><span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span><br><span style="line-height:1.5;">static</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;AutoResetEvent autoEvent;<br><br></span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">void</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;DoWork()<br> {<br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;worker thread started, now waiting on event<img src="https://images.cnblogs.com/dot.gif" alt="" style="border:0px;"></span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> autoEvent.WaitOne();<br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">&nbsp;worker thread reactivated, now exiting<img src="https://images.cnblogs.com/dot.gif" alt="" style="border:0px;"></span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> }<br><br> [STAThread]<br></span><span style="line-height:1.5;">static</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">void</span><span style="line-height:1.5;">&nbsp;Main(</span><span style="line-height:1.5;">string</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">[] args)<br> {<br> autoEvent&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">new</span><span style="line-height:1.5;">&nbsp;AutoResetEvent(</span><span style="line-height:1.5;">false</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br><br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">main thread starting worker thread<img src="https://images.cnblogs.com/dot.gif" alt="" style="border:0px;"></span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> Thread t&nbsp;</span><span style="line-height:1.5;">=</span><span style="line-height:1.5;">&nbsp;</span><span style="line-height:1.5;">new</span><span style="line-height:1.5;">&nbsp;Thread(</span><span style="line-height:1.5;">new</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp;ThreadStart(DoWork));<br> t.Start();<br><br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">main thrad sleeping for 1 second<img src="https://images.cnblogs.com/dot.gif" alt="" style="border:0px;"></span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> Thread.Sleep(</span><span style="line-height:1.5;">1000</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br><br> Console.WriteLine(</span><span style="line-height:1.5;">"</span><span style="line-height:1.5;">main thread signaling worker thread<img src="https://images.cnblogs.com/dot.gif" alt="" style="border:0px;"></span><span style="line-height:1.5;">"</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">);<br> autoEvent.Set();<br><br> Console.ReadLine();&nbsp;<br> }</span></span>
    <pre></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;border:none;">复制代码</a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(29,88,209);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">我们先来看一下输出：</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><img src="https://pic002.cnblogs.com/img/michaelxu/200809/2008092004141838.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">在主函数中，首先创建一个AutoResetEvent的实例，参数false表示初始状态为非终止，如果是true的话，初始状态则为终止。然后创建并启动一个子线程，在子线程中，通过调用AutoResetEvent的WaitOne方法，使子线程等待指定事件的发生。然后主线程等待一秒后，调用AutoResetEvent的Ｓｅｔ方法，使状态由非终止变为终止，重新激活子线程。</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">参考：</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">1/MSDN(<a href="http://msdn.microsoft.com/zh-cn/library/ms173179(VS.80).aspx" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;">http://msdn.microsoft.com/zh-cn/library/ms173179(VS.80).aspx</a>&nbsp;)</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;">2/http://www.cnblogs.com/VincentWP/archive/2008/06/25/1229104.html</p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><a href="http://www.cnblogs.com/michaelxu/archive/2008/09/20/1293716.html" rel="nofollow" style="color:rgb(29,88,209);text-decoration:none;">原文地址</a></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
   <p style="font-family:Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
   <p><font><span style="font-size:12px;">本文转自Work Hard Work Smart博客园博客，原文链接：http://www.cnblogs.com/linlf03/archive/2012/02/17/2356400.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
