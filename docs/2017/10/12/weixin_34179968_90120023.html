<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>反射-获取信息详细（转） « NotBeCN</title>
  <meta name="description" content="                 摘 要            反射，一个很有用且有意思的特性。当动态创建某个类型的实例或是调用方法或是访问对象成员时通常会用到它，它是基于程序集及元数据而工作的，所以这一章我们来讨论一下程序集、反射如何工作、如何动态创建类型及对象等相关知识，甚至可以动态创建程序集。       ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/12/weixin_34179968_90120023.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">反射-获取信息详细（转）</h1>
    <p class="post-meta">Oct 12, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="titlediv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="line-height:1.8;">摘 要</span>
   </div> 
   <div class="blockdiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p>反射，一个很有用且有意思的特性。当动态创建某个类型的实例或是调用方法或是访问对象成员时通常会用到它，它是基于程序集及元数据而工作的，所以这一章我们来讨论一下程序集、反射如何工作、如何动态创建类型及对象等相关知识，甚至可以动态创建程序集。</p> 
   </div> 
   <div class="blockdiv"> 
    <div class="sectiondiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <span style="line-height:1.8;">第一节 应用程序域与程序集</span>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">通过本系列的前面章节，我们已经知道，Windows为每个进程分配独立的内存空间地址，各个进程之间不能直接相互访问。Windows对.NET的支持是以宿主和COM的形式实现的，基于.NET平台语言实现的代码文件使用Windows PE的文件格式，CLR其实就是COM，相当于一个虚拟机（当然这个虚拟机可以部署到任意支持它的系统环境中），在安装.NET Framework时，CLR的组件与其他COM一样在Windows系统中享有同等的待遇，当CLR启动初始化时会创建一个应用程序域，应用程序域是一组程序集的逻辑容器，它会随着进程的终止而被卸载销毁，CLR把程序代码所需要的程序集加载到当前（或指定的）应用程序域内。CLR可以以其初始化时创建的应用程序域为基础再创建其他的新应用程序域，两个应用程序域中的代码不能直接访问，当然可以通过“中介”进行数据传送。新的程序域创建完后CLR完全可以卸载它，以同步方式调用AppDomain.Unload方法即可，调用此方法后，CLR会挂起当前进程中的所有线程，接着查找并中止运行在即将卸载的程序域内的线程，然后进行垃圾回收，最后主线程恢复运行。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">任何Windows程序都可以寄宿CLR，一台机上可以安装多个版本的CLR。Windows在启动一个托管的程序时会先启动MSCorEE.dll中的一个方法，该方法在内部根据一个托管的可执行文件信息来加载相应版本的CLR，CLR初始完成之后，将程序集加载到应用程序域，最后CLR检查程序集的CLR头信息找到Main方法并执行它。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <div class="sectiondiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <span style="line-height:1.8;">第二节 加载程序集</span>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">程序集是所有类型的集合，它还有一个重要的东西就是元数据。JIT就是利用程序集的TypeRef和AssemblyRef等元数据来确定所引用的程序集及类型，这些元数据包括名称、版本、语言文化和公钥标记等，JIT就是根据这些信息来加载一个程序集到应用程序域中。如果要自己加载一个程序集，可以调用类型Assembly的LoadXXX系列方法。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（1） Load重载系列</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">该方法会按照一定的顺序查找指定目录中的程序集：先去GAC中查找（如果是一个强命名程序集），如果找不到，则去应用程序的基目录、子目录查找。如果都没找到，则抛出异常。如下代码加载程序集MyAssemblyB：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>            <span style="line-height:1.8;">string</span> assemblyName = <span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">;
            Assembly assembly </span>= Assembly.Load(assemblyName);</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（2） LoadFrom重载系列</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">加载指定程序集名称或路径的程序集，其在内部调用Load方法，并且还可以指定一个网络路径，如果指定网络路径，则先下载该程序集，再将其加载到程序域，如下代码：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>Assembly.LoadFrom(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">http://solan.cnblogs.com/MyAssembly.dll</span><span style="line-height:1.8;">"</span>);</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（3） LoadFile重载系列</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">从任意路径加载一个程序集，并且可以从不同路径加载相同名称的程序集。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在一个项目中，可能程序集之间都有依赖关系，也可以将一个程序集作为资源数据嵌入到一个程序集中，在需要时再加载该程序集，这时通过注册ResolveAssembly事件来加载这个程序集。如下;</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>            AppDomain.CurrentDomain.AssemblyResolve += (sender, arg) =&gt;<span style="line-height:1.8;">
            {
                </span><span style="line-height:1.8;">byte</span>[] buffer = <span style="line-height:1.8;">null</span><span style="line-height:1.8;">;
                </span><span style="line-height:1.8;">using</span> (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">ConsoleApp.MyAssemblyA.dll</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">))
                {
                    buffer </span>= <span style="line-height:1.8;">new</span> <span style="line-height:1.8;">byte</span><span style="line-height:1.8;">[stream.Length];
                    stream.Read(buffer, </span><span style="line-height:1.8;">0</span><span style="line-height:1.8;">, buffer.Length);
                }
                </span><span style="line-height:1.8;">return</span><span style="line-height:1.8;"> Assembly.Load(buffer);
            };</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">以上代码要求必须先将MyAssemblyA.dll文件以资源形式嵌入到ConsoleApp项目中。这样在运行ConsoleApp程序时，如果使用了MyAssemblyA中的类型且未找到MyAssemblyA.dll文件，则会进入上面的事件方法来加载程序集MyAssemblyA。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果只是想了解一个程序集的元数据分析其类型而不调用类型的成员，为了提高性能，可以调用这些方法：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre><span style="line-height:1.8;">Assembly.ReflectionOnlyLoadFrom(String assemblyFile)
Assembly.ReflectionOnlyLoad(</span><span style="line-height:1.8;">byte</span><span style="line-height:1.8;">[] rawAssembly)
Assembly.ReflectionOnlyLoad(String assemblyName)</span></pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果试图调用上面这三个方法加载的程序集中类型的代码，则CLR会抛出异常。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <div class="sectiondiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <span style="line-height:1.8;">第三节 反射</span>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">我们知道，在程序集（或模块）内有一个很重要的数据就是元数据，它们描述了类型定义表，字段定义表，方法表等，也就是说所有的类型及成员定义项都会在这里被清楚详细地记录下来。很明显，如果我们拿到了这些“描述信息”，当然就相当于已经明确知道了一个类型及其成员，进而就可以“构造”这个类型，通过反射就可以达到这样的目的。另人高兴的是我们不用分析那些元数据就可以方便地得到程序集内的类型成员，.NET Framework提供了一些与此相关的类定义在命名空间System.Reflection下。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">反射提供了封装程序集、模块和类型的对象（Type 类型）。反射机制运行在程序运行时动态发现类型及其成员。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（1）查找程序集内所定义的类型</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在将某一程序集加载到应用程序域后，可以通过Assembly的GetExportedTypes方法来获取该程序集所有的公开类型，如下代码：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>        <span style="line-height:1.8;">private</span> <span style="line-height:1.8;">void</span><span style="line-height:1.8;"> GetTypes()
        {
            </span><span style="line-height:1.8;">string</span> assemblyName = <span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">;
            Assembly assembly </span>=<span style="line-height:1.8;"> Assembly.Load(assemblyName);
            Type[] types </span>=<span style="line-height:1.8;"> assembly.GetExportedTypes();
            </span><span style="line-height:1.8;">foreach</span> (Type t <span style="line-height:1.8;">in</span><span style="line-height:1.8;"> types)
            {
                Console.WriteLine(t.Name);
            }
        }</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（2）查找类型成员</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在命名空间System.Reflection中有一个抽象类型MemberInfo，它封装了与类型成员相关的通用属性，每一个类型成员都有一个对应的从MemberInfo派生而来的类型，并且内置了一些特殊的属性特征，如FieldInfo、MethodBase(ContructorInfo、MethodInfo)、PropertyInfo和EventInfo。可以通过调用类型Type对象的GetMembers方法获取该类型的所有成员或相应成员，如下代码（对上面的GetTypes方法的修改）获取全部成员列表：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>            Type[] types =<span style="line-height:1.8;"> assembly.GetExportedTypes();
            </span><span style="line-height:1.8;">foreach</span> (Type t <span style="line-height:1.8;">in</span><span style="line-height:1.8;"> types)
            {
                Console.WriteLine(t.Name);
                MemberInfo[] members </span>=<span style="line-height:1.8;"> t.GetMembers();
            }</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">Type有一组GetXXX方法是获取对象成员的，以下列出部分方法：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>GetConstructor/GetConstructors <span style="line-height:1.8;">//</span><span style="line-height:1.8;">获取构造函数</span>
GetEvent/GetEvents <span style="line-height:1.8;">//</span><span style="line-height:1.8;">获取事件</span>
GetField/GetFields <span style="line-height:1.8;">//</span><span style="line-height:1.8;">获取字段</span>
GetMethod/GetMethods <span style="line-height:1.8;">//</span><span style="line-height:1.8;">获取方法</span>
GetProperty/GetProperties <span style="line-height:1.8;">//</span><span style="line-height:1.8;">获取属性</span></pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">并且每个方法都可以接收一个枚举类型BindingFlags的参数指定控制绑定和由反射执行的成员和类型搜索方法的标志。有关BindingFlags 枚举可参考<a href="http://msdn.microsoft.com/zh-cn/library/system.reflection.bindingflags(VS.100).aspx%E3%80%82" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">MSDN文档</a></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如下代码获取AudiCar类型的Owner属性和Run()方法：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>        <span style="line-height:1.8;">private</span> <span style="line-height:1.8;">void</span><span style="line-height:1.8;"> GetTypeMethod()
        {
            </span><span style="line-height:1.8;">string</span> assemblyName = <span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">;
            Assembly assembly </span>=<span style="line-height:1.8;"> Assembly.Load(assemblyName);
            Type t </span>= assembly.GetType(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB.AudiCar</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            MethodInfo method </span>= t.GetMethod(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">Run</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            PropertyInfo pro </span>= t.GetProperty(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">Owner</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
        }</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（3）构造类型实例</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在拿到类型及成员信息之后，我们就可以构造类型的实例对象了。FCL提供了几个方法来构造一个类型的实例对象，有关这些方法详细内容，可参考MSDN文档：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>Activator.CreateInstance() <span style="line-height:1.8;">//</span><span style="line-height:1.8;">重载系列</span>
Activator.CreateInstanceFrom() <span style="line-height:1.8;">//</span><span style="line-height:1.8;">重载系列</span>
AppDomain.CurrentDomain.CreateInstance() <span style="line-height:1.8;">//</span><span style="line-height:1.8;">重载系列</span>
AppDomain.CurrentDomain.CreateInstanceFrom() <span style="line-height:1.8;">//</span><span style="line-height:1.8;">重载系列</span></pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如下构造AudiCar类型的实例：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>        <span style="line-height:1.8;">private</span> <span style="line-height:1.8;">void</span><span style="line-height:1.8;"> TestCreateInstance()
        {
            </span><span style="line-height:1.8;">string</span> assemblyName = <span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">;
            Assembly assembly </span>=<span style="line-height:1.8;"> Assembly.Load(assemblyName);
            Type t </span>= assembly.GetType(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB.AudiCar</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            </span><span style="line-height:1.8;">var</span> obj =<span style="line-height:1.8;"> Activator.CreateInstance(t);
            Debug.Assert(obj </span>!= <span style="line-height:1.8;">null</span><span style="line-height:1.8;">);
        }</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">看一下调试：</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img class="img" src="https://pic002.cnblogs.com/images/2012/48455/2012090315161919.jpg" alt="" style="border:0px;"></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">另外，还可以调用类型的构造函数创建实例对象，如下：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>obj = t.InvokeMember(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">AudiCar</span><span style="line-height:1.8;">"</span>, BindingFlags.CreateInstance, <span style="line-height:1.8;">null</span>, <span style="line-height:1.8;">null</span>, <span style="line-height:1.8;">null</span>);</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <div class="sectiondiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <span style="line-height:1.8;">第四节 通过反射访问对象成员</span>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果仅仅得到类型的对象，好像意义并不大，我们更多的是要操作对象，比如访问属性，调用方法等，这一节我们来看一下如何访问成员。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">类型Type提供了一个访问目标类型成员的非常靠谱的方法InvokeMember，调用此方法时，它会在类型成员中找到目标成员（这通常指定成员名称，也可以指定搜索筛选条件BindingFlags，如果调用的目标成员是方法，还可以给方法传递参数。），如果找到则调用目标方法，并返回目标访问返回的结果，如果未找到，则抛出异常，如果是在目标方法内部有异常，则InvokeMember会先捕获该异常，包装后再抛出新的异常TargetInvocationException。以下是InvokeMember方法的原型：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;">public</span> <span style="line-height:1.8;">object</span> InvokeMember(<span style="line-height:1.8;">string</span> name, BindingFlags invokeAttr, Binder binder, <span style="line-height:1.8;">object</span> target, <span style="line-height:1.8;">object</span><span style="line-height:1.8;">[] args);
</span><span style="line-height:1.8;">public</span> <span style="line-height:1.8;">object</span> InvokeMember(<span style="line-height:1.8;">string</span> name, BindingFlags invokeAttr, Binder binder, <span style="line-height:1.8;">object</span> target, <span style="line-height:1.8;">object</span><span style="line-height:1.8;">[] args,
 CultureInfo culture);
</span><span style="line-height:1.8;">public</span> <span style="line-height:1.8;">abstract</span> <span style="line-height:1.8;">object</span> InvokeMember(<span style="line-height:1.8;">string</span> name, BindingFlags invokeAttr, Binder binder, <span style="line-height:1.8;">object</span><span style="line-height:1.8;"> target,
 </span><span style="line-height:1.8;">object</span>[] args, ParameterModifier[] modifiers, CultureInfo culture, <span style="line-height:1.8;">string</span><span style="line-height:1.8;">[] namedParameters);
name 目标方法名称
invokeAttr 查找成员筛选器
binder 规定了匹配成员和实参的规则
target 要调用其成员的对象
args 传递给目标方法的参数</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在上一节的最后我们展示了如何调用类型的构造函数来实例化一个对象，下面的代码演示了如何调用对象的方法，其中方法Turn接收一个Direction类型的参数：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>            <span style="line-height:1.8;">string</span> assemblyName = <span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">;
            Assembly assembly </span>=<span style="line-height:1.8;"> Assembly.Load(assemblyName);
            Type t </span>= assembly.GetType(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB.AudiCar</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            </span><span style="line-height:1.8;">var</span> obj =<span style="line-height:1.8;"> Activator.CreateInstance(t);
            t.InvokeMember(</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">Turn</span><span style="line-height:1.8;">"</span>, BindingFlags.InvokeMethod, <span style="line-height:1.8;">null</span>, obj, <span style="line-height:1.8;">new</span> <span style="line-height:1.8;">object</span>[] { Direction.East });</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">另外，调用目标对象的方法，还可以以MethodInfo的方式进行，如下：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>            Type t = assembly.GetType(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB.AudiCar</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            </span><span style="line-height:1.8;">var</span> obj =<span style="line-height:1.8;"> Activator.CreateInstance(t);
            MethodInfo method </span>= t.GetMethod(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">Turn</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            method.Invoke(obj, </span><span style="line-height:1.8;">new</span> <span style="line-height:1.8;">object</span>[] { Direction.Weast });</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">以下是对属性的读写操作：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>            Type t = assembly.GetType(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB.AudiCar</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            </span><span style="line-height:1.8;">var</span> obj =<span style="line-height:1.8;"> Activator.CreateInstance(t);
            </span><span style="line-height:1.8;">//</span><span style="line-height:1.8;">为属性Owner赋值</span>
            obj.GetType().GetProperty(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">Owner</span><span style="line-height:1.8;">"</span>).SetValue(obj, <span style="line-height:1.8;">"</span><span style="line-height:1.8;">张三</span><span style="line-height:1.8;">"</span>, <span style="line-height:1.8;">null</span><span style="line-height:1.8;">);
            </span><span style="line-height:1.8;">//</span><span style="line-height:1.8;">读取属性Owner的值</span>
            <span style="line-height:1.8;">string</span> name = (<span style="line-height:1.8;">string</span>)obj.GetType().GetProperty(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">Owner</span><span style="line-height:1.8;">"</span>).GetValue(obj, <span style="line-height:1.8;">null</span>);</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">对于其他成员（如字段等）的访问，可参考MSDN文档。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span class="spanKeyword" style="line-height:1.8;">反射对泛型的支持</span></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">以上的演示都是针对普通类型，其实反射也提供了对泛型的支持，这里只简单演示一下反射对泛型的简单操作。比如我们有如下一个泛型类型定义：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre><span style="line-height:1.8;">namespace</span><span style="line-height:1.8;"> MyAssemblyB
{
    </span><span style="line-height:1.8;">public</span> <span style="line-height:1.8;">class</span> MyGeneric&lt;T&gt;<span style="line-height:1.8;">
    {
        </span><span style="line-height:1.8;">public</span> <span style="line-height:1.8;">string</span> GetName&lt;T&gt;<span style="line-height:1.8;">(T name)
        {
            </span><span style="line-height:1.8;">return</span> <span style="line-height:1.8;">"</span><span style="line-height:1.8;">Generic Name：</span><span style="line-height:1.8;">"</span> +<span style="line-height:1.8;"> name.ToString();
        }
    }
}</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这个类型很简单，类型MyGeneric内有一个方法，该方法返回带有附加信息” Generic Name：”的名称。先来看一下如何获取指定参数类型为string的泛型类：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>        <span style="line-height:1.8;">private</span> <span style="line-height:1.8;">void</span><span style="line-height:1.8;"> TestGenericType()
        {
            </span><span style="line-height:1.8;">string</span> assemblyName = <span style="line-height:1.8;">"</span><span style="line-height:1.8;">MyAssemblyB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">;
            Assembly assembly </span>=<span style="line-height:1.8;"> Assembly.Load(assemblyName);
            Type[] types </span>=<span style="line-height:1.8;"> assembly.GetExportedTypes();
            </span><span style="line-height:1.8;">foreach</span> (Type t <span style="line-height:1.8;">in</span><span style="line-height:1.8;"> types)
            {
                </span><span style="line-height:1.8;">//</span><span style="line-height:1.8;">检测是否泛型（在程序集MyAssemblyB中只定义了一个泛型类型 MyGeneric&lt;T&gt;）</span>
                <span style="line-height:1.8;">if</span><span style="line-height:1.8;"> (t.IsGenericType)
                {
                    </span><span style="line-height:1.8;">//</span><span style="line-height:1.8;">为泛型类型参数指定System.String类型，并创建实例</span>
                    <span style="line-height:1.8;">object</span> obj = Activator.CreateInstance(t.MakeGenericType(<span style="line-height:1.8;">new</span> Type[] { <span style="line-height:1.8;">typeof</span><span style="line-height:1.8;">(System.String) }));
                    </span><span style="line-height:1.8;">//</span><span style="line-height:1.8;">生成泛型方法</span>
                    MethodInfo m = obj.GetType().GetMethod(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">GetName</span><span style="line-height:1.8;">"</span>).MakeGenericMethod(<span style="line-height:1.8;">new</span> Type[] { <span style="line-height:1.8;">typeof</span><span style="line-height:1.8;">(System.String) });
                    </span><span style="line-height:1.8;">//</span><span style="line-height:1.8;">调用泛型方法</span>
                    <span style="line-height:1.8;">var</span> value = m.Invoke(obj, <span style="line-height:1.8;">new</span> <span style="line-height:1.8;">object</span>[] { <span style="line-height:1.8;">"</span><span style="line-height:1.8;">a</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;"> });
                    Console.WriteLine(value);
                }
            }
        }</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">调试起来，看一下最终的value值：</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img class="img" src="https://pic002.cnblogs.com/images/2012/48455/2012090409344817.jpg" alt="" style="border:0px;"></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">反射泛型的时候，要先确定目标类型是泛型，在创建泛型类型实例前，必须调用MakeGenericType方法构造一个真正的泛型，该方法接收一个要指定泛型类型参数的类型数组，同样调用泛型方法前要调用方法MakeGenericMethod构造相应的泛型方法，此方法也接收一个指定泛型类型的类型数组。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <div class="sectiondiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <span style="line-height:1.8;">第五节 动态创建类型</span>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">前面几节所描述的都是基于已经存在程序集的情况下进行反射，.NET Framework还提供了在内存中动态创建类型的强大功能。我们知道程序集包括模块，模块包括类型，类型包括成员，在动态创建类型的时候也是要遵循这个顺序。动态创建类型是基于元数据的实现方式来实现的，这一部分被定义在命名空间System.Reflection.Emit内，有一系列的XXXBuilder构造器来创建相应的类型对象。我们来看一要动态创建类型，有哪些步骤（这里只是简单演示）：</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（1） 程序集是老窝，所以要先创建一个程序集：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>AssemblyBuilder aBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(<span style="line-height:1.8;">new</span> AssemblyName(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">TempDynamicAssembly</span><span style="line-height:1.8;">"</span>), AssemblyBuilderAccess.Run);</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（2） 有了程序集，接下来是模块</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>ModuleBuilder mBuilder = aBuilder.DefineDynamicModule(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">NotifyPropertyChangedObject</span><span style="line-height:1.8;">"</span>);</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（3） 接下来就是创建类型了：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre><span style="line-height:1.8;">this</span>.tBuilder = mBuilder.DefineType(typeFullName, TypeAttributes.Public | TypeAttributes.BeforeFieldInit);</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（4） 现在可以创建类型的成员了，为类型创建一个属性Name。我们知道属性包含字段和对字段的两个访问器，所以应该先创建字段，然后再创建两个访问器方法，这一段是按照IL码的先后顺序来的，如下：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>            FieldBuilder fieldBuilder = <span style="line-height:1.8;">this</span>.tBuilder.DefineField(<span style="line-height:1.8;">string</span>.Format(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">{0}Field</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">, propertyName), propertyType, FieldAttributes.Private);
            PropertyBuilder propertyBuilder </span>= tBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span style="line-height:1.8;">null</span><span style="line-height:1.8;">);
            MethodAttributes getSetAttr </span>= MethodAttributes.Public | MethodAttributes.SpecialName |<span style="line-height:1.8;"> MethodAttributes.HideBySig;
            MethodBuilder getAccessor </span>= tBuilder.DefineMethod(<span style="line-height:1.8;">string</span>.Format(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">get_{0}</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">, propertyName), getSetAttr, propertyType, Type.EmptyTypes);
            ILGenerator getIL </span>=<span style="line-height:1.8;"> getAccessor.GetILGenerator();
            getIL.Emit(OpCodes.Ldarg_0);
            getIL.Emit(OpCodes.Ldfld, fieldBuilder);
            getIL.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getAccessor);

            MethodBuilder setAccessor </span>= tBuilder.DefineMethod(<span style="line-height:1.8;">string</span>.Format(<span style="line-height:1.8;">"</span><span style="line-height:1.8;">set_{0}</span><span style="line-height:1.8;">"</span>, propertyName), getSetAttr, <span style="line-height:1.8;">null</span>, <span style="line-height:1.8;">new</span><span style="line-height:1.8;"> Type[] { propertyType });
            setAccessor.DefineParameter(</span><span style="line-height:1.8;">1</span>, ParameterAttributes.None, <span style="line-height:1.8;">"</span><span style="line-height:1.8;">value</span><span style="line-height:1.8;">"</span><span style="line-height:1.8;">);
            ILGenerator setIL </span>=<span style="line-height:1.8;"> setAccessor.GetILGenerator();
            setIL.Emit(OpCodes.Nop);
            setIL.Emit(OpCodes.Ldarg_0);
            setIL.Emit(OpCodes.Ldarg_1);
            setIL.Emit(OpCodes.Stfld, fieldBuilder);
            setIL.Emit(OpCodes.Ldarg_0);
            setIL.Emit(OpCodes.Ldstr, propertyName);
            setIL.Emit(OpCodes.Call, </span><span style="line-height:1.8;">this</span><span style="line-height:1.8;">.mBuilder);
            setIL.Emit(OpCodes.Nop);
            setIL.Emit(OpCodes.Ret);
            propertyBuilder.SetSetMethod(setAccessor);</span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border:none;"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.8;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">注意，这里面有对事件的操作，可以忽略。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（5） 最后调用类型构造器的CreateType()方法就可以创建该类型了：</p> 
    <div class="cnblogs_code" style="color:rgb(0,0,0);font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);">
     <pre>tBuilder.CreateType();</pre>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">该方法返回一个Type类型。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">类型创建完成后，我们就可以使用上一节讲的反射相关知识对该类型进行操作了，这里当然是一个简单的类型，如果想创建复杂的类型，比如有方法，事件等成员，那可以发挥你的汇编能力来慢慢折腾吧，也可以体味一下当时汇编程序员们的苦逼！托管下的汇编编码已经很简化了，围绕Emit方法折腾死！如果想研究IL,可以用IL DASM打开托管程序集，慢慢欣赏吧。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在我们的日常开发中，有时用了动态类型还是很方便的，比如当你要创建一个DataGrid的数据源DataTable，但多少列不确定，列的数据类型不确定，列名也不确定的情况下，这时根据要求创建一个动态类型，继而再创建一个该类型的集合就很方便使用了。我封装了一个动态创建类型的类，在本文的结尾提供下载，喜欢的可以拿去。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这里所描述的是动态地在内存创建一个类，关于动态类型dynamic和var，这里就不再瞎掰了，感兴趣的可以去查找相关资料。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <div class="sectiondiv" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
     <span style="line-height:1.8;">第六节 应用反射时要注意的几点</span>
    </div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">反射为我们开发提供了非常便利的编程实践，但使用它也有几点需要注意。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">既然是反射，我们在编码时对类型是未知的，如果是已知，就没必要再用反射了， 除非是要做类似分析类型元数据的工具，而我们一般使用反射是要操作其属性字段、调用其方法等，目的是用而不是分析。在编译使用了反射的代码过程中，反射的目标类型是不安全的，很有可能在调用反射出来的类对象时出错，这一点要注意。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">反射是基于元数据实现的，所以在使用反射过程中，代码会搜索程序集的元数据，这些元数据是基于字符串的，并且无法预编译，所以这一系列的操作对性能有严重影响。另外，由于我们对目标类型未知，在向方法传递参数时通常是以object数组传递，CLR会逐个检查参数的数据类型，无论是传入还是返回，都有可能进行大量的类型转换，这也损伤了性能。所以对于反射的应用，应该注意。当然，像一些ORM等框架是以牺牲性能来换取方便的开发体验就另当别说了。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">转自：<a href="http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.cnblogs.com/solan/archive/2012/09/04/CSharp15.html</a></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
    <p><font color="#333333"><span style="font-size:14px;">本文转自武沛齐博客园博客，原文链接：http://www.cnblogs.com/wupeiqi/archive/2013/03/10/2953228.html，如需转载请自行联系原作者</span></font><br></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
