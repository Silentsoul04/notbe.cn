<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>短路径算法-Dijkstra算法的应用之单词转换(词梯问题) « NotBeCN</title>
  <meta name="description" content="             一，问题描述    在英文单词表中，有一些单词非常相似，它们可以通过只变换一个字符而得到另一个单词。比如：hive--&gt;five；wine--&gt;line；line--&gt;nine；nine--&gt;mine.....    那么，就存在这样一个问题：给定一个单词作为起始...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/10/18/weixin_33827965_90136231.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">短路径算法-Dijkstra算法的应用之单词转换(词梯问题)</h1>
    <p class="post-meta">Oct 18, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>一，问题描述</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在英文单词表中，有一些单词非常相似，它们可以通过只变换一个字符而得到另一个单词。比如：hive--&gt;five；wine--&gt;line；line--&gt;nine；nine--&gt;mine.....</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">那么，就存在这样一个问题：给定一个单词作为起始单词(相当于图的源点)，给定另一个单词作为终点，求从起点单词经过的最少变换(每次变换只会变换一个字符)，变成终点单词。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">这个问题，其实就是最短路径问题。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">由于最短路径问题中，求解源点到终点的最短路径与求解源点到图中所有顶点的最短路径复杂度差不多，故求解两个单词之间的最短路径相当于求解源点单词到所有单词之间的最短路径。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">给定所有的英文单词，大约有89000个，我们需要找出通过单个字母的替换可以变成至少15个其他单词的单词？程序如何实现？</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">给定两个单词，一个作为源点，另一个作为终点，需要找出从源点开始，经过最少次单个字母替换，变成终点单词，这条变换路径中经过了哪些单词？</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">比如：(zero--&gt;five)：（zero--&gt;hero--&gt;here--&gt;hire--&gt;five）</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>二，算法分析</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设所有的单词存储在一个txt文件中，每行一个单词。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">现在的问题主要有两个：①从文件中读取单词，并构造一个图；②图的最短路径算法--Dijkstra算法实现。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">由于单词A替换一个字符变成单词B，那么反过来单词B替换一个字符也可以变成单词A（自反性）【wine--&gt;fine； fine--&gt;wine】。故图是一个无向图。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>构造图的算法分析：</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">现在更进一步，假设单词已经读取到一个List&lt;String&gt;中，图采用邻接表形式存储，<a href="http://www.cnblogs.com/hapjin/p/4766823.html" rel="nofollow" style="color:#000000;">构造图其实就是</a>：如何根据List&lt;String&gt; 构造一个Map&lt;String,List&lt;String&gt;&gt;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">其中Map中的Key是某个单词，Value则是该单词的“邻接单词”列表，邻接单词即：该单词经过一个字符的替换变成另一个单词。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如：wine的邻接单词有：fine、line、nine.....</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">一个最直接的想法就是：</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">由于单词都在List&lt;String&gt;中存储，那么从第1个单词开始，依次扫描第2个至第N个单词，判断第1个单词是否与第 2,3,.....N个单词只差一个字符。这样一遍扫描，找出了List&lt;String&gt;中第1个单词的邻接表。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">继续，对于第2个单词，依次扫描第3,4,....N个单词，找出List&lt;String&gt;中第2个单词的邻接表。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">.......</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">上述过程可描述成如下循环：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre>    <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; N; i++<span style="line-height:1.5;">)
        </span><span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> j = i+1; j &lt; N; j++)<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">N 表示单词表中所有单词个数<br>
//do something....<br></span></pre>
   </div> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">显然，上述构造图的算法的时间复杂度为O(N^2)。具体代码如下：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,128);line-height:1.5;"> 1</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> Map&lt;String, List&lt;String&gt;&gt; computeAdjacentWords2(List&lt;String&gt;<span style="line-height:1.5;"> theWords){
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 2</span>         Map&lt;String, List&lt;String&gt;&gt; adjWords = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> TreeMap&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 3</span>         String[] words = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> String[theWords.size()];
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 4</span>         words =<span style="line-height:1.5;"> theWords.toArray(words);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 5</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 6</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; words.length; i++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 7</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> j = i+1; j &lt; words.length; j++<span style="line-height:1.5;">)//在整个单词表中的所有单词之间进行比较
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 8</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;">(oneCharOff(words[i], words[j]))
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 9</span> <span style="line-height:1.5;">                {
</span><span style="color:rgb(0,128,128);line-height:1.5;">10</span>                     update(adjWords, words[i], words[j]);<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">无向图,i--j</span>
<span style="color:rgb(0,128,128);line-height:1.5;">11</span>                     update(adjWords, words[j], words[i]);<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">j--i</span>
<span style="color:rgb(0,128,128);line-height:1.5;">12</span> <span style="line-height:1.5;">                }
</span><span style="color:rgb(0,128,128);line-height:1.5;">13</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> adjWords;
</span><span style="color:rgb(0,128,128);line-height:1.5;">14</span>     }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">注意第4行，它将List转换成了数组，这样可以提高程序的执行效率。因为，若不转换成数组，在随后的第6、7行for循环中，在执行时泛型擦除，将频繁向下转型（Object转型成String）</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">另外两个工具方法如下：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">判断两个单词 只替换一个字符变成另一单词</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">private</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">boolean</span><span style="line-height:1.5;"> oneCharOff(String word1, String word2) {
        </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (word1.length() != word2.length())<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">单词长度不相等,肯定不符合条件. </span>
            <span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);line-height:1.5;">int</span> diffs = 0<span style="line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; word1.length(); i++<span style="line-height:1.5;">)
            </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (word1.charAt(i) !=<span style="line-height:1.5;"> word2.charAt(i))
                </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (++diffs &gt; 1<span style="line-height:1.5;">)
                    </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span> diffs == 1<span style="line-height:1.5;">;
    }

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">将单词添加到邻接表中</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">private</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> &lt;T&gt; <span style="color:rgb(0,0,255);line-height:1.5;">void</span> update(Map&lt;T, List&lt;String&gt;&gt;<span style="line-height:1.5;"> m, T key, String value) {
        List</span>&lt;String&gt; lst =<span style="line-height:1.5;"> m.get(key);
        </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (lst == <span style="color:rgb(0,0,255);line-height:1.5;">null</span>) {<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">该 Key是第一次出现</span>
            lst = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> ArrayList&lt;String&gt;<span style="line-height:1.5;">();
            m.put(key, lst);
        }
        lst.add(value);
    }</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Dijkstra算法分析：</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;上面已经提到，这是一个无向图，无向图的最短路径问题，无向图的Dijkstra算法实现要比带权的有向图简单得多。简单的原因在于：无向图的Dijkstra实现只需要一个<span style="text-decoration:underline;">队列</span>，采用“广度”遍历的思想从源点开始向外扩散求解图中其他顶点到源点的距离，<strong>之所以这样，是因为无向图一旦访问到某个顶点，更新它的前驱顶点后，它的前驱顶点以后都不会再变了（<a href="http://www.cnblogs.com/hapjin/p/5435724.html" rel="nofollow" style="color:#000000;">参考博文</a>）。而对于有向图，某个顶点的前驱顶点可能会被多次更新。因此，需要<span style="text-decoration:underline;">更复杂的数据结构</span>来”贪心“选择下一个距离最短的顶点。</strong></p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,128);line-height:1.5;"> 1</span> <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 2</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 使用Dijkstra算法求解无向图 从 start 到 end 的最短路径
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 3</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> adjcentWords 保存单词Map,Map&lt;String, List&lt;string&gt;&gt;key:表示某个单词, Value:与该单词只差一个字符的单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 4</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> start 起始单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 5</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> end 结束单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 6</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@return</span><span style="color:rgb(0,128,0);line-height:1.5;"> 从start 转换成 end 经过的中间单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 7</span>  <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 8</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> List&lt;String&gt; findChain(Map&lt;String, List&lt;String&gt;&gt;<span style="line-height:1.5;"> adjcentWords, String start, String end){
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 9</span>         Map&lt;String, String&gt; previousWord = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> HashMap&lt;String, String&gt;();<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">Key:某个单词,Value:该单词的前驱单词</span>
<span style="color:rgb(0,128,128);line-height:1.5;">10</span>         Queue&lt;String&gt; queue = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> LinkedList&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;">11</span>         
<span style="color:rgb(0,128,128);line-height:1.5;">12</span> <span style="line-height:1.5;">        queue.offer(start);
</span><span style="color:rgb(0,128,128);line-height:1.5;">13</span>         <span style="color:rgb(0,0,255);line-height:1.5;">while</span>(!<span style="line-height:1.5;">queue.isEmpty()){
</span><span style="color:rgb(0,128,128);line-height:1.5;">14</span>             String preWord =<span style="line-height:1.5;"> queue.poll();
</span><span style="color:rgb(0,128,128);line-height:1.5;">15</span>             List&lt;String&gt; adj =<span style="line-height:1.5;"> adjcentWords.get(preWord);
</span><span style="color:rgb(0,128,128);line-height:1.5;">16</span>             
<span style="color:rgb(0,128,128);line-height:1.5;">17</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (String word : adj) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">18</span>                 <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">代表这个word的'距离'(前驱单词)没有被更新过.(第一次遍历到该word),每个word的'距离'只会被更新一次.</span>
<span style="color:rgb(0,128,128);line-height:1.5;">19</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">if</span>(previousWord.get(word) == <span style="color:rgb(0,0,255);line-height:1.5;">null</span>){<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">理解为什么需要if判断</span>
<span style="color:rgb(0,128,128);line-height:1.5;">20</span> <span style="line-height:1.5;">                    previousWord.put(word, preWord);
</span><span style="color:rgb(0,128,128);line-height:1.5;">21</span> <span style="line-height:1.5;">                    queue.offer(word);
</span><span style="color:rgb(0,128,128);line-height:1.5;">22</span> <span style="line-height:1.5;">                }
</span><span style="color:rgb(0,128,128);line-height:1.5;">23</span>                 
<span style="color:rgb(0,128,128);line-height:1.5;">24</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;">25</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;">26</span>         previousWord.put(start, <span style="color:rgb(0,0,255);line-height:1.5;">null</span>);<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">记得把源点的前驱顶点添加进去</span>
<span style="color:rgb(0,128,128);line-height:1.5;">27</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> geChainFromPreviousMap(previousWord, start, end);
</span><span style="color:rgb(0,128,128);line-height:1.5;">28</span>     }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">第19行进行if判断的原因是：还是前面提到的，每个顶点的前驱只会更新一次。当第一次遍历到 'word'时，它的前驱顶点'preWord'就被永久确定下来了。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">当在后面可能再次从另外一个顶点遍历到该'word'时，这个顶点不可能是'word'的前驱顶点了。因为：这条到'word'的路径不可能是最短的了。这就是”广度“ 搜索的思想！</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>三，构造图的算法改进</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">这里将构造图的算法改进单独作为一节，是因为它很好地用到了“分类的思想”，在处理大量的数据时，先将相关的数据分类，然后以类为单位，一个一个地处理类中的所有数据。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>分类要覆盖所有的数据，相当于概率论中的对 数据集合S的一个全划分。</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">将列表List&lt;String&gt;中的单词构造图，本质上查找每个单词的所有邻接单词。显然如果两个单词的长度不相等，它们就不可能构成邻接关系。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,102,0);">因此，可以把单词表中所有的单词先按单词的长度进行分类，分成长度为1的单词、长度为2的单词....长度为N的单词。分成了N个集合，这N个集合就是单词表的一个全划分，因为对于单词表中的任何一个单词，它一定属于这N个集合中的某一个。</span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">因此，先将按长度进行分类。然后再对每一类中的单词进行判断。改进后的代码如下：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,128);line-height:1.5;"> 1</span>     <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 2</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * 根据单词构造邻接表
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 3</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> theWords 包含所有单词List
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 4</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * </span><span style="color:rgb(128,128,128);line-height:1.5;">@return</span><span style="color:rgb(0,128,0);line-height:1.5;"> Map&lt;String, List&lt;string&gt;&gt;key:表示某个单词, Value:与该单词只差一个字符的单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 5</span>      <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 6</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> Map&lt;String, List&lt;String&gt;&gt;<span style="line-height:1.5;"> computeAdjacentWords(
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 7</span>             List&lt;String&gt;<span style="line-height:1.5;"> theWords) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 8</span>         Map&lt;String, List&lt;String&gt;&gt; adjWords = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> TreeMap&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 9</span>         Map&lt;Integer, List&lt;String&gt;&gt; wordsByLength = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> TreeMap&lt;&gt;<span style="line-height:1.5;">();//单词分类,Key表示单词长度，Value表示长度相同的单词集合
</span><span style="color:rgb(0,128,128);line-height:1.5;">10</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">11</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (String word : theWords)
</span><span style="color:rgb(0,128,128);line-height:1.5;">12</span> <span style="line-height:1.5;">            update(wordsByLength, word.length(), word);
</span><span style="color:rgb(0,128,128);line-height:1.5;">13</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">14</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (List&lt;String&gt;<span style="line-height:1.5;"> groupWords : wordsByLength.values()) {//分组处理单词
</span><span style="color:rgb(0,128,128);line-height:1.5;">15</span>             String[] words = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> String[groupWords.size()];
</span><span style="color:rgb(0,128,128);line-height:1.5;">16</span> <span style="line-height:1.5;">            groupWords.toArray(words);
</span><span style="color:rgb(0,128,128);line-height:1.5;">17</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">18</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; words.length; i++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;">19</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> j = i + 1; j &lt; words.length; j++<span style="line-height:1.5;">)//只在一个组内所有的单词之间进行比较
</span><span style="color:rgb(0,128,128);line-height:1.5;">20</span>                     <span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;"> (oneCharOff(words[i], words[j])) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">21</span> <span style="line-height:1.5;">                        update(adjWords, words[i], words[j]);
</span><span style="color:rgb(0,128,128);line-height:1.5;">22</span> <span style="line-height:1.5;">                        update(adjWords, words[j], words[i]);
</span><span style="color:rgb(0,128,128);line-height:1.5;">23</span> <span style="line-height:1.5;">                    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">24</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">25</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;">26</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> adjWords;
</span><span style="color:rgb(0,128,128);line-height:1.5;">27</span>     }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">第11行至12行，完成单词分类，将单词按长度分类保存在一个Map中。Map的Key表示单词长度，Value表示所有长度相同的单词集合。如: &lt;4, five,line,good,high....&gt;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>第18行至19行的for循环，现在只需要对一个分类里面的所有单词进行比较了。而上面第2点（算法分析）中贴出的<span>computeAdjacentWords</span>2()方法中的第6、7行for循环则是对所有的单词进行遍历。</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">可以看出，改进后的算法比较的次数少了。但是从时间复杂度的角度来看，仍是O（N^2）。且额外用了一个Map&lt;Integer, List&lt;String&gt;&gt;来保存每个分类。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>四，总结</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;这个单词转换问题让我认识到了图论算法的重要性。以前觉得图的算法高大上，遥不可及，原来它的应用如此实在。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Dijkstra算法是一个典型的贪心算法。对于带权的有向图的Dijkstra算法实现需要用到最小堆。最小堆的DelMin操作最坏情况下的复杂度为O(logN)，很符合Dijkstra中贪心选取下一个距离最小的顶点。<span style="color:rgb(255,0,0);"><strong>其次，要注意的是：当选取了某个顶点之后，该顶点的所有邻接点的距离都可能被更新，这里需要进行堆调整，可视为将这些邻接点执行decreaseKey(weight)操作。但是，有个问题，我们需要找到该顶点的所有邻接点！而对最小堆中的某个元素进行查找操作是低效的！</strong>(为什么网上大部分的基于最小堆实现的Dijkstra算法都没有考虑查找邻接点且对它执行decreaseKey操作????)<strong>因此，Dijkstra算法的实现才会借助对查找效率更好的斐波拉契堆或者配对堆来实现。</strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">其次，对待求解的大问题进行分类，将大问题分解成若干小的类别的问题，这是一种分治的思想。只”比较“（处理）相关的元素而不是”比较“所有的元素，有效地减少了程序的时间复杂度。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>五，完整代码实现</strong></p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,128);line-height:1.5;">  1</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.io.BufferedReader;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  2</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.io.File;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  3</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.io.FileReader;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  4</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.io.IOException;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  5</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.ArrayList;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  6</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.HashMap;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  7</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.LinkedList;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  8</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.List;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  9</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.Map;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 10</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.Queue;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 11</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.util.TreeMap;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 12</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 13</span> <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> WordLadder {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 14</span>     
<span style="color:rgb(0,128,128);line-height:1.5;"> 15</span>     <span style="color:rgb(0,128,0);line-height:1.5;">/*</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 16</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * 从文件中将单词读入到List&lt;String&gt;. 假设一行一个单词,单词没有重复
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 17</span>      <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 18</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> List&lt;String&gt; read(<span style="color:rgb(0,0,255);line-height:1.5;">final</span><span style="line-height:1.5;"> String filepath) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 19</span>         List&lt;String&gt; wordList = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> ArrayList&lt;String&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 20</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 21</span>         File file = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> File(filepath);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 22</span>         FileReader fr = <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 23</span>         BufferedReader br = <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 24</span>         String lines = <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 25</span>         String word = <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 26</span>         <span style="color:rgb(0,0,255);line-height:1.5;">try</span><span style="line-height:1.5;"> {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 27</span>             fr = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> FileReader(file);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 28</span>             br = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> BufferedReader(fr);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 29</span>             String line = <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 30</span>             <span style="color:rgb(0,0,255);line-height:1.5;">int</span> index = -1<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 31</span>             <span style="color:rgb(0,0,255);line-height:1.5;">while</span> ((lines = br.readLine()) != <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 32</span>                 <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> word = line.substring(0, line.indexOf(" ")).trim();</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 33</span>                 line =<span style="line-height:1.5;"> lines.trim();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 34</span>                 index = line.indexOf(" "<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 35</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (index == -1<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 36</span>                     <span style="color:rgb(0,0,255);line-height:1.5;">continue</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 37</span>                 word = line.substring(0, line.indexOf(" "<span style="line-height:1.5;">));
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 38</span> <span style="line-height:1.5;">                wordList.add(word);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 39</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 40</span>         } <span style="color:rgb(0,0,255);line-height:1.5;">catch</span><span style="line-height:1.5;"> (IOException e) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 41</span> <span style="line-height:1.5;">            e.printStackTrace();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 42</span>         } <span style="color:rgb(0,0,255);line-height:1.5;">finally</span><span style="line-height:1.5;"> {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 43</span>             <span style="color:rgb(0,0,255);line-height:1.5;">try</span><span style="line-height:1.5;"> {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 44</span> <span style="line-height:1.5;">                fr.close();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 45</span> <span style="line-height:1.5;">                br.close();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 46</span>             } <span style="color:rgb(0,0,255);line-height:1.5;">catch</span><span style="line-height:1.5;"> (IOException e) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 47</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 48</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 49</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 50</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 51</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> wordList;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 52</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 53</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 54</span>     <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 55</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * 根据单词构造邻接表
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 56</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> theWords 包含所有单词List
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 57</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * </span><span style="color:rgb(128,128,128);line-height:1.5;">@return</span><span style="color:rgb(0,128,0);line-height:1.5;"> Map&lt;String, List&lt;string&gt;&gt;key:表示某个单词, Value:与该单词只差一个字符的单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 58</span>      <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 59</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> Map&lt;String, List&lt;String&gt;&gt;<span style="line-height:1.5;"> computeAdjacentWords(
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 60</span>             List&lt;String&gt;<span style="line-height:1.5;"> theWords) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 61</span>         Map&lt;String, List&lt;String&gt;&gt; adjWords = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> TreeMap&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 62</span>         Map&lt;Integer, List&lt;String&gt;&gt; wordsByLength = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> TreeMap&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 63</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 64</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (String word : theWords)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 65</span> <span style="line-height:1.5;">            update(wordsByLength, word.length(), word);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 66</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 67</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (List&lt;String&gt;<span style="line-height:1.5;"> groupWords : wordsByLength.values()) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 68</span>             String[] words = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> String[groupWords.size()];
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 69</span> <span style="line-height:1.5;">            groupWords.toArray(words);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 70</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 71</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; words.length; i++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 72</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> j = i + 1; j &lt; words.length; j++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 73</span>                     <span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;"> (oneCharOff(words[i], words[j])) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 74</span> <span style="line-height:1.5;">                        update(adjWords, words[i], words[j]);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 75</span> <span style="line-height:1.5;">                        update(adjWords, words[j], words[i]);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 76</span> <span style="line-height:1.5;">                    }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 77</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 78</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 79</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> adjWords;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 80</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 81</span>     
<span style="color:rgb(0,128,128);line-height:1.5;"> 82</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> Map&lt;String, List&lt;String&gt;&gt; computeAdjacentWords2(List&lt;String&gt;<span style="line-height:1.5;"> theWords){
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 83</span>         Map&lt;String, List&lt;String&gt;&gt; adjWords = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> TreeMap&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 84</span>         String[] words = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> String[theWords.size()];
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 85</span>         words =<span style="line-height:1.5;"> theWords.toArray(words);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 86</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 87</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; words.length; i++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 88</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> j = i+1; j &lt; words.length; j++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 89</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;">(oneCharOff(words[i], words[j]))
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 90</span> <span style="line-height:1.5;">                {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 91</span>                     update(adjWords, words[i], words[j]);<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">无向图,i--j</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 92</span>                     update(adjWords, words[j], words[i]);<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">j--i</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 93</span> <span style="line-height:1.5;">                }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 94</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> adjWords;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 95</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 96</span>     
<span style="color:rgb(0,128,128);line-height:1.5;"> 97</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 98</span>     <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">判断两个单词 只替换一个字符变成另一单词</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 99</span>     <span style="color:rgb(0,0,255);line-height:1.5;">private</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">boolean</span><span style="line-height:1.5;"> oneCharOff(String word1, String word2) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">100</span>         <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (word1.length() != word2.length())<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">单词长度不相等,肯定不符合条件. </span>
<span style="color:rgb(0,128,128);line-height:1.5;">101</span>             <span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">102</span>         <span style="color:rgb(0,0,255);line-height:1.5;">int</span> diffs = 0<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">103</span>         <span style="color:rgb(0,0,255);line-height:1.5;">for</span> (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i = 0; i &lt; word1.length(); i++<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;">104</span>             <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (word1.charAt(i) !=<span style="line-height:1.5;"> word2.charAt(i))
</span><span style="color:rgb(0,128,128);line-height:1.5;">105</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (++diffs &gt; 1<span style="line-height:1.5;">)
</span><span style="color:rgb(0,128,128);line-height:1.5;">106</span>                     <span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">107</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span> diffs == 1<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">108</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">109</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">110</span>     <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">将单词添加到邻接表中</span>
<span style="color:rgb(0,128,128);line-height:1.5;">111</span>     <span style="color:rgb(0,0,255);line-height:1.5;">private</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> &lt;T&gt; <span style="color:rgb(0,0,255);line-height:1.5;">void</span> update(Map&lt;T, List&lt;String&gt;&gt;<span style="line-height:1.5;"> m, T key, String value) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">112</span>         List&lt;String&gt; lst =<span style="line-height:1.5;"> m.get(key);
</span><span style="color:rgb(0,128,128);line-height:1.5;">113</span>         <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (lst == <span style="color:rgb(0,0,255);line-height:1.5;">null</span>) {<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">该 Key是第一次出现</span>
<span style="color:rgb(0,128,128);line-height:1.5;">114</span>             lst = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> ArrayList&lt;String&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;">115</span> <span style="line-height:1.5;">            m.put(key, lst);
</span><span style="color:rgb(0,128,128);line-height:1.5;">116</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;">117</span> <span style="line-height:1.5;">        lst.add(value);
</span><span style="color:rgb(0,128,128);line-height:1.5;">118</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">119</span>     
<span style="color:rgb(0,128,128);line-height:1.5;">120</span>     
<span style="color:rgb(0,128,128);line-height:1.5;">121</span> <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;">122</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 使用Dijkstra算法求解从 start 到 end 的最短路径
</span><span style="color:rgb(0,128,128);line-height:1.5;">123</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> adjcentWords 保存单词Map,Map&lt;String, List&lt;string&gt;&gt;key:表示某个单词, Value:与该单词只差一个字符的单词
</span><span style="color:rgb(0,128,128);line-height:1.5;">124</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> start 起始单词
</span><span style="color:rgb(0,128,128);line-height:1.5;">125</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@param</span><span style="color:rgb(0,128,0);line-height:1.5;"> end 结束单词
</span><span style="color:rgb(0,128,128);line-height:1.5;">126</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * </span><span style="color:rgb(128,128,128);line-height:1.5;">@return</span><span style="color:rgb(0,128,0);line-height:1.5;"> 从start 转换成 end 经过的中间单词
</span><span style="color:rgb(0,128,128);line-height:1.5;">127</span>  <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;">128</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> List&lt;String&gt; findChain(Map&lt;String, List&lt;String&gt;&gt;<span style="line-height:1.5;"> adjcentWords, String start, String end){
</span><span style="color:rgb(0,128,128);line-height:1.5;">129</span>         Map&lt;String, String&gt; previousWord = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> HashMap&lt;String, String&gt;();<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">Key:某个单词,Value:该单词的前驱单词</span>
<span style="color:rgb(0,128,128);line-height:1.5;">130</span>         Queue&lt;String&gt; queue = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> LinkedList&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;">131</span>         
<span style="color:rgb(0,128,128);line-height:1.5;">132</span> <span style="line-height:1.5;">        queue.offer(start);
</span><span style="color:rgb(0,128,128);line-height:1.5;">133</span>         <span style="color:rgb(0,0,255);line-height:1.5;">while</span>(!<span style="line-height:1.5;">queue.isEmpty()){
</span><span style="color:rgb(0,128,128);line-height:1.5;">134</span>             String preWord =<span style="line-height:1.5;"> queue.poll();
</span><span style="color:rgb(0,128,128);line-height:1.5;">135</span>             List&lt;String&gt; adj =<span style="line-height:1.5;"> adjcentWords.get(preWord);
</span><span style="color:rgb(0,128,128);line-height:1.5;">136</span>             
<span style="color:rgb(0,128,128);line-height:1.5;">137</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (String word : adj) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">138</span>                 <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">代表这个word的'距离'(前驱单词)没有被更新过.(第一次遍历到该word),每个word的'距离'只会被更新一次.</span>
<span style="color:rgb(0,128,128);line-height:1.5;">139</span>                 <span style="color:rgb(0,0,255);line-height:1.5;">if</span>(previousWord.get(word) == <span style="color:rgb(0,0,255);line-height:1.5;">null</span>){<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">理解为什么需要if判断</span>
<span style="color:rgb(0,128,128);line-height:1.5;">140</span> <span style="line-height:1.5;">                    previousWord.put(word, preWord);
</span><span style="color:rgb(0,128,128);line-height:1.5;">141</span> <span style="line-height:1.5;">                    queue.offer(word);
</span><span style="color:rgb(0,128,128);line-height:1.5;">142</span> <span style="line-height:1.5;">                }
</span><span style="color:rgb(0,128,128);line-height:1.5;">143</span>                 
<span style="color:rgb(0,128,128);line-height:1.5;">144</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;">145</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;">146</span>         previousWord.put(start, <span style="color:rgb(0,0,255);line-height:1.5;">null</span>);<span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">记得把源点的前驱顶点添加进去</span>
<span style="color:rgb(0,128,128);line-height:1.5;">147</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> geChainFromPreviousMap(previousWord, start, end);
</span><span style="color:rgb(0,128,128);line-height:1.5;">148</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">149</span>     
<span style="color:rgb(0,128,128);line-height:1.5;">150</span>     <span style="color:rgb(0,0,255);line-height:1.5;">private</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> List&lt;String&gt; geChainFromPreviousMap(Map&lt;String, String&gt;<span style="line-height:1.5;"> previousWord, String start, String end){
</span><span style="color:rgb(0,128,128);line-height:1.5;">151</span>         LinkedList&lt;String&gt; result = <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">152</span>         
<span style="color:rgb(0,128,128);line-height:1.5;">153</span>         <span style="color:rgb(0,0,255);line-height:1.5;">if</span>(previousWord.get(end) != <span style="color:rgb(0,0,255);line-height:1.5;">null</span><span style="line-height:1.5;">){
</span><span style="color:rgb(0,128,128);line-height:1.5;">154</span>             result = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> LinkedList&lt;&gt;<span style="line-height:1.5;">();
</span><span style="color:rgb(0,128,128);line-height:1.5;">155</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(String pre = end; pre != <span style="color:rgb(0,0,255);line-height:1.5;">null</span>; pre =<span style="line-height:1.5;"> previousWord.get(pre))
</span><span style="color:rgb(0,128,128);line-height:1.5;">156</span> <span style="line-height:1.5;">                result.addFirst(pre);
</span><span style="color:rgb(0,128,128);line-height:1.5;">157</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;">158</span>         <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> result;
</span><span style="color:rgb(0,128,128);line-height:1.5;">159</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">160</span> }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">处理的单词TXT文件格式如下：</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="https://images2015.cnblogs.com/blog/715283/201604/715283-20160429202110191-1433387156.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;本文转自hapjin博客园博客，原文链接：http://www.cnblogs.com/hapjin/p/5445370.html，如需转载请自行联系原作者</p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
