<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>如何恢复已删除的Linux下的普通文件 « NotBeCN</title>
  <meta name="description" content="                       本人观点： 在不修改内核的情况下，&nbsp;&nbsp;恢复删除不久的小文件 是有效的，因为 只占一个直接 inode，不需要间接节点信息保存， 像重要的配置文件，可用此法恢复 要想恢复误删除的文件，必须清楚数据在磁盘上究竟是如何存储的，以及如何定位并恢复数据。本文...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/07/31/weixin_33866037_90125050.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">如何恢复已删除的Linux下的普通文件</h1>
    <p class="post-meta">Jul 31, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1> </h1> 
   <div class="blogpost-body"> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;font-weight:normal;line-height:1.5;">本人观点： 在不修改内核的情况下，&nbsp;&nbsp;恢复删除不久的小文件 是有效的，因为 只占一个直接 inode，不需要间接节点信息保存， 像重要的配置文件，可用此法恢复<br><br> 要想恢复误删除的文件，必须清楚数据在磁盘上究竟是如何存储的，以及如何定位并恢复数据。本文从数据恢复的角度，着重介绍了 ext2 文件系统中使用的一些基本概念和重要数据结构，并通过几个实例介绍了如何手工恢复已经删除的文件。最后针对 ext2 现有实现存在的大文件无法正常恢复的问题，通过修改内核中的实现，给出了一种解决方案。<br> 对于很多 Linux 的用户来说，可能有一个问题一直都非常头疼：对于那些不小心删除的数据来说，怎样才能恢复出来呢？大家知道，在 Windows 系统上，回收站中保存了最近使用资源管理器时删除的文件。即便是对于那些在命令行中删除的文件来说，也有很多工具（例如 recover4all，FinalData Recovery）可以把这些已经删除的文件恢复出来。在Linux 下这一切是否可能呢？<br> 实际上，为了方便用户的使用，现在 Linux 上流行的桌面管理工具（例如gnome和KDE）中都已经集成了回收站的功能。其基本思想是在桌面管理工具中捕获对文件的删除操作，将要删除的文件移动到 用户根目录下的 .Trash 文件夹中，但却并不真正删除该文件。当然，像在 Windows 上一样，如果用户在删除文件的同时，按下了 Shift 键并确认删除该文件，那么这个文件就不会被移动到 .Trash 文件夹中，也就无从恢复了。此时，习惯了使用 Windows 上各种恢复工具的人就会顿足捶胸，抱怨 Linux 上工具的缺乏了。但是请稍等一下，难道按照这种方式删除的文件就真的无从恢复了么？或者换一个角度来看，使用 rm 命令删除的文件是否还有办法能够恢复出来呢？<br> 背景知识<br> 在开始真正进行实践之前，让我们首先来了解一下在 Linux 系统中，文件是如何进行存储和定位的，这对于理解如何恢复文件来说非常重要。我们知道，数据最终以数据块的形式保存在磁盘上，而操作系统是通过文件系统来 管理这些数据的。ext2/ext3 是 Linux 上应用最为广泛的文件系统，本文将以 ext2 文件系统为例展开介绍。<br> 我们知道，在操作系统中，文件系统是采用一种层次化的形式表示的，通常可以表示成一棵倒置的树。所有的文件和子目录都是通过查找其父目录项来定位的，目录 项中通过匹配文件名可以找到对应的索引节点号（inode），通过查找索引节点表（inode table）就可以找到文件在磁盘上的位置，整个过程如图1所示。<br><strong>图 1. 文件数据定位过程</strong><br><img src="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/images/image001.jpg" alt="" style="border:0px;">&nbsp;<br><br> 对于 ext2 类型的文件系统来说，目录项是使用一个名为 ext2_dir_entry_2 的结构来表示的，该结构定义如下所示：<br><strong>清单 1. ext2_dir_entry_2 结构定义</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> struct ext2_dir_entry_2 {<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;inode;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 索引节点号 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;rec_len;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; /* 目录项的长度 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__u8&nbsp; &nbsp; name_len;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 文件名长度 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__u8&nbsp; &nbsp; file_type;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 文件类型 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;char&nbsp; &nbsp; name[EXT2_NAME_LEN];&nbsp; &nbsp; /* 文件名 */<br> };<br><br> 在 Unix/Linux 系统中，目录只是一种特殊的文件。目录和文件是通过 file_type 域来区分的，该值为 1 则表示是普通文件，该值为 2 则表示是目录。<br> 对于每个 ext2 分区来说，其在物理磁盘上的布局如图 2 所示：<br><strong>图 2. ext2 分区的布局</strong><br><img src="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/images/image002.jpg" alt="" style="border:0px;">&nbsp;<br><br> 从图 2 中可以看到，对于 ext2 文件系统来说，磁盘被划分成一个个大小相同的数据块，每个块的大小可以是1024、2048 或 4096 个字节。其中，第一个块称为引导块，一般保留做引导扇区使用，因此 ext2 文件系统一般都是从第二个块开始的。剩余的块被划分为一个个的块组，ext2 文件系统会试图尽量将相同文件的数据块都保存在同一个块组中，并且尽量保证文件在磁盘上的连续性，从而提高文件读写时的性能。<br> 至于一个分区中到底有多少个块组，这取决于两个因素：<br><br> 分区大小。&nbsp;<br> 块大小。&nbsp;<br> 最终的计算公式如下：<br> 分区中的块组数＝分区大小/(块大小*8)<br> 这是由于在每个块组中使用了一个数据块位图来标识数据块是否空闲，因此每个块组中最多可以有（块大小*8）个块；该值除上分区大小就是分区中总的块组数。<br> 每个块组都包含以下内容：<br><br> 超级块。存放文件系统超级块的一个拷贝。&nbsp;<br> 组描述符。该块组的组描述符。&nbsp;<br> 数据块位图。标识相应的数据块是否空闲。&nbsp;<br> 索引节点位图。标识相应的索引节点是否空闲。&nbsp;<br> 索引节点表。存放所有索引节点的数据。&nbsp;<br> 数据块。该块组中用来保存实际数据的数据块。&nbsp;<br> 在每个块组中都保存了超级块的一个拷贝，默认情况下，只有第一个块组中的超级块结构才会被系统内核使用；其他块组中的超级块可以在 e2fsck 之类的程序对磁盘上的文件系统进行一致性检查使用。在 ext2 文件系统中，超级块的结构会通过一个名为 ext2_super_block 的结构进行引用。该结构的一些重要域如下所示：<br><strong>清单 2. ext2_super_block 结构定义</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> struct ext2_super_block {<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_inodes_count;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 索引节点总数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_blocks_count;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 块数，即文件系统以块为单位的大小 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_r_blocks_count;&nbsp; &nbsp;&nbsp; &nbsp; /* 系统预留的块数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_free_blocks_count;&nbsp; &nbsp; /* 空闲块数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_free_inodes_count;&nbsp; &nbsp; /* 空闲索引节点数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_first_data_block;&nbsp; &nbsp;&nbsp;&nbsp;/* 第一个可用数据块的块号 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_log_block_size;&nbsp; &nbsp;&nbsp; &nbsp; /* 块大小 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_blocks_per_group;&nbsp; &nbsp;&nbsp;&nbsp;/* 每个块组中的块数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;s_inodes_per_group;&nbsp; &nbsp;&nbsp;&nbsp;/* 每个块组中的索引节点个数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;...<br> }<br><br> 每个块组都有自己的组描述符，在 ext2 文件系统中是通过一个名为 ext2_group_desc的结构进行引用的。该结构的定义如下：<br><strong>清单 3. ext2_group_desc 结构定义</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> /*<br> * Structure of a blocks group descriptor<br> */<br> struct ext2_group_desc<br> {<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;bg_block_bitmap;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 数据块位图的块号 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;bg_inode_bitmap;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 索引节点位图的块号 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;bg_inode_table;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 第一个索引节点表的块号 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;bg_free_blocks_count;&nbsp; &nbsp;/* 该组中空闲块数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;bg_free_inodes_count;&nbsp; &nbsp;/* 该组中空闲索引节点数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;bg_used_dirs_count;&nbsp; &nbsp;&nbsp;&nbsp;/* 该组中的目录项 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;bg_pad;<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;bg_reserved[3];<br> };<br><br> 数据块位图和索引节点位图分别占用一个块的大小，其每一位描述了对应数据块或索引节点是否空闲，如果该位为0，则表示空闲；如果该位为1，则表示已经使用。<br> 索引节点表存放在一系列连续的数据块中，每个数据块中可以包括若干个索引节点。每个索引节点在 ext2 文件系统中都通过一个名为 ext2_inode 的结构进行引用，该结构大小固定为 128 个字节，其中一些重要的域如下所示：<br><strong>清单 4. ext2_inode 结构定义</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> /*<br> * Structure of an inode on the disk<br> */<br> struct ext2_inode {<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;i_mode;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 文件模式 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;i_uid;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; /* 文件所有者的 uid */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_size;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* 以字节为单位的文件长度 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_atime;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 最后一次访问该文件的时间 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_ctime;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 索引节点最后改变的时间 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_mtime;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 文件内容最后改变的时间 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_dtime;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;/* 文件删除的时间 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;i_gid;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; /* 文件所有者的 gid */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le16&nbsp;&nbsp;i_links_count;&nbsp;&nbsp;/* 硬链接数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_blocks;&nbsp; &nbsp;&nbsp; &nbsp; /* 文件的数据块数 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;...<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;__le32&nbsp;&nbsp;i_block[EXT2_N_BLOCKS];/* 指向数据块的指针 */<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;...<br> };<br><br> 第一个索引节点所在的块号保存在该块组描述符的 bg_inode_table 域中。请注意 i_block 域，其中就包含了保存数据的数据块的位置。有关如何对数据块进行寻址，请参看后文“数据块寻址方式”一节的内容。<br> 需要知道的是，在普通的删除文件操作中，操作系统并不会逐一清空保存该文件的数据块的内容，而只会释放该文件所占用的索引节点和数据块，方法是将索引节点 位图和数据块位图中的相应标识位设置为空闲状态。因此，如果我们可以找到文件对应的索引节点，由此查到相应的数据块，就可能从磁盘上将已经删除的文件恢复 出来。<br> 幸运的是，这一切都是可能的！本文将通过几个实验来了解一下如何从磁盘上恢复删除的文件。<br><br><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" style="border:0px;"><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" style="border:0px;"><br><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/index.html#main" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><strong>回页首</strong></a><br><br> 数据块寻址方式<br> 回想一下，ext2_inode 结构的 i_block 域是一个大小为 EXT2_N_BLOCKS 的数组，其中保存的就是真正存放文件数据的数据块的位置。通常来说，EXT2_N_BLOCKS 大小为 15。在 ext2 文件系统，采用了直接寻址和间接寻址两种方式来对数据块进行寻址，原理如图3 所示：<br><strong>图 3. 数据块寻址方式</strong><br><img src="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/images/image003.jpg" alt="" style="border:0px;">&nbsp;<br><br> 对于 i_block 的前 12 个元素（i_block[0]到i_block[11]）来说，其中存放的就是实际的数据块号，即对应于文件的 0 到 11 块。这种方式称为直接寻址。&nbsp;<br> 对于第13个元素（i_block[12]）来说，其中存放的是另外一个数据块的逻辑块号；这个块中并不存放真正的数据，而是存放真正保存数据的数据块的 块号。即 i_block[12] 指向一个二级数组，其每个元素都是对应数据块的逻辑块号。由于每个块号需要使用 4 个字节表示，因此这种寻址方式可以访问的对应文件的块号范围为 12 到 (块大小/4)+11。这种寻址方式称为间接寻址。&nbsp;<br> 对于第14个元素（i_block[13]）来说，其中存放也是另外一个数据块的逻辑块号。与间接寻址方式不同的是，i_block[13] 所指向的是一个数据块的逻辑块号的二级数组，而这个二级数组的每个元素又都指向一个三级数组，三级数组的每个元素都是对应数据块的逻辑块号。这种寻址方式 称为二次间接寻址，对应文件块号的寻址范围为 (块大小/4)+12 到 (块大小/4)2+(块大小/4)+11。&nbsp;<br> 对于第15个元素（i_block[14]）来说，则利用了三级间接索引，其第四级数组中存放的才是逻辑块号对应的文件块号，其寻址范围从 (块大小/4)2+(块大小/4)+12 到 (块大小/4)3+ (块大小/4)2+(块大小/4)+11。&nbsp;<br> ext2 文件系统可以支持1024、2048和4096字节三种大小的块，对应的寻址能力如下表所示：<br><strong>表 1. 各种数据块对应的文件寻址范围</strong><br><br> 块大小&nbsp;<br> 直接寻址&nbsp;<br> 间接寻址&nbsp;<br> 二次间接寻址&nbsp;<br> 三次间接寻址&nbsp;<br><br> 1024&nbsp;<br> 12KB&nbsp;<br> 268KB&nbsp;<br> 64.26MB&nbsp;<br> 16.06GB&nbsp;<br><br> 2048&nbsp;<br> 24KB&nbsp;<br> 1.02MB&nbsp;<br> 513.02MB&nbsp;<br> 265.5GB&nbsp;<br><br> 4096&nbsp;<br> 48KB&nbsp;<br> 4.04MB&nbsp;<br> 4GB&nbsp;<br> ~ 4TB&nbsp;<br><br> 掌握上面介绍的知识之后，我们就可以开始恢复文件的实验了。<br><br><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" style="border:0px;"><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" style="border:0px;"><br><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/index.html#main" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><strong>回页首</strong></a><br><br> 准备文件系统<br> 为了防止破坏已有系统，本文将采用一个新的分区进行恢复删除文件的实验。<br> 首先让我们准备好一个新的分区，并在上面创建 ext2 格式的文件系统。下面的命令可以帮助创建一个 20GB 的分区：<br><strong>清单 5. 新建磁盘分区</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # fdisk /dev/sdb&nbsp;<br><br> 在笔者的机器上，这个分区是 /dev/sdb6。然后创建文件系统：<br><strong>清单 6. 在新分区上创建 ext2 文件系统</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # mke2fs /dev/sdb6<br><br> 并将其挂载到系统上来：<br><strong>清单 7. 挂载创建的 ext2 文件系统</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # mkdir /tmp/test<br> # mount /dev/sdb6 /tmp/test<br><br> 在真正使用这个文件系统之前，让我们首先使用系统提供的一个命令 dumpe2fs 来熟悉一下这个文件系统的一些具体参数：<br><strong>清单 8. 使用 dumpe2fs 熟悉这个文件系统的参数</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # dumpe2fs /dev/sdb6&nbsp;<br> dumpe2fs 1.39 (29-May-2006)<br> Filesystem volume name:&nbsp; &nbsp;<br> Last mounted on:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> Filesystem UUID:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; d8b10aa9-c065-4aa5-ab6f-96a9bcda52ce<br> Filesystem magic number:&nbsp;&nbsp;0xEF53<br> Filesystem revision #:&nbsp; &nbsp; 1 (dynamic)<br> Filesystem features:&nbsp; &nbsp;&nbsp; &nbsp;ext_attr resize_inode dir_index filetype sparse_super large_file<br> Default mount options:&nbsp; &nbsp; (none)<br> Filesystem state:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;not clean<br> Errors behavior:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Continue<br> Filesystem OS type:&nbsp; &nbsp;&nbsp; &nbsp; Linux<br> Inode count:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2443200<br> Block count:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;4885760<br> Reserved block count:&nbsp; &nbsp;&nbsp;&nbsp;244288<br> Free blocks:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;4797829<br> Free inodes:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2443189<br> First block:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;0<br> Block size:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;4096<br> Fragment size:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;4096<br> Reserved GDT blocks:&nbsp; &nbsp;&nbsp; &nbsp;1022<br> Blocks per group:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;32768<br> Fragments per group:&nbsp; &nbsp;&nbsp; &nbsp;32768<br> Inodes per group:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;16288<br> Inode blocks per group:&nbsp; &nbsp;509<br> Filesystem created:&nbsp; &nbsp;&nbsp; &nbsp; Mon Oct 29 20:04:16 2007<br> Last mount time:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Mon Oct 29 20:06:52 2007<br> Last write time:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Mon Oct 29 20:08:31 2007<br> Mount count:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1<br> Maximum mount count:&nbsp; &nbsp;&nbsp; &nbsp;39<br> Last checked:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; Mon Oct 29 20:04:16 2007<br> Check interval:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;15552000 (6 months)<br> Next check after:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Sat Apr 26 20:04:16 2008<br> Reserved blocks uid:&nbsp; &nbsp;&nbsp; &nbsp;0 (user root)<br> Reserved blocks gid:&nbsp; &nbsp;&nbsp; &nbsp;0 (group root)<br> First inode:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;11<br> Inode size:&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;128<br> Default directory hash:&nbsp; &nbsp;tea<br> Directory Hash Seed:&nbsp; &nbsp;&nbsp; &nbsp;d1432419-2def-4762-954a-1a26fef9d5e8<br><br> Group 0: (Blocks 0-32767)<br> &nbsp;&nbsp;Primary superblock at 0, Group descriptors at 1-2<br> &nbsp;&nbsp;Reserved GDT blocks at 3-1024<br> &nbsp;&nbsp;Block bitmap at 1025 (+1025), Inode bitmap at 1026 (+1026)<br> &nbsp;&nbsp;Inode table at 1027-1535 (+1027)<br> &nbsp;&nbsp;31224 free blocks, 16276 free inodes, 2 directories<br> &nbsp;&nbsp;Free blocks: 1543-22535, 22537-32767<br> &nbsp;&nbsp;Free inodes: 12, 14-16288<br><br> ...<br><br> Group 149: (Blocks 4882432-4885759)<br> &nbsp;&nbsp;Block bitmap at 4882432 (+0), Inode bitmap at 4882433 (+1)<br> &nbsp;&nbsp;Inode table at 4882434-4882942 (+2)<br> &nbsp;&nbsp;2817 free blocks, 16288 free inodes, 0 directories<br> &nbsp;&nbsp;Free blocks: 4882943-4885759<br> &nbsp;&nbsp;Free inodes: 2426913-2443200<br><br> 应用前面介绍的一些知识，我们可以看到，这个文件系统中，块大小（Block size）为4096字节，因此每个块组中的块数应该是4096*8=32768个（Blocks per group），每个块组的大小是 128MB，整个分区被划分成20GB/(4KB*32768)=160个。但是为什么我们只看到 150 个块组（0到149）呢？实际上，在 fdisk 中，我们虽然输入要创建的分区大小为 20GB，但实际上，真正分配的空间并不是严格的20GB，而是只有大约 20*109 个字节，准确地说，应该是 (4885760 * 4096) / (1024*1024*1024) = 18.64GB。这是由于不同程序的计数单位的不同造成的，在使用存储设备时经常遇到这种问题。因此，这个分区被划分成 150 个块组，前 149 个块组分别包含 32768 个块（即 128B），最后一个块组只包含 3328 个块。<br> 另外，我们还可以看出，每个索引节点的大小是 128 字节，每个块组中包含 16288 个索引节点，在磁盘上使用 509 个块来存储（16288*128/4096），在第一个块组中，索引节点表保存在 1027 到 1535 块上。<br> 数据块和索引节点是否空闲，是分别使用块位图和索引节点位图来标识的，在第一个块组中，块位图和索引节点位图分别保存在 1025 和 1026 块上。<br> dumpe2fs 的输出结果中还包含了其他一些信息，我们暂时先不用详细关心这些信息。<br><br><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" style="border:0px;"><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" style="border:0px;"><br><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/index.html#main" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><strong>回页首</strong></a><br><br> 准备测试文件<br> 现在请将附件中的 createfile.sh 文件下载到本地，并将其保存到 /tmp/test 目录中，这个脚本可以帮助我们创建一个特殊的文件，其中每行包含 1KB 字符，最开始的14个字符表示行号。之所以采用这种文件格式，是为了方便地确认所恢复出来的文件与原始文件之间的区别。这个脚本的用法如下：<br><strong>清单 9. createfile.sh 脚本的用法</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # ./createfile.sh [size in KB] [filename]<br><br> 第 1 个参数表示所生成的文件大小，单位是 KB；第 2 个参数表示所生成文件的名字。<br> 下面让我们创建几个测试文件：<br><strong>清单 10. 准备测试文件</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # cd /tmp/test<br> #./createfile.sh 35 testfile.35K<br> #./createfile.sh 10240 testfile.10M<br><br> # cp testfile.35K testfile.35K.orig<br> # cp testfile.10M testfile.10M.orig<br><br> 上面的命令新创建了大小为 35 KB 和 9000KB 的两个文件，并为它们各自保存了一个备份，备份文件的目的是为了方便使用 diff 之类的工具验证最终恢复出来的文件与原始文件完全一致。<br> ls 命令的 –i 选项可以查看有关保存文件使用的索引节点的信息：<br><strong>清单11. 查看文件的索引节点号</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # ls -li | sort<br> 11 drwx------ 2 root root&nbsp; &nbsp; 16384 Oct 29 20:08 lost+found<br> 12 -rwxr-xr-x 1 root root&nbsp; &nbsp;&nbsp;&nbsp;1406 Oct 29 20:09 createfile.sh<br> 13 -rw-r--r-- 1 root root&nbsp; &nbsp; 35840 Oct 29 20:09 testfile.35K<br> 14 -rw-r--r-- 1 root root 10485760 Oct 29 20:10 testfile.10M<br> 15 -rw-r--r-- 1 root root&nbsp; &nbsp; 35840 Oct 29 20:10 testfile.35K.orig<br> 16 -rw-r--r-- 1 root root 10485760 Oct 29 20:11 testfile.10M.orig<br><br> 第一列中的数字就是索引节点号。从上面的输出结果我们可以看出，索引节点号是按照我们创建文件的顺序而逐渐自增的，我们刚才创建的 35K 大小的文件的索引节点号为 13，10M 大小的文件的索引节点号为 14。debugfs 中提供了很多工具，可以帮助我们了解进一步的信息。现在执行下面的命令：<br><strong>清单12. 查看索引节点&nbsp;&nbsp;的详细信息</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # echo "stat " | debugfs /dev/sdb6<br> debugfs 1.39 (29-May-2006)<br> Inode: 13&nbsp;&nbsp;Type: regular&nbsp; &nbsp; Mode:&nbsp;&nbsp;0644&nbsp; &nbsp;Flags: 0x0&nbsp; &nbsp;Generation: 2957086759<br> User:&nbsp; &nbsp;&nbsp;&nbsp;0&nbsp; &nbsp;Group:&nbsp; &nbsp;&nbsp;&nbsp;0&nbsp; &nbsp;Size: 35840<br> File ACL: 0&nbsp; &nbsp; Directory ACL: 0<br> Links: 1&nbsp; &nbsp;Blockcount: 72<br> Fragment:&nbsp;&nbsp;Address: 0&nbsp; &nbsp; Number: 0&nbsp; &nbsp; Size: 0<br> ctime: 0x47268467 -- Mon Oct 29 20:09:59 2007<br> atime: 0x4726849d -- Mon Oct 29 20:10:53 2007<br> mtime: 0x47268467 -- Mon Oct 29 20:09:59 2007<br> BLOCKS:<br> (0-8):4096-4104<br> TOTAL: 9<br><br> 输出结果显示的就是索引节点 13 的详细信息，从中我们可以看到诸如文件大小（35840=35K）、权限（0644）等信息，尤其需要注意的是最后 3 行的信息，即该文件被保存到磁盘上的 4096 到 4104 总共 9 个数据块中。<br> 下面再看一下索引节点 14 （即 testfile.10M 文件）的详细信息：<br><strong>清单13. 查看索引节点&nbsp;&nbsp;的详细信息</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # echo "stat " | debugfs /dev/sdb6<br> debugfs 1.39 (29-May-2006)<br> Inode: 14&nbsp;&nbsp;Type: regular&nbsp;&nbsp;Mode: 0644&nbsp;&nbsp;Flags: 0x0&nbsp; &nbsp;Generation: 2957086760<br> User:&nbsp; &nbsp;&nbsp;&nbsp;0&nbsp; &nbsp;Group:&nbsp; &nbsp;&nbsp;&nbsp;0&nbsp; &nbsp;Size: 10485760<br> File ACL: 0&nbsp; &nbsp; Directory ACL: 0<br> Links: 1&nbsp; &nbsp;Blockcount: 20512<br> Fragment:&nbsp;&nbsp;Address: 0&nbsp; &nbsp; Number: 0&nbsp; &nbsp; Size: 0<br> ctime: 0x47268485 -- Mon Oct 29 20:10:29 2007<br> atime: 0x472684a5 -- Mon Oct 29 20:11:01 2007<br> mtime: 0x47268485 -- Mon Oct 29 20:10:29 2007<br> BLOCKS:<br> (0-11):24576-24587, (IND):24588, (12-1035):24589-25612, (DIND):25613, (IND):25614,&nbsp;<br> (1036-2059):25615-26638, (IND):26639, (2060-2559):26640-27139<br> TOTAL: 2564<br><br> 和索引节点 13 相比，二者之间最重要的区别在于 BLOCKS 的数据，testfile.10M 在磁盘上总共占用了 2564 个数据块，由于需要采用二级间接寻址模式进行访问，所以使用了4个块来存放间接寻址的信息，分别是24588、25613、25614和26639，其中 25613块中存放的是二级间接寻址的信息。<br><br><img src="http://www.ibm.com/i/v14/rules/blue_rule.gif" alt="" style="border:0px;"><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/c.gif" alt="" style="border:0px;"><br><br><img src="http://www.ibm.com/i/v14/icons/u_bold.gif" alt="" style="border:0px;"><br><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/index.html#main" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;"><strong>回页首</strong></a><br><br> 恢复删除文件<br> 现在将刚才创建的两个文件删除：<br><strong>清单14. 删除测试文件</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # rm -f testfile.35K testfile.10M<br><br> debugfs 的 lsdel 命令可以查看文件系统中删除的索引节点的信息：<br><strong>清单15. 使用 lsdel 命令搜索已删除的文件</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # echo "lsdel" | debugfs /dev/sdb6<br> debugfs 1.39 (29-May-2006)<br> Inode&nbsp;&nbsp;Owner&nbsp;&nbsp;Mode&nbsp; &nbsp; Size&nbsp; &nbsp; Blocks&nbsp; &nbsp;Time deleted<br> &nbsp; &nbsp; 13&nbsp; &nbsp;&nbsp; &nbsp;0 100644&nbsp;&nbsp;35840&nbsp; &nbsp; 9/9&nbsp; &nbsp;&nbsp; &nbsp;Mon Oct 29 20:32:05 2007<br> &nbsp; &nbsp; 14&nbsp; &nbsp;&nbsp; &nbsp;0 100644 10485760 2564/2564 Mon Oct 29 20:32:05 2007<br> 2 deleted inodes found.<br><br> 回想一下 inode 结构中有 4 个有关时间的域，分别是 i_atime、i_ctime、i_mtime和i_dtime，分别表示该索引节点的最近访问时间、创建时间、修改时间和删除时间。其中 i_dtime域只有在该索引节点对应的文件或目录被删除时才会被设置。dubugfs 的 lsdel 命令会去扫描磁盘上索引节点表中的所有索引节点，其中 i_dtime 不为空的项就被认为是已经删除的文件所对应的索引节点。<br> 从上面的结果可以看到，刚才删除的两个文件都已经找到了，我们可以通过文件大小区分这两个文件，二者一个大小为35K，另外一个大小为10M，正式我们刚才删除的两个文件。debugfs 的 dump 命令可以帮助恢复文件：<br><strong>清单16. 使用 dump 命令恢复已删除的文件</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # echo "dump&nbsp;&nbsp;/tmp/recover/testfile.35K.dump" | debugfs /dev/sdb6<br> # echo "dump&nbsp;&nbsp;/tmp/recover/testfile.10M.dump" | debugfs /dev/sdb6<br><br> 执行上面的命令之后，在 /tmp/recover 目录中会生成两个文件，比较这两个文件与我们前面备份的文件的内容就会发现，testfile.35K.dump 与 testfile.35K.orig 的内容完全相同，而 testfile.10M.dump 文件中则仅有前 48K 数据是对的，后面的数据全部为 0 了。这是否意味着删除文件时间已经把数据也同时删除了呢？实际上不是，我们还是有办法把数据全部恢复出来的。记得我们刚才使用 debugfs 的 stat 命令查看索引节点 14 时的 BLOCKS 的数据吗？这些数据记录了整个文件在磁盘上存储的位置，有了这些数据就可以把整个文件恢复出来了，请执行下面的命令：<br><strong>清单 17. 使用 dd 命令手工恢复已删除的文件</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # dd if=/dev/sdb6 of=/tmp/recover/testfile.10M.dd.part1 bs=4096 count=12 skip=24576<br> # dd if=/dev/sdb6 of=/tmp/recover/testfile.10M.dd.part2 bs=4096 count=1024 skip=24589<br> # dd if=/dev/sdb6 of=/tmp/recover/testfile.10M.dd.part2 bs=4096 count=1024 skip=25615<br> # dd if=/dev/sdb6 of=/tmp/recover/testfile.10M.dd.part4 bs=4096 count=500 skip=26640<br><br> # cat /tmp/recover/testfile.10M.dd.part[1-4] &gt; /tmp/recover/ testfile.10M.dd<br><br> 比较一下最终的 testfile.10M.dd 文件和已经备份过的 testfile.10M.orig 文件就会发现，二者完全相同：<br><strong>清单 18. 使用 diff 命令对恢复文件和原文件进行比较</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # diff /tmp/recover/ testfile.10M.dd /tmp/test/ testfile.10M.orig<br><br> 数据明明存在，但是刚才我们为什么没法使用 debugfs 的 dump 命令将数据恢复出来呢？现在使用 debugfs 的 stat 命令再次查看一下索引节点 14 的信息：<br><strong>清单 19. 再次查看索引节点&nbsp;&nbsp;的详细信息</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # echo "stat " | debugfs /dev/sdb6<br> debugfs 1.39 (29-May-2006)<br> Inode: 14&nbsp;&nbsp;Type: regular&nbsp;&nbsp;Mode:&nbsp;&nbsp;0644&nbsp;&nbsp;Flags: 0x0&nbsp; &nbsp;Generation: 2957086760<br> User:&nbsp; &nbsp;&nbsp;&nbsp;0&nbsp; &nbsp;Group:&nbsp; &nbsp;&nbsp;&nbsp;0&nbsp; &nbsp;Size: 10485760<br> File ACL: 0&nbsp; &nbsp; Directory ACL: 0<br> Links: 0&nbsp; &nbsp;Blockcount: 20512<br> Fragment:&nbsp;&nbsp;Address: 0&nbsp; &nbsp; Number: 0&nbsp; &nbsp; Size: 0<br> ctime: 0x47268995 -- Mon Oct 29 20:32:05 2007<br> atime: 0x472684a5 -- Mon Oct 29 20:11:01 2007<br> mtime: 0x47268485 -- Mon Oct 29 20:10:29 2007<br> dtime: 0x47268995 -- Mon Oct 29 20:32:05 2007<br> BLOCKS:<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; (0-11):24576-24587, (IND):24588, (DIND):25613<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; TOTAL: 14<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<br><br> 与前面的结果比较一下不难发现，BLOCKS后面的数据说明总块数为 14，而且也没有整个文件所占据的数据块的详细说明了。既然文件的数据全部都没有发生变化，那么间接寻址所使用的那些索引数据块会不会有问题呢？现在我们 来查看一下 24588 这个间接索引块中的内容：<br><strong>清单 20. 查看间接索引块 24588 中的内容</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> # dd if=/dev/sdb6 of=block. 24588 bs=4096 count=1 skip=24588<br><br> # hexdump block. 24588<br> 0000000 0000 0000 0000 0000 0000 0000 0000 0000<br> *<br> 0001000<br><br> 显然，这个数据块的内容被全部清零了。debugfs 的dump 命令按照原来的寻址方式试图恢复文件时，所访问到的实际上都是第0 个数据块（引导块）中的内容。这个分区不是可引导分区，因此这个数据块中没有写入任何数据，因此 dump 恢复出来的数据只有前48K是正确的，其后所有的数据全部为0。<br> 实际上，ext2 是一种非常优秀的文件系统，在磁盘空间足够的情况下，它总是试图将数据写入到磁盘上的连续数据块中，因此我们可以假定数据是连续存放的，跳过间接索引所占 据的 24588、25613、25614和26639，将从24576 开始的其余 2500 个数据块读出，就能将整个文件完整地恢复出来。但是在磁盘空间有限的情况下，这种假设并不成立，如果系统中磁盘碎片较多，或者同一个块组中已经没有足够大 的空间来保存整个文件，那么文件势必会被保存到一些不连续的数据块中，此时上面的方法就无法正常工作了。<br> 反之，如果在删除文件的时候能够将间接寻址使用的索引数据块中的信息保存下来，那么不管文件在磁盘上是否连续，就都可以将文件完整地恢复出来了，但是这样 就需要修改 ext2 文件系统的实现了。在 ext2 的实现中，与之有关的有两个函数：ext2_free_data 和 ext2_free_branches（都在 fs/ext2/inode.c 中）。2.6 版本内核中这两个函数的实现如下：<br><strong>清单 21. 内核中 ext2_free_data 和 ext2_free_branches 函数的实现</strong><br><br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;<br> 814 /**<br> 815&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;ext2_free_data - free a list of data blocks<br> 816&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@inode: inode we are dealing with<br> 817&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@p:&nbsp; &nbsp;&nbsp;&nbsp;array of block numbers<br> 818&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@q:&nbsp; &nbsp;&nbsp;&nbsp;points immediately past the end of array<br> 819&nbsp;&nbsp;*<br> 820&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;We are freeing all blocks refered from that array (numbers are<br> 821&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;stored as little-endian 32-bit) and updating @inode-&gt;i_blocks<br> 822&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;appropriately.<br> 823&nbsp;&nbsp;*/<br> 824 static inline void ext2_free_data(struct inode *inode, __le32 *p, __le32 *q)<br> 825 {<br> 826&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;unsigned long block_to_free = 0, count = 0;<br> 827&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;unsigned long nr;<br> 828&nbsp;<br> 829&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for ( ; p *p = 0;<br> 833&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; /* accumulate blocks to free if they're contiguous */<br> 834&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; if (count == 0)<br> 835&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;goto free_this;<br> 836&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; else if (block_to_free == nr - count)<br> 837&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;count++;<br> 838&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; else {<br> 839&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;mark_inode_dirty(inode);<br> 840&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ext2_free_blocks (inode, block_to_free, count);<br> 841&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; free_this:<br> 842&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;block_to_free = nr;<br> 843&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;count = 1;<br> 844&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; }<br> 845&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}<br> 846&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;}<br> 847&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if (count &gt; 0) {<br> 848&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;mark_inode_dirty(inode);<br> 849&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ext2_free_blocks (inode, block_to_free, count);<br> 850&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;}<br> 851 }<br> 852&nbsp;<br> 853 /**<br> 854&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;ext2_free_branches - free an array of branches<br> 855&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@inode: inode we are dealing with<br> 856&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@p:&nbsp; &nbsp;&nbsp;&nbsp;array of block numbers<br> 857&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@q:&nbsp; &nbsp;&nbsp;&nbsp;pointer immediately past the end of array<br> 858&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;@depth: depth of the branches to free<br> 859&nbsp;&nbsp;*<br> 860&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;We are freeing all blocks refered from these branches (numbers are<br> 861&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;stored as little-endian 32-bit) and updating @inode-&gt;i_blocks<br> 862&nbsp;&nbsp;*&nbsp; &nbsp;&nbsp; &nbsp;appropriately.<br> 863&nbsp;&nbsp;*/<br> 864 static void ext2_free_branches(struct inode *inode, __le32 *p, __le32 *q, int depth)<br> 865 {<br> 866&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;struct buffer_head * bh;<br> 867&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;unsigned long nr;<br> 868&nbsp;<br> 869&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if (depth--) {<br> 870&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int addr_per_block = EXT2_ADDR_PER_BLOCK(inode-&gt;i_sb);<br> 871&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;for ( ; p *p = 0;<br> 876&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; bh = sb_bread(inode-&gt;i_sb, nr);<br> 877&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; /*<br> 878&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;* A read failure? Report error and clear slot<br> 879&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;* (should be rare).<br> 880&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;*/&nbsp;<br> 881&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; if (!bh) {<br> 882&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ext2_error(inode-&gt;i_sb, "ext2_free_branches",<br> 883&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;"Read failure, inode=%ld, block=%ld",<br> 884&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;inode-&gt;i_ino, nr);<br> 885&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;continue;<br> 886&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; }<br> 887&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ext2_free_branches(inode,<br> 888&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;(__le32*)bh-&gt;b_data,<br> 889&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;(__le32*)bh-&gt;b_data + addr_per_block,<br> 890&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;depth);<br> 891&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; bforget(bh);<br> 892&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ext2_free_blocks(inode, nr, 1);<br> 893&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; mark_inode_dirty(inode);<br> 894&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}<br> 895&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;} else<br> 896&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ext2_free_data(inode, p, q);<br> 897 }<br><br> 注意第 832 和 875 这两行就是用来将对应的索引项置为 0 的。将这两行代码注释掉（对于最新版本的内核 2.6.23 可以下载本文给的补丁）并重新编译 ext2 模块，然后重新加载新编译出来的模块，并重复上面的实验，就会发现利用 debugfs 的 dump 命令又可以完美地恢复出整个文件来了。<br> 显然，这个补丁并不完善，因为这个补丁中的处理只是保留了索引数据块中的索引节点数据，但是还没有考虑数据块位图的处理，如果对应的数据块没有设置为正在 使用的状态，并且刚好这些数据块被重用了，其中的索引节点数据就有可能会被覆盖掉了，这样就彻底没有办法再恢复文件了。感兴趣的读者可以沿用这个思路自行 开发一个比较完善的补丁。<br><br> 参考资料&nbsp;<br><br><a href="http://tldp.org/HOWTO/Ext2fs-Undeletion.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">Linux Ext2fs Undeletion mini-HOWTO</a>&nbsp;<br><br><a href="http://www.oreilly.com/catalog/understandlk/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">Understanding the Linux Kernel</a>&nbsp;<br><br><a href="http://www.kernel.org/pub/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">Linux kernel source code</a>&nbsp;<br><br> 原文链接 ：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/index.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.ibm.com/developerworks/cn/linux/l-cn-filesrc/index.html</a></p> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;font-weight:normal;line-height:1.5;"><br></p> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;font-weight:normal;line-height:1.5;"><br></p> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;font-weight:normal;line-height:1.5;"><br></p> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;font-weight:normal;line-height:1.5;"><br></p> 
    <p style="line-height:1.5;"><font color="#4b4b4b"><span style="font-size:13px;font-weight:normal;">本文转自夏雪冬日博客园博客，原文链接：http://www.cnblogs.com/heyonggang/archive/2013/01/03/2842706.html，如需转载请自行联系原作者</span></font><br></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
