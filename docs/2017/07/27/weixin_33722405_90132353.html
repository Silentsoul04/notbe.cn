<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>浅析linux内核中timer定时器的生成和sofirq软中断调用流程【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://blog.chinaunix.net/uid-20564848-id-73480.html    浅析linux内核中timer定时器的生成和sofirq软中断调用流程 &nbsp;&nbsp;mod_timer添加的定时器timer在内核的软中断中发生调用,__ru...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/07/27/weixin_33722405_90132353.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">浅析linux内核中timer定时器的生成和sofirq软中断调用流程【转】</h1>
    <p class="post-meta">Jul 27, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://blog.chinaunix.net/uid-20564848-id-73480.html" rel="nofollow">http://blog.chinaunix.net/uid-20564848-id-73480.html</a></p> 
   <p><code><span style="color:#000000;">浅析linux内核中timer定时器的生成和sofirq软中断调用流程<br><br> &nbsp;&nbsp;mod_timer添加的定时器timer在内核的软中断中发生调用<span style="color:#0000cc;">,__run_timers会spin_lock_irq<span style="color:#0000cc;">(<span style="color:#0000cc;">&amp;base<span style="color:#0000cc;">-<span style="color:#0000cc;">&gt;lock<span style="color:#0000cc;">)<span style="color:#0000cc;">;禁止cpu中断<span style="color:#0000cc;">,所以我们的timer回调处理函数handler工作在irq关闭的环境中<span style="color:#0000cc;">,所以需要作很多考虑<span style="color:#0000cc;">,比如在handler中尽量不要执行会引起pending的函数调用<span style="color:#0000cc;">,比如kmalloc之类可能引起pending的操作<span style="color:#0000cc;">,否则会使kernel永远停在我们的handler中不能返回<span style="color:#0000cc;">,这样kernel将因为我们ko设计上的失败而死机<span style="color:#0000cc;">[luther<span style="color:#0000cc;">.gliethttp<span style="color:#0000cc;">]<span style="color:#0000cc;">!<br> &nbsp;&nbsp;我们可以使用如下几行语句<span style="color:#0000cc;">,向我们的ko驱动添加一个timer定时器<span style="color:#0000cc;">,来处理时间事件<span style="color:#0000cc;">:<br><span style="color:#0000ff;">struct __wlanwlan_check_tx_flow_timer<br><span style="color:#0000cc;">{<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000ff;">struct timer_list timer<span style="color:#0000cc;">;<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000ff;">int timer_freq<span style="color:#0000cc;">;<br><span style="color:#0000cc;">} wlan_check_tx_flow_timer <span style="color:#0000cc;">= <span style="color:#0000cc;">{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.timer_freq <span style="color:#0000cc;">= 8<span style="color:#0000cc;">*1000<span style="color:#0000cc;">,<br><span style="color:#0000cc;">}<span style="color:#0000cc;">;<br><span style="color:#0000ff;">static <span style="color:#0000ff;">void wlan_check_tx_flow_timer_handler<span style="color:#0000cc;">(<span style="color:#0000ff;">unsigned <span style="color:#0000ff;">long data<span style="color:#0000cc;">)<br><span style="color:#0000cc;">{<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.<span style="color:#0000cc;">.<span style="color:#0000cc;">.<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#ff9900;">//重新启动timer定时器 <br> &nbsp;&nbsp;&nbsp;&nbsp;mod_timer<span style="color:#0000cc;">(<span style="color:#0000cc;">&amp;wlan_check_tx_flow_timer<span style="color:#0000cc;">.timer<span style="color:#0000cc;">, jiffies <span style="color:#0000cc;">+ msecs_to_jiffies<span style="color:#0000cc;">(wlan_check_tx_flow_timer<span style="color:#0000cc;">.timer_freq<span style="color:#0000cc;">)<span style="color:#0000cc;">)<span style="color:#0000cc;">;<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.<span style="color:#0000cc;">.<span style="color:#0000cc;">.<br><span style="color:#0000cc;">}<br><span style="color:#ff9900;">//设置定时器<br> setup_timer<span style="color:#0000cc;">(<span style="color:#0000cc;">&amp;wlan_check_tx_flow_timer<span style="color:#0000cc;">.timer<span style="color:#0000cc;">, wlan_check_tx_flow_timer_handler<span style="color:#0000cc;">, <span style="color:#0000cc;">(<span style="color:#0000ff;">unsigned <span style="color:#0000ff;">long<span style="color:#0000cc;">)<span style="color:#0000cc;">&amp;wlan_check_tx_flow_timer<span style="color:#0000cc;">)<span style="color:#0000cc;">;<br><span style="color:#ff9900;">//添加定时器<br> mod_timer<span style="color:#0000cc;">(<span style="color:#0000cc;">&amp;wlan_check_tx_flow_timer<span style="color:#0000cc;">.timer<span style="color:#0000cc;">, jiffies <span style="color:#0000cc;">+ msecs_to_jiffies<span style="color:#0000cc;">(wlan_check_tx_flow_timer<span style="color:#0000cc;">.timer_freq<span style="color:#0000cc;">)<span style="color:#0000cc;">)<span style="color:#0000cc;">;<br><br> 那么这个wlan_check_tx_flow_timer_handler处理函数在什么时候被调用的呢？那么我们追入内核中<span style="color:#0000cc;">,看看kernel对定时器的具体管理<span style="color:#0000cc;">.<br> 首先kernel在启动的最前面注册TIMER_SOFTIRQ的处理函数<span style="color:#0000cc;">[luther<span style="color:#0000cc;">.gliethttp<span style="color:#0000cc;">]<span style="color:#0000cc;">,<br> start_kernel<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;init_timers<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;open_softirq<span style="color:#0000cc;">(TIMER_SOFTIRQ<span style="color:#0000cc;">, run_timer_softirq<span style="color:#0000cc;">, <span style="color:#ff0000;">NULL<span style="color:#0000cc;">)<span style="color:#0000cc;">;<br> 那么由谁来调用raise_softirq<span style="color:#0000cc;">(TIMER_SOFTIRQ<span style="color:#0000cc;">)<span style="color:#0000cc;">;触发TIMER_SOFTIRQ软中断呢<span style="color:#0000cc;">,这就和平台相关了<span style="color:#0000cc;">,对于pxa935处理器来说<span style="color:#0000cc;">[luther<span style="color:#0000cc;">.gliethttp<span style="color:#0000cc;">]<span style="color:#0000cc;">,<br> MACHINE_START<span style="color:#0000cc;">(LUTHER<span style="color:#0000cc;">, <span style="color:#ff00ff;">"luther"<span style="color:#0000cc;">)<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.phys_io <span style="color:#0000cc;">= 0x40000000<span style="color:#0000cc;">,<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.boot_params <span style="color:#0000cc;">= 0xa0000100<span style="color:#0000cc;">,<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.io_pg_offst <span style="color:#0000cc;">= <span style="color:#0000cc;">(io_p2v<span style="color:#0000cc;">(0x40000000<span style="color:#0000cc;">) <span style="color:#0000cc;">&gt;<span style="color:#0000cc;">&gt; 18<span style="color:#0000cc;">) <span style="color:#0000cc;">&amp; 0xfffc<span style="color:#0000cc;">,<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.map_io <span style="color:#0000cc;">= pxa_map_io<span style="color:#0000cc;">,<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.init_irq <span style="color:#0000cc;">= pxa3xx_init_irq<span style="color:#0000cc;">,<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.timer <span style="color:#0000cc;">= <span style="color:#0000cc;">&amp;pxa_timer<span style="color:#0000cc;">,<br> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#0000cc;">.init_machine <span style="color:#0000cc;">= luther_init<span style="color:#0000cc;">,<br> MACHINE_END<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;pxa_timer_init<span style="color:#ff9900;">//平台对应的定时器初始化<br><span style="color:#0000cc;">=<span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;pxa_timer_irq<span style="color:#0000cc;">.dev_id <span style="color:#0000cc;">= <span style="color:#0000cc;">&amp;ckevt_32ktimer<span style="color:#0000cc;">;<br><span style="color:#0000cc;">=<span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;setup_irq<span style="color:#0000cc;">(IRQ_OST_4_11<span style="color:#0000cc;">, <span style="color:#0000cc;">&amp;pxa_timer_irq<span style="color:#0000cc;">)<span style="color:#0000cc;">; <span style="color:#ff9900;">//32768的rtc<br><span style="color:#0000cc;">=<span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;clockevents_register_device<span style="color:#0000cc;">(<span style="color:#0000cc;">&amp;ckevt_32ktimer<span style="color:#0000cc;">)<span style="color:#0000cc;">;<br><br> pxa_timer_interrupt中断处理函数<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;c<span style="color:#0000cc;">-<span style="color:#0000cc;">&gt;event_handler<span style="color:#0000cc;">(c<span style="color:#0000cc;">)<span style="color:#0000cc;">;也就是tick_handle_periodic系统时钟函数<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;tick_handle_periodic<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;update_process_times<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;run_local_timers<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;raise_softirq<span style="color:#0000cc;">(TIMER_SOFTIRQ<span style="color:#0000cc;">)<span style="color:#0000cc;">;<br> 这里仅仅是触发了TIMER_SOFTIRQ软中断<span style="color:#0000cc;">,那么在什么地方处理我们mod_timer添加的timer定时器处理函数wlan_check_tx_flow_timer_handler呢<span style="color:#0000cc;">[luther<span style="color:#0000cc;">.gliethttp<span style="color:#0000cc;">]？<br> __irq_svc<span style="color:#0000cc;">:<span style="color:#ff9900;">//内核中发生的中断<br> __irq_usr<span style="color:#0000cc;">:<span style="color:#ff9900;">//用户空间时发生的中断<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;asm_do_IRQ<br><span style="color:#0000cc;">=<span style="color:#0000cc;">&gt;irq_exit =&gt;do_softirq =&gt;__do_softirq =&gt;调用上面注册的run_timer_softirq软中断处理函数 =&gt;run_timer_softirq =&gt;__run_timers static inline void __run_timers(struct tvec_base *base) { &nbsp;&nbsp;&nbsp;&nbsp;struct timer_list *timer; &nbsp;&nbsp;&nbsp;&nbsp;spin_lock_irq(&amp;base-&gt;lock);//禁止中断 &nbsp;&nbsp;&nbsp; while (time_after_eq(jiffies, base-&gt;timer_jiffies)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (时间到了) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn = timer-&gt;function; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = timer-&gt;data; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn(data);//这就是我们上面添加的static void wlan_check_tx_flow_timer_handler(unsigned long data);定时器处理函数了. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;set_running_timer(base, NULL); &nbsp;&nbsp;&nbsp;&nbsp;spin_unlock_irq(&amp;base-&gt;lock);//打开中断 } //================ include/asm/hardirq.h typedef struct { &nbsp;&nbsp;&nbsp;&nbsp;unsigned int __softirq_pending; &nbsp;&nbsp;&nbsp;&nbsp;unsigned int local_timer_irqs; } ____cacheline_aligned irq_cpustat_t; //================ kernel/softirq.c|45| irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned; #ifndef __ARCH_IRQ_STAT irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;//在这里定义irq_stat存储空间 EXPORT_SYMBOL(irq_stat); #endif //================ include/linux/irq_cpustat.h #ifndef __ARCH_IRQ_STAT //引用的就是上面的irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned; extern irq_cpustat_t irq_stat[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* defined in asm/hardirq.h */ #define __IRQ_STAT(cpu, member)&nbsp;&nbsp;&nbsp;&nbsp;(irq_stat[cpu].member) #endif //================ arch/arm/kernel/entry-armv.S|331| .word&nbsp;&nbsp;&nbsp;&nbsp;irq_stat #ifdef CONFIG_PREEMPT svc_preempt: &nbsp;&nbsp;&nbsp;&nbsp;teq&nbsp;&nbsp;&nbsp;&nbsp;r8, #0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ was preempt count = 0 &nbsp;&nbsp;&nbsp;&nbsp;ldreq&nbsp;&nbsp;&nbsp;&nbsp;r6, .LCirq_stat //操作 &nbsp;&nbsp;&nbsp;&nbsp;movne&nbsp;&nbsp;&nbsp;&nbsp;pc, lr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ no &nbsp;&nbsp;&nbsp;&nbsp;ldr&nbsp;&nbsp;&nbsp;&nbsp;r0, [r6, #4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ local_irq_count &nbsp;&nbsp;&nbsp;&nbsp;ldr&nbsp;&nbsp;&nbsp;&nbsp;r1, [r6, #8]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ local_bh_count &nbsp;&nbsp;&nbsp;&nbsp;adds&nbsp;&nbsp;&nbsp;&nbsp;r0, r0, r1 &nbsp;&nbsp;&nbsp;&nbsp;movne&nbsp;&nbsp;&nbsp;&nbsp;pc, lr &nbsp;&nbsp;&nbsp;&nbsp;mov&nbsp;&nbsp;&nbsp;&nbsp;r7, #0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ preempt_schedule_irq &nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;r7, [tsk, #TI_PREEMPT]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ expects preempt_count == 0 1:&nbsp;&nbsp;&nbsp;&nbsp;bl&nbsp;&nbsp;&nbsp;&nbsp;preempt_schedule_irq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ irq en/disable is done inside &nbsp;&nbsp;&nbsp;&nbsp;ldr&nbsp;&nbsp;&nbsp;&nbsp;r0, [tsk, #TI_FLAGS]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ get new tasks TI_FLAGS &nbsp;&nbsp;&nbsp;&nbsp;tst&nbsp;&nbsp;&nbsp;&nbsp;r0, #_TIF_NEED_RESCHED &nbsp;&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;&nbsp;&nbsp;preempt_return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ go again &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;1b #endif .LCirq_stat: &nbsp;&nbsp;&nbsp;&nbsp;.word&nbsp;&nbsp;&nbsp;&nbsp;irq_stat //引用irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;地址 #endif &nbsp;&nbsp;/* arch independent irq_stat fields */ #define local_softirq_pending() \ &nbsp;&nbsp;&nbsp;&nbsp;__IRQ_STAT(smp_processor_id(), __softirq_pending) #define __ARCH_IRQ_EXIT_IRQS_DISABLED&nbsp;&nbsp;&nbsp;&nbsp;1 #ifdef __ARCH_IRQ_EXIT_IRQS_DISABLED # define invoke_softirq()&nbsp;&nbsp;&nbsp;&nbsp;__do_softirq() //是这个 #else # define invoke_softirq()&nbsp;&nbsp;&nbsp;&nbsp;do_softirq() #endif #ifndef __ARCH_SET_SOFTIRQ_PENDING #define set_softirq_pending(x) (local_softirq_pending() = (x)) #define or_softirq_pending(x) (local_softirq_pending() |= (x)) #endif #define __raise_softirq_irqoff(nr) do { or_softirq_pending(1UL &lt;&lt; (nr)); } while (0) inline void raise_softirq_irqoff(unsigned int nr) { &nbsp;&nbsp;&nbsp;&nbsp;__raise_softirq_irqoff(nr); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!in_interrupt()) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeup_softirqd(); } void raise_softirq(unsigned int nr) { &nbsp;&nbsp;&nbsp;&nbsp;unsigned long flags; &nbsp;&nbsp;&nbsp;&nbsp;local_irq_save(flags); &nbsp;&nbsp;&nbsp;&nbsp;raise_softirq_irqoff(nr); &nbsp;&nbsp;&nbsp;&nbsp;local_irq_restore(flags); } =&gt;s3c2410_timer_interrupt =&gt;timer_tick =&gt;pxa_timer_init ==&gt;pxa_timer_irq.dev_id = &amp;ckevt_32ktimer; ==&gt;setup_irq(IRQ_OST_4_11, &amp;pxa_timer_irq); //32768的rtc ==&gt;clockevents_register_device(&amp;ckevt_32ktimer); =&gt;clockevents_register_device =&gt;clockevents_do_notify =&gt;raw_notifier_call_chain(&amp;clockevents_chain, reason, dev); =&gt;__raw_notifier_call_chain =&gt;notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call, nr_calls); =&gt;nb-&gt;notifier_call(nb, val, v);就是tick_notify start_kernel =&gt;tick_init static struct notifier_block tick_notifier = { &nbsp;&nbsp;&nbsp;&nbsp;.notifier_call = tick_notify, }; void __init tick_init(void) { &nbsp;&nbsp;&nbsp;&nbsp;clockevents_register_notifier(&amp;tick_notifier); } clockevents_register_notifier =&gt;raw_notifier_chain_register(&amp;clockevents_chain, nb); =&gt;notifier_chain_register将tick_notifier添加到clockevents_chain这个单向链表中[luther.gliethttp] static int tick_notify(struct notifier_block *nb, unsigned long reason, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *dev) { &nbsp;&nbsp;&nbsp;&nbsp;switch (reason) { &nbsp;&nbsp;&nbsp;&nbsp;case CLOCK_EVT_NOTIFY_ADD: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tick_check_new_device(dev); &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;return NOTIFY_OK; } =&gt;tick_notify =&gt;tick_check_new_device =&gt;tick_setup_device(td, newdev, cpu, cpumask); static void tick_setup_device(struct tick_device *td, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct clock_event_device *newdev, int cpu, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpumask_t cpumask) { &nbsp;&nbsp;&nbsp;&nbsp;ktime_t next_event; &nbsp;&nbsp;&nbsp;&nbsp;void (*handler)(struct clock_event_device *) = NULL; &nbsp;&nbsp;&nbsp;&nbsp;/* &nbsp;&nbsp;&nbsp;&nbsp; * First device setup ? &nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp;if (!td-&gt;evtdev) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * If no cpu took the do_timer update, assign it to &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * this cpu: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tick_do_timer_cpu == -1) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_do_timer_cpu = cpu; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_next_period = ktime_get(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_period = ktime_set(0, NSEC_PER_SEC / HZ); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * Startup in periodic mode first. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;td-&gt;mode = TICKDEV_MODE_PERIODIC;//设置第1个tick设备为TICKDEV_MODE_PERIODIC模式 &nbsp;&nbsp;&nbsp; } else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler = td-&gt;evtdev-&gt;event_handler; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_event = td-&gt;evtdev-&gt;next_event; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;td-&gt;evtdev = newdev; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;if (td-&gt;mode == TICKDEV_MODE_PERIODIC) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_setup_periodic(newdev, 0); &nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_setup_oneshot(newdev, handler, next_event); } void tick_setup_periodic(struct clock_event_device *dev, int broadcast) { &nbsp;&nbsp;&nbsp;&nbsp;tick_set_periodic_handler(dev, broadcast);//设置event_handler处理函数为dev-&gt;event_handler = tick_handle_periodic; &nbsp;&nbsp;&nbsp;&nbsp;/* Broadcast setup ? */ &nbsp;&nbsp;&nbsp;&nbsp;if (!tick_device_is_functional(dev)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; &nbsp;&nbsp;&nbsp;&nbsp;if (dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clockevents_set_mode(dev, CLOCK_EVT_MODE_PERIODIC); &nbsp;&nbsp;&nbsp;&nbsp;} else { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long seq; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ktime_t next; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq = read_seqbegin(&amp;xtime_lock); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next = tick_next_period; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} while (read_seqretry(&amp;xtime_lock, seq)); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (;;) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!clockevents_program_event(dev, next, ktime_get())) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next = ktime_add(next, tick_period); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} } void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast) { &nbsp;&nbsp;&nbsp;&nbsp;if (!broadcast) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dev-&gt;event_handler = tick_handle_periodic; &nbsp;&nbsp;&nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dev-&gt;event_handler = tick_handle_periodic_broadcast; } =&gt;pxa_timer_interrupt { &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;if (OSSR &amp; OST_C4) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OIER &amp;= ~OST_C4; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OSSR = OST_C4; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (timer32k_enabled) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c-&gt;event_handler(c);//调用tick_handle_periodic处理函数,作为 &nbsp;&nbsp;&nbsp; } &nbsp;&nbsp;&nbsp;&nbsp;... } void tick_handle_periodic(struct clock_event_device *dev) { &nbsp;&nbsp;&nbsp;&nbsp;int cpu = smp_processor_id(); &nbsp;&nbsp;&nbsp;&nbsp;ktime_t next; &nbsp;&nbsp;&nbsp;&nbsp;tick_periodic(cpu);//调用do_timer(1);将jiffies_64加1 &nbsp;&nbsp;&nbsp;&nbsp;if (dev-&gt;mode != CLOCK_EVT_MODE_ONESHOT) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; &nbsp;&nbsp;&nbsp;&nbsp;/* &nbsp;&nbsp;&nbsp;&nbsp; * Setup the next period for devices, which do not have &nbsp;&nbsp;&nbsp;&nbsp; * periodic mode: &nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp;next = ktime_add(dev-&gt;next_event, tick_period); &nbsp;&nbsp;&nbsp;&nbsp;for (;;) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!clockevents_program_event(dev, next, ktime_get())) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_periodic(cpu); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next = ktime_add(next, tick_period); &nbsp;&nbsp;&nbsp;&nbsp;} } static void tick_periodic(int cpu) { &nbsp;&nbsp;&nbsp;&nbsp;if (tick_do_timer_cpu == cpu) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write_seqlock(&amp;xtime_lock); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Keep track of the next tick event */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tick_next_period = ktime_add(tick_next_period, tick_period); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do_timer(1); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write_sequnlock(&amp;xtime_lock); &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;update_process_times(user_mode(get_irq_regs())); &nbsp;&nbsp;&nbsp;&nbsp;profile_tick(CPU_PROFILING); } arch/arm/kernel/time.c|332| update_process_times(user_mode(get_irq_regs())); =&gt;update_process_times =&gt;run_local_timers =&gt;raise_softirq(TIMER_SOFTIRQ);//触发软中断,当irq_exit时调用__do_softirq来处理 =&gt;run_timer_softirq =&gt;__run_timers =&gt; fn = timer-&gt;function;//执行 data = timer-&gt;data; fn(data); //================ include/asm/arch-pxa/entry-macro.S|22| .macro&nbsp;&nbsp;&nbsp;&nbsp;get_irqnr_and_base, irqnr, irqstat, base, tmp //pxa获取irq中断号函数 //================ arch/arm/kernel/entry-armv.S|37| bne&nbsp;&nbsp;&nbsp;&nbsp;asm_do_IRQ &nbsp;&nbsp;&nbsp;&nbsp;.macro&nbsp;&nbsp;&nbsp;&nbsp;irq_handler &nbsp;&nbsp;&nbsp;&nbsp;get_irqnr_preamble r5, lr 1:&nbsp;&nbsp;&nbsp;&nbsp;get_irqnr_and_base r0, r6, r5, lr //获取irq中断号,存储到r0寄存器中,作为参数传递给asm_do_IRQ &nbsp;&nbsp;&nbsp; movne&nbsp;&nbsp;&nbsp;&nbsp;r1, sp &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;@ routine called with r0 = irq number, r1 = struct pt_regs * &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;adrne&nbsp;&nbsp;&nbsp;&nbsp;lr, 1b &nbsp;&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;&nbsp;&nbsp;asm_do_IRQ &nbsp;&nbsp;&nbsp;&nbsp;... //================ &nbsp;&nbsp;&nbsp; .align&nbsp;&nbsp;&nbsp;&nbsp;5 __irq_svc://内核中发生的中断 &nbsp;&nbsp;&nbsp; svc_entry &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;irq_handler &nbsp;&nbsp;&nbsp;&nbsp;... //================ &nbsp;&nbsp;&nbsp; .align&nbsp;&nbsp;&nbsp;&nbsp;5 __irq_usr://用户空间时发生的中断 &nbsp;&nbsp;&nbsp; usr_entry &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;irq_handler &nbsp;&nbsp;&nbsp;&nbsp;... //================ &nbsp;&nbsp;&nbsp; .macro&nbsp;&nbsp;&nbsp;&nbsp;vector_stub, name, mode, correction=0 &nbsp;&nbsp;&nbsp;&nbsp;.align&nbsp;&nbsp;&nbsp;&nbsp;5 vector_\name: &nbsp;&nbsp;&nbsp;&nbsp;.if \correction &nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;&nbsp;&nbsp;&nbsp;lr, lr, #\correction &nbsp;&nbsp;&nbsp;&nbsp;.endif &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;@ Save r0, lr_&lt;exception&gt; (parent PC) and spsr_&lt;exception&gt; &nbsp;&nbsp;&nbsp;&nbsp;@ (parent CPSR) &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;stmia&nbsp;&nbsp;&nbsp;&nbsp;sp, {r0, lr}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ save r0, lr &nbsp;&nbsp;&nbsp;&nbsp;mrs&nbsp;&nbsp;&nbsp;&nbsp;lr, spsr &nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;&nbsp;&nbsp;&nbsp;lr, [sp, #8]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ save spsr &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;@ Prepare for SVC32 mode. IRQs remain disabled. &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;mrs&nbsp;&nbsp;&nbsp;&nbsp;r0, cpsr &nbsp;&nbsp;&nbsp;&nbsp;eor&nbsp;&nbsp;&nbsp;&nbsp;r0, r0, #(\mode ^ SVC_MODE) &nbsp;&nbsp;&nbsp;&nbsp;msr&nbsp;&nbsp;&nbsp;&nbsp;spsr_cxsf, r0 &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;@ the branch table must immediately follow this code &nbsp;&nbsp;&nbsp;&nbsp;@ &nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;lr, lr, #0x0f //lr存储了spsr,所以一共有16种cpu模式 &nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;r0, sp //传参 &nbsp;&nbsp;&nbsp; ldr&nbsp;&nbsp;&nbsp;&nbsp;lr, [pc, lr, lsl #2]//取出相应模式下的处理函数指针,比如__irq_usr或者__irq_svc &nbsp;&nbsp;&nbsp; movs&nbsp;&nbsp;&nbsp;&nbsp;pc, lr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ branch to handler in SVC mode &nbsp;&nbsp;&nbsp;&nbsp;.endm //================ &nbsp;&nbsp;&nbsp; .globl&nbsp;&nbsp;&nbsp;&nbsp;__stubs_start __stubs_start: /* &nbsp;* Interrupt dispatcher &nbsp;*/ &nbsp;&nbsp;&nbsp;&nbsp;vector_stub&nbsp;&nbsp;&nbsp;&nbsp;irq, IRQ_MODE, 4 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_usr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 0 (USR_26 / USR_32) &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 1 (FIQ_26 / FIQ_32) &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 2 (IRQ_26 / IRQ_32) &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_svc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 3 (SVC_26 / SVC_32) &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 4 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 5 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 6 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 7 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 8 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ 9 &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ a &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ b &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ c &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ d &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ e &nbsp;&nbsp;&nbsp;&nbsp;.long&nbsp;&nbsp;&nbsp;&nbsp;__irq_invalid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ f //================ &nbsp;&nbsp;&nbsp; .globl&nbsp;&nbsp;&nbsp;&nbsp;__vectors_start __vectors_start: &nbsp;&nbsp;&nbsp;&nbsp;swi&nbsp;&nbsp;&nbsp;&nbsp;SYS_ERROR0 &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;vector_und + stubs_offset &nbsp;&nbsp;&nbsp;&nbsp;ldr&nbsp;&nbsp;&nbsp;&nbsp;pc, .LCvswi + stubs_offset &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;vector_pabt + stubs_offset &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;vector_dabt + stubs_offset &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;vector_addrexcptn + stubs_offset &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;vector_irq + stubs_offset &nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;vector_fiq + stubs_offset //================ asm_do_IRQ(unsigned int irq, struct pt_regs *regs) =&gt;desc_handle_irq(irq, desc);// static inline void desc_handle_irq(unsigned int irq, struct irq_desc *desc) { &nbsp;&nbsp;&nbsp;&nbsp;desc-&gt;handle_irq(irq, desc);//调用中断号irq对应的handler回调处理函数[luther.gliethttp] } __irq_svc://内核中发生的中断 __irq_usr://用户空间时发生的中断 =&gt;asm_do_IRQ =&gt;irq_exit =&gt;do_softirq =&gt;__do_softirq =&gt; { &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;h = softirq_vec;//执行软中断函数 &nbsp;&nbsp;&nbsp;&nbsp;do { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pending &amp; 1) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h-&gt;action(h); //如果32768的时间到达,那asm_do_IRQ中将触发raise_softirq(TIMER_SOFTIRQ); //在这里将执行管理系统tick的run_timer_softirq软中断[luther.gliethttp] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_bh_qsctr_inc(cpu); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h++; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pending &gt;&gt;= 1; &nbsp;&nbsp;&nbsp;&nbsp;} while (pending); &nbsp;&nbsp;&nbsp;&nbsp;... } start_kernel =&gt;init_timers =&gt;open_softirq(TIMER_SOFTIRQ, run_timer_softirq, NULL); void open_softirq(int nr, void (*action)(struct softirq_action*), void *data) { &nbsp;&nbsp;&nbsp;&nbsp;softirq_vec[nr].data = data; &nbsp;&nbsp;&nbsp;&nbsp;softirq_vec[nr].action = action; } static void run_timer_softirq(struct softirq_action *h) { &nbsp;&nbsp;&nbsp;&nbsp;struct tvec_base *base = __get_cpu_var(tvec_bases);//获得time时间根 &nbsp;&nbsp;&nbsp;&nbsp;hrtimer_run_pending(); &nbsp;&nbsp;&nbsp;&nbsp;if (time_after_eq(jiffies, base-&gt;timer_jiffies)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__run_timers(base); } //执行软中断 =&gt;run_timer_softirq =&gt;__run_timers =&gt; fn = timer-&gt;function; data = timer-&gt;data; fn(data); static inline void __run_timers(struct tvec_base *base) { &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;spin_lock_irq(&amp;base-&gt;lock);//禁止中断 &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp;fn = timer-&gt;function; &nbsp;&nbsp;&nbsp;&nbsp;data = timer-&gt;data; &nbsp;&nbsp;&nbsp;&nbsp;fn(data); &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;set_running_timer(base, NULL); &nbsp;&nbsp;&nbsp;&nbsp;spin_unlock_irq(&amp;base-&gt;lock);//打开中断 } mod_timer =&gt;__mod_timer int __mod_timer(struct timer_list *timer, unsigned long expires) { &nbsp;&nbsp;&nbsp;&nbsp;struct tvec_base *base, *new_base; &nbsp;&nbsp;&nbsp;&nbsp;unsigned long flags; &nbsp;&nbsp;&nbsp;&nbsp;int ret = 0; &nbsp;&nbsp;&nbsp;&nbsp;timer_stats_timer_set_start_info(timer); &nbsp;&nbsp;&nbsp;&nbsp;BUG_ON(!timer-&gt;function); &nbsp;&nbsp;&nbsp;&nbsp;base = lock_timer_base(timer, &amp;flags); &nbsp;&nbsp;&nbsp;&nbsp;if (timer_pending(timer)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detach_timer(timer, 0); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = 1; &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;new_base = __get_cpu_var(tvec_bases);//获得time时间根 &nbsp;&nbsp;&nbsp;&nbsp;if (base != new_base) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * We are trying to schedule the timer on the local CPU. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * However we can't change timer's base while it is running, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * otherwise del_timer_sync() can't detect that the timer's &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * handler yet has not finished. This also guarantees that &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the timer is serialized wrt itself. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (likely(base-&gt;running_timer != timer)) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* See the comment in lock_timer_base() */ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer_set_base(timer, NULL); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_unlock(&amp;base-&gt;lock); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;base = new_base; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spin_lock(&amp;base-&gt;lock); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer_set_base(timer, base); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;timer-&gt;expires = expires; &nbsp;&nbsp;&nbsp;&nbsp;internal_add_timer(base, timer); //添加到链表上,这样当timer超时到达时,run_timer_softirq=&gt;__run_timers软中断中将会回调该处理函数[luther.gliethttp]. &nbsp;&nbsp;&nbsp; spin_unlock_irqrestore(&amp;base-&gt;lock, flags); &nbsp;&nbsp;&nbsp;&nbsp;return ret; }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
