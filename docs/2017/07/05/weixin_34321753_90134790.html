<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>iOS:转载sqlite3 « NotBeCN</title>
  <meta name="description" content="                       &nbsp;     SQLITE3 使用总结&nbsp;2012-08-21 13:48:28                      分类：&nbsp;SQLite/嵌入式数据库       &nbsp;                          SQL...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/07/05/weixin_34321753_90134790.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">iOS:转载sqlite3</h1>
    <p class="post-meta">Jul 5, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div class="Blog_tit4 Blog_tit5">
     &nbsp;
     <a href="http://blog.chinaunix.net/uid-8447633-id-3321394.html" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">SQLITE3 使用总结</a>&nbsp;2012-08-21 13:48:28
    </div> 
    <div class="Blog_con2"> 
     <div class="Blog_con3"> 
      <p>分类：&nbsp;SQLite/嵌入式数据库</p> 
      <p>&nbsp;</p> 
     </div> 
     <div class="Blog_wz1"> 
      <div class="article_title">
       <a href="http://blog.csdn.net/skywalker256/article/details/4556939" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">SQLITE3 使用总结</a>
      </div> 
      <div class="article_manage">
       2009-09-16 07:36&nbsp;2624人阅读&nbsp;
       <a href="http://blog.csdn.net/skywalker256/article/details/4556939#comments" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">评论</a>(10)&nbsp;
       <a title="收藏" href="http://www.cnblogs.com/" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">收藏</a>&nbsp;
       <a title="举报" href="http://blog.csdn.net/skywalker256/article/details/4556939#report" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">举报</a> 
      </div> 
      <div class="article_content"> 
       <div>
        前序： 
        <p align="left">Sqlite3&nbsp;的确很好用。小巧、速度快。但是因为非微软的产品，帮助文档总觉得不够。这些天再次研究它，又有一些收获，这里把我对&nbsp;sqlite3&nbsp;的研究列出来，以备忘记。</p> 
        <p align="left">这里要注明，我是一个跨平台专注者，并不喜欢只用&nbsp;windows&nbsp;平台。我以前的工作就是为&nbsp;unix&nbsp;平台写代码。下面我所写的东西，虽然没有验证，但是我已尽量不使用任何&nbsp;windows&nbsp;的东西，只使用标准&nbsp;C&nbsp;或标准C++。但是，我没有尝试过在别的系统、别的编译器下编译，因此下面的叙述如果不正确，则留待以后修改。</p> 
        <p align="left">下面我的代码仍然用&nbsp;VC&nbsp;编写，因为我觉得VC是一个很不错的IDE，可以加快代码编写速度（例如配合&nbsp;Vassist&nbsp;）。下面我所说的编译环境，是VC2003。如果读者觉得自己习惯于&nbsp;unix&nbsp;下用&nbsp;vi&nbsp;编写代码速度较快，可以不用管我的说明，只需要符合自己习惯即可，因为我用的是标准&nbsp;C&nbsp;或&nbsp;C++&nbsp;。不会给任何人带来不便。</p> 
        <p align="left">&nbsp;</p> 一、版本 
        <p align="left">从&nbsp;<a href="http://www.sqlite.org/" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">www.sqlite.org</a>&nbsp;网站可下载到最新的&nbsp;sqlite&nbsp;代码和编译版本。我写此文章时，最新代码是&nbsp;3.3.17&nbsp;版本。</p> 
        <p align="left">很久没有去下载&nbsp;sqlite&nbsp;新代码，因此也不知道&nbsp;sqlite&nbsp;变化这么大。以前很多文件，现在全部合并成一个&nbsp;sqlite3.c&nbsp;文件。如果单独用此文件，是挺好的，省去拷贝一堆文件还担心有没有遗漏。但是也带来一个问题：此文件太大，快接近7万行代码，VC开它整个机器都慢下来了。如果不需要改它代码，也就不需要打开&nbsp;sqlite3.c&nbsp;文件，机器不会慢。但是，下面我要写通过修改&nbsp;sqlite&nbsp;代码完成加密功能，那时候就比较痛苦了。如果个人水平较高，建议用些简单的编辑器来编辑，例如UltraEdit&nbsp;或&nbsp;Notepad&nbsp;。速度会快很多。</p> 
        <p align="left">&nbsp;</p> 二、基本编译 
        <p align="left">这个不想多说了，在&nbsp;VC&nbsp;里新建&nbsp;dos&nbsp;控制台空白工程，把&nbsp;sqlite3.c&nbsp;和&nbsp;sqlite3.h&nbsp;添加到工程，再新建一个&nbsp;main.cpp文件。在里面写:</p> 
        <p align="left">extern&nbsp;"C"</p> 
        <p align="left">{</p> 
        <p align="left">#include&nbsp;"./sqlite3.h"</p> 
        <p align="left">};</p> 
        <p align="left">int main( int , char** )</p> 
        <p align="left">{</p> 
        <p align="left">return&nbsp;0;</p> 
        <p align="left">}</p> 
        <p align="left">为什么要&nbsp;extern “C”&nbsp;？如果问这个问题，我不想说太多，这是C++的基础。要在&nbsp;C++&nbsp;里使用一段&nbsp;C&nbsp;的代码，必须要用&nbsp;extern “C”&nbsp;括起来。C++跟&nbsp;C虽然语法上有重叠，但是它们是两个不同的东西，内存里的布局是完全不同的，在C++编译器里不用extern “C”括起C代码，会导致编译器不知道该如何为&nbsp;C&nbsp;代码描述内存布局。</p> 
        <p align="left">可能在&nbsp;sqlite3.c&nbsp;里人家已经把整段代码都&nbsp;extern “C”&nbsp;括起来了，但是你遇到一个&nbsp;.c&nbsp;文件就自觉的再括一次，也没什么不好。</p> 
        <p align="left">基本工程就这样建立起来了。编译，可以通过。但是有一堆的&nbsp;warning。可以不管它。</p> 
        <p align="left">&nbsp;</p> 三、SQLITE操作入门 
        <p align="left">sqlite提供的是一些C函数接口，你可以用这些函数操作数据库。通过使用这些接口，传递一些标准&nbsp;sql&nbsp;语句（以&nbsp;char *&nbsp;类型）给&nbsp;sqlite&nbsp;函数，sqlite&nbsp;就会为你操作数据库。</p> 
        <p align="left">sqlite&nbsp;跟MS的access一样是文件型数据库，就是说，一个数据库就是一个文件，此数据库里可以建立很多的表，可以建立索引、触发器等等，但是，它实际上得到的就是一个文件。备份这个文件就备份了整个数据库。</p> 
        <p align="left">sqlite&nbsp;不需要任何数据库引擎，这意味着如果你需要&nbsp;sqlite&nbsp;来保存一些用户数据，甚至都不需要安装数据库(如果你做个小软件还要求人家必须装了sqlserver&nbsp;才能运行，那也太黑心了)。</p> 
        <p align="left">下面开始介绍数据库基本操作。</p> 1&nbsp;基本流程（1）关键数据结构 
        <p align="left">sqlite&nbsp;里最常用到的是&nbsp;sqlite3 *&nbsp;类型。从数据库打开开始，sqlite就要为这个类型准备好内存，直到数据库关闭，整个过程都需要用到这个类型。当数据库打开时开始，这个类型的变量就代表了你要操作的数据库。下面再详细介绍。</p> （2）打开数据库 
        <p align="left">int&nbsp;sqlite3_open(&nbsp;文件名, sqlite3 ** );</p> 
        <p align="left">用这个函数开始数据库操作。</p> 
        <p align="left">需要传入两个参数，一是数据库文件名，比如：c://DongChunGuang_Database.db。</p> 
        <p align="left">文件名不需要一定存在，如果此文件不存在，sqlite&nbsp;会自动建立它。如果它存在，就尝试把它当数据库文件来打开。</p> 
        <p align="left">sqlite3 **&nbsp;参数即前面提到的关键数据结构。这个结构底层细节如何，你不要关它。</p> 
        <p align="left">函数返回值表示操作是否正确，如果是&nbsp;SQLITE_OK&nbsp;则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考&nbsp;sqlite3.h&nbsp;文件。里面有详细定义（顺便说一下，sqlite3&nbsp;的代码注释率自称是非常高的，实际上也的确很高。只要你会看英文，sqlite&nbsp;可以让你学到不少东西）。</p> 
        <p align="left">下面介绍关闭数据库后，再给一段参考代码。</p> （3）关闭数据库 
        <p align="left">int&nbsp;sqlite3_close(sqlite3 *);</p> 
        <p align="left">前面如果用&nbsp;sqlite3_open&nbsp;开启了一个数据库，结尾时不要忘了用这个函数关闭数据库。</p> 
        <p align="left">下面给段简单的代码：</p> 
        <p align="left">extern&nbsp;"C"</p> 
        <p align="left">{</p> 
        <p align="left">#include&nbsp;"./sqlite3.h"</p> 
        <p align="left">};</p> 
        <p align="left">int main( int , char** )</p> 
        <p align="left">{</p> 
        <p align="left">&nbsp;&nbsp;&nbsp;sqlite3 * db = NULL;&nbsp;//声明sqlite关键结构指针</p> 
        <p align="left">&nbsp;&nbsp;&nbsp;int result;</p> 
        <p align="left">&nbsp;</p> 
        <p align="left">//打开数据库</p> 
        <p align="left">//需要传入&nbsp;db&nbsp;这个指针的指针，因为&nbsp;sqlite3_open&nbsp;函数要为这个指针分配内存，还要让db指针指向这个内存区</p> 
        <p align="left">&nbsp;&nbsp;&nbsp;result = sqlite3_open(&nbsp;“c://Dcg_database.db”, &amp;db );</p> 
        <p align="left">&nbsp;&nbsp;&nbsp;if( result !=&nbsp;SQLITE_OK&nbsp;)</p> 
        <p align="left">&nbsp;&nbsp;&nbsp;{</p> 
        <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;//数据库打开失败</p> 
        <p align="left">return -1;</p> 
        <p align="left">}</p> 
        <p align="left">//数据库操作代码</p> 
        <p align="left">//…</p> 
        <p align="left">&nbsp;</p> 
        <p align="left">//数据库打开成功</p> 
        <p align="left">//关闭数据库</p> 
        <p align="left">sqlite3_close( db );</p> 
        <p align="left">return&nbsp;0;</p> 
        <p align="left">}</p> 
        <p align="left">这就是一次数据库操作过程。</p> 
        <p align="left">&nbsp;</p> 
        <p align="left">&nbsp;</p> 
        <div>
         2 SQL语句操作 
         <p align="left">本节介绍如何用sqlite&nbsp;执行标准&nbsp;sql&nbsp;语法。</p> 
         <p align="left">&nbsp;</p> （1）执行sql语句 
         <p align="left">int&nbsp;sqlite3_exec(sqlite3*,&nbsp;const&nbsp;char&nbsp;*sql, sqlite3_callback,&nbsp;void&nbsp;*,&nbsp;&nbsp;char&nbsp;**errmsg );</p> 
         <p align="left">这就是执行一条&nbsp;sql&nbsp;语句的函数。</p> 
         <p align="left">第1个参数不再说了，是前面open函数得到的指针。说了是关键数据结构。</p> 
         <p align="left">第2个参数const char *sql&nbsp;是一条&nbsp;sql&nbsp;语句，以/0结尾。</p> 
         <p align="left">第3个参数sqlite3_callback&nbsp;是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。（什么是回调函数，自己找别的资料学习）</p> 
         <p align="left">第4个参数void *&nbsp;是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。等下我们再看回调函数的写法，以及这个参数的使用。</p> 
         <p align="left">第5个参数char ** errmsg&nbsp;是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行&nbsp;sqlite3_exec&nbsp;之后，执行失败时可以查阅这个指针（直接&nbsp;printf(“%s/n”,errmsg)）得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个&nbsp;char*得到具体错误提示。</p> 
         <p align="left">说明：通常，sqlite3_callback&nbsp;和它后面的&nbsp;void *&nbsp;这两个位置都可以填&nbsp;NULL。填NULL表示你不需要回调。比如你做insert&nbsp;操作，做&nbsp;delete&nbsp;操作，就没有必要使用回调。而当你做&nbsp;select&nbsp;时，就要使用回调，因为&nbsp;sqlite3&nbsp;把数据查出来，得通过回调告诉你查出了什么数据。</p> （2）exec&nbsp;的回调 
         <p align="left">typedef&nbsp;int&nbsp;(*sqlite3_callback)(void*,int,char**,&nbsp;char**);</p> 
         <p align="left">你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：</p> 
         <p align="left">//sqlite3的回调函数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
         <p align="left">// sqlite&nbsp;每查到一条记录，就调用一次这个回调</p> 
         <p align="left">int&nbsp;LoadMyInfo(&nbsp;void&nbsp;* para,&nbsp;int&nbsp;n_column,&nbsp;char&nbsp;** column_value,&nbsp;char&nbsp;** column_name )</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//para是你在&nbsp;sqlite3_exec&nbsp;里传入的&nbsp;void *&nbsp;参数</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//n_column是这一条记录有多少个字段&nbsp;(即这条记录有多少列)</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;// char ** column_value&nbsp;是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），每一个元素都是一个&nbsp;char *&nbsp;值，是一个字段内容（用字符串来表示，以/0结尾）</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//char ** column_name&nbsp;跟&nbsp;column_value是对应的，表示这个字段的字段名称</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;//这里，我不使用&nbsp;para&nbsp;参数。忽略它的存在.</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;int i;</p> 
         <p align="left">printf(&nbsp;“记录包含&nbsp;%d&nbsp;个字段/n”, n_column );</p> 
         <p align="left">for( i = 0 ; i &lt; n_column; i ++ )</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“字段名:%s&nbsp;&nbsp;ß&gt;&nbsp;字段值:%s/n”,&nbsp;&nbsp;column_name[i], column_value[i] );</p> 
         <p align="left">}</p> 
         <p align="left">printf(&nbsp;“------------------/n“&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
         <p align="left">return 0;</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">int main( int , char ** )</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;sqlite3 * db;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;int result;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;char * errmsg = NULL;</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;result = sqlite3_open(&nbsp;“c://Dcg_database.db”, &amp;db );</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;if( result !=&nbsp;SQLITE_OK&nbsp;)</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据库打开失败</p> 
         <p align="left">return -1;</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">//数据库操作代码</p> 
         <p align="left">//创建一个测试表，表名叫&nbsp;MyTable_1，有2个字段：&nbsp;ID&nbsp;和&nbsp;name。其中ID是一个自动增加的类型，以后insert时可以不去指定这个字段，它会自己从0开始增加</p> 
         <p align="left">result = sqlite3_exec( db,&nbsp;“create table MyTable_1( ID integer primary key autoincrement, name nvarchar(32) )”, NULL, NULL, errmsg );</p> 
         <p align="left">if(result !=&nbsp;SQLITE_OK&nbsp;)</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“创建表失败，错误码:%d，错误原因:%s/n”, result, errmsg );</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">//插入一些记录</p> 
         <p align="left">result = sqlite3_exec( db,&nbsp;“insert into MyTable_1( name ) values (&nbsp;‘走路’&nbsp;)”, 0, 0, errmsg );</p> 
         <p align="left">if(result !=&nbsp;SQLITE_OK&nbsp;)</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">result = sqlite3_exec( db,&nbsp;“insert into MyTable_1( name ) values (&nbsp;‘骑单车’&nbsp;)”, 0, 0, errmsg );</p> 
         <p align="left">if(result !=&nbsp;SQLITE_OK&nbsp;)</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">result = sqlite3_exec( db,&nbsp;“insert into MyTable_1( name ) values (&nbsp;‘坐汽车’&nbsp;)”, 0, 0, errmsg );</p> 
         <p align="left">if(result !=&nbsp;SQLITE_OK&nbsp;)</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">//开始查询数据库</p> 
         <p align="left">result = sqlite3_exec( db,&nbsp;“select * from MyTable_1”, LoadMyInfo, NULL, errmsg );</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">//关闭数据库</p> 
         <p align="left">sqlite3_close( db );</p> 
         <p align="left">return&nbsp;0;</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">通过上面的例子，应该可以知道如何打开一个数据库，如何做数据库基本操作。</p> 
         <p align="left">有这些知识，基本上可以应付很多数据库操作了。</p> 
         <p align="left">&nbsp;</p> （3）不使用回调查询数据库 
         <p align="left">上面介绍的&nbsp;sqlite3_exec&nbsp;是使用回调来执行&nbsp;select&nbsp;操作。还有一个方法可以直接查询而不需要回调。但是，我个人感觉还是回调好，因为代码可以更加整齐，只不过用回调很麻烦，你得声明一个函数，如果这个函数是类成员函数，你还不得不把它声明成&nbsp;static&nbsp;的（要问为什么？这又是C++基础了。C++成员函数实际上隐藏了一个参数：this，C++调用类的成员函数的时候，隐含把类指针当成函数的第一个参数传递进去。结果，这造成跟前面说的&nbsp;sqlite&nbsp;回调函数的参数不相符。只有当把成员函数声明成&nbsp;static&nbsp;时，它才没有多余的隐含的this参数）。</p> 
         <p align="left">虽然回调显得代码整齐，但有时候你还是想要非回调的&nbsp;select&nbsp;查询。这可以通过&nbsp;sqlite3_get_table&nbsp;函数做到。</p> 
         <p align="left">int&nbsp;sqlite3_get_table(sqlite3*,&nbsp;const&nbsp;char&nbsp;*sql,&nbsp;char&nbsp;***resultp,&nbsp;int&nbsp;*nrow,&nbsp;int&nbsp;*ncolumn,&nbsp;char&nbsp;**errmsg );</p> 
         <p align="left">第1个参数不再多说，看前面的例子。</p> 
         <p align="left">第2个参数是&nbsp;sql&nbsp;语句，跟&nbsp;sqlite3_exec&nbsp;里的&nbsp;sql&nbsp;是一样的。是一个很普通的以/0结尾的char *字符串。</p> 
         <p align="left">第3个参数是查询结果，它依然一维数组（不要以为是二维数组，更不要以为是三维数组）。它内存布局是：第一行是字段名称，后面是紧接着是每个字段的值。下面用例子来说事。</p> 
         <p align="left">第4个参数是查询出多少条记录（即查出多少行）。</p> 
         <p align="left">第5个参数是多少个字段（多少列）。</p> 
         <p align="left">第6个参数是错误信息，跟前面一样，这里不多说了。</p> 
         <p align="left">下面给个简单例子:</p> 
         <p align="left">int main( int , char ** )</p> 
         <p align="left">{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;sqlite3 * db;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int result;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;char * errmsg = NULL;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;char **dbResult;&nbsp;//是&nbsp;char **&nbsp;类型，两个*号</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int nRow, nColumn;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int i , j;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int index;</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;result =&nbsp;sqlite3_open(&nbsp;“c://Dcg_database.db”, &amp;db );</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;if( result !=&nbsp;SQLITE_OK&nbsp;)</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据库打开失败</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//数据库操作代码</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//假设前面已经创建了&nbsp;MyTable_1&nbsp;表</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//开始查询，传入的&nbsp;dbResult&nbsp;已经是&nbsp;char **，这里又加了一个&nbsp;&amp;&nbsp;取地址符，传递进去的就成了&nbsp;char ***</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;result =&nbsp;sqlite3_get_table( db,&nbsp;“select * from MyTable_1”, &amp;dbResult, &amp;nRow, &amp;nColumn, &amp;errmsg );</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;if(&nbsp;SQLITE_OK&nbsp;== result )</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//查询成功</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = nColumn;&nbsp;//前面说过&nbsp;dbResult&nbsp;前面第一行数据是字段名称，从&nbsp;nColumn&nbsp;索引开始才是真正的数据</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“查到%d条记录/n”, nRow );</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;&nbsp;i = 0; i &lt; nRow ; i++ )</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“第&nbsp;%d&nbsp;条记录/n”, i+1 );</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j = 0 ; j &lt; nColumn; j++ )</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“字段名:%s&nbsp;&nbsp;ß&gt;&nbsp;字段值:%s/n”,&nbsp;&nbsp;dbResult[j], dbResult [index] );</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++index;&nbsp;// dbResult&nbsp;的字段值是连续的，从第0索引到第&nbsp;nColumn - 1索引都是字段名称，从第&nbsp;nColumn&nbsp;索引开始，后面都是字段值，它把一个二维的表（传统的行列表示法）用一个扁平的形式来表示</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&nbsp;“-------/n”&nbsp;);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//到这里，不论数据库查询是否成功，都释放&nbsp;char**&nbsp;查询结果，使用&nbsp;sqlite&nbsp;提供的功能来释放</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;sqlite3_free_table( dbResult );</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;//关闭数据库</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;sqlite3_close( db );</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;return&nbsp;0;</p> 
         <p align="left">}</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">到这个例子为止，sqlite3&nbsp;的常用用法都介绍完了。</p> 
         <p align="left">用以上的方法，再配上&nbsp;sql&nbsp;语句，完全可以应付绝大多数数据库需求。</p> 
         <p align="left">但有一种情况，用上面方法是无法实现的：需要insert、select&nbsp;二进制。当需要处理二进制数据时，上面的方法就没办法做到。下面这一节说明如何插入二进制数据</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;</p> 
         <div>
          3&nbsp;操作二进制 
          <p align="left">sqlite&nbsp;操作二进制数据需要用一个辅助的数据类型：sqlite3_stmt *&nbsp;。</p> 
          <p align="left">这个数据类型记录了一个“sql语句”。为什么我把&nbsp;“sql语句”&nbsp;用双引号引起来？因为你可以把&nbsp;sqlite3_stmt *&nbsp;所表示的内容看成是&nbsp;sql语句，但是实际上它不是我们所熟知的sql语句。它是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。</p> 
          <p align="left">正因为这个结构已经被解析了，所以你可以往这个语句里插入二进制数据。当然，把二进制数据插到&nbsp;sqlite3_stmt&nbsp;结构里可不能直接&nbsp;memcpy&nbsp;，也不能像&nbsp;std::string&nbsp;那样用&nbsp;+&nbsp;号。必须用&nbsp;sqlite&nbsp;提供的函数来插入。</p> 
          <p align="left">&nbsp;</p> （1）写入二进制 
          <p align="left">下面说写二进制的步骤。</p> 
          <p align="left">要插入二进制，前提是这个表的字段的类型是&nbsp;blob&nbsp;类型。我假设有这么一张表：</p> 
          <p align="left">create table Tbl_2( ID integer, file_content&nbsp;&nbsp;blob )</p> 
          <p align="left">首先声明</p> 
          <p align="left">sqlite3_stmt&nbsp;* stat;</p> 
          <p align="left">然后，把一个&nbsp;sql&nbsp;语句解析到&nbsp;stat&nbsp;结构里去：</p> 
          <p align="left">sqlite3_prepare( db,&nbsp;“insert into Tbl_2( ID, file_content) values( 10, ? )”, -1, &amp;stat, 0 );</p> 
          <p align="left">上面的函数完成&nbsp;sql&nbsp;语句的解析。第一个参数跟前面一样，是个&nbsp;sqlite3 *&nbsp;类型变量，第二个参数是一个&nbsp;sql&nbsp;语句。</p> 
          <p align="left">这个&nbsp;sql&nbsp;语句特别之处在于&nbsp;values&nbsp;里面有个&nbsp;?&nbsp;号。在sqlite3_prepare函数里，?号表示一个未定的值，它的值等下才插入。</p> 
          <p align="left">第三个参数我写的是-1，这个参数含义是前面&nbsp;sql&nbsp;语句的长度。如果小于0，sqlite会自动计算它的长度（把sql语句当成以/0结尾的字符串）。</p> 
          <p align="left">第四个参数是&nbsp;sqlite3_stmt&nbsp;的指针的指针。解析以后的sql语句就放在这个结构里。</p> 
          <p align="left">第五个参数我也不知道是干什么的。为0就可以了。</p> 
          <p align="left">如果这个函数执行成功（返回值是&nbsp;SQLITE_OK&nbsp;且&nbsp;stat&nbsp;不为NULL&nbsp;），那么下面就可以开始插入二进制数据。</p> 
          <p align="left">sqlite3_bind_blob( stat, 1, pdata, (int)(length_of_data_in_bytes), NULL );&nbsp;//&nbsp;pdata为数据缓冲区，length_of_data_in_bytes为数据大小，以字节为单位</p> 
          <p align="left">这个函数一共有5个参数。</p> 
          <p align="left">第1个参数：是前面prepare得到的&nbsp;sqlite3_stmt *&nbsp;类型变量。</p> 
          <p align="left">第2个参数：?号的索引。前面prepare的sql语句里有一个?号，假如有多个?号怎么插入？方法就是改变&nbsp;bind_blob&nbsp;函数第2个参数。这个参数我写1，表示这里插入的值要替换&nbsp;stat&nbsp;的第一个?号（这里的索引从1开始计数，而非从0开始）。如果你有多个?号，就写多个&nbsp;bind_blob&nbsp;语句，并改变它们的第2个参数就替换到不同的?号。如果有?号没有替换，sqlite为它取值null。</p> 
          <p align="left">第3个参数：二进制数据起始指针。</p> 
          <p align="left">第4个参数：二进制数据的长度，以字节为单位。</p> 
          <p align="left">第5个参数：是个析够回调函数，告诉sqlite当把数据处理完后调用此函数来析够你的数据。这个参数我还没有使用过，因此理解也不深刻。但是一般都填NULL，需要释放的内存自己用代码来释放。</p> 
          <p align="left">bind完了之后，二进制数据就进入了你的“sql语句”里了。你现在可以把它保存到数据库里：</p> 
          <p align="left">int result =&nbsp;sqlite3_step( stat );</p> 
          <p align="left">通过这个语句，stat&nbsp;表示的sql语句就被写到了数据库里。</p> 
          <p align="left">最后，要把&nbsp;sqlite3_stmt&nbsp;结构给释放：</p> 
          <p align="left">sqlite3_finalize( stat );&nbsp;//把刚才分配的内容析构掉</p> 
          <p align="left">&nbsp;</p> （2）读出二进制 
          <p align="left">下面说读二进制的步骤。</p> 
          <p align="left">跟前面一样，先声明&nbsp;sqlite3_stmt *&nbsp;类型变量：</p> 
          <p align="left">sqlite3_stmt&nbsp;* stat;</p> 
          <p align="left">然后，把一个&nbsp;sql&nbsp;语句解析到&nbsp;stat&nbsp;结构里去：</p> 
          <p align="left">sqlite3_prepare( db,&nbsp;“select * from Tbl_2”, -1, &amp;stat, 0 );</p> 
          <p align="left">当&nbsp;prepare&nbsp;成功之后（返回值是&nbsp;SQLITE_OK&nbsp;），开始查询数据。</p> 
          <p align="left">int result =&nbsp;sqlite3_step( stat );</p> 
          <p align="left">这一句的返回值是SQLITE_ROW&nbsp;时表示成功（不是&nbsp;SQLITE_OK&nbsp;）。</p> 
          <p align="left">你可以循环执行sqlite3_step&nbsp;函数，一次step查询出一条记录。直到返回值不为&nbsp;SQLITE_ROW&nbsp;时表示查询结束。</p> 
          <p align="left">然后开始获取第一个字段：ID&nbsp;的值。ID是个整数，用下面这个语句获取它的值：</p> 
          <p align="left">int id = sqlite3_column_int( stat, 0 );&nbsp;//第2个参数表示获取第几个字段内容，从0开始计算，因为我的表的ID字段是第一个字段，因此这里我填0</p> 
          <p align="left">&nbsp;</p> 
          <p align="left">下面开始获取&nbsp;file_content&nbsp;的值，因为&nbsp;file_content&nbsp;是二进制，因此我需要得到它的指针，还有它的长度：</p> 
          <p align="left">const void * pFileContent =&nbsp;sqlite3_column_blob( stat, 1 );</p> 
          <p align="left">int len =&nbsp;sqlite3_column_bytes( stat, 1 );</p> 
          <p align="left">这样就得到了二进制的值。</p> 
          <p align="left">把&nbsp;pFileContent&nbsp;的内容保存出来之后，不要忘了释放&nbsp;sqlite3_stmt&nbsp;结构：</p> 
          <p align="left">sqlite3_finalize( stat );&nbsp;//把刚才分配的内容析构掉</p> 
          <p align="left">&nbsp;</p> （3）重复使用&nbsp;sqlite3_stmt&nbsp;结构 
          <p align="left">如果你需要重复使用&nbsp;sqlite3_prepare&nbsp;解析好的&nbsp;sqlite3_stmt&nbsp;结构，需要用函数：&nbsp;sqlite3_reset。</p> 
          <p align="left">result =&nbsp;sqlite3_reset(stat);</p> 
          <p align="left">这样，&nbsp;stat&nbsp;结构又成为&nbsp;sqlite3_prepare&nbsp;完成时的状态，你可以重新为它&nbsp;bind&nbsp;内容。</p> 4&nbsp;事务处理 
          <p align="left">sqlite&nbsp;是支持事务处理的。如果你知道你要同步删除很多数据，不仿把它们做成一个统一的事务。</p> 
          <p align="left">通常一次&nbsp;sqlite3_exec&nbsp;就是一次事务，如果你要删除1万条数据，sqlite就做了1万次：开始新事务-&gt;删除一条数据-&gt;提交事务-&gt;开始新事务-&gt;…&nbsp;的过程。这个操作是很慢的。因为时间都花在了开始事务、提交事务上。</p> 
          <p align="left">你可以把这些同类操作做成一个事务，这样如果操作错误，还能够回滚事务。</p> 
          <p align="left">事务的操作没有特别的接口函数，它就是一个普通的&nbsp;sql&nbsp;语句而已：</p> 
          <p align="left">分别如下：</p> 
          <p align="left">int result;&nbsp;</p> 
          <p align="left">result&nbsp;= sqlite3_exec( db, "begin transaction", 0, 0, &amp;zErrorMsg ); //开始一个事务</p> 
          <p align="left">result&nbsp;= sqlite3_exec( db, "commit transaction", 0, 0, &amp;zErrorMsg ); //提交事务</p> 
          <p align="left">result&nbsp;= sqlite3_exec( db, "rollback transaction", 0, 0, &amp;zErrorMsg ); //回滚事务</p> 
         </div> 四、C/C++开发接口简介1&nbsp;总览 
         <p align="left">SQLite3是SQLite一个全新的版本,它虽然是在SQLite 2.8.13的代码基础之上开发的,但是使用了和之前的版本不兼容的数据库格式和API. SQLite3是为了满足以下的需求而开发的:</p> 
         <ul>
          <li style="list-style:disc;">支持UTF-16编码.</li> 
          <li style="list-style:disc;">用户自定义的文本排序方法.</li> 
          <li style="list-style:disc;">可以对BLOBs字段建立索引.</li> 
         </ul>
         <p align="left">因此为了支持这些特性我改变了数据库的格式,建立了一个与之前版本不兼容的3.0版.&nbsp;至于其他的兼容性的改变,例如全新的API等等,都将在理论介绍之后向你说明,这样可以使你最快的一次性摆脱兼容性问题.</p> 
         <p align="left">3.0版的和2.X版的API非常相似,但是有一些重要的改变需要注意.&nbsp;所有API接口函数和数据结构的前缀都由"sqlite_"改为了"sqlite3_".&nbsp;这是为了避免同时使用SQLite 2.X和SQLite 3.0这两个版本的时候发生链接冲突.</p> 
         <p align="left">由于对于C语言应该用什么数据类型来存放UTF-16编码的字符串并没有一致的规范.&nbsp;因此SQLite使用了普通的void*&nbsp;类型来指向UTF-16编码的字符串.&nbsp;客户端使用过程中可以把void*映射成适合他们的系统的任何数据类型.</p> 2 C/C++接口 
         <p align="left">SQLite 3.0一共有83个API函数,此外还有一些数据结构和预定义(#defines). (完整的API介绍请参看另一份文档.)&nbsp;不过你们可以放心,这些接口使用起来不会像它的数量所暗示的那么复杂.&nbsp;最简单的程序仍然使用三个函数就可以完成: sqlite3_open(), sqlite3_exec(),&nbsp;和&nbsp;sqlite3_close().&nbsp;要是想更好的控制数据库引擎的执行,可以使用提供的sqlite3_prepare()函数把SQL语句编译成字节码,然后在使用sqlite3_step()函数来执行编译后的字节码.&nbsp;以sqlite3_column_开头的一组API函数用来获取查询结果集中的信息.&nbsp;许多接口函数都是成对出现的,同时有UTF-8和UTF-16两个版本.&nbsp;并且提供了一组函数用来执行用户自定义的SQL函数和文本排序函数.</p> （1）如何打开关闭数据库 
         <p align="left">&nbsp;&nbsp;&nbsp;typedef struct sqlite3 sqlite3;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int sqlite3_open(const char*, sqlite3**);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int sqlite3_open16(const void*, sqlite3**);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int sqlite3_close(sqlite3*);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;const char *sqlite3_errmsg(sqlite3*);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;const void *sqlite3_errmsg16(sqlite3*);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int sqlite3_errcode(sqlite3*);</p> 
         <p align="left">sqlite3_open()&nbsp;函数返回一个整数错误代码,而不是像第二版中一样返回一个指向sqlite3结构体的指针. sqlite3_open()&nbsp;和sqlite3_open16()&nbsp;的不同之处在于sqlite3_open16()&nbsp;使用UTF-16编码(使用本地主机字节顺序)传递数据库文件名.&nbsp;如果要创建新数据库, sqlite3_open16()&nbsp;将内部文本转换为UTF-16编码,&nbsp;反之sqlite3_open()&nbsp;将文本转换为UTF-8编码.</p> 
         <p align="left">打开或者创建数据库的命令会被缓存,直到这个数据库真正被调用的时候才会被执行.&nbsp;而且允许使用PRAGMA声明来设置如本地文本编码或默认内存页面大小等选项和参数.</p> 
         <p align="left">sqlite3_errcode()&nbsp;通常用来获取最近调用的API接口返回的错误代码. sqlite3_errmsg()&nbsp;则用来得到这些错误代码所对应的文字说明.&nbsp;这些错误信息将以&nbsp;UTF-8&nbsp;的编码返回,并且在下一次调用任何SQLite API函数的时候被清除. sqlite3_errmsg16()&nbsp;和sqlite3_errmsg()&nbsp;大体上相同,除了返回的错误信息将以&nbsp;UTF-16&nbsp;本机字节顺序编码.</p> 
         <p align="left">SQLite3的错误代码相比SQLite2没有任何的改变,它们分别是:</p> 
         <p align="left">#define SQLITE_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;/* Successful result */</p> 
         <p align="left">#define SQLITE_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;/* SQL error or missing database */</p> 
         <p align="left">#define SQLITE_INTERNAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;/* An internal logic error in SQLite */</p> 
         <p align="left">#define SQLITE_PERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;/* Access permission denied */</p> 
         <p align="left">#define SQLITE_ABORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;/* Callback routine requested an abort */</p> 
         <p align="left">#define SQLITE_BUSY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;/* The database file is locked */</p> 
         <p align="left">#define SQLITE_LOCKED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;/* A table in the database is locked */</p> 
         <p align="left">#define SQLITE_NOMEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;/* A malloc() failed */</p> 
         <p align="left">#define SQLITE_READONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;/* Attempt to write a readonly database */</p> 
         <p align="left">#define SQLITE_INTERRUPT&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;/* Operation terminated by sqlite_interrupt() */</p> 
         <p align="left">#define SQLITE_IOERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;/* Some kind of disk I/O error occurred */</p> 
         <p align="left">#define SQLITE_CORRUPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;/* The database disk image is malformed */</p> 
         <p align="left">#define SQLITE_NOTFOUND&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;/* (Internal Only) Table or record not found */</p> 
         <p align="left">#define SQLITE_FULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;/* Insertion failed because database is full */</p> 
         <p align="left">#define SQLITE_CANTOPEN&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;/* Unable to open the database file */</p> 
         <p align="left">#define SQLITE_PROTOCOL&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;/* Database lock protocol error */</p> 
         <p align="left">#define SQLITE_EMPTY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;&nbsp;/* (Internal Only) Database table is empty */</p> 
         <p align="left">#define SQLITE_SCHEMA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17&nbsp;&nbsp;&nbsp;/* The database schema changed */</p> 
         <p align="left">#define SQLITE_TOOBIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;/* Too much data for one row of a table */</p> 
         <p align="left">#define SQLITE_CONSTRAINT&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;/* Abort due to contraint violation */</p> 
         <p align="left">#define SQLITE_MISMATCH&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;/* Data type mismatch */</p> 
         <p align="left">#define SQLITE_MISUSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21&nbsp;&nbsp;&nbsp;/* Library used incorrectly */</p> 
         <p align="left">#define SQLITE_NOLFS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;&nbsp;/* Uses OS features not supported on host */</p> 
         <p align="left">#define SQLITE_AUTH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;/* Authorization denied */</p> 
         <p align="left">#define SQLITE_ROW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;/* sqlite_step() has another row ready */</p> 
         <p align="left">#define SQLITE_DONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;101&nbsp;&nbsp;/* sqlite_step() has finished executing */</p> 
         <p>&nbsp;</p> （2）执行&nbsp;SQL&nbsp;语句 
         <p align="left">typedef int (*sqlite_callback)(void*,int,char**, char**);</p> 
         <p align="left">int sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void*, char**);</p> 
         <p align="left">sqlite3_exec&nbsp;函数依然像它在SQLite2中一样承担着很多的工作.&nbsp;该函数的第二个参数中可以编译和执行零个或多个SQL语句.&nbsp;查询的结果返回给回调函数.&nbsp;更多地信息可以查看API&nbsp;参考.</p> 
         <p align="left">在SQLite3里,sqlite3_exec一般是被准备SQL语句接口封装起来使用的.</p> 
         <p align="left">typedef struct sqlite3_stmt sqlite3_stmt;</p> 
         <p align="left">int sqlite3_prepare(sqlite3*, const char*, int, sqlite3_stmt**, const char**);</p> 
         <p align="left">int sqlite3_prepare16(sqlite3*, const void*, int, sqlite3_stmt**, const void**);</p> 
         <p align="left">int sqlite3_finalize(sqlite3_stmt*);</p> 
         <p align="left">int sqlite3_reset(sqlite3_stmt*);</p> 
         <p align="left">sqlite3_prepare&nbsp;接口把一条SQL语句编译成字节码留给后面的执行函数.&nbsp;使用该接口访问数据库是当前比较好的的一种方法.</p> 
         <p align="left">sqlite3_prepare()&nbsp;处理的SQL语句应该是UTF-8编码的.&nbsp;而sqlite3_prepare16()&nbsp;则要求是UTF-16编码的.&nbsp;输入的参数中只有第一个SQL语句会被编译.&nbsp;第四个参数则用来指向输入参数中下一个需要编译的SQL语句存放的SQLite statement对象的指针,任何时候如果调用&nbsp;sqlite3_finalize()&nbsp;将销毁一个准备好的SQL声明.&nbsp;在数据库关闭之前，所有准备好的声明都必须被释放销毁. sqlite3_reset()&nbsp;函数用来重置一个SQL声明的状态，使得它可以被再次执行.</p> 
         <p align="left">SQL声明可以包含一些型如"?"&nbsp;或&nbsp;"?nnn"&nbsp;或&nbsp;":aaa"的标记，&nbsp;其中"nnn"&nbsp;是一个整数，"aaa"&nbsp;是一个字符串.&nbsp;这些标记代表一些不确定的字符值（或者说是通配符），可以在后面用sqlite3_bind&nbsp;接口来填充这些值.&nbsp;每一个通配符都被分配了一个编号（由它在SQL声明中的位置决定，从1开始），此外也可以用&nbsp;"nnn"&nbsp;来表示&nbsp;"?nnn"&nbsp;这种情况.&nbsp;允许相同的通配符在同一个SQL声明中出现多次,&nbsp;在这种情况下所有相同的通配符都会被替换成相同的值.&nbsp;没有被绑定的通配符将自动取NULL值.</p> 
         <p align="left">int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));</p> 
         <p align="left">int sqlite3_bind_double(sqlite3_stmt*, int, double);</p> 
         <p align="left">int sqlite3_bind_int(sqlite3_stmt*, int, int);</p> 
         <p align="left">int sqlite3_bind_int64(sqlite3_stmt*, int, long long int);</p> 
         <p align="left">int sqlite3_bind_null(sqlite3_stmt*, int);</p> 
         <p align="left">int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));</p> 
         <p align="left">int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int n, void(*)(void*));</p> 
         <p align="left">int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);</p> 
         <p align="left">以上是&nbsp;sqlite3_bind&nbsp;所包含的全部接口，它们是用来给SQL声明中的通配符赋值的.&nbsp;没有绑定的通配符则被认为是空值.绑定上的值不会被sqlite3_reset()函数重置.&nbsp;但是在调用了sqlite3_reset()之后所有的通配符都可以被重新赋值.</p> 
         <p align="left">在SQL声明准备好之后(其中绑定的步骤是可选的),&nbsp;需要调用以下的方法来执行:</p> 
         <p align="left">int sqlite3_step(sqlite3_stmt*);</p> 
         <p align="left">如果SQL返回了一个单行结果集，sqlite3_step()&nbsp;函数将返回&nbsp;SQLITE_ROW ,&nbsp;如果SQL语句执行成功或者正常将返回SQLITE_DONE ,&nbsp;否则将返回错误代码.&nbsp;如果不能打开数据库文件则会返回&nbsp;SQLITE_BUSY .&nbsp;如果函数的返回值是SQLITE_ROW,&nbsp;那么下边的这些方法可以用来获得记录集行中的数据:</p> 
         <p align="left">const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);</p> 
         <p align="left">int sqlite3_column_bytes(sqlite3_stmt*, int iCol);</p> 
         <p align="left">int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);</p> 
         <p align="left">int sqlite3_column_count(sqlite3_stmt*);</p> 
         <p align="left">const char *sqlite3_column_decltype(sqlite3_stmt *, int iCol);</p> 
         <p align="left">const void *sqlite3_column_decltype16(sqlite3_stmt *, int iCol);</p> 
         <p align="left">double sqlite3_column_double(sqlite3_stmt*, int iCol);</p> 
         <p align="left">int sqlite3_column_int(sqlite3_stmt*, int iCol);</p> 
         <p align="left">long long int sqlite3_column_int64(sqlite3_stmt*, int iCol);</p> 
         <p align="left">const char *sqlite3_column_name(sqlite3_stmt*, int iCol);</p> 
         <p align="left">const void *sqlite3_column_name16(sqlite3_stmt*, int iCol);</p> 
         <p align="left">const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);</p> 
         <p align="left">const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);</p> 
         <p align="left">int sqlite3_column_type(sqlite3_stmt*, int iCol);</p> 
         <p align="left">sqlite3_column_count()函数返回结果集中包含的列数. sqlite3_column_count()&nbsp;可以在执行了&nbsp;sqlite3_prepare()之后的任何时刻调用. sqlite3_data_count()除了必需要在sqlite3_step()之后调用之外，其他跟sqlite3_column_count()&nbsp;大同小异.&nbsp;如果调用sqlite3_step()&nbsp;返回值是&nbsp;SQLITE_DONE&nbsp;或者一个错误代码,&nbsp;则此时调用sqlite3_data_count()&nbsp;将返回&nbsp;0&nbsp;，然而sqlite3_column_count()&nbsp;仍然会返回结果集中包含的列数.</p> 
         <p align="left">返回的记录集通过使用其它的几个&nbsp;sqlite3_column_***()&nbsp;函数来提取,&nbsp;所有的这些函数都把列的编号作为第二个参数.&nbsp;列编号从左到右以零起始.&nbsp;请注意它和之前那些从1起始的参数的不同.</p> 
         <p align="left">sqlite3_column_type()函数返回第N列的值的数据类型.&nbsp;具体的返回值如下:</p> 
         <p align="left">#define SQLITE_INTEGER&nbsp;&nbsp;1</p> 
         <p align="left">#define SQLITE_FLOAT&nbsp;&nbsp;&nbsp;&nbsp;2</p> 
         <p align="left">#define SQLITE_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3</p> 
         <p align="left">#define SQLITE_BLOB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4</p> 
         <p align="left">#define SQLITE_NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</p> 
         <p align="left">sqlite3_column_decltype()&nbsp;则用来返回该列在&nbsp;CREATE TABLE&nbsp;语句中声明的类型.&nbsp;它可以用在当返回类型是空字符串的时候. sqlite3_column_name()&nbsp;返回第N列的字段名. sqlite3_column_bytes()&nbsp;用来返回&nbsp;UTF-8&nbsp;编码的BLOBs列的字节数或者TEXT字符串的字节数. sqlite3_column_bytes16()&nbsp;对于BLOBs列返回同样的结果，但是对于TEXT字符串则按&nbsp;UTF-16&nbsp;的编码来计算字节数. sqlite3_column_blob()&nbsp;返回&nbsp;BLOB&nbsp;数据. sqlite3_column_text()&nbsp;返回&nbsp;UTF-8&nbsp;编码的&nbsp;TEXT&nbsp;数据. sqlite3_column_text16()&nbsp;返回&nbsp;UTF-16&nbsp;编码的&nbsp;TEXT&nbsp;数据. sqlite3_column_int()&nbsp;以本地主机的整数格式返回一个整数值. sqlite3_column_int64()&nbsp;返回一个64位的整数.&nbsp;最后, sqlite3_column_double()&nbsp;返回浮点数.</p> 
         <p align="left">不一定非要按照sqlite3_column_type()接口返回的数据类型来获取数据.&nbsp;数据类型不同时软件将自动转换.</p> （3）用户自定义函数 
         <p align="left">可以使用以下的方法来创建用户自定义的SQL函数:</p> 
         <p align="left">typedef struct sqlite3_value sqlite3_value;</p> 
         <p align="left">int sqlite3_create_function(</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3 *,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char *zFunctionName,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int nArg,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int eTextRep,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void*,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*xFunc)(sqlite3_context*,int,sqlite3_value**),</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*xStep)(sqlite3_context*,int,sqlite3_value**),</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*xFinal)(sqlite3_context*)</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;);</p> 
         <p align="left">&nbsp;</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;int sqlite3_create_function16(</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3*,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void *zFunctionName,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int nArg,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int eTextRep,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void*,</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*xFunc)(sqlite3_context*,int,sqlite3_value**),</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*xStep)(sqlite3_context*,int,sqlite3_value**),</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*xFinal)(sqlite3_context*)</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;);</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;#define SQLITE_UTF8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;#define SQLITE_UTF16&nbsp;&nbsp;&nbsp;&nbsp;2</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;#define SQLITE_UTF16BE&nbsp;&nbsp;3</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;#define SQLITE_UTF16LE&nbsp;&nbsp;4</p> 
         <p align="left">&nbsp;&nbsp;&nbsp;#define SQLITE_ANY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5</p> 
         <p align="left">nArg&nbsp;参数用来表明自定义函数的参数个数.&nbsp;如果参数值为0，则表示接受任意个数的参数.&nbsp;用&nbsp;eTextRep&nbsp;参数来表明传入参数的编码形式.&nbsp;参数值可以是上面的五种预定义值. SQLite3&nbsp;允许同一个自定义函数有多种不同的编码参数的版本.&nbsp;数据库引擎会自动选择转换参数编码个数最少的版本使用.</p> 
         <p align="left">普通的函数只需要设置&nbsp;xFunc&nbsp;参数，而把&nbsp;xStep&nbsp;和&nbsp;xFinal&nbsp;设为NULL.&nbsp;聚合函数则需要设置&nbsp;xStep&nbsp;和&nbsp;xFinal&nbsp;参数，然后把&nbsp;xFunc&nbsp;设为NULL.&nbsp;该方法和使用sqlite3_create_aggregate() API一样.</p> 
         <p align="left">sqlite3_create_function16()和sqlite_create_function()的不同就在于自定义的函数名一个要求是&nbsp;UTF-16&nbsp;编码，而另一个则要求是&nbsp;UTF-8.</p> 
         <p align="left">请注意自定函数的参数目前使用了sqlite3_value结构体指针替代了SQLite version 2.X中的字符串指针.&nbsp;下面的函数用来从sqlite3_value结构体中提取数据:</p> 
         <p align="left">&nbsp;&nbsp; const&nbsp;void&nbsp;*sqlite3_value_blob(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; int sqlite3_value_bytes(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; int sqlite3_value_bytes16(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; double sqlite3_value_double(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; int sqlite3_value_int(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; long long int sqlite3_value_int64(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; const unsigned char *sqlite3_value_text(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; const void *sqlite3_value_text16(sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; int sqlite3_value_type(sqlite3_value*);</p> 
         <p align="left">上面的函数调用以下的API来获得上下文内容和返回结果:</p> 
         <p align="left">&nbsp;&nbsp; void *sqlite3_aggregate_context(sqlite3_context*, int nbyte);</p> 
         <p align="left">&nbsp;&nbsp; void *sqlite3_user_data(sqlite3_context*);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_blob(sqlite3_context*, const void*, int n, void(*)(void*));</p> 
         <p align="left">&nbsp;&nbsp; void qlite3_result_double(sqlite3_context*, double);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_error(sqlite3_context*, const char*, int);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_error16(sqlite3_context*, const void*, int);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_int(sqlite3_context*, int);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_int64(sqlite3_context*, long long int);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_null(sqlite3_context*);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_text(sqlite3_context*, const char*, int n, void(*)(void*));&nbsp;</p> 
         <p align="left">&nbsp; void sqlite3_result_text16(sqlite3_context*, const void*, int n, void(*)(void*));</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_result_value(sqlite3_context*, sqlite3_value*);</p> 
         <p align="left">&nbsp;&nbsp; void *sqlite3_get_auxdata(sqlite3_context*, int);</p> 
         <p align="left">&nbsp;&nbsp; void sqlite3_set_auxdata(sqlite3_context*, int, void*, void (*)(void*));</p> （4）用户自定义排序规则 
         <p align="left">下面的函数用来实现用户自定义的排序规则:</p> 
         <p align="left">sqlite3_create_collation(sqlite3*, const char *zName, int eTextRep, void*,</p> 
         <p align="left">int(*xCompare)(void*,int,const void*,int,const void*));</p> 
         <p align="left">sqlite3_create_collation16(sqlite3*, const void *zName, int eTextRep, void*,</p> 
         <p align="left">int(*xCompare)(void*,int,const void*,int,const void*));</p> 
         <p align="left">sqlite3_collation_needed(sqlite3*, void*,</p> 
         <p align="left">void(*)(void*,sqlite3*,int eTextRep,const char*));</p> 
         <p align="left">sqlite3_collation_needed16(sqlite3*, void*,</p> 
         <p align="left">void(*)(void*,sqlite3*,int eTextRep,const void*));</p> 
         <p align="left">sqlite3_create_collation()&nbsp;函数用来声明一个排序序列和实现它的比较函数.&nbsp;比较函数只能用来做文本的比较. eTextRep&nbsp;参数可以取如下的预定义值&nbsp;SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, SQLITE_ANY，用来表示比较函数所处理的文本的编码方式.&nbsp;同一个自定义的排序规则的同一个比较函数可以有&nbsp;UTF-8, UTF-16LE&nbsp;和&nbsp;UTF-16BE&nbsp;等多个编码的版本. sqlite3_create_collation16()和sqlite3_create_collation()&nbsp;的区别也仅仅在于排序名称的编码是&nbsp;UTF-16&nbsp;还是&nbsp;UTF-8.</p> 
         <div>
          可以使用&nbsp;sqlite3_collation_needed()&nbsp;函数来注册一个回调函数，当数据库引擎遇到未知的排序规则时会自动调用该函数.&nbsp;在回调函数中可以查找一个相似的比较函数，并激活相应的sqlite_3_create_collation()函数.&nbsp;回调函数的第四个参数是排序规则的名称，同样sqlite3_collation_needed采用&nbsp;UTF-8&nbsp;编码. sqlite3_collation_need16()&nbsp;采用&nbsp;UTF-16&nbsp;编码.
         </div> 
         <div>
          &nbsp;
         </div> 
         <div>
          &nbsp;
         </div> 
         <div> 
          <div>
           五、给数据库加密 
           <p align="left">前面所说的内容网上已经有很多资料，虽然比较零散，但是花点时间也还是可以找到的。现在要说的这个——数据库加密，资料就很难找。也可能是我操作水平不够，找不到对应资料。但不管这样，我还是通过网上能找到的很有限的资料，探索出了给sqlite数据库加密的完整步骤。</p> 
           <p align="left">这里要提一下，虽然&nbsp;sqlite&nbsp;很好用，速度快、体积小巧。但是它保存的文件却是明文的。若不信可以用&nbsp;NotePad&nbsp;打开数据库文件瞧瞧，里面&nbsp;insert&nbsp;的内容几乎一览无余。这样赤裸裸的展现自己，可不是我们的初衷。当然，如果你在嵌入式系统、智能手机上使用&nbsp;sqlite，最好是不加密，因为这些系统运算能力有限，你做为一个新功能提供者，不能把用户有限的运算能力全部花掉。</p> 
           <p align="left">Sqlite为了速度而诞生。因此Sqlite本身不对数据库加密，要知道，如果你选择标准AES算法加密，那么一定有接近50%的时间消耗在加解密算法上，甚至更多（性能主要取决于你算法编写水平以及你是否能使用cpu提供的底层运算能力，比如MMX或sse系列指令可以大幅度提升运算速度）。</p> 
           <p align="left">Sqlite免费版本是不提供加密功能的，当然你也可以选择他们的收费版本，那你得支付2000块钱，而且是USD。我这里也不是说支付钱不好，如果只为了数据库加密就去支付2000块，我觉得划不来。因为下面我将要告诉你如何为免费的Sqlite扩展出加密模块——自己动手扩展，这是Sqlite允许，也是它提倡的。</p> 
           <p align="left">那么，就让我们一起开始为&nbsp;sqlite3.c&nbsp;文件扩展出加密模块。</p> 
           <p align="left">&nbsp;</p> 1&nbsp;必要的宏 
           <p align="left">通过阅读&nbsp;Sqlite&nbsp;代码（当然没有全部阅读完，6万多行代码，没有一行是我习惯的风格，我可没那么多眼神去看），我搞清楚了两件事：</p> 
           <p align="left">Sqlite是支持加密扩展的；</p> 
           <p align="left">需要&nbsp;#define&nbsp;一个宏才能使用加密扩展。</p> 
           <p align="left">这个宏就是&nbsp;&nbsp;SQLITE_HAS_CODEC。</p> 
           <p align="left">你在代码最前面（也可以在&nbsp;sqlite3.h&nbsp;文件第一行）定义：</p> 
           <p align="left">#ifndef&nbsp;SQLITE_HAS_CODEC</p> 
           <p align="left">#define&nbsp;SQLITE_HAS_CODEC</p> 
           <p align="left">#endif</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">如果你在代码里定义了此宏，但是还能够正常编译，那么应该是操作没有成功。因为你应该会被编译器提示有一些函数无法链接才对。如果你用的是&nbsp;VC 2003，你可以在“解决方案”里右键点击你的工程，然后选“属性”，找到“C/C++”，再找到“命令行”，在里面手工添加“/D "SQLITE_HAS_CODEC"”。</p> 
           <p align="left">定义了这个宏，一些被&nbsp;Sqlite&nbsp;故意屏蔽掉的代码就被使用了。这些代码就是加解密的接口。</p> 
           <p align="left">尝试编译，vc会提示你有一些函数无法链接，因为找不到他们的实现。</p> 
           <p align="left">如果你也用的是VC2003，那么会得到下面的提示：</p> 
           <p align="left">error LNK2019:&nbsp;无法解析的外部符号&nbsp;_sqlite3CodecGetKey&nbsp;，该符号在函数&nbsp;_attachFunc&nbsp;中被引用</p> 
           <p align="left">error LNK2019:&nbsp;无法解析的外部符号&nbsp;_sqlite3CodecAttach&nbsp;，该符号在函数&nbsp;_attachFunc&nbsp;中被引用</p> 
           <p align="left">error LNK2019:&nbsp;无法解析的外部符号&nbsp;_sqlite3_activate_see&nbsp;，该符号在函数&nbsp;_sqlite3Pragma&nbsp;中被引用</p> 
           <p align="left">error LNK2019:&nbsp;无法解析的外部符号&nbsp;_sqlite3_key&nbsp;，该符号在函数&nbsp;_sqlite3Pragma&nbsp;中被引用</p> 
           <p align="left">fatal error LNK1120: 4&nbsp;个无法解析的外部命令</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">这是正常的，因为Sqlite只留了接口而已，并没有给出实现。</p> 
           <p align="left">下面就让我来实现这些接口。</p> 
           <p align="left">&nbsp;</p> 2自己实现加解密接口函数 
           <p align="left">如果真要我从一份&nbsp;<a href="http://www.sqlite.org/" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">www.sqlite.org</a>&nbsp;网上down下来的&nbsp;sqlite3.c&nbsp;文件，直接摸索出这些接口的实现，我认为我还没有这个能力。</p> 
           <p align="left">好在网上还有一些代码已经实现了这个功能。通过参照他们的代码以及不断编译中vc给出的错误提示，最终我把整个接口整理出来。</p> 
           <p align="left">实现这些预留接口不是那么容易，要重头说一次怎么回事很困难。我把代码都写好了，直接把他们按我下面的说明拷贝到&nbsp;sqlite3.c&nbsp;文件对应地方即可。我在下面也提供了sqlite3.c&nbsp;文件，可以直接参考或取下来使用。</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">这里要说一点的是，我另外新建了两个文件：crypt.c和crypt.h。</p> 
           <p align="left">其中crypt.h如此定义：</p> 
           <p align="left">#ifndef&nbsp;&nbsp;DCG_SQLITE_CRYPT_FUNC_</p> 
           <p align="left">#define&nbsp;&nbsp;DCG_SQLITE_CRYPT_FUNC_</p> 
           <p align="left">/***********</p> 
           <p align="left">董淳光写的&nbsp;SQLITE&nbsp;加密关键函数库</p> 
           <p align="left">***********/</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">/***********</p> 
           <p align="left">关键加密函数</p> 
           <p align="left">***********/</p> 
           <p align="left">int&nbsp;My_Encrypt_Func(&nbsp;unsigned&nbsp;char&nbsp;* pData,&nbsp;unsigned&nbsp;int&nbsp;data_len,&nbsp;const&nbsp;char&nbsp;* key,&nbsp;unsigned&nbsp;int&nbsp;len_of_key );</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">/***********</p> 
           <p align="left">关键解密函数</p> 
           <p align="left">***********/</p> 
           <p align="left">int&nbsp;My_DeEncrypt_Func(&nbsp;unsigned&nbsp;char&nbsp;* pData,&nbsp;unsigned&nbsp;int&nbsp;data_len,&nbsp;const&nbsp;char&nbsp;* key,&nbsp;unsigned&nbsp;intlen_of_key );</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">#endif</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">其中的&nbsp;crypt.c&nbsp;如此定义：</p> 
           <p align="left">#include&nbsp;"./crypt.h"</p> 
           <p align="left">#include&nbsp;"memory.h"</p> 
           <p align="left">/***********</p> 
           <p align="left">关键加密函数</p> 
           <p align="left">***********/</p> 
           <p align="left">int&nbsp;My_Encrypt_Func(&nbsp;unsigned&nbsp;char&nbsp;* pData,&nbsp;unsigned&nbsp;int&nbsp;data_len,&nbsp;const&nbsp;char&nbsp;* key,&nbsp;unsigned&nbsp;int&nbsp;len_of_key )</p> 
           <p align="left">{</p> 
           <p align="left">return&nbsp;0;</p> 
           <p align="left">}</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">/***********</p> 
           <p align="left">关键解密函数</p> 
           <p align="left">***********/</p> 
           <p align="left">int&nbsp;My_DeEncrypt_Func(&nbsp;unsigned&nbsp;char&nbsp;* pData,&nbsp;unsigned&nbsp;int&nbsp;data_len,&nbsp;const&nbsp;char&nbsp;* key,&nbsp;unsigned&nbsp;intlen_of_key )</p> 
           <p align="left">{</p> 
           <p align="left">return&nbsp;0;</p> 
           <p align="left">}</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">这个文件很容易看，就两函数，一个加密一个解密。传进来的参数分别是待处理的数据、数据长度、密钥、密钥长度。</p> 
           <p align="left">处理时直接把结果作用于&nbsp;pData&nbsp;指针指向的内容。</p> 
           <p align="left">你需要定义自己的加解密过程，就改动这两个函数，其它部分不用动。扩展起来很简单。</p> 
           <p align="left">这里有个特点，data_len&nbsp;一般总是&nbsp;1024&nbsp;字节。正因为如此，你可以在你的算法里使用一些特定长度的加密算法，比如AES要求被加密数据一定是128位（16字节）长。这个1024不是碰巧，而是&nbsp;Sqlite&nbsp;的页定义是1024字节，在sqlite3.c文件里有定义:</p> 
           <p align="left"># define&nbsp;SQLITE_DEFAULT_PAGE_SIZE&nbsp;1024</p> 
           <p align="left">你可以改动这个值，不过还是建议没有必要不要去改它。</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">上面写了两个扩展函数，如何把扩展函数跟&nbsp;Sqlite&nbsp;挂接起来，这个过程说起来比较麻烦。我直接贴代码。</p> 
           <p align="left">分3个步骤。</p> 
           <p align="left">首先，在&nbsp;sqlite3.c&nbsp;文件顶部，添加下面内容：</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">#ifdef&nbsp;SQLITE_HAS_CODEC</p> 
           <p align="left">#include&nbsp;"./crypt.h"</p> 
           <p align="left">/***********</p> 
           <p align="left">用于在&nbsp;sqlite3&nbsp;最后关闭时释放一些内存</p> 
           <p align="left">***********/</p> 
           <p align="left">void&nbsp;sqlite3pager_free_codecarg(void&nbsp;*pArg);</p> 
           <p align="left">#endif</p> 
           <p align="left">这个函数之所以要在&nbsp;sqlite3.c&nbsp;开头声明，是因为下面在&nbsp;sqlite3.c&nbsp;里面某些函数里要插入这个函数调用。所以要提前声明。</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">其次，在sqlite3.c文件里搜索“sqlite3PagerClose”函数，要找到它的实现代码（而不是声明代码）。</p> 
           <p align="left">实现代码里一开始是：</p> 
           <p align="left">#ifdef&nbsp;SQLITE_ENABLE_MEMORY_MANAGEMENT</p> 
           <p align="left">&nbsp;&nbsp;/* A malloc() cannot fail in sqlite3ThreadData() as one or more calls to</p> 
           <p align="left">&nbsp;&nbsp;** malloc() must have already been made by this thread before it gets</p> 
           <p align="left">&nbsp;&nbsp;** to this point. This means the ThreadData must have been allocated already</p> 
           <p align="left">&nbsp;&nbsp;** so that ThreadData.nAlloc can be set.</p> 
           <p align="left">&nbsp;&nbsp;*/</p> 
           <p align="left">&nbsp;&nbsp;ThreadData *pTsd = sqlite3ThreadData();</p> 
           <p align="left">&nbsp;&nbsp;assert( pPager );</p> 
           <p align="left">&nbsp;&nbsp;assert( pTsd &amp;&amp; pTsd-&gt;nAlloc );</p> 
           <p align="left">#endif</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">需要在这部分后面紧接着插入：</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">#ifdef&nbsp;SQLITE_HAS_CODEC</p> 
           <p align="left">&nbsp;&nbsp;sqlite3pager_free_codecarg(pPager-&gt;pCodecArg);</p> 
           <p align="left">#endif</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">这里要注意，sqlite3PagerClose&nbsp;函数大概也是&nbsp;3.3.17版本左右才改名的，以前版本里是叫&nbsp;“sqlite3pager_close”。因此你在老版本sqlite代码里搜索“sqlite3PagerClose”是搜不到的。</p> 
           <p align="left">类似的还有“sqlite3pager_get”、“sqlite3pager_unref”、“sqlite3pager_write”、“sqlite3pager_pagecount”等都是老版本函数，它们在&nbsp;pager.h&nbsp;文件里定义。新版本对应函数是在&nbsp;sqlite3.h&nbsp;里定义（因为都合并到&nbsp;sqlite3.c和sqlite3.h两文件了）。所以，如果你在使用老版本的sqlite，先看看&nbsp;pager.h&nbsp;文件，这些函数不是消失了，也不是新蹦出来的，而是老版本函数改名得到的。</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">最后，往sqlite3.c&nbsp;文件下找。找到最后一行：</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">/************** End of main.c ************************************************/</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">在这一行后面，接上本文最下面的代码段。</p> 
           <p align="left">这些代码很长，我不再解释，直接接上去就得了。</p> 
           <p align="left">唯一要提的是&nbsp;DeriveKey&nbsp;函数。这个函数是对密钥的扩展。比如，你要求密钥是128位，即是16字节，但是如果用户只输入&nbsp;1个字节呢？2个字节呢？或输入50个字节呢？你得对密钥进行扩展，使之符合16字节的要求。</p> 
           <p align="left">DeriveKey&nbsp;函数就是做这个扩展的。有人把接收到的密钥求md5，这也是一个办法，因为md5运算结果固定16字节，不论你有多少字符，最后就是16字节。这是md5算法的特点。但是我不想用md5，因为还得为它添加包含一些&nbsp;md5&nbsp;的.c或.cpp文件。我不想这么做。我自己写了一个算法来扩展密钥，很简单的算法。当然，你也可以使用你的扩展方法，也而可以使用md5&nbsp;算法。只要修改&nbsp;DeriveKey&nbsp;函数就可以了。</p> 
           <p align="left">在&nbsp;DeriveKey&nbsp;函数里，只管申请空间构造所需要的密钥，不需要释放，因为在另一个函数里有释放过程，而那个函数会在数据库关闭时被调用。参考我的&nbsp;DeriveKey&nbsp;函数来申请内存。</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">这里我给出我已经修改好的&nbsp;sqlite3.c&nbsp;和&nbsp;sqlite3.h&nbsp;文件。</p> 
           <p align="left">如果太懒，就直接使用这两个文件，编译肯定能通过，运行也正常。当然，你必须按我前面提的，新建&nbsp;crypt.h&nbsp;和crypt.c&nbsp;文件，而且函数要按我前面定义的要求来做。</p> 3&nbsp;加密使用方法 
           <p align="left">现在，你代码已经有了加密功能。</p> 
           <p align="left">你要把加密功能给用上，除了改&nbsp;sqlite3.c&nbsp;文件、给你工程添加&nbsp;SQLITE_HAS_CODEC&nbsp;宏，还得修改你的数据库调用函数。</p> 
           <p align="left">前面提到过，要开始一个数据库操作，必须先&nbsp;sqlite3_open&nbsp;。</p> 
           <p align="left">加解密过程就在&nbsp;sqlite3_open&nbsp;后面操作。</p> 
           <p align="left">假设你已经&nbsp;sqlite3_open&nbsp;成功了，紧接着写下面的代码：</p> 
           <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int i;</p> 
           <p align="left">//添加、使用密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
           <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i =&nbsp;&nbsp;sqlite3_key( db, "dcg", 3 );</p> 
           <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//修改密码</p> 
           <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i =&nbsp;&nbsp;sqlite3_rekey(&nbsp;db, "dcg", 0 );</p> 
           <p align="left">用&nbsp;sqlite3_key&nbsp;函数来提交密码。</p> 
           <p align="left">第1个参数是&nbsp;sqlite3 *&nbsp;类型变量，代表着用&nbsp;sqlite3_open&nbsp;打开的数据库（或新建数据库）。</p> 
           <p align="left">第2个参数是密钥。</p> 
           <p align="left">第3个参数是密钥长度。</p> 
           <p align="left">用&nbsp;sqlite3_rekey&nbsp;来修改密码。参数含义同&nbsp;sqlite3_key。</p> 
           <p align="left">&nbsp;</p> 
           <p align="left">实际上，你可以在sqlite3_open函数之后，到&nbsp;sqlite3_close&nbsp;函数之前任意位置调用&nbsp;sqlite3_key&nbsp;来设置密码。</p> 
           <p align="left">但是如果你没有设置密码，而数据库之前是有密码的，那么你做任何操作都会得到一个返回值：SQLITE_NOTADB，并且得到错误提示：“file is encrypted or is not a database”。</p> 
           <p align="left">只有当你用&nbsp;sqlite3_key&nbsp;设置了正确的密码，数据库才会正常工作。</p> 
           <p align="left">如果你要修改密码，前提是你必须先&nbsp;sqlite3_open&nbsp;打开数据库成功，然后&nbsp;sqlite3_key&nbsp;设置密钥成功，之后才能用sqlite3_rekey&nbsp;来修改密码。</p> 
           <p align="left">如果数据库有密码，但你没有用&nbsp;sqlite3_key&nbsp;设置密码，那么当你尝试用&nbsp;sqlite3_rekey&nbsp;来修改密码时会得到SQLITE_NOTADB&nbsp;返回值。</p> 
           <p align="left">如果你需要清空密码，可以使用：</p> 
           <p align="left">//修改密码</p> 
           <p align="left">i =&nbsp;&nbsp;sqlite3_rekey( db, NULL, 0 );</p> 
           <p align="left">来完成密码清空功能。</p> 
           <p align="left">&nbsp;</p> 
           <div>
            4 sqlite3.c&nbsp;最后添加代码段 
            <p align="left">&nbsp;</p> 
            <p align="left">/***</p> 
            <p align="left">董淳光定义的加密函数</p> 
            <p align="left">***/</p> 
            <p align="left">#ifdef&nbsp;SQLITE_HAS_CODEC</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">/***</p> 
            <p align="left">加密结构</p> 
            <p align="left">***/</p> 
            <p align="left">#define&nbsp;CRYPT_OFFSET 8</p> 
            <p align="left">typedef&nbsp;struct&nbsp;_CryptBlock</p> 
            <p align="left">{</p> 
            <p align="left">BYTE*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReadKey;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;读数据库和写入事务的密钥</p> 
            <p align="left">BYTE*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteKey;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;写入数据库的密钥</p> 
            <p align="left">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PageSize;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;页的大小</p> 
            <p align="left">BYTE*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data;</p> 
            <p align="left">} CryptBlock, *LPCryptBlock;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">#ifndef&nbsp;&nbsp;DB_KEY_LENGTH_BYTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*密钥长度*/</p> 
            <p align="left">#define&nbsp;&nbsp;DB_KEY_LENGTH_BYTE&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;&nbsp;/*密钥长度*/</p> 
            <p align="left">#endif</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">#ifndef&nbsp;&nbsp;DB_KEY_PADDING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*密钥位数不足时补充的字符*/</p> 
            <p align="left">#define&nbsp;&nbsp;DB_KEY_PADDING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x33&nbsp;&nbsp;/*密钥位数不足时补充的字符*/</p> 
            <p align="left">#endif</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">/***&nbsp;下面是编译时提示缺少的函数&nbsp;***/</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">/**&nbsp;这个函数不需要做任何处理，获取密钥的部分在下面&nbsp;DeriveKey&nbsp;函数里实现&nbsp;**/</p> 
            <p align="left">void&nbsp;sqlite3CodecGetKey(sqlite3* db,&nbsp;int&nbsp;nDB,&nbsp;void** Key,&nbsp;int* nKey)</p> 
            <p align="left">{</p> 
            <p align="left">return&nbsp;;</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">/*被sqlite&nbsp;和&nbsp;sqlite3_key_interop&nbsp;调用,&nbsp;附加密钥到数据库.*/</p> 
            <p align="left">int&nbsp;sqlite3CodecAttach(sqlite3 *db,&nbsp;int&nbsp;nDb,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeyLen);</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">/**</p> 
            <p align="left">这个函数好像是&nbsp;sqlite 3.3.17前不久才加的，以前版本的sqlite里没有看到这个函数</p> 
            <p align="left">这个函数我还没有搞清楚是做什么的，它里面什么都不做直接返回，对加解密没有影响</p> 
            <p align="left">**/</p> 
            <p align="left">void&nbsp;sqlite3_activate_see(const&nbsp;char* right )</p> 
            <p align="left">{&nbsp;&nbsp;&nbsp;</p> 
            <p align="left">return;</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">int&nbsp;sqlite3_key(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKey);</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">int&nbsp;sqlite3_rekey(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKey);</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">/***</p> 
            <p align="left">下面是上面的函数的辅助处理函数</p> 
            <p align="left">***/</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">//&nbsp;从用户提供的缓冲区中得到一个加密密钥</p> 
            <p align="left">//&nbsp;用户提供的密钥可能位数上满足不了要求，使用这个函数来完成密钥扩展</p> 
            <p align="left">static&nbsp;unsigned&nbsp;char&nbsp;* DeriveKey(const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeyLen);</p> 
            <p align="left">//创建或更新一个页的加密算法索引.此函数会申请缓冲区.</p> 
            <p align="left">static&nbsp;LPCryptBlock CreateCryptBlock(unsigned&nbsp;char* hKey, Pager *pager, LPCryptBlock pExisting);</p> 
            <p align="left">//加密/解密函数,&nbsp;被pager调用</p> 
            <p align="left">void&nbsp;* sqlite3Codec(void&nbsp;*pArg,&nbsp;unsigned&nbsp;char&nbsp;*data, Pgno nPageNum,&nbsp;int&nbsp;nMode);</p> 
            <p align="left">//设置密码函数</p> 
            <p align="left">int&nbsp;__stdcall&nbsp;sqlite3_key_interop(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeySize);</p> 
            <p align="left">//&nbsp;修改密码函数</p> 
            <p align="left">int&nbsp;__stdcall&nbsp;sqlite3_rekey_interop(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeySize);</p> 
            <p align="left">//销毁一个加密块及相关的缓冲区,密钥.</p> 
            <p align="left">static&nbsp;void&nbsp;DestroyCryptBlock(LPCryptBlock pBlock);</p> 
            <p align="left">static&nbsp;void&nbsp;* sqlite3pager_get_codecarg(Pager *pPager);</p> 
            <p align="left">void&nbsp;sqlite3pager_set_codec(Pager *pPager,void&nbsp;*(*xCodec)(void*,void*,Pgno,int),void&nbsp;*pCodecArg&nbsp;&nbsp;&nbsp;&nbsp;);</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">//加密/解密函数,&nbsp;被pager调用</p> 
            <p align="left">void&nbsp;* sqlite3Codec(void&nbsp;*pArg,&nbsp;unsigned&nbsp;char&nbsp;*data, Pgno nPageNum,&nbsp;int&nbsp;nMode)</p> 
            <p align="left">{</p> 
            <p align="left">LPCryptBlock pBlock = (LPCryptBlock)pArg;</p> 
            <p align="left">unsigned&nbsp;int&nbsp;dwPageSize = 0;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">if&nbsp;(!pBlock)&nbsp;return&nbsp;data;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">//&nbsp;确保pager的页长度和加密块的页长度相等.如果改变,就需要调整.</p> 
            <p align="left">if&nbsp;(nMode != 2)</p> 
            <p align="left">{</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PgHdr *pageHeader;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pageHeader = DATA_TO_PGHDR(data);</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pageHeader-&gt;pPager-&gt;pageSize != pBlock-&gt;PageSize)</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateCryptBlock(0, pageHeader-&gt;pPager, pBlock);</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">switch(nMode)</p> 
            <p align="left">{</p> 
            <p align="left">case&nbsp;0:&nbsp;// Undo a "case 7" journal file encryption</p> 
            <p align="left">case&nbsp;2:&nbsp;//重载一个页</p> 
            <p align="left">case&nbsp;3:&nbsp;//载入一个页</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pBlock-&gt;ReadKey)&nbsp;break;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwPageSize = pBlock-&gt;PageSize;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My_DeEncrypt_Func(data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE );&nbsp;&nbsp;/*调用我的解密函数*/</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p> 
            <p align="left">case&nbsp;6:&nbsp;//加密一个主数据库文件的页</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pBlock-&gt;WriteKey)&nbsp;break;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pBlock-&gt;Data + CRYPT_OFFSET, data, pBlock-&gt;PageSize);</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = pBlock-&gt;Data + CRYPT_OFFSET;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwPageSize = pBlock-&gt;PageSize;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My_Encrypt_Func(data , dwPageSize, pBlock-&gt;WriteKey, DB_KEY_LENGTH_BYTE );&nbsp;/*调用我的加密函数*/</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p> 
            <p align="left">case&nbsp;7:&nbsp;//加密事务文件的页</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*在正常环境下,&nbsp;读密钥和写密钥相同.&nbsp;当数据库是被重新加密的,读密钥和写密钥未必相同.</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回滚事务必要用数据库文件的原始密钥写入.因此,当一次回滚被写入,总是用数据库的读密钥,</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是为了保证与读取原始数据的密钥相同.</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pBlock-&gt;ReadKey)&nbsp;break;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pBlock-&gt;Data + CRYPT_OFFSET, data, pBlock-&gt;PageSize);</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = pBlock-&gt;Data + CRYPT_OFFSET;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwPageSize = pBlock-&gt;PageSize;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;My_Encrypt_Func( data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE );&nbsp;/*调用我的加密函数*/</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">return&nbsp;data;</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">//销毁一个加密块及相关的缓冲区,密钥.</p> 
            <p align="left">static&nbsp;void&nbsp;DestroyCryptBlock(LPCryptBlock pBlock)</p> 
            <p align="left">{</p> 
            <p align="left">//销毁读密钥.</p> 
            <p align="left">if&nbsp;(pBlock-&gt;ReadKey){</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqliteFree(pBlock-&gt;ReadKey);</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">//如果写密钥存在并且不等于读密钥,也销毁.</p> 
            <p align="left">if&nbsp;(pBlock-&gt;WriteKey &amp;&amp; pBlock-&gt;WriteKey != pBlock-&gt;ReadKey){</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqliteFree(pBlock-&gt;WriteKey);</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">if(pBlock-&gt;Data){</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqliteFree(pBlock-&gt;Data);</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">//释放加密块.</p> 
            <p align="left">sqliteFree(pBlock);</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">static&nbsp;void&nbsp;* sqlite3pager_get_codecarg(Pager *pPager)</p> 
            <p align="left">{</p> 
            <p align="left">return&nbsp;(pPager-&gt;xCodec) ? pPager-&gt;pCodecArg: NULL;</p> 
            <p align="left">}</p> 
            <p align="left">//&nbsp;从用户提供的缓冲区中得到一个加密密钥</p> 
            <p align="left">static&nbsp;unsigned&nbsp;char&nbsp;* DeriveKey(const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeyLen)</p> 
            <p align="left">{</p> 
            <p align="left">unsigned&nbsp;char&nbsp;*&nbsp;&nbsp;hKey = NULL;</p> 
            <p align="left">int&nbsp;j;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">if( pKey == NULL || nKeyLen == 0 )</p> 
            <p align="left">{</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">hKey = sqliteMalloc( DB_KEY_LENGTH_BYTE + 1 );</p> 
            <p align="left">if( hKey == NULL )</p> 
            <p align="left">{</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;</p> 
            <p align="left">}</p> 
            <p align="left">hKey[ DB_KEY_LENGTH_BYTE ] = 0;</p> 
            <p align="left">if( nKeyLen &lt; DB_KEY_LENGTH_BYTE )</p> 
            <p align="left">{</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy( hKey, pKey, nKeyLen );&nbsp;//先拷贝得到密钥前面的部分</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j = DB_KEY_LENGTH_BYTE - nKeyLen;</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//补充密钥后面的部分</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(&nbsp;&nbsp;hKey + nKeyLen,&nbsp;&nbsp;DB_KEY_PADDING, j&nbsp;&nbsp;);</p> 
            <p align="left">}</p> 
            <p align="left">else</p> 
            <p align="left">{&nbsp;//密钥位数已经足够,直接把密钥取过来</p> 
            <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&nbsp;&nbsp;hKey, pKey, DB_KEY_LENGTH_BYTE );</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">return&nbsp;hKey;</p> 
            <p align="left">}</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;</p> 
            <p align="left">&nbsp;</p> 
            <div> 
             <p align="left">//创建或更新一个页的加密算法索引.此函数会申请缓冲区.</p> 
             <p align="left">static&nbsp;LPCryptBlock CreateCryptBlock(unsigned&nbsp;char* hKey, Pager *pager, LPCryptBlock pExisting)</p> 
             <p align="left">{</p> 
             <p align="left">LPCryptBlock pBlock;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">if&nbsp;(!pExisting)&nbsp;//创建新加密块</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock = sqliteMalloc(sizeof(CryptBlock));</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(pBlock, 0,&nbsp;sizeof(CryptBlock));</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;ReadKey = hKey;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;WriteKey = hKey;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;PageSize = pager-&gt;pageSize;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;Data = (unsigned&nbsp;char*)sqliteMalloc(pBlock-&gt;PageSize + CRYPT_OFFSET);</p> 
             <p align="left">}</p> 
             <p align="left">else&nbsp;//更新存在的加密块</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock = pExisting;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;( pBlock-&gt;PageSize != pager-&gt;pageSize &amp;&amp; !pBlock-&gt;Data){</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqliteFree(pBlock-&gt;Data);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;PageSize = pager-&gt;pageSize;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;Data = (unsigned&nbsp;char*)sqliteMalloc(pBlock-&gt;PageSize + CRYPT_OFFSET);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">memset(pBlock-&gt;Data, 0, pBlock-&gt;PageSize + CRYPT_OFFSET);</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">return&nbsp;pBlock;</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">/*</p> 
             <p align="left">** Set the codec for this pager</p> 
             <p align="left">*/</p> 
             <p align="left">void&nbsp;sqlite3pager_set_codec(</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pager *pPager,</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*xCodec)(void*,void*,Pgno,int),</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pCodecArg</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</p> 
             <p align="left">{</p> 
             <p align="left">pPager-&gt;xCodec = xCodec;</p> 
             <p align="left">pPager-&gt;pCodecArg = pCodecArg;</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">int&nbsp;sqlite3_key(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKey)</p> 
             <p align="left">{</p> 
             <p align="left">return&nbsp;sqlite3_key_interop(db, pKey, nKey);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">int&nbsp;sqlite3_rekey(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKey)</p> 
             <p align="left">{</p> 
             <p align="left">return&nbsp;sqlite3_rekey_interop(db, pKey, nKey);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">/*被sqlite&nbsp;和&nbsp;sqlite3_key_interop&nbsp;调用,&nbsp;附加密钥到数据库.*/</p> 
             <p align="left">int&nbsp;sqlite3CodecAttach(sqlite3 *db,&nbsp;int&nbsp;nDb,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeyLen)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;rc = SQLITE_ERROR;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char* hKey = 0;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;//如果没有指定密匙,可能标识用了主数据库的加密或没加密.</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pKey || !nKeyLen)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!nDb)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SQLITE_OK;&nbsp;//主数据库,&nbsp;没有指定密钥所以没有加密.</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;//附加数据库,使用主数据库的密钥.</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取主数据库的加密块并复制密钥给附加数据库使用</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(sqlite3BtreePager(db-&gt;aDb[0].pBt));</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pBlock)&nbsp;return&nbsp;SQLITE_OK;&nbsp;//主数据库没有加密</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pBlock-&gt;ReadKey)&nbsp;return&nbsp;SQLITE_OK;&nbsp;//没有加密</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pBlock-&gt;ReadKey, &amp;hKey, 16);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;//用户提供了密码,从中创建密钥.</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hKey = DeriveKey(pKey, nKeyLen);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;//创建一个新的加密块,并将解码器指向新的附加数据库.</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(hKey)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPCryptBlock pBlock = CreateCryptBlock(hKey, sqlite3BtreePager(db-&gt;aDb[nDb].pBt), NULL);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3pager_set_codec(sqlite3BtreePager(db-&gt;aDb[nDb].pBt), sqlite3Codec, pBlock);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = SQLITE_OK;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;rc;</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">// Changes the encryption key for an existing database.</p> 
             <p align="left">int&nbsp;__stdcall&nbsp;sqlite3_rekey_interop(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeySize)</p> 
             <p align="left">{</p> 
             <p align="left">Btree *pbt = db-&gt;aDb[0].pBt;</p> 
             <p align="left">Pager *p = sqlite3BtreePager(pbt);</p> 
             <p align="left">LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(p);</p> 
             <p align="left">unsigned&nbsp;char&nbsp;* hKey = DeriveKey(pKey, nKeySize);</p> 
             <p align="left">int&nbsp;rc = SQLITE_ERROR;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">if&nbsp;(!pBlock &amp;&amp; !hKey)&nbsp;return&nbsp;SQLITE_OK;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//重新加密一个数据库,改变pager的写密钥,&nbsp;读密钥依旧保留.</p> 
             <p align="left">if&nbsp;(!pBlock)&nbsp;//加密一个未加密的数据库</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock = CreateCryptBlock(hKey, p, NULL);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;ReadKey = 0;&nbsp;//&nbsp;原始数据库未加密</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3pager_set_codec(sqlite3BtreePager(pbt), sqlite3Codec, pBlock);</p> 
             <p align="left">}</p> 
             <p align="left">else&nbsp;//&nbsp;改变已加密数据库的写密钥</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;WriteKey = hKey;</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//&nbsp;开始一个事务</p> 
             <p align="left">rc = sqlite3BtreeBeginTrans(pbt, 1);</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">if&nbsp;(!rc)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;用新密钥重写所有的页到数据库。</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pgno nPage = sqlite3PagerPagecount(p);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pgno nSkip = PAGER_MJ_PGNO(p);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pPage;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pgno n;</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(n = 1; rc == SQLITE_OK &amp;&amp; n &lt;= nPage; n ++)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n == nSkip)&nbsp;continue;</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = sqlite3PagerGet(p, n, &amp;pPage);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!rc)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = sqlite3PagerWrite(pPage);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3PagerUnref(pPage);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//&nbsp;如果成功，提交事务。</p> 
             <p align="left">if&nbsp;(!rc)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc = sqlite3BtreeCommit(pbt);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//&nbsp;如果失败，回滚。</p> 
             <p align="left">if&nbsp;(rc)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3BtreeRollback(pbt);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//&nbsp;如果成功，销毁先前的读密钥。并使读密钥等于当前的写密钥。</p> 
             <p align="left">if&nbsp;(!rc)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pBlock-&gt;ReadKey)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqliteFree(pBlock-&gt;ReadKey);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;ReadKey = pBlock-&gt;WriteKey;</p> 
             <p align="left">}</p> 
             <p align="left">else//&nbsp;如果失败，销毁当前的写密钥，并恢复为当前的读密钥。</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pBlock-&gt;WriteKey)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqliteFree(pBlock-&gt;WriteKey);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pBlock-&gt;WriteKey = pBlock-&gt;ReadKey;</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//&nbsp;如果读密钥和写密钥皆为空，就不需要再对页进行编解码。</p> 
             <p align="left">//&nbsp;销毁加密块并移除页的编解码器</p> 
             <p align="left">if&nbsp;(!pBlock-&gt;ReadKey &amp;&amp; !pBlock-&gt;WriteKey)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlite3pager_set_codec(p, NULL, NULL);</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestroyCryptBlock(pBlock);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">return&nbsp;rc;</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">/***</p> 
             <p align="left">下面是加密函数的主体</p> 
             <p align="left">***/</p> 
             <p align="left">int&nbsp;__stdcall&nbsp;sqlite3_key_interop(sqlite3 *db,&nbsp;const&nbsp;void&nbsp;*pKey,&nbsp;int&nbsp;nKeySize)</p> 
             <p align="left">{</p> 
             <p align="left">&nbsp;&nbsp;return&nbsp;sqlite3CodecAttach(db, 0, pKey, nKeySize);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">//&nbsp;释放与一个页相关的加密块</p> 
             <p align="left">void&nbsp;sqlite3pager_free_codecarg(void&nbsp;*pArg)</p> 
             <p align="left">{</p> 
             <p align="left">if&nbsp;(pArg)</p> 
             <p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestroyCryptBlock((LPCryptBlock)pArg);</p> 
             <p align="left">}</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">#endif&nbsp;//#ifdef SQLITE_HAS_CODEC</p> 
             <p align="left">&nbsp;</p> 
             <p align="left">&nbsp;</p> 五、性能优化 
             <p align="left">很多人直接就使用了，并未注意到SQLite也有配置参数，可以对性能进行调整。有时候，产生的结果会有很大影响。</p> 
             <p align="left">主要通过pragma指令来实现。</p> 
             <p align="left">比如：&nbsp;空间释放、磁盘同步、Cache大小等。</p> 
             <p align="left">不要打开。前文提高了，Vacuum的效率非常低！</p> 1 auto_vacuum 
             <p align="left">PRAGMA auto_vacuum;&nbsp;<br> PRAGMA auto_vacuum = 0 | 1;</p> 
             <p align="left">查询或设置数据库的auto-vacuum标记。</p> 
             <p align="left">正常情况下，当提交一个从数据库中删除数据的事务时，数据库文件不改变大小。未使用的文件页被标记并在以后的添加操作中再次使用。这种情况下使用VACUUM命令释放删除得到的空间。</p> 
             <p align="left">当开启auto-vacuum，当提交一个从数据库中删除数据的事务时，数据库文件自动收缩，&nbsp;(VACUUM命令在auto-vacuum开启的数据库中不起作用)。数据库会在内部存储一些信息以便支持这一功能，这使得数据库文件比不开启该选项时稍微大一些。</p> 
             <p align="left">只有在数据库中未建任何表时才能改变auto-vacuum标记。试图在已有表的情况下修改不会导致报错。</p> 2 cache_size 
             <p align="left">建议改为8000</p> 
             <p align="left">PRAGMA cache_size;&nbsp;<br> PRAGMA cache_size = Number-of-pages;</p> 
             <p align="left">查询或修改SQLite一次存储在内存中的数据库文件页数。每页使用约1.5K内存，缺省的缓存大小是2000.&nbsp;若需要使用改变大量多行的UPDATE或DELETE命令，并且不介意SQLite使用更多的内存的话，可以增大缓存以提高性能。</p> 
             <p align="left">当使用cache_size pragma改变缓存大小时，改变仅对当前对话有效，当数据库关闭重新打开时缓存大小恢复到缺省大小。&nbsp;要想永久改变缓存大小，使用<a href="http://www.jimmydong.com/blog/" rel="nofollow" style="text-decoration:none;color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">default_cache_size</a>&nbsp;pragma.</p> 3 case_sensitive_like 
             <p align="left">打开。不然搜索中文字串会出错。</p> 
             <p align="left">PRAGMA case_sensitive_like;&nbsp;<br> PRAGMA case_sensitive_like = 0 | 1;</p> 
             <p align="left">LIKE运算符的缺省行为是忽略latin1字符的大小写。因此在缺省情况下'a' LIKE 'A'的值为真。可以通过打开case_sensitive_like pragma来改变这一缺省行为。当启用case_sensitive_like，'a' LIKE 'A'为假而&nbsp;'a' LIKE 'a'依然为真。</p> 4 count_changes 
             <p align="left">打开。便于调试</p> 
             <p align="left">PRAGMA count_changes;&nbsp;<br> PRAGMA count_changes = 0 | 1;</p> 
             <p align="left">查询或更改count-changes标记。正常情况下INSERT, UPDATE和DELETE语句不返回数据。&nbsp;当开启count-changes，以上语句返回一行含一个整数值的数据——该语句插入，修改或删除的行数。&nbsp;返回的行数不包括由触发器产生的插入，修改或删除等改变的行数。</p> 5 page_size 
             <p align="left">PRAGMA page_size;&nbsp;<br> PRAGMA page_size = bytes;</p> 
             <p align="left">查询或设置page-size值。只有在未创建数据库时才能设置page-size。页面大小必须是2的整数倍且大于等于512小于等于8192。&nbsp;上限可以通过在编译时修改宏定义SQLITE_MAX_PAGE_SIZE的值来改变。上限的上限是32768.</p> 6 synchronous 
             <p align="left">如果有定期备份的机制，而且少量数据丢失可接受，用OFF</p> 
             <p align="left">PRAGMA synchronous;&nbsp;<br> PRAGMA synchronous = FULL; (2)&nbsp;<br> PRAGMA synchronous = NORMAL; (1)&nbsp;<br> PRAGMA synchronous = OFF; (0)</p> 
             <p align="left">查询或更改"synchronous"标记的设定。第一种形式(查询)返回整数值。&nbsp;当synchronous设置为FULL (2), SQLite数据库引擎在紧急时刻会暂停以确定数据已经写入磁盘。&nbsp;这使系统崩溃或电源出问题时能确保数据库在重起后不会损坏。FULL synchronous很安全但很慢。&nbsp;当synchronous设置为NORMAL, SQLite数据库引擎在大部分紧急时刻会暂停，但不像FULL模式下那么频繁。&nbsp;NORMAL模式下有很小的几率(但不是不存在)发生电源故障导致数据库损坏的情况。但实际上，在这种情况下很可能你的硬盘已经不能使用，或者发生了其他的不可恢复的硬件错误。&nbsp;设置为synchronous OFF (0)时，SQLite在传递数据给系统以后直接继续而不暂停。若运行SQLite的应用程序崩溃，&nbsp;数据不会损伤，但在系统崩溃或写入数据时意外断电的情况下数据库可能会损坏。另一方面，在synchronous OFF时&nbsp;一些操作可能会快50倍甚至更多。</p> 
             <p align="left">在SQLite 2中，缺省值为NORMAL.而在3中修改为FULL.</p> 7 temp_store 
             <p align="left">使用2，内存模式。</p> 
             <p align="left">PRAGMA temp_store;&nbsp;<br> PRAGMA temp_store = DEFAULT; (0)&nbsp;<br> PRAGMA temp_store = FILE; (1)&nbsp;<br> PRAGMA temp_store = MEMORY; (2)</p> 
             <p align="left">查询或更改"temp_store"参数的设置。当temp_store设置为DEFAULT (0),使用编译时的C预处理宏&nbsp;TEMP_STORE来定义储存临时表和临时索引的位置。当设置为MEMORY (2)临时表和索引存放于内存中。&nbsp;当设置为FILE (1)则存放于文件中。temp_store_directorypragma&nbsp;可用于指定存放该文件的目录。当改变temp_store设置，所有已存在的临时表，索引，触发器及视图将被立即删除。</p> 
             <div>
              经测试，在类BBS应用上，通过以上调整，效率可以提高2倍以上。
             </div> 
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
   <div> 
    <font color="#333333"><span style="font-size:14px;">本文转自当天真遇到现实博客园博客，原文链接：http://www.cnblogs.com/XYQ-208910/p/4825224.html，如需转载请自行联系原作者</span></font>
    <br>
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
