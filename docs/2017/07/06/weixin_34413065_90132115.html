<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++ 语言基础 « NotBeCN</title>
  <meta name="description" content="             入门简介 　 　&nbsp; 变量 C++数据类型 C++操作符&nbsp;C++中的函数 main函数 数组 字符串数组 字符串操作函数&nbsp; C++是个强大的语言，可以用于做别的语言做不了的工作。但是，这种强大功能是有代价的。开始使用C++时，你可能会遇到内存溢出和访问失效等问...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/07/06/weixin_34413065_90132115.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C++ 语言基础</h1>
    <p class="post-meta">Jul 6, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">入门简介 　 　&nbsp;<br> 变量 C++数据类型 C++操作符&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中的函数 main函数 数组 字符串数组 字符串操作<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>&nbsp;<br><br> C++是个强大的语言，可以用于做别的语言做不了的工作。但是，这种强大功能是有代价的。开始使用C++时，你可能会遇到内存溢出和访问失效等问题，使程序死机。这里用最简短的篇幅介绍C++语言基础。C++语言本身有专著介绍，这种书还特别厚，所以别指望我能用三言两语说清楚。读者学完本书并使用C++ Builder一般时间之后，最后对<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>语言再作更深入的了解。&nbsp;<br><br> C++可以最充分地利用面向对象编程(OOP)的优势。OOP不只是一个新名词，而有它的实际意义，可以生成可复用的对象。新术语 对象(object)，和前面介绍的构件一样，是完成特定编程任务的软件块（构件是对象，但对象不全是构件，稍后会解释这点）。对象只向用户（使用对象的编程人员）显示必须的部分，从而简化对象的使用。用户不必知道的所有内部机制都隐藏在幕后。这一切都包括在<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%C3%E6%CF%F2%B6%D4%CF%F3" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">面向对象</a>编程的概念中。OOP可以用模块化方法进行编程，从而避免每次从头开始。C++ Builder程序是面向OOP的，因为C++ Builder大量使用构件。生成构件后（你生成的或C++ Builder内置的构件），就可以在任何<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>&nbsp;Builder程序中重复使用。构件还可以扩展，通过继承生成具有新功能的新构件。最妙的是，构件隐藏了所有内容细节，使编程人员能集中精力充分利用构件。&nbsp;<br><br> 入门简介&nbsp;<br> 在C++之前先有C语言，C++是建立在C语言之上的，称为“带类的C语言”。这个C语言基础在当今的C++程序中仍然很重要。C++并不是取代C，而是补充和支持C。本章余下部分和下几章主要介绍<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中来源于C语言的部分。实际上，这里介绍的是<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cyy/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C语言</a>，第2课"C++基础"中才转入C++。读者不必关心哪个来自C，哪个来自C++，因为这些全在C++中。C++语言很难按顺序介绍，因为我们要介绍的所有特性都是交叉的。我准备的一次介绍一块，然后拼凑起来。到第3课"高级C++"结束，你将对<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>语言有个完整的了解。一下子没有掌握某个概念也没关系，有些概念必须经过实践才能完全了解。&nbsp;<br><br> 变量&nbsp;<br> 还是从变量讲起来吧。变量(variable)实际上是赋予内存地址的名称。声明变量后，就可以用它操作内存中的数据。下面举几个例子进行说明。下列码段用了两个变量，每条语句末尾用说明语句描述执行该语句时发生的情况：&nbsp;<br> int x;// variable declared as an integer variable&nbsp;<br> x = 100;// 'x' now contains the value 100&nbsp;<br> x +=50;// 'x' now contains the value 150&nbsp;<br> int y = 150;// 'y' declared and initialized to 150&nbsp;<br> x += y;// 'x' now contains the value 300&nbsp;<br> x++;// 'x' now contains the value 301&nbsp;<br> 新术语 变量(variable)是留作存放某个数值的计算机内存地址。注意x的值在变量操作时会改变，稍后会介绍操作变量的<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>操作符。警告 声明而未初始化的变量包含随机值。由于变量所指向的内存还没有初始化，所以不知道该内存地址包含什么值。&nbsp;<br> 例如，下列代码&nbsp;<br> int k;&nbsp;<br> int y;&nbsp;<br> x=y+10; //oops!&nbsp;<br> 本例中变量y没有事先初始化，所以x可能取得任何值。例外的情况是全局变量和用static修饰声明的变量总是初始化为0。而所有其它变量在初始化或赋值之前包含随机值。变量名可以混合大写、小写字母和数字与下划线（_），但不能包含空格和其它特殊字符。变量名必须以字母或下划线开始。一般来说，变量名以下划线或双下划线开始不好。变量名允许的最大长度随编译器的不同而不同。如果变量名保持在32个字符以下，则绝对安全。实际中，任何超过20个字符的变量名都是不实用的。&nbsp;<br> 下例是有效变量名的例子：&nbsp;<br> int aVeryLongVariableName;// a long variable name&nbsp;<br> int my_variable;// a variable with an underscore&nbsp;<br> int_ x;// OK,but not advisedint X;// uppercase variable name&nbsp;<br> int Labe12;// a variable name containing a number&nbsp;<br> int GetItemsInContainer(); // thanks Pete!&nbsp;<br> 说明&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中的变量名是考虑大小写的，下列变量是不同的：int XPos;int xpos;如果你原先所用语言不考虑大小写（如Pascal)，则开始接触考虑大小写的语言可能不太适应。</p> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>数据类型&nbsp;<br> 新术语 C++数据类型定义编译器在内存中存放信息的方式。在有些编程语言中，可以向变量赋予任何数值类型。例如，下面是BASIC代码的例子：x = 1;x = 1000;x = 3.14;x = 457000;在BASIC中，翻译器能考虑根据数字长度和类型分配空间。而在C++，则必须先声明变量类型再使用变量：int x1 = 1;int x = 1000;float y = 3.14;long z = 457000;这样，编译器就可以进行类型检查，确保程序运行时一切顺利。数据类型使用不当会导致编译错误或警告，以便分析和纠正之后再运行。有些数据类型有带符号和无符号两种。带符号（signed)数据类型可以包含正数和负数，而无符号（unsigned)数据类型只能包含正数。表1.1列出了<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中的数据类型、所要内存量和可能的取值范围。&nbsp;<br> 表1.1<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>数据类型(32位程序)&nbsp;<br> 数据类型 字节 数取值范围&nbsp;<br> char 1 -128到126&nbsp;<br> unsigned char 1 0到255&nbsp;<br> short 2 -32,768到32,767&nbsp;<br> unsigned short 2 0到65,535&nbsp;<br> long 4 -2,147,483,648到2,147,483,648&nbsp;<br> unsigned long 4 0到4,294,967,295&nbsp;<br> int 4 同long&nbsp;<br> unsigned int 4 同unsigned long&nbsp;<br> float 4 1.2E-38到3.4E381&nbsp;<br> double 8 2.2E-308到1.8E3082&nbsp;<br> bool 1 true或false&nbsp;<br> 从上表可以看出，int与long相同。那么，为什么C++还要区分这两种数据类型呢?实际上这是个遗留问题。在16位编程环境中，int要求2个字节而long要求4个字节。而在32位编程环境中，这两种数据都用4个字节存放。C++Builder只生成32位程序，所以int与long相同。说明 在C++ Builder和BorLand C++ 5.0中，Bool是个真正的数据类型。有些C++编译器有Bool关键字，则Bool不是个真正的数据类型。有时Bool只是个typedef，使Bool等价于int。typedef实际上建立别名，使编译器在一个符号与另一符号间划上等号。typedef的语法如下：typedef int Bool;这就告诉编译器:Bool是int的别名。说明 只有double和float数据类型使用浮点数（带小数点的数）。其它数据类型只涉及整数值。尽管integer数据类型也可以指定带小数点的数值，但小数部分会舍弃，只将整数部分赋予整型变量，例如：int x=3.75;得到的x取值为3。注意，这个整数值并不是四舍五入，而是放弃小数部分。顺便说一句，大多数Windows程序很少用到浮点数。C++可以在必要时进行不同数据类型间的换算。例如：short result;long num1 = 200;long num2 = 200;result = num1 * num2;这里我想将两个长整型的积赋予一个短整型。尽管这个公式混用了两种数据类型，但<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>能够进行换算。计算结果会怎样呢?结果会让你大吃一惊，是25536，这是绕接(wrop)的结果。从表1.1可以看出，短整型的最大取值为32767，在最大值之上加1会怎么样呢?得到的是32768。这实际上与汽车里程计从99999回到00000的道理一样。为了说明这点，请输入并运行下列清单1.3中包含的程序。&nbsp;<br> 清单1.3Wrapme.cpp&nbsp;<br> 1: #include &lt;iostream.h&gt;&nbsp;<br> 2: #include &lt;conio.h&gt;&nbsp;<br> 3: #pragma hdrstop&nbsp;<br> 4:&nbsp;<br> 5: int main(int argc,char **argv)&nbsp;<br> 6: {&nbsp;<br> 7:short x = 32767;&nbsp;<br> 8:cout &lt;&lt; " x = " &lt;&lt; x &lt;&lt; endl;&nbsp;<br> 9:x++;&nbsp;<br> 10: cout &lt;&lt; " x = " &lt;&lt; x &lt;&lt; endl;&nbsp;<br> 11: getch();&nbsp;<br> 12: return 0;&nbsp;<br> 13: }&nbsp;<br> 说明后面几节要介绍的有些清单没有下列语句：&nbsp;<br> #include&lt;condefs.h&gt;&nbsp;<br> C++ Builder生成新的控制台应用程序时会自动加上这条语句。这在你所用的程序中不是必须的，所以代码清单中将其省略。无论有无这条语句，程序运行结果是一致的。分析输出结果为：x=32767 x=32768如果用int数据类型，则不会有这个问题，因为int数据类型的取值范围在正向20亿之间，一般不会有绕回的问题。但这时程序可能会稍大一些，因为int需要4字节存储，而short只需要2字节存储。对于大多数应用程序，这个差别是不显著的。前面介绍了自动类型换算。有时<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>无法进行换算，这时可能在编译器中产生编译错误，说Cannot convert from x to y(无法从x换算到Y)。编译器也可能警告说Conversion might lose significant digits（换算可能丢失显著位）。提示 编译器警告应当作编译器错误，因为它表明出了错误。我们应努力生成无警告的编译。有时警告无法避免，但一定要认真检查所有警告。应充分了解警告的原因并尽量予以纠正。</p> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>操作符&nbsp;<br> 操作符(operator)用于操作数据。操作符进行计算、检查等式、进行赋值、操作变量和进行其它更奇怪的工作。C++中有许多操作符，这里不想列出全部，只列出最常用的操作符，如下表所示。表1.2常用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>操作符操作符说明举例&nbsp;<br> 算术运算符&nbsp;<br> + 加 x=y+z;&nbsp;<br> - 减 x=y-z;&nbsp;<br> * 乘 x=y*z;&nbsp;<br> ／ 除 x=y／z;&nbsp;<br> 赋值运算符&nbsp;<br> = 赋值 x=10;&nbsp;<br> += 赋值与和 x+=10;(等于x=x+10;)&nbsp;<br> -= 赋值与减 x-=10;&nbsp;<br> *= 赋值与乘 x*=10;&nbsp;<br> \= 赋值与除 x\=10;&nbsp;<br> &amp;= 赋值位与 x&amp;=0x02;&nbsp;<br> |= 赋值位或 x|=0x02;&nbsp;<br> 逻辑操作符&nbsp;<br> &amp;&amp; 逻辑与 if(x &amp;&amp; 0xFF) {...}&nbsp;<br> || 逻辑或 if(x || 0xFF) {...}&nbsp;<br> 等式操作符&nbsp;<br> == 等于 if(x == 10) {...}&nbsp;<br> != 不等于 if(x != 10) {...}&nbsp;<br> &lt; 小于 if(x &lt; 10) {...}&nbsp;<br> &gt; 大于 if(x &gt; 10) {...}&nbsp;<br> &lt;= 小于或等于 if(x &lt;= 10) {...}&nbsp;<br> &gt;= 大于或等于 if(x &gt;= 10) {...}&nbsp;<br> 一元操作符&nbsp;<br> * 间接操作符 int x=*y;&nbsp;<br> &amp; 地址操作符 int* x=&amp;y;&nbsp;<br> ～ 位非 x &amp;=～0x02;&nbsp;<br> ! 逻辑非 if(!valid) {...}&nbsp;<br> ++ 递增操作符 x++（等于x=x+1;）&nbsp;<br> -- 递减操作符 x--;&nbsp;<br> 类和结构操作符&nbsp;<br> :: 范围解析 MyClass :: SomeFunction();&nbsp;<br> -&gt; 间接成员 MyClass-&gt; SomeFunction();&nbsp;<br> · 直接成员 MyClass . SomeFunction();&nbsp;<br> 可以看出，这个清单长了些，没法一下子记住。使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>时，你会慢慢熟悉这些操作符的。必须指出，递增操作符既可用作前递增(++x)，也可用作后递增(x++)。前递增操作符告诉编译器先递增再使用变量，而后递增操作符则让编译器先使用变量值再递增。例如下列代码：&nbsp;<br> int x = 10;&nbsp;<br> cout &lt;&lt; "x = " &lt;&lt; x++ &lt;&lt; end1;&nbsp;<br> cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; end1;&nbsp;<br> cout &lt;&lt; "x = " x &lt;&lt; end1;&nbsp;<br> cout &lt;&lt; "x = " &lt;&lt; ++x &lt;&lt; end1;&nbsp;<br> 输出结果如下：&nbsp;<br> x=10&nbsp;<br> x=11&nbsp;<br> x=12&nbsp;<br> x=12&nbsp;<br> 递减操作符也是这样，这里不想将这些内容讲得太深，但读者可以耐心阅读下去，正如彭兹对奥古斯特所说，“奥古，耐心点，罗马不是一天建成的”。说明 在C++中操作符可以过载(overload)。编程人员可以通过过载标准操作符让它在特定类中进行特定运行。例如，可以在一个类中过载递增操作符，让它将变量递增10而不是递增1。操作符过载是个高级C++技术，本书不准备详细介绍。你也许会发现，有些操作符使用了相同的符号。符号的意义随情境的不同而不同。例如，星号(*)可以作为乘号、声明指针或取消<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">指针</a>引用。这初看起来有点乱，事实上，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>编程老手有时也觉得有点乱。多实践，你会慢慢适应的。本书有许多例子介绍这些操作符。读者不必死记每个操作符的作用，而可以在学习中通过程序和码段去理解其作用。&nbsp;<br><br><a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>&nbsp;<br> 函数是与主程序分开的码段。这些码段在程序中需要进行特定动作时调用（执行）。例如，函数可能取两个值并对其进行复杂的数学运算。然后返回结果，函数可能取一个字串进行分析，然后返回分析字串的一部分。新术语 函数（function)是与主程序分开的码段，进行预定的一个服务。<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>是各种编程语言的重要部分，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>也不例外。最简单的函数不带参数，返回void（表示不返回任何东西），其它函数可能带一个或几个参数并可能返回一个值。函数名规则与变量名相同。图1.5显示了函数的构成部分。新术语 参数(parameter)是传递给<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>的值，用于改变操作或指示操作程度。&nbsp;<br> 返回类型&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>名 参数表&nbsp;<br> ↓ ↓ ↓&nbsp;<br> int SomeFunction(int x, int y){&nbsp;<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>体→int z = (x * y); return z; ↑返回语句&nbsp;<br> }&nbsp;<br> 图1.5函数的构成部分使用函数前，要先进行声明。函数声明或原型(prototype)告诉编译器函数所取的参数个数、每个参数的数据类型和函数返回值的数据类型。清单1.4列示了这个概念。新术语 原型(prototype)是<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>外观的声明或其定义的说明。&nbsp;<br> 清单1.4Muttiply.cpp&nbsp;<br> 1: #include &lt;iostream.h&gt;&nbsp;<br> 2: #include &lt;conio.h&gt;&nbsp;<br> 3: #pragma hdrstop&nbsp;<br> 4:&nbsp;<br> 5: int multiply(int,int)&nbsp;<br> 6: void showResult(int);&nbsp;<br> 7:&nbsp;<br> 8:int main(int argc,char **argv);&nbsp;<br> 9:{&nbsp;<br> 10: int x,y,result;&nbsp;<br> 11: cout &lt;&lt; end1 &lt;&lt; "Enter the first value:";&nbsp;<br> 12: cin &gt;&gt; x;&nbsp;<br> 13: cout &lt;&lt; "Enter the second value: ";&nbsp;<br> 14: cin &gt;&gt; y;&nbsp;<br> 15: result=multiply(x,y);&nbsp;<br> 16: showResult(result);&nbsp;<br> 17: cout &lt;&lt; end1 &lt;&lt; end1 &lt;&lt; "Press any key to continue...";&nbsp;<br> 18: getch();&nbsp;<br> 19: return 0&nbsp;<br> 20: }&nbsp;<br> 21:&nbsp;<br> 22: int multiply(int x,int y)&nbsp;<br> 23: {&nbsp;<br> 24:return x * y;&nbsp;<br> 25: }&nbsp;<br> 26:&nbsp;<br> 27: void showResult(int res)&nbsp;<br> 28: {&nbsp;<br> 29:cout &lt;&lt; "The result is: " &lt;&lt; res &lt;&lt;end1;&nbsp;<br> 30: }&nbsp;<br> 这个程序的11到14行用标准输入流cin向用户取两个数字，第15行调用multiply()函数将两个数相乘，第16行调用showResult()函数显示相乘的结果。注意主程序前面第5和第6行multiply()和showResult()函数的原型声明。原型中只列出了返回类型、函数名和函数参数的数据类型。这是函数声明的最基本要求。函数原型中还可以包含用于建档函数功能的变量名。例如，multiply()函数的函数声明可以写成如下：int multiply(int firstNumber,int secondNumber);这里函数multiply()的作用很明显，但代码既可通过说明也可通过代码本身建档。注意清单1.4中函数multiply()的定义(22到25行)在主函数定义码段(8到20行)之外。函数定义中包含实际的函数体。这里的函数体是最基本的，因为函数只是将函数的两个参数相乘并返回结果。清单1.4中函数multiply()可以用多种方法调用，可以传递变量、直接数或其它<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>调用的结果：&nbsp;<br> result = multiply(2,5);//passing literal values&nbsp;<br> result = multiply(x,y); //passing variables&nbsp;<br> showResult(multiply(x,y));&nbsp;<br> //return value used as a&nbsp;<br> //parameter for another function&nbsp;<br> multiply(x,y);//return value ignored&nbsp;<br> 注意 最后一例中没有使用返回值。本例中调用函数multiply()而不用返回值没什么道理，但C++编程中经常忽略返回值。有许多函数是先进行特定动作再返回一个数值，表示函数调用的状态。有时返回值与程序无关，可以忽略不计。如果将返回值忽略，则只是放弃这个值，而不会有别的危害。例如，前面的样本程序中忽略了getch()函数的返回值（返回所按键的ASCII值）。函数可以调用其它函数，甚至可以调用自己，这种调用称为递归(recursion)。这在C++编程中是个较复杂的问题，这里先不介绍。新术语 递归(recursion)就是函数调用自己的过程。本节介绍的函数指的是C或C++程序中的独立函数（独立<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>不是类的成员）。<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中的独立<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>可以和<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cyy/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C语言</a>中一样使用，但C++将<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>进一步深化，将在稍后介绍<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>时介绍。</p> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>规则&nbsp;<br> ·&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>可以取任意多个参数或不取参数。&nbsp;<br> · 函数可以返回一个值，但<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>不强求返回一个值。&nbsp;<br> · 如果<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>返回void类型，则不能返回数值。&nbsp;<br> 如果要让返回void类型的函数返回数值，则会发生编译错误。返回void类型的函数不需包含return语句，但也可以包含这个语句。如果没有return语句，则<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>到达末尾的结束大括号时自动返回。&nbsp;<br> · 如果函数原型表示函数返回数值，则函数体中应包含返回数值的return语句，如果<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>不返回数值，则会发生编译错误。&nbsp;<br> ·&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>可以取任意多个参数，但只能返回一个数值。&nbsp;<br> · 变量可以按数值、<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">指针</a>或引用传递给<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>（将在稍后介绍）。&nbsp;<br> 语法：<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>语句的声明（原型）格式如下： ret_type function_name(argtype_1 arg_1,argtype_2 arg_2,...,argtype_n arg_n);&nbsp;<br> 函数声明表示代码中要包括的函数，应当显示函数的返回数据类型(ret_type)和函数名(function_name)，表示<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>所要数据变元的顺序（arg_1,arg_2,...,arg_n)和类型(argtype_1,argtype_2,...argtype_n)。&nbsp;<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>语句的定义格式如下：&nbsp;<br> ret_type function_name(argtype_1 arg_1,argtype_2 arg_2,...,argtype_narg_n);&nbsp;<br> { statements;&nbsp;<br> return ret_type; }&nbsp;<br> 函数定义表示构成函数的代码块(statements),应当显示函数的返回数据类型(ret type)和函数名(function_name)，包括<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>所要数据变元（arg_1,arg_2,...,arg_n)和类型(argtype_1,argtype_2,...argtype_n)。&nbsp;<br><br> main()<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>&nbsp;<br> C++程序必须有main()函数。main()函数是程序的入口点。前面介绍的每个样本程序都有main()函数。但是，并非所有C++程序都有传统的main()函数。用C或C++写成的Windows程序入口点函数称为WinMain()，而不是传统的main()函数。说明 C++ Builder GUI应用程序有WinMain()，但隐藏起来了。C++ Builder使用户无需考虑Windows程序的低级细节，而可以集中考虑程序用户界面和其它部分的创建。main()函数和其它函数一样是<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>，有相同的构成部分。在32位控制台应用程序中，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>&nbsp;Builder生成具有下列原型的缺省main()函数：int main(int argc,char** argv);这个main()函数形式取两个参数并返回一个整型值。前面说过，数值在调用函数时传递给函数。但对于main()函数，没有直接调用，而是在程序运行时自动执行。那么，main()<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>如何取得参数呢?办法是从命令行取得。现说明如下：假设有个Win32控制台应用程序要在DOS提示下用下列命令行执行：grep WM_KILLFOCUS 杁 -i&nbsp;<br> 这里要用命令行变元WM_KILLFOCUS、d和i启动程序grep,我们要演示如何在main()<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>中将其变为argc和argv.首先，整型变量argc包含命令行中传递的参数个数，至少为1，因为程序名也算作参数。变量argv是个数组，包含字串的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%D6%B8%D5%EB&amp;Submit=+%CB%D1%CB%F7+" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">指针</a>。这个数组包含命令行中传递的每个字串。本例中：&nbsp;<br> argc包含4&nbsp;<br> argv[0] 包含C:|cbuilder|bin|grep.exe&nbsp;<br> argv[1] 包含WM_KILLFOCUS&nbsp;<br> argv[2] 包含 d&nbsp;<br> argv[3] 包含 i&nbsp;<br> 下面用一个小程序验证这个事实。在<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>&nbsp;Builder中生成新的控制台应用程序并输入清单1.5所示的程序。清单1.5Argstest.cpp&nbsp;<br> 1: #include &lt;iostream.h&gt;&nbsp;<br> 2: #include &lt;conio.h&gt;&nbsp;<br> 3: #pragma hdrstop&nbsp;<br> 4:&nbsp;<br> 5: int main(int argc,char **argv)&nbsp;<br> 6: {&nbsp;<br> 7:cout &lt;&lt; "argv = "argc &lt;&lt; end1;&nbsp;<br> 8.for (int i=0;i&lt;argc;i++)&nbsp;<br> 9. cout &lt;&lt; "Parameter " &lt;&lt; i &lt;&lt; ": " &lt;&lt; argv[i]&lt;&lt; end1;&nbsp;<br> 10. cout &lt;&lt; end1 &lt;&lt; "Press any key to continue...";&nbsp;<br> 11: getch();&nbsp;<br> 12: return 0;&nbsp;<br> 13: }&nbsp;<br> 将这个项目存为Argstest，然后不是单击Run按钮，而是选择主菜单中的Project|Build All，这样只建立项目而不执行程序。项目建成后，选择主菜单中的Run|Parameters,在RunParameters对话框RunParameters字段中输入下列内容：one two three "four five" six然后单击Run按钮，程序即用所指定的命令行参数运行。另一种办法是用下列命令行在DOS提示下运行程序：argstest one two three "four five" six程序运行时，它会显示传入的变元数，然后列出每个变元。运行几次，每次提供不同命令行变元，注意产生的结果。&nbsp;<br> 大多数程序中main()函数的返回值并不重要，因为通常不使用返回值。事实上，可以不要求main()函数返回数值。main()<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>的形式有多种，下列声明均有效：main();int main();// same as above&nbsp;<br> int main(void); // same as above&nbsp;<br> int main(int argc,char** argv);&nbsp;<br> void main();&nbsp;<br> void main(int argc, char** argv);&nbsp;<br> 还有更多的形式。如果不想使用命令行变元，则可以用第一种main()函数形式，其不取参数（括号内为空的）并返回一个int(不指定时返回缺省返回值）。换句话说main()<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>最基本的形式不取参数并返回一个int。&nbsp;<br><br> 数组&nbsp;<br> 任何<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>固有数据类型都可以放进数组中。数组(array)就是数值的集合。例如，假设要保存一个整型数组，放五个整型值。可以声明数组如下：int myArray[5];这里编译器为数组分配图1.7所示的内存空间。由于每个int要4个字节存储，所以整个数组占用20字节的内存空间。&nbsp;<br> mArray[0]mArray[1]mArray[2]mArray[3]&nbsp;<br> mArray[4]&nbsp;<br> baseAddrbasseAddr+4baseAddr+8&nbsp;<br> baseAddr+12baseAddr+16&nbsp;<br> 声明数组后，就可以用如下脚标操作符([])填入数值：&nbsp;<br> myArray[0] = -200;&nbsp;<br> myArray[1] = -100;&nbsp;<br> myArray[2] = 0;&nbsp;<br> myArray[3] = 100;&nbsp;<br> myArray[4] = 200;&nbsp;<br> 由上可见，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>中的数组是以0为基数的。后面程序中可以用脚标操作符访问数组的各个元素：&nbsp;<br> int result=myarray[3]+myArray[4]; // result will be 300&nbsp;<br> 还有一次声明和填入整个数组内容的简捷方法如下：&nbsp;<br> int myArray[5] = {-200, -100,0,100,200};&nbsp;<br> 进一步说，如果知道数组的元素个数，并在声明数组时填充数组，则声明数组时连数组长度都可以省略。例如：int myArray[] = {-200, -100,0,100,200 };这是可行的，因为编译器从赋予的数值表可以判断出数组中元素的个数和分配给数组的内存空间。&nbsp;<br> 数组可以是多维的。为了生成两维整型数组，可用下列代码：&nbsp;<br> int mdArray[3][5];&nbsp;<br> 这样就分配15个int空间(共60字节)。数组的元素可以和一维数组一样访问，只是要提供两个脚标操作符：int x = mdArray[1][1]+mdArray[2][1];&nbsp;<br> 图1.8两维数组在内存中的样子警告 注意不要重载数组末尾。&nbsp;<br> C++一个强大的特性是能直接访问内存。由于这个特性，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>无法阻止你写入特定内存地址，即使这个地址是程序不让访问的。下列代码是合法的，但会导致程序或Windows崩溃：int array[5];array[5]=10;这是常见的错误，因为数组是以0为基数的，最大脚标应是4而不是5。如果重载数组末尾，则无法知道哪个内存被改写了，使结果难以预料，甚至会导致程序或Windows崩溃。这类问题很难诊断，因为受影响的内存通常要在很久以后才访问，这时才发生崩溃（让你莫名其中之妙）。所以写入数组时一定要小心。&nbsp;<br> 数组规则&nbsp;<br> ·数组是以0为基数。数组中的第一个元素为0，第二个元素为1，第三个元素为2，等等。&nbsp;<br> ·数组长度应为编译常量。编译器在编译时必须知道为数组分配多少内存空间。不能用变量指定数组长度。所以下列代码不合法，会导致编译错误：&nbsp;<br> int x = 10;int myArray[x]; // compiler error here·&nbsp;<br> 小心不要重载数组末尾。&nbsp;<br> · 大数组从堆叠（heap）而不是堆栈(stack)中分配(详见稍后)。· 从堆叠分配的数组可以用变量指定数组长度。例如：int x = 10;int* myArray = new int[x]; // this is OK</p> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">字符数组&nbsp;<br> 奇怪的是，C++不支持字串变量（放置文本的变量），<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>程序中的字串是用char数据类型的数组表示的。例如，可以将变量赋予char数组如下：&nbsp;<br> char text[] = "This is a string.";&nbsp;<br> 这就在内存中分配18字节的内存空间用于存放字串。根据你的领悟能力，也许你会发现该字串中只有17个字符。分配18个字节的原因是字串要以终止null结尾，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>在分配内存空间时把终止null算作一个字符。&nbsp;<br> 新术语 终止null是个特殊字符，用|0表示，等于数值0。程序遇到字符数组中的0时，表示已经到字串末尾。为了说明这点，输入并运行下列控制台应用程序。&nbsp;<br> 清单1.6Nulltest.cpp&nbsp;<br> 1: #include &lt;iostream.h&gt;&nbsp;<br> 2: #include &lt;conio.h&gt;&nbsp;<br> 3: #pragma hdrstop&nbsp;<br> 4:&nbsp;<br> 5: int main(int argc,char **argv)&nbsp;<br> 6: {&nbsp;<br> 7:char str[]="This is a string.";&nbsp;<br> 8.cout &lt;&lt; str &lt;&lt; end1;&nbsp;<br> 9.str[7]= '\0';&nbsp;<br> 10. cout &lt;&lt; str &lt;&lt; end1&nbsp;<br> 11. cout &lt;&lt; end1 &lt;&lt; "Press any key to continue...";&nbsp;<br> 12: getch();&nbsp;<br> 13: return 0;&nbsp;<br> 14: }&nbsp;<br> 分析 最初，字符数组包含字符串This is a string和一个终止null，这个字串通过cout送到屏幕上。下一行将数组的第7个元素赋值为|0，即终止null。字串再次发送到屏幕上，但这时只显示This is。原因是计算机认为数组中字串在第7个元素上终止，余下字串仍然在内存空间中，但不显示，因为遇到了终止null。图1.10演示了将数组的第7个元素赋值为|0的语句前后的字符数组。&nbsp;<br> 之前&nbsp;<br> Thi&nbsp;<br> sisastri&nbsp;<br> ng.\0&nbsp;<br> 之后&nbsp;<br> This&nbsp;<br> is\0astri&nbsp;<br> ng.\0&nbsp;<br> 图1.10字符数组的内容&nbsp;<br> 清单1.6中也可以赋值0而不是'|0'，结果相同，因为数字0和char数据类型'|0'是等值的。例如，下列语句是等价的：&nbsp;<br> str[7] = '|0';&nbsp;<br> str[7] = 0;&nbsp;<br> 说明&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>程序中单引号与双引号是有差别的。向数组元素赋值终止null和其它字符值时，必须用单引号。单引号的作用是将引号内的字符变成整型值（该字符的ASCII值），然后将这个值存放在内存地址中。将字串赋予字符数组时，必须用双引号。如果用错引号，则编译器会发生编译错误。</p> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">字串操作<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>&nbsp;<br> 如果你用过具有string数据类型的编程语言，你可能很不习惯，别人也有同感，所以标准<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cyy/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C语言</a>库中提供了几个字串操作函数。表1.3列出了最常用的字串操作函数及其用法说明。关于每个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>的详细说明和实例，见<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>&nbsp;Builder联机帮助。&nbsp;<br> 表1.3字串操作<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>&nbsp;<br><a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>&nbsp;说明&nbsp;<br> strcat() 将字串接合到目标字串的末尾&nbsp;<br> strcmp() 比较两个字串是否相等&nbsp;<br> strcmpi() 比较两个字串是否相等，不考虑大小写&nbsp;<br> strcpy() 将字串内容复制到目标字串中&nbsp;<br> strstr() 扫描字串中第一个出现的字串&nbsp;<br> strlen() 返回字串长度&nbsp;<br> strupr() 将字串中的所有字符变成大写&nbsp;<br> sprintf() 根据几个参数建立字串&nbsp;<br> 说明 这里介绍的字串操作是C语言中的字串处理方法。大多数C++编译器提供了cstring类，可以简化字串的处理(C++ Builder的Visual构件库中有个AnsiString类，可以处理字串操作。C++ Builder联机帮助中详细介绍了AnsiString类)。尽管C语言中的字串处理方法比较麻烦，但并不过时，<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>编程人员经常在使用cstring类和AnsiString类等字串类的同时使用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cyy/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C语言</a>中的字串处理方法。这里不想对表中的每个函数进行举例说明，只想举两个最常用的函数。strcpy()<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>将一个字串复制到另一字串中，源字串可以是变量或直接字串。例如下列代码：&nbsp;<br> //set up a string to hold 29 characters&nbsp;<br> char buff[30];&nbsp;<br> //copy a string literal to the buffer&nbsp;<br> strcpy (buff,"This is a test.");//display it&nbsp;<br> cout &lt;&lt; buff &lt;&lt; end;&nbsp;<br> //initialize a second string buffer&nbsp;<br> char buff2[]="A second string.";&nbsp;<br> //copy the contents of this string to the first buffer&nbsp;<br> strcpy (buff,buff2);&nbsp;<br> cout &lt;&lt; buff &lt;&lt; end1;&nbsp;<br> 字符数组中比数字数组中更容易重载数字末尾。例如下列代码：&nbsp;<br> char buff[10]= "A string";// later....&nbsp;<br> strcpy(buff,"This is a test."); //oops!&nbsp;<br> 这里建立了放10个字符的字符数组，最初指定需要9个字节的字符串（记住终止null)。后来可能忘记了数组长度，将需要16个字节的字串复制到了缓冲区，对数组重载了六个字节。这个小小错误就擦去了某个内存位置上的六个字节。所以将数据复制到字符数组中时要特别小心。另一个常用的字串函数是sprintf()。这个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>可以混合文本和数字建立格式化字串。下面例子将两个数相加，然后用sprintf()建立字串以报告结果：&nbsp;<br> char buff[20];&nbsp;<br> int x = 10 * 20;&nbsp;<br> sprintf(buff,"The result is: %d",x);&nbsp;<br> cout &lt;&lt; buff;&nbsp;<br> 执行这个码段时，程序显示下列结果：The result is:200&nbsp;<br> 本例中%d告诉sprintf()函数此处有个整型值，格式字串末尾插入变量x，告诉sprintf()在字串的这个位置放上变量x的值。sprintf()是个特别的<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>，可以取多个变元。你必须提供目标缓冲区和格式字串，但格式字串后面的变元数是个变量。下面的sprintf()例子用了另外三个变元：&nbsp;<br> int x = 20;&nbsp;<br> int y = 5;&nbsp;<br> sprintf(buff, "%d + %d", x, y, x + y);&nbsp;<br> cout &lt;&lt; buff;&nbsp;<br> 执行这个码段时，屏幕上显示的结果如下：20 + 5 = 25&nbsp;<br> 说明&nbsp;<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>字串中的单斜杠表示特殊字符。例如，'\n'表示新行符，'\t'表示跳表符。为了在字串中放上实际的斜杠，要用双斜杠如下：&nbsp;<br> strcpy(fileName, "c:\\windows\\system\\win.ini");&nbsp;<br> 许多编程人员因为忘了这个简单的事实而夜不能寐，苦苦折腾。这是个常见的错误，别说我没有告诉你。sprintf()有个兄弟叫wsprintf()，是Windows版的sprintf().Windows程序中可能同时用这两个函数。wsprintf()与sprintf()的作用相似，唯一的差别是不能在格式字串中放上浮点数。C++ Builder程序中两个<a class="channel_keylink" href="http://www.bc-cn.net/Article/Search.asp?Field=Title&amp;ClassID=&amp;keyword=%BA%AF%CA%FD" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">函数</a>均可使用，但用sprintf()更好，因为它完全支持浮点数（还可以少输入一个字符）。关于sprintf()的进一步介绍，见<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>&nbsp;Builder联机帮助。&nbsp;<br><br> 字串数组不仅可以有字符数组，还可以有字符数组的数组（即字串数组）。这听起来有点复杂，其实前面的Argstest程序中已经用过。这类数组可以分配如下：&nbsp;<br> char strings[][20] = {&nbsp;<br> "This is string 1",&nbsp;<br> "This is string 2",&nbsp;<br> "This is string 3",&nbsp;<br> "This is string 4"};&nbsp;<br> 这个代码生成四个字串的数组，每个字串最多放19个字符。尽管可以使用这种字串数组，但C++ Builder中还有更简单的字串数组处理办法（将在后面介绍<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cjj/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C++</a>&nbsp;Builder时介绍）。说明 如果经常用到字串数组，应当看看标准模板库(STL).STL提供了比用<a class="channel_keylink" href="http://www.bc-cn.net/Article/kfyy/cyy/Index.html" rel="nofollow" style="color:rgb(255,51,102);text-decoration:none;">C语言</a>式字符数组更方便地存放和操作字串数组的方法.STL中还有个string类。</p> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p><font><span style="font-size:14px;">本文转自茄子_2008博客园博客，原文链接：http://www.cnblogs.com/xd502djj/archive/2010/09/23/1833363.html</span></font><span style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者。</span></p> 
   <div>
    <br>
   </div> 
   <p style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
