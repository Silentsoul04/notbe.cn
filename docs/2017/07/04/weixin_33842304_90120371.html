<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Socket编程小结 « NotBeCN</title>
  <meta name="description" content="                  目录：&nbsp;     什么是&nbsp;socket？...&nbsp;1     Internet&nbsp;套接字的两种类型...&nbsp;1     网络理论...&nbsp;2     结构体...&nbsp;2     本机转换...&nbsp;3     I...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/07/04/weixin_33842304_90120371.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Socket编程小结</h1>
    <p class="post-meta">Jul 4, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <p><span>目录：<span>&nbsp;<br></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267852" rel="nofollow" style="color:rgb(52,104,164);"><span><span>什么是</span></span>&nbsp;socket<span><span>？</span></span><span><span>...&nbsp;</span></span><span>1</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267853" rel="nofollow" style="color:rgb(52,104,164);"><span>Internet&nbsp;</span><span><span>套接字的两种类型</span></span><span><span>...&nbsp;</span></span><span>1</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267854" rel="nofollow" style="color:rgb(52,104,164);"><span><span>网络理论</span></span><span><span>...&nbsp;</span></span><span>2</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267855" rel="nofollow" style="color:rgb(52,104,164);"><span><span>结构体</span></span><span><span>...&nbsp;</span></span><span>2</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267856" rel="nofollow" style="color:rgb(52,104,164);"><span><span>本机转换</span></span><span><span>...&nbsp;</span></span><span>3</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267857" rel="nofollow" style="color:rgb(52,104,164);"><span>IP&nbsp;</span><span><span>地址和如何处理它们</span></span><span><span>...&nbsp;</span></span><span>4</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267858" rel="nofollow" style="color:rgb(52,104,164);"><span>socket()</span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>4</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267859" rel="nofollow" style="color:rgb(52,104,164);"><span>bind()</span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>4</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267860" rel="nofollow" style="color:rgb(52,104,164);"><span>connect()</span><span><span>程序</span></span><span><span>...&nbsp;</span></span><span>5</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267861" rel="nofollow" style="color:rgb(52,104,164);"><span>listen()</span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>6</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267862" rel="nofollow" style="color:rgb(52,104,164);"><span>accept()</span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>6</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267863" rel="nofollow" style="color:rgb(52,104,164);"><span>send() and recv()</span><span><span>&nbsp;</span></span><span>7</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267864" rel="nofollow" style="color:rgb(52,104,164);"><span>sendto()&nbsp;</span><span><span>和 recvfrom()</span></span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>7</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267865" rel="nofollow" style="color:rgb(52,104,164);"><span>close()</span><span><span>和shutdown()</span></span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>8</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267866" rel="nofollow" style="color:rgb(52,104,164);"><span>getpeername()</span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>8</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267867" rel="nofollow" style="color:rgb(52,104,164);"><span>gethostname()</span><span><span>函数</span></span><span><span>...&nbsp;</span></span><span>8</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267868" rel="nofollow" style="color:rgb(52,104,164);"><span><span>域名服务（DNS</span></span><span><span>）</span></span><span><span>...&nbsp;</span></span><span>8</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267869" rel="nofollow" style="color:rgb(52,104,164);"><span><span>客户-</span></span><span><span>服务器背景知识</span></span><span><span>...&nbsp;</span></span><span>9</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267870" rel="nofollow" style="color:rgb(52,104,164);"><span><span>简单的服务器</span></span><span><span>...&nbsp;</span></span><span>9</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267871" rel="nofollow" style="color:rgb(52,104,164);"><span><span>简单的客户程序</span></span><span><span>...&nbsp;</span></span><span>10</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267872" rel="nofollow" style="color:rgb(52,104,164);"><span><span>数据包 Sockets</span></span><span><span>&nbsp;</span></span><span>11</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267873" rel="nofollow" style="color:rgb(52,104,164);"><span><span>阻塞</span></span><span><span>...&nbsp;</span></span><span>13</span></a></span></span></p> 
    <p><span><span><a href="http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html#_Toc151267874" rel="nofollow" style="color:rgb(52,104,164);"><span>select()--</span><span><span>多路同步 I/O</span></span><span><span>..&nbsp;</span></span><span>13</span></a></span></span></p> 
    <p><span><br><br> --------------------------------------------------------------------------------&nbsp;<br><br></span></p> 
    <p><a name="_Toc151267852">什么是</a><span>&nbsp;socket</span><span>？</span></p> 
    <p><span>你经常听到人们谈论着 “<span>socket</span>”，或许你还不知道它的确切含义。现在让我告诉你：它是使用标准<span>Unix&nbsp;</span>文件描述符<span>&nbsp;(file descriptor)&nbsp;</span>和其它程序通讯的方式。什么？你也许听到一些<span>Unix</span>高手<span>(hacker)</span>这样说过：“呀，<span>Unix</span>中的一切就是文件！”那个家伙也许正在说到一个事实：<span>Unix&nbsp;</span>程序在执行任何形式的<span>&nbsp;I/O&nbsp;</span>的时候，程序是在读或者写一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数。但是<span>(</span>注意后面的话<span>)</span>，这个文件可能是一个网络连接，<span>&nbsp;FIFO</span>，管道，终端，磁盘上的文件或者什么其它的东西。<span>Unix&nbsp;</span>中所有的东西就是文件！所以，你想和<span>Internet</span>上别的程序通讯的时候，你将要使用到文件描述符。你必须理解刚才的话。现在你脑海中或许冒出这样的念头：“那么我从哪里得到网络通讯的文件描述符呢？”，这个问题无论如何我都要回答：你利用系统调用<span>&nbsp;socket()</span>，它返回套接字描述符<span>&nbsp;(socket descriptor)</span>，然后你再通过它来进行<span>send()</span>和<span>&nbsp;recv()</span>调用。 “但是<span>...</span>”，你可能有很大的疑惑，“如果它是个文件描述符，那么为什 么不用一般调用<span>read()</span>和<span>write()</span>来进行套接字通讯？”简单的答案是：“你可以使用！”。详细的答案是：“你可以，但是使用<span>send()</span>和<span>recv()</span>让你更好的控制数据传输。”<span>&nbsp;<br></span>存在这样一个情况：在我们的世界上，有很多种套接字。有<span>DARPA Internet&nbsp;</span>地址<span>&nbsp;(Internet&nbsp;</span>套接字<span>)</span>，本地节点的路径名<span>&nbsp;(Unix</span>套接字<span>)</span>，<span>CCITT X.25</span>地址<span>&nbsp;(</span>你可以将<span>X.25&nbsp;</span>套接字完全忽略<span>)</span>。也许在你的<span>Unix&nbsp;</span>机器上还有其它的。我们在这里只讲第一种：<span>Internet&nbsp;</span>套接字。</span></p> 
    <p><a name="_Toc151267853">Internet&nbsp;</a><span>套接字的两种类型</span><span>&nbsp;<br></span><span>　　什么意思？有两种类型的<span>Internet&nbsp;</span>套接字？是的。不，我在撒谎。其实还有很多，但是我可不想吓着你。我们这里只讲两种。除了这些<span>,&nbsp;</span>我打算另外介绍的<span>&nbsp;"Raw Sockets"&nbsp;</span>也是非常强大的，很值得查阅。<span>&nbsp;<br></span>那么这两种类型是什么呢？<strong><em><span>一种是<span>"Stream Sockets"</span>（流格式），另外一种是<span>"Datagram Sockets"</span>（数据包格式）</span></em></strong>。我们以后谈到它们的时候也会用到<span>&nbsp;"SOCK_STREAM"&nbsp;</span>和<span>&nbsp;"SOCK_DGRAM"</span>。<strong><em><span>数据报套接字有时也叫“无连接套接字”</span></em></strong><span>(</span>如果你确实要连接的时候可以用<span>connect()</span>。<span>)&nbsp;</span><strong><em><span>流式套接字是可靠的双向通讯的数据流</span></em></strong>。如果你向套接字按顺序输出“<span>1</span>，<span>2</span>”，那么它们将按顺序“<span>1</span>，<span>2</span>”到达另一边。它们是无错误的传递的，有自己的错误控制，在此不讨论。<span>&nbsp;<br></span>有什么在使用流式套接字？你可能听说过<span>&nbsp;telnet</span>，不是吗？它就使用流式套接字。你需要你所输入的字符按顺序到达，不是吗？同样，<span>WWW</span>浏览器使用的<span>&nbsp;HTTP&nbsp;</span>协议也使用它们来下载页面。实际上，当你通过端口<span>80 telnet</span>到一个<span>&nbsp;WWW&nbsp;</span>站点，然后输入 “<span>GET pagename</span>” 的时候，你也可以得到<span>&nbsp;HTML&nbsp;</span>的内容。为什么流式套接字可以达到高质量的数据传输？这是因为它使用了“传输控制协议<span>&nbsp;(The Transmission Control Protocol)</span>”，也叫 “<span>TCP</span>”<span>&nbsp;(</span>请参考<span>&nbsp;RFC-793&nbsp;</span>获得详细资料。<span>)TCP&nbsp;</span>控制你的数据按顺序到达并且没有错误。你也许听到 “<span>TCP</span>” 是因为听到过 “<span>TCP/IP</span>”。这里的<span>&nbsp;IP&nbsp;</span>是指“<span>Internet&nbsp;</span>协议”<span>(</span>请参考<span>&nbsp;RFC-791</span>。<span>) IP&nbsp;</span>只是处理<span>&nbsp;Internet&nbsp;</span>路由而已。</span></p> 
    <p><strong><em>那么数据报套接字呢？为什么它叫无连接呢？为什么它是不可靠的呢？有这样的一些事实：如果你发送一个数据报，它可能会到达，它可能次序颠倒了</em></strong><span>。如果它到达，那么在这个包的内部是无错误的。数据报也使用<span>&nbsp;IP&nbsp;</span>作路由，但是它不使用<span>&nbsp;TCP</span>。它使用“用户数据报协议<span>&nbsp;(User Datagram Protocol)</span>”，也叫 “<span>UDP</span>”<span>&nbsp;(</span>请参考<span>&nbsp;RFC-768</span>。<span>)</span>为什么它们是无连接的呢？主要是因为它并不象流式套接字那样维持一个连接。你只要建立一个包，构造一个有目标信息的<span>IP&nbsp;</span>头，然后发出去。无需连接。它们通常使用于传输包<span>-</span>包信息。简单的应用程序有：<span>tftp, bootp</span>等等。<span>&nbsp;<br></span>你也许会想：“假如数据丢失了这些程序如何正常工作？”我的朋友，每个程序在<span>&nbsp;UDP&nbsp;</span>上有自己的协议。例如，<span>tftp&nbsp;</span>协议每发出的一个被接受到包，收到者必须发回一个包来说“我收到了！”<span>&nbsp;(</span>一个“命令正确应答”也叫“<span>ACK</span>” 包<span>)</span>。如果在一定时间内<span>(</span>例如<span>5</span>秒<span>)</span>，发送方没有收到应答，它将重新发送，直到得到<span>&nbsp;ACK</span>。这一<span>ACK</span>过程在实现<span>&nbsp;SOCK_DGRAM&nbsp;</span>应用程序的时候非常重要。</span></p> 
    <p><a name="_Toc151267854">网络理论</a><span>&nbsp;<br></span><span>　　既然我刚才提到了协议层，那么现在是讨论网络究竟如何工作和一些关于<span>&nbsp;SOCK_DGRAM&nbsp;</span>包是如何建立的例子。当然，你也可以跳过这一段， 如果你认为已经熟悉的话。现在是学习数据封装<span>&nbsp;(Data Encapsulation)&nbsp;</span>的时候了！它非常非常重 要。它重要性重要到你在网络课程学（图<span>1</span>：数据封装）习中无论如何也得也得掌握它。主要 的内容是：一个包，先是被第一个协议<span>(</span>在这里是<span>TFTP )</span>在它的报头（也许是报尾）包装<span>(</span>“封装”<span>)</span>，然后，整个数据<span>(</span>包括<span>&nbsp;TFTP&nbsp;</span>头<span>)</span>被另外一个协议<span>&nbsp;(</span>在这里是<span>&nbsp;UDP )</span>封装，然后下一个<span>( IP )</span>，一直重复下去，直到硬件<span>(</span>物理<span>)&nbsp;</span>层<span>(&nbsp;</span>这里是以太网<span>&nbsp;)</span>。当另外一台机器接收到包，硬件先剥去以太网头，内核剥去<span>IP</span>和<span>UDP&nbsp;</span>头，<span>TFTP</span>程序再剥去<span>TFTP</span>头，最后得到数据。现在我们终于讲到声名狼藉的网络分层模型<span>&nbsp;(Layered Network Model)</span>。这种网络模型在描述网络系统上相对其它模型有很多优点。例如， 你可以写一个套接字程序而不用关心数据的物理传输<span>(</span>串行口，以太网，连接单元接口<span>&nbsp;(AUI)&nbsp;</span>还是其它介质<span>)</span>，因为底层的程序会为你处理它们。实际 的网络硬件和拓扑对于程序员来说是透明的。不说其它废话了，我现在列出整个层次模型。如果你要参加网络考试，可一定要记住：</span></p> 
    <p><span>应用层<span>&nbsp;(Application)</span></span></p> 
    <p><span>表示层<span>&nbsp;(Presentation)</span></span></p> 
    <p><span>会话层<span>&nbsp;(Session)</span></span></p> 
    <p><span>传输层<span>(Transport)</span></span></p> 
    <p><span>网络层<span>(Network)</span></span></p> 
    <p><span>数据链路层<span>(Data Link)</span></span></p> 
    <p><span>物理层<span>(Physical)</span></span></p> 
    <p><span>物理层是硬件<span>(</span>串口，以太网等等<span>)</span>。应用层是和硬件层相隔最远的<span>--</span>它 是用户和网络交互的地方。这个模型如此通用，如果你想，你可以把它作为修车指南。把它对应 到<span>&nbsp;Unix</span>，结果是：<span>&nbsp;<br></span>应用层<span>(Application Layer) (telnet, ftp,</span>等等<span>)</span>传输层<span>(Host-to-Host Transport Layer) (TCP, UDP)Internet</span>层<span>(Internet Layer) (IP</span>和路由<span>)</span>网络访问层<span>&nbsp;(Network Access Layer) (</span>网络层，数据链路层和物理层<span>)</span></span></p> 
    <p><span>现在，你可能看到这些层次如何协调来封装原始的数据了。<span>&nbsp;<br></span>看看建立一个简单的数据包有多少工作？哎呀，你将不得不使用<span>&nbsp;"cat"&nbsp;</span>来建立数据包头！这仅仅是个玩笑。对于流式套接字你要作的是<span>&nbsp;send()&nbsp;</span>发送数据。对于数据报式套接字，你按照你选择的方式封装数据然后使用<span>sendto()</span>。内核将为你建立传输层和<span>&nbsp;Internet&nbsp;</span>层，硬件完成网络访问层。 这就是现代科技。现在结束我们的网络理论速成班。哦，忘记告诉你关于路由的事情了。但是我不准备谈它，如果你真的关心，那么参考<span>&nbsp;IP RFC</span>。</span></p> 
    <p><a name="_Toc151267855">结构体</a><span>&nbsp;<br></span><span>　　终于谈到编程了。在这章，我将谈到被套接字用到的各种数据类型。因为它们中的一些内容很重要了。首先是简单的一个：<span>socket</span>描述符。它是下面的类型：<span>int&nbsp;<br></span>仅仅是一个常见的<span>&nbsp;int</span>。从现在起，事情变得不可思议了，而你所需做的就是继续看下去。注 意这样的事实：有两种字节排列顺序：重要的字节<span>&nbsp;(</span>有时叫<span>&nbsp;"octet"</span>，即八位位组<span>)&nbsp;</span>在前面，或者不重要的字节在前面。前一种叫“网络字节顺序<span>&nbsp;(Network Byte Order)</span>”。有些机器在内部是按照这个顺序储存数据，而另外 一些则不然。当我说某数据必须按照<span>&nbsp;NBO&nbsp;</span>顺序，那么你要调用函数<span>(</span>例如<span>&nbsp;htons() )</span>来将它从本机字节顺序<span>&nbsp;(Host Byte Order)&nbsp;</span>转换过来。如果我没有 提到<span>&nbsp;NBO</span>，那么就让它保持本机字节顺序。我的第一个结构<span>(</span>在这个技术手册<span>TM</span>中<span>)--struct sockaddr.</span>。这个结构 为许多类型的套接字储存套接字地址信息：<span>&nbsp;<br> struct sockaddr {&nbsp;<br></span>　　<span>&nbsp;unsigned short sa_family; /*&nbsp;</span>地址家族<span>, AF_xxx */&nbsp;<br></span>　　<span>&nbsp;char sa_data[14]; /*14</span>字节协议地址<span>*/&nbsp;<br></span>　　<span>&nbsp;};&nbsp;<br> sa_family&nbsp;</span>能够是各种各样的类型，但是在这篇文章中都是<span>&nbsp;"AF_INET"</span>。<span>&nbsp;sa_data</span>包含套接字中的目标地址和端口信息。这好像有点 不明智。<span>&nbsp;<br></span>为了处理<span>struct sockaddr</span>，程序员创造了一个并列的结构：<span>&nbsp;struct sockaddr_in ("in"&nbsp;</span>代表<span>&nbsp;"Internet"</span>。<span>)&nbsp;<br> struct sockaddr_in {&nbsp;<br> short int sin_family; /*&nbsp;</span>通信类型<span>&nbsp;*/&nbsp;<br> unsigned short int sin_port; /*&nbsp;</span>端口<span>&nbsp;*/&nbsp;<br> struct in_addr sin_addr; /* Internet&nbsp;</span>地址<span>&nbsp;*/&nbsp;<br> unsigned char sin_zero[8]; /*&nbsp;</span>与<span>sockaddr</span>结构的长度相同<span>*/&nbsp;<br></span>　　<span>&nbsp;};&nbsp;<br></span>用这个数据结构可以轻松处理套接字地址的基本元素。注意<span>&nbsp;sin_zero (</span>它被加入到这个结构，并且长度和<span>&nbsp;struct sockaddr&nbsp;</span>一样<span>)&nbsp;</span>应该使用函数<span>&nbsp;bzero()&nbsp;</span>或<span>&nbsp;memset()&nbsp;</span>来全部置零。 同时，这一重要的字节，一个指向<span>sockaddr_in</span>结构体的指针也可以被指向结构体<span>sockaddr</span>并且代替它。这样的话即使<span>&nbsp;socket()&nbsp;</span>想要的是<span>&nbsp;struct sockaddr *</span>，你仍然可以使用<span>&nbsp;struct sockaddr_in</span>，并且在最后转换。同时，注意<span>&nbsp;sin_family&nbsp;</span>和<span>&nbsp;struct sockaddr&nbsp;</span>中的<span>&nbsp;sa_family&nbsp;</span>一致并能够设置为<span>&nbsp;"AF_INET"</span>。最后，<span>sin_port</span>和<span>&nbsp;sin_addr&nbsp;</span>必须是网络字节顺序<span>&nbsp;(Network Byte Order)</span>！你也许会反对道：<span>"</span>但是，怎么让整个数据结构<span>&nbsp;struct in_addr sin_addr&nbsp;</span>按照网络字节顺序呢<span>?"&nbsp;</span>要知道这个问题的答案，我们就要仔细的看一看这 个数据结构：<span>&nbsp;struct in_addr,&nbsp;</span>有这样一个联合<span>&nbsp;(unions)</span>：<span>&nbsp;<br> /* Internet&nbsp;</span>地址<span>&nbsp;(</span>一个与历史有关的结构<span>) */&nbsp;<br></span>　　<span>&nbsp;struct in_addr {&nbsp;<br></span>　　<span>&nbsp;unsigned long s_addr;&nbsp;<br></span>　　<span>&nbsp;};&nbsp;<br></span>它曾经是个最坏的联合，但是现在那些日子过去了。如果你声明<span>&nbsp;"ina"&nbsp;</span>是数据结构<span>&nbsp;struct sockaddr_in&nbsp;</span>的实例，那么<span>&nbsp;"ina.sin_addr.s_addr"&nbsp;</span>就储 存<span>4</span>字节的<span>&nbsp;IP&nbsp;</span>地址<span>(</span>使用网络字节顺序<span>)</span>。如果你不幸的系统使用的还是恐怖的联合<span>&nbsp;struct in_addr&nbsp;</span>，你还是可以放心<span>4</span>字节的<span>&nbsp;IP&nbsp;</span>地址并且和上面 我说的一样<span>(</span>这是因为使用了“<span>#define</span>”。<span>)</span></span></p> 
    <p><a name="_Toc151267856">本机转换</a><span>&nbsp;<br></span><span>　　我们现在到了新的章节。我们曾经讲了很多网络到本机字节顺序的转换，现在可以实践了！你能够转换两种类型：<span>&nbsp;short (</span>两个字节<span>)</span>和<span>&nbsp;long (</span>四个字节<span>)</span>。这个函数对于变量类型<span>&nbsp;unsigned&nbsp;</span>也适用。假设你想将<span>&nbsp;short&nbsp;</span>从本机字节顺序转 换为网络字节顺序。用<span>&nbsp;"h"&nbsp;</span>表示<span>&nbsp;"</span>本机<span>&nbsp;(host)"</span>，接着是<span>&nbsp;"to"</span>，然后用<span>&nbsp;"n"&nbsp;</span>表 示<span>&nbsp;"</span>网络<span>&nbsp;(network)"</span>，最后用<span>&nbsp;"s"&nbsp;</span>表示<span>&nbsp;"short"</span>：<span>&nbsp;h-to-n-s,&nbsp;</span>或者<span>&nbsp;htons() ("Host to Network Short")</span>。<span>&nbsp;<br></span>太简单了<span>...&nbsp;<br></span>如果不是太傻的话，你一定想到了由<span>"n"</span>，<span>"h"</span>，<span>"s"</span>，和<span>&nbsp;"l"</span>形成的正确 组合，例如这里肯定没有<span>stolh() ("Short to Long Host")&nbsp;</span>函数，不仅在这里 没有，所有场合都没有。但是这里有：<span>&nbsp;<br> htons()--"Host to Network Short"&nbsp;<br></span>　　<span>htonl()--"Host to Network Long"&nbsp;<br></span>　　<span>ntohs()--"Network to Host Short"&nbsp;<br></span>　　<span>ntohl()--"Network to Host Long"&nbsp;<br></span>现在，你可能想你已经知道它们了。你也可能想：“如果我想改变<span>&nbsp;char&nbsp;</span>的顺序要怎么办呢<span>?</span>” 但是你也许马上就想到，“用不着考虑的”。你也许会想到：我的<span>&nbsp;68000&nbsp;</span>机器已经使用了网络字节顺序，我没有必要去调用<span>&nbsp;htonl()</span>转换<span>&nbsp;IP&nbsp;</span>地址。你可能是对的，但是当你移植你的程序到别的机器上的时候，你的程序将失败。可移植性！这里是<span>&nbsp;Unix&nbsp;</span>世界！记住：在你将数据放到网络上的时候，确信它们是网络字节顺序的。<span>&nbsp;<br></span>最后一点：为什么在数据结构<span>&nbsp;struct sockaddr_in&nbsp;</span>中，<span>&nbsp;sin_addr&nbsp;</span>和<span>&nbsp;sin_port&nbsp;</span>需要转换为网络字节顺序，而<span>sin_family&nbsp;</span>需不需要呢<span>?&nbsp;</span>答案是：<span>&nbsp;sin_addr&nbsp;</span>和<span>&nbsp;sin_port&nbsp;</span>分别封装在包的<span>&nbsp;IP&nbsp;</span>和<span>&nbsp;UDP&nbsp;</span>层。因此，它们必须要 是网络字节顺序。但是<span>&nbsp;sin_family&nbsp;</span>域只是被内核<span>&nbsp;(kernel)&nbsp;</span>使用来决定在数 据结构中包含什么类型的地址，所以它必须是本机字节顺序。同时，<span>&nbsp;sin_family&nbsp;</span>没有发送到网络上，它们可以是本机字节顺序。</span></p> 
    <p><a name="_Toc151267857">IP&nbsp;</a><span>地址和如何处理它们</span><span>&nbsp;<br></span><span>现在我们很幸运，因为我们有很多的函数来方便地操作<span>&nbsp;IP&nbsp;</span>地址。没有必要用手工计算它们，也没有必要用<span>"&lt;&lt;"</span>操作来储存成长整字型。首先，假设你已经有了一个<span>sockaddr_in</span>结构体<span>ina</span>，你有一个<span>IP</span>地址<span>"132.241.5.10"</span>要储存在其中，你就要用到函数<span>inet_addr(),</span>将<span>IP</span>地址从 点数格式转换成无符号长整型。使用方法如下：<span>&nbsp;<br> ina.sin_addr.s_addr = inet_addr("132.241.5.10");&nbsp;<br></span>注意，<span>inet_addr()</span>返回的地址已经是网络字节格式，所以你无需再调用 函数<span>htonl()</span>。<span>&nbsp;<br></span>我们现在发现上面的代码片断不是十分完整的，因为它没有错误检查。 显而易见，当<span>inet_addr()</span>发生错误时返回<span>-1</span>。记住这些二进制数字？<span>(</span>无符号数<span>)-1</span>仅仅和<span>IP</span>地址<span>255.255.255.255</span>相符合！这可是广播地址！大错特 错！记住要先进行错误检查。<span>&nbsp;<br></span>好了，现在你可以将<span>IP</span>地址转换成长整型了。有没有其相反的方法呢？ 它可以将一个<span>in_addr</span>结构体输出成点数格式？这样的话，你就要用到函数<span>&nbsp;inet_ntoa()("ntoa"</span>的含义是<span>"network to ascii")</span>，就像这样：<span>&nbsp;<br> printf("%s",inet_ntoa(ina.sin_addr));&nbsp;<br></span>它将输出<span>IP</span>地址。需要注意的是<span>inet_ntoa()</span>将结构体<span>in-addr</span>作为一个参数，不是长整形。同样需要注意的是它返回的是一个指向一个字符的 指针。它是一个由<span>inet_ntoa()</span>控制的静态的固定的指针，所以每次调用<span>inet_ntoa()</span>，它就将覆盖上次调用时所得的<span>IP</span>地址。例如：<span>&nbsp;<br> char *a1, *a2;&nbsp;<br> .&nbsp;<br> .&nbsp;<br> a1 = inet_ntoa(ina1.sin_addr); /*&nbsp;</span>这是<span>198.92.129.1 */&nbsp;<br> a2 = inet_ntoa(ina2.sin_addr); /*&nbsp;</span>这是<span>132.241.5.10 */&nbsp;<br> printf("address 1: %sn",a1);&nbsp;<br> printf("address 2: %sn",a2);&nbsp;<br></span>输出如下：<span>&nbsp;<br> address 1: 132.241.5.10&nbsp;<br> address 2: 132.241.5.10&nbsp;<br></span>假如你需要保存这个<span>IP</span>地址，使用<span>strcopy()</span>函数来指向你自己的字符指针。<span>&nbsp;<br></span>上面就是关于这个主题的介绍。稍后，你将学习将一个类 似<span>"wintehouse.gov"</span>的字符串转换成它所对应的<span>IP</span>地址<span>(</span>查阅域名服务<span>,</span>稍后<span>)</span>。</span></p> 
    <p><a name="_Toc151267858">socket()</a><span>函数</span><span>&nbsp;<br></span><span>我想我不能再不提这个了－下面我将讨论一下<span>socket()</span>系统调用。<span>&nbsp;<br></span>下面是详细介绍：<span>&nbsp;<br> #include &lt;sys/types.h&gt;&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> int socket(int domain, int type, int protocol);&nbsp;<br></span>但是它们的参数是什么<span>?&nbsp;</span>首先，<span>domain&nbsp;</span>应该设置成<span>&nbsp;"AF_INET"</span>，就 象上面的数据结构<span>struct sockaddr_in&nbsp;</span>中一样。然后，参数<span>&nbsp;type&nbsp;</span>告诉内核 是<span>&nbsp;SOCK_STREAM&nbsp;</span>类型还是<span>&nbsp;SOCK_DGRAM&nbsp;</span>类型。最后，把<span>&nbsp;protocol</span>设置为<span>&nbsp;"0"</span>。<span>(</span>注意：有很多种<span>&nbsp;domain</span>、<span>type</span>，我不可能一一列出了，请看<span>&nbsp;socket()&nbsp;</span>的<span>&nbsp;man</span>帮助。当然，还有一个<span>"</span>更好<span>"</span>的方式去得到<span>&nbsp;protocol</span>。同 时请查阅<span>&nbsp;getprotobyname()&nbsp;</span>的<span>&nbsp;man&nbsp;</span>帮助。<span>)&nbsp;<br> socket()&nbsp;</span>只是返回你以后在系统调用种可能用到的<span>&nbsp;socket&nbsp;</span>描述符，或 者在错误的时候返回<span>-1</span>。全局变量<span>&nbsp;errno&nbsp;</span>中将储存返回的错误值。<span>(</span>请参考<span>&nbsp;perror()&nbsp;</span>的<span>&nbsp;man&nbsp;</span>帮助。<span>)</span></span></p> 
    <p><a name="_Toc151267859">bind()</a><span>函数</span><span>&nbsp;<br></span><span>　　一旦你有一个套接字，你可能要将套接字和机器上的一定的端口关联起来。<span>(</span>如果你想用<span>listen()</span>来侦听一定端口的数据，这是必要一步<span>--MUD&nbsp;</span>告 诉你说用命令<span>&nbsp;"telnet x.y.z 6969"</span>。<span>)</span>如果你只想用<span>&nbsp;connect()</span>，那么这个步 骤没有必要。但是无论如何，请继续读下去。<span>&nbsp;<br></span>这里是系统调用<span>&nbsp;bind()&nbsp;</span>的大概：<span>&nbsp;<br> #include &lt;sys/types.h&gt;&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> int bind(int sockfd, struct sockaddr *my_addr, int addrlen);&nbsp;<br> sockfd&nbsp;</span>是调用<span>&nbsp;socket&nbsp;</span>返回的文件描述符。<span>my_addr&nbsp;</span>是指向数据结构<span>&nbsp;struct sockaddr&nbsp;</span>的指针，它保存你的地址<span>(</span>即端口和<span>&nbsp;IP&nbsp;</span>地址<span>)&nbsp;</span>信息。<span>&nbsp;addrlen&nbsp;</span>设置为<span>&nbsp;sizeof(struct sockaddr)</span>。<span>&nbsp;<br></span>简单得很不是吗<span>?&nbsp;</span>再看看例子：<span>&nbsp;<br> #include &lt;string.h&gt;&nbsp;<br> #include &lt;sys/types.h&gt;&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> #define MYPORT 3490&nbsp;<br> main()&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>&nbsp;int sockfd;&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in my_addr;&nbsp;<br> sockfd = socket(AF_INET, SOCK_STREAM, 0); /*</span>需要错误检查<span>&nbsp;*/&nbsp;<br> my_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br></span>　　<span>&nbsp;my_addr.sin_port = htons(MYPORT); /* short, network byte order */&nbsp;<br></span>　　<span>&nbsp;my_addr.sin_addr.s_addr = inet_addr("132.241.5.10");&nbsp;<br></span>　　<span>&nbsp;bzero(&amp;(my_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br> /* don't forget your error checking for bind(): */&nbsp;<br></span>　　<span>&nbsp;bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr));&nbsp;<br></span>　　这里也有要注意的几件事情。<span>my_addr.sin_port&nbsp;</span>是网络字节顺序，<span>&nbsp;my_addr.sin_addr.s_addr&nbsp;</span>也是的。另外要注意到的事情是因系统的不同， 包含的头文件也不尽相同，请查阅本地的<span>&nbsp;man&nbsp;</span>帮助文件。<span>&nbsp;<br></span>在<span>&nbsp;bind()&nbsp;</span>主题中最后要说的话是，在处理自己的<span>&nbsp;IP&nbsp;</span>地址和<span>/</span>或端口的 时候，有些工作是可以自动处理的。<span>&nbsp;<br> my_addr.sin_port = 0; /*&nbsp;</span>随机选择一个没有使用的端口&nbsp;<span>*/&nbsp;<br></span>　　<span>my_addr.sin_addr.s_addr = INADDR_ANY; /*&nbsp;</span>使用自己的<span>IP</span>地址<span>&nbsp;*/&nbsp;<br></span>通过将<span>0</span>赋给<span>&nbsp;my_addr.sin_port</span>，你告诉<span>&nbsp;bind()&nbsp;</span>自己选择合适的端 口。同样，将<span>&nbsp;my_addr.sin_addr.s_addr&nbsp;</span>设置为<span>&nbsp;INADDR_ANY</span>，你告诉 它自动填上它所运行的机器的<span>&nbsp;IP&nbsp;</span>地址。如果你一向小心谨慎，那么你可能注意到我没有将<span>&nbsp;INADDR_ANY&nbsp;</span>转换为网络字节顺序！这是因为我知道内部的东西：<span>INADDR_ANY&nbsp;</span>实际上就 是<span>&nbsp;0</span>！即使你改变字节的顺序，<span>0</span>依然是<span>0</span>。但是完美主义者说应该处处一致，<span>INADDR_ANY</span>或许是<span>12</span>呢？你的代码就不能工作了，那么就看下面 的代码：<span>&nbsp;<br> my_addr.sin_port = htons(0); /*&nbsp;</span>随机选择一个没有使用的端口<span>&nbsp;*/&nbsp;<br> my_addr.sin_addr.s_addr = htonl(INADDR_ANY);/*&nbsp;</span>使用自己的<span>IP</span>地址<span>&nbsp;*/&nbsp;<br></span>你或许不相信，上面的代码将可以随便移植。我只是想指出，既然你 所遇到的程序不会都运行使用<span>htonl</span>的<span>INADDR_ANY</span>。<span>&nbsp;<br> bind()&nbsp;</span>在错误的时候依然是返回<span>-1</span>，并且设置全局错误变量<span>errno</span>。<span>&nbsp;<br></span>在你调用<span>&nbsp;bind()&nbsp;</span>的时候，你要小心的另一件事情是：不要采用小于<span>&nbsp;1024</span>的端口号。所有小于<span>1024</span>的端口号都被系统保留！你可以选择从<span>1024&nbsp;</span>到<span>65535</span>的端口<span>(</span>如果它们没有被别的程序使用的话<span>)</span>。 你要注意的另外一件小事是：有时候你根本不需要调用它。如果你使 用<span>&nbsp;connect()&nbsp;</span>来和远程机器进行通讯，你不需要关心你的本地端口号<span>(</span>就象你在使用<span>&nbsp;telnet&nbsp;</span>的时候<span>)</span>，你只要简单的调用<span>&nbsp;connect()&nbsp;</span>就可以了，它会检查套接字是否绑定端口，如果没有，它会自己绑定一个没有使用的本地端 口。</span></p> 
    <p><a name="_Toc151267860">connect()</a><span>程序</span><span>&nbsp;<br></span><span>　　现在我们假设你是个<span>&nbsp;telnet&nbsp;</span>程序。你的用户命令你得到套接字的文件 描述符。你听从命令调用了<span>socket()</span>。下一步，你的用户告诉你通过端口<span>&nbsp;23(</span>标准<span>&nbsp;telnet&nbsp;</span>端口<span>)</span>连接到<span>"132.241.5.10"</span>。你该怎么做呢<span>?&nbsp;</span>幸运的是，你正在阅读<span>&nbsp;connect()--</span>如何连接到远程主机这一章。你可不想让你的用户失望。<span>&nbsp;connect()&nbsp;</span>系统调用是这样的：<span>&nbsp;<br> #include &lt;sys/types.h&gt;&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);&nbsp;<br> sockfd&nbsp;</span>是系统调用<span>&nbsp;socket()&nbsp;</span>返回的套接字文件描述符。<span>serv_addr&nbsp;</span>是 保存着目的地端口和<span>&nbsp;IP&nbsp;</span>地址的数据结构<span>&nbsp;struct sockaddr</span>。<span>addrlen&nbsp;</span>设置 为<span>&nbsp;sizeof(struct sockaddr)</span>。<span>&nbsp;<br></span>想知道得更多吗？让我们来看个例子：<span>&nbsp;<br> #include &lt;string.h&gt;&nbsp;<br> #include &lt;sys/types.h&gt;&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> #define DEST_IP "132.241.5.10"&nbsp;<br></span>　　<span>#define DEST_PORT 23&nbsp;<br> main()&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br> int sockfd;&nbsp;<br> struct sockaddr_in dest_addr; /*&nbsp;</span>目的地址<span>*/&nbsp;<br> sockfd = socket(AF_INET, SOCK_STREAM, 0); /*&nbsp;</span>错误检查<span>&nbsp;*/&nbsp;<br> dest_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br> dest_addr.sin_port = htons(DEST_PORT); /* short, network byte order */&nbsp;<br> dest_addr.sin_addr.s_addr = inet_addr(DEST_IP);&nbsp;<br> bzero(&amp;(dest_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br> /* don't forget to error check the connect()! */&nbsp;<br> connect(sockfd, (struct sockaddr *)&amp;dest_addr, sizeof(struct sockaddr));&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　再一次，你应该检查<span>&nbsp;connect()&nbsp;</span>的返回值<span>--</span>它在错误的时候返回<span>-1</span>，并 设置全局错误变量<span>&nbsp;errno</span>。同时，你可能看到，我没有调用<span>&nbsp;bind()</span>。因为我不在乎本地的端口号。 我只关心我要去那。内核将为我选择一个合适的端口号，而我们所连接的 地方也自动地获得这些信息。一切都不用担心。</span></p> 
    <p><a name="_Toc151267861">listen()</a><span>函数</span><span>&nbsp;<br></span><span>　　是换换内容得时候了。假如你不希望与远程的一个地址相连，或者说，仅仅是将它踢开，那你就需要等待接入请求并且用各种方法处理它们。处 理过程分两步：首先，你听<span>--listen()</span>，然后，你接受<span>--accept() (</span>请看下面的 内容<span>)</span>。<span>&nbsp;<br></span>除了要一点解释外，系统调用<span>&nbsp;listen&nbsp;</span>也相当简单。<span>&nbsp;<br> int listen(int sockfd, int backlog);&nbsp;<br> sockfd&nbsp;</span>是调用<span>&nbsp;socket()&nbsp;</span>返回的套接字文件描述符。<span>backlog&nbsp;</span>是在进入 队列中允许的连接数目。什么意思呢<span>?&nbsp;</span>进入的连接是在队列中一直等待直到你接受<span>&nbsp;(accept()&nbsp;</span>请看下面的文章<span>)</span>连接。它们的数目限制于队列的允许。 大多数系统的允许数目是<span>20</span>，你也可以设置为<span>5</span>到<span>10</span>。和别的函数一样，在发生错误的时候返回<span>-1</span>，并设置全局错误变量<span>&nbsp;errno</span>。你可能想象到了，在你调用<span>&nbsp;listen()&nbsp;</span>前你或者要调用<span>&nbsp;bind()&nbsp;</span>或者让内核随便选择一个端口。如果你想侦听进入的连接，那么系统调用的顺序可 能是这样的：<span>&nbsp;<br> socket();&nbsp;<br></span>　　<span>bind();&nbsp;<br> listen();&nbsp;<br></span>　　<span>/* accept()&nbsp;</span>应该在这<span>&nbsp;*/&nbsp;<br></span>因为它相当的明了，我将在这里不给出例子了。<span>(</span>在<span>&nbsp;accept()&nbsp;</span>那一章的 代码将更加完全。<span>)</span>真正麻烦的部分在<span>&nbsp;accept()</span>。</span></p> 
    <p><a name="_Toc151267862">accept()</a><span>函数</span><span>&nbsp;<br></span><span>　　准备好了，系统调用<span>&nbsp;accept()&nbsp;</span>会有点古怪的地方的！你可以想象发生 这样的事情：有人从很远的地方通过一个你在侦听<span>&nbsp;(listen())&nbsp;</span>的端口连接<span>&nbsp;(connect())&nbsp;</span>到你的机器。它的连接将加入到等待接受<span>&nbsp;(accept())&nbsp;</span>的队列 中。你调用<span>&nbsp;accept()&nbsp;</span>告诉它你有空闲的连接。它将返回一个新的套接字文件描述符！这样你就有两个套接字了，原来的一个还在侦听你的那个端口， 新的在准备发送<span>&nbsp;(send())&nbsp;</span>和接收<span>&nbsp;( recv())&nbsp;</span>数据。这就是这个过程！函数是这样定义的：<span>&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> int accept(int sockfd, void *addr, int *addrlen);&nbsp;<br> sockfd&nbsp;</span>相当简单，是和<span>&nbsp;listen()&nbsp;</span>中一样的套接字描述符。<span>addr&nbsp;</span>是个指 向局部的数据结构<span>&nbsp;sockaddr_in&nbsp;</span>的指针。这是要求接入的信息所要去的地方（你可以测定那个地址在那个端口呼叫你）。在它的地址传递给<span>&nbsp;accept&nbsp;</span>之 前，<span>addrlen&nbsp;</span>是个局部的整形变量，设置为<span>&nbsp;sizeof(struct sockaddr_in)</span>。<span>&nbsp;accept&nbsp;</span>将不会将多余的字节给<span>&nbsp;addr</span>。如果你放入的少些，那么它会通过改<span>&nbsp;<br></span>变<span>&nbsp;addrlen&nbsp;</span>的值反映出来。<span>&nbsp;<br></span>同样，在错误时返回<span>-1</span>，并设置全局错误变量<span>&nbsp;errno</span>。<span>&nbsp;<br></span>现在是你应该熟悉的代码片段。<span>&nbsp;<br> #include &lt;string.h&gt;&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> #include &lt;sys/types.h&gt;&nbsp;<br> #define MYPORT 3490 /*</span>用户接入端口<span>*/&nbsp;<br> #define BACKLOG 10 /*&nbsp;</span>多少等待连接控制<span>*/&nbsp;<br> main()&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>int sockfd, new_fd; /* listen on sock_fd, new connection on new_fd */&nbsp;<br></span>　　<span>struct sockaddr_in my_addr; /*&nbsp;</span>地址信息<span>&nbsp;*/&nbsp;<br></span>　　<span>struct sockaddr_in their_addr; /* connector's address information */&nbsp;<br></span>　　<span>int sin_size;&nbsp;<br> sockfd = socket(AF_INET, SOCK_STREAM, 0); /*&nbsp;</span>错误检查<span>*/&nbsp;<br> my_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br></span>　　<span>my_addr.sin_port = htons(MYPORT); /* short, network byte order */&nbsp;<br></span>　　<span>my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */&nbsp;<br></span>　　<span>bzero(&amp;(my_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br> /* don't forget your error checking for these calls: */&nbsp;<br></span>　　<span>bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr));&nbsp;<br> listen(sockfd, BACKLOG);&nbsp;<br> sin_size = sizeof(struct sockaddr_in);&nbsp;<br></span>　　<span>new_fd = accept(sockfd, &amp;their_addr, &amp;sin_size);&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>注意，在系统调用<span>&nbsp;send()&nbsp;</span>和<span>&nbsp;recv()&nbsp;</span>中你应该使用新的套接字描述符<span>&nbsp;new_fd</span>。如果你只想让一个连接进来，那么你可以使用<span>&nbsp;close()&nbsp;</span>去关闭原来的文件描述符<span>&nbsp;sockfd&nbsp;</span>来避免同一个端口更多的连接。</span></p> 
    <p><a name="_Toc151267863">send() and recv()</a><span>函数<span>&nbsp;<br></span>　　这两个函数用于流式套接字或者数据报套接字的通讯。如果你喜欢使 用无连接的数据报套接字，你应该看一看下面关于<span>sendto()&nbsp;</span>和<span>&nbsp;recvfrom()&nbsp;</span>的章节。<span>&nbsp;<br> send()&nbsp;</span>是这样的：<span>&nbsp;<br> int send(int sockfd, const void *msg, int len, int flags);&nbsp;<br> sockfd&nbsp;</span>是你想发送数据的套接字描述符<span>(</span>或者是调用<span>&nbsp;socket()&nbsp;</span>或者是<span>&nbsp;accept()&nbsp;</span>返回的。<span>)msg&nbsp;</span>是指向你想发送的数据的指针。<span>len&nbsp;</span>是数据的长度。 把<span>&nbsp;flags&nbsp;</span>设置为<span>&nbsp;0&nbsp;</span>就可以了。<span>(</span>详细的资料请看<span>&nbsp;send()&nbsp;</span>的<span>&nbsp;man page)</span>。<span>&nbsp;<br></span>这里是一些可能的例子：<span>&nbsp;<br> char *msg = "Beej was here!";&nbsp;<br></span>　　<span>int len, bytes_sent;&nbsp;<br></span>　　<span>.&nbsp;<br></span>　　<span>.&nbsp;<br></span>　　<span>len = strlen(msg);&nbsp;<br></span>　　<span>bytes_sent = send(sockfd, msg, len, 0);&nbsp;<br></span>　　<span>.&nbsp;<br></span>　　<span>.&nbsp;<br></span>　　<span>.&nbsp;<br> send()&nbsp;</span>返回实际发送的数据的字节数<span>--</span>它可能小于你要求发送的数 目！ 注意，有时候你告诉它要发送一堆数据可是它不能处理成功。它只是发送它可能发送的数据，然后希望你能够发送其它的数据。记住，如果<span>&nbsp;send()&nbsp;</span>返回的数据和<span>&nbsp;len&nbsp;</span>不匹配，你就应该发送其它的数据。但是这里也有个好消息：如果你要发送的包很小<span>(</span>小于大约<span>&nbsp;1K)</span>，它可能处理让数据一 次发送完。最后要说得就是，它在错误的时候返回<span>-1</span>，并设置<span>&nbsp;errno</span>。<span>&nbsp;<br> recv()&nbsp;</span>函数很相似：<span>&nbsp;<br> int recv(int sockfd, void *buf, int len, unsigned int flags);&nbsp;<br> sockfd&nbsp;</span>是要读的套接字描述符。<span>buf&nbsp;</span>是要读的信息的缓冲。<span>len&nbsp;</span>是缓 冲的最大长度。<span>flags&nbsp;</span>可以设置为<span>0</span>。<span>(</span>请参考<span>recv()&nbsp;</span>的<span>&nbsp;man page</span>。<span>) recv()&nbsp;</span>返回实际读入缓冲的数据的字节数。或者在错误的时候返回<span>-1</span>， 同时设置<span>errno</span>。<span>&nbsp;<br></span>很简单，不是吗<span>?&nbsp;</span>你现在可以在流式套接字上发送数据和接收数据了。 你现在是<span>&nbsp;Unix&nbsp;</span>网络程序员了！</span></p> 
    <p><a name="_Toc151267864">sendto()&nbsp;</a><span>和<span>&nbsp;recvfrom()</span>函数</span><span>&nbsp;<br></span><span>　　“这很不错啊”，你说，“但是你还没有讲无连接数据报套接字呢？” 没问题，现在我们开始这个内容。<span>&nbsp;<br></span>既然数据报套接字不是连接到远程主机的，那么在我们发送一个包之 前需要什么信息呢<span>?&nbsp;</span>不错，是目标地址！看看下面的：<span>&nbsp;<br> int sendto(int sockfd, const void *msg, int len, unsigned int flags,&nbsp;<br></span>　　<span>const struct sockaddr *to, int tolen);&nbsp;<br></span>你已经看到了，除了另外的两个信息外，其余的和函数<span>&nbsp;send()&nbsp;</span>是一样 的。<span>&nbsp;to&nbsp;</span>是个指向数据结构<span>&nbsp;struct sockaddr&nbsp;</span>的指针，它包含了目的地的<span>&nbsp;IP&nbsp;</span>地址和端口信息。<span>tolen&nbsp;</span>可以简单地设置为<span>&nbsp;sizeof(struct sockaddr)</span>。 和函数<span>&nbsp;send()&nbsp;</span>类似，<span>sendto()&nbsp;</span>返回实际发送的字节数<span>(</span>它也可能小于 你想要发送的字节数！<span>)</span>，或者在错误的时候返回<span>&nbsp;-1</span>。<span>&nbsp;<br></span>相似的还有函数<span>&nbsp;recv()&nbsp;</span>和<span>&nbsp;recvfrom()</span>。<span>recvfrom()&nbsp;</span>的定义是这样的：<span>&nbsp;<br> int recvfrom(int sockfd, void *buf, int len, unsigned int flags,&nbsp;</span>　<span>struct sockaddr *from, int *fromlen);&nbsp;<br></span>又一次，除了两个增加的参数外，这个函数和<span>&nbsp;recv()&nbsp;</span>也是一样的。<span>from&nbsp;</span>是一个指向局部数据结构<span>&nbsp;struct sockaddr&nbsp;</span>的指针，它的内容是源机器的<span>&nbsp;IP&nbsp;</span>地址和端口信息。<span>fromlen&nbsp;</span>是个<span>&nbsp;int&nbsp;</span>型的局部指针，它的初始值为<span>sizeof(struct sockaddr)</span>。函数调用返回后，<span>fromlen&nbsp;</span>保存着实际储存在<span>&nbsp;from&nbsp;</span>中的地址的长度。<span>&nbsp;<br> recvfrom()&nbsp;</span>返回收到的字节长度，或者在发生错误后返回<span>&nbsp;-1</span>。<span>&nbsp;<br></span>记住，如果你用<span>&nbsp;connect()&nbsp;</span>连接一个数据报套接字，你可以简单的调 用<span>&nbsp;send()&nbsp;</span>和<span>&nbsp;recv()&nbsp;</span>来满足你的要求。这个时候依然是数据报套接字，依然使用<span>&nbsp;UDP</span>，系统套接字接口会为你自动加上了目标和源的信息。</span></p> 
    <p><a name="_Toc151267865">close()</a><span>和<span>shutdown()</span>函数</span><span>&nbsp;<br></span><span>　　你已经整天都在发送<span>&nbsp;(send())&nbsp;</span>和接收<span>&nbsp;(recv())&nbsp;</span>数据了，现在你准备关 闭你的套接字描述符了。这很简单，你可以使用一般的<span>&nbsp;Unix&nbsp;</span>文件描述符 的<span>&nbsp;close()&nbsp;</span>函数：<span>&nbsp;<br></span>　　<span>close(sockfd);&nbsp;<br></span>它将防止套接字上更多的数据的读写。任何在另一端读写套接字的企 图都将返回错误信息。<span>&nbsp;<br></span>如果你想在如何关闭套接字上有多一点的控制，你可以使用函数<span>&nbsp;shutdown()</span>。它允许你将一定方向上的通讯或者双向的通讯<span>(</span>就象<span>close()</span>一 样<span>)</span>关闭，你可以使用：<span>&nbsp;<br> int shutdown(int sockfd, int how);&nbsp;<br> sockfd&nbsp;</span>是你想要关闭的套接字文件描述复。<span>how&nbsp;</span>的值是下面的其中之 一：<span>&nbsp;<br></span>　　<span>0&nbsp;</span>– 不允许接受<span>&nbsp;<br></span>　　<span>1&nbsp;</span>– 不允许发送<span>&nbsp;<br></span>　　<span>2&nbsp;</span>– 不允许发送和接受<span>(</span>和<span>&nbsp;close()&nbsp;</span>一样<span>)&nbsp;<br> shutdown()&nbsp;</span>成功时返回<span>&nbsp;0</span>，失败时返回<span>&nbsp;-1(</span>同时设置<span>&nbsp;errno</span>。<span>)&nbsp;</span>如果在无连接的数据报套接字中使用<span>shutdown()</span>，那么只不过是让<span>&nbsp;send()&nbsp;</span>和<span>&nbsp;recv()&nbsp;</span>不能使用<span>(</span>记住你在数据报套接字中使用了<span>&nbsp;connect&nbsp;</span>后 是可以使用它们的<span>)</span>。</span></p> 
    <p><a name="_Toc151267866">getpeername()</a><span>函数</span><span>&nbsp;<br></span><span>　　这个函数太简单了。<span>&nbsp;<br></span>它太简单了，以至我都不想单列一章。但是我还是这样做了。 函数<span>&nbsp;getpeername()&nbsp;</span>告诉你在连接的流式套接字上谁在另外一边。函数是这样的：<span>&nbsp;<br> #include &lt;sys/socket.h&gt;&nbsp;<br> int getpeername(int sockfd, struct sockaddr *addr, int *addrlen);&nbsp;<br> sockfd&nbsp;</span>是连接的流式套接字的描述符。<span>addr&nbsp;</span>是一个指向结构<span>&nbsp;struct sockaddr (</span>或者是<span>&nbsp;struct sockaddr_in)&nbsp;</span>的指针，它保存着连接的另一边的信息。<span>addrlen&nbsp;</span>是一个<span>&nbsp;int&nbsp;</span>型的指针，它初始化为<span>&nbsp;sizeof(struct sockaddr)</span>。函数在错误的时候返回<span>&nbsp;-1</span>，设置相应的<span>&nbsp;errno</span>。 一旦你获得它们的地址，你可以使用<span>&nbsp;inet_ntoa()&nbsp;</span>或者<span>&nbsp;gethostbyaddr()&nbsp;</span>来打印或者获得更多的信息。但是你不能得到它的帐号。<span>(</span>如果它运行着愚蠢的守护进程，这是可能的，但是它的讨论已经超出了本文的范围，请参考<span>&nbsp;RFC-1413&nbsp;</span>以获得更多的信息。<span>)</span></span></p> 
    <p><a name="_Toc151267867">gethostname()</a><span>函数</span><span>&nbsp;</span><span><br></span><span>　　甚至比<span>&nbsp;getpeername()&nbsp;</span>还简单的函数是<span>&nbsp;gethostname()</span>。它返回你程 序所运行的机器的主机名字。然后你可以使用<span>&nbsp;gethostbyname()&nbsp;</span>以获得你 的机器的<span>&nbsp;IP&nbsp;</span>地址。<span>&nbsp;<br></span>　　下面是定义：<span>&nbsp;<br></span>　　<span>#include &lt;unistd.h&gt;&nbsp;<br> int gethostname(char *hostname, size_t size);&nbsp;<br></span>参数很简单：<span>hostname&nbsp;</span>是一个字符数组指针，它将在函数返回时保存<span>&nbsp;<br></span>主机名。<span>size</span>是<span>hostname&nbsp;</span>数组的字节长度。<span>&nbsp;<br></span>函数调用成功时返回<span>&nbsp;0</span>，失败时返回<span>&nbsp;-1</span>，并设置<span>&nbsp;errno</span>。</span></p> 
    <p><a name="_Toc151267868">域名服务（<span>DNS</span>）</a><span>&nbsp;<br></span><span>　　如果你不知道<span>&nbsp;DNS&nbsp;</span>的意思，那么我告诉你，它代表域名服务<span>(Domain Name Service)</span>。它主要的功能是：你给它一个容易记忆的某站点的地址，它给你<span>&nbsp;IP&nbsp;</span>地址<span>(</span>然后你就可以使用<span>&nbsp;bind(), connect(), sendto()&nbsp;</span>或者其它 函数<span>)&nbsp;</span>。当一个人输入：<span>&nbsp;<br></span>　　<span>&nbsp;$ telnet whitehouse.gov&nbsp;<br> telnet&nbsp;</span>能知道它将连接<span>&nbsp;(connect())&nbsp;</span>到<span>&nbsp;"198.137.240.100"</span>。<span>&nbsp;<br></span>但是这是如何工作的呢<span>?&nbsp;</span>你可以调用函数<span>&nbsp;gethostbyname()</span>：<span>&nbsp;<br> #include &lt;netdb.h&gt;&nbsp;<br></span>　　<span>struct hostent *gethostbyname(const char *name);&nbsp;<br></span>很明白的是，它返回一个指向<span>&nbsp;struct hostent&nbsp;</span>的指针。这个数据结构 是这样的：<span>&nbsp;<br></span>　　<span>&nbsp;struct hostent {&nbsp;<br></span>　　<span>&nbsp;char *h_name;&nbsp;<br></span>　　<span>&nbsp;char **h_aliases;&nbsp;<br></span>　　<span>&nbsp;int h_addrtype;&nbsp;<br></span>　　<span>&nbsp;int h_length;&nbsp;<br></span>　　<span>&nbsp;char **h_addr_list;&nbsp;<br></span>　　<span>&nbsp;};&nbsp;<br></span>　　<span>&nbsp;#define h_addr h_addr_list[0]&nbsp;<br></span>这里是这个数据结构的详细资料：<span>&nbsp;<br> struct hostent:&nbsp;<br></span>　　<span>h_name&nbsp;</span>– 地址的正式名称。<span>&nbsp;<br></span>　　<span>h_aliases&nbsp;</span>– 空字节<span>-</span>地址的预备名称的指针。<span>&nbsp;<br></span>　　<span>h_addrtype&nbsp;</span>–地址类型<span>;&nbsp;</span>通常是<span>AF_INET</span>。<span>&nbsp;<br></span>　　<span>h_length&nbsp;</span>– 地址的比特长度。<span>&nbsp;<br></span>　　<span>h_addr_list&nbsp;</span>– 零字节<span>-</span>主机网络地址指针。网络字节顺序。<span>&nbsp;<br></span>　　<span>h_addr - h_addr_list</span>中的第一地址。<span>&nbsp;<br> gethostbyname()&nbsp;</span>成功时返回一个指向结构体<span>&nbsp;hostent&nbsp;</span>的指针，或者 是个空<span>&nbsp;(NULL)&nbsp;</span>指针。<span>(</span>但是和以前不同，不设置<span>errno</span>，<span>h_errno&nbsp;</span>设置错 误信息。请看下面的<span>&nbsp;herror()</span>。<span>)&nbsp;<br></span>但是如何使用呢<span>?&nbsp;</span>有时候（我们可以从电脑手册中发现），向读者灌输 信息是不够的。这个函数可不象它看上去那么难用。<span>&nbsp;<br></span>这里是个例子：<span>&nbsp;<br> #include &lt;stdio.h&gt;&nbsp;<br></span>　　<span>#include &lt;stdlib.h&gt;&nbsp;<br></span>　　<span>#include &lt;errno.h&gt;&nbsp;<br></span>　　<span>#include &lt;netdb.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;netinet/in.h&gt;&nbsp;<br> int main(int argc, char *argv[])&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>&nbsp;struct hostent *h;&nbsp;<br> if (argc != 2) { /*&nbsp;</span>检查命令行<span>&nbsp;*/&nbsp;<br></span>　　<span>&nbsp;fprintf(stderr,"usage: getip addressn");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> if ((h=gethostbyname(argv[1])) == NULL) { /*&nbsp;</span>取得地址信息<span>&nbsp;*/&nbsp;<br></span>　　<span>&nbsp;herror("gethostbyname");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> printf("Host name : %sn", h-&gt;h_name);&nbsp;<br></span>　　<span>printf("IP Address : %sn",inet_ntoa(*((struct in_addr *)h-&gt;h_addr)));&nbsp;<br> return 0;&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>在使用<span>&nbsp;gethostbyname()&nbsp;</span>的时候，你不能用<span>&nbsp;perror()&nbsp;</span>打印错误信息<span>&nbsp;(</span>因为<span>&nbsp;errno&nbsp;</span>没有使用<span>)</span>，你应该调用<span>&nbsp;herror()</span>。<span>&nbsp;<br></span>相当简单，你只是传递一个保存机器名的字符串<span>(</span>例如<span>&nbsp;"whitehouse.gov")&nbsp;</span>给<span>&nbsp;gethostbyname()</span>，然后从返回的数据结构<span>&nbsp;struct hostent&nbsp;</span>中获取信息。<span>&nbsp;<br></span>唯一也许让人不解的是输出<span>&nbsp;IP&nbsp;</span>地址信息。<span>h-&gt;h_addr&nbsp;</span>是一个<span>&nbsp;char *</span>， 但是<span>&nbsp;inet_ntoa()&nbsp;</span>需要的是<span>&nbsp;struct in_addr</span>。因此，我转换<span>&nbsp;h-&gt;h_addr&nbsp;</span>成<span>&nbsp;struct in_addr *</span>，然后得到数据。</span></p> 
    <p><a name="_Toc151267869">客户<span>-</span>服务器背景知识</a><span>&nbsp;<br></span><span>　　这里是个客户<span>--</span>服务器的世界。在网络上的所有东西都是在处理客户进程和服务器进程的交谈。举个<span>telnet&nbsp;</span>的例子。当你用<span>&nbsp;telnet (</span>客户<span>)</span>通过<span>23&nbsp;</span>号端口登陆到主机，主机上运行的一个程序<span>(</span>一般叫<span>&nbsp;telnetd</span>，服务器<span>)</span>激活。它处理这个连接，显示登陆界面，等等。</span></p> 
    <p><span>图<span>2</span>：客户机和服务器的关系<span>&nbsp;<br></span>图<span>&nbsp;2&nbsp;</span>说明了客户和服务器之间的信息交换。<span>&nbsp;<br></span>注意，客户<span>--</span>服务器之间可以使用<span>SOCK_STREAM</span>、<span>SOCK_DGRAM&nbsp;</span>或者其它<span>(</span>只要它们采用相同的<span>)</span>。一些很好的客户<span>--</span>服务器的例子有<span>&nbsp;telnet/telnetd</span>、<span>&nbsp;ftp/ftpd&nbsp;</span>和<span>&nbsp;bootp/bootpd</span>。每次你使用<span>&nbsp;ftp&nbsp;</span>的时候，在远 端都有一个<span>&nbsp;ftpd&nbsp;</span>为你服务。<span>&nbsp;<br></span>一般，在服务端只有一个服务器，它采用<span>&nbsp;fork()&nbsp;</span>来处理多个客户的连 接。基本的程序是：服务器等待一个连接，接受<span>&nbsp;(accept())&nbsp;</span>连接，然后<span>&nbsp;fork()&nbsp;</span>一个子进程处理它。这是下一章我们的例子中会讲到的。</span></p> 
    <p><a name="_Toc151267870">简单的服务器</a><span>&nbsp;<br></span><span>　　这个服务器所做的全部工作是在流式连接上发送字符串<span>&nbsp;"Hello, World!n"</span>。你要测试这个程序的话，可以在一台机器上运行该程序，然后 在另外一机器上登陆：<span>&nbsp;<br></span>　　<span>&nbsp;$ telnet remotehostname 3490&nbsp;<br> remotehostname&nbsp;</span>是该程序运行的机器的名字。<span>&nbsp;<br></span>服务器代码：<span>&nbsp;<br> #include &lt;stdio.h&gt;&nbsp;<br></span>　　<span>#include &lt;stdlib.h&gt;&nbsp;<br></span>　　<span>#include &lt;errno.h&gt;&nbsp;<br></span>　　<span>#include &lt;string.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;netinet/in.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/socket.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/wait.h&gt;&nbsp;<br> #define MYPORT 3490 /*</span>定义用户连接端口<span>*/&nbsp;<br> #define BACKLOG 10 /*</span>多少等待连接控制<span>*/&nbsp;<br> main()&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>&nbsp;int sockfd, new_fd; /* listen on sock_fd, new connection on new_fd&nbsp;<br> */&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in my_addr; /* my address information */&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in their_addr; /* connector's address information */&nbsp;<br></span>　　<span>&nbsp;int sin_size;&nbsp;<br> if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("socket");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> my_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br></span>　　<span>&nbsp;my_addr.sin_port = htons(MYPORT); /* short, network byte order */&nbsp;<br></span>　　<span>&nbsp;my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */&nbsp;<br></span>　　<span>&nbsp;bzero(&amp;(my_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br><br> if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct&nbsp;<br> sockaddr))== -1) {&nbsp;<br></span>　　<span>&nbsp;perror("bind");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> if (listen(sockfd, BACKLOG) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("listen");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> while(1) { /* main accept() loop */&nbsp;<br></span>　　<span>&nbsp;sin_size = sizeof(struct sockaddr_in);&nbsp;<br></span>　　<span>&nbsp;if ((new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr,&nbsp;<br></span>　　<span>&nbsp;&amp;sin_size)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("accept");&nbsp;<br></span>　　<span>&nbsp;continue;&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>　　<span>&nbsp;printf("server: got connection from %sn",&nbsp;<br></span>　　<span>&nbsp;inet_ntoa(their_addr.sin_addr));&nbsp;<br></span>　　<span>&nbsp;if (!fork()) { /* this is the child process */&nbsp;<br></span>　　<span>&nbsp;if (send(new_fd, "Hello, world!n", 14, 0) == -1)&nbsp;<br></span>　　<span>&nbsp;perror("send");&nbsp;<br></span>　　<span>&nbsp;close(new_fd);&nbsp;<br></span>　　<span>&nbsp;exit(0);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>　　<span>&nbsp;close(new_fd); /* parent doesn't need this */&nbsp;<br> while(waitpid(-1,NULL,WNOHANG) &gt; 0); /* clean up child processes */&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>如果你很挑剔的话，一定不满意我所有的代码都在一个很大的<span>main()&nbsp;</span>函数中。如果你不喜欢，可以划分得更细点。<span>&nbsp;<br></span>你也可以用我们下一章中的程序得到服务器端发送的字符串。</span></p> 
    <p><a name="_Toc151267871">简单的客户程序</a><span>&nbsp;</span><span><br></span><span>　　这个程序比服务器还简单。这个程序的所有工作是通过<span>&nbsp;3490&nbsp;</span>端口连接到命令行中指定的主机，然后得到服务器发送的字符串。<span>&nbsp;<br></span>客户代码<span>:&nbsp;<br> #include &lt;stdio.h&gt;&nbsp;<br></span>　　<span>#include &lt;stdlib.h&gt;&nbsp;<br></span>　　<span>#include &lt;errno.h&gt;&nbsp;<br></span>　　<span>#include &lt;string.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;netinet/in.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/socket.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/wait.h&gt;&nbsp;<br> #define PORT 3490 /*&nbsp;</span>客户机连接远程主机的端口<span>&nbsp;*/&nbsp;<br> #define MAXDATASIZE 100 /*&nbsp;</span>每次可以接收的最大字节<span>&nbsp;*/&nbsp;<br> int main(int argc, char *argv[])&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>&nbsp;int sockfd, numbytes;&nbsp;<br></span>　　<span>&nbsp;char buf[MAXDATASIZE];&nbsp;<br></span>　　<span>&nbsp;struct hostent *he;&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in their_addr; /* connector's address information */&nbsp;<br> if (argc != 2) {&nbsp;<br></span>　　<span>&nbsp;fprintf(stderr,"usage: client hostnamen");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> if ((he=gethostbyname(argv[1])) == NULL) { /* get the host info */&nbsp;<br></span>　　<span>&nbsp;herror("gethostbyname");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("socket");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> their_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br></span>　　<span>their_addr.sin_port = htons(PORT); /* short, network byte order */&nbsp;<br></span>　　<span>their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);&nbsp;<br></span>　　<span>bzero(&amp;(their_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br> if (connect(sockfd, (struct sockaddr *)&amp;their_addr,sizeof(struct&nbsp;<br> sockaddr)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("connect");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> if ((numbytes=recv(sockfd, buf, MAXDATASIZE, 0)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("recv");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> buf[numbytes] = '';&nbsp;<br> printf("Received: %s",buf);&nbsp;<br> close(sockfd);&nbsp;<br> return 0;&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>注意，如果你在运行服务器之前运行客户程序，<span>connect()&nbsp;</span>将返回<span>&nbsp;"Connection refused"&nbsp;</span>信息，这非常有用。</span></p> 
    <p><a name="_Toc151267872"><span><span>数据包<span>&nbsp;Sockets</span></span></span></a><span>&nbsp;</span><span><br></span><span>　　我不想讲更多了，所以我给出代码<span>&nbsp;talker.c&nbsp;</span>和<span>&nbsp;listener.c</span>。<span>&nbsp;<br> listener&nbsp;</span>在机器上等待在端口<span>&nbsp;4590&nbsp;</span>来的数据包。<span>talker&nbsp;</span>发送数据包到 一定的机器，它包含用户在命令行输入的内容。<span>&nbsp;<br></span>这里就是<span>&nbsp;listener.c</span>：<span>&nbsp;<br> #include &lt;stdio.h&gt;&nbsp;<br></span>　　<span>#include &lt;stdlib.h&gt;&nbsp;<br></span>　　<span>#include &lt;errno.h&gt;&nbsp;<br></span>　　<span>#include &lt;string.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;netinet/in.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/socket.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/wait.h&gt;&nbsp;<br> #define MYPORT 4950 /* the port users will be sending to */&nbsp;<br> #define MAXBUFLEN 100&nbsp;<br> main()&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>&nbsp;int sockfd;&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in my_addr; /* my address information */&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in their_addr; /* connector's address information */&nbsp;<br></span>　　<span>&nbsp;int addr_len, numbytes;&nbsp;<br></span>　　<span>&nbsp;char buf[MAXBUFLEN];&nbsp;<br> if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("socket");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> my_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br></span>　　<span>&nbsp;my_addr.sin_port = htons(MYPORT); /* short, network byte order */&nbsp;<br></span>　　<span>&nbsp;my_addr.sin_addr.s_addr = INADDR_ANY; /* auto-fill with my IP */&nbsp;<br></span>　　<span>&nbsp;bzero(&amp;(my_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br> if (bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr))&nbsp;<br><br></span>　　<span>&nbsp;== -1) {&nbsp;<br></span>　　<span>&nbsp;perror("bind");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> addr_len = sizeof(struct sockaddr);&nbsp;<br></span>　　<span>&nbsp;if ((numbytes=recvfrom(sockfd, buf, MAXBUFLEN, 0,&nbsp;<br></span>　　<span>&nbsp;(struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("recvfrom");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> printf("got packet from %sn",inet_ntoa(their_addr.sin_addr));&nbsp;<br></span>　　<span>&nbsp;printf("packet is %d bytes longn",numbytes);&nbsp;<br></span>　　<span>&nbsp;buf[numbytes] = '';&nbsp;<br></span>　　<span>&nbsp;printf("packet contains "%s"n",buf);&nbsp;<br> close(sockfd);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>注意在我们的调用<span>&nbsp;socket()</span>，我们最后使用了<span>&nbsp;SOCK_DGRAM</span>。同时， 没有必要去使用<span>&nbsp;listen()&nbsp;</span>或者<span>&nbsp;accept()</span>。我们在使用无连接的数据报套接 字！<span>&nbsp;<br></span>下面是<span>&nbsp;talker.c</span>：<span>&nbsp;<br> #include &lt;stdio.h&gt;&nbsp;<br></span>　　<span>#include &lt;stdlib.h&gt;&nbsp;<br></span>　　<span>#include &lt;errno.h&gt;&nbsp;<br></span>　　<span>#include &lt;string.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;netinet/in.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/socket.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/wait.h&gt;&nbsp;<br> #define MYPORT 4950 /* the port users will be sending to */&nbsp;<br> int main(int argc, char *argv[])&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>&nbsp;int sockfd;&nbsp;<br></span>　　<span>&nbsp;struct sockaddr_in their_addr; /* connector's address information */&nbsp;<br></span>　　<span>&nbsp;struct hostent *he;&nbsp;<br></span>　　<span>&nbsp;int numbytes;&nbsp;<br><br> if (argc != 3) {&nbsp;<br></span>　　<span>&nbsp;fprintf(stderr,"usage: talker hostname messagen");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> if ((he=gethostbyname(argv[1])) == NULL) { /* get the host info */&nbsp;<br></span>　　<span>&nbsp;herror("gethostbyname");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("socket");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br><br> their_addr.sin_family = AF_INET; /* host byte order */&nbsp;<br></span>　　<span>&nbsp;their_addr.sin_port = htons(MYPORT); /* short, network byte order&nbsp;<br> */&nbsp;<br></span>　　&nbsp;<span>their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);&nbsp;<br></span>　　<span>&nbsp;bzero(&amp;(their_addr.sin_zero),; /* zero the rest of the struct */&nbsp;<br> if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,&nbsp;<br></span>　　<span>&nbsp;(struct sockaddr *)&amp;their_addr, sizeof(struct sockaddr))) == -1) {&nbsp;<br></span>　　<span>&nbsp;perror("sendto");&nbsp;<br></span>　　<span>&nbsp;exit(1);&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br> printf("sent %d bytes to&nbsp;<br> %sn",numbytes,inet_ntoa(their_addr.sin_addr));&nbsp;<br> close(sockfd);&nbsp;<br> return 0;&nbsp;<br></span>　　<span>&nbsp;}&nbsp;<br></span>这就是所有的了。在一台机器上运行<span>&nbsp;listener</span>，然后在另外一台机器上 运行<span>&nbsp;talker</span>。观察它们的通讯！<span>&nbsp;<br></span>除了一些我在上面提到的数据套接字连接的小细节外，对于数据套接 字，我还得说一些，当一个讲话者呼叫<span>connect()</span>函数时并指定接受者的地址时，从这点可以看出，讲话者只能向<span>connect()</span>函数指定的地址发送和接受信息。因此，你不需要使用<span>sendto()</span>和<span>recvfrom()</span>，你完全可以用<span>send()&nbsp;</span>和<span>recv()</span>代替。</span></p> 
    <p><a name="_Toc151267873">阻塞</a><span>&nbsp;<br></span><span>　　阻塞，你也许早就听说了。<span>"</span>阻塞<span>"</span>是<span>&nbsp;"sleep"&nbsp;</span>的科技行话。你可能注意到前面运行的<span>&nbsp;listener&nbsp;</span>程序，它在那里不停地运行，等待数据包的到来。实际在运行的是它调用<span>&nbsp;recvfrom()</span>，然后没有数据，因此<span>&nbsp;recvfrom()</span>说<span>"&nbsp;</span>阻塞<span>&nbsp;(block)"</span>，直到数据的到来。<span>&nbsp;<br></span>很多函数都利用阻塞。<span>accept()&nbsp;</span>阻塞，所有的<span>&nbsp;recv*()&nbsp;</span>函数阻塞。它 们之所以能这样做是因为它们被允许这样做。当你第一次调用<span>&nbsp;socket()&nbsp;</span>建立套接字描述符的时候，内核就将它设置为阻塞。如果你不想套接字阻塞，你就要调用函数<span>&nbsp;fcntl()</span>：<span>&nbsp;<br> #include &lt;unistd.h&gt;&nbsp;<br></span>　　<span>#include &lt;fontl.h&gt;&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;sockfd = socket(AF_INET, SOCK_STREAM, 0);&nbsp;<br></span>　　<span>&nbsp;fcntl(sockfd, F_SETFL, O_NONBLOCK);&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　<span>&nbsp;.&nbsp;<br></span>　　通过设置套接字为非阻塞，你能够有效地<span>"</span>询问<span>"</span>套接字以获得信息。如果你尝试着从一个非阻塞的套接字读信息并且没有任何数据，它不允许阻 塞<span>--</span>它将返回<span>&nbsp;-1&nbsp;</span>并将<span>&nbsp;errno&nbsp;</span>设置为<span>&nbsp;EWOULDBLOCK</span>。<span>&nbsp;<br></span>但是一般说来，这种询问不是个好主意。如果你让你的程序在忙等状 态查询套接字的数据，你将浪费大量的<span>&nbsp;CPU&nbsp;</span>时间。更好的解决之道是用下一章讲的<span>&nbsp;select()&nbsp;</span>去查询是否有数据要读进来。</span></p> 
    <p><a name="_Toc151267874">select()--</a><span><span><span>多路同步<span>&nbsp;I/O</span></span></span></span><span>&nbsp;<br></span><span>　　虽然这个函数有点奇怪，但是它很有用。假设这样的情况：你是个服务器，你一边在不停地从连接上读数据，一边在侦听连接上的信息。 没问题，你可能会说，不就是一个<span>&nbsp;accept()&nbsp;</span>和两个<span>&nbsp;recv()&nbsp;</span>吗<span>?&nbsp;</span>这么 容易吗，朋友<span>?&nbsp;</span>如果你在调用<span>&nbsp;accept()&nbsp;</span>的时候阻塞呢<span>?&nbsp;</span>你怎么能够同时接受<span>&nbsp;recv()&nbsp;</span>数据<span>?&nbsp;</span>“用非阻塞的套接字啊！” 不行！你不想耗尽所有的<span>&nbsp;CPU&nbsp;</span>吧<span>?&nbsp;</span>那么，该如何是好<span>?&nbsp;<br> select()&nbsp;</span>让你可以同时监视多个套接字。如果你想知道的话，那么它就 会告诉你哪个套接字准备读，哪个又准备写，哪个套接字又发生了例外<span>&nbsp;(exception)</span>。<span>&nbsp;<br></span>闲话少说，下面是<span>&nbsp;select()</span>：<span>&nbsp;<br> #include &lt;sys/time.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;unistd.h&gt;&nbsp;<br> int select(int numfds, fd_set *readfds, fd_set *writefds,fd_set&nbsp;<br> *exceptfds, struct timeval *timeout);&nbsp;<br></span>这个函数监视一系列文件描述符，特别是<span>&nbsp;readfds</span>、<span>writefds&nbsp;</span>和<span>&nbsp;exceptfds</span>。如果你想知道你是否能够从标准输入和套接字描述符<span>&nbsp;sockfd&nbsp;</span>读入数据，你只要将文件描述符<span>&nbsp;0&nbsp;</span>和<span>&nbsp;sockfd&nbsp;</span>加入到集合<span>&nbsp;readfds&nbsp;</span>中。参 数<span>numfds&nbsp;</span>应该等于最高的文件描述符的值加<span>1</span>。在这个例子中，你应该 设置该值为<span>&nbsp;sockfd+1</span>。因为它一定大于标准输入的文件描述符<span>&nbsp;(0)</span>。 当函数<span>&nbsp;select()&nbsp;</span>返回的时候，<span>readfds&nbsp;</span>的值修改为反映你选择的哪个文件描述符可以读。你可以用下面讲到的宏<span>&nbsp;FD_ISSET()&nbsp;</span>来测试。 在我们继续下去之前，让我来讲讲如何对这些集合进行操作。每个集合类型都是<span>&nbsp;fd_set</span>。下面有一些宏来对这个类型进行操作：<span>&nbsp;<br> FD_ZERO(fd_set *set)&nbsp;</span>– 清除一个文件描述符集合<span>&nbsp;<br></span>　　<span>FD_SET(int fd, fd_set *set) -&nbsp;</span>添加<span>fd</span>到集合<span>&nbsp;<br></span>　　<span>FD_CLR(int fd, fd_set *set)&nbsp;</span>– 从集合中移去<span>fd&nbsp;<br></span>　　<span>FD_ISSET(int fd, fd_set *set)&nbsp;</span>– 测试<span>fd</span>是否在集合中<span>&nbsp;<br></span>最后，是有点古怪的数据结构<span>&nbsp;struct timeval</span>。有时你可不想永远等待别人发送数据过来。也许什么事情都没有发生的时候你也想每隔<span>96</span>秒在终 端上打印字符串<span>&nbsp;"Still Going..."</span>。这个数据结构允许你设定一个时间，如果时间到了，而<span>&nbsp;select()&nbsp;</span>还没有找到一个准备好的文件描述符，它将返回让你继续处理。<span>&nbsp;<br></span>数据结构<span>&nbsp;struct timeval&nbsp;</span>是这样的：<span>&nbsp;<br> struct timeval {&nbsp;<br></span>　　<span>&nbsp;int tv_sec; /* seconds */&nbsp;<br></span>　　<span>&nbsp;int tv_usec; /* microseconds */&nbsp;<br></span>　　<span>&nbsp;};&nbsp;<br></span>只要将<span>&nbsp;tv_sec&nbsp;</span>设置为你要等待的秒数，将<span>&nbsp;tv_usec&nbsp;</span>设置为你要等待的微秒数就可以了。是的，是微秒而不是毫秒。<span>1,000</span>微秒等于<span>1</span>毫秒，<span>1,000&nbsp;</span>毫秒等于<span>1</span>秒。也就是说，<span>1</span>秒等于<span>1,000,000</span>微秒。为什么用符号<span>&nbsp;"usec"</span>呢<span>?&nbsp;</span>字母<span>&nbsp;"u"&nbsp;</span>很象希腊字母<span>&nbsp;Mu</span>，而<span>&nbsp;Mu&nbsp;</span>表示<span>&nbsp;"</span>微<span>"&nbsp;</span>的意思。当然，函数 返回的时候<span>&nbsp;timeout&nbsp;</span>可能是剩余的时间，之所以是可能，是因为它依赖于 你的<span>&nbsp;Unix&nbsp;</span>操作系统。<span>&nbsp;<br></span>哈！我们现在有一个微秒级的定时器！别计算了，标准的<span>&nbsp;Unix&nbsp;</span>系统 的时间片是<span>100</span>毫秒，所以无论你如何设置你的数据结构<span>&nbsp;struct timeval</span>，你都要等待那么长的时间。<span>&nbsp;<br></span>还有一些有趣的事情：如果你设置数据结构<span>&nbsp;struct timeval&nbsp;</span>中的数据为<span>&nbsp;0</span>，<span>select()&nbsp;</span>将立即超时，这样就可以有效地轮询集合中的所有的文件描述符。如果你将参数<span>&nbsp;timeout&nbsp;</span>赋值为<span>&nbsp;NULL</span>，那么将永远不会发生超时，即一直等到第一个文件描述符就绪。最后，如果你不是很关心等待多长时间，那么就把它赋为<span>&nbsp;NULL&nbsp;</span>吧。<span>&nbsp;<br></span>下面的代码演示了在标准输入上等待<span>&nbsp;2.5&nbsp;</span>秒：<span>&nbsp;<br> #include &lt;sys/time.h&gt;&nbsp;<br></span>　　<span>#include &lt;sys/types.h&gt;&nbsp;<br></span>　　<span>#include &lt;unistd.h&gt;&nbsp;<br> #define STDIN 0 /* file descriptor for standard input */&nbsp;<br> main()&nbsp;<br></span>　　<span>&nbsp;{&nbsp;<br></span>　　<span>struct timeval tv;&nbsp;<br></span>　　<span>fd_set readfds;&nbsp;<br> tv.tv_sec = 2;&nbsp;<br></span>　　<span>tv.tv_usec = 500000;&nbsp;<br> FD_ZERO(&amp;readfds);&nbsp;<br></span>　　<span>FD_SET(STDIN, &amp;readfds);&nbsp;<br> /* don't care about writefds and exceptfds: */&nbsp;<br></span>　　<span>select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);&nbsp;<br> if (FD_ISSET(STDIN, &amp;readfds))&nbsp;<br></span>　　<span>printf("A key was pressed!n");&nbsp;<br></span>　　<span>else&nbsp;<br></span>　　<span>printf("Timed out.n");&nbsp;<br></span>　　<span>}&nbsp;<br></span>如果你是在一个<span>&nbsp;line buffered&nbsp;</span>终端上，那么你敲的键应该是回车<span>&nbsp;(RETURN)</span>，否则无论如何它都会超时。<span>&nbsp;<br></span>现在，你可能回认为这就是在数据报套接字上等待数据的方式<span>--</span>你是对 的：它可能是。有些<span>&nbsp;Unix&nbsp;</span>系统可以按这种方式，而另外一些则不能。你 在尝试以前可能要先看看本系统的<span>&nbsp;man page&nbsp;</span>了。<span>&nbsp;<br></span>最后一件关于<span>&nbsp;select()&nbsp;</span>的事情：如果你有一个正在侦听<span>&nbsp;(listen())&nbsp;</span>的套 接字，你可以通过将该套接字的文件描述符加入到<span>&nbsp;readfds&nbsp;</span>集合中来看是否有新的连接。<span>&nbsp;<br></span>这就是我关于函数<span>select()&nbsp;</span>要讲的所有的东西。</span></p> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">
    专注于企业信息化，最近对股票数据分析较为感兴趣，可免费分享股票个股主力资金实时变化趋势分析工具，股票交流QQ群：457394862
   </div> 
   <div class="clear" style="clear:both;color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"></div> 
   <div> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">分类:&nbsp;<a href="http://www.cnblogs.com/omygod/category/72753.html" rel="nofollow" style="color:rgb(52,104,164);">C/C++</a><br></p> 
    <p style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
    <p><font color="#4b4b4b"><span style="font-size:13px;">本文转自沧海-重庆博客园博客，原文链接：http://www.cnblogs.com/omygod/archive/2007/05/11/742559.html，如需转载请自行联系原作者</span></font><br></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
