<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>如何养成良好的c++编程习惯（1）——内存管理 « NotBeCN</title>
  <meta name="description" content="             开篇导读    　　“养成良好的编程习惯”其实是相当综合的一个命题，可以从多个角度、维度和层次进行论述和评判。如代码的风格、效率和可读性；模块设计的灵活 性、可扩展性和耦合度等等。要试图把所有方面都阐述清楚必须花很多的精力，而且也不一定能阐述得全面。因此，本系列文章以软件开发的基础问题为...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/03/31/weixin_34279579_90117454.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">如何养成良好的c++编程习惯（1）——内存管理</h1>
    <p class="post-meta">Mar 31, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><span style="line-height:1.5;font-size:18pt;"><strong>开篇导读</strong></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　“养成良好的编程习惯”其实是相当综合的一个命题，可以从多个角度、维度和层次进行论述和评判。如代码的风格、效率和可读性；模块设计的灵活 性、可扩展性和耦合度等等。要试图把所有方面都阐述清楚必须花很多的精力，而且也不一定能阐述得全面。因此，本系列文章以软件开发的基础问题为切入点，阐 述程序设计和代码编写方面的细节问题，以点带面，旨在激发大家的思考与总结，希望能为大家带来实际的帮助。 &nbsp;&nbsp;&nbsp; 　　　　</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　虽然本系列文章定位为科普读物，但本座相信它们不但适合新手们学习借鉴，同时也能引发老鸟们的反思与共鸣。欢迎大家提出宝贵的意见和反馈 ^_^</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　在开篇讲述本章主要内容之前，本座首先用小小篇幅论述一下一种良好的工作习惯 —— 积累、提炼与求精。在工作和学习的过程中，不断把学到的知识通过有效的方式积累起来，形成自己的知识库，随着知识量的扩大，就会得到从量变到质变的提升。 另外还要不断地对知识进行提炼，随着自己知识面的扩大以及水平的提升，你肯定会发现原有知识库存在着一些片面、局限、笨拙甚至错误。这时，就需要你有精益 求精精的态度和毅力对知识库进行优化整理。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　也许以上这些各位都曾想过去实施，也明白其中的道理，但是自己就是给自己各种堂而皇之的借口不花时间去做。这样说吧，技术之路不好走，这个行业 有两项基本要求：1、对软件开发工作本身有很大兴趣；2、耐得住寂寞。两者缺一不可，否则还是趁年轻早点转行吧，要不转做软件行业的销售、产品或者管理也 行，总之就不要做开发 ^_^</p> 
   <hr style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><strong><span style="line-height:1.5;font-size:18pt;">内存管理相关问题</span></strong></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　一提起 C/C++ 的内存管理，大部分人脑海里都立刻涌出 new / delete / malloc / free 等几个恐怖的单词吧？的确，C/C++ 的手工内存管理是它们区别于其他语言的一大特点，也像一道屏障立在那些想从其它语言转向 C/C++ 的人士身前。由此也引起各大论坛对 “C++ 人气低落”和“是否应该引入垃圾回收机制”等相关话题的剧烈争论。本座一直无视这些争论，其实并非本座不关心 C++ 的发展与命运，相反，本座十分关心。虽然从现在的眼光看来，无论是 C++ 身上有多少硬伤，C++ 委员会的大爷们和 C++ 编译器厂商的大佬们如何扯猫尾。毕竟最爱就是最爱，残缺美也是美，不解释。本座之所以不关心这些争论，原因是因为看透了，一门语言就像一种人生，是有生命 周期的，没落只是快慢的问题，旧事物总会被新事物取代，这是客观规律不可避免。秦始皇最终不也是没找到长生不老的仙丹么？只要曾经发光发热过，在还有价值 的时候能为大众所用就已经无憾了。本座在此还要申明一种态度：本座并不排斥任何语言，相反，本座对新语言的诞生非常感兴趣。会去了解它们的特点，看看它们 能帮助解决哪方面的问题。正如这几年，由于工作需要，本座用得最多的是 Java 和一些动态语言（它们的确能解决很多问题），而 C/C++ 却没再用了。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　嗯，扯远了，我们还是回到正题吧。说起 C/C++ 的内存管理似乎令人望而生畏，满屏的 new / delete / malloc / free，OutPut 窗口无尽的 Memory Leak 警告，程序诡异的 0X00000004 指针异常，仿佛回到那一年我们一起哭过的日子，你 Hold 得住吗？其实，现实并没有你想的那么糟糕。只要你付出一点点，花一点点心思，没错！就一点点而已 ——&nbsp;<strong>用 C++ 类封装内存访问</strong>，就会解决你大部分的烦恼，让你受益终身。以 Windows 程序为例，主要有以下几种内存管理方式：</p> 
   <ul style="list-style:none;font-size:12px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;"> <strong>虚拟内存</strong>（Virtual Memory）</li> 
    <li style="list-style-type:disc;"> <strong>默认堆</strong>和<strong>私有堆</strong>（Process Heap &amp; Private Heap）</li> 
    <li style="list-style-type:disc;"> <strong>内存映射文件</strong>（File Mapping）</li> 
    <li style="list-style-type:disc;"> <strong>进程堆栈</strong>（Heap，其实就是用 malloc()&nbsp;或&nbsp;默认的 new 操作符在 Process Heap 里一小块一小块地割肉 ^_^）</li> 
    <li style="list-style-type:disc;"> <strong>栈</strong>（Stack，内存由调用者或被调用者自动管理）</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　 今天我们的主题是封装，至于每种内存模型的概念和 API 的使用方式在这里就不讲了，Google 一下就知道。其实用 C++ 封装上述前 4 种内存访问的原理都差不多，就是在构造函数或其他操作函数中分配内存，然后再在析构函数中确保内存被正确释放。虚拟内存、默认堆和私有堆的操作方式相似， 这里就不一一展示了，有兴趣的朋友可以参考本座前几天发表的那篇无人问津的文章：《<a href="http://www.cnblogs.com/ldcsaa/archive/2012/02/12/2348302.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">C++ 封装私有堆（Private Heap）</a>》，哎！下面对内存映射文件的封装也只稍作介绍、我们主要讨论的是使用频率最高的 malloc() 和 new 的封装。</p> 
   <hr style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><span style="line-height:1.5;font-size:18pt;"><strong>&nbsp;内存映射文件</strong></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　下面的代码把 File Mapping 句柄以及从 File Mapping 映射出来的内存分别封装到 CFileMapping 和 CShareMemory 中，可以直接使用 CShareMemory 可以创建一个 File Mapping 以及映射 File Mapping 的内存。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">class</span> CFileMapping<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
CFileMapping(    <br>
LPCTSTR lpszName,<br>
DWORD dwMaximumSizeLow,<br>
DWORD dwMaximumSizeHigh                            = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>,<br>
HANDLE hFile                                    = INVALID_HANDLE_VALUE,<br>
DWORD flProtect                                    = PAGE_READWRITE,<br>
LPSECURITY_ATTRIBUTES lpFileMappingAttributes    = NULL<br>
)<br>
{<br>
m_hMap    = ::CreateFileMapping    (<br>
hFile,<br>
lpFileMappingAttributes,<br>
flProtect,<br>
dwMaximumSizeHigh,<br>
dwMaximumSizeLow,<br>
lpszName<br>
);<br>
ASSERT(IsValid());<br>
}<br><br>
~CFileMapping()<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(IsValid())<br>
VERIFY(::CloseHandle(m_hMap));<br>
}<br><br>
LPVOID ViewMap    (<br>
DWORD dwNumberOfBytesToMap,<br>
DWORD dwFileOffsetLow,<br>
DWORD dwFileOffsetHigh    = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>,<br>
DWORD dwDesiredAccess    = FILE_MAP_ALL_ACCESS<br>
)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> ::MapViewOfFile    (<br>
m_hMap,<br>
dwDesiredAccess,<br>
dwFileOffsetHigh,<br>
dwFileOffsetLow,<br>
dwNumberOfBytesToMap<br>
);<br>
}<br><br>
BOOL UnViewMap(LPCVOID lpBaseAddress)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> ::UnmapViewOfFile(lpBaseAddress);<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">operator</span> HANDLE    ()    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_hMap;}<br>
BOOL IsValid    ()    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_hMap != NULL;}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
HANDLE m_hMap;<br><br>
DECLARE_PRIVATE_COPY_CONSTRUCTOR(CFileMapping)<br>
};<br><br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> CShareMemory<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
CShareMemory(DWORD dwSize, LPCTSTR lpszName = NULL)<br>
: m_fm(lpszName, dwSize)<br>
{<br>
ASSERT(dwSize &gt; <span style="color:rgb(128,0,128);line-height:1.5;">0</span>);<br>
}<br><br>
~CShareMemory()<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);line-height:1.5;">set</span>&lt;ULONG_PTR&gt;::const_iterator it = m_set.begin(); it != m_set.end(); ++it)<br>
{<br>
LPVOID pV = (LPVOID)*it;<br>
ASSERT(pV);<br><br>
m_fm.UnViewMap(pV);<br>
}<br><br>
m_set.clear();<br>
}<br><br>
LPVOID Alloc(DWORD dwNumberOfBytesToMap, DWORD dwFileOffsetLow)<br>
{<br>
LPVOID pV = m_fm.ViewMap(dwNumberOfBytesToMap, dwFileOffsetLow);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(pV) m_set.insert((ULONG_PTR)pV);<br><br>
ASSERT(pV);<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> pV;<br>
}<br><br>
BOOL Free(LPCVOID lpBaseAddress)<br>
{<br>
ASSERT(lpBaseAddress);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">set</span>&lt;ULONG_PTR&gt;::iterator it = m_set.find((ULONG_PTR)lpBaseAddress);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(it != m_set.end())<br>
m_set.erase(it);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_fm.UnViewMap(lpBaseAddress);<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br><br>
CFileMapping    m_fm;<br><span style="color:rgb(0,0,255);line-height:1.5;">set</span>&lt;ULONG_PTR&gt;    m_set;<br><br>
DECLARE_PRIVATE_COPY_CONSTRUCTOR(CShareMemory)<br>
};</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　细心的朋友一定会发觉其实这样封装是有缺点的：首先，CShareMemory 只能做内存共享，不能映射到真实文件（hFile 永远为 INVALID_HANDLE_VALUE）；第二，可以对 CShareMemory 的 Alloc() 和 Free() 方法进一步封装，利用封装类的析构函数自动调用&nbsp;Free()，这样就可以完全消除 “set&lt;ULONG_PTR&gt;&nbsp;m_set”&nbsp;这个属性了；第三，CFileMapping 也可以把文件句柄一起封装进来，这样，从 CreateFile() 到 CreateFileMapping() 都受控了。这个不完美的封装就权当反面教材吧 ^_^</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <hr style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><span style="line-height:1.5;font-size:18pt;"><strong>malloc() 系列函数</strong></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　很多人都建议，在 C++ 中尽量用 new 操作符取代 malloc()，因为 new 类型安全，自动调用构造函数和析构函数等等。关于这点本座略有异议，在某些情形下 malloc() 其实比 new 更好使，效率方面我们可以不计较（几乎所有编译器的&nbsp;new 操作符都用 malloc() 分配内存），从事过偏底层开发的人都清楚，我们避免不了处理 row data（如：socket 的收发缓冲区等）数据，这类数据是非常适合使用 malloc() 的，用 new 分配的内存还要停顿下来想想到底是用 delete、delete[]、::delete、::delete[] 中的哪个释放，malloc() 分配的内存想都不用想，free() 包打天下，何况人家有 realloc() 可以方便地重新调整内存，你有没有 “renew” 呢？总之一句话，malloc() 的确是有存在的必要，就看接下来我们如何封装它了，请看代码：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> T                 : 数据类型（内置类型或结构体）<br></span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> MAX_CACHE_SIZE    : 预申请内存的最大数目，以 sizeof(T) 为单位，如果该值设置合理，对于<br></span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">                     需要动态递增缓冲区的 buffer 来说能大大提高效率</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> T, size_t MAX_CACHE_SIZE = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> CBufferPtrT<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br><span style="color:rgb(0,0,255);line-height:1.5;">explicit</span> CBufferPtrT(size_t size = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>, <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> zero = <span style="color:rgb(0,0,255);line-height:1.5;">false</span>)    {Reset(); Malloc(size, zero);}<br><span style="color:rgb(0,0,255);line-height:1.5;">explicit</span> CBufferPtrT(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> T* pch, size_t size)    {Reset(); Copy(pch, size);}<br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 拷贝构造函数要分两种情形</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>    CBufferPtrT(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&amp; other)    {Reset(); Copy(other);}<br>
template&lt;size_t S&gt; CBufferPtrT(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&lt;T, S&gt;&amp; other)    {Reset(); Copy(other);}<br><br>
~CBufferPtrT() {Free();}<br><br>
T* Malloc(size_t size = <span style="color:rgb(128,0,128);line-height:1.5;">1</span>, <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> zero = <span style="color:rgb(0,0,255);line-height:1.5;">false</span>)<br>
{<br>
Free();<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> Alloc(size, zero, <span style="color:rgb(0,0,255);line-height:1.5;">false</span>);<br>
}<br><br>
T* Realloc(size_t size, <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> zero = <span style="color:rgb(0,0,255);line-height:1.5;">false</span>)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> Alloc(size, zero, <span style="color:rgb(0,0,255);line-height:1.5;">true</span>);<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">void</span> Free()<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_pch)<br>
{<br>
free(m_pch);<br>
Reset();<br>
}<br>
}<br><br>
template&lt;size_t S&gt; CBufferPtrT&amp; Copy(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&lt;T, S&gt;&amp; other)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>((<span style="color:rgb(0,0,255);line-height:1.5;">void</span>*)&amp;other != (<span style="color:rgb(0,0,255);line-height:1.5;">void</span>*)<span style="color:rgb(0,0,255);line-height:1.5;">this</span>)<br>
Copy(other.Ptr(), other.Size());<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> *<span style="color:rgb(0,0,255);line-height:1.5;">this</span>;<br>
}<br><br>
CBufferPtrT&amp; Copy(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> T* pch, size_t size)<br>
{<br>
Malloc(size);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_pch)<br>
memcpy(m_pch, pch, size * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T));<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> *<span style="color:rgb(0,0,255);line-height:1.5;">this</span>;<br>
}<br><br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 动态扩大 buffer</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>    template&lt;size_t S&gt; CBufferPtrT&amp; Cat(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&lt;T, S&gt;&amp; other)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>((<span style="color:rgb(0,0,255);line-height:1.5;">void</span>*)&amp;other != (<span style="color:rgb(0,0,255);line-height:1.5;">void</span>*)<span style="color:rgb(0,0,255);line-height:1.5;">this</span>)<br>
Cat(other.Ptr(), other.Size());<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> *<span style="color:rgb(0,0,255);line-height:1.5;">this</span>;<br>
}<br><br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 动态扩大 buffer</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>    CBufferPtrT&amp; Cat(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> T* pch, size_t size = <span style="color:rgb(128,0,128);line-height:1.5;">1</span>)<br>
{<br>
size_t pre_size = m_size;<br>
Realloc(m_size + size);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_pch)<br>
memcpy(m_pch + pre_size, pch, size * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T));<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> *<span style="color:rgb(0,0,255);line-height:1.5;">this</span>;<br>
}<br><br>
template&lt;size_t S&gt; <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> Equal(<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&lt;T, S&gt;&amp; other) <span style="color:rgb(0,0,255);line-height:1.5;">const</span><br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>((<span style="color:rgb(0,0,255);line-height:1.5;">void</span>*)&amp;other == (<span style="color:rgb(0,0,255);line-height:1.5;">void</span>*)<span style="color:rgb(0,0,255);line-height:1.5;">this</span>)<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">true</span>;<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span> <span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_size != other.Size())<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">false</span>;<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span> <span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_size == <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">true</span>;<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> (memcmp(m_pch, other.Ptr(), m_size * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T)) == <span style="color:rgb(128,0,128);line-height:1.5;">0</span>);<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">bool</span> Equal(T* pch) <span style="color:rgb(0,0,255);line-height:1.5;">const</span><br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_pch == pch)<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">true</span>;<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span> <span style="color:rgb(0,0,255);line-height:1.5;">if</span>(!m_pch || !pch)<br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">false</span>;<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> (memcmp(m_pch, pch, m_size * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T)) == <span style="color:rgb(128,0,128);line-height:1.5;">0</span>);<br>
}<br><br>
T*    Ptr()    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_pch;}<br><span style="color:rgb(0,0,255);line-height:1.5;">const</span> T*    Ptr()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_pch;}<br>
T&amp;    Get(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> *(m_pch + i);}<br><span style="color:rgb(0,0,255);line-height:1.5;">const</span> T&amp;    Get(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i)    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> *(m_pch + i);}<br>
size_t    Size()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_size;}<br><span style="color:rgb(0,0,255);line-height:1.5;">bool</span>    IsValid()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_pch != <span style="color:rgb(128,0,128);line-height:1.5;">0</span>;}<br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 啊哈，竟然是类型安全的</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    T*    ()    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Ptr();}<br><span style="color:rgb(0,0,255);line-height:1.5;">operator</span> <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    T*    ()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Ptr();}<br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 哇塞，竟然还支持索引访问</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>    T&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    []    (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Get(i);}<br><span style="color:rgb(0,0,255);line-height:1.5;">const</span> T&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    []    (<span style="color:rgb(0,0,255);line-height:1.5;">int</span> i)    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Get(i);}<br><span style="color:rgb(0,0,255);line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    ==    (T* pv)    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Equal(pv);}<br>
template&lt;size_t S&gt; <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    ==    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&lt;T, S&gt;&amp; other)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Equal(other);}<br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 赋值操作符要分两种情形</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>    CBufferPtrT&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&amp; other)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Copy(other);}<br>
template&lt;size_t S&gt; CBufferPtrT&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span>    =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> CBufferPtrT&lt;T, S&gt;&amp; other)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> Copy(other);}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br><span style="color:rgb(0,0,255);line-height:1.5;">void</span> Reset()    {m_pch = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>; m_size = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>; m_capacity = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>;}<br>
size_t GetAllocSize(size_t size)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> max(size, min(size * <span style="color:rgb(128,0,128);line-height:1.5;">2</span>, m_size + MAX_CACHE_SIZE));}<br><br>
T* Alloc(size_t size, <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> zero = <span style="color:rgb(0,0,255);line-height:1.5;">false</span>, <span style="color:rgb(0,0,255);line-height:1.5;">bool</span> is_realloc = <span style="color:rgb(0,0,255);line-height:1.5;">false</span>)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(size &gt;= <span style="color:rgb(128,0,128);line-height:1.5;">0</span> &amp;&amp; size != m_size)<br>
{<br>
size_t rsize = GetAllocSize(size);<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(size &gt; m_capacity || rsize &lt; m_size)<br>
{<br>
m_pch = is_realloc                            ?<br>
(T*)realloc(m_pch, rsize * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T))    :<br>
(T*)malloc(rsize * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T))            ;<br><br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(m_pch || rsize == <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)<br>
{<br>
m_size        = size;<br>
m_capacity    = rsize;<br>
}<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span><br>
Reset();<br>
}<br><span style="color:rgb(0,0,255);line-height:1.5;">else</span><br>
m_size = size;<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(zero &amp;&amp; m_pch)<br>
memset(m_pch, <span style="color:rgb(128,0,128);line-height:1.5;">0</span>, m_size * <span style="color:rgb(0,0,255);line-height:1.5;">sizeof</span>(T));<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> m_pch;<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
T*        m_pch;<br>
size_t    m_size;<br>
size_t    m_capacity;<br>
};<br><br><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 常用 buffer 类型的 typedef</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span>typedef CBufferPtrT&lt;<span style="color:rgb(0,0,255);line-height:1.5;">char</span>&gt;            CCharBufferPtr;<br>
typedef CBufferPtrT&lt;wchar_t&gt;        CWCharBufferPtr;<br>
typedef CBufferPtrT&lt;unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span>&gt;    CByteBufferPtr;<br>
typedef CByteBufferPtr                CBufferPtr;<br><br>
#ifdef _UNICODE<br>
typedef CWCharBufferPtr            CTCharBufferPtr;<br><span style="color:rgb(0,0,255);line-height:1.5;">#else</span><br>
typedef CCharBufferPtr            CTCharBufferPtr;<br><span style="color:rgb(0,0,255);line-height:1.5;">#endif</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br> 嗯。这里要解释一下为何需要两个拷贝构造函数和赋值操作符重载，首先，编译器为不同的模板参数生成不同的类，也就是 说：CBufferPtrT&lt;int, 1&gt; 和 CBufferPtrT&lt;int, 2&gt; 被看作是不同的类，另外，C++ 编译器为每个类提供了提供了拷贝构造函数和赋值操作符重载的默认实现（浅拷贝）。因此，上述的第一组拷贝构造函数和赋值操作符重载是改写编译器的默认实 现，第二组拷贝构造函数和赋值操作符重载是处理其它类到本类的转换。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　本座对这个封装灰常满意（唯一美中不足的就是 cnblogs 的编辑器太坑爹了，把代码弄乱 ^_^），它并非只是一个普通的 malloc() 封装，完全能可以把它看作是一种“<strong>支持索引访问的类型安全的动态缓冲区”</strong>。如果把它放在一个 socket 通信类中作为成员属性，充当跨越多个线程和多个方法访问的接收缓冲区和发送缓冲区的角色就最适合不过了（当然要自己做同步了）。大家可以调试一下下面的测试例子，了解一下它的用法：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <img class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" style="border:0px;vertical-align:middle;">
    <span class="cnblogs_code_collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">测试用例</span> 
    <div class="cnblogs_code_hide"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
     </div> 
     <pre><span style="color:rgb(0,128,128);line-height:1.5;"> 1</span> <span style="color:rgb(0,0,255);line-height:1.5;">int</span> _tmain(<span style="color:rgb(0,0,255);line-height:1.5;">int</span> argc, _TCHAR* argv[])<br><span style="color:rgb(0,128,128);line-height:1.5;"> 2</span> {<br><span style="color:rgb(0,128,128);line-height:1.5;"> 3</span>     CBufferPtr buffer;<br><span style="color:rgb(0,128,128);line-height:1.5;"> 4</span> <br><span style="color:rgb(0,128,128);line-height:1.5;"> 5</span>     unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span> c1    = <span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">X</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;"> 6</span>     unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span> pc1[] = <span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">123</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;"> 7</span>     unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span> pc2[] = <span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">abc</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;"> 8</span>     buffer.Cat(&amp;c1);<br><span style="color:rgb(0,128,128);line-height:1.5;"> 9</span>     buffer.Cat(pc1, <span style="color:rgb(128,0,128);line-height:1.5;">3</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">10</span>     buffer.Cat(pc2, <span style="color:rgb(128,0,128);line-height:1.5;">3</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">11</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">12</span>     CBufferPtrT&lt;unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span>, <span style="color:rgb(128,0,128);line-height:1.5;">10</span>&gt; buffer2 = buffer;<br><span style="color:rgb(0,128,128);line-height:1.5;">13</span>     buffer2.Cat(buffer);<br><span style="color:rgb(0,128,128);line-height:1.5;">14</span>     buffer2.Realloc(<span style="color:rgb(128,0,128);line-height:1.5;">0</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">15</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">16</span>     unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span>* pc = buffer;<br><span style="color:rgb(0,128,128);line-height:1.5;">17</span>     <span style="color:rgb(0,0,255);line-height:1.5;">const</span> unsigned <span style="color:rgb(0,0,255);line-height:1.5;">char</span>&amp; c = buffer[<span style="color:rgb(128,0,128);line-height:1.5;">5</span>];<br><span style="color:rgb(0,128,128);line-height:1.5;">18</span>     buffer[<span style="color:rgb(128,0,128);line-height:1.5;">5</span>] = <span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">O</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;">19</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">20</span>     <span style="color:rgb(0,0,255);line-height:1.5;">short</span> i1    = <span style="color:rgb(128,0,128);line-height:1.5;">0x7FFF</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;">21</span>     <span style="color:rgb(0,0,255);line-height:1.5;">short</span> pi0[] = {<span style="color:rgb(128,0,128);line-height:1.5;">9</span>,<span style="color:rgb(128,0,128);line-height:1.5;">9</span>,<span style="color:rgb(128,0,128);line-height:1.5;">9</span>};<br><span style="color:rgb(0,128,128);line-height:1.5;">22</span>     <span style="color:rgb(0,0,255);line-height:1.5;">short</span> pi1[] = {<span style="color:rgb(128,0,128);line-height:1.5;">1</span>,<span style="color:rgb(128,0,128);line-height:1.5;">2</span>,<span style="color:rgb(128,0,128);line-height:1.5;">3</span>};<br><span style="color:rgb(0,128,128);line-height:1.5;">23</span>     <span style="color:rgb(0,0,255);line-height:1.5;">short</span> pi2[] = {<span style="color:rgb(128,0,128);line-height:1.5;">4</span>,<span style="color:rgb(128,0,128);line-height:1.5;">5</span>,<span style="color:rgb(128,0,128);line-height:1.5;">6</span>};<br><span style="color:rgb(0,128,128);line-height:1.5;">24</span>     <span style="color:rgb(0,0,255);line-height:1.5;">short</span> pi3[] = {<span style="color:rgb(128,0,128);line-height:1.5;">8</span>,<span style="color:rgb(128,0,128);line-height:1.5;">8</span>,<span style="color:rgb(128,0,128);line-height:1.5;">8</span>};<br><span style="color:rgb(0,128,128);line-height:1.5;">25</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">26</span>     CBufferPtrT&lt;<span style="color:rgb(0,0,255);line-height:1.5;">short</span>, <span style="color:rgb(128,0,128);line-height:1.5;">10</span>&gt; bufferS(pi0, <span style="color:rgb(128,0,128);line-height:1.5;">3</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">27</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">28</span>     bufferS.Cat(&amp;i1);<br><span style="color:rgb(0,128,128);line-height:1.5;">29</span>     bufferS.Cat(pi1, <span style="color:rgb(128,0,128);line-height:1.5;">3</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">30</span>     bufferS.Cat(pi2, <span style="color:rgb(128,0,128);line-height:1.5;">3</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">31</span>     bufferS.Cat(pi3, <span style="color:rgb(128,0,128);line-height:1.5;">3</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">32</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">33</span>     CBufferPtrT&lt;<span style="color:rgb(0,0,255);line-height:1.5;">short</span>, <span style="color:rgb(128,0,128);line-height:1.5;">5</span>&gt; bufferS2;<br><span style="color:rgb(0,128,128);line-height:1.5;">34</span>     bufferS2.Malloc(<span style="color:rgb(128,0,128);line-height:1.5;">4</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">35</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">36</span>     bufferS2 = bufferS;<br><span style="color:rgb(0,128,128);line-height:1.5;">37</span>     bufferS2.Realloc(<span style="color:rgb(128,0,128);line-height:1.5;">30</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">38</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">39</span>     CBufferPtrT&lt;<span style="color:rgb(0,0,255);line-height:1.5;">int</span>&gt; bufferI(<span style="color:rgb(128,0,128);line-height:1.5;">5</span>, <span style="color:rgb(0,0,255);line-height:1.5;">true</span>);<br><span style="color:rgb(0,128,128);line-height:1.5;">40</span>     <br><span style="color:rgb(0,128,128);line-height:1.5;">41</span>     <span style="color:rgb(0,0,255);line-height:1.5;">for</span>(size_t i = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>; i &lt; bufferI.Size(); i++)<br><span style="color:rgb(0,128,128);line-height:1.5;">42</span>         bufferI[i] = i *<span style="color:rgb(128,0,128);line-height:1.5;">10</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;">43</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">44</span>     bufferI.Malloc();<br><span style="color:rgb(0,128,128);line-height:1.5;">45</span>     bufferI[<span style="color:rgb(128,0,128);line-height:1.5;">0</span>] = <span style="color:rgb(128,0,128);line-height:1.5;">123</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;">46</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">47</span>     <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 下面这行编译不通过，正好说明这个类是类型安全的<br></span><span style="color:rgb(0,128,128);line-height:1.5;">48</span> <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> bufferI = bufferS;</span><span style="color:rgb(0,128,0);line-height:1.5;"><br></span><span style="color:rgb(0,128,128);line-height:1.5;">49</span> <br><span style="color:rgb(0,128,128);line-height:1.5;">50</span>     <span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(128,0,128);line-height:1.5;">0</span>;<br><span style="color:rgb(0,128,128);line-height:1.5;">51</span> }</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
     </div> 
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <hr style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><span style="line-height:1.5;font-size:18pt;"><strong>new&nbsp;&amp; delete</strong></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">　　一说到 new 的封装大家立马想到的就是智能指针吧！没错，就是智能指针。但&nbsp;STL 提供的 auto_ptr 缺陷很多，首先使用起来不方便，竟然连这种写法都不支持：“std::auto_ptr&lt;int&gt; pi = new int;”，天理何在啊！更可恨的是不支持数组指针（需要 delete[]），另外如果某些类重载了 new 操作符的话使用它也有很多问题的，还有其它的很多缺点（我忘记了 ^_^）。不过，C++0x 似乎对智能指针作了重大改进，已经有支持引用计数的智能指针了，但不知是否解决数组指针和区分 delete 与 ::delete 的问题（本座没实测，要是您知道麻烦告诉一声 ^_^）。无论如何，下面代码列出的智能指针支持区分 delete / delete[] / ::delete&nbsp;/ ::delete[]。算是 auto_ptr 的改良（也没有使用引用计数），文章篇幅太长了，测试用例就不发了，各位看官自行尝试吧：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">                       smart_ptr 单实体或数组智能指针                    </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">struct</span> simple_deleter<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> delete_ptr(_Ty* pv) {delete pv;}<br>
};<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">struct</span> global_simple_deleter<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> delete_ptr(_Ty* pv) {::delete pv;}<br>
};<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">struct</span> array_deleter<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> delete_ptr(_Ty* pv) {delete[] pv;}<br>
};<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">struct</span> global_array_deleter<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> delete_ptr(_Ty* pv) {::delete[] pv;}<br>
};<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty, <span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Deleter&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> smart_ptr<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
smart_ptr(_Ty* _Ptr = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)                    : _Myptr(_Ptr)                {}<br>
smart_ptr(smart_ptr&lt;_Ty, _Deleter&gt;&amp; _Right)    : _Myptr(_Right.release())    {}<br><br>
~smart_ptr()<br>
{<br>
reset();<br>
}<br><br>
smart_ptr&lt;_Ty, _Deleter&gt;&amp; reset(_Ty* _Ptr = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (_Ptr != _Myptr)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(_Myptr)<br>
_Deleter::delete_ptr(_Myptr);<br><br>
_Myptr = _Ptr;<br>
}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> *<span style="color:rgb(0,0,255);line-height:1.5;">this</span>;<br>
}<br><br>
smart_ptr&lt;_Ty, _Deleter&gt;&amp; reset(smart_ptr&lt;_Ty, _Deleter&gt;&amp; _Right)<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (<span style="color:rgb(0,0,255);line-height:1.5;">this</span> != &amp;_Right)<br>
reset(_Right.release());<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> *<span style="color:rgb(0,0,255);line-height:1.5;">this</span>;<br>
}<br><br>
_Ty* release()<br>
{<br>
_Ty* _Ptr    = _Myptr;<br>
_Myptr        = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>;<br><br><span style="color:rgb(0,0,255);line-height:1.5;">return</span> _Ptr;<br>
}<br><br>
smart_ptr&lt;_Ty, _Deleter&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ty* _Ptr)                        {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> reset(_Ptr);}<br>
smart_ptr&lt;_Ty, _Deleter&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_ptr&lt;_Ty, _Deleter&gt;&amp; _Right)    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> reset(_Right);}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">bool</span> is_valid        ()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> _Myptr != <span style="color:rgb(128,0,128);line-height:1.5;">0</span>;}<br>
_Ty&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> *        ()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> *_Myptr;}<br>
_Ty* <span style="color:rgb(0,0,255);line-height:1.5;">get</span>            ()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> _Myptr;}<br>
_Ty* <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> -&gt;    ()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> _Myptr;}<br><span style="color:rgb(0,0,255);line-height:1.5;">operator</span> _Ty*        ()    <span style="color:rgb(0,0,255);line-height:1.5;">const</span>    {<span style="color:rgb(0,0,255);line-height:1.5;">return</span> _Myptr;}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_ptr&lt;_Ty, _Deleter&gt;                    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_ptr&lt;_Ty, _Deleter&gt;&amp;    reset        (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_ptr&lt;_Ty, _Deleter&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_ptr&lt;_Ty, _Deleter&gt;                    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Other, _Deleter&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_ptr&lt;_Ty, _Deleter&gt;&amp;    reset        (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Other, _Deleter&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_ptr&lt;_Ty, _Deleter&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Other, _Deleter&gt;&amp;);<br><br><span style="color:rgb(0,0,255);line-height:1.5;">protected</span>:<br>
_Ty* _Myptr;<br>
};<br><br><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">                    smart_simple_ptr 单实体智能指针                      </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> smart_simple_ptr : <span style="color:rgb(0,0,255);line-height:1.5;">public</span> smart_ptr&lt;_Ty, simple_deleter&lt;_Ty&gt;&gt;<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
smart_simple_ptr(_Ty* _Ptr = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)                                    : smart_ptr(_Ptr)    {}<br>
smart_simple_ptr(smart_simple_ptr&lt;_Ty&gt;&amp; _Right)                    : smart_ptr(_Right)    {}<br>
smart_simple_ptr(smart_ptr&lt;_Ty, simple_deleter&lt;_Ty&gt;&gt;&amp; _Right)    : smart_ptr(_Right)    {}<br><br>
smart_simple_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_ptr&lt;_Ty, simple_deleter&lt;_Ty&gt;&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_simple_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_simple_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_simple_ptr&lt;_Ty&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_simple_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_simple_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ty* _Ptr)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_simple_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ptr);}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_simple_ptr&lt;_Ty&gt;                (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_simple_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_simple_ptr&lt;_Ty&gt;                (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_simple_ptr&lt;_Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_simple_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_simple_ptr&lt;_Other&gt;&amp;);<br>
};<br><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">           smart_gd_simple_ptr 单实体智能指针 (使用全局 delete)          </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> smart_gd_simple_ptr : <span style="color:rgb(0,0,255);line-height:1.5;">public</span> smart_ptr&lt;_Ty, global_simple_deleter&lt;_Ty&gt;&gt;<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
smart_gd_simple_ptr(_Ty* _Ptr = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)                                        : smart_ptr(_Ptr)    {}<br>
smart_gd_simple_ptr(smart_gd_simple_ptr&lt;_Ty&gt;&amp; _Right)                    : smart_ptr(_Right)    {}<br>
smart_gd_simple_ptr(smart_ptr&lt;_Ty, global_simple_deleter&lt;_Ty&gt;&gt;&amp; _Right)    : smart_ptr(_Right)    {}<br><br>
smart_gd_simple_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_ptr&lt;_Ty, global_simple_deleter&lt;_Ty&gt;&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_gd_simple_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_gd_simple_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_gd_simple_ptr&lt;_Ty&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_gd_simple_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_gd_simple_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ty* _Ptr)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_gd_simple_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ptr);}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_simple_ptr&lt;_Ty&gt;                    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_simple_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_simple_ptr&lt;_Ty&gt;                    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_gd_simple_ptr&lt;_Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_simple_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_gd_simple_ptr&lt;_Other&gt;&amp;);<br>
};<br><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">                   smart_array_ptr 数组智能指针                        </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> smart_array_ptr : <span style="color:rgb(0,0,255);line-height:1.5;">public</span> smart_ptr&lt;_Ty, array_deleter&lt;_Ty&gt;&gt;<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
smart_array_ptr(_Ty* _Ptr = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)                                : smart_ptr(_Ptr)    {}<br>
smart_array_ptr(smart_simple_ptr&lt;_Ty&gt;&amp; _Right)                : smart_ptr(_Right)    {}<br>
smart_array_ptr(smart_ptr&lt;_Ty, array_deleter&lt;_Ty&gt;&gt;&amp; _Right)    : smart_ptr(_Right)    {}<br><br>
smart_array_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_ptr&lt;_Ty, array_deleter&lt;_Ty&gt;&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_array_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_array_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_array_ptr&lt;_Ty&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_array_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_array_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ty* _Ptr)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_array_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ptr);}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_array_ptr&lt;_Ty&gt;                    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_array_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_array_ptr&lt;_Ty&gt;                    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_array_ptr&lt;_Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_array_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_array_ptr&lt;_Other&gt;&amp;);<br>
};<br><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">          smart_gd_array_ptr 数组智能指针 (使用全局 delete)          </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;">**********************************************************************</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Ty&gt;<br><span style="color:rgb(0,0,255);line-height:1.5;">class</span> smart_gd_array_ptr : <span style="color:rgb(0,0,255);line-height:1.5;">public</span> smart_ptr&lt;_Ty, global_array_deleter&lt;_Ty&gt;&gt;<br>
{<br><span style="color:rgb(0,0,255);line-height:1.5;">public</span>:<br>
smart_gd_array_ptr(_Ty* _Ptr = <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)                                        : smart_ptr(_Ptr)    {}<br>
smart_gd_array_ptr(smart_gd_array_ptr&lt;_Ty&gt;&amp; _Right)                        : smart_ptr(_Right)    {}<br>
smart_gd_array_ptr(smart_ptr&lt;_Ty, global_array_deleter&lt;_Ty&gt;&gt;&amp; _Right)    : smart_ptr(_Right)    {}<br><br>
smart_gd_array_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_ptr&lt;_Ty, global_array_deleter&lt;_Ty&gt;&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_gd_array_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_gd_array_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (smart_gd_array_ptr&lt;_Ty&gt;&amp; _Right)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_gd_array_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Right);}<br><br>
smart_gd_array_ptr&lt;_Ty&gt;&amp; <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ty* _Ptr)<br>
{<span style="color:rgb(0,0,255);line-height:1.5;">return</span> (smart_gd_array_ptr&lt;_Ty&gt;&amp;)__super::<span style="color:rgb(0,0,255);line-height:1.5;">operator</span> = (_Ptr);}<br><br><span style="color:rgb(0,0,255);line-height:1.5;">private</span>:<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_array_ptr&lt;_Ty&gt;                (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_array_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_ptr&lt;_Ty, _Other&gt;&amp;);<br><br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_array_ptr&lt;_Ty&gt;                (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_gd_array_ptr&lt;_Other&gt;&amp;);<br>
template&lt;<span style="color:rgb(0,0,255);line-height:1.5;">class</span> _Other&gt; smart_gd_array_ptr&lt;_Ty&gt;&amp;    <span style="color:rgb(0,0,255);line-height:1.5;">operator</span> =    (<span style="color:rgb(0,0,255);line-height:1.5;">const</span> smart_gd_array_ptr&lt;_Other&gt;&amp;);<br>
};</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:0px;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <hr style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br><span style="line-height:1.5;font-size:18pt;"><strong>&nbsp;后记</strong></span></p> 
   <ul style="list-style:none;font-size:12px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li>
     <ul style="list-style:none;">
      <li style="list-style-type:disc;">&nbsp;对于内存管理，其实还有一种情形还没讲的，就是如何优雅地管理 vetor、list、map 这类容器中的指针，这个话题留到以后讨论 STL 时再详细阐述吧。</li> 
      <li style="list-style-type:disc;">在本座的代码中基本上看不到&nbsp;free /&nbsp;delere 这类单词（new 则是有的 —— 给智能指针赋值的时候 ^_^），就本座的经验而言，封装如果利用得当确实能减少很多麻烦，使代码更清晰，有条理，降低错误发生几率。</li> 
      <li style="list-style-type:disc;">当然了，封装并不是万能，它不能解决所有问题，关键是靠个人的专注与细心。</li> 
      <li style="list-style-type:disc;">本座码字提出自己的观点，旨在抛砖引玉，激发大家思考如何培养良好的编程习惯，不是权威，更不能尽信。最实在的知识应该来自个人最直接的体验。</li> 
     </ul></li>
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">转自：<a href="http://www.cnblogs.com/ldcsaa/archive/2012/02/18/2356638.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.cnblogs.com/ldcsaa/archive/2012/02/18/2356638.html</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"><br></p> 
   <p style="line-height:1.5;"><font color="#4b4b4b"><span style="font-size:13px;">本文转自夏雪冬日博客园博客，原文链接：http://www.cnblogs.com/heyonggang/archive/2012/12/25/2831800.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
