<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>module加载过程初步分析［更新中］【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://blog.chinaunix.net/uid-1817735-id-2837068.html    分析这个过程可以有助于我们认识在加载模块时出现的问题大抵在哪里了。 直接从sys_init_module()系统调用的地方开始了。 该函数的实现在 kernel/mod...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/23/weixin_34128501_90135976.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">module加载过程初步分析［更新中］【转】</h1>
    <p class="post-meta">Nov 23, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">转自：<a href="http://blog.chinaunix.net/uid-1817735-id-2837068.html" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">http://blog.chinaunix.net/uid-1817735-id-2837068.html</a></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">分析这个过程可以有助于我们认识在加载模块时出现的问题大抵在哪里了。<br><br> 直接从sys_init_module()系统调用的地方开始了。<br> 该函数的实现在 kernel/module.c 中<br> /* This is where the real work happens */<br> asmlinkage long<br> sys_init_module(void __user *umod,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned long len,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char __user *uargs)<br> {<br> &nbsp;&nbsp;&nbsp; struct module *mod;<br> &nbsp;&nbsp;&nbsp; int ret = 0;<br><br> &nbsp;&nbsp;&nbsp; /* Must have permission */<br> &nbsp;&nbsp;&nbsp; if (!capable(CAP_SYS_MODULE))<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -EPERM;&nbsp; //权限错误&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp; /* Only one module load at a time, please */<br> &nbsp;&nbsp;&nbsp; if (mutex_lock_interruptible(&amp;module_mutex) != 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -EINTR; //中断系统调用，一次只能加载一个module&nbsp;<br><br> &nbsp;&nbsp;&nbsp; /* Do all the hard work */<br> &nbsp;&nbsp;&nbsp; mod = load_module(umod, len, uargs); //load_module返回一个struct module的数据结构<br> &nbsp;&nbsp;&nbsp; if (IS_ERR(mod)) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mutex_unlock(&amp;module_mutex);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return PTR_ERR(mod);<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; /* Drop lock so they can recurse */<br> &nbsp;&nbsp;&nbsp; mutex_unlock(&amp;module_mutex);<br><br> &nbsp;&nbsp;&nbsp; blocking_notifier_call_chain(&amp;module_notify_list,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; MODULE_STATE_COMING, mod);&nbsp; //通知模块list有新的模块加入<br><br> &nbsp;&nbsp;&nbsp; /* Start the module */<br> &nbsp;&nbsp;&nbsp; if (mod-&gt;init != NULL)&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ret = do_one_initcall(mod-&gt;init);&nbsp; //execute init()<br> &nbsp;&nbsp;&nbsp; if (ret &lt; 0) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Init routine failed: abort.&nbsp; Try to protect us from<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buggy refcounters. */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;state = MODULE_STATE_GOING;&nbsp; //change module status<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; synchronize_sched();<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; module_put(mod);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; blocking_notifier_call_chain(&amp;module_notify_list,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; MODULE_STATE_GOING, mod); //通知模块list有模块移出<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mutex_lock(&amp;module_mutex);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; free_module(mod);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mutex_unlock(&amp;module_mutex);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; wake_up(&amp;module_wq);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return ret;<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; if (ret &gt; 0) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printk(KERN_WARNING "%s: '%s'-&gt;init suspiciously returned %d, "<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "it should follow 0/-E convention\n"<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KERN_WARNING "%s: loading module anyway...\n",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, mod-&gt;name, ret,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dump_stack();<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; /* Now it's a first class citizen!&nbsp; Wake up anyone waiting for it. */<br> &nbsp;&nbsp;&nbsp; mod-&gt;state = MODULE_STATE_LIVE; //可以使用这个模块了<br> &nbsp;&nbsp;&nbsp; wake_up(&amp;module_wq);<br><br> &nbsp;&nbsp;&nbsp; mutex_lock(&amp;module_mutex);<br> &nbsp;&nbsp;&nbsp; /* Drop initial reference. */<br> &nbsp;&nbsp;&nbsp; module_put(mod); //init execute, don't use again。how to execute .probe???<br> &nbsp;&nbsp;&nbsp; unwind_remove_table(mod-&gt;unwind_info, 1);<br> &nbsp;&nbsp;&nbsp; module_free(mod, mod-&gt;module_init); //free module_init()<br> &nbsp;&nbsp;&nbsp; mod-&gt;module_init = NULL;<br> &nbsp;&nbsp;&nbsp; mod-&gt;init_size = 0;<br> &nbsp;&nbsp;&nbsp; mod-&gt;init_text_size = 0;<br> &nbsp;&nbsp;&nbsp; mutex_unlock(&amp;module_mutex);<br><br> &nbsp;&nbsp;&nbsp; return 0;<br> }<br><br> 上面的代码注释中可以看出先会检测权限，权限检测通过后判断是否是一次加载一个模块，如果不是的话，返回系统调用错误。<br> 接下来是一个非常关键的调用 load_module()这个函数将模块从用户空间拷贝到内核空间，并对模块文件进行解析，重定向后以便系统使用。该函数定义也在kernel/module.c 文件中<br><br> /* Allocate and load the module: note that size of section 0 is always<br> &nbsp;&nbsp; zero, and we rely on this for optional sections. */<br> static noinline struct module *load_module(void __user *umod,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; unsigned long len,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; const char __user *uargs)<br> {<br> &nbsp;&nbsp;&nbsp; Elf_Ehdr *hdr;<br> &nbsp;&nbsp;&nbsp; Elf_Shdr *sechdrs;<br> &nbsp;&nbsp;&nbsp; char *secstrings, *args, *modmagic, *strtab = NULL;<br> &nbsp;&nbsp;&nbsp; unsigned int i;<br> &nbsp;&nbsp;&nbsp; unsigned int symindex = 0;<br> &nbsp;&nbsp;&nbsp; unsigned int strindex = 0;<br> &nbsp;&nbsp;&nbsp; unsigned int setupindex;<br> &nbsp;&nbsp;&nbsp; unsigned int exindex;<br> &nbsp;&nbsp;&nbsp; unsigned int exportindex;<br> &nbsp;&nbsp;&nbsp; unsigned int modindex;<br> &nbsp;&nbsp;&nbsp; unsigned int obsparmindex;<br> &nbsp;&nbsp;&nbsp; unsigned int infoindex;<br> &nbsp;&nbsp;&nbsp; unsigned int gplindex;<br> &nbsp;&nbsp;&nbsp; unsigned int crcindex;<br> &nbsp;&nbsp;&nbsp; unsigned int gplcrcindex;<br> &nbsp;&nbsp;&nbsp; unsigned int versindex;<br> &nbsp;&nbsp;&nbsp; unsigned int pcpuindex;<br> &nbsp;&nbsp;&nbsp; unsigned int gplfutureindex;<br> &nbsp;&nbsp;&nbsp; unsigned int gplfuturecrcindex;<br> &nbsp;&nbsp;&nbsp; unsigned int unwindex = 0;<br> #ifdef CONFIG_UNUSED_SYMBOLS<br> &nbsp;&nbsp;&nbsp; unsigned int unusedindex;<br> &nbsp;&nbsp;&nbsp; unsigned int unusedcrcindex;<br> &nbsp;&nbsp;&nbsp; unsigned int unusedgplindex;<br> &nbsp;&nbsp;&nbsp; unsigned int unusedgplcrcindex;<br> #endif<br> &nbsp;&nbsp;&nbsp; unsigned int markersindex;<br> &nbsp;&nbsp;&nbsp; unsigned int markersstringsindex;<br> &nbsp;&nbsp;&nbsp; struct module *mod;<br> &nbsp;&nbsp;&nbsp; long err = 0;<br> &nbsp;&nbsp;&nbsp; void *percpu = NULL, *ptr = NULL; /* Stops spurious gcc warning */<br> &nbsp;&nbsp;&nbsp; struct exception_table_entry *extable;<br> &nbsp;&nbsp;&nbsp; mm_segment_t old_fs;<br><br> &nbsp;&nbsp;&nbsp; DEBUGP("load_module: umod=%p, len=%lu, uargs=%p\n",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; umod, len, uargs);<br> &nbsp;&nbsp;&nbsp; if (len &lt; sizeof(*hdr))<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return ERR_PTR(-ENOEXEC);<br><br> &nbsp;&nbsp;&nbsp; /* Suck in entire file: we'll want most of it. */<br> &nbsp;&nbsp;&nbsp; /* vmalloc barfs on "unusual" numbers.&nbsp; Check here */<br> &nbsp;&nbsp;&nbsp; if (len &gt; 64 * 1024 * 1024 || (hdr = vmalloc(len)) == NULL)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return ERR_PTR(-ENOMEM);<br> &nbsp;&nbsp;&nbsp; if (copy_from_user(hdr, umod, len) != 0) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -EFAULT;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; /* Sanity checks against insmoding binaries or wrong arch,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weird elf version */<br> &nbsp;&nbsp;&nbsp; if (memcmp(hdr-&gt;e_ident, ELFMAG, SELFMAG) != 0 //验证是否是elf文件<br> &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Elf_Ehdr = elf header<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned char e_indent[EI_NIDENT]; //EI_NIDENT = 16<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_MAG0&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 文件标识<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_MAG1&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 文件标识<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_MAG2&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 文件标识<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_MAG3&nbsp;&nbsp;&nbsp; &nbsp; 3&nbsp;&nbsp;&nbsp; 文件标识<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_CLASS&nbsp; 4&nbsp;&nbsp;&nbsp; 文件类<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_DATA&nbsp;&nbsp;&nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp; 数据编码<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_VERSION 6&nbsp;&nbsp; 文件版本<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_PAD&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 补齐字节开始处<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; EI_NIDENT 16&nbsp;&nbsp; e_ident[]大小<br> &nbsp;&nbsp;&nbsp; */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || hdr-&gt;e_type != ET_REL&nbsp; // e_type 目标文件类型<br> &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_NONE = 0&nbsp; &nbsp;&nbsp;&nbsp; 未知的目标文件格式&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_REL&nbsp;&nbsp;&nbsp; = 1 &nbsp;&nbsp;&nbsp; 可重定位文件<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_EXEC = 2&nbsp;&nbsp;&nbsp; 可执行文件<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_DYN&nbsp; = 3&nbsp;&nbsp;&nbsp; 共享目标文件<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_CORE = 4&nbsp;&nbsp;&nbsp; Core文件 (转储格式)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_LOPROC = 0xff00 特定处理器文件<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_HIPROC = 0xffff 特定处理器文件<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ET_LOPROC 与 ET_HIPROC 之间的取值用来标识与处理器相关的文件格式&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || !elf_check_arch(hdr)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || hdr-&gt;e_shentsize != sizeof(*sechdrs)) {// e_shentsize节区头部表格的表项大小<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOEXEC;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; if (len &lt; hdr-&gt;e_shoff + hdr-&gt;e_shnum * sizeof(Elf_Shdr)) //sh = section header<br> &nbsp;&nbsp;&nbsp; //e_shoff 节区头部表格的偏移量(按字节计算)。如果文件没有节区头部表格，可以为0<br> &nbsp;&nbsp;&nbsp; //e_shnum 节区头部表格的表项数目。可以为0的<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto truncated;<br><br> &nbsp;&nbsp;&nbsp; /* Convenience variables */<br> &nbsp;&nbsp;&nbsp; sechdrs = (void *)hdr + hdr-&gt;e_shoff; //可以确定节区开始位置<br> &nbsp;&nbsp;&nbsp; secstrings = (void *)hdr + sechdrs[hdr-&gt;e_shstrndx].sh_offset;<br> &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e_shstrndx 节区头部表格中与节区名称字符串表相关的表项的索引。如果文件没有节区名称字符串表，<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 该参数可以为SHN_UNDEF<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sh_offset 该成员的取值给出节区的第一个字节与文件头之间的偏移。<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 确定节区名称字符串的位置<br> &nbsp;&nbsp;&nbsp; */<br> &nbsp;&nbsp;&nbsp; sechdrs[0].sh_addr = 0;<br><br> &nbsp;&nbsp;&nbsp; for (i = 1; i &lt; hdr-&gt;e_shnum; i++) { // e_shnum&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (sechdrs[i].sh_type != SHT_NOBITS&nbsp; //sh_type 为节区的内容和语义进行分类<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_NULL = 0&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_PROGBITS = 1 此节区包含程序定义的信息，其格式和含义都由程序来解释<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_SYMTAB = 2&nbsp;&nbsp;&nbsp; &nbsp;此节区包含一个符号表。<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_STRTAB = 3&nbsp; 此节区包含字符串表 文件可能包含多个字符串表节区<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_RELA = 4 &nbsp;&nbsp;&nbsp; 此节区包含重定位表项，其中可能会有补齐内容<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_HASH = 5 &nbsp;&nbsp;&nbsp; 此节区包含符号哈希表<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_DYNAMIC = 6 &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .....<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_NOBITS = 8&nbsp; 这种类型的节区不占用文件中的空间。<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHT_REL = 9 &nbsp;&nbsp;&nbsp; 此节区包含重定位表项，其中没有补全<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .....<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; */<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &amp;&amp; len &lt; sechdrs[i].sh_offset + sechdrs[i].sh_size)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto truncated;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Mark all sections sh_addr with their address in the<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; temporary image. */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[i].sh_addr = (size_t)hdr + sechdrs[i].sh_offset;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // sh_addr&nbsp; 如果节区将出现在进程的内存镜像中，这个成员给出节区的第一个字节映出的位置<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 求得该节区在装入image 的内存地址&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Internal symbols and strings. */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (sechdrs[i].sh_type == SHT_SYMTAB) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; symindex = i;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; strindex = sechdrs[i].sh_link; //sh_link 此成员给出节区头部表索引链接，<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //具体的解释依赖于节区的类型<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; strtab = (char *)hdr + sechdrs[strindex].sh_offset;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br> #ifndef CONFIG_MODULE_UNLOAD<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Don't load .exit sections */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (strncmp(secstrings+sechdrs[i].sh_name, ".exit", 5) == 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[i].sh_flags &amp;= ~(unsigned long)SHF_ALLOC; // 不会为这个节区分配内存<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sh_flags字段定义了一个节区中包含的内容是否可以修改,是否可以执行等信息<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 如果一个标志位被设置，则该位取值为1。未定义的各位都设置为0<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHF_WRITE&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 0x1&nbsp;&nbsp;&nbsp; 包含进程执行过程中将可写的数据<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHF_ALLOC&nbsp;&nbsp;&nbsp; 0x2&nbsp;&nbsp;&nbsp; 此节区在进程执行过程中占用内存，某些控制节区并不出现于目标<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 文件的内存映像中，对于那些节区，此位应设置为0<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHF_EXECINSTR&nbsp;&nbsp;&nbsp; 0x4&nbsp;&nbsp;&nbsp; 节区包含可执行的机器指令<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SHF_MASKPROC&nbsp;&nbsp;&nbsp; 0xf0000000&nbsp;&nbsp;&nbsp; 所有包含于此掩码中的四位都用于处理器专用的语义<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; */<br> #endif<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; modindex = find_sec(hdr, sechdrs, secstrings,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ".gnu.linkonce.this_module"); //objdump -x modules_name.ko<br> &nbsp;&nbsp;&nbsp; if (!modindex) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printk(KERN_WARNING "No module found in object\n");<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOEXEC; //可执行格式错误<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; mod = (void *)sechdrs[modindex].sh_addr;&nbsp;<br><br> &nbsp;&nbsp;&nbsp; if (symindex == 0) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printk(KERN_WARNING "%s: module has no symbols (stripped?)\n",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOEXEC;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; /* Optional sections */<br> &nbsp;&nbsp;&nbsp; exportindex = find_sec(hdr, sechdrs, secstrings, "__ksymtab");<br> &nbsp;&nbsp;&nbsp; gplindex = find_sec(hdr, sechdrs, secstrings, "__ksymtab_gpl");<br> &nbsp;&nbsp;&nbsp; gplfutureindex = find_sec(hdr, sechdrs, secstrings, "__ksymtab_gpl_future");<br> &nbsp;&nbsp;&nbsp; crcindex = find_sec(hdr, sechdrs, secstrings, "__kcrctab");<br> &nbsp;&nbsp;&nbsp; gplcrcindex = find_sec(hdr, sechdrs, secstrings, "__kcrctab_gpl");<br> &nbsp;&nbsp;&nbsp; gplfuturecrcindex = find_sec(hdr, sechdrs, secstrings, "__kcrctab_gpl_future");<br> #ifdef CONFIG_UNUSED_SYMBOLS<br> &nbsp;&nbsp;&nbsp; unusedindex = find_sec(hdr, sechdrs, secstrings, "__ksymtab_unused");<br> &nbsp;&nbsp;&nbsp; unusedgplindex = find_sec(hdr, sechdrs, secstrings, "__ksymtab_unused_gpl");<br> &nbsp;&nbsp;&nbsp; unusedcrcindex = find_sec(hdr, sechdrs, secstrings, "__kcrctab_unused");<br> &nbsp;&nbsp;&nbsp; unusedgplcrcindex = find_sec(hdr, sechdrs, secstrings, "__kcrctab_unused_gpl");<br> #endif<br> &nbsp;&nbsp;&nbsp; setupindex = find_sec(hdr, sechdrs, secstrings, "__param");<br> &nbsp;&nbsp;&nbsp; exindex = find_sec(hdr, sechdrs, secstrings, "__ex_table");<br> &nbsp;&nbsp;&nbsp; obsparmindex = find_sec(hdr, sechdrs, secstrings, "__obsparm");<br> &nbsp;&nbsp;&nbsp; versindex = find_sec(hdr, sechdrs, secstrings, "__versions");<br> &nbsp;&nbsp;&nbsp; infoindex = find_sec(hdr, sechdrs, secstrings, ".modinfo");<br> &nbsp;&nbsp;&nbsp; pcpuindex = find_pcpusec(hdr, sechdrs, secstrings); // return 0,!CONFIG_SMP<br> #ifdef ARCH_UNWIND_SECTION_NAME<br> &nbsp;&nbsp;&nbsp; unwindex = find_sec(hdr, sechdrs, secstrings, ARCH_UNWIND_SECTION_NAME);<br> #endif<br><br> &nbsp;&nbsp;&nbsp; /* Don't keep modinfo and version sections. */<br> &nbsp;&nbsp;&nbsp; sechdrs[infoindex].sh_flags &amp;= ~(unsigned long)SHF_ALLOC;<br> &nbsp;&nbsp;&nbsp; sechdrs[versindex].sh_flags &amp;= ~(unsigned long)SHF_ALLOC;<br> #ifdef CONFIG_KALLSYMS<br> &nbsp;&nbsp;&nbsp; /* Keep symbol and string tables for decoding later. */<br> &nbsp;&nbsp;&nbsp; sechdrs[symindex].sh_flags |= SHF_ALLOC;<br> &nbsp;&nbsp;&nbsp; sechdrs[strindex].sh_flags |= SHF_ALLOC;<br> #endif<br> &nbsp;&nbsp;&nbsp; if (unwindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[unwindex].sh_flags |= SHF_ALLOC;<br><br> &nbsp;&nbsp;&nbsp; /* Check module struct version now, before we try to use module. */<br> &nbsp;&nbsp;&nbsp; if (!check_modstruct_version(sechdrs, versindex, mod)) {//checkout modstruct version<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOEXEC;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; modmagic = get_modinfo(sechdrs, infoindex, "vermagic");<br> &nbsp;&nbsp;&nbsp; /* This is allowed: modprobe --force will invalidate it. */<br> &nbsp;&nbsp;&nbsp; if (!modmagic) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = try_to_force_load(mod, "magic");<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (err)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; } else if (!same_magic(modmagic, vermagic, versindex)) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printk(KERN_ERR "%s: version magic '%s' should be '%s'\n",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name, modmagic, vermagic);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOEXEC;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; /* Now copy in args */<br> &nbsp;&nbsp;&nbsp; args = strndup_user(uargs, ~0UL &gt;&gt; 1);<br> &nbsp;&nbsp;&nbsp; if (IS_ERR(args)) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = PTR_ERR(args);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_hdr;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; if (find_module(mod-&gt;name)) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -EEXIST; //模块存在的错误<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_mod;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; mod-&gt;state = MODULE_STATE_COMING; //修改模块的状态.开始加入进来了<br><br> &nbsp;&nbsp;&nbsp; /* Allow arches to frob section contents and sizes.&nbsp; */<br> &nbsp;&nbsp;&nbsp; err = module_frob_arch_sections(hdr, sechdrs, secstrings, mod); // nothing to do for mips<br> &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_mod;<br><br> &nbsp;&nbsp;&nbsp; if (pcpuindex) { //nothing to do for !smp<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* We have a special allocation for this section. */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; percpu = percpu_modalloc(sechdrs[pcpuindex].sh_size,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sechdrs[pcpuindex].sh_addralign,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mod-&gt;name);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!percpu) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOMEM;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_mod;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[pcpuindex].sh_flags &amp;= ~(unsigned long)SHF_ALLOC;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;percpu = percpu;<br> &nbsp;&nbsp;&nbsp; }<br><br> &nbsp;&nbsp;&nbsp; /* Determine total sizes, and put offsets in sh_entsize.&nbsp; For now<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; this is done generically; there doesn't appear to be any<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; special cases for the architectures. */<br> &nbsp;&nbsp;&nbsp; layout_sections(mod, hdr, sechdrs, secstrings); //get core size + init() size<br><br> &nbsp;&nbsp;&nbsp; /* Do the allocs. */<br> &nbsp;&nbsp;&nbsp; ptr = module_alloc_update_bounds(mod-&gt;core_size);//ready for module<br> &nbsp;&nbsp;&nbsp; if (!ptr) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOMEM;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_percpu;<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; memset(ptr, 0, mod-&gt;core_size);<br> &nbsp;&nbsp;&nbsp; mod-&gt;module_core = ptr; //module_core address<br><br> &nbsp;&nbsp;&nbsp; ptr = module_alloc_update_bounds(mod-&gt;init_size);<br> &nbsp;&nbsp;&nbsp; if (!ptr &amp;&amp; mod-&gt;init_size) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = -ENOMEM;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_core;<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; memset(ptr, 0, mod-&gt;init_size);<br> &nbsp;&nbsp;&nbsp; mod-&gt;module_init = ptr; //module_init address<br><br> &nbsp;&nbsp;&nbsp; /* Transfer each section which specifies SHF_ALLOC */<br> &nbsp;&nbsp;&nbsp; DEBUGP("final section addresses:\n");<br> &nbsp;&nbsp;&nbsp; for (i = 0; i &lt; hdr-&gt;e_shnum; i++) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; void *dest;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!(sechdrs[i].sh_flags &amp; SHF_ALLOC))<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (sechdrs[i].sh_entsize &amp; INIT_OFFSET_MASK)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dest = mod-&gt;module_init<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; + (sechdrs[i].sh_entsize &amp; ~INIT_OFFSET_MASK);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dest = mod-&gt;module_core + sechdrs[i].sh_entsize;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (sechdrs[i].sh_type != SHT_NOBITS)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; memcpy(dest, (void *)sechdrs[i].sh_addr,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sechdrs[i].sh_size); //memcpy 拷贝各个段到相应位置<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Update sh_addr to point to copy in image. */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[i].sh_addr = (unsigned long)dest; //更新地址<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; DEBUGP("\t0x%lx %s\n", sechdrs[i].sh_addr, secstrings + sechdrs[i].sh_name);<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; /* Module has been moved. */<br> &nbsp;&nbsp;&nbsp; mod = (void *)sechdrs[modindex].sh_addr; //更新module 段地址<br><br> &nbsp;&nbsp;&nbsp; /* Now we've moved module, initialize linked lists, etc. */<br> &nbsp;&nbsp;&nbsp; module_unload_init(mod);<br><br> &nbsp;&nbsp;&nbsp; /* add kobject, so we can reference it. */<br> &nbsp;&nbsp;&nbsp; err = mod_sysfs_init(mod);<br> &nbsp;&nbsp;&nbsp; if (err)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto free_unload;<br><br> &nbsp;&nbsp;&nbsp; /* Set up license info based on the info section */<br> &nbsp;&nbsp;&nbsp; set_license(mod, get_modinfo(sechdrs, infoindex, "license"));<br><br> &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;* ndiswrapper is under GPL by itself, but loads proprietary modules.<br> &nbsp;&nbsp;&nbsp; &nbsp;* Don't use add_taint_module(), as it would prevent ndiswrapper from<br> &nbsp;&nbsp;&nbsp; &nbsp;* using GPL-only symbols it needs.<br> &nbsp;&nbsp;&nbsp; &nbsp;*/<br> &nbsp;&nbsp;&nbsp; if (strcmp(mod-&gt;name, "ndiswrapper") == 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; add_taint(TAINT_PROPRIETARY_MODULE);<br><br> &nbsp;&nbsp;&nbsp; /* driverloader was caught wrongly pretending to be under GPL */<br> &nbsp;&nbsp;&nbsp; if (strcmp(mod-&gt;name, "driverloader") == 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; add_taint_module(mod, TAINT_PROPRIETARY_MODULE);<br><br> &nbsp;&nbsp;&nbsp; /* Set up MODINFO_ATTR fields */<br> &nbsp;&nbsp;&nbsp; setup_modinfo(mod, sechdrs, infoindex);<br><br> &nbsp;&nbsp;&nbsp; /* Fix up syms, so that st_value is a pointer to location. */<br> &nbsp;&nbsp;&nbsp; err = simplify_symbols(sechdrs, symindex, strtab, versindex, pcpuindex,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod);<br> &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto cleanup;<br><br> &nbsp;&nbsp;&nbsp; /* Set up EXPORTed &amp; EXPORT_GPLed symbols (section 0 is 0 length) */<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_syms = sechdrs[exportindex].sh_size / sizeof(*mod-&gt;syms);<br> &nbsp;&nbsp;&nbsp; mod-&gt;syms = (void *)sechdrs[exportindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; if (crcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;crcs = (void *)sechdrs[crcindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_gpl_syms = sechdrs[gplindex].sh_size / sizeof(*mod-&gt;gpl_syms);<br> &nbsp;&nbsp;&nbsp; mod-&gt;gpl_syms = (void *)sechdrs[gplindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; if (gplcrcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;gpl_crcs = (void *)sechdrs[gplcrcindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_gpl_future_syms = sechdrs[gplfutureindex].sh_size /<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;gpl_future_syms);<br> &nbsp;&nbsp;&nbsp; mod-&gt;gpl_future_syms = (void *)sechdrs[gplfutureindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; if (gplfuturecrcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;gpl_future_crcs = (void *)sechdrs[gplfuturecrcindex].sh_addr;<br><br> #ifdef CONFIG_UNUSED_SYMBOLS<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_unused_syms = sechdrs[unusedindex].sh_size /<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;unused_syms);<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_unused_gpl_syms = sechdrs[unusedgplindex].sh_size /<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sizeof(*mod-&gt;unused_gpl_syms);<br> &nbsp;&nbsp;&nbsp; mod-&gt;unused_syms = (void *)sechdrs[unusedindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; if (unusedcrcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;unused_crcs = (void *)sechdrs[unusedcrcindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; mod-&gt;unused_gpl_syms = (void *)sechdrs[unusedgplindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; if (unusedgplcrcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;unused_gpl_crcs<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; = (void *)sechdrs[unusedgplcrcindex].sh_addr;<br> #endif<br><br> #ifdef CONFIG_MODVERSIONS<br> &nbsp;&nbsp;&nbsp; if ((mod-&gt;num_syms &amp;&amp; !crcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || (mod-&gt;num_gpl_syms &amp;&amp; !gplcrcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || (mod-&gt;num_gpl_future_syms &amp;&amp; !gplfuturecrcindex)<br> #ifdef CONFIG_UNUSED_SYMBOLS<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || (mod-&gt;num_unused_syms &amp;&amp; !unusedcrcindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; || (mod-&gt;num_unused_gpl_syms &amp;&amp; !unusedgplcrcindex)<br> #endif<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printk(KERN_WARNING "%s: No versions for exported symbols.\n", mod-&gt;name);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = try_to_force_load(mod, "nocrc");<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (err)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto cleanup;<br> &nbsp;&nbsp;&nbsp; }<br> #endif<br> &nbsp;&nbsp;&nbsp; markersindex = find_sec(hdr, sechdrs, secstrings, "__markers");<br> &nbsp;&nbsp;&nbsp;&nbsp; markersstringsindex = find_sec(hdr, sechdrs, secstrings,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "__markers_strings");<br><br> &nbsp;&nbsp;&nbsp; /* Now do relocations. */<br> &nbsp;&nbsp;&nbsp; for (i = 1; i &lt; hdr-&gt;e_shnum; i++) {<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; const char *strtab = (char *)sechdrs[strindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; unsigned int info = sechdrs[i].sh_info;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Not a valid relocation section? */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (info &gt;= hdr-&gt;e_shnum)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* Don't bother with non-allocated sections */<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!(sechdrs[info].sh_flags &amp; SHF_ALLOC))<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br><br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (sechdrs[i].sh_type == SHT_REL) //relocations section<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = apply_relocate(sechdrs, strtab, symindex, i,mod);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (sechdrs[i].sh_type == SHT_RELA) //包含重定位表项，有补全的内容<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; err = apply_relocate_add(sechdrs, strtab, symindex, i,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mod);<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto cleanup;<br> &nbsp;&nbsp;&nbsp; }<br> #ifdef CONFIG_MARKERS<br> &nbsp;&nbsp;&nbsp; mod-&gt;markers = (void *)sechdrs[markersindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_markers =<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[markersindex].sh_size / sizeof(*mod-&gt;markers);<br> #endif<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Find duplicate symbols */<br> &nbsp;&nbsp;&nbsp; err = verify_export_symbols(mod);<br><br> &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto cleanup;<br><br> &nbsp; &nbsp;&nbsp;&nbsp; /* Set up and sort exception table */&nbsp;&nbsp; //什么是exception table ??? 是指系统异常处理的那个异常表&nbsp;<br> &nbsp;&nbsp;&nbsp; mod-&gt;num_exentries = sechdrs[exindex].sh_size / sizeof(*mod-&gt;extable);<br> &nbsp;&nbsp;&nbsp; mod-&gt;extable = extable = (void *)sechdrs[exindex].sh_addr;<br> &nbsp;&nbsp;&nbsp; sort_extable(extable, extable + mod-&gt;num_exentries);<br><br> &nbsp;&nbsp;&nbsp; /* Finally, copy percpu area over. */<br> &nbsp;&nbsp;&nbsp; percpu_modcopy(mod-&gt;percpu, (void *)sechdrs[pcpuindex].sh_addr,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sechdrs[pcpuindex].sh_size);<br><br> &nbsp;&nbsp;&nbsp; add_kallsyms(mod, sechdrs, symindex, strindex, secstrings);<br><br> #ifdef CONFIG_MARKERS<br> &nbsp;&nbsp;&nbsp; if (!mod-&gt;taints)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; marker_update_probe_range(mod-&gt;markers,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mod-&gt;markers + mod-&gt;num_markers);<br> #endif<br> &nbsp;&nbsp;&nbsp; err = module_finalize(hdr, sechdrs, mod);<br> &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto cleanup;<br><br> &nbsp;&nbsp;&nbsp; /* flush the icache in correct context */<br> &nbsp;&nbsp;&nbsp; old_fs = get_fs(); //get current_thread_info addr_limits<br> &nbsp;&nbsp;&nbsp; set_fs(KERNEL_DS);<br><br> &nbsp;&nbsp;&nbsp; /*<br> &nbsp;&nbsp;&nbsp; &nbsp;* Flush the instruction cache, since we've played with text.<br> &nbsp;&nbsp;&nbsp; &nbsp;* Do it before processing of module parameters, so the module<br> &nbsp;&nbsp;&nbsp; &nbsp;* can provide parameter accessor functions of its own.<br> &nbsp;&nbsp;&nbsp; &nbsp;*/<br> &nbsp;&nbsp;&nbsp; if (mod-&gt;module_init)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; flush_icache_range((unsigned long)mod-&gt;module_init,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (unsigned long)mod-&gt;module_init<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; + mod-&gt;init_size); //刷cache，将这个范围内的刷掉。<br> &nbsp;&nbsp;&nbsp; flush_icache_range((unsigned long)mod-&gt;module_core,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; (unsigned long)mod-&gt;module_core + mod-&gt;core_size);<br><br> &nbsp;&nbsp;&nbsp; set_fs(old_fs);<br><br> &nbsp;&nbsp;&nbsp; mod-&gt;args = args;<br> &nbsp;&nbsp;&nbsp; if (obsparmindex)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printk(KERN_WARNING "%s: Ignoring obsolete parameters\n",<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod-&gt;name);<br><br> &nbsp;&nbsp;&nbsp; /* Now sew it into the lists so we can get lockdep and oops<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * info during argument parsing.&nbsp; Noone should access us, since<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * strong_try_module_get() will fail. */<br> &nbsp;&nbsp;&nbsp; stop_machine(__link_module, mod, NULL); //干什么呢?<br><br> &nbsp;&nbsp;&nbsp; /* Size of section 0 is 0, so this works well if no params */<br> &nbsp;&nbsp;&nbsp; err = parse_args(mod-&gt;name, mod-&gt;args,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;(struct kernel_param *)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sechdrs[setupindex].sh_addr,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sechdrs[setupindex].sh_size<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/ sizeof(struct kernel_param),<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NULL);<br> &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto unlink;<br><br> &nbsp;&nbsp;&nbsp; err = mod_sysfs_setup(mod,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (struct kernel_param *)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sechdrs[setupindex].sh_addr,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sechdrs[setupindex].sh_size<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / sizeof(struct kernel_param));<br> &nbsp;&nbsp;&nbsp; if (err &lt; 0)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; goto unlink;<br> &nbsp;&nbsp;&nbsp; add_sect_attrs(mod, hdr-&gt;e_shnum, secstrings, sechdrs);<br> &nbsp;&nbsp;&nbsp; add_notes_attrs(mod, hdr-&gt;e_shnum, secstrings, sechdrs);<br><br> &nbsp;&nbsp;&nbsp; /* Size of section 0 is 0, so this works well if no unwind info. */<br> &nbsp;&nbsp;&nbsp; mod-&gt;unwind_info = unwind_add_table(mod,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (void *)sechdrs[unwindex].sh_addr,<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sechdrs[unwindex].sh_size);<br><br> &nbsp;&nbsp;&nbsp; /* Get rid of temporary copy */<br> &nbsp;&nbsp;&nbsp; vfree(hdr); //释放临时copy<br><br> &nbsp;&nbsp;&nbsp; /* Done! */<br> &nbsp;&nbsp;&nbsp; return mod;<br><br> &nbsp;unlink:<br> &nbsp;&nbsp;&nbsp; stop_machine(__unlink_module, mod, NULL);<br> &nbsp;&nbsp;&nbsp; module_arch_cleanup(mod);<br> &nbsp;cleanup:<br> &nbsp;&nbsp;&nbsp; kobject_del(&amp;mod-&gt;mkobj.kobj);<br> &nbsp;&nbsp;&nbsp; kobject_put(&amp;mod-&gt;mkobj.kobj);<br> &nbsp;free_unload:<br> &nbsp;&nbsp;&nbsp; module_unload_free(mod);<br> &nbsp;&nbsp;&nbsp; module_free(mod, mod-&gt;module_init);<br> &nbsp;free_core:<br> &nbsp;&nbsp;&nbsp; module_free(mod, mod-&gt;module_core);<br> &nbsp;free_percpu:<br> &nbsp;&nbsp;&nbsp; if (percpu)<br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; percpu_modfree(percpu);<br> &nbsp;free_mod:<br> &nbsp;&nbsp;&nbsp; kfree(args);<br> &nbsp;free_hdr:<br> &nbsp;&nbsp;&nbsp; vfree(hdr);<br> &nbsp;&nbsp;&nbsp; return ERR_PTR(err);<br><br> &nbsp;truncated:<br> &nbsp;&nbsp;&nbsp; printk(KERN_ERR "Module len %lu truncated\n", len);<br> &nbsp;&nbsp;&nbsp; err = -ENOEXEC;<br> &nbsp;&nbsp;&nbsp; goto free_hdr;<br> }</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p><font color="#666666"><span style="font-size:14px;"><br></span></font></p> 
   <p><font color="#666666"><span style="font-size:14px;">本文转自张昺华-sky博客园博客，原文链接：http://www.cnblogs.com/sky-heaven/p/5569240.html</span></font><span style="font-size:14px;color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';">，如需转载请自行联系原作者</span></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
