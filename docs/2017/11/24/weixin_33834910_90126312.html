<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>【原】iOS动态性(五)一种可复用且解耦的用户统计实现(运行时Runtime) « NotBeCN</title>
  <meta name="description" content="             用户行为统计(User Behavior Statistics, UBS)一直是移动互联网产品中必不可少的环节，也俗称埋点。在保证移动端流量不会受较大影响的前提下，PM们总是希望埋点覆盖面越广越好。目前常规的做法是将埋点代码封装成工具类，但凡工程中需要埋点(如点击事件、页面跳转)的地方都...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/24/weixin_33834910_90126312.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">【原】iOS动态性(五)一种可复用且解耦的用户统计实现(运行时Runtime)</h1>
    <p class="post-meta">Nov 24, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">用户行为统计(User Behavior Statistics, UBS)一直是移动互联网产品中必不可少的环节，也俗称埋点。在保证移动端流量不会受较大影响的前提下，PM们总是希望埋点覆盖面越广越好。目前常规的做法是将埋点代码封装成工具类，但凡工程中需要埋点(如点击事件、页面跳转)的地方都插入埋点代码。一旦项目越来越复杂，你会发现埋点的代码散落在程序的各个角落，不利于维护以及复用。本文旨在<strong>探讨</strong>利用iOS的运行时机制实现一种可复、解耦、容易维护的用户统计方案。探讨毕竟是探讨，欢迎到留言讨论。本文虽有些长却是用心之作，希望你有耐心看完。</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">注：本文需要一些iOS的Runtime基础</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">该方案的完成将会用到以下知识：</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <ul>
     <li style="list-style:disc;">Method Swizzling(Hook)</li> 
     <li style="list-style:disc;">单元测试</li> 
    </ul>
   </blockquote> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;">一、常规埋点做法</h2> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">接着开头的话题，我们先回顾一下主流的埋点是怎么做的。我粗糙地将埋点分为两种：1、页面统计，包括页面停留时间、页面进入次数；2、交互事件统计，包括单击、双击、手势交互等。</p> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;">1)常规页面统计埋点</h4> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">以统计页面进入次数为例，最简单粗暴的做法是在所有页面的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">viewDidAppear:</code>以及<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">viewDidDisappear:</code>中分别埋点，将自己对应的pageID上传给服务端。代码大概长酱紫：</p> 
   <pre><code class="hljs groovy" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">@implementation</span> HomeViewController
<span class="hljs-comment" style="color:#008000;">//...other methods</span>
- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)<span class="hljs-string" style="color:rgb(163,21,21);">viewDidAppear:</span>(BOOL)animated
{
    [<span class="hljs-keyword" style="color:rgb(0,0,255);">super</span> <span class="hljs-string" style="color:rgb(163,21,21);">viewWillAppear:</span>animated];
    [WUserStatistics <span class="hljs-string" style="color:rgb(163,21,21);">sendEventToServer:</span>@<span class="hljs-string" style="color:rgb(163,21,21);">"PAGE_EVENT_HOME_ENTER"</span>];
}

- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)<span class="hljs-string" style="color:rgb(163,21,21);">viewDidDisappear:</span>(BOOL)animated
{
    [<span class="hljs-keyword" style="color:rgb(0,0,255);">super</span> <span class="hljs-string" style="color:rgb(163,21,21);">viewDidDisappear:</span>animated];
    [WUserStatistics <span class="hljs-string" style="color:rgb(163,21,21);">sendEventToServer:</span>@<span class="hljs-string" style="color:rgb(163,21,21);">"PAGE_EVENT_HOME_LEAVE"</span>];
}
<span class="hljs-meta" style="color:rgb(43,145,175);">@end</span></code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">+[WUserStatistics sendEventToServer:]</code>封装网络请求，将ID上传给服务器。上述方案有以下弊端：</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">1、复用性差。这部分埋点代码很难给其他项目复用<br> 2、工作量大。尤其当页面较多时，需要修改的代码较多<br> 3、引入“脏代码”，不易维护</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">第3点提到的“脏代码”意思是用户行为分析这种业务其实跟主业务没太大关系，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">不应该保持如此高的耦合度</code>，因为这些代码会干扰我们对项目主业务的维护。这个我个人看法。</p> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;">2)常规交互事件埋点</h4> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">常规做法一般在交互事件的selector中获取该事件的ID并上传给服务端，代码大概长酱紫：</p> 
   <pre><code class="hljs objectivec" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">- (<span class="hljs-keyword" style="color:rgb(0,0,255);">IBAction</span>)onFavBtnPressed:(<span class="hljs-keyword" style="color:rgb(0,0,255);">id</span>)sender
{
    [WUserStatistics sendEventToServer:<span class="hljs-string" style="color:rgb(163,21,21);">@"CTRL_EVENT_HOME_FAV"</span>];
    <span class="hljs-comment" style="color:#008000;">//...do other things</span>
}
</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">稍微大一点的APP如果采用这种方式，那诸如此类的埋点代码将遍地都是。它的缺点参考页面统计埋点部分，其复用性基本为零，也就是在新项目中根本无法复用埋点代码。</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">小总结一下，采用常规的做法虽然直观方便，但在<strong>可复用性、可维护性</strong>等方面有所欠缺。在我看来，借助运行时可以很好地避开这些缺点。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;">二、Method Swizzling、Hook与代码注入</h2> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">由于Runtime知识不属于本文的重点，这里只简单介绍。<br> 在iOS中，我们可以在运行时替换两个方法的实现，达到“勾住”某个方法并注入代码的目的。具体做法是:</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">重载类的“+(void)load”方法，在程序加载到内存时利用Runtime的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">method_exchangeImplementations</code>等接口将方法(设为M)的实现互相交换。当方法M被调用时就会被勾住(Hook)，执行我们的方法。</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">这种技术也称为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">Method Swizzling</code>，属于面向切面编程(Aspect-Oriented Programming)的一种实现。</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">替换两个方法的实现，代码一般长酱紫：</p> 
   <pre><code class="hljs java" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);"><span class="hljs-meta" style="color:rgb(43,145,175);">@interface</span> WHookUtility : NSObject
+ (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)swizzlingInClass:(Class)cls originalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;
<span class="hljs-meta" style="color:rgb(43,145,175);">@end</span>

<span class="hljs-meta" style="color:rgb(43,145,175);">@implementation</span> WHookUtility

+ (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)swizzlingInClass:(Class)cls originalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector
{
    Class <span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span> </span>= cls;
    Method originalMethod = class_getInstanceMethod(<span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span>, <span class="hljs-title" style="color:rgb(163,21,21);">originalSelector</span>)</span>;
    Method swizzledMethod = class_getInstanceMethod(<span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span>, <span class="hljs-title" style="color:rgb(163,21,21);">swizzledSelector</span>)</span>;
    
    BOOL didAddMethod =
    class_addMethod(<span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span>, <span class="hljs-title" style="color:rgb(163,21,21);">originalSelector</span>, <span class="hljs-title" style="color:rgb(163,21,21);">method_getImplementation</span>(<span class="hljs-title" style="color:rgb(163,21,21);">swizzledMethod</span>), <span class="hljs-title" style="color:rgb(163,21,21);">method_getTypeEncoding</span>(<span class="hljs-title" style="color:rgb(163,21,21);">swizzledMethod</span>))</span>;
    
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> (didAddMethod) {
        class_replaceMethod(<span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">class</span>, <span class="hljs-title" style="color:rgb(163,21,21);">swizzledSelector</span>, <span class="hljs-title" style="color:rgb(163,21,21);">method_getImplementation</span>(<span class="hljs-title" style="color:rgb(163,21,21);">originalMethod</span>), <span class="hljs-title" style="color:rgb(163,21,21);">method_getTypeEncoding</span>(<span class="hljs-title" style="color:rgb(163,21,21);">originalMethod</span>))</span>;
    } <span class="hljs-keyword" style="color:rgb(0,0,255);">else</span> {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}
<span class="hljs-meta" style="color:rgb(43,145,175);">@end</span>
</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">这个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">WHookUtility</code>工具类下文会用到。比如现在我们要勾住<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">UIViewController</code>的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">viewWillAppear:</code>方法，可以这样做：</p> 
   <pre><code class="hljs objectivec" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);"><span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">@implementation</span> <span class="hljs-title" style="color:rgb(163,21,21);">UIViewController</span> (<span class="hljs-title" style="color:rgb(163,21,21);">userStastistics</span>)</span>
+ (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)load {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-built_in" style="color:rgb(0,0,255);">dispatch_once_t</span> onceToken;
    <span class="hljs-built_in" style="color:rgb(0,0,255);">dispatch_once</span>(&amp;onceToken, ^{
        SEL originalSelector = <span class="hljs-keyword" style="color:rgb(0,0,255);">@selector</span>(viewWillAppear:);
        SEL swizzledSelector = <span class="hljs-keyword" style="color:rgb(0,0,255);">@selector</span>(swiz_viewWillAppear:);
        [WHookUtility swizzlingInClass:[<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> class] originalSelector:originalSelector swizzledSelector:swizzledSelector];
    });
}
<span class="hljs-meta" style="color:rgb(43,145,175);">#pragma mark - Method Swizzling</span>
- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)swiz_viewWillAppear:(<span class="hljs-built_in" style="color:rgb(0,0,255);">BOOL</span>)animated
{
    <span class="hljs-comment" style="color:#008000;">//插入需要执行的代码</span>
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSLog</span>(<span class="hljs-string" style="color:rgb(163,21,21);">@"我在viewWillAppear执行前偷偷插入了一段代码"</span>);
    <span class="hljs-comment" style="color:#008000;">//不能干扰原来的代码流程，插入代码结束后要让本来该执行的代码继续执行</span>
    [<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> swiz_viewWillAppear:animated];
}
<span class="hljs-keyword" style="color:rgb(0,0,255);">@end</span>
</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">更多关于Runtime、method swizzling、面向切面编程的介绍请参考<a href="http://www.cnblogs.com/wengzilin/p/4704996.html" rel="nofollow" style="color:rgb(68,68,68);">这里</a></p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;">三、基于运行时的埋点方案</h2> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">为了便于下文叙述，先引入一个简单的项目，共有两个页面(<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">HomeViewController</code>，<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">DetailViewController</code>)，如下：<br><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093212410-1874081902.gif" style="border:0px;" alt="374539-20160412093212410-1874081902.gif"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">需求是</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <ol>
     <li style="list-style:decimal;">统计两个页面的展示与离开次数</li> 
     <li style="list-style:decimal;">统计收藏、分享单击事件的次数</li> 
     <li style="list-style:decimal;"><strong>对现有工程代码影响越小越好</strong></li> 
    </ol>
   </blockquote> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;">1)统计两个页面的展示与离开次数</h4> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">这部分应该比较直观了，摒弃掉在每个controller中埋点的方式，我们对UIViewController添加category从而Hook到<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">viewWillAppear:</code>与<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">viewWillDisappear:</code>。在这两个方法中注入埋点代码：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093346191-1292494582.jpg" style="border:0px;" alt="374539-20160412093346191-1292494582.jpg"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">这时候问题来了，项目中每个页面都会有自己的页面事件编号(pageEventID)，此处的埋点代码如何知道要发送什么pageEventID给服务端呢？轻松祭出<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">if-else</code>神器：</p> 
   <pre><code class="hljs objectivec" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">- (<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *)pageEventID:(<span class="hljs-built_in" style="color:rgb(0,0,255);">BOOL</span>)bEnterPage
{
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *selfClassName = <span class="hljs-built_in" style="color:rgb(0,0,255);">NSStringFromClass</span>([<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> class]);
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *pageEventID = <span class="hljs-literal" style="color:rgb(163,21,21);">nil</span>;
    <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> ([selfClassName isEqualToString:<span class="hljs-string" style="color:rgb(163,21,21);">@"HomeViewController"</span>]) {
        pageEventID = bEnterPage ? <span class="hljs-string" style="color:rgb(163,21,21);">@"EVENT_HOME_ENTER_PAGE"</span> : <span class="hljs-string" style="color:rgb(163,21,21);">@"EVENT_HOME_LEAVE_PAGE"</span>;
    } <span class="hljs-keyword" style="color:rgb(0,0,255);">else</span> <span class="hljs-keyword" style="color:rgb(0,0,255);">if</span> ([selfClassName isEqualToString:<span class="hljs-string" style="color:rgb(163,21,21);">@"DetailViewController"</span>]) {
        pageEventID = bEnterPage ? <span class="hljs-string" style="color:rgb(163,21,21);">@"EVENT_DETAIL_ENTER_PAGE"</span> : <span class="hljs-string" style="color:rgb(163,21,21);">@"EVENT_DETAIL_LEAVE_PAGE"</span>;
    }
    <span class="hljs-comment" style="color:#008000;">//else if (&lt;#expression#&gt;)...</span>
}</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">当然，我们可以有更优雅的方式，比如用一个配置表替代上面一长串的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">if</code>判断，这样无论页面数怎么增加，代码始终是那么一小段。我们新建一个<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">WGlobalUserStatisticsConfig.plist</code>的配置表来存放每个页面在进入以及离开时的pageEventID，结构如下：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093412066-1210835541.png" style="border:0px;" alt="374539-20160412093412066-1210835541.png"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">因此，页面进出统计中获取pageEventID的代码始终是以下这几句：</p> 
   <pre><code class="hljs objectivec" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">- (<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *)pageEventID:(<span class="hljs-built_in" style="color:rgb(0,0,255);">BOOL</span>)bEnterPage
{
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *configDict = [<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> dictionaryFromUserStatisticsConfigPlist];
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *selfClassName = <span class="hljs-built_in" style="color:rgb(0,0,255);">NSStringFromClass</span>([<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> class]);
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> configDict[selfClassName][<span class="hljs-string" style="color:rgb(163,21,21);">@"PageEventIDs"</span>][bEnterPage ? <span class="hljs-string" style="color:rgb(163,21,21);">@"Enter"</span> : <span class="hljs-string" style="color:rgb(163,21,21);">@"Leave"</span>];
}

- (<span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *)dictionaryFromUserStatisticsConfigPlist
{
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *filePath = [[<span class="hljs-built_in" style="color:rgb(0,0,255);">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string" style="color:rgb(163,21,21);">@"WGlobalUserStatisticsConfig"</span> ofType:<span class="hljs-string" style="color:rgb(163,21,21);">@"plist"</span>];
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *dic = [<span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> dictionaryWithContentsOfFile:filePath];
    <span class="hljs-keyword" style="color:rgb(0,0,255);">return</span> dic;
}</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">效果如下：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093447723-1563067760.gif" style="border:0px;" alt="374539-20160412093447723-1563067760.gif"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">以上就是完成了页面进出统计的埋点，并且达到了我们的第三点预期：对现有代码基本无影响。<strong>通过Method Swizzling的方式现有的工程甚至不需要<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">import</code>任何文件！</strong>后期代码变动时需要维护的仅仅是plist配置表。</p> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;">2)统计收藏、分享单击事件的次数</h4> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">与上一节思路一致，要做到解耦显然需要通过category+hook来实现。本文demo中收藏跟分享都是UIButton类型，可以考虑添加UIButton的catogory。但更好的方式是添加UIControl的category，这样可以让埋点代码覆盖到所有UIControl的子类中去，比如button、switch、segment等，提高复用性。<br> 既然要hook，那就要清楚到底要hook<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">UIControl</code>的哪(几)个方法，只有部分方法是满足埋点需求的，最好是所hook的方法能提供target、actionName等信息。这是个尝试的过程。<br><code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">UIControl</code>的方法列表有以下：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093510254-944695206.png" style="border:0px;" alt="374539-20160412093510254-944695206.png"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">通过观察方法名和参数，我们有理由怀疑是倒数第二个，因其携带了不少貌似有价值的信息：</p> 
   <pre><code class="hljs groovy" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)<span class="hljs-string" style="color:rgb(163,21,21);">sendAction:</span>(SEL)action <span class="hljs-string" style="color:rgb(163,21,21);">to:</span>(nullable id)target <span class="hljs-string" style="color:rgb(163,21,21);">forEvent:</span>(nullable UIEvent *)event;</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">于是写出测试代码看看：</p> 
   <pre><code class="hljs objectivec" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);"><span class="hljs-class"><span class="hljs-keyword" style="color:rgb(0,0,255);">@implementation</span> <span class="hljs-title" style="color:rgb(163,21,21);">UIControl</span> (<span class="hljs-title" style="color:rgb(163,21,21);">userStastistics</span>)</span>

+ (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)load {
    <span class="hljs-keyword" style="color:rgb(0,0,255);">static</span> <span class="hljs-built_in" style="color:rgb(0,0,255);">dispatch_once_t</span> onceToken;
    <span class="hljs-built_in" style="color:rgb(0,0,255);">dispatch_once</span>(&amp;onceToken, ^{
        SEL originalSelector = <span class="hljs-keyword" style="color:rgb(0,0,255);">@selector</span>(sendAction:to:forEvent:);
        SEL swizzledSelector = <span class="hljs-keyword" style="color:rgb(0,0,255);">@selector</span>(swiz_sendAction:to:forEvent:);
        [WHookUtility swizzlingInClass:[<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> class] originalSelector:originalSelector swizzledSelector:swizzledSelector];
    });
}

<span class="hljs-meta" style="color:rgb(43,145,175);">#pragma mark - Method Swizzling</span>
- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)swiz_sendAction:(SEL)action to:(<span class="hljs-keyword" style="color:rgb(0,0,255);">id</span>)target forEvent:(<span class="hljs-built_in" style="color:rgb(0,0,255);">UIEvent</span> *)event;
{
    <span class="hljs-comment" style="color:#008000;">//插入埋点代码</span>
    [<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> performUserStastisticsAction:action to:target forEvent:event];
    [<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> swiz_sendAction:action to:target forEvent:event];
}

- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)performUserStastisticsAction:(SEL)action to:(<span class="hljs-keyword" style="color:rgb(0,0,255);">id</span>)target forEvent:(<span class="hljs-built_in" style="color:rgb(0,0,255);">UIEvent</span> *)event;
{
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSLog</span>(<span class="hljs-string" style="color:rgb(163,21,21);">@"\n***hook success.\n[1]action:%@\n[2]target:%@ \n[3]event:%ld"</span>, <span class="hljs-built_in" style="color:rgb(0,0,255);">NSStringFromSelector</span>(action), target, (<span class="hljs-keyword" style="color:rgb(0,0,255);">long</span>)event);
}
<span class="hljs-keyword" style="color:rgb(0,0,255);">@end</span></code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">Log如下图：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093538973-1248387457.png" style="border:0px;" alt="374539-20160412093538973-1248387457.png"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">可以看到，通过category+method swizzling的方式在没有修改现有工程任何代码的情况下已经成功Hook到所有点击事件，在Hook代码中我们知道了一个点击事件的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">target</code>也就是ViewController，也知道了点击事件的响应函数名，知道了点击的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">TouchSet</code>。这些信息已经能满足埋点需求了。<br> 与页面统计埋点类似，我们同样采用plist配置表的方式避免一大长串的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">if-else</code>判断：<br><img src="http://upload-images.jianshu.io/upload_images/1053533-356fd87dcfb9c865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单击事件配置表结构.png" style="border:0px;"><br> 有了这张配置表就很容易得到某次单击事件的事件ID(ControlEventID)：</p> 
   <pre><code class="hljs markdown" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">NSString *actionString = NSStringFromSelector(action);//获取SEL string
NSString *targetName = NSStringFromClass([target class]);//viewController name
NSDictionary *configDict = [self dictionaryFromUserStatisticsConfigPlist];
eventID = configDict[<span class="hljs-string" style="color:rgb(163,21,21);">targetName</span>][<span class="hljs-symbol" style="color:rgb(0,176,232);">@"ControlEventIDs"</span>][<span class="hljs-string" style="color:rgb(163,21,21);">actionString</span>];</code></pre> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">事实上，我把某个页面单元的所有事件ID分成了两类：<strong>页面事件ID</strong>(PageEventIDs，页面的进出等)、<strong>交互事件ID</strong>(ControlEventIDs，单击、双击、手势等)。分类有助于下文使用单元测试(Unit Test)进行自动化后期维护。</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">埋点效果如图：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093602223-341717525.gif" style="border:0px;" alt="374539-20160412093602223-341717525.gif"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">到这里先做了阶段性的总结，本文提出的思路有以下优越性：</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <ul>
     <li style="list-style:disc;">与工程代码基本解耦，避免引入“脏代码”</li> 
     <li style="list-style:disc;">即使后期工程代码发生重构，需要修改的仅仅是plist配置表</li> 
     <li style="list-style:disc;">维护配置表比维护散落在工程各个角落的代码简单</li> 
    </ul>
   </blockquote> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;">四、基于单元测试的后期维护</h2> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">俗话说，创业难守业更难。前面的思路基本可以完成初步的埋点需求。但是在实际项目中代码重构是很频繁的。这意味着在多人协作开发、代码重构频繁的项目中响应事件方法甚至页面名称都可能被改掉，造成事件ID获取不到导致埋点失效。<br> 代码变动的情况无非以下几种(这里只介绍响应事件发生改变的情况)：</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">1、响应事件方法名称改变或者删除</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">比如收藏事件原先是<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">onFavBtnPressed:</code>，之后被改成<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">onFavouriteBtnPressed:</code>。代码发生变动但是plist配置表中由于开发人员疏忽忘记同步修改了。这种疏忽在开发压力大进度赶的情况下是有很大概率发生的。由于代码与配置表不匹配将导致eventID为nil。在这种情况下单元测试就很有必要了，使用完备的测试用例能在发版前检测到这种不匹配情况从而避免埋点失效。<br> 在单元测试中我们首先读取plist配置文件，遍历所有的页面。在一个页面内遍历所有的ControlEventIDs，对每个响应函数名进行<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">respondsToSelector:</code>判断：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093619988-1899799096.png" style="border:0px;" alt="374539-20160412093619988-1899799096.png"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">单测代码如下：</p> 
   <pre><code class="hljs objectivec" style="vertical-align:middle;color:rgb(0,0,0);line-height:1.5;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">- (<span class="hljs-keyword" style="color:rgb(0,0,255);">void</span>)testIfUserStatisticsConfigPlistValid
{
    <span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *configDict = [<span class="hljs-keyword" style="color:rgb(0,0,255);">self</span> dictionaryFromUserStatisticsConfigPlist];
    <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssertNotNil</span>(configDict, <span class="hljs-string" style="color:rgb(163,21,21);">@"WGlobalUserStatisticsConfig.plist加载失败"</span>);
    
    [configDict enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *  _Nonnull key, <span class="hljs-keyword" style="color:rgb(0,0,255);">id</span>  _Nonnull obj, <span class="hljs-built_in" style="color:rgb(0,0,255);">BOOL</span> * _Nonnull stop) {
        <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssert</span>([obj isKindOfClass:[<span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> class]], <span class="hljs-string" style="color:rgb(163,21,21);">@"plist文件结构可能已经改变，请确认"</span>);
        <span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *targetPageName = key;
        Class pageClass = <span class="hljs-built_in" style="color:rgb(0,0,255);">NSClassFromString</span>(targetPageName);
        <span class="hljs-keyword" style="color:rgb(0,0,255);">id</span> pageInstance = [[pageClass alloc] init];
        
        <span class="hljs-comment" style="color:#008000;">//一个pageDict对应一个页面，存放pageID,所有的action及对应的eventID</span>
        <span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *pageDict = (<span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *)obj;
        
        <span class="hljs-comment" style="color:#008000;">//页面配置信息</span>
        <span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *pageEventIDDict = pageDict[<span class="hljs-string" style="color:rgb(163,21,21);">@"PageEventIDs"</span>];
        
        <span class="hljs-comment" style="color:#008000;">//交互配置信息</span>
        <span class="hljs-built_in" style="color:rgb(0,0,255);">NSDictionary</span> *controlEventIDDict = pageDict[<span class="hljs-string" style="color:rgb(163,21,21);">@"ControlEventIDs"</span>];
        
        <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssert</span>(pageEventIDDict, <span class="hljs-string" style="color:rgb(163,21,21);">@"plist文件未包含PageID字段或者该字段值为空"</span>);
        <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssert</span>(controlEventIDDict, <span class="hljs-string" style="color:rgb(163,21,21);">@"plist文件未包含EventIDs字段或者该字段值为空"</span>);
        
        [pageEventIDDict enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *  _Nonnull key, <span class="hljs-keyword" style="color:rgb(0,0,255);">id</span>  _Nonnull value, <span class="hljs-built_in" style="color:rgb(0,0,255);">BOOL</span> * _Nonnull stop) {
            <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssert</span>([value isKindOfClass:[<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> class]], <span class="hljs-string" style="color:rgb(163,21,21);">@"plist文件结构可能已经改变，请确认"</span>);
            <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssertNotNil</span>(value, <span class="hljs-string" style="color:rgb(163,21,21);">@"EVENT_ID为空，请确认"</span>);
        }];
        
        [controlEventIDDict enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *  _Nonnull key, <span class="hljs-keyword" style="color:rgb(0,0,255);">id</span>  _Nonnull value, <span class="hljs-built_in" style="color:rgb(0,0,255);">BOOL</span> * _Nonnull stop) {
            <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssert</span>([value isKindOfClass:[<span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> class]], <span class="hljs-string" style="color:rgb(163,21,21);">@"plist文件结构可能已经改变，请确认"</span>);
            <span class="hljs-built_in" style="color:rgb(0,0,255);">NSString</span> *actionName = key;
            SEL actionSel = <span class="hljs-built_in" style="color:rgb(0,0,255);">NSSelectorFromString</span>(actionName);
            <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssert</span>([pageInstance respondsToSelector:actionSel], <span class="hljs-string" style="color:rgb(163,21,21);">@"代码与plist文件函数不匹配，请确认：-[%@ %@]"</span>, targetPageName, actionName);
            
            <span class="hljs-comment" style="color:#008000;">//EVENT_ID不能为空</span>
            <span class="hljs-built_in" style="color:rgb(0,0,255);">XCTAssertNotNil</span>(value, <span class="hljs-string" style="color:rgb(163,21,21);">@"EVENT_ID为空，请确认"</span>);
        }];
    }];
    
}</code></pre> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">我们来测试一下，如果把<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">HomeViewController</code>的<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">onFavBtnPressed:</code>改成<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">onMyFavBtnPressed:</code>后单元测试的结果就是：</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/374539/201604/374539-20160412093636582-1499213224.png" style="border:0px;" alt="374539-20160412093636582-1499213224.png"></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">这种改变给单测轻松捕捉到了，</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">只要XCTAssert的log够详细，维护起来其实相当轻松的。</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">上图中的log已经明确指出<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">-[HomeViewController onFavBtnPressed:]</code>方法发生了改变。</p> 
   <blockquote style="background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <p style="line-height:1.5;">2、代码中新增了响应事件</p> 
   </blockquote> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">这种情况常见于新版本中有新的埋点需求。如果代码中新增了响应事件并且该响应事件是在PM要求的埋点列表中，但是plist有可能会漏掉该事件。这种情况是比较棘手的。上一种情况是基于plist列表去校验代码，这里就要反过来，根据代码去校验plist是否有缺失。但问题来了，一个项目中响应函数往往是非常多的，并不是任何响应函数都需要埋点。需要埋点的响应函数与其他响应函数并没有区别。<br> 对于这种情况，一种方式是加强code review避免忘记往配置表中添加埋点(这简直就是废话)；一种是：要求埋点响应函数的方法名中包含约定的字符串，比如收藏事件的方法名为<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">onFavBtnPressed_UA:</code>表示这个事件是需要埋点的。然后在单元测试中使用运行时API<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">class_copyMethodList</code>取出标记了<code style="line-height:1.8;vertical-align:middle;font-family:'Courier New', sans-serif;border:1px solid rgb(204,204,204);">_UA</code>的所有函数，随后到plist中校验是否存在。不存在则表示测试用例不通过，提示开发人员校验。</p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">代码略。如果对单元测试不熟悉，可以参考<a href="http://www.jianshu.com/p/8bbec078cabe" rel="nofollow" style="color:rgb(68,68,68);">单元测试</a></p> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">小总结：<br> 合理的单元测试可以为本文方案的后期维护减轻相当大的负担，测试用例的完备性很重要，需要用心设计考虑周全。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;">五、结语</h2> 
   <p style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;line-height:1.5;">以上就是结合运行时所设计出的用户统计思路全部内容。应该说该方案的可复用性与解耦程度都是不错的，既适合于新建的工程，也适合于已经创建的工程。利用Method Swizzling把埋点代码集中管理其实也是合理的，有利于专人开发、跟踪及维护。当然以上思路只考虑简单的情形，更复杂的情况就需要变通了，但总体思路就是如此。</p> 
   <p style="line-height:1.5;"><font color="#444444"><span style="font-size:12px;">本文转自编程小翁博客园博客，原文链接：http://www.cnblogs.com/wengzilin/p/5381377.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
