<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>MFC 常用控件 « NotBeCN</title>
  <meta name="description" content="                                &nbsp; &nbsp; 在MFC窗体控件中，常用的有Button、Static Box、Edit Box、Scroll Bar、Tree Ctrl、List Ctrl、Tab Ctrl等。通常在访问这些控件的时候，要先在建立类向导中添加一个变量，...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/26/weixin_34122810_90125689.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">MFC 常用控件</h1>
    <p class="post-meta">Nov 26, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1></h1> 
   <div class="clear"></div> 
   <div class="postBody"> 
    <div class="blogpost-body"> 
     <p>&nbsp; &nbsp; 在MFC窗体控件中，常用的有Button、Static Box、Edit Box、Scroll Bar、Tree Ctrl、List Ctrl、Tab Ctrl等。通常在访问这些控件的时候，要先在建立类向导中添加一个变量，这个变量就是这个控件。类型为CTRL，值为该控件。</p> 
     <p> 然后就可以方便的访问这些控件了。</p> 
     <p> </p> 
     <p>这里有一篇不错的文章：</p> 
     <p>4.1 Button</p> 
     <p>按钮窗口（控件）在MFC中使用CButton表示，CButton包含了三种样式的按钮，Push Button，Check Box，Radio Box。所以在利用CButton对象生成按钮窗口时需要指明按钮的风格。</p> 
     <p>创建按钮：BOOL CButton::Create( LPCTSTR lpszCaption, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );其中lpszCaption是按钮上显示的文字，dwStyle为按钮风格，除了Windows风格可以使用外（如 WS_CHILD|WS_VISUBLE|WS_BORDER）还有按钮专用的一些风格。</p> 
     <p>· BS_AUTOCHECKBOX 检查框，按钮的状态会自动改变 Same as a check box, except that a check mark appears in the check box when the user selects the box; the check mark disappears the next time the user selects the box.</p> 
     <p>· BS_AUTORADIOBUTTON 圆形选择按钮，按钮的状态会自动改变 Same as a radio button, except that when the user selects it, the button automatically highlights itself and removes the selection from any other radio buttons with the same style in the same group.</p> 
     <p>· BS_AUTO3STATE 允许按钮有三种状态即：选中，未选中，未定 Same as a three-state check box, except that the box changes its state when the user selects it.</p> 
     <p>· BS_CHECKBOX 检查框 Creates a small square that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style).</p> 
     <p>· BS_DEFPUSHBUTTON 默认普通按钮 Creates a button that has a heavy black border. The user can select this button by pressing the ENTER key. This style enables the user to quickly select the most likely option (the default option).</p> 
     <p>· BS_LEFTTEXT 左对齐文字 When combined with a radio-button or check-box style, the text appears on the left side of the radio button or check box.</p> 
     <p>· BS_OWNERDRAW 自绘按钮 Creates an owner-drawn button. The framework calls the DrawItem member function when a visual aspect of the button has changed. This style must be set when using the CBitmapButton class.</p> 
     <p>· BS_PUSHBUTTON 普通按钮 Creates a pushbutton that posts a WM_COMMAND message to the owner window when the user selects the button.</p> 
     <p>· BS_RADIOBUTTON 圆形选择按钮 Creates a small circle that has text displayed to its right (unless this style is combined with the BS_LEFTTEXT style). Radio buttons are usually used in groups of related but mutually exclusive choices.</p> 
     <p>· BS_3STATE 允许按钮有三种状态即：选中，未选中，未定 Same as a check box, except that the box can be dimmed as well as checked. The dimmed state typically is used to show that a check box has been disabled. </p> 
     <p>rect为窗口所占据的矩形区域，pParentWnd为父窗口指针，nID为该窗口的ID值。</p> 
     <p>获取/改变按钮状态：对于检查按钮和圆形按钮可能有两种状态，选中和未选中，如果设置了BS_3STATE或BS_AUTO3STATE风格就可能出现第三种状态：未定，这时按钮显示灰色。通过调用int CButton::GetCheck( ) 得到当前是否被选中，返回0：未选中，1：选中，2：未定。调用void CButton::SetCheck( int nCheck );设置当前选中状态。</p> 
     <p>处理按钮消息：要处理按钮消息需要在父窗口中进行消息映射，映射宏为ON_BN_CLICKED( id, memberFxn )id为按钮的ID值，就是创建时指定的nID值。处理函数原型为afx_msg void memberFxn( );</p> 
     <p>4.2 Static Box</p> 
     <p>静态文本控件的功能比较简单，可作为显示字符串，图标，位图用。创建一个窗口可以使用成员函数： <br> BOOL CStatic::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff ); <br> 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对静态控件指明专门的风格。</p> 
     <p>· SS_CENTER,SS_LEFT,SS_RIGHT 指明字符显示的对齐方式。</p> 
     <p>· SS_GRAYRECT 显示一个灰色的矩形</p> 
     <p>· SS_NOPREFIX 如果指明该风格，对于字符&amp;将直接显示，否则&amp;将作为转义符，&amp;将不显示而在其后的字符将有下划线，如果需要直接显示&amp;必须使用&amp;&amp;表示。</p> 
     <p>· SS_BITMAP 显示位图</p> 
     <p>· SS_ICON 显示图标</p> 
     <p>· SS_CENTERIMAGE 图象居中显示</p> 
     <p>控制显示的文本利用成员函数SetWindowText/GetWindowText用于设置/得到当前显示的文本。</p> 
     <p>控制显示的图标利用成员函数SetIcon/GetIcon用于设置/得到当前显示的图标。</p> 
     <p>控制显示的位图利用成员函数SetBitmap/GetBitmap用于设置/得到当前显示的位图。下面一段代码演示如何创建一个显示位图的静态窗口并设置位图</p> 
     <p>CStatic* pstaDis=new CStatic; pstaDis-&gt;Create("",WS_CHILD|WS_VISIBLE|SS_BITMAP|SSCENTERIMAGE, CRect(0,0,40,40),pWnd,1); CBitmap bmpLoad; bmpLoad.LoadBitmap(IDB_TEST); pstaDis-&gt;SetBitmap(bmpLoad.Detach()); </p> 
     <p>4.3 Edit Box</p> 
     <p>Edit窗口是用来接收用户输入最常用的一个控件。创建一个输入窗口可以使用成员函数： <br> BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff ); <br> 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对输入控件指明专门的风格。</p> 
     <p>· ES_AUTOHSCROLL,ES_AUTOVSCROLL 指明输入文字超出显示范围时自动滚动。</p> 
     <p>· ES_CENTER,ES_LEFT,ES_RIGHT 指定对齐方式</p> 
     <p>· ES_MULTILINE 是否允许多行输入</p> 
     <p>· ES_PASSWORD 是否为密码输入框，如果指明该风格则输入的文字显示为* </p> 
     <p>· ES_READONLY 是否为只读</p> 
     <p>· ES_UPPERCASE,ES_LOWERCASE 显示大写/小写字符</p> 
     <p>控制显示的文本利用成员函数SetWindowText/GetWindowText用于设置/得到当前显示的文本。</p> 
     <p>通过GetLimitText/SetLimitText可以得到/设置在输入框中输入的字符数量。</p> 
     <p>由于在输入时用户可能选择某一段文本，所以通过void CEdit::GetSel( int&amp; nStartChar, int&amp; nEndChar )得到用户选择的字符范围，通过调用void CEdit::SetSel( int nStartChar, int nEndChar, BOOL bNoScroll = FALSE )可以设置当前选择的文本范围，如果指定nStartChar=0 nEndChar=-1则表示选中所有的文本。void ReplaceSel( LPCTSTR lpszNewText, BOOL bCanUndo = FALSE )可以将选中的文本替换为指定的文字。</p> 
     <p>此外输入框还有一些和剪贴板有关的功能，void Clear( );删除选中的文本，void Copy( );可将选中的文本送入剪贴板，void Paste( );将剪贴板中内容插入到当前输入框中光标位置，void Cut( );相当于Copy和Clear结合使用。</p> 
     <p>最后介绍一下输入框几种常用的消息映射宏：</p> 
     <p>· ON_EN_CHANGE 输入框中文字更新后产生</p> 
     <p>· ON_EN_ERRSPACE 输入框无法分配内存时产生</p> 
     <p>· ON_EN_KILLFOCUS / ON_EN_SETFOCUS 在输入框失去/得到输入焦点时产生</p> 
     <p>使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn( );的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用输入框，Class Wizard会自动列出相关的消息，并能自动产生消息映射代码。</p> 
     <p>4.4 Scroll Bar</p> 
     <p>Scroll Bar一般不会单独使用，因为SpinCtrl可以取代滚动条的一部分作用，但是如果你需要自己生成派生窗口，滚动条还是会派上一些用场。创建一个滚动条可以使用成员函数： ： <br> BOOL CEdit::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff ); <br> 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对滚动条指明专门的风格。</p> 
     <p>· SBS_VERT 风格将创建一个垂直的滚动条。</p> 
     <p>· SBS_HORZ 风格将创建一个水平的滚动条。</p> 
     <p>在创建滚动条后需要调用void SetScrollRange( int nMinPos, int nMaxPos, BOOL bRedraw = TRUE )设置滚动范围， <br> int GetScrollPos( )/int SetScrollPos( )用来得到和设置当前滚动条的位置。</p> 
     <p>void ShowScrollBar( BOOL bShow = TRUE );用来显示/隐藏滚动条。</p> 
     <p>BOOL EnableScrollBar( UINT nArrowFlags = ESB_ENABLE_BOTH )用来设置滚动条上箭头是否为允许状态。nArrowFlags可取以下值：</p> 
     <p>· ESB_ENABLE_BOTH 两个箭头都为允许状态</p> 
     <p>· ESB_DISABLE_LTUP 上/左箭头为禁止状态</p> 
     <p>· ESB_DISABLE_RTDN 下/右箭头为禁止状态</p> 
     <p>· ESB_DISABLE_BOTH 两个箭头都为禁止状态</p> 
     <p>如果需要在滚动条位置被改变时得到通知，需要在父窗口中定义对消息WM_VSCROLL/WM_HSCROLL的映射。方法为在父窗口类中重载 <br> afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )/afx_msg void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar ) <br> 所使用的消息映射宏为：ON_WM_VSCROLL( ),ON_WM_HSCROLL( )，在映射宏中不需要指明滚动条的ID，因为所有滚动条的滚动消息都由同样的函数处理。在OnHScroll/OnVScroll的第三个参数会指明当前滚动条的指针。第一个参数表示滚动条上发生的动作，可取以下值：</p> 
     <p>· SB_TOP/SB_BOTTOM 已滚动到顶/底部</p> 
     <p>· SB_LINEUP/SB_LINEDOWN 向上/下滚动一行</p> 
     <p>· SB_PAGEDOWN/SB_PAGEUP 向上/下滚动一页</p> 
     <p>· SB_THUMBPOSITION/SB_THUMBTRACK 滚动条拖动到某一位置，参数nPos指明当前位置（参数nPos在其它的情况下是无效的）</p> 
     <p>· SB_ENDSCROLL 滚动条拖动完成（用户松开鼠标）</p> 
     <p>4.5 List Box/Check List Box</p> 
     <p>ListBox窗口用来列出一系列的文本，每条文本占一行。创建一个列表窗口可以使用成员函数： <br> BOOL CListBox::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff ); <br> 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。</p> 
     <p>· LBS_MULTIPLESEL 指明列表框可以同时选择多行</p> 
     <p>· LBS_EXTENDEDSEL 可以通过按下Shift/Ctrl键选择多行</p> 
     <p>· LBS_SORT 所有的行按照字母顺序进行排序</p> 
     <p>在列表框生成后需要向其中加入或是删除行，可以利用： <br> int AddString( LPCTSTR lpszItem )添加行， <br> int DeleteString( UINT nIndex )删除指定行， <br> int InsertString( int nIndex, LPCTSTR lpszItem )将行插入到指定位置。 <br> void ResetContent( )可以删除列表框中所有行。 <br> 通过调用int GetCount( )得到当前列表框中行的数量。</p> 
     <p>如果需要得到/设置当前被选中的行，可以调用int GetCurSel( )/int SetCurSel(int iIndex)。如果你指明了选择多行的风格，你就需要先调用int GetSelCount( )得到被选中的行的数量，然后int GetSelItems( int nMaxItems, LPINT rgIndex )得到所有选中的行，参数rgIndex为存放被选中行的数组。通过调用int GetLBText( int nIndex, LPTSTR lpszText )得到列表框内指定行的字符串。</p> 
     <p>此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem )可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。 <br> int SelectString( int nStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。</p> 
     <p>在MFC 4.2版本中添加了CCheckListBox类，该类是由CListBox派生并拥有CListBox的所有功能，不同的是可以在每行前加上一个检查框。必须注意的是在创建时必须指明LBS_OWNERDRAWFIXED或LBS_OWNERDRAWVARIABLE风格。</p> 
     <p>通过void SetCheckStyle( UINT nStyle )/UINT GetCheckStyle( )可以设置/得到检查框的风格，关于检查框风格可以参考4.1 Button中介绍。通过void SetCheck( int nIndex, int nCheck )/int GetCheck( int nIndex )可以设置和得到某行的检查状态，关于检查框状态可以参考4.1 Button中介绍。</p> 
     <p>最后介绍一下列表框几种常用的消息映射宏：</p> 
     <p>· ON_LBN_DBLCLK 鼠标双击</p> 
     <p>· ON_EN_ERRSPACE 输入框无法分配内存时产生</p> 
     <p>· ON_EN_KILLFOCUS / ON_EN_SETFOCUS 在输入框失去/得到输入焦点时产生</p> 
     <p>· ON_LBN_SELCHANGE 选择的行发生改变</p> 
     <p>使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn( );的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用列表框，Class Wizard会自动列出相关的消息，并能自动产生消息映射代码。</p> 
     <p>4.6 Combo Box/Combo Box Ex</p> 
     <p>组合窗口是由一个输入框和一个列表框组成。创建一个组合窗口可以使用成员函数： <br> BOOL CListBox::Create( LPCTSTR lpszText, DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID = 0xffff ); <br> 其中dwStyle将指明该窗口的风格，除了子窗口常用的风格WS_CHILD,WS_VISIBLE外，你可以针对列表控件指明专门的风格。</p> 
     <p>· CBS_DROPDOWN 下拉式组合框</p> 
     <p>· CBS_DROPDOWNLIST 下拉式组合框，但是输入框内不能进行输入</p> 
     <p>· CBS_SIMPLE 输入框和列表框同时被显示</p> 
     <p>· LBS_SORT 所有的行按照字母顺序进行排序</p> 
     <p>由于组合框内包含了列表框，所以列表框的功能都能够使用，如可以利用： <br> int AddString( LPCTSTR lpszItem )添加行， <br> int DeleteString( UINT nIndex )删除指定行， <br> int InsertString( int nIndex, LPCTSTR lpszItem )将行插入到指定位置。 <br> void ResetContent( )可以删除列表框中所有行。 <br> 通过调用int GetCount( )得到当前列表框中行的数量。</p> 
     <p>如果需要得到/设置当前被选中的行的位置，可以调用int GetCurSel( )/int SetCurSel(int iIndex)。通过调用int GetLBText( int nIndex, LPTSTR lpszText )得到列表框内指定行的字符串。</p> 
     <p>此外通过调用int FindString( int nStartAfter, LPCTSTR lpszItem )可以在当前所有行中查找指定的字符传的位置，nStartAfter指明从那一行开始进行查找。 <br> int SelectString( int nStartAfter, LPCTSTR lpszItem )可以选中包含指定字符串的行。</p> 
     <p>此外输入框的功能都能够使用，如可以利用： <br> DWORD GetEditSel( ) /BOOL SetEditSel( int nStartChar, int nEndChar )得到或设置输入框中被选中的字符位置。 <br> BOOL LimitText( int nMaxChars )设置输入框中可输入的最大字符数。 <br> 输入框的剪贴板功能Copy,Clear,Cut,Paste动可以使用。</p> 
     <p>最后介绍一下列表框几种常用的消息映射宏：</p> 
     <p>· ON_CBN_DBLCLK 鼠标双击</p> 
     <p>· ON_CBN_DROPDOWN 列表框被弹出</p> 
     <p>· ON_CBN_KILLFOCUS / ON_CBN_SETFOCUS 在输入框失去/得到输入焦点时产生</p> 
     <p>· ON_CBN_SELCHANGE 列表框中选择的行发生改变</p> 
     <p>· ON_CBN_EDITUPDATE 输入框中内容被更新</p> 
     <p>使用以上几种消息映射的方法为定义原型如：afx_msg void memberFxn( );的函数，并且定义形式如ON_Notification( id, memberFxn )的消息映射。如果在对话框中使用组合框，Class Wizard会自动列出相关的消息，并能自动产生消息映射代码。</p> 
     <p>4.7 Tree Ctrl</p> 
     <p>树形控件TreeCtrl和下节要讲的<a href="http://www.hevttc.edu.cn/xbsz/slx/VC6/web/48.htm" rel="nofollow">列表控件 ListCtrl</a>在系统中大量被使用，例如Windows资源管理器就是一个典型的例子。</p> 
     <p>树形控件可以用于树形的结构，其中有一个根接点(Root)然后下面有许多子结点，而每个子结点上有允许有一个或多个或没有子结点。MFC中使用CTreeCtrl类来封装树形控件的各种操作。通过调用 <br> BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );创建一个窗口，dwStyle中可以使用以下一些树形控件的专用风格：</p> 
     <p>· TVS_HASLINES 在父/子结点之间绘制连线</p> 
     <p>· TVS_LINESATROOT 在根/子结点之间绘制连线</p> 
     <p>· TVS_HASBUTTONS 在每一个结点前添加一个按钮，用于表示当前结点是否已被展开</p> 
     <p>· TVS_EDITLABELS 结点的显示字符可以被编辑</p> 
     <p>· TVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点</p> 
     <p>· TVS_DISABLEDRAGDROP 不允许Drag/Drop </p> 
     <p>· TVS_NOTOOLTIPS 不使用ToolTip显示结点的显示字符</p> 
     <p>在树形控件中每一个结点都有一个句柄（HTREEITEM），同时添加结点时必须提供的参数是该结点的父结点句柄，（其中根Root结点只有一个，既不可以添加也不可以删除）利用 <br> HTREEITEM InsertItem( LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST );可以添加一个结点，pszItem为显示的字符，hParent代表父结点的句柄，当前添加的结点会排在hInsertAfter表示的结点的后面，返回值为当前创建的结点的句柄。下面的代码会建立一个如下形式的树形结构：</p> 
     <p>+--- Parent1 +--- Child1_1 +--- Child1_2 +--- Child1_3 +--- Parent2 +--- Parent3 /*假设m_tree为一个CTreeCtrl对象，而且该窗口已经创建*/ HTREEITEM hItem,hSubItem; hItem = m_tree.InsertItem("Parent1",TVI_ROOT); 在根结点上添加Parent1 hSubItem = m_tree.InsertItem("Child1_1",hItem); //在Parent1上添加一个子结点 hSubItem = m_tree.InsertItem("Child1_2",hItem,hSubItem); //在Parent1上添加一个子结点，排在Child1_1后面 hSubItem = m_tree.InsertItem("Child1_3",hItem,hSubItem); hItem = m_tree.InsertItem("Parent2",TVI_ROOT,hItem); hItem = m_tree.InsertItem("Parent3",TVI_ROOT,hItem); </p> 
     <p>如果你希望在每个结点前添加一个小图标，就必需先调用CImageList* SetImageList( CImageList * pImageList, int nImageListType );指明当前所使用的ImageList，nImageListType为TVSIL_NORMAL。在调用完成后控件中使用图片以设置的 ImageList中图片为准。然后调用 <br> HTREEITEM InsertItem( LPCTSTR lpszItem, int nImage, int nSelectedImage, HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST);添加结点，nImage为结点没被选中时所使用图片序号，nSelectedImage为结点被选中时所使用图片序号。下面的代码演示了ImageList的设置。</p> 
     <p>/*m_list 为CImageList对象 IDB_TREE 为16*(16*4)的位图，每个图片为16*16共4个图标*/ m_list.Create(IDB_TREE,16,4,RGB(0,0,0)); m_tree.SetImageList(&amp;m_list,TVSIL_NORMAL); m_tree.InsertItem("Parent1",0,1); //添加，选中时显示图标1，未选中时显示图标0 </p> 
     <p>此外CTreeCtrl还提供了一些函数用于得到/修改控件的状态。 <br> HTREEITEM GetSelectedItem( );将返回当前选中的结点的句柄。BOOL SelectItem( HTREEITEM hItem );将选中指明结点。 <br> BOOL GetItemImage( HTREEITEM hItem, int&amp; nImage, int&amp; nSelectedImage ) / BOOL SetItemImage( HTREEITEM hItem, int nImage, int nSelectedImage )用于得到/修改某结点所使用图标索引。 <br> CString GetItemText( HTREEITEM hItem ) /BOOL SetItemText( HTREEITEM hItem, LPCTSTR lpszItem );用于得到/修改某一结点的显示字符。 <br> BOOL DeleteItem( HTREEITEM hItem );用于删除某一结点，BOOL DeleteAllItems( );将删除所有结点。</p> 
     <p>此外如果想遍历树可以使用下面的函数： <br> HTREEITEM GetRootItem( );得到根结点。 <br> HTREEITEM GetChildItem( HTREEITEM hItem );得到子结点。 <br> HTREEITEM GetPrevSiblingItem/GetNextSiblingItem( HTREEITEM hItem );得到指明结点的上/下一个兄弟结点。 <br> HTREEITEM GetParentItem( HTREEITEM hItem );得到父结点。</p> 
     <p>树形控件的消息映射使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn )，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同void OnXXXTree(NMHDR* pNMHDR, LRESULT* pResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于树形控件可能取值和对应的数据结构为：</p> 
     <p>· TVN_SELCHANGED 在所选中的结点发生改变后发送，所用结构：NMTREEVIEW </p> 
     <p>· TVN_ITEMEXPANDED 在某结点被展开后发送，所用结构：NMTREEVIEW </p> 
     <p>· TVN_BEGINLABELEDIT 在开始编辑结点字符时发送，所用结构：NMTVDISPINFO </p> 
     <p>· TVN_ENDLABELEDIT 在结束编辑结点字符时发送，所用结构：NMTVDISPINFO </p> 
     <p>· TVN_GETDISPINFO 在需要得到某结点信息时发送，（如得到结点的显示字符）所用结构：NMTVDISPINFO </p> 
     <p>关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。</p> 
     <p>关于动态提供结点所显示的字符：首先你在添加结点时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送 TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMTVDISPINFO，然后填充其中 item.pszText。但是我们通过什么来知道该结点所对应的信息呢，我的做法是在添加结点后设置其lParam参数，然后在提供信息时利用该参数来查找所对应的信息。下面的代码说明了这种方法：</p> 
     <p>char szOut[8][3]={"No.1","No.2","No.3"}; //添加结点 HTREEITEM hItem = m_tree.InsertItem(LPSTR_TEXTCALLBACK,...) m_tree.SetItemData(hItem, 0 ); hItem = m_tree.InsertItem(LPSTR_TEXTCALLBACK,...) m_tree.SetItemData(hItem, 1 ); //处理消息 void CParentWnd::OnGetDispInfoTree(NMHDR* pNMHDR, LRESULT* pResult) { TV_DISPINFO* pTVDI = (TV_DISPINFO*)pNMHDR; pTVDI-&gt;item.pszText=szOut[pTVDI-&gt;item.lParam]; //通过lParam得到需要显示的字符在数组中的位置 *pResult = 0; } </p> 
     <p>关于编辑结点的显示字符：首先需要设置树形控件的TVS_EDITLABELS风格，在开始编辑时该控件将会发送TVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送TVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为 LPNMTVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息：</p> 
     <p>//处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDR* pNMHDR, LRESULT* pResult) { TV_DISPINFO* pTVDI = (TV_DISPINFO*)pNMHDR; if(pTVDI-&gt;item.lParam==0);//判断是否取消该操作 *pResult = 1; else *pResult = 0; } //处理消息 TVN_BEGINLABELEDIT void CParentWnd::OnBeginEditTree(NMHDR* pNMHDR, LRESULT* pResult) { TV_DISPINFO* pTVDI = (TV_DISPINFO*)pNMHDR; if(pTVDI-&gt;item.pszText==NULL);//判断是否已经取消取消编辑 m_tree.SetItemText(pTVDI-&gt;item.hItem,pTVDI-&gt;pszText); //重置显示字符 *pResult = 0; } </p> 
     <p>上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。</p> 
     <p>4.8 List Ctrl</p> 
     <p>列表控件可以看作是功能增强的ListBox，它提供了四种风格，而且可以同时显示一列的多中属性值。MFC中使用CListCtrl类来封装列表控件的各种操作。通过调用 <br> BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );创建一个窗口，dwStyle中可以使用以下一些列表控件的专用风格：</p> 
     <p>· LVS_ICON LVS_SMALLICON LVS_LIST LVS_REPORT 这四种风格决定控件的外观，同时只可以选择其中一种，分别对应：大图标显示，小图标显示，列表显示，详细报表显示</p> 
     <p>· LVS_EDITLABELS 结点的显示字符可以被编辑，对于报表风格来讲可编辑的只为第一列。</p> 
     <p>· LVS_SHOWSELALWAYS 在失去焦点时也显示当前选中的结点</p> 
     <p>· LVS_SINGLESEL 同时只能选中列表中一项</p> 
     <p>首先你需要设置列表控件所使用的ImageList，如果你使用大图标显示风格，你就需要以如下形式调用： <br> CImageList* SetImageList( CImageList* pImageList, LVSIL_NORMAL); <br> 如果使用其它三种风格显示而不想显示图标你可以不进行任何设置，否则需要以如下形式调用： <br> CImageList* SetImageList( CImageList* pImageList, LVSIL_SMALL); </p> 
     <p>通过调用 int InsertItem( int nItem, LPCTSTR lpszItem );可以在列表控件中nItem指明位置插入一项，lpszItem为显示字符。除LVS_REPORT风格外其他三种风格都只需要直接调用 InsertItem就可以了，但如果使用报表风格就必须先设置列表控件中的列信息。</p> 
     <p>通过调用 int InsertColumn( int nCol, LPCTSTR lpszColumnHeading, int nFormat , int nWidth, int nSubItem);可以插入列。iCol为列的位置，从零开始，lpszColumnHeading为显示的列名，nFormat为显示对齐方式， nWidth为显示宽度，nSubItem为分配给该列的列索引。</p> 
     <p>在有多列的列表控件中就需要为每一项指明其在每一列中的显示字符，通过调用 <br> BOOL SetItemText( int nItem, int nSubItem, LPTSTR lpszText );可以设置每列的显示字符。nItem为设置的项的位置，nSubItem为列位置，lpszText为显示字符。下面的代码演示了如何设置多列并插入数据：</p> 
     <p>m_list.SetImageList(&amp;m_listSmall,LVSIL_SMALL);//设置ImageList m_list.InsertColumn(0,"Col 1",LVCFMT_LEFT,300,0);//设置列 m_list.InsertColumn(1,"Col 2",LVCFMT_LEFT,300,1); m_list.InsertColumn(2,"Col 3",LVCFMT_LEFT,300,2); m_list.InsertItem(0,"Item 1_1");//插入行 m_list.SetItemText(0,1,"Item 1_2");//设置该行的不同列的显示字符 m_list.SetItemText(0,2,"Item 1_3"); </p> 
     <p>此外CListCtrl还提供了一些函数用于得到/修改控件的状态。 <br> COLORREF GetTextColor( )/BOOL SetTextColor( COLORREF cr );用于得到/设置显示的字符颜色。 <br> COLORREF GetTextBkColor( )/BOOL SetTextBkColor( COLORREF cr );用于得到/设置显示的背景颜色。 <br> void SetItemCount( int iCount );用于得到添加进列表中项的数量。 <br> BOOL DeleteItem(int nItem);用于删除某一项，BOOL DeleteAllItems( );将删除所有项。 <br> BOOL SetBkImage(HBITMAP hbm, BOOL fTile , int xOffsetPercent, int yOffsetPercent);用于设置背景位图。 <br> CString GetItemText( int nItem, int nSubItem );用于得到某项的显示字符。</p> 
     <p>列表控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn )，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同void OnXXXList(NMHDR* pNMHDR, LRESULT* pResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为：</p> 
     <p>· LVN_BEGINLABELEDIT 在开始某项编辑字符时发送，所用结构：NMLVDISPINFO </p> 
     <p>· LVN_ENDLABELEDIT 在结束某项编辑字符时发送，所用结构：NMLVDISPINFO </p> 
     <p>· LVN_GETDISPINFO 在需要得到某项信息时发送，（如得到某项的显示字符）所用结构：NMLVDISPINFO </p> 
     <p>关于ON_NOTIFY有很多内容，将在以后的内容中进行详细讲解。</p> 
     <p>关于动态提供结点所显示的字符：首先你在项时需要指明lpszItem参数为：LPSTR_TEXTCALLBACK。在控件显示该结点时会通过发送 TVN_GETDISPINFO来取得所需要的字符，在处理该消息时先将参数pNMHDR转换为LPNMLVDISPINFO，然后填充其中 item.pszText。通过item中的iItem,iSubItem可以知道当前显示的为那一项。下面的代码演示了这种方法：</p> 
     <p>char szOut[8][3]={"No.1","No.2","No.3"}; //添加结点 m_list.InsertItem(LPSTR_TEXTCALLBACK,...) m_list.InsertItem(LPSTR_TEXTCALLBACK,...) //处理消息 void CParentWnd::OnGetDispInfoList(NMHDR* pNMHDR, LRESULT* pResult) { LV_DISPINFO* pLVDI = (LV_DISPINFO*)pNMHDR; pLVDI-&gt;item.pszText=szOut[pTVDI-&gt;item.iItem]; //通过iItem得到需要显示的字符在数组中的位置 *pResult = 0; } </p> 
     <p>关于编辑某项的显示字符：（在报表风格中只对第一列有效）首先需要设置列表控件的LVS_EDITLABELS风格，在开始编辑时该控件将会发送 LVN_BEGINLABELEDIT，你可以通过在处理函数中返回TRUE来取消接下来的编辑，在编辑完成后会发送LVN_ENDLABELEDIT，在处理该消息时需要将参数pNMHDR转换为LPNMLVDISPINFO，然后通过其中的item.pszText得到编辑后的字符，并重置显示字符。如果编辑在中途中取消该变量为NULL。下面的代码说明如何处理这些消息：</p> 
     <p>//处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDR* pNMHDR, LRESULT* pResult) { LV_DISPINFO* pLVDI = (LV_DISPINFO*)pNMHDR; if(pLVDI-&gt;item.iItem==0);//判断是否取消该操作 *pResult = 1; else *pResult = 0; } //处理消息 LVN_BEGINLABELEDIT void CParentWnd::OnBeginEditList(NMHDR* pNMHDR, LRESULT* pResult) { LV_DISPINFO* pLVDI = (LV_DISPINFO*)pNMHDR; if(pLVDI-&gt;item.pszText==NULL);//判断是否已经取消取消编辑 m_list.SetItemText(pLVDI-&gt;item.iItem,0,pLVDI-&gt;pszText); //重置显示字符 *pResult = 0; } </p> 
     <p>上面讲述的方法所进行的消息映射必须在父窗口中进行（同样WM_NOTIFY的所有消息都需要在父窗口中处理）。</p> 
     <p>如何得到当前选中项位置：在列表控件中没有一个类似于ListBox中GetCurSel()的函数，但是可以通过调用GetNextItem( -1, LVNI_ALL | LVNI_SELECTED);得到选中项位置。</p> 
     <p>4.9 Tab Ctrl</p> 
     <p>Tab属性页控件可以在一个窗口中添加不同的页面，然后在页选择发生改变时得到通知。MFC中使用CTabCtrl类来封装属性页控件的各种操作。通过调用 <br> BOOL Create( DWORD dwStyle, const RECT&amp; rect, CWnd* pParentWnd, UINT nID );创建一个窗口，dwStyle中可以使用以下一些属性页控件的专用风格：</p> 
     <p>TCS_BUTTONS 使用按钮来表示页选择位置 <br> TCS_MULTILINE 分行显示页选择位置 <br> TCS_SINGLELINE 只使用一行显示页选择位置 <br> 在控件创建后必需向其中添加页面才可以使用，添加页面的函数为： <br> BOOL InsertItem( int nItem, LPCTSTR lpszItem );nItem为位置，从零开始，lpszItem为页选择位置上显示的文字。如果你希望在页选择位置处显示一个图标，你可以调用 <br> BOOL InsertItem( int nItem, LPCTSTR lpszItem, int nImage );nImage指明所使用的图片位置。（在此之前必须调用CImageList * SetImageList( CImageList * pImageList );设置正确的ImageList）</p> 
     <p>此外CTabCtrl还提供了一些函数用于得到/修改控件的状态。 <br> int GetCurSel( )/int SetCurSel( int nItem );用于得到/设置当前被选中的页位置。 <br> BOOL DeleteItem( int nItem )/BOOL DeleteAllItems( );用于删除指定/所有页面。 <br> void RemoveImage( int nImage );用于删除某页选择位置上的图标。</p> 
     <p>属性页控件的消息映射同样使用ON_NOTIFY宏，形式如同：ON_NOTIFY( wNotifyCode, id, memberFxn )，wNotifyCode为通知代码，id为产生该消息的窗口ID，memberFxn为处理函数，函数的原型如同void OnXXXTab(NMHDR* pNMHDR, LRESULT* pResult)，其中pNMHDR为一数据结构，在具体使用时需要转换成其他类型的结构。对于列表控件可能取值和对应的数据结构为：</p> 
     <p>TCN_SELCHANGE 在当前页改变后发送，所用结构：NMHDR <br> TCN_SELCHANGING 在当前页改变时发送可以通过返回TRUE来禁止页面的改变，所用结构：NMHDR </p> 
     <p>一般来讲在当前页发生改变时需要隐藏当前的一些子窗口，并显示其它的子窗口。下面的伪代码演示了如何使用属性页控件：</p> 
     <p>CParentWnd::OnCreate(...) <br> { <br> m_tab.Create(...); <br> m_tab.InsertItem(0,"Option 1"); <br> m_tab.InsertItem(1,"Option 2"); <br> Create a edit box as the m_tab's Child <br> Create a static box as the m_tab's Child <br> edit_box.ShowWindow(SW_SHOW); // edit box在属性页的第一页 <br> static_box.ShowWindow(SW_HIDE); // static box在属性页的第二页 <br> } <br> void CParentWnd::OnSelectChangeTab(NMHDR* pNMHDR, LRESULT* pResult) <br> {//处理页选择改变后的消息 <br> if(m_tab.GetCurSel()==0) <br> {//根据当前页显示/隐藏不同的子窗口 <br> edit_box.ShowWindow(SW_SHOW); <br> static_box.ShowWindow(SW_HIDE); <br> } <br> else <br> {// <br> edit_box.ShowWindow(SW_HIDE); <br> static_box.ShowWindow(SW_SHOW); <br> } <br> }</p> 
     <p> </p> 
     <p>原文链接：<a title="http://blog.chinaunix.net/u2/65112/showart_515770.html" href="http://blog.chinaunix.net/u2/65112/showart_515770.html" rel="nofollow">http://blog.chinaunix.net/u2/65112/showart_515770.html</a>，用到时候可以看看。</p> 
     <p> 今天主要是弄明白了一个问题，就是如何访问这些控件。貌似还有一种方法，直接通过ID来访问。CWnd::GetDlgItem，该函数根据参数说明的控件ID，返回指定控件的一个CWnd型指针，程序可以把该指针强制转换成相应的控件类指针，然后通过该指针来访问控件．该方法对自动和手工创建的控件均适用．其实该方法与通过控件对象来访问控件的方法在本质上是一样的．例如：</p> 
     <p>CWnd::GetDlgItem(IDC_STATIC_Line)-&gt;SetWindowText(_T("这是通过GetDlgItem获取的控件")); 如果需要用到针对控件特殊的方法，可以进行类型的强制转化。另外，返回值是一个指向控件的指针。</p> 
     <p><br></p> 
     <p><br></p> 
     <p><br></p> 
     <p>本文转自齐师傅博客园博客，原文链接：http://www.cnblogs.com/youring2/archive/2010/08/18/1802903.html，如需转载请自行联系原作者</p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
