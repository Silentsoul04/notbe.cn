<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>（转）.net面试问答（大汇总） « NotBeCN</title>
  <meta name="description" content="                             用.net做B/S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？&nbsp;答：     从下至上分别为：数据访问层、业务逻辑层（又或成为领域层）、表示层&nbsp; 数据访问层：有时候也称为是持久层，其功能主要是负责数据库的访问...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/26/weixin_34008933_90125183.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">（转）.net面试问答（大汇总）</h1>
    <p class="post-meta">Nov 26, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div>
    <br>
   </div> 
   <div> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>用.net做B/S结构的系统，您是用几层结构来开发，每一层之间的关系以及为什么要这样分层？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);"></span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">从下至上分别为：数据访问层、业务逻辑层（又或成为领域层）、表示层&nbsp;<br> 数据访问层：有时候也称为是持久层，其功能主要是负责数据库的访问&nbsp;<br> 业务逻辑层：是整个系统的核心，它与这个系统的业务（领域）有关&nbsp;<br> 表示层：是系统的UI部分，负责使用者与整个系统的交互。</span>&nbsp;<span style="color:rgb(0,128,0);">&nbsp;<br> 优点：&nbsp; 分工明确，条理清晰，易于调试，而且具有可扩展性。&nbsp;<br> 缺点：&nbsp; 增加成本。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>分层式结构究竟其优势何在？&nbsp;<br></strong><span style="color:rgb(0,128,0);">1、开发人员可以只关注整个结构中的其中某一层；&nbsp;<br> 2、可以很容易的用新的实现来替换原有层次的实现；&nbsp;<br> 3、可以降低层与层之间的依赖；&nbsp;<br> 4、有利于标准化；&nbsp;<br> 5、利于各层逻辑的复用。&nbsp;<br> 概括来说，分层式设计可以达至如下目的：分散关注、松散耦合、逻辑复用、标准定义。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>分层式结构也不可避免具有一些缺陷：</strong>&nbsp;<br> &nbsp;<span style="color:rgb(0,128,0);">1、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相</span><span style="color:rgb(0,128,0);">应的数据，如今却必须通过中间层来完成。&nbsp;<br> 2、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证</span><span style="color:rgb(0,128,0);">其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>MVC模式</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">MVC(Model-View-Controller)把交互系统的组成分解成<span style="color:rgb(0,128,0);">模型、视图、控制器</span>三种部件</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>mvc的优点：</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">1.通过把项目分成model view和controller，使得复杂项目更加容易维护。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">2.没有使用view state和服务器表单控件，可以更方便的控制应用程序的行为</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">3.应用程序通过controller来控制程序请求，可以提供丰富的url重写。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">4.对单元测试的支持更加出色</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">5.在团队开发模式下表现更出众</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>MVC的不足：</strong>&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">（1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。&nbsp;&nbsp;&nbsp;&nbsp;<br> （2）视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。&nbsp;&nbsp;&nbsp;&nbsp;<br> （3）视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>asp.net如何实现MVC模式，举例说明！</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">web/business/dataaccess</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>列举ASP.NET 页面之间传递值的几种方式。&nbsp;<br></strong><span style="color:rgb(0,128,0);">1.使用QueryString, 如....?id=1; response. Redirect()....&nbsp;<br> 2.使用Session变量&nbsp;<br> 3.使用Server.Transfer</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。</strong>&nbsp;<br><span style="color:rgb(0,128,0);">session(viewstate) 简单，但易丢失&nbsp;<br> application 全局&nbsp;<br> cookie 简单，但可能不支持，可能被伪造&nbsp;<br> input ttype="hidden" 简单，可能被伪造&nbsp;<br> url参数简单，显示于地址栏，长度有限&nbsp;<br> 数据库稳定，安全，但性能相对弱</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>列举ADO.NET中的五个主要对象，并简单描述</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">connection,command,dataReader,trans,dataset ...&nbsp;<br><span style="color:rgb(0,128,0);">Connection 对象主要是开启程序和数据库之间的连结&nbsp;<br> Command 对象主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数据等指令&nbsp;<br> DataSetCommand 对象主要是在数据源以及DataSet 之间执行数据传输的工作&nbsp;<br> DataSet 这个对象可以视为一个暂存区（Cache），可以把从数据库中所查询到的数据保留起来&nbsp;<br> DataReader对象只是一次一笔向下循序的读取数据源中的数据，而且这些数据是只读的，并不允许作其它的操作。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">因为DataReader 在读取数据的时候限制了每次只读取一笔，而且只能只读，所以使用起来不但节省资源而且</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全部传回，故可以降低网络的负载。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>ADO.net中常用的对象有哪些？分别描述一下。&nbsp;<br></strong>答：&nbsp;<br><span style="color:rgb(0,128,0);">Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 打开数据库连接&nbsp;<br> Command&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 执行数据库命令&nbsp;<br> DataAdapter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 连接数据，执行数据库命令，填充DataSet&nbsp;<br> DataSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数据在内存中的缓存，数据结构&nbsp;<br> DataReader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 只读向前的读取数据库</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>DataReader和DataSet的异同&nbsp;<br></strong><span style="color:rgb(0,128,0);">DataReader和DataSet最大的区别在于&nbsp;<br></span><span style="color:rgb(0,128,0);">DataReader使用时始终占用SqlConnection,在线操作数据库..任何</span><span style="color:rgb(0,128,0);">对SqlConnection的操作都会引发DataReader的异常..因为DataReader每次只在内存中加载一条数据,所以占用的</span><span style="color:rgb(0,128,0);">内存是很小的..因为DataReader的特殊性和高性能.所以DataReader是只进的..你读了第一条后就不能再去读取第</span><span style="color:rgb(0,128,0);">一条了..&nbsp;<br> DataSet则是将数据一次性加载在内存中.抛弃数据库连接..读取完毕即放弃数据库连接..因为DataSet将数据全部</span><span style="color:rgb(0,128,0);">加载在内存中.所以比较消耗内存...但是确比DataReader要灵活..可以动态的添加行,列,数据.对数据库进行回传更</span><span style="color:rgb(0,128,0);">新操作...</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>.net中读写数据库需要用到那些类？他们的作用？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">DataSet:数据存储器。&nbsp;<br> &nbsp;&nbsp;&nbsp; DataCommand:执行语句命令。&nbsp;<br> &nbsp;&nbsp;&nbsp; DataAdapter:数据的集合，用语填充。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>存储过程和sql语句的优缺点&nbsp;<br></strong>答：&nbsp;<br> 存储过程的优缺点：</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>优点：</strong>&nbsp;<br><span style="color:rgb(0,128,0);">1.由于应用程序随着时间推移会不断更改，增删功能，T－SQL过程代码会变得更复杂，StoredProcedure为封装</span><span style="color:rgb(0,128,0);">此代码提供了一个替换位置。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">2.执行计划（存储过程在首次运行时将被编译，这将产生一个执行计划－－ 实际上是 Microsoft SQL Server为在</span><span style="color:rgb(0,128,0);">存储过程中获取由 T-SQL 指定的结果而必须采取的步骤的记录。）缓存改善性能。........但sql server新版本，执行计划已针对所有 T-SQL 批处理进行了缓存，而不管它们是否在存储过程中，所</span><span style="color:rgb(0,128,0);">以没比较优势了。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">3.存储过程可以用于降低网络流量，存储过程代码直接存储于数据库中，所以不会产生大量T-sql语句的代码流量</span><span style="color:rgb(0,128,0);">。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">4.使用存储过程使您能够增强对执行计划的重复使用，由此可以通过使用远程过程调用 (RPC) 处理服务器上的存</span><span style="color:rgb(0,128,0);">储过程而提高性能。RPC 封装参数和调用服务器端过程的方式使引擎能够轻松地找到匹配的执行计划，并只需插</span><span style="color:rgb(0,128,0);">入更新的参数值。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">5.可维护性高，更新存储过程通常比更改、测试以及重新部署程序集需要较少的时间和精力。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">6.代码精简一致，一个存储过程可以用于应用程序代码的不同位置。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">7.更好的版本控制，通过使用 Microsoft Visual SourceSafe 或某个其他源代码控制工具，您可以轻松地恢复到或</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">引用旧版本的存储过程。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">8.增强安全性：&nbsp;<br> a、通过向用户授予对存储过程（而不是基于表）的访问权限，它们可以提供对特定数据的访问；&nbsp;<br> b、提高代码安全，防止 SQL注入（但未彻底解决，例如，将数据操作语言－－DML，附加到输入参数）；&nbsp;<br> c、SqlParameter 类指定存储过程参数的数据类型，作为深层次防御性策略的一部分，可以验证用户提供的值类</span><span style="color:rgb(0,128,0);">型（但也不是万无一失，还是应该传递至数据库前得到附加验证）。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>缺点：</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">1.如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则您仍需要更新程序集</span><span style="color:rgb(0,128,0);">中的代码以添加参数、更新 GetValue() 调用，等等，这时候估计比较繁琐了。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">2.可移植性差</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">由于存储过程将应用程序绑定到 SQL Server，因此使用存储过程封装业务逻辑将限制应用程序的可移植性。如</span><span style="color:rgb(0,128,0);">果应用程序的可移植性在您的环境中非常重要，则将业务逻辑封装在不特定于 RDBMS 的中间层中可能是一个更</span><span style="color:rgb(0,128,0);">佳的选择。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">Sql语句灵活，可移植性强，查询速度比存储过程慢些</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>说出你所了解的数据库访问组件(例如ADO，至少4种)&nbsp;<br></strong>答：<span style="color:rgb(128,0,64);">ADO，ADO.Net，MDAC(Microsoft Data Access Components)，Microsoft SQL Server OLE DB Provider，</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,64);">Microsoft Jet OLE DB Provider，Desktop Database Drivers ODBC Driver，Visual FoxPro ODBC Driver</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,64);"></span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>阐述面向接口、面向对象、面向方面编程的区别</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">面向接口更关注的是概念，它的原则是先定义好行为规范，再根据行为规范创建实现，严格的来说，面向接口应</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">该是面向对象中的一部分吧，因为面向对象也强调的是本末倒置原则，也就是实现依赖于抽象，而抽象不依赖于</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">具体实现，更具比较的应该是面向接口与面向抽象对象，我的体会是面向接口更加灵活，但实现时候，稍微有些</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">代码冗余，而面向抽象可以结合面向接口，先定义接口，再定义抽象类，在抽象类中处理一些公共逻辑，再实现</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">具体实现类。面向对象是对复杂问题的分解。面向方面的编程是一种新概念，它解决了很多面向对象无法解决的</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">问题，比如面向对象技术只能对业务相关的代码模块化，而无法对和业务无关的代码模块化。而面向方面正是解</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">决这一问题的方案，它的关键思想是"将应用程序中的商业逻辑与对其提供支持的通用服务进行分离"。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是面向对象&nbsp;<br></strong><span style="color:rgb(0,128,0);">万物都是对象，其主要特征：封装、继承、多态</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"><strong>怎样实现多态</strong>&nbsp;</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">1.通过对象直接调用成员函数时，始终默认使用该对象的类的成员函数（除非用::显示指定类名）。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">2.通过指向对象的指针或引用调用成员函数时：如果该函数是实函数，则调用该指针或引用的类的成员函数；如果该函</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">数是虚函数，则调用该指针或引用指向的对象的类的成员函数。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>面向对象的思想主要包括什么？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">任何事物都可以理解为对象，其主要特征： 继承。封装。多态。特点：代码好维护，安全，隐藏信息</span>&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是Interface？它与Abstract Class有什么区别？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">接口(Interface)是用来定义行为规范的，不会有具体实现，而抽象类除定义行为规范外，可以有部分实现，但一</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">个类能实现多个接口，但只能继承一个父类</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是抽象类（abstract class）?&nbsp;<br></strong>答：<span style="color:rgb(255,128,0);">一种不可以被实例化的类。抽象类中一般含有抽象方法，当然也可有具体实现。继承类只有实现过所有抽象</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">类的抽象方法后才能被实例化。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>接口（interface）是什么？&nbsp;<br></strong>答：<span style="color:rgb(255,128,0);">只含有公有抽象方法（public abstract method）的类。这些方法必须在子类中被实现。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>为什么不能指定接口中方法的修饰符？&nbsp;<br></strong>答：<span style="color:rgb(255,128,0);">接口中的方法用来定义对象之间通信的契约，指定接口中的方法为私有或保护没有意义。它们默认为公有方法。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>接口和抽象类的区别是什么？&nbsp;<br></strong>答：<span style="color:rgb(255,128,0);">接口用于规范，抽象类用于共性。接口中只能声明方法，属性，事件，索引器。而抽象类中可以有方法的实</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">现，也可以定义非静态的类变量。抽象类是类，所以只能被单继承，但是接口却可以一次实现多个。抽象类可以</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">提供某些方法的部分实现，接口不可以.抽象类的实例是它的子类给出的。接口的实例是实现接口的类给出的。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">再抽象类中加入一个方法，那么它的子类就同时有了这个方法。而在接口中加入新的方法，那么实现它的类就要</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">重新编写（这就是为什么说接口是一个类的规范了）。接口成员被定义为公共的，但抽象类的成员也可以是私有</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">的、受保护的、内部的或受保护的内部成员（其中受保护的内部成员只能在应用程序的代码或派生类中访问）。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">此外接口不能包含字段、构造函数、析构函数、静态成员或常量</span>。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么时候使用抽象类，什么时候用接口&nbsp;<br></strong>答：<span style="color:rgb(255,128,0);">接口用于规范，抽象类用于共性。接口中只能声明方法，属性，事件，索引器。而抽象类中可以有方法的实</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">现，也可以定义非静态的类变量。抽象类是类，所以只能被单继承，但是接口却可以一次实现多个。抽象类可以</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">提供某些方法的部分实现，接口不可以.抽象类的实例是它的子类给出的。接口的实例是实现接口的类给出的。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">再抽象类中加入一个方法，那么它的子类就同时有了这个方法。而在接口中加入新的方法，那么实现它的类就要</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">重新编写（这就是为什么说接口是一个类的规范了）。接口成员被定义为公共的，但抽象类的成员也可以是私有</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">的、受保护的、内部的或受保护的内部成员（其中受保护的内部成员只能在应用程序的代码或派生类中访问）。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,128,0);">此外接口不能包含字段、构造函数、析构函数、静态成员或常量。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>请详述在dotnet中类(class)与结构(struct)的异同？&nbsp;<br></strong>答：<span style="color:rgb(128,0,128);">Class可以被实例化,属于引用类型,是分配在内存的堆上的,Struct属于值类型,是分配在内存的栈上的.</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>详述.NET里class和struct的异同！</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"><span style="color:rgb(255,128,0);">结构具有以下特点：</span>&nbsp;<br> 结构是值类型，而类是引用类型。&nbsp;<br> 向方法传递结构时，结构是通过传值方式传递的，而不是作为引用传递的。&nbsp;<br> 与类不同，结构的实例化可以不使用 new 运算符。&nbsp;<br> 结构可以声明构造函数，但它们必须带参数。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">一个结构不能从另一个结构或类继承，而且不能作为一个类的基。&nbsp;<br> 所有结构都直接继承自 System.ValueType，后者继承自 System.Object。&nbsp;<br> 结构可以实现接口。&nbsp;<br> 在结构中初始化实例字段是错误的。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"><span style="color:rgb(255,128,0);">类与结构的差别</span>&nbsp;<br><strong>1. 值类型与引用类型&nbsp;<br></strong>结构是值类型：值类型在堆栈上分配地址，所有的基类型都是结构类型&nbsp;<br> 例如：int 对应System.int32 结构，string 对应 system.string 结构 ，通过使用结构可以创建更多的值类型&nbsp;<br> 类是引用类型：引用类型在堆上分配地址 堆栈的执行效率要比堆的执行效率高&nbsp;<br> 可是堆栈的资源有限，不适合处理大的逻辑复杂的对象。&nbsp;<br> 所以结构处理作为基类型对待的小对象，而类处理某个商业逻辑&nbsp;<br> 因为结构是值类型所以结构之间的赋值可以创建新的结构，而类是引用类型，类之间的赋值只是复制引用 注：&nbsp;<br> 1.虽然结构与类的类型不一样，可是他们的基类型都是对象（object）,c#中所有类型的基类型都是object&nbsp;<br> 2.虽然结构的初始化也使用了New 操作符可是结构对象依然分配在堆栈上而不是堆上&nbsp;<br> 如果不使用“新建”(new)，那么在初始化所有字段之前，字段将保持未赋值状态，且对象不可用&nbsp;<br><strong>2．继承性</strong>&nbsp;<br> 结构：不能从另外一个结构或者类继承，本身也不能被继承&nbsp;<br> 虽然结构没有明确的用sealed声明，可是结构是隐式的sealed .&nbsp;<br> 类：完全可扩展的，除非显示的声明sealed 否则类可以继承其他类和接口，自身也能被继承&nbsp;<br> 注：虽然结构不能被继承 可是结构能够继承接口，方法和类继承接口一样&nbsp;<br> 例如:结构实现接口&nbsp;<br> interface IImage&nbsp;<br> {&nbsp;<br> void Paint();&nbsp;<br> }&nbsp;<br> struct Picture : IImage&nbsp;<br> {&nbsp;<br> public void Paint()&nbsp;<br> {&nbsp;<br> // painting code goes here&nbsp;<br> }&nbsp;<br> private int x, y, z; // other struct members&nbsp;<br> }</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">3．内部结构：&nbsp;<br><strong>结构：&nbsp;<br></strong>没有默认的构造函数，但是可以添加构造函数&nbsp;<br> 没有析构函数&nbsp;<br> 没有 abstract 和 sealed(因为不能继承)&nbsp;<br> 不能有protected 修饰符&nbsp;<br> 可以不使用new 初始化&nbsp;<br> 在结构中初始化实例字段是错误的&nbsp;<br><strong>类：</strong>&nbsp;<br> 有默认的构造函数&nbsp;<br> 有析构函数&nbsp;<br> 可以使用 abstract 和 sealed&nbsp;<br> 有protected 修饰符&nbsp;<br> 必须使用new 初始化</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"><strong>如何选择结构还是类&nbsp;<br></strong>1． 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些&nbsp;<br> 2． 结构表示如点、矩形和颜色这样的轻量对象&nbsp;<br> 例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。&nbsp;<br> 在此情况下，结构的成本较低。&nbsp;<br> 3． 在表现抽象和多级别的对象层次时，类是最好的选择&nbsp;<br> 4． 大多数情况下该类型只是一些数据时，结构时最佳的选择</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>C#中的接口和类有什么异同。</strong>&nbsp;<br> 答：&nbsp;<br><span style="color:rgb(0,128,0);"><strong>异：&nbsp;<br></strong>不能直接实例化接口。&nbsp;<br> 接口不包含方法的实现。&nbsp;<br> 接口、类和结构可从多个接口继承。但是C# 只支持单继承：类只能从一个基类继承实现。&nbsp;<br> 类定义可在不同的源文件之间进行拆分。&nbsp;<br><strong>同：&nbsp;<br></strong>接口、类和结构可从多个接口继承。&nbsp;<br> 接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。&nbsp;<br> 接口可以包含事件、索引器、方法和属性。&nbsp;<br> 一个类可以实现多个接口。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是抽象类（abstract class）？&nbsp;<br></strong><span style="color:rgb(128,0,128);">一种不可以被实例化的类。抽象类中一般含有抽象方法，当然也可有具体实现。继承类只有实现过所有抽</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,128);">象类的抽象方法后才能被实例化。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>何时必须声明一个类为抽象类？&nbsp;<br></strong><span style="color:rgb(128,0,128);">当这个类中包含抽象方法时，或是该类并没有完全实现父类的抽象方法时。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">接<strong>口（interface）是什么？</strong>&nbsp;<br><span style="color:rgb(128,0,128);">只含有共有抽象方法（public abstract method）的类。这些方法必须在子类中被实现。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>为什么不能指定接口中方法的修饰符？&nbsp;<br></strong><span style="color:rgb(128,0,128);">接口中的方法用来定义对象之间通信的契约，指定接口中的方法为私有或保护没有意义。他们默认为公有方法。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>可以继承多个接口么？</strong>&nbsp;<br><span style="color:rgb(128,0,128);">当然。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>那么如果这些接口中有重复的方法名称呢？&nbsp;<br></strong><span style="color:rgb(128,0,128);">这种情况中你可以决定如何实现。当然需要特别得小心。但是在编译环节是没有问题的。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>接口和抽象类的区别是什么？&nbsp;<br></strong><span style="color:rgb(128,0,128);">接口中所有方法必须是抽象的，并且不能指定方法的访问修饰符。抽象类中可以有方法的实现，也可以指</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,128);">定方法的访问修饰符。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>const和readonly有什么区别？&nbsp;<br></strong><span style="color:rgb(0,128,0);">const关键字用来声明编译时常量，readonly用来声明运行时常量。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>解释virtual、sealed、override和abstract的区别&nbsp;<br></strong><span style="color:rgb(0,128,0);">（virtual申明虚方法的关键字，说明该方法可以被重写，sealed说明该类不可被继承，override重写基</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">类的方法，abstract申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">例化。）</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>C#中的委托是什么？事件是不是一种委托？&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="color:rgb(0,128,0);">委托可以把一个方法作为参数代入另一个方法。委托可以理解为指向一个函数的引用。是，是一种特殊的委托</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是Interface？它与Abstract Class有什么区别？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,128);">接口(Interface)是用来定义行为规范的，不会有具体实现，而抽象类除定义行为规范外，可以有部分实现，但一个类能实现多个接口，但只能继承一个父类</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是反射?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,128);">程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,128);">动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类型的</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(128,0,128);">字段属性。它是在运行时创建和使用类型实例</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>C#中所有对象共同的基类是什么？&nbsp;<br></strong><span style="color:rgb(255,128,0);">System.Object.</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>如何在C#中实现继承？&nbsp;<br></strong><span style="color:rgb(255,128,0);">在类名后加上一个冒号，再加上基类的名称。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>C#支持多重继承吗？&nbsp;<br></strong><span style="color:rgb(255,128,0);">不支持。可以用接口来实现。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>被protected修饰的属性/方法在何处可以访问？&nbsp;<br></strong><span style="color:rgb(255,128,0);">在继承或间接继承与这个类的子类中可以访问。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>私有成员会被继承么？&nbsp;<br></strong><span style="color:rgb(255,128,0);">会，但是不能被访问。所以看上去他们似乎是不能被继承的，但实际上确实被继承了。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>C#提供一个默认的无参构造函数，当我实现了另外一个有一个参数的构造函数时，还想保留这个无参数的构</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>造函数。这样我应该写几个构造函数？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">两个，一旦你实现了一个构造函数，C#就不会再提供默认的构造函数了，所以需要手动实现那个无参构造</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">函数。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>重载和覆写有什么区别？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">重载是方法的名称相同,不同的参数类型，不同的参数个数，不同的参数顺序。覆写提供了子类中改变父类方法行为的实现(是进行基类中函数的重写)。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>在方法定义中，virtual有什么含义？</strong>&nbsp;<br> 答：<span style="color:rgb(0,64,0);">被virtual修饰的方法可以被子类覆写</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>能够将非静态的方法覆写成静态方法吗？</strong>&nbsp;<br> 答：<span style="color:rgb(0,128,0);">不能，覆写方法的签名必须与被覆写方法的签名保持一致，除了将virtual改为override。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>可以覆写私有的虚方法吗？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">不可以，甚至子类中无法访问父类中的私有方法</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>能够阻止某一个类被其他类继承吗？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">可以，使用关键字sealed</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>能够实现允许某个类别继承，但不允许其中的某个方法被覆写吗？</strong>&nbsp;<br> 答：<span style="color:rgb(0,128,0);">可以，标记这个类为public，并标记这个方法为sealed。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>如何区别重载方法？</strong>&nbsp;<br><span style="color:rgb(0,128,0);">不同的参数类型，不同的参数个数，不同的参数顺序</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"></span>&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>简述 private、 protected、 public、 internal 修饰符的访问权限。&nbsp;<br></strong><span style="color:rgb(0,128,0);">private : 私有成员, 在类的内部才可以访问。&nbsp;<br> protected : 保护成员，该类内部和继承类中可以访问。&nbsp;<br> public : 公共成员，完全公开，没有访问限制。&nbsp;<br> internal: 在同一命名空间内可以访问。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>new的两种用法</strong>&nbsp;<br> 答：<span style="color:rgb(0,128,0);">实例话对象，隐藏基类方法。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>.new有几种用法</strong>&nbsp;<br> 第一种<span style="color:rgb(255,0,0);">:new Class();</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">第二种:<span style="color:rgb(255,0,0);">覆盖方法</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">public new XXXX(){}</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">第三种:<span style="color:rgb(255,0,0);">new 约束指定泛型类声明中的任何类型参数都必须有公共的无参数构造函数</span>。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">3.datagrid.datasouse可以连接什么数据源 [dataset,datatable,dataview]</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,0,255);">dataset,datatable,dataview , IList</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>类成员有( )种可访问形式</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">可访问性：<span style="color:rgb(0,128,0);">public ,protected ,private,internal</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>用sealed修饰的类有什么特点&nbsp;</strong><br><span style="color:rgb(0,128,0);">sealed 修饰符用于防止从所修饰的类派生出其它类。如果一个密封类被指定为其他类的基类，则会发生编译时错误。&nbsp;<br> 密封类不能同时为抽象类。&nbsp;<br> sealed 修饰符主要用于防止非有意的派生，但是它还能促使某些运行时优化。具体说来，由于密封类永</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">远不会有任何派生类，所以对密封类的实例的虚拟函数成员的调用可以转换为非虚拟调用来处理。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>虚函数的用法</strong>&nbsp;<br> 答：&nbsp;<br><span style="color:rgb(0,128,0);">1)virtual指明一成员函数为虚函数,而virtual仅用于类的定义里,在类外可不加此关键字.&nbsp;<br> 2)一个类的成员函数被定义为虚函数时,子类该函数仍保持虚函数特征.&nbsp;<br> 3)子类覆盖此函数时,定义里可不加virtual关键字,但函数声明要和基类的完全一致!且此声明是必须的.&nbsp;<br> 4)不是纯虚函数时,父类的虚函数必须要实现; 而若将父类的虚函数设定为纯虚函数时,子类必需要覆盖之而且必</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">须要实现之!</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>委托与事件的用法</strong>&nbsp;<br> 答：<span style="color:rgb(0,128,0);">public delegate void handels();//返回值是void，没有参数&nbsp;<br> public event handels eventHandels;&nbsp;<br> his.eventHandels = new handels(fun);&nbsp;<br> public void fun()&nbsp;<br> &nbsp;&nbsp;&nbsp; { }</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>传入某个属性的SET方法的隐含参数的名称是什么？&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">value，它的类型和属性所声明的类型相同。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>string是值类型还是引用类型?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">引用类型</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>String类与StringBuilder类有什么区别？为什么在.Net类库中要同时存在这2个类？(简答)</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">stringBuilder比string更节约内存,所以stringBuilder更快</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">String 对象是不可改变的。每次使用 System.String 类中的方法之一或进行运算时（如赋值、拼接等）时，都要</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。而 StringBuilder 则不会。在需要对字</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">符串执行重复修改的情况下，与创建新的 String 对象相关的系统开销可能会非常昂贵。如果要修改字符串而不</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">创建新的对象，则可以使用 System.Text.StringBuilder 类。例如，当在一个循环中将许多字符串连接在一起时</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">，使用 StringBuilder 类可以提升性能。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"><strong><span style="color:rgb(64,0,64);">System.String 和System.StringBuilder有什么区别？</span></strong>&nbsp;<br> System.String是不可变的字符串。System.StringBuilder存放了一个可变的字符串，并提供一些对这个字符串修</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">改的方法。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>在C＃中，string str = null 与 string str = “” 请尽量使用文字或图象说明其中的区别。&nbsp;<br></strong>答：<span style="color:rgb(0,0,255);">string str = null 是不给他分配内存空间,而string str = "" 给它分配长度为空字符串的内存空间。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是装箱和拆箱？</strong>&nbsp;<br> 答：<span style="color:rgb(128,0,0);">从值类型接口转换到引用类型装箱。从引用类型转换到值类型拆箱。装箱（boxing）是将值类型的数据转化成引用类型，int i=3; object o = i ;便是装箱过程，而拆箱(unboxing)是将饮用类型数据转换值类型,比如int j = (int)o；属于拆箱</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>ASP.net的身份验证方式有哪些？分别是什么原理？</strong>&nbsp;<br> 答：<span style="color:rgb(0,0,160);">Windwos(默认)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用IIS...From(窗体)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用帐户....Passport(密钥)</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Session有什么重大BUG，微软提出了什么方法加以解决？</strong>&nbsp;<br> 答：<span style="color:rgb(0,128,0);">是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>c#中的三元运算符是&nbsp;<span style="color:rgb(255,0,0);">？：</span></strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">.能用foreach遍历访问的对象需要实现<strong><span style="color:rgb(255,0,0);">()&nbsp;</span></strong>接口或声明 (&nbsp;<strong><span style="color:rgb(255,0,0);">GetEnumerator</span></strong>)方法的类型。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>.&lt;%# %&gt; 和 &lt;% %&gt; 有什么区别？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&lt;%# %&gt;<span style="color:rgb(128,128,0);">表示绑定的数据源</span>&nbsp;&lt;% %&gt;<span style="color:rgb(128,128,0);">是服务器端代码块 常量</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>在.net（C# or vb.net）中如何获得当前窗体或控件的句柄，特别是控件本身的句柄（请列举）</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">this(C#) Me(vb.net).</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>.C#可否对内存进行直接的操作？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在.net下，.net引用了垃圾回收（GC）功能，它替代了程序员 不过在C#中，不能直接实现Finalize方法，而是在析构函数中调用基类的Finalize()方法</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>DateTime是否可以为null?</strong>&nbsp;<span style="color:rgb(0,128,0);">不能，因为其为Struct类型，而结构属于值类型，值类型不能为null,只有引用类型才能被赋值null</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>DateTime.Parse(myString); 这行代码有什么问题？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">有问题，当myString不能满足时间格式要求的时候，会引发异常，建议使用DateTime.TryParse()&nbsp;<br></span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>net的错误处理机制是</strong>:</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">采用try-&gt;catch-&gt;finally结构，</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>为什么不提倡catch(Exception)&nbsp;<br></strong><span style="color:rgb(0,128,0);">try..catch在出现异常的时候影响性能; 应该捕获更具体得异常，比如IOExeception,OutOfMemoryException等</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>catch(Exception e){throw e;}和catch(Exception e){throw;}的区别</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">将发生的异常对象抛出，另一个只是抛出异常，并没有抛出原异常对象）</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>error和exception区别：</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">error&nbsp;<span style="color:rgb(0,128,0);">表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">exception&nbsp;<span style="color:rgb(0,128,0);">表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>.UDP连接和TCP连接的异同</strong>&nbsp;<br> 答:前者只管传,不管数据到不到,无须建立连接.后者保证传输的数据准确,须要连结.</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>请解释转发与跳转的区别&nbsp;<br></strong>转发就是服务端的跳转A页面提交数据到B页面,B页面进行处理然后从服务端跳转到其它页面&nbsp;<br> 跳转就是指客户端的跳转</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>使用ASMX的XML Web服务与使用SOAP的.NET Remoting的区别?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">Web服务使用的消息机制，而Remoting采用的RPC. Web Service能用于不同平台，不同语言，Remoting只适用</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">于.Net。效率上Remoting高于Xml Web Service</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>类型系统是由XMLSchema表示的吗？CLS是XMLSchema表示的吗？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">不清楚</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>从概念上阐述前期绑定（early-binding）和后期绑定（late-binding）的区别?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">这个就像是强弱类型的比较相似，前期绑定是在编译的时候就确定了要绑定的数据，而后期绑定是在运行的时候</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">才填充数据。所以前期绑定如果失败，会在编译时报编译错误，而后期绑定失败只有在运行时的时候才发生</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>调用Assembly.Load算静态引用还是动态引用？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">动态</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;<strong>列举一下你所了解的XML技术及其应用</strong>&nbsp;<br> 答：保存配置,站与站之间的交流,WEB SERVICE。以及与数据库的数据交互等地方都要用它.&nbsp;<br> 7.如何理解委托？&nbsp;<br> 答：&nbsp;<br> 相当于函数指针,定义了委托就可以在不调用原方法名称的情况下调用那个方法.&nbsp;<br> 委托具有以下特点：&nbsp;<br> 委托类似于 C++ 函数指针，但它是类型安全的。&nbsp;<br> 委托允许将方法作为参数进行传递。&nbsp;<br> 委托可用于定义回调方法。&nbsp;<br> 委托可以链接在一起；例如，可以对一个事件调用多个方法。&nbsp;<br> 方法不需要与委托签名精确匹配。有关更多信息，请参见协变和逆变。&nbsp;<br> C# 2.0 版引入了匿名方法的概念，此类方法允许将代码块作为参数传递，以代替单独定义的方法。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>简述你对XML Web Service的原理的认识？</strong>&nbsp;<br> 答：利用SOAP(简单对象访问协议)在http上执行远程方法的调用，也可以使用WSDL（Web服务描述语言）来</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">完成完整的描述Web服务，然后用UDDI注册各个服务提供商提供的服务，以便共享他们。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么叫应用程序域？</strong>&nbsp;<br> 答：应用程序域可以理解为一种轻量级进程。起到安全的作用。占用资源小。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>CTS、CLS、CLR分别作何解释？&nbsp;<br></strong>答：CTS：通用语言系统。CLS：通用语言规范。<span style="color:rgb(255,128,0);">CLR：公共语言运行库。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是受管制的代码？</strong>&nbsp;<br> 答：unsafe：非托管代码。不经过CLR运行。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是强类型系统？</strong>&nbsp;<br> 答：RTTI：类型识别系统。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是Code-Behind技术？</strong>&nbsp;<br> 答：代码后植。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>在.net中，配件的意思是？&nbsp;<br></strong>答：程序集。（中间语言，源数据，资源，装配清单）</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>常用的调用WebService的方法有哪些？</strong>&nbsp;<br> 答：1.使用WSDL.exe命令行工具。&nbsp;<br> &nbsp;&nbsp;&nbsp; 2.使用VS.NET中的Add Web Reference菜单选项</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>net Remoting 的工作原理是什么？&nbsp;<br></strong>答：服务器端向客户端发送一个进程编号，一个程序域编号，以确定对象的位置。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>O/R Mapping 的原理&nbsp;<br></strong>答：<span style="color:rgb(0,128,0);">利用反射，配置将对象和数据库表映射</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>remoting和webservice两项技术的理解以及实际中的应用。</strong>&nbsp;<br> 答：WS主要是可利用HTTP，穿透防火墙。而Remoting可以利用TCP/IP，二进制传送提高效率。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>out保留字怎么使用，什么时候使用</strong>&nbsp;<br> 答：有时为了从一个函数中返回多个值，我们需要使用out关键字，把输出值赋给通过引用传递给方法的变量（也就是参数）。但C#要求变量再被引用的前必须初始化。在调用该方法时，还需要添加out关键字</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>PDB是什么东西? 在调试中它应该放在哪里？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">PDB是用于保存调试和项目状态信息的文件，在debug的时候将产生pdb文件，调试的时候应该放在和对应应用</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">程序集相同目录。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>什么是反射?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够动态的</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类型的字段属性。它</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">是在运行时创建和使用类型实例&nbsp;</span><span style="color:rgb(0,128,0);">&nbsp;</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>概述反射和序列化</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">反射:<span style="color:rgb(0,0,255);">程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,0,255);">象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,0,255);">可以调用类型的方法或访问其字段和属性</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">序列化:<span style="color:rgb(0,0,160);">序列化是将对象转换为容易传输的格式的过程。例如，可以序列化一个对象，然后使用 HTTP 通</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,0,160);">过 Internet 在客户端和服务器之间传输该对象。在另一端，反序列化将从该流重新构造对象。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>11)&nbsp; XmlSerializer是如何工作的？使用这个类的进程需要什么ACL权限？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">我只知道XmlSerializer是将对象的属性和字段进行序列化和反序列化的，序列化成为xml数据，反序列化再将xml</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">转换成对象。应该至少需要ACL权限中的读权限.</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>23）XmlSerializer使用的针对属性的模式有什么好处？解决了什么问题？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">只序列化有用的数据，而不是序列化整个对象。实现没必要的数据冗余，和提升序列化时的性能。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">26.根据委托(delegate)的知识，请完成以下用户控件中代码片段的填写：&nbsp;<br> namespace test&nbsp;<br> {&nbsp;<br> public delegate void OnDBOperate();&nbsp;<br> public class UserControlBase : System.Windows.Forms.UserControl&nbsp;<br> {&nbsp;<br> public event OnDBOperate OnNew;&nbsp;<br> privatevoidtoolBar_ButtonClick(objectsender,System.Windows.Forms.ToolBarButtonClickEventArgs e)&nbsp;<br> {&nbsp;<br> if(e.Button.Equals(BtnNew))&nbsp;<br> {&nbsp;<br> //请在以下补齐代码用来调用OnDBOperate委托签名的OnNew事件。&nbsp;<br> }&nbsp;<br> }&nbsp;<br> }&nbsp;<br> 答：if( OnNew != null )&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; OnNew( this, e );</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">27.分析以下代码，完成填空&nbsp;<br> string strTmp = "abcdefg某某某";&nbsp;<br> int i= System.Text.Encoding.Default.GetBytes(strTmp).Length;&nbsp;<br> int j= strTmp.Length;&nbsp;<br> 以上代码执行完后，i= j=&nbsp;<br> 答：i=13,j=10</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>28.SQLSERVER服务器中，给定表 table1 中有两个字段 ID、LastUpdateDate，ID表示更新的事务号，</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>LastUpdateDate表示更新时的服务器时间，请使用一句SQL语句获得最后更新的事务号&nbsp;<br></strong>答：Select ID FROM table1 Where LastUpdateDate = (Select MAX(LastUpdateDate) FROM table1)</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">29.根据线程安全的相关知识，分析以下代码，当调用test方法时i&gt;10时是否会引起死锁?并简要说明理由。&nbsp;<br> public void test(int i)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp; lock(this)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp; if (i&gt;10)&nbsp;<br> &nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp; i--;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp; test(i);&nbsp;<br> &nbsp;&nbsp; }&nbsp;<br> }&nbsp;<br> }&nbsp;<br> 答：不会发生死锁，（但有一点int是按值传递的，所以每次改变的都只是一个副本，因此不会出现死锁。但如果</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">把int换做一个object，那么死锁会发生）</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>3） 什么叫圈复杂度（cyclomatic complexity）？为什么它很重要？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">不知道，望指教 ？</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>4） 写一个标准的lock()，在访问变量的前后创建临界区，要有"双重检查"，</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">lock的使用&nbsp;<br> &nbsp; public void LockTest()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object lockObj = new Object();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (lockObj)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>5） 什么叫FullTrust？放入GAC的assembly是否是FullTrust的?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">FullTrust完全信任。放入GAC中的Assembly是否FullTrust我的理解不是。我理解FullTrust是可以通过代码设定的</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>6） 代码加上需要安全权限的特性有什么好处？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">可以更加灵活的设置对代码的访问权限，实现代码级保护。？这点不是特清楚，有明白的给讲解下</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>7） gacutil /l | find /i "Corillian" 这句命令的作用是什么？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">全局程序集缓存中如果有Corillian就更新该程序集，没有就安装</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>8） sn -t foo.dll 这句命令是干嘛的？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">显示程序集foo.dll的公钥标记</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>9） DCOM需要防火墙打开哪些端口？端口135是干嘛用的？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">135端口，因为DCOM的端口号是随机分配的，默认情况下，会分配1024以上的端口号，所以默认情况下,DCOM</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">不能穿越防火墙。因为根本不晓得开哪个端口。但有解决办法可以使DCOM分配的端口号固定，135是远程过程</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">调用(RPC)的默认端口</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>10）对比OOP和SOA，它们的目的分别是什么？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">我想OOP和SOA应该没有对比性吧。OOP是一种编程模型，强调将复杂的逻辑分解出小的模块，特性是继承，封</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">装和多态 。而SOA是一个技术框架，技术框架和编程模型应该说不是一码事吧？SOA的思想是将业务逻辑封装</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">成服务或者中间件提供给应用程序来调用，当然其组件化思想是继承和发扬了OOP的优点。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>13）Debug.Write和Trace.Write有什么不同？何时应该使用哪一个？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Debug.Write是调试的时候向跟踪窗口输出信息。当编译模式为debug的时候才有效，为release的时</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">候Debug.Write在编译的时候会忽略,而Trace则是在debug和release两种模式下均可以向跟踪窗口输出信息。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>14）Debug Build和Release Build的区别，是否会有明显的速度变化？请说明理由。</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Debug会产生pdb文件，release不会。Debug用于开发时的调试，不能要于部署，而release用于部署.debug编</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">译一些特殊代码，比如#IFDEBUG Debug.Write等，而Release则会将那些特殊标记省略</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>15）JIT是以assembly为单位发生还是以方法为单位发生？这对于工作区有何影响?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">方法，道理很简单，因为对于一次运行，很可能只用到一个程序集中极少数类型和对象，而大部分可能并不会被</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">使用，此时CLR傻乎乎的给整个程序集都给Compile了，CLR不是傻疯了么&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>17）a.Equals(b)和a == b一样吗？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">不一样。a.Equals(b)表示a与b一致， a==b表示a与b的值相等</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>18）在对象比较中，对象一致和对象相等分别是指什么？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">对象一致是指两个对象是同一个对象，引用相同。而对象相等是指两个对象的值相同，但引用不一定相同</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>19）在.NET中如何实现深拷贝（deep copy）？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">实现IClonable接口</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>20）请解释一下IClonable</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">IClonable方法是实现深度复制的接口，实现它应该能深度复制一个对象出来。深度复制的特征的调用对象的构造</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">方法，创建新的对象，包括创建对象中嵌套的引用对象的新实例。而Shadow复制则不同，是浅表复制，不重新</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">创建新实例。浅表复制的实现是Object.MemberWiseClone().</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">深度复制(Deep Copy)与浅表复制(Shadow Copy)的比较&nbsp;<br> &nbsp; public class Name&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string FirstName;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string LastName;&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; public class Person:ICloneable&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Name PersonName;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public string Email;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /**//// &lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Deep Copy的例子&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Object Clone()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Person p = new Person();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.Email = this.Email;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.PersonName = new Name();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.PersonName.FirstName = this.PersonName.FirstName;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.PersonName.LastName = this.PersonName.LastName;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return p;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void ChangLastName(string lastName)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.PersonName.LastName = lastName;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void Main()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Person p = new Person();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.PersonName = new Name();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.PersonName.LastName = "jill";&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.PersonName.FirstName = "zhang";&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.Email = "jillzhang@126.com";&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Person sameNamePerson = p.Clone() as Person;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sameNamePerson.ChangLastName("clr_");&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(p.PersonName.LastName);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(sameNamePerson.PersonName.LastName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Person samePerson = p.MemberwiseClone() as Person;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; samePerson.ChangLastName("Shadow");</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(p.PersonName.LastName);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(sameNamePerson.PersonName.LastName);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Read();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>24）为什么不应该在.NET中使用out参数？它究竟好不好?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">我挺喜欢用out参数的，特别是当函数需要有多于1个返回的时候，我比较愿意用out，至于它好不好没研究过 ？</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>25）特性能够放到某个方法的参数上？如果可以，这有什么用？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">可以，作用可以对参数有进一步限定，比如输入参数为int类型，可以通过允许AttributeTargets=ParameterInfo</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">的Attribute自定义实现来限定输入参数的大小，比如当输入参数小于100的时候便抱错。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">对方法的参数设置Attribute的例子&nbsp;<br> &nbsp; [AttributeUsage(AttributeTargets.Parameter)]&nbsp;<br> &nbsp;&nbsp;&nbsp; public class ParameterAtt : Attribute&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int Min = 100;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp; public class AttributeTest&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void TestMethod([ParameterAtt(Min = 100)] int par1)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParameterInfo para = MethodInfo.GetCurrentMethod().GetParameters()[0];&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParameterAtt att = ParameterAtt.GetCustomAttribute(para, typeof(ParameterAtt)) as</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">ParameterAtt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (att.Min &gt; par1)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new Exception("要求para1最小为" + att.Min);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">9.执行下面代码后：</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">String strTemp ="abcdefg 某某某"；</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Int i System.Text.Encoding.Default.GetBytes(strTemp).Length;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Int j = strTemp.Length;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">问：i=(14 ) ；j=(11 )</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">i=(14 ) ；j=(11 ) 中文两个字节</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>12.概述.NET里对 remoting 和 webservice 两项技术的理解和实际中的应用。</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">远程逻辑调用，remoing接口只能用在.net中</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>13.什么是code-behind技术</strong>&nbsp;<br> codebehind是指代码和用户界面分开&nbsp;<br> aspx and cs</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>9.&nbsp; 如何给服务器端控件增加客户端脚本。&nbsp;<br></strong>答：控件的Attributes</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>6． 私有程序集与共享程序集有什么区别？&nbsp;<br></strong>一个私有程序集通常为单个应用程序所使用，并且存储于这个应用程序所在的目录之中，或此目录下面的一个子</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">目录中。共享程序集通常存储在全局程序集缓存（Global Assembly Cache）之中，这是一个由.NET运行时所维</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">护的程序集仓库。共享程序集通常是对许多应用程序都有用的代码库，比如.NET Framework类。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>10 .请解释ASP.NET中以什么方式进行数据验证&nbsp;<br></strong>Aps.net 中有非空验证，比较验证，取值范围验证，正则表达式验证及客户自定义验证五大控件，另还有一个集</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">中验证信息处理控件</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>11．WEB控件可以激发服务端事件，请谈谈服务端事件是怎么发生并解释其原理？自动传回是什么？为什么要</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>使用自动传回。</strong>&nbsp;<br> 在web控件发生事件时，客户端采用提交的形式将数据交回服务端，服务端先调用Page_Load事件,然后根据传</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">回的状态信息自动调用服务端事件自动传回是当我们在点击客户端控件时，采用提交表单的形式将数据直接传回</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">到务端&nbsp;<br> 只有通过自动传回才能实现服务端事件的机制，如果没有自动回传机制就只能调用客户端事件，而不能调用服务</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">端事件</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>13．&nbsp; 请解释web.config文件中的重要节点</strong>&nbsp;<br><span style="color:rgb(0,128,0);">appSettings包含自定义应用程序设置。&nbsp;<br> system.web 系统配置&nbsp;<br> compilation动态调试编译设置&nbsp;<br> customErrors自定义错误信息设置&nbsp;<br> authentication身份验证,此节设置应用程序的身份验证策略。&nbsp;<br> authorization授权, 此节设置应用程序的授权策略.</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>14．&nbsp; 请解释ASP。NET中的web页面与其隐藏类之间的关系？</strong>&nbsp;<br> 一个ASP.NET页面一般都对应一个隐藏类,一般都在ASP.NET页面的声明中指定了隐藏类例如一个页面Tst1.aspx</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">的页面声明如下&nbsp;<br> &lt;%@ Page language="c#" Codebehind="Tst1.aspx.cs" AutoEventWireup="false" Inherits="T1.Tst1" %&gt;&nbsp;<br> Codebehind="Tst1.aspx.cs" 表明经编译此页面时使用哪一个代码文件&nbsp;<br> Inherits="T1.Tst1" 表用运行时使用哪一个隐藏类</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>15．&nbsp; 什么是viewstate，能否禁用？是否所用控件都可以禁用?</strong>&nbsp;<br> Viewstate是保存状态的一种机制，EnableViewState属性设置为false即可禁用</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>16．&nbsp; 当发现不能读取页面上的输入的数据时很有可能是什么原因造成的？怎么解决？</strong>&nbsp;<br> 很有可能是在Page_Load中数据处理时没有进行Page的IsPostBack属性判断</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>17．&nbsp; 请解释什么是上下文对象，在什么情况下要使用上下文对象</strong>&nbsp;<br> 上下文对象是指HttpContext类的Current 属性，当我们在一个普通类中要访问内置对</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">象(Response,Request,Session,Server,Appliction等)时就要以使用此对象</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>&nbsp;</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>16、解释一下ajax及实现原理</strong>&nbsp;<br> 答：Ajax的核心是JavaScript对象XmlHttpRequest，它使您可以使用JavaScript向服务器提出请求并处理响应， 而不阻塞用户，异步请求。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>const和readonly有什么区别？&nbsp;<br></strong>const关键字用来声明编译时常量，readonly用来声明运行时常量。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>1、delegate是引用类型还是值类型？enum、int[]和string呢（难度系数40%）？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：delegate引用类型，enum值类型，int[]引用类型，string引用类型。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>2、我们知道new可以调用构造函数创建一个对象，那么new还有什么别的语法吗？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：隐藏基类相同签名方法，如果在C# 2.0中则还作为泛型构造函数约束。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>3、base这个关键字有哪几种语法？override呢？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：base两个语法，分别是调用基类构造函数和调用基类方法，override用于重写基类方法。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>4、请指出C#中是否有下列关键字？</strong>virtual、sealed、abstract、import、as、in、goto、final、Const、signed、</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">String（提示，仅指出C#中没有的即可）（难度系数50%）。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：没有的关键字：import、final、Const、signed、String</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>5、在循环：for( int i = 0; i &lt; 100; i++ ) Console.WriteLine( i );中，请指出i++的执行时机。</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：在Console.WriterLine( i );执行之后</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>6、试说明continue关键字的用处。</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：马上开始下一次循环，忽略循环体余下的语句</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>7、object是C#的关键字吗？请指出C#中有哪些类型关键字，如int、float。（提示，写得越多越好）。</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：是，object、int、uint、long、ulong、short、ushort、byte、sbyte、char、float、double、decimal、boo</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">l，如回答：enum、struct、class、delegate也算对。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>8、C#的XML文档注释中（以///开头的注释），&lt;summary&gt;标签用于描述什么？&lt;param&gt;标签呢？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：&lt;summary&gt;用于某个元素的概要说明，&lt;param&gt;用于某个方法的参数概要说明。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>9、我们知道[]是数组和索引器的访问操作符，但它还有一个语法，是什么？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">答案：特性（Attribute）</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>18.请叙述属性与索引器的区别。&nbsp;<br></strong>属性 索引器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; 通过名称标识。 通过签名标识。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; 通过简单名称或成员访问来访问。 通过元素访问来访问。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; 可以为静态成员或实例成员。 必须为实例成员。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; 属性的&nbsp;&nbsp; get&nbsp;&nbsp; 访问器没有参数。 索引器的&nbsp;&nbsp; get&nbsp;&nbsp; 访问器具有与索引器相同的形参表。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; 属性的&nbsp;&nbsp; set&nbsp;&nbsp; 访问器包含隐式&nbsp;&nbsp; value&nbsp;&nbsp; 参数。 除了&nbsp;&nbsp; value&nbsp;&nbsp; 参数外，索引器的&nbsp;&nbsp; set&nbsp;&nbsp; 访问器还具有与索引</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">器相同的形参表。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>1) 描述线程与进程的区别？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">线程(Thread)与进程（Process）二者都定义了某种边界，不同的是进程定义的是应用程序与应用程序之间的边</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">界，不同的进程之间不能共享代码和数据空间，而线程定义的是代码执行堆栈和执行上下文的边界。一个进程可</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">以包括若干个线程，同时创建多个线程来完成某项任务，便是多线程。而同一进程中的不同线程共享代码和数据</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">空间。用一个比喻来说，如果一个家庭代表一个进程，在家庭内部，各个成员就是线程，家庭中的每个成员都有</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">义务对家庭的财富进行积累，同时也有权利对家庭财富进行消费，当面对一个任务的时候，家庭也可以派出几个</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">成员来协同完成，而家庭之外的人则没有办法直接消费不属于自己家庭的财产。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>2) 什么是Windows服务，它的生命周期与标准的EXE程序有什么不同</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Windows服务是运行在windows后台指定用户下（默认System）的应用程序，它没有标准的UI界面，想比标准</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">的EXE程序，Windows服务是在服务开始的时候创建，而在服务结束的时候销毁，而且可以设置服务是否与操作</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">系统一起启动，一起关闭。它支持三种方式：１）自动方式 2）手动方式 ３）禁用 。自动方式的时</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">候，windows服务将在OS启动后自动启动运行，而手动方式则必须手工启动服务，禁用的情况下服务将不能被</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">启动。另外标准的EXE默认使用的当前登录的用户，而windows服务则默认使用System用户，这在对系统资源访</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">问的时候特别需要注意。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>3)&nbsp; Windows单个进程所能访问的最大内存量是多少？它与系统的最大虚拟内存一样吗？这对于系统设计有什么</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>影响？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">这个需要针对硬件平台，公式为单个进程能访问的最大内存量=2的处理器位数次方/2，比如通常情况下，32位</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">处理器下，单个进程所能访问的最大内存量为:232 /2 = 2G 。单个进程能访问的最大内存量是最大虚拟内存</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">的1/2，因为要分配给操作系统一半虚拟内存。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>4)&nbsp; 什么是强类型，什么是弱类型？哪种更好些？为什么?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类型。没有</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译型编程语</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，多用于解释型编</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">程语言，如javascript,vb等</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>5)&nbsp; PID是什么？在做系统的故障排除时如何使用它？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">PID是进程编号，在系统发现故障的时候，可以根据它寻找故障所发生的具体进程，并且可通过visual studio.net</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">等ide将故障进程附加到进程中进行调试(debug)</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>6)&nbsp; 单个TCP/IP端口上能够被多少个进程侦听？</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">１个</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>7)&nbsp; 什么是GAC？它解决了什么问题?</strong></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Gloal Assembly Cache，全局应用程序集缓存。它解决了几个程序共享某一个程序集的问题。不必再将那个被共</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">享的程序集拷贝到应用程序目录了，其实这道理很简单，.net应用程序在加载的时候，会首先查看全局应用程序</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">集缓存，如果有就可以直接使用，没有再到应用程序目录进行查找。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>1.白盒测试和黑盒测试</strong>&nbsp;<br> 答：<span style="color:rgb(0,128,0);">黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">分是否以经过检查。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">。因此黑盒测试又叫功能测试或数据驱动测试。黑盒测试主要是为了发现以下几类错误：</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">1、是否有不正确或遗漏的功能？</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">2、在接口上，输入是否能正确的接受？能否输出正确的结果？</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">3、是否有数据结构错误或外部信息（例如数据文件）访问错误？</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">4、性能上是否能够满足要求？</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">5、是否有初始化或终止性错误？</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。白盒</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">测试主要是想对程序模块进行如下检查：</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">1、对程序模块的所有独立的执行路径至少测试一遍。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">2、对所有的逻辑判定，取“真”与取“假”的两种情况都能至少测一遍。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">3、在循环的边界和运行的界限内执行循环体。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);">4、测试内部数据结构的有效性，等等。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>请简述一下用Socket进行同步通讯编程的详细步骤&nbsp;<br></strong><span style="color:rgb(0,0,255);">1、在应用程序和远程设备中使用协议和网络地址初始化套接字&nbsp;<br> 2、在应用程序中通过指定端口和地址建立监听&nbsp;<br> 3、远程设备发出连接请求&nbsp;<br> 4、应用程序接受连接产生通信scoket&nbsp;<br> 5、应用程序和远程设备开始通讯（在通讯中应用程序将挂起直到通讯结束）&nbsp;<br> 6、通讯结束，关闭应用程序和远程设备的Socket回收资源</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>OSI网络结构的七层模型及其核心思想是什么&nbsp;<br></strong><span style="color:rgb(0,128,0);">第七层：应用层&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp; 定义了用于在网络中进行通信和数据传输的接口 - 用户程式；&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp; 提供标准服务，比如虚拟终端、文件以及任务的传输和处理；&nbsp;<br> 第六层：表示层&nbsp;<br> &nbsp;&nbsp;&nbsp; 掩盖不同系统间的数据格式的不同性；&nbsp;<br> &nbsp;&nbsp;&nbsp; 指定独立结构的数据传输格式；&nbsp;<br> &nbsp;&nbsp;&nbsp; 数据的编码和解码；加密和解密；压缩和解压缩&nbsp;<br> 第五层：会话层&nbsp;<br> &nbsp;&nbsp;&nbsp; 管理用户会话和对话；&nbsp;<br> &nbsp;&nbsp;&nbsp; 控制用户间逻辑连接的建立和挂断；&nbsp;<br> &nbsp;&nbsp;&nbsp; 报告上一层发生的错误&nbsp;<br> 第四层：传输层&nbsp;<br> &nbsp;&nbsp;&nbsp; 管理网络中端到端的信息传送；&nbsp;<br> &nbsp;&nbsp;&nbsp; 通过错误纠正和流控制机制提供可靠且有序的数据包传送；&nbsp;<br> &nbsp;&nbsp;&nbsp; 提供面向无连接的数据包的传送；&nbsp;<br> 第三层：网络层&nbsp;<br> &nbsp;&nbsp;&nbsp; 定义网络设备间如何传输数据；&nbsp;<br> &nbsp;&nbsp;&nbsp; 根据唯一的网络设备地址路由数据包；&nbsp;<br> &nbsp;&nbsp;&nbsp; 提供流和拥塞控制以防止网络资源的损耗&nbsp;<br> 第二层：数据链路层&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 定义操作通信连接的程序；&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 封装数据包为数据帧；&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 监测和纠正数据包传输错误&nbsp;<br> 第一层：物理层&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 定义通过网络设备发送数据的物理方式；&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 作为网络媒介和设备间的接口；&nbsp;<br> &nbsp;&nbsp;&nbsp; 定义光学、电气以及机械特性。</span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"></span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(0,128,0);"></span></p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>2 几十上百万行，如何快速查询出表数据&nbsp;<br></strong>答：用分页存储过程&nbsp;<br> /*&nbsp;<br> &nbsp; 函数名称: GetRecordFromPage&nbsp;<br> &nbsp; 函数功能: 获取指定页的数据&nbsp;<br> &nbsp; 参数说明: @tblName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 包含数据的表名&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @fldName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关键字段名&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @PageSize&nbsp;&nbsp;&nbsp;&nbsp; 每页记录数&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @PageIndex&nbsp;&nbsp;&nbsp; 要获取的页码&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @OrderType&nbsp;&nbsp;&nbsp; 排序类型, 0 - 升序, 1 - 降序&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @strWhere&nbsp;&nbsp;&nbsp;&nbsp; 查询条件 (注意: 不要加 where)&nbsp;<br> */&nbsp;<br> CREATE PROCEDURE GetRecordFromPage&nbsp;<br> &nbsp;&nbsp;&nbsp; @tblName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(255),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 表名&nbsp;<br> &nbsp;&nbsp;&nbsp; @fldName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(255),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 字段名&nbsp;<br> &nbsp;&nbsp;&nbsp; @PageSize&nbsp;&nbsp;&nbsp;&nbsp; int = 10,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 页尺寸&nbsp;<br> &nbsp;&nbsp;&nbsp; @PageIndex&nbsp;&nbsp;&nbsp; int = 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 页码&nbsp;<br> &nbsp;&nbsp;&nbsp; @OrderType&nbsp;&nbsp;&nbsp; bit = 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 设置排序类型, 非 0 值则降序&nbsp;<br> &nbsp;&nbsp;&nbsp; @strWhere&nbsp;&nbsp;&nbsp;&nbsp; varchar(2000) = ''&nbsp; -- 查询条件 (注意: 不要加 where)&nbsp;<br> AS</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">declare @strSQL&nbsp;&nbsp; varchar(6000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 主语句&nbsp;<br> declare @strTmp&nbsp;&nbsp; varchar(1000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 临时变量&nbsp;<br> declare @strOrder varchar(500)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 排序类型</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">if @OrderType != 0&nbsp;<br> begin&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strTmp = '&lt;(select min'&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strOrder = ' order by [' + @fldName + '] desc'&nbsp;<br> end&nbsp;<br> else&nbsp;<br> begin&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strTmp = '&gt;(select max'&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strOrder = ' order by [' + @fldName +'] asc'&nbsp;<br> end</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">set @strSQL = 'select top ' + str(@PageSize) + ' * from ['&nbsp;<br> &nbsp;&nbsp;&nbsp; + @tblName + '] where [' + @fldName + ']' + @strTmp + '(['&nbsp;<br> &nbsp;&nbsp;&nbsp; + @fldName + ']) from (select top ' + str((@PageIndex-1)*@PageSize) + ' ['&nbsp;<br> &nbsp;&nbsp;&nbsp; + @fldName + '] from [' + @tblName + ']' + @strOrder + ') as tblTmp)'&nbsp;<br> &nbsp;&nbsp;&nbsp; + @strOrder</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">if @strWhere != ''&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strSQL = 'select top ' + str(@PageSize) + ' * from ['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @tblName + '] where [' + @fldName + ']' + @strTmp + '(['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @fldName + ']) from (select top ' + str((@PageIndex-1)*@PageSize) + ' ['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @fldName + '] from [' + @tblName + '] where ' + @strWhere + ' '&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @strOrder + ') as tblTmp) and ' + @strWhere + ' ' + @strOrder</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">if @PageIndex = 1&nbsp;<br> begin&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strTmp = ''&nbsp;<br> &nbsp;&nbsp;&nbsp; if @strWhere != ''&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @strTmp = ' where (' + @strWhere + ')'</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp; set @strSQL = 'select top ' + str(@PageSize) + ' * from ['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @tblName + ']' + @strTmp + ' ' + @strOrder&nbsp;<br> end</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">exec (@strSQL)</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">GO</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>三、数据库查询优化：&nbsp;<br></strong>1、多态性，多种数据库兼容；&nbsp;<br> 2、支持翻页，支持查询总数，页码显示；&nbsp;<br> 3、能处理100万以上数据量；&nbsp;<br> 答：&nbsp;<br> CREATE&nbsp;&nbsp; PROCEDURE&nbsp;&nbsp; dbo.LSP_SP_SelectElementByPage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; @SelectFields&nbsp;&nbsp; varchar(200),/*要查询的字段列表*/&nbsp;&nbsp;&nbsp;<br> &nbsp; @Condition&nbsp;&nbsp; varchar(300),/*查询条件*/&nbsp;&nbsp;&nbsp;<br> &nbsp; @PageSize&nbsp;&nbsp; int&nbsp;&nbsp; =20,/*页面大小，默认为20*/&nbsp;&nbsp;&nbsp;<br> &nbsp; @PageNumber&nbsp;&nbsp; int&nbsp;&nbsp; =1/*页号，默认为第一页*/&nbsp;&nbsp;&nbsp;<br> &nbsp; /*@PageCount&nbsp;&nbsp; int&nbsp;&nbsp; out返回满足条件的总页数*/&nbsp;&nbsp;&nbsp;<br> &nbsp; AS&nbsp;&nbsp;&nbsp;<br> &nbsp; begin&nbsp;&nbsp;&nbsp;<br> &nbsp; declare&nbsp;&nbsp; @count&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;<br> &nbsp; select&nbsp;&nbsp; @count&nbsp;&nbsp; =count(*)&nbsp;&nbsp; from&nbsp;&nbsp; lsp_t_elementInfo&nbsp;&nbsp;&nbsp;<br> &nbsp; if(@count&nbsp;&nbsp; %@PageSize=0)&nbsp;&nbsp;&nbsp;<br> &nbsp; set&nbsp;&nbsp; @count&nbsp;&nbsp; =&nbsp;&nbsp; @count/@PageSize&nbsp;&nbsp;&nbsp;<br> &nbsp; else&nbsp;&nbsp;&nbsp;<br> &nbsp; set&nbsp;&nbsp; @count&nbsp;&nbsp; =&nbsp;&nbsp; @count/@PageSize&nbsp;&nbsp; +1&nbsp;&nbsp;&nbsp;<br> &nbsp; select&nbsp;&nbsp; @count&nbsp;&nbsp; PageCount&nbsp;&nbsp;&nbsp;<br> &nbsp; select&nbsp;&nbsp; IDENTITY(int,1,1)&nbsp;&nbsp; as&nbsp;&nbsp; iid,ElementName,Type&nbsp;&nbsp; into&nbsp;&nbsp; #temptable&nbsp;&nbsp; from&nbsp;&nbsp; LSP_T_ElementInfo&nbsp;&nbsp;&nbsp;<br> &nbsp; select&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp; from&nbsp;&nbsp; #temptable&nbsp;&nbsp; where&nbsp;&nbsp; iid&nbsp;&nbsp; between&nbsp;&nbsp;&nbsp;&nbsp; @PageSize&nbsp;&nbsp; *&nbsp;&nbsp; (@PageNumber&nbsp;&nbsp; -1)&nbsp;&nbsp; and&nbsp;&nbsp; @PageSize&nbsp;&nbsp; *&nbsp;&nbsp; @PageNumber&nbsp;&nbsp;&nbsp;<br> &nbsp; end&nbsp;&nbsp;&nbsp;<br> &nbsp; GO</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>1.两个表，写查询语句，根据两个字段一个是升序，一个将序。&nbsp;<br> 答：<span style="color:rgb(255,128,0);">select * from a,b where a.字段1 ＝ b.字段1 order by a.字段2 asc,b.字段2 desc&nbsp;<br></span>2.根据第一题，每页面显示10条记录，在第25页时怎样显示&nbsp;<br></strong>答：&nbsp;<br> /*&nbsp;<br> &nbsp; 函数名称: GetRecordFromPage&nbsp;<br> &nbsp; 函数功能: 获取指定页的数据&nbsp;<br> &nbsp; 参数说明: @tblName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 包含数据的表名&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @fldName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关键字段名&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @PageSize&nbsp;&nbsp;&nbsp;&nbsp; 每页记录数&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @PageIndex&nbsp;&nbsp;&nbsp; 要获取的页码&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @OrderType&nbsp;&nbsp;&nbsp; 排序类型, 0 - 升序, 1 - 降序&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @strWhere&nbsp;&nbsp;&nbsp;&nbsp; 查询条件 (注意: 不要加 where)&nbsp;<br> */&nbsp;<br> CREATE PROCEDURE GetRecordFromPage&nbsp;<br> &nbsp;&nbsp;&nbsp; @tblName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(255),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 表名&nbsp;<br> &nbsp;&nbsp;&nbsp; @fldName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; varchar(255),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 字段名&nbsp;<br> &nbsp;&nbsp;&nbsp; @PageSize&nbsp;&nbsp;&nbsp;&nbsp; int = 10,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 页尺寸&nbsp;<br> &nbsp;&nbsp;&nbsp; @PageIndex&nbsp;&nbsp;&nbsp; int = 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 页码&nbsp;<br> &nbsp;&nbsp;&nbsp; @OrderType&nbsp;&nbsp;&nbsp; bit = 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 设置排序类型, 非 0 值则降序&nbsp;<br> &nbsp;&nbsp;&nbsp; @strWhere&nbsp;&nbsp;&nbsp;&nbsp; varchar(2000) = ''&nbsp; -- 查询条件 (注意: 不要加 where)&nbsp;<br> AS</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">declare @strSQL&nbsp;&nbsp; varchar(6000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 主语句&nbsp;<br> declare @strTmp&nbsp;&nbsp; varchar(1000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 临时变量&nbsp;<br> declare @strOrder varchar(500)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- 排序类型</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">if @OrderType != 0&nbsp;<br> begin&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strTmp = '&lt;(select min'&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strOrder = ' order by [' + @fldName + '] desc'&nbsp;<br> end&nbsp;<br> else&nbsp;<br> begin&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strTmp = '&gt;(select max'&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strOrder = ' order by [' + @fldName +'] asc'&nbsp;<br> end</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">set @strSQL = 'select top ' + str(@PageSize) + ' * from ['&nbsp;<br> &nbsp;&nbsp;&nbsp; + @tblName + '] where [' + @fldName + ']' + @strTmp + '(['&nbsp;<br> &nbsp;&nbsp;&nbsp; + @fldName + ']) from (select top ' + str((@PageIndex-1)*@PageSize) + ' ['&nbsp;<br> &nbsp;&nbsp;&nbsp; + @fldName + '] from [' + @tblName + ']' + @strOrder + ') as tblTmp)'&nbsp;<br> &nbsp;&nbsp;&nbsp; + @strOrder</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">if @strWhere != ''&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strSQL = 'select top ' + str(@PageSize) + ' * from ['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @tblName + '] where [' + @fldName + ']' + @strTmp + '(['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @fldName + ']) from (select top ' + str((@PageIndex-1)*@PageSize) + ' ['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @fldName + '] from [' + @tblName + '] where ' + @strWhere + ' '&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @strOrder + ') as tblTmp) and ' + @strWhere + ' ' + @strOrder</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">if @PageIndex = 1&nbsp;<br> begin&nbsp;<br> &nbsp;&nbsp;&nbsp; set @strTmp = ''&nbsp;<br> &nbsp;&nbsp;&nbsp; if @strWhere != ''&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set @strTmp = ' where (' + @strWhere + ')'</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp; set @strSQL = 'select top ' + str(@PageSize) + ' * from ['&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @tblName + ']' + @strTmp + ' ' + @strOrder&nbsp;<br> end</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">exec (@strSQL)</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">GO</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>2.写出一条Sql语句： 取出表A中第31到第40记录（SQLServer, 以自动增长的ID作为主键,&nbsp; 注意：ID可能不是连续的。）&nbsp;<br></strong>select top 10 * from A where id not in (select top 30 id from A)&nbsp;<br> 解2: select top 10 * from A where id &gt; (select max(id) from (select top 30 id from A )as A)</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>3.public class c{ public c(string a) : this() {;}; public c() {;} } 解释第一个构造函数中发生了什么？这个构造函数有什么用?&nbsp;<br></strong>（第一个构造函数调用了第二个构造函数，这个构造函数构造了一个c对象的实例。）</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>4.一个长度为10000的字符串，通过随机从a-z中抽取10000个字符组成。请用c＃语言编写主要程序来实现。&nbsp;<br></strong>答：&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using System.Text;&nbsp;<br> StringBuilder sb = new StringBuilder(0, 10000);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string strABC = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z";&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string[] ABC = strABC.Split(',');&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len = ABC.Length;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Random rd = new Random();&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 10000; i++)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sb.Append(ABC[rd.Next(len)]);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>5.产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复。&nbsp;<br></strong>int[] intArr=new int[100];&nbsp;<br> ArrayList myList=new ArrayList();&nbsp;<br> Random rnd=new Random();&nbsp;<br> while(myList.Count&lt;100)&nbsp;<br> {&nbsp;<br> int num=rnd.Next(1,101);&nbsp;<br> if(!myList.Contains(num))&nbsp;<br> myList.Add(num);&nbsp;<br> }&nbsp;<br> for(int i=0;i&lt;100;i++)&nbsp;<br> intArr[i]=(int)myList[i];</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>2.如何把</strong><strong>一个Array复制到ArrayList里&nbsp;<br></strong>答：&nbsp;<br> foreach( object o in array )arrayList.Add(o);</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>8.用C#写一段选择排序算法，要求用自己的编程风格。&nbsp;<br></strong>答：private int min;&nbsp;<br> &nbsp;&nbsp;&nbsp; public void xuanZhe(int[] list)//选择排序&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; list.Length - 1; i++)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min = i;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int j = i + 1; j &lt; list.Length; j++)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (list[j] &lt; list[min])</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min = j;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = list[min];</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list[min] = list[i];</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list[i] = t;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>4.写一个函数计算当参数为N的值:1-2+3-4+5-6+7……+N</strong>&nbsp;<br> 答：public int returnSum(int n)&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int sum = 0;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 1; i &lt;= n; i++)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int k = i;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i % 2 == 0)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = -k;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum = sum + k;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sum;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp; public int returnSum1(int n)&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int k = n;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n == 0)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n % 2 == 0)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = -k;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return aaa(n - 1) + k;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">7. 某一密码仅使用K、L、M、N、O共5个字母，密码中的单词从左向右排列，密码单词必须遵循如下规则 ：&nbsp;<br> （1） 密码单词的最小长度是两个字母，可以相同，也可以不同&nbsp;<br> （2） K不可能是单词的第一个字母&nbsp;<br> （3） 如果L出现，则出现次数不止一次&nbsp;<br> （4） M不能使最后一个也不能是倒数第二个字母&nbsp;<br> （5） K出现，则N就一定出现&nbsp;<br> （6） O如果是最后一个字母，则L一定出现&nbsp;<br> 问题一：下列哪一个字母可以放在LO中的O后面，形成一个3个字母的密码单词？&nbsp;<br> A) K B)L C) M D) N&nbsp;<br> 答案:B&nbsp;<br> 问题二：如果能得到的字母是K、L、M，那么能够形成的两个字母长的密码单词的总数是多少？&nbsp;<br> A)1个 B)3个 C)6个 D）9个&nbsp;<br> 答案:A&nbsp;<br> 问题三：下列哪一个是单词密码？&nbsp;<br> A) KLLN B) LOML C) MLLO D)NMKO&nbsp;<br> 答案:C</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>62-63=1 等式不成立，请移动一个数字（不可以移动减号和等于号），使得等式成立，如何移动？&nbsp;<br></strong>答案:62移动成2的6次方</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>17、列出常用的使用javascript操作xml的类包</strong>&nbsp;<br> 答：&nbsp;<br> XML.prototype.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");&nbsp;<br> XML.prototype.InitXML=InitXML;&nbsp;<br> XML.prototype.getFirstChild=getFirstChild;&nbsp;<br> XML.prototype.getLastChild=getLastChild;&nbsp;<br> XML.prototype.getChild=getChild;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 取得节点值&nbsp;<br> XML.prototype.getNodeslength=getNodeslength;&nbsp;&nbsp; // 最得节点下的子节点的个数&nbsp;<br> XML.prototype.getNode=getNode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 取得指定节点&nbsp;<br> XML.prototype.delNode=delNode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 删除指定节点,如果节点相同,则删除最前面的节点.&nbsp;<br> XML.prototype.getNodeAttrib=getNodeAttrib;&nbsp;&nbsp;&nbsp; // 取得节点的指定属性值.&nbsp;<br> XML.prototype.InsertBeforeChild=InsertBeforeChild;&nbsp; // 在指定节点之前插入一个节点.&nbsp;<br> XML.prototype.InsertChild=InsertChild;&nbsp;&nbsp;&nbsp;&nbsp; // 在指定节点下插入节点.&nbsp;<br> XML.prototype.setAttrib=setAttrib;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 设置指定属性的值.&nbsp;<br> XML.prototype.setNodeValue=setNodeValue;&nbsp;&nbsp;&nbsp; //&nbsp; 设置指定节点的值.&nbsp;<br> XML.prototype.CreateNodeS=CreateNodeS;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 创建一个指定名的节点．&nbsp;<br> XML.prototype.addAttrib=addAttrib;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; 为指定节点添加指定属性，并设置初值.&nbsp;<br> XML.prototype.FindString=FindString;&nbsp;&nbsp;&nbsp;&nbsp; // 在指定节点下查找字符串.</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>给定以下XML文件，完成算法流程图</strong>&lt;FileSystem&gt;&nbsp;<br> &lt; DriverC &gt;&nbsp;<br> &lt;Dir DirName=”MSDOS622”&gt;&nbsp;<br> &lt;File FileName =” Command.com” &gt;&lt;/File&gt;&nbsp;<br> &lt;/Dir&gt;&nbsp;<br> &lt;File FileName =”MSDOS.SYS” &gt;&lt;/File&gt;&nbsp;<br> &lt;File FileName =” IO.SYS” &gt;&lt;/File&gt;&nbsp;<br> &lt;/DriverC&gt;&nbsp;<br> &lt;/FileSystem&gt;&nbsp;<br> 请画出遍历所有文件名（FileName）的流程图(请使用递归算法)。&nbsp;<br> 答：&nbsp;<br> void FindFile( Directory d )&nbsp;<br> {&nbsp;<br> FileOrFolders = d.GetFileOrFolders();&nbsp;<br> foreach( FileOrFolder fof in FileOrFolders )&nbsp;<br> {&nbsp;<br> if( fof is File )&nbsp;<br> You Found a file;&nbsp;<br> else if ( fof is Directory )&nbsp;<br> FindFile( fof );&nbsp;<br> }&nbsp;<br> }</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>6.C#代码实现，确保windows程序只有一个实例（instance）&nbsp;<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///&lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///应用程序的主入口点。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///&lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STAThread]&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; staticvoid Main()&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //防止程序多次运行&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!OneInstance.IsFirst("GetPayInfo"))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show ("警告:程序正在运行中! 请不要重复打开程序!可在右下角系统栏找到!","程序错误提</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">示:",MessageBoxButtons.OK,MessageBoxIcon.Stop);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application.Run(new Form1());&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ******************* 防止程序多次执行 **************************&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicabstractclass OneInstance&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///&lt;summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///判断程序是否正在运行&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///&lt;/summary&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///&lt;param name="appId"&gt;程序名称&lt;/param&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ///&lt;returns&gt;如果程序是第一次运行返回True,否则返回False&lt;/returns&gt;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicstaticbool IsFirst(string appId)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool ret=false;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(OpenMutex(0x1F0001,0,appId)==IntPtr.Zero)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateMutex(IntPtr.Zero,0,appId);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret=true;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("Kernel32.dll",CharSet=CharSet.Auto)]&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; privatestaticextern IntPtr OpenMutex(&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint dwDesiredAccess, // access&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bInheritHandle,&nbsp;&nbsp;&nbsp; // inheritance option&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string lpName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object name&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("Kernel32.dll",CharSet=CharSet.Auto)]&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; privatestaticextern IntPtr CreateMutex(&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr lpMutexAttributes, // SD&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int bInitialOwner,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // initial owner&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string lpName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // object name&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;</p> 
    <p><font><span style="font-size:14px;"><br></span></font></p> 
    <p><font><span style="font-size:14px;"><br></span></font></p> 
    <p><font><span style="font-size:14px;"><br></span></font></p> 
    <p><font><span style="font-size:14px;">本文转自94cool博客园博客，原文链接：http://www.cnblogs.com/94cool/archive/2011/10/31/2229769.html，如需转载请自行联系原作者</span></font></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
