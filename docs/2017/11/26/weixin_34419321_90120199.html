<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>MPEG音频文件格式(包括MP3文件格式)详解 « NotBeCN</title>
  <meta name="description" content="             最近又在做MP3相关的程序，需要了解mp3的文件格式，于是就从网上找了一些资料，并将内容整理如下，加入了自己的一些理解。     　　MP3 文件是由帧(frame)构成的，帧是MP3 文件最小的组成单位。MP3 的全称应为MPEG1 Layer-3 音频文件，MPEG(Moving P...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/26/weixin_34419321_90120199.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">MPEG音频文件格式(包括MP3文件格式)详解</h1>
    <p class="post-meta">Nov 26, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>最近又在做MP3相关的程序，需要了解mp3的文件格式，于是就从网上找了一些资料，并将内容整理如下，加入了自己的一些理解。 </p> 
   <p>　　MP3 文件是由帧(frame)构成的，帧是MP3 文件最小的组成单位。MP3 的全称应为MPEG1 Layer-3 音频文件，MPEG(Moving Picture Experts Group)在汉语中译为活动图像专家组，特指活动影音压缩标准，MPEG 音频文件是MPEG1 标准中的声音部分，也叫MPEG 音频层，它根据压缩质量和编码复杂程度划分为三层，即 Layer-1、Layer2、Layer3，且分别对应MP1、MP2、MP3 这三种声音文件，并根据不同的用途，使用不同层次的编码。MPEG音频编码的层次越高，编码器越复杂，压缩率也越高，MP1 和MP2 的压缩率分别为4：1 和 6：1-8：1，而MP3 的压缩率则高达10：1-12：1，也就是说，一分钟CD 音质的音乐，未经压缩需要10MB的存储空间，而经过MP3 压缩编码后只有1MB 左右。不过MP3 对音频信号采用的是有损压缩方式，为了降低声音失真度，MP3 采取了“感官编码技术”，即编码时先对音频文件进行频谱分析，然后用过滤器滤掉噪音电平，接着通过量化的方式将剩下的每一位打散排列，最后形成具有较高压缩比的MP3 文件，并使压缩后的文件在回放时能够达到比较接近原音源的声音效果。</p> 
   <p><br> 一、MPEG音频压缩基础</p> 
   <p>　　在众多音频压缩方法中，这些方法在保持声音质量的同时尽量压缩数字音频使之占用更小的存储空间。MPEG压缩是该领域中效果最好的一个。这种压缩是有损压缩，这意味着，当运用这一方法压缩时肯定会丢失一部分音频信息。但是，由于压缩方法的控制很难发现这种损失。使用几个非常复杂和苛刻的数学算法，使得只有原始音频中几乎听不到的部分损失掉。这就给重要的信息剩下了更多的空间。通过这种方法可以将音频压缩12倍（可以选择压缩率），效果显著。正是应为他的质量，MPEG音频变得流行起来。<br> MPEG-1，MPEG-2和MPEG-4都是人们熟悉的MPEG标准，MP3只涉及到前两中，另外还有一个非官方标准MPEG-2.5用于扩展MPEG-2/LSF到更低的采样率。<br> MPEG-1音频（ISO/IEC 11172-3）描述了具有如下属性的三层音频编码：<br> 1或2个声道<br> 采样频率为32kHz，44.1kHz或48kHz<br> 位率从32kbps到448kbps<br> 每一层都有自己的优点。<br> MPEG-2音频（ISO/IEC 13818-3）有两个MPEG-1的扩展，通常叫做MPEG-2/LSF和MPEG-2/Multichannel<br> MPEG-2/LSF有如下特点：<br> 1或2个声道<br> 采样频率为MPEG-1的一半<br> 波特率从8kbps256kbps<br> MPEG-2/Mutichannel有如下特点：<br> 多达5个声道和1个LFE-通道（低频增强 不是重低音）<br> 同MPEG-1一样的采样频率<br> 5.1的最高波特率可能达到1Mbps</p> 
   <p>二、MPEG Layer3编/解码的基本原理</p> 
   <p>　　音乐CD具有44.1KHz 16Bits 立体声的音频质量，一张CD可以存储74分钟的歌曲(大约15首左右)。如何将这些歌曲无损或基本无损地进行压缩,以使在同样的媒体上存储更多的歌曲,一直困扰着软件业。当MPEG协会提出MPEG Audio Layer1～Layer3后，机会产生了。通过使用MPEG1 Layer3编码技术，制作者得以用大约12∶1的压缩率记录16KHz带宽的有损音乐信号。不过,同CD原声区别不大。人的听力系统具有非常优越的性能，其动态范围超过96dB。你既可以听到扣子掉在地上这样小的声音，也可以听到波音747的强大的轰鸣声。但当我们站在飞机场听着波音747的轰鸣时, 你还能分辨出扣子掉在地上的声音吗？不可能。人的听力系统适应声音的动态变化，人们对这种适应及屏蔽特性音质研究后得出对声音压缩非常有用的理论。人们很早以前就知道利用这种特性来为磁带录音降低噪音了(当没有音乐时嘶嘶声很容易听到，而当音乐信号电平很高时嘶嘶声不容易听到)。当声音较强时产生屏蔽效应。在阈值曲线下的噪音或小信号声音无法被人耳听到。在较强信号出现时，允许通过更多的信号。在此时增加被量化过的小信号数据(使用无用的位来携带更多的信息)可以达到一定程度的压缩的目的。通常情况下,MP3压缩器将原始声音通过FFT(快速傅立叶变换)变化到频域，然后通过一定的算法算出何种频率声音可以携带更多的信息。而在还原时解码器所需要做的仅仅是将其从频域再变换回来。 </p> 
   <p>三、整个MP3文件结构：</p> 
   <p>MP3文件大体分为三部分：TAG_V2(ID3V2)，Frame, TAG_V1(ID3V1)</p> 
   <p>ID3V2<br> 包含了作者，作曲，专辑等信息，长度不固定，扩展了ID3V1的信息量。<br><br> Frame</p> 
   <p>.</p> 
   <p>.</p> 
   <p>.</p> 
   <p>Frame<br> 一系列的帧，个数由文件大小和帧长决定</p> 
   <p>每个FRAME的长度可能不固定，也可能固定，由位率bitrate决定</p> 
   <p>每个FRAME又分为帧头和数据实体两部分</p> 
   <p>帧头记录了mp3的位率，采样率，版本等信息，每个帧之间相互独立<br><br> ID3V1<br> 包含了作者，作曲，专辑等信息，长度为128BYTE。<br></p> 
   <p><br> 四、MPEG音频帧格式 </p> 
   <p>　　一个MPEG音频文件是许多的称为帧的较小部分组成的，通常，帧是独立的组成部分。每一帧都拥有自己的头和音频信息。没有文件头。所以，我们可以剪切MPEG文件的任何部分并且能够正常播放（当然要分割到帧的结束处尽管许多程序会处理错误头）。在LayerIII中就并不是100%正确的。这是因为在MPEG-1LayerIII文件中的数据组织中，帧常常是互相关联的并且不能那样随便裁切。<br> 当你想读取MPEG文件的信息时，通常只找到第一帧就足够了，读取它的头信息然后假设其它帧是相同的就可以。但这也不是所有情况。变比特率的MPEG文件使用使用所谓比特变换，也就是说每一帧的比特率依照具体内容变化。这种方法没有减少声音质量的帧将应用较低的波特率。这样就允许更好的压缩质量的同时又保证了高质量的音质。<br> 帧头由每一帧的前4个字节（32位）组成。帧头的前11比特（或前12个位，见下文关于帧同步）总是固定的称作“帧同步”。因此，可以在整个文件中查找第一个帧同步（即：必须找到一个值为255的且其后跟着三到四个最高位置1的字节。）然后读取整个头检查值是否正确。关于头中每一个比特的具体含义应该验证那一个值的有效性可以操看下面的表格，如果存在被定义为保留，无效，损坏或不允许的值表明该头已经损坏。记住，光有这些是不够的，帧同步能在许多二进制文件里面的应用是很广的。而且，MPEG文件可能在开头包含可能有错误同步信息的垃圾，所以我们必须检查两个或者更多一些帧来确定我们现在读取的文件是一个MPEG文件。<br> 帧可能还有CRC校验。如果存在的话，CRC校验紧跟在帧头之后，长为16比特。CRC校验之后是音频数据。计算出帧长度，如果你需要读取其他头或者计算该帧的CRC值，可以使用它比较文件中读出来的帧。验证MPEG头的有效性这是一个非常好的方法。</p> 
   <p>1、帧头格式</p> 
   <p>下面是一个头内容图示，使用字符A到M表示不同的区域。在表格中你可以看到每一区域的详细内容。</p> 
   <p>　　AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM </p> 
   <p>符号i<br> 长度(bits)<br> 位置(bits)<br> 描述<br><br> A<br> 11<br> (31-21)<br> 帧同步（所有位置1）<br><br> B<br> 2<br> (20,19)<br> MPEG 音频版本ID<br> 00 – MPEG 2.5<br> 01 – 保留<br> 10 – MPEG 2 （ISO/IEC 13818-3）<br> 11 – MPEG 1 （ISO/IEC 11172-3）<br> 注：MPEG 2.5不是官方标准。帧头第20个比特用来表示2.5版本。不支持该版本的应用程序一般认为该比特位置位为帧同步位，也就是说帧同步（A）的长度为12而不是这里规定的11，这样B也就变成了1位（第19个位）。推荐使用该表的方法因为这样允许你可以区分三个版本以获得最高兼容性。<br><br> C<br> 2<br> (18,17)<br> Layer描述<br> 00 - 保留<br> 01 - Layer III<br> 10 - Layer II<br> 11 - Layer I<br><br> D<br> 1<br> (16)<br> 校验位<br> 0 - 紧跟帧头后有16位即2个字节用作CRC校验<br> 1 - 没有校验 <br><br> E<br> 4<br> (15,12)<br> 位率索引</p> 
   <p>索引值<br> MPEG 1<br> MPEG 2, 2.5 (LSF)<br><br> Layer I<br> Layer II<br> Layer III<br> Layer I<br> Layer II &amp; III<br><br> 0000<br> Free<br><br> 0001<br> 32<br> 32<br> 32<br> 32<br> 8<br><br> 0010<br> 64<br> 48<br> 40<br> 48<br> 16<br><br> 0011<br> 96<br> 56<br> 48<br> 56<br> 24<br><br> 0100<br> 128<br> 64<br> 56<br> 64<br> 32<br><br> 0101<br> 160<br> 80<br> 64<br> 80<br> 40<br><br> 0110<br> 192<br> 96<br> 80<br> 96<br> 48<br><br> 0111<br> 224<br> 112<br> 96<br> 112<br> 56<br><br> 1000<br> 256<br> 128<br> 112<br> 128<br> 64<br><br> 1001<br> 288<br> 160<br> 128<br> 144<br> 80<br><br> 1010<br> 320<br> 192<br> 160<br> 160<br> 96<br><br> 1011<br> 352<br> 224<br> 192<br> 176<br> 112<br><br> 1100<br> 384<br> 256<br> 224<br> 192<br> 128<br><br> 1101<br> 416<br> 320<br> 256<br> 224<br> 144<br><br> 1110<br> 448<br> 384<br> 320<br> 256<br> 160<br><br> 1111<br> Bad<br></p> 
   <p>注：所有值单位为kbps，而且1kbit=1000bit而不是1024bit</p> 
   <p>Free表示空闲，如果固定比特率（这种文件不能变换比特率）和上表定义的不同，应该有应用程序决定。这种情况的实现应该只用于内部目的因为第三方应用程序是没有办法找出正确比特率的。但是这么做并不是很重要况且还浪费精力。Bad表示该值无效。<br> MPEG文件可以有VBR。表示文件的比特率可以变化。我已经知道了两种惯用方法：<br> 比特率变换(bitrate switching)：每一帧都创建成不同的比特率。可以应用在任何层。LayerIII解码器必须支持该方法。LayerI和LayerII也可以支持。<br> 比特池(bit reservoir)：比特率可以使从前面的帧中借来的（受限），以便腾出空间来容纳输入信号部分。然而这样就导致各帧之间不再相互独立，意味着不能随便分割文件。这种方法只有LayerIII支持。</p> 
   <p>LyaerII中有一些不被允许比特率组合和模式。下表是允许的组合。</p> 
   <p>bitrate<br> allowed modes<br><br> free<br> all<br><br> 32<br> single channel<br><br> 48<br> single channel<br><br> 56<br> single channel<br><br> 64<br> all<br><br> 80<br> single channel<br><br> 96<br> all<br><br> 112<br> all<br><br> 128<br> all<br><br> 160<br> all<br><br> 192<br> all<br><br> 224<br> stereo, intensity stereo, dual channel<br><br> 256<br> stereo, intensity stereo, dual channel<br><br> 320<br> stereo, intensity stereo, dual channel<br><br> 384<br> stereo, intensity stereo, dual channel<br><br><br> F<br> 2<br> (11,10)<br> 采样频率（单位：Hz）</p> 
   <p>bits<br> MPEG1<br> MPEG2<br> MPEG2.5<br><br> 00<br> 44100<br> 22050<br> 11025<br><br> 01<br> 48000<br> 24000<br> 12000<br><br> 10<br> 32000<br> 16000<br> 8000<br><br> 11<br> 保留<br><br><br> G<br> 1<br> (9)<br> 填充位<br> 0 – 没有填充 <br> 1 – 填充了一个额外的空位<br> 填充用来达到正确的比特率。例如：128k 44.1kHz LayerII使用了很多418bit或417bit长的帧来达到正确的128k比特率。LyaerI的空位有32bit长，LayerII和LayerIII的空位有8bit长。</p> 
   <p> <br> H<br> 1<br> (8)<br> 私有bit，可以用来做特殊应用。例如可以用来触发应用程序的特殊事件。<br><br> I<br> 2<br> (7,6)<br> 声道<br> 00 立体声<br> 01 联合立体声（立体声）<br> 10 双声道（立体声）<br> 11 单声道（单声） </p> 
   <p>注：双声道文件由二个独立的单声道组成。 每一个声道使用整个文件一半的位率。大多数的解码器把它当作立体声来输出，但是它并不总是这种情况。按我的理解就是是两个声道的信息是完全相同的，并不能把它当作立体声看待。<br><br> J<br> 2<br> (5,4)<br> 扩展模式（仅在联合立体声时有效）<br> 扩展模式用来连接对立体声效果无用的信息，来减少所需的资源。这两个位在联合立体声模式下有编码器动态指定。<br> 完整的MPEG文件的频率序列分成有32个子带。在LayerI和LayerII中这两个位确定强度立体声应用的频带。 <br> LayerIII中这两个位确定应用了哪一种联合立体声（M/S stereo或者Intensity stereo）频带由解压算法决定。</p> 
   <p>值<br> Layer I &amp; II<br> Layer III<br><br> M/S stereo<br> Intensity stereo<br><br> 00<br> bands 4 to 31<br> off<br> off<br><br> 01<br> bands 8 to 31<br> off<br> on<br><br> 10<br> bands 12 to 31<br> on<br> off<br><br> 11<br> bands 16 to 31<br> on<br> on<br><br><br> K<br> 1<br> (3)<br> 版权<br> 0无版权<br> 1有版权 <br><br> L<br> 1<br> (2)<br> 原创<br> 0 原创拷贝<br> 1 原创 <br><br> M<br> 2<br> (1,0)<br> 强调<br> 00 - 无<br> 01 - 50/15 ms<br> 10 - 保留<br> 11 - CCIT J.17<br></p> 
   <p><br> 关于读取帧头我使用了下面的方法<br> 定义一个结构体<br> typedef struct frameHeader <br> { <br> unsigned int sync1:8; //同步信息1 </p> 
   <p>unsigned int error_protection:1; //CRC校验 <br> unsigned int layer:2; //层 <br> unsigned int version:2; //版本 <br> unsigned int sync2:3; //同步信息2 </p> 
   <p>unsigned int extension:1; //版权 <br> unsigned int padding:1; //填充空白字 <br> unsigned int sample_rate_index:2; //采样率索引 <br> unsigned int bit_rate_index:4; //位率索引 </p> 
   <p>unsigned int emphasis:2; //强调方式 <br> unsigned int original:1; //原始媒体 <br> unsigned int copyright:1; //版权标志 <br> unsigned int mode_extension:2; //扩展模式，仅用于联合立体声<br> unsigned int channel_mode:2; //声道模式 </p> 
   <p>}FHEADER, *pFHEADER; </p> 
   <p>请注意我的同步信息分成了两个部分，而且其他的位的顺序也和上表列出的有所差别，这个主要是因为c语言在存取数据时总是从低位开始，而这个帧头是需要从高位来读取的。<br> 读取方式如下<br> FHEADER header;<br> fread( &amp;header, sizeof( FHEADER ), 1, streams );//这里假设文件已打开，读取位置已经指向帧头所在的位置</p> 
   <p>这样一次就可以读入帧头的所有信息了。</p> 
   <p>2、如何计算帧长度</p> 
   <p>我们首先区分两个术语：帧大小和帧长度。帧大小即每帧采样数表示一帧中采样的个数，这是恒定值。其值入下表所示</p> 
   <p> MPEG 1<br> MPEG 2 (LSF)<br> MPEG 2.5 (LSF)<br><br> Layer I<br> 384<br> 384<br> 384<br><br> Layer II<br> 1152<br> 1152<br> 1152<br><br> Layer III<br> 1152<br> 576<br> 576<br></p> 
   <p><br> 帧长度是压缩时每一帧的长度，包括帧头。它将填充的空位也计算在内。LayerI的一个空位长4字节，LayerII和LayerIII的空位是1字节。当读取MPEG文件时必须计算该值以便找到相邻的帧。<br> 注意：因为有填充和比特率变换，帧长度可能变化。<br> 从头中读取比特率，采样频率和填充，<br> LyaerI使用公式：<br> 帧长度（字节） = (( 每帧采样数 / 8 * 比特率 ) / 采样频率 ) + 填充 * 4<br> LyerII和LyaerIII使用公式：<br> 帧长度（字节）= (( 每帧采样数 / 8 * 比特率 ) / 采样频率 ) + 填充<br> 例：<br> LayerIII 比特率 128000，采样频率 44100，填充0<br> =〉帧大小 417字节</p> 
   <p>3、每帧的持续时间</p> 
   <p>之前看了一些文章都说mp3的一帧的持续时间是26ms，结果在实际程序的编写中发现无法正确按时间定位到帧，然后又查了一些文章才知道，所谓26ms一帧只是针对MPEG1 Layer III而且采样率为44.1KHz来说是对的，但mp3文件并不都是如此，其实这个时间也是可以通过计算来获得，下面给出计算公式</p> 
   <p>每帧持续时间(毫秒) = 每帧采样数 / 采样频率 * 1000 </p> 
   <p>这样通过计算可知 MPEG1 Layer III 采样率为44.1KHz的一帧持续时间为26.12...不是整数，不过我们权且认为它就是26毫秒吧。<br> 如果是MPEG2 Layer III 采样率为16KHz的话那一帧要持续36毫秒，这个相差还是蛮大的，所以还是应该通过计算来获的，当然可以按MPEG版本，层数和采样率来建一个表，这样直接查表就可以知道时间了。</p> 
   <p>4、CRC校验</p> 
   <p>如果帧头的校验位为0，则帧头后就有一个16位的CRC值，这个值是big-endian的值，把这个值和该帧通过计算得出的CRC值进行比较就可以得知该帧是否有效。<br> 关于CRC校验下面给出我找到的英文原文，我的英文水平不高，翻译的不行。</p> 
   <p>If the protection bit in the header is not set, the frame contains a 16 bit CRC (Cyclic Redundancy Checksum). This checksum directly follows the frame header and is a big-endian WORD. To verify this checksum you have to calculate it for the frame and compare the calculated CRC with the stored CRC. If they aren't equal probably a transfer error has appeared. It is also helpful to check the CRC to verify that you really found the beginning of a frame, because the sync bits do in same cases also occur within the data section of a frame.</p> 
   <p>The CRC is calculated by applying the CRC-16 algorithm (with the generator polynom 0x8005) to a part of the frame. The following data is considered for the CRC: the last two bytes of the header and a number of bits from the audio data which follows the checksum after the header. The checksum itself must be skipped for CRC calculation. Unfortunately there is no easy way to compute the number of frames which are necessary for the checksum calculation in Layer II. Therefore I left it out in the code. You would need other information apart from the header to calculate the necessary bits. However it is possible to compute the number of protected bits in Layer I and Layer III only with the information from the header.</p> 
   <p>For Layer III, you consider the complete side information for the CRC calculation. The side information follows the header or the CRC in Layer III files. It contains information about the general decoding of the frame, but doesn't contain the actual encoded audio samples. The following table shows the size of the side information for all Layer III files.</p> 
   <p> MPEG 1<br> MPEG 2/2.5 (LSF)<br><br> Stereo, Joint Stereo, Dual Channel<br> 32<br> 17<br><br> Mono<br> 17<br> 9<br></p> 
   <p><br> For Layer I files, you must consider the mode extension from the header. Then you can calculate the number of bits which are necessary for CRC calculation by applying the following formula:</p> 
   <p>4 * (number of channels * bound of intensity stereo + (32 - bound of intensity stereo));This can be read as two times the number of stereo subbands plus the number of mono subbands and the result multiplied with 4. For simple mono frames, this equals 128, because the number of channels is one and the bound of intensity stereo is 32, meaning that there is no intensity stereo. For stereo frames this is 256. For more information have a look at the CRC code in the class CMPAFrame.</p> 
   <p>5、帧数据</p> 
   <p>在帧头后边是Side Info(姑且称之为通道信息)。对标准的立体声MP3文件来说其长度为32字节。通道信息后面是Scale factor(增益因子)信息。当解码器在读到上述信息后，就可以进行解码了。当MP3文件被打开后，播放器首先试图对帧进行同步，然后分别读取通道信息及增益因子等数据，再进行霍夫曼解码，至此我们已经获得解压后的数据。但这些数据仍然不能进行播放，它们还处于频域，要想听到歌曲还要将它由频域通过特定的手段转换到时域。接下来的处理分别为立体化处理；抗锯齿处理；IMDCT变换；IDCT变换及窗口化滑动处理。</p> 
   <p>我们知道，对于mp3来说现在有两种编码方式，一种是CBR，也就是固定位率，固定位率的帧的大小在整个文件中都是是固定的（公式如上所述），只要知道文件总长度，和从第一帧帧头读出的信息，就都可以通过计算得出这个mp3文件的信息，比如总的帧数，总的播放时间等等，要定位到某一帧或某个时间点也很方便，这种编码方式不需要文件头，第一帧开始就是音频数据。另一种是VBR，就是可变位率，VBR 是XING 公司推出的算法，所以在MP3 的FRAME 里会有“Xing"这个关键字（也有用"Info"来标识的，现在很多流行的小软件也可以进行VBR 压缩，它们是否遵守这个约定，那就不得而知了），它存放在MP3文件中的第一个有效帧的数据区里，它标识了这个MP3文件是VBR的。同时第一个帧里存放了MP3 文件的帧的总个数，这就很容易获得了播放总时间，同时还有100个字节存放了播放总时间的100个时间分段的帧索引，假设4 分钟的MP3 歌曲，240S，分成100 段，每两个相邻INDEX 的时间差就是2.4S，所以通过这个INDEX，只要前后处理少数的FRAME，就能快速找出我们需要快进的帧头。其实这第一帧就相当于文件头了。不过现在有些编码器在编码CBR文件时也像VBR那样将信息记入第一帧，比如著名的lame，它使用"Info"来做CBR的标记。</p> 
   <p>6、VBR 头 </p> 
   <p>这里列出VBR的第一帧存储文件信息的头的格式。有两种格式，一种是常见的XING Header（头部包含字符‘Xing’），另一种是VBRI Header（头部包含字符‘VBRI’）鉴于VBRI Header不常见，下面只说XING Header，关于VBRI Header请看<a href="http://www.codeproject.com/audio/MPEGAudioInfo.asp" rel="nofollow">http://www.codeproject.com/audio/MPEGAudioInfo.asp</a>。</p> 
   <p>XING Header的起始位置，相对于第一帧帧头的位置，单位是字节</p> 
   <p>36-39 "Xing" 文件为MPEG1并且不是单声道(大多数VBR的mp3文件都是如此)<br> 21-24 "Xing" 文件为MPEG1并且是单声道<br> 21-24 "Xing" 文件为MPEG2并且不是单声道<br> 13-16 "Xing" 文件为MPEG2并且是单声道</p> 
   <p>XING Header格式</p> 
   <p>位置（从‘Xing’标记开始)<br> 长度<br> 含义<br> 举例<br><br> 0<br> 4<br> VBR头标记，4个字节的ASCII字符，内容为 'Xing' 或者 'Info'<br> 'Xing'<br><br> 4<br> 4<br> 指示VBR头具体内容的标记, 组合方式为逻辑或. 区域是强制的.</p> 
   <p>0x0001 - 总帧数存储区域设置为存在，不包括第一帧<br> 0x0002 - 文件长度存储区域设置为存在，不包括标签<br> 0x0004 - TOC 索引存储区域设置为存在<br> 0x0008 - 质量指示存储区域设置为存在<br> 0x0007<br> (意味总帧数，文件长度，TOC的存储区有效)<br><br> 8<br> 4<br> 存储总帧数的Big-Endian值<br> 7344<br><br> 8 or 12<br> 4<br> 存储文件长度Big-Endian值，单位为字节<br> 45000<br><br> 8, 12 or 16<br> 100<br> 100字节的 TOC 索引，用于快速定位</p> 
   <p>对于这个区域的存储内容，我认为可有可无，因为用1个字节来索引一个几兆文件的一帧是不可能做到准确定位的，就我所见基本上所有的VBR的mp3文件的 TOC都几乎是相同的，就是把256平均分成100份然后填进去，其实和正确的值差不到哪里去，如果懒的话这么做也成吧，反正也是不准确的定位。</p> 
   <p>TCO索引的计算方式如下<br> (TOC[i] / 256) * 文件长度 <br> 比如文件持续240秒，我需要跳到60秒，文件长度为5000000字节 <br> 计算如下<br> TOC[(60/240)*100] = TOC[25]<br> 然后相对于文件中的位置大约是在<br> (TOC[25]/256) * 5000000</p> 
   <p>如果要自己重建的话，基本是把这个步骤反过来做就可以了。要求准确的话，就需要根据时间点找到正确帧的位置然后再计算，我定位帧的做法都是从第一帧开始搜索，这样偏差我认为不会超过1帧，也比较准确，不过计算出来的TOC的值还是和偷懒的做法大同小异。<br><br> 8, 12, 16, 108, 112 or 116<br> 4<br> 质量指示器，为0(最好)-100(最差)的Big-Endian值<br> 0<br></p> 
   <p><br> 这样算来，XING Header包括帧头一共最多只需要156个字节就够了。当然也可以在XING Header后面存储编码器的信息，比如lame在其后就是存储其版本，这需要给第一帧留足够的空间才行。</p> 
   <p>至于mp3的信息用从XING Header读出的信息就可以计算<br> 比如<br> 总持续时间 = 总帧数 * 每帧采样数 / 采样率 （结果为秒）<br> 平均位率 = 文件长度 / 总持续时间 * 8</p> 
   <p>五、MPEG音频标签</p> 
   <p>MPEG音频标签分为两种，一种是ID3v1，存在文件尾部，长度128字节，另一种是ID3v2，是对ID3v1的扩展，存在文件头部，长度不定。</p> 
   <p>1、ID3v1</p> 
   <p>ID3v1标签用来描述MPEG音频文件。包含艺术家，标题，唱片集，发布年代和流派。另外还有额外的注释空间。位于音频文件的最后固定为128字节。可以读取该文件的最后这128字节获得标签。</p> 
   <p>结构如下</p> 
   <p>AAABBBBB BBBBBBBB BBBBBBBB BBBBBBBB<br> BCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCD<br> DDDDDDDD DDDDDDDD DDDDDDDD DDDDDEEE<br> EFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFG</p> 
   <p>符号<br> 长度 (bytes)<br> 位置 (bytes)<br> 描述<br><br> A<br> 3<br> (0-2)<br> 标签标志。如果存在标签并且正确的话，必须包含'TAG'。<br><br> B<br> 30<br> (3-32)<br> 标题<br><br> C<br> 30<br> (33-62)<br> 艺术家<br><br> D<br> 30<br> (63-92)<br> 唱片集<br><br> E<br> 4<br> (93-96)<br> 年代<br><br> F<br> 30<br> (97-126)<br> 注释<br><br> G<br> 1<br> (127)<br> 流派<br><br> 该规格要求所有的空间必须以空字符(ASCII 0)填充。但是并不是所有的应用程序遵循该规则，比如winamp就用空格(ASCII 32)代替之。<br> 在ID3v1.1结构中有些改变。注释部分的最后一个字节用来定义唱片集中的轨道号。如果不知道该信息时可以用空字符(ASCII 0)代替。<br> 流派使用原码表示，为下列数字之一：<br> 0<br> 'Blues'<br> 20<br> 'Alternative'<br> 40<br> 'AlternRock'<br> 60<br> 'Top 40'<br><br> 1<br> 'Classic Rock'<br> 21<br> 'Ska'<br> 41<br> 'Bass'<br> 61<br> 'Christian Rap'<br><br> 2<br> 'Country'<br> 22<br> 'Death Metal'<br> 42<br> 'Soul'<br> 62<br> 'Pop/Funk'<br><br> 3<br> 'Dance'<br> 23<br> 'Pranks'<br> 43<br> 'Punk'<br> 63<br> 'Jungle'<br><br> 4<br> 'Disco'<br> 24<br> 'Soundtrack'<br> 44<br> 'Space'<br> 64<br> 'Native American'<br><br> 5<br> 'Funk'<br> 25<br> 'Euro-Techno'<br> 45<br> 'Meditative'<br> 65<br> 'Cabaret'<br><br> 6<br> 'Grunge'<br> 26<br> 'Ambient'<br> 46<br> 'Instrumental Pop'<br> 66<br> 'New Wave'<br><br> 7<br> 'Hip-Hop'<br> 27<br> 'Trip-Hop'<br> 47<br> 'Instrumental Rock'<br> 67<br> 'Psychadelic'<br><br> 8<br> 'Jazz'<br> 28<br> 'Vocal'<br> 48<br> 'Ethnic'<br> 68<br> 'Rave'<br><br> 9<br> 'Metal'<br> 29<br> 'Jazz+Funk'<br> 49<br> 'Gothic'<br> 69<br> 'Showtunes'<br><br> 10<br> 'New Age'<br> 30<br> 'Fusion'<br> 50<br> 'Darkwave'<br> 70<br> 'Trailer'<br><br> 11<br> 'Oldies'<br> 31<br> 'Trance'<br> 51<br> 'Techno-Industrial'<br> 71<br> 'Lo-Fi'<br><br> 12<br> 'Other'<br> 32<br> 'Classical'<br> 52<br> 'Electronic'<br> 72<br> 'Tribal'<br><br> 13<br> 'Pop'<br> 33<br> 'Instrumental'<br> 53<br> 'Pop-Folk'<br> 73<br> 'Acid Punk'<br><br> 14<br> 'R&amp;B'<br> 34<br> 'Acid'<br> 54<br> 'Eurodance'<br> 74<br> 'Acid Jazz'<br><br> 15<br> 'Rap'<br> 35<br> 'House'<br> 55<br> 'Dream'<br> 75<br> 'Polka'<br><br> 16<br> 'Reggae'<br> 36<br> 'Game'<br> 56<br> 'Southern Rock'<br> 76<br> 'Retro'<br><br> 17<br> 'Rock'<br> 37<br> 'Sound Clip'<br> 57<br> 'Comedy'<br> 77<br> 'Musical'<br><br> 18<br> 'Techno'<br> 38<br> 'Gospel'<br> 58<br> 'Cult'<br> 78<br> 'Rock &amp; Roll'<br><br> 19<br> 'Industrial'<br> 39<br> 'Noise'<br> 59<br> 'Gangsta'<br> 79<br> 'Hard Rock'<br><br> Winamp扩充了这个表<br> 80<br> 'Folk'<br> 92<br> 'Progressive Rock'<br> 104<br> 'Chamber Music'<br> 116<br> 'Ballad'<br><br> 81<br> 'Folk-Rock'<br> 93<br> 'Psychedelic Rock'<br> 105<br> 'Sonata'<br> 117<br> 'Poweer Ballad'<br><br> 82<br> 'National Folk'<br> 94<br> 'Symphonic Rock'<br> 106<br> 'Symphony'<br> 118<br> 'Rhytmic Soul'<br><br> 83<br> 'Swing'<br> 95<br> 'Slow Rock'<br> 107<br> 'Booty Brass'<br> 119<br> 'Freestyle'<br><br> 84<br> 'Fast Fusion'<br> 96<br> 'Big Band'<br> 108<br> 'Primus'<br> 120<br> 'Duet'<br><br> 85<br> 'Bebob'<br> 97<br> 'Chorus'<br> 109<br> 'Porn Groove'<br> 121<br> 'Punk Rock'<br><br> 86<br> 'Latin'<br> 98<br> 'Easy Listening'<br> 110<br> 'Satire'<br> 122<br> 'Drum Solo'<br><br> 87<br> 'Revival'<br> 99<br> 'Acoustic'<br> 111<br> 'Slow Jam'<br> 123<br> 'A Capela'<br><br> 88<br> 'Celtic'<br> 100<br> 'Humour'<br> 112<br> 'Club'<br> 124<br> 'Euro-House'<br><br> 89<br> 'Bluegrass'<br> 101<br> 'Speech'<br> 113<br> 'Tango'<br> 125<br> 'Dance Hall'<br><br> 90<br> 'Avantgarde'<br> 102<br> 'Chanson'<br> 114<br> 'Samba'<br><br> 91<br> 'Gothic Rock'<br> 103<br> 'Opera'<br> 115<br> 'Folklore'<br><br> 其他扩充 126<br> 'Goa'<br> 132<br> 'BritPop'<br> 138<br> 'BlackMetal'<br> 144<br> 'TrashMetal'<br><br> 127<br> 'Drum&amp;Bass'<br> 133<br> 'Negerpunk'<br> 139<br> 'Crossover'<br> 145<br> 'Anime'<br><br> 128<br> 'Club-House'<br> 134<br> 'PolskPunk'<br> 140<br> 'ContemporaryChristian'<br> 146<br> 'JPop'<br><br> 129<br> 'Hardcore'<br> 135<br> 'Beat'<br> 141<br> 'ChristianRock'<br> 147<br> 'Synthpop'<br><br> 130<br> 'Terror'<br> 136<br> 'ChristianGangstaRap'<br> 142<br> 'Merengue'<br><br> 131<br> 'Indie'<br> 137<br> 'HeavyMetal'<br> 143<br> 'Salsa'<br></p> 
   <p><br> 其他任何的数值都认为是“unknown”</p> 
   <p>2、ID3V2</p> 
   <p>ID3V2 到现在一共有4 个版本，但流行的播放软件一般只支持第3 版，既ID3v2.3。由于ID3V1 记录在MP3 文件的末尾，ID3V2 就只好记录在MP3 文件的首部了(如果有一天发布ID3V3，真不知道该记录在哪里)。也正是由于这个原因，对ID3V2 的操作比ID3V1 要慢。而且ID3V2 结构比ID3V1 的结构要复杂得多，但比前者全面且可以伸缩和扩展。<br> 下面就介绍一下ID3V2.3。<br> 每个ID3V2.3 的标签都一个标签头和若干个标签帧或一个扩展标签头组成。关于曲目的信息如标题、作者等都存放在不同的标签帧中，扩展标签头和标签帧并不是必要的，但每个标签至少要有一个标签帧。标签头和标签帧一起顺序存放在MP3 文件的首部。</p> 
   <p>（一）、标签头</p> 
   <p>在文件的首部顺序记录10 个字节的ID3V2.3 的头部。数据结构如下：</p> 
   <p>char Header[3]; /*必须为"ID3"否则认为标签不存在*/<br> char Ver; /*版本号ID3V2.3 就记录3*/<br> char Revision; /*副版本号此版本记录为0*/<br> char Flag; /*存放标志的字节，这个版本只定义了三位，稍后详细解说*/<br> char Size[4]; /*标签大小，包括标签头的10 个字节和所有的标签帧的大小*/<br> 注:对这里我有疑惑，因为在实际寻找首帧的过程中，我发现有的mp3文件的标签大小是不包含标签头的，但有的又是包含的，可能是某些mp3编码器写标签的BUG，所以为了兼容只好认为其是包含的，如果按大小找不到，再向后搜索，直到找到首帧为止。</p> 
   <p>（1）.标志字节</p> 
   <p>标志字节一般为0，定义如下：<br> abc00000<br> a -- 表示是否使用Unsynchronisation(这个单词不知道是什么意思，字典里也没有找到，一般不设置)<br> b -- 表示是否有扩展头部，一般没有(至少Winamp 没有记录)，所以一般也不设置<br> c -- 表示是否为测试标签(99.99%的标签都不是测试用的啦，所以一般也不设置)<br> （2）.标签大小<br> 一共四个字节，但每个字节只用7 位，最高位不使用恒为0。所以格式如下<br> 0xxxxxxx 0xxxxxxx 0xxxxxxx 0xxxxxxx<br> 计算大小时要将0 去掉，得到一个28 位的二进制数，就是标签大小(不懂为什么要这样做)，计算公式如<br> 下：<br> int total_size;<br> total_size = (Size[0]&amp;0x7F)*0x200000<br> +(Size[1]&amp;0x7F)*0x4000<br> +(Size[2]&amp;0x7F)*0x80<br> +(Size[3]&amp;0x7F)</p> 
   <p>（二）、标签帧</p> 
   <p>每个标签帧都有一个10 个字节的帧头和至少一个字节的不固定长度的内容组成。它们也是顺序存放在文件<br> 中，和标签头和其他的标签帧也没有特殊的字符分隔。得到一个完整的帧的内容只有从帧头中的到内容大<br> 小后才能读出，读取时要注意大小，不要将其他帧的内容或帧头读入。<br> 帧头的定义如下：<br> char FrameID[4]; /*用四个字符标识一个帧，说明其内容，稍后有常用的标识对照表*/<br> char Size[4]; /*帧内容的大小，不包括帧头，不得小于1*/<br> char Flags[2]; /*存放标志，只定义了6 位，稍后详细解说*/</p> 
   <p>（1）.帧标识</p> 
   <p>用四个字符标识一个帧，说明一个帧的内容含义，常用的对照如下：<br> TIT2=标题 表示内容为这首歌的标题，下同<br> TPE1=作者<br> TALB=专集<br> TRCK=音轨 格式：N/M 其中N 为专集中的第N 首，M 为专集中共M 首，N 和M 为ASCII 码表示的数字<br> TYER=年代 是用ASCII 码表示的数字<br> TCON=类型 直接用字符串表示<br> COMM=备注 格式："eng\0 备注内容"，其中eng 表示备注所使用的自然语言</p> 
   <p>（2）.大小</p> 
   <p>这个可没有标签头的算法那么麻烦，每个字节的8 位全用，格式如下<br> xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx<br> 算法如下：<br> int FSize;<br> FSize = Size[0]*0x100000000<br> +Size[1]*0x10000<br> +Size[2]*0x100<br> +Size[3];</p> 
   <p>（3）.标志</p> 
   <p>只定义了6 位，另外的10 位为0，但大部分的情况下16 位都为0 就可以了。格式如下：<br> abc00000 ijk00000<br> a -- 标签保护标志，设置时认为此帧作废<br> b -- 文件保护标志，设置时认为此帧作废<br> c -- 只读标志，设置时认为此帧不能修改(但我没有找到一个软件理会这个标志)<br> i -- 压缩标志，设置时一个字节存放两个BCD 码表示数字<br> j -- 加密标志(没有见过哪个MP3 文件的标签用了加密)<br> k -- 组标志，设置时说明此帧和其他的某帧是一组<br> 值得一提的是winamp 在保存和读取帧内容的时候会在内容前面加个'\0'，并把这个字节计算在帧内容的<br> 大小中。</p> 
   <p>附：帧标识的含义<br> （4）. Declared ID3v2 frames</p> 
   <p>The following frames are declared in this draft.<br> AENC Audio encryption<br> APIC Attached picture<br> COMM Comments<br> COMR Commercial frame<br> ENCR Encryption method registration<br> EQUA Equalization<br> ETCO Event timing codes<br> GEOB General encapsulated object<br> GRID Group identification registration<br> IPLS Involved people list<br> LINK Linked information<br> MCDI Music CD identifier<br> MLLT MPEG location lookup table<br> OWNE Ownership frame<br> PRIV Private frame<br> PCNT Play counter<br> POPM Popularimeter<br> POSS Position synchronisation frame<br> RBUF Recommended buffer size<br> RVAD Relative volume adjustment<br> RVRB Reverb<br> SYLT Synchronized lyric/text<br> SYTC Synchronized tempo codes<br> TALB Album/Movie/Show title<br> TBPM BPM (beats per minute)<br> TCOM Composer<br> TCON Content type<br> TCOP Copyright message<br> TDAT Date<br> TDLY Playlist delay<br> TENC Encoded by<br> TEXT Lyricist/Text writer<br> TFLT File type<br> TIME Time<br> TIT1 Content group description<br> TIT2 Title/songname/content description<br> TIT3 Subtitle/Description refinement<br> TKEY Initial key<br> TLAN Language(s)<br> TLEN Length<br> TMED Media type<br> TOAL Original album/movie/show title<br> TOFN Original filename<br> TOLY Original lyricist(s)/text writer(s)<br> TOPE Original artist(s)/performer(s)<br> TORY Original release year<br> TOWN File owner/licensee<br> TPE1 Lead performer(s)/Soloist(s)<br> TPE2 Band/orchestra/accompaniment<br> TPE3 Conductor/performer refinement<br> TPE4 Interpreted, remixed, or otherwise modified by<br> TPOS Part of a set<br> TPUB Publisher<br> TRCK Track number/Position in set<br> TRDA Recording dates<br> TRSN Internet radio station name<br> TRSO Internet radio station owner<br> TSIZ Size<br> TSRC ISRC (international standard recording code)<br> TSSE Software/Hardware and settings used for encoding<br> TYER Year<br> TXXX User defined text information frame<br> UFID Unique file identifier<br> USER Terms of use<br> USLT Unsychronized lyric/text transcription<br> WCOM Commercial information<br> WCOP Copyright/Legal information<br> WOAF Official audio file webpage<br> WOAR Official artist/performer webpage<br> WOAS Official audio source webpage<br> WORS Official internet radio station homepage<br> WPAY Payment<br> WPUB Publishers official webpage<br> WXXX User defined URL link frame</p> 
   <p>以上文字绝大多数来源于网络，当中也包含一些我自己的理解，如果有错请指正。</p> 
   <p><br></p> 
   <p><br></p> 
   <p><br></p> 
   <p>本文转自94cool博客园博客，原文链接：http://www.cnblogs.com/94cool/archive/2010/03/12/1684744.html，如需转载请自行联系原作者</p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
