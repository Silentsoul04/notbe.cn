<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>转载:SendMessage()这个函数有很多奇妙的用途 « NotBeCN</title>
  <meta name="description" content="                             举例:        1,获得MEMO中的光标位置.        Lops:=SendMessage(memol.Handle,EM_LINEFROMCHAR,Memol.SelStart,0);//光标所在的行号        Cpos:=SendMe...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/26/weixin_33897722_90132384.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">转载:SendMessage()这个函数有很多奇妙的用途</h1>
    <p class="post-meta">Nov 26, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div>
    <br>
   </div> 
   <div> 
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">举例:</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">1,获得MEMO中的光标位置.</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Lops:=SendMessage(memol.Handle,EM_LINEFROMCHAR,Memol.SelStart,0);//光标所在的行号</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Cpos:=SendMessage(meno1.Handle,EM_LINEINDEX,Lpos,0);//光标所在的字符位置</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">LineLength:=SendMessage(memol.handle,EM_LINELENGTH,Cpos,0);//这行的字符数.</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">2,开关显示器.</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">SendMessage(Handle, WM_SYSCOMMAND, SC_MONITORPOWER, 0);//关闭显示器.</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">SendMessage(Handle, WM_SYSCOMMAND, SC_MONITORPOWER, -1);//打开显示器.</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">3,有人问我如何让Memo翻页,我试了一下,</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Next:&nbsp;</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">sendmessage(memo1.handle,wm_keydown,VK_NEXT,-1);&nbsp;</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">sendmessage(memo1.handle,wm_keyup,VK_NEXT,-1);&nbsp;</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Prev:&nbsp;</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">sendmessage(memo1.handle,wm_keydown,VK_PRIOR,-1);&nbsp;</span>
    <br style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">sendmessage(memo1.handle,wm_keyup,VK_PRIOR,-1);</span> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br> TTreeView:<br> (引用CommCtrl)<br> SendMessage(TreeView.Handle,TVM_SETBKCOLOR,0,RGB(255,0,0));　设置TV背景颜色</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">SendMessage(Button.Handle,WM_LBUTTONDOWN,0,0);　　鼠标左键按下<br> SendMessage(Button.Handle,WM_LBUTTONUP,0,0);　　　鼠标左键抬起<br> SendMessage(Edit.Handle,WM_SETTEXT,255,Integer(PChar('abc')));　传递文本<br> SendMessage(Edit.Handle,WM_Char,Wparam('Q'),2);　　传递字符<br> SendMessage(Button.Handle,BM_SETSTYLE,BS_RADIOBUTTON,1);　　改变Button风格<br> SendMessage(ComboBox.Handle,CB_SETDROPPEDWIDTH,300,0);　　改变CBDownWidth<br> WM_CUT、WM_COPY和WM_PASTE　　剪切，复制，粘帖</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">实现任意组合键<br> keybd_event(VK_Control, MapVirtualKey(VK_Control, 0), 0, 0);<br> keybd_event(ord('V'), MapVirtualKey(ord('V'), 0), 0, 0);<br> keybd_event(ord('V'), MapVirtualKey(ord('V'), 0), KEYEVENTF_KEYUP, 0);<br> keybd_event(VK_Control, MapVirtualKey(VK_Control, 0), KEYEVENTF_KEYUP, 0);</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br> SendMessageA</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">说明: 调用一个窗口的窗口函数，将一条消息发给那个窗口。除非消息处理完毕，否则该函数不会返回SendMessage所包含4个参数:<br> 1. hwnd 32位的窗口句柄窗口可以是任何类型的屏幕对象，因为Win32能够维护大多数可视对象的句柄<br> 2. wMsg 用于区别其他消息的常量值，这些常量可以是Windows单元中预定义的常量，也可以是自定义的常量<br> 3. wParam 通常是一个与消息有关的常量值，也可能是窗口或控件的句柄<br> 4. lParam 通常是一个指向内存中数据的指针。由于WParm、lParam和Pointer都是32位的，因此，它们之间可以相互转换</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">wMsg函数<br> WM_Create 创建一个窗口<br> WM_DESTROY 当一个窗口被破坏时发送<br> WM_MOVE 移动一个窗口<br> WM_SIZE 改变一个窗口的大小<br> WM_ACTIVATE 一个窗口被激活或失去激活状态<br> WM_SETFOCUS 一个窗口获得焦点<br> WM_KILLFOCUS 一个窗口失去焦点<br> WM_ENABLE 一个窗口改变成Enable状态<br> WM_SETREDRAW 设置窗口是否能重画<br> WM_SETTEXT 应用程序发送此消息来设置一个窗口的文本<br> WM_GETTEXT 应用程序发送此消息来复制对应窗口的文本到缓冲区<br> WM_GETTEXTLENGTH 得到与一个窗口有关的文本的长度（不包含空字符）<br> WM_PAINT 要求一个窗口重画自己<br> WM_CLOSE 当一个窗口或应用程序要关闭时发送一个信号<br> WM_QUERYENDSESSION 用户选择结束对话框或程序自己调用ExitWindows函数<br> WM_QUIT 用来结束程序运行<br> WM_QUERYOPEN 用户窗口恢复以前的大小位置时，把此消息发送给某个图标<br> WM_ERASEBKGND 当窗口背景必须被擦除时（例在窗口改变大小时）<br> WM_SYSCOLORCHANGE 当系统颜色改变时，发送此消息给所有顶级窗口<br> WM_QUERYENDSESSION 消息后，此消息发送给应用程序，通知它对话是否结束<br> WM_SHOWWINDOW 当隐藏或显示窗口是发送此消息给这个窗口<br> WM_ACTIVATEAPP 发此消息给应用程序哪个窗口是激活的，哪个是非激活的<br> WM_FONTCHANGE 当系统的字体资源库变化时发送此消息给所有顶级窗口<br> WM_TIMECHANGE 当系统的时间变化时发送此消息给所有顶级窗口<br> WM_CANCELMODE 发送此消息来取消某种正在进行的摸态（操作）<br> WM_SETCURSOR 如果鼠标引起光标在某个窗口中移动<br> WM_ENDSESSION 当系统进程发出且鼠标输入没有被捕获时，就发消息给某个窗口<br> WM_MOUSEACTIVATE 当光标在某个非激活的窗口中而用户正按着鼠标的某个键发送此消息给当前窗口<br> WM_CHILDACTIVATE 送此消息给MDI子窗口当用户点击此窗口的标题栏，或当窗口被激活，移动，改变大小<br> WM_QUEUESYNC 此消息由基于计算机的训练程序发送,通过 WH_JOURNALPALYBACK的hook程序分离出用户输入消息<br> WM_GETMINMAXINFO 此消息发送给窗口当它将要改变大小或位置<br> WM_PAINTICON 发送给最小化窗口当它图标将要被重画<br> WM_ICONERASEBKGND 此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画<br> WM_NEXTDLGCT发送此消息给一个对话框程序去更改焦点位置<br> WM_SPOOLERSTATUS 每当打印管理列队增加或减少一条作业时发出此消息<br> WM_DRAWITEM 当button，combobox，listbox，menu的可视外观改变时发送<br> WM_MEASUREITEM 当button, combobox, listbox, listview control, or menuitem 被创建时<br> WM_VKEYTOITEM 此消息有一个LBS_WANTKEYBOARDINPUT风格的发出给它的所有者来响应WM_KEYDOWN消息<br> WM_CHARTOITEM 此消息由一个LBS_WANTKEYBOARDINPUT风格的列表框发送给他的所有者来响应WM_CHAR消息<br> WM_SETFONT 当绘制文本时程序发送此消息得到控件要用的颜色<br> WM_GETFONT 应用程序发送此消息得到当前控件绘制文本的字体<br> WM_SETHOTKEY 应用程序发送此消息让一个窗口与一个热键相关连<br> WM_GETHOTKEY 应用程序发送此消息来判断热键与某个窗口是否有关联<br> WM_QUERYDRAGICON 此消息发送给最小化窗口，当此窗口将要被拖放而它的类中没有定义图标，应用程序能返回一个图标或光标的句柄，当用户拖放图标时系统显示这个图标或光标<br> WM_COMPAREITEM 发送此消息来判定combobox或listbox新增加的项的相对位置<br> WM_COMPACTING 显示内存已经很少了<br> WM_WINDOWPOSCHANGING 发送此消息给那个窗口的大小和位置将要被改变时，来调用setwindowpos函数或其它窗口管理函数<br> WM_WINDOWPOSCHANGED 发送此消息给那个窗口的大小和位置已经被改变时，来调用setwindowpos函数或其它窗口管理函数<br> WM_POWER 当系统将要进入暂停状态时发送此消息<br> WM_COPYDATA 当一个应用程序传递数据给另一个应用程序时发送此消息<br> WM_CANCELJOURNA 当某个用户取消程序日志激活状态，提交此消息给程序<br> WM_NOTIFY 当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口<br> WM_INPUTLANGCHANGEREQUEST 当用户选择某种输入语言，或输入语言的热键改变<br> WM_INPUTLANGCHANGE 当平台现场已经被改变后发送此消息给受影响的最顶级窗口<br> WM_TCARD 当程序已经初始化windows帮助例程时发送此消息给应用程序<br> WM_HELP 此消息显示用户按下了F1，如果某个菜单是激活的，就发送此消息个此窗口关联的菜单，否则就发送给有焦点的窗口，如果当前都没有焦点，就把此消息发送给当前激活的窗口<br> WM_USERCHANGED 当用户已经登入或退出后发送此消息给所有的窗口，当用户登入或退出时系统更新用户的具体设置信息，在用户更新设置时系统马上发送此消息<br> WM_NOTIFYFORMAT 公用控件，自定义控件和他们的父窗口通过此消息来判断控件是使用ANSI还是UNICODE结构<br> WM_CONTEXTMENU 当用户某个窗口中点击了一下右键就发送此消息给这个窗口<br> WM_STYLECHANGING 当调用SETWINDOWLONG函数将要改变一个或多个 窗口的风格时发送此消息给那个窗口<br> WM_STYLECHANGED 当调用SETWINDOWLONG函数一个或多个 窗口的风格后发送此消息给那个窗口<br> WM_DISPLAYCHANGE 当显示器的分辨率改变后发送此消息给所有的窗口<br> WM_GETICON 此消息发送给某个窗口来返回与某个窗口有关连的大图标或小图标的句柄<br> WM_SETICON 程序发送此消息让一个新的大图标或小图标与某个窗口关联<br> WM_NCCreate 当某个窗口第一次被创建时，此消息在WM_Create消息发送前发送<br> WM_NCDESTROY 此消息通知某个窗口，非客户区正在销毁&nbsp;<br> WM_NCCALCSIZE 当某个窗口的客户区域必须被核算时发送此消息<br> WM_NCHITTEST 移动鼠标，按住或释放鼠标时发生<br> WM_NCPAINT 程序发送此消息给某个窗口当它（窗口）的框架必须被绘制时<br> WM_NCACTIVATE 此消息发送给某个窗口仅当它的非客户区需要被改变来显示是激活还是非激活状态<br> WM_GETDLGCODE 发送此消息给某个与对话框程序关联的控件，widdows控制方位键和TAB键使输入进入此控件通过应<br> WM_NCMOUSEMOVE 当光标在一个窗口的非客户区内移动时发送此消息给这个窗口非客户区为:窗体的标题栏及窗的边框体<br> WM_NCLBUTTONDOWN 当光标在一个窗口的非客户区同时按下鼠标左键时提交此消息<br> WM_NCLBUTTONUP 当用户释放鼠标左键同时光标某个窗口在非客户区时发送此消息<br> WM_NCLBUTTONDBLCLK 当用户双击鼠标左键同时光标某个窗口在非客户区时发送此消息<br> WM_NCRBUTTONDOWN 当用户按下鼠标右键同时光标又在窗口的非客户区时发送此消息<br> WM_NCRBUTTONUP 当用户释放鼠标右键同时光标又在窗口的非客户区时发送此消息<br> WM_NCRBUTTONDBLCLK 当用户双击鼠标右键同时光标某个窗口在非客户区时发送此消息<br> WM_NCMBUTTONDOWN 当用户按下鼠标中键同时光标又在窗口的非客户区时发送此消息<br> WM_NCMBUTTONUP 当用户释放鼠标中键同时光标又在窗口的非客户区时发送此消息<br> WM_NCMBUTTONDBLCLK 当用户双击鼠标中键同时光标又在窗口的非客户区时发送此消息<br> WM_KEYFIRST&nbsp;<br> WM_KEYDOWN 按下一个键<br> WM_KEYUP 释放一个键<br> WM_CHAR 按下某键，并已发出WM_KEYDOWN， WM_KEYUP消息<br> WM_DEADCHAR 当用translatemessage函数翻译WM_KEYUP消息时发送此消息给拥有焦点的窗口<br> WM_SYSKEYDOWN 当用户按住ALT键同时按下其它键时提交此消息给拥有焦点的窗口<br> WM_SYSKEYUP 当用户释放一个键同时ALT 键还按着时提交此消息给拥有焦点的窗口<br> WM_SYSCHAR 当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后提交此消息给拥有焦点的窗口<br> WM_SYSDEADCHAR 当WM_SYSKEYDOWN消息被TRANSLATEMESSAGE函数翻译后发送此消息给拥有焦点的窗口<br> WM_INITDIALOG 在一个对话框程序被显示前发送此消息给它，通常用此消息初始化控件和执行其它任务<br> WM_COMMAND 当用户选择一条菜单命令项或当某个控件发送一条消息给它的父窗口，一个快捷键被翻译<br> WM_SYSCOMMAND 当用户选择窗口菜单的一条命令或当用户选择最大化或最小化时那个窗口会收到此消息<br> WM_TIMER 发生了定时器事件<br> WM_HSCROL当一个窗口标准水平滚动条产生一个滚动事件时发送此消息给那个窗口，也发送给拥有它的控件<br> WM_VSCROL当一个窗口标准垂直滚动条产生一个滚动事件时发送此消息给那个窗口也，发送给拥有它的控件<br> WM_INITMENU 当一个菜单将要被激活时发送此消息，它发生在用户菜单条中的某项或按下某个菜单键，它允许程序在显示前更改菜单<br> WM_INITMENUPOPUP 当一个下拉菜单或子菜单将要被激活时发送此消息，它允许程序在它显示前更改菜单，而不要改变全部<br> WM_MENUSelect 当用户选择一条菜单项时发送此消息给菜单的所有者（一般是窗口）<br> WM_MENUCHAR 当菜单已被激活用户按下了某个键（不同于加速键），发送此消息给菜单的所有者<br> WM_ENTERIDLE 当一个模态对话框或菜单进入空载状态时发送此消息给它的所有者，一个模态对话框或菜单进入空载状态就是在处理完一条或几条先前的消息后没有消息它的列队中等待<br> WM_CTLCOLORMSGBOX 在windows绘制消息框前发送此消息给消息框的所有者窗口，通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置消息框的文本和背景颜色<br> WM_CTLCOLOREDIT 当一个编辑型控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置编辑框的文本和背景颜色<br> WM_CTLCOLORLISTBOX 当一个列表框控件将要被绘制前发送此消息给它的父窗口;通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置列表框的文本和背景颜色<br> WM_CTLCOLORBTN 当一个按钮控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置按纽的文本和背景颜色<br> WM_CTLCOLORDLG 当一个对话框控件将要被绘制前发送此消息给它的父窗口 通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置对话框的文本背景颜色<br> WM_CTLCOLORSCROLLBAR 当一个滚动条控件将要被绘制时发送此消息给它的父窗口,通过响应这条消息，所有者窗口可以通过使用给定的相关显示设备的句柄来设置滚动条的背景颜色<br> WM_CTLCOLORSTATIC 当一个静态控件将要被绘制时发送此消息给它的父窗口 通过响应这条消息,所有者窗口可以通过使用给定的相关显示设备的句柄来设置静态控件的文本和背景颜色<br> WM_MOUSEFIRST&nbsp;<br> WM_MOUSEMOVE 移动鼠标<br> WM_LBUTTONDOWN 按下鼠标左键<br> WM_LBUTTONUP 释放鼠标左键<br> WM_LBUTTONDBLCLK 双击鼠标左键<br> WM_RBUTTONDOWN 按下鼠标右键<br> WM_RBUTTONUP 释放鼠标右键<br> WM_RBUTTONDBLCLK 双击鼠标右键<br> WM_MBUTTONDOWN 按下鼠标中键&nbsp;<br> WM_MBUTTONUP 释放鼠标中键<br> WM_MBUTTONDBLCLK 双击鼠标中键<br> WM_MOUSEWHEE当鼠标轮子转动时发送此消息个当前有焦点的控件<br> WM_PARENTNOTIFY 当MDI子窗口被创建或被销毁，或用户按了一下鼠标键而光标在子窗口上时发送此消息给它的父窗口<br> WM_ENTERMENULOOP 发送此消息通知应用程序的主窗口that已经进入了菜单循环模式<br> WM_EXITMENULOOP 发送此消息通知应用程序的主窗口that已退出了菜单循环模式<br> WM_SIZING 当用户正在调整窗口大小时发送此消息给窗口 通过此消息应用程序可以监视窗口大小和位置也可以修改他们<br> WM_CAPTURECHANGED 发送此消息 给窗口当它失去捕获的鼠标时<br> WM_MOVING 当用户在移动窗口时发送此消息，通过此消息应用程序可以监视窗口大小和位置也可以修改他们<br> WM_POWERBROADCAST 此消息发送给应用程序来通知它有关电源管理事件&nbsp;<br> WM_DEVICECHANGE 当设备的硬件配置改变时发送此消息给应用程序或设备驱动程序<br> WM_MDIDESTROY 应用程序发送此消息给多文档的客户窗口来关闭一个MDI 子窗口<br> WM_MDIACTIVATE 应用程序发送此消息给多文档的客户窗口通知客户窗口激活另一个MDI子窗口，当客户窗口收到此消息后，它发出WM_MDIACTIVE消息给MDI子窗口（未激活）激活它<br> WM_MDIRESTORE 程序 发送此消息给MDI客户窗口让子窗口从最大最小化恢复到原来大小<br> WM_MDINEXT 程序 发送此消息给MDI客户窗口激活下一个或前一个窗口<br> WM_MDIMAXIMIZE 程序发送此消息给MDI客户窗口来最大化一个MDI子窗口<br> WM_MDITILE 程序 发送此消息给MDI客户窗口以平铺方式重新排列所有MDI子窗口<br> WM_MDICASCADE 程序 发送此消息给MDI客户窗口以层叠方式重新排列所有MDI子窗口<br> WM_MDIICONARRANGE 程序 发送此消息给MDI客户窗口重新排列所有最小化的MDI子窗口<br> WM_MDIGETACTIVE 程序 发送此消息给MDI客户窗口来找到激活的子窗口的句柄<br> WM_MDISETMENU 程序 发送此消息给MDI客户窗口用MDI菜单代替子窗口的菜单<br> WM_CUT 程序发送此消息给一个编辑框或combobox来删除当前选择的文本<br> WM_COPY 程序发送此消息给一个编辑框或combobox来复制当前选择的文本到剪贴板<br> WM_PASTE 程序发送此消息给editcontrol或combobox从剪贴板中得到数据<br> WM_CLEAR 程序发送此消息给editcontrol或combobox清除当前选择的内容<br> WM_UNDO 程序发送此消息给editcontrol或combobox撤消最后一次操作<br> WM_DESTROYCLIPBOARD 当调用ENPTYCLIPBOARD函数时 发送此消息给剪贴板的所有者<br> WM_DRAWCLIPBOARD 当剪贴板的内容变化时发送此消息给剪贴板观察链的第一个窗口,它允许用剪贴板观察窗口来显示剪贴板的新内容<br> WM_PAINTCLIPBOARD 当剪贴板包含CF_OWNERDIPLAY格式的数据并且剪贴板观察窗口的客户区需要重画<br> WM_SIZECLIPBOARD 当剪贴板包含CF_OWNERDIPLAY格式的数据并且剪贴板观察窗口的客户区域的大小已经改变是此消息通过剪贴板观察窗口发送给剪贴板的所有者<br> WM_ASKCBFORMATNAME 通过剪贴板观察窗口发送此消息给剪贴板的所有者来请求一个CF_OWNERDISPLAY格式的剪贴板的名字<br> WM_CHANGECBCHAIN 当一个窗口从剪贴板观察链中移去时发送此消息给剪贴板观察链的第一个窗口<br> WM_HSCROLLCLIPBOARD 此消息通过一个剪贴板观察窗口发送给剪贴板的所有者,它发生在当剪贴板包含CFOWNERDISPALY格式的数据并且有个事件在剪贴板观察窗的水平滚动条上,所有者应滚动剪贴板图象并更新滚动条的值<br> WM_QUERYNEWPALETTE 此消息发送给将要收到焦点的窗口，此消息能使窗口在收到焦点时同时有机会实现他的逻辑调色板<br> WM_PALETTEISCHANGING 当一个应用程序正要实现它的逻辑调色板时发此消息通知所有的应用程序<br> WM_PALETTECHANGED 此消息在一个拥有焦点的窗口实现它的逻辑调色板后发送此消息给所有顶级并重叠的窗口，以此来改变系统调色板<br> WM_HOTKEY 当用户按下由REGISTERHOTKEY函数注册的热键时提交此消息<br> WM_PRINT 应用程序发送此消息仅当WINDOWS或其它应用程序发出一个请求要求绘制一个应用程序的一部分<br> WM_DDE_INITIATE = WM_DDE_FIRST + 0 一个DDE客户程序提交此消息开始一个与服务器程序的会话来响应那个指定的程序和主题名<br> WM_DDE_TERMINATE = WM_DDE_FIRST + 1 一个DDE应用程序（无论是客户还是服务器）提交此消息来终止一个会话<br> WM_DDE_ADVISE = WM_DDE_FIRST + 2 一个DDE客户程序提交此消息给一个DDE服务程序来请求服务器每当数据项改变时更新它<br> WM_DDE_UNADVISE = WM_DDE_FIRST + 3 一个DDE客户程序通过此消息通知一个DDE服务程序不更新指定的项或一个特殊的剪贴板格式的项<br> WM_DDE_ACK = WM_DDE_FIRST + 4 此消息通知一个DDE（动态数据交换）程序已收到并正处理WM_DDE_POKE,WM_DDE_EXECUTE,WM_DDE_DATA, WM_DDE_ADVISE, WM_DDE_UNADVISE, or WM_DDE_INITIAT消息<br> WM_DDE_DATA = WM_DDE_FIRST + 5 一个DDE服务程序提交此消息给DDE客户程序来传递个一数据项给客户或通知客户的一条可用数据项<br> WM_DDE_REQUEST = WM_DDE_FIRST + 6 一个DDE客户程序提交此消息给一个DDE服务程序来请求一个数据项的值<br> WM_DDE_POKE = WM_DDE_FIRST + 7 一个DDE客户程序提交此消息给一个DDE服务程序，客户使用此消息来请求服务器接收一个未经同意的数据项服务器通过答复WM_DDE_ACK消息提示是否它接收这个数据项</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">SendMessage与PostMessage的区别&nbsp;<br> １、首先是返回值意义的区别，我们先看一下 MSDN 里的声明：</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">LRESULT SendMessage(<br> HWND hWnd,<br> UINT Msg,<br> WPARAM wParam,<br> LPARAM lParam<br> );<br> BOOL PostMessage(<br> HWND hWnd,<br> UINT Msg,<br> WPARAM wParam,<br> LPARAM lParam<br> );</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　其中 4 个参数的意义是一样的，返回值类型不同（其实从数据上看他们一样是一个 32 位的数，只是意义不一样），LRESULT 表示的是消息被处理后的返回值，BOOL 表示的是消息是不是 Post 成功。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">２、PostMessage 是异步的，SendMessage 是同步的。<br> PostMessage 只把消息放入队列，不管消息是否被处理就返回，消息可能不被处理；而 SendMessage 等待消息被处理完了之后才返回，如果消息不被处理，发送消息的线程将一直被阻塞。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">３、如果在同一个线程内，SendMessage 发送消息时，由 USER32.DLL 模块调用目标窗口的消息处理程序，并将结果返回。SendMessage 在同一线程中发送消息并不入线程消息队列。PostMessage 发送消息时，消息要先放入线程的消息队列，然后通过消息循环分派到目标窗口（DispatchMessage）。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　如果在不同线程内，SendMessage 发送消息到目标窗口所属线程的消息队列，然后发送消息的线程在 USER32.DLL 模块内监视和等待消息处理，直到目标窗口处理完返回。SendMessage 在返回前还做了很多工作，比如，响应别的线程向它 SendMessage。Post 到别的线程时，最好用 PostThreadMessage 代替 PostMessage，PostMessage 的 hWnd 参数可以是 NULL，等效于 PostThreadMessage + GetCurrentThreadId。Post WM_QUIT 时，应使用 PostQuitMessage 代替。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">４、系统只整编（marshal）系统消息（0 到 WM_USER 之间的消息），发送用户消息（WM_USER 以上）到别的进程时，需要自己做整编。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　用 PostMessage、SendNotifyMessage、SendMessageCallback 等异步函数发送系统消息时，参数里不可以使用指针，因为发送者并不等待消息的处理就返回，接受者还没处理指针就已经被释放了。</p> 
    <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">５、在 Windows 2000/XP 里，每个消息队列最多只能存放 10,000 个 Post 的消息，超过的还没被处理的将不会被处理，直接丢掉。这个值可以改得更大：[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows] USERPostMessageLimit，最小可以是 4000。</p> 
    <p><font><span style="font-size:14px;"><br></span></font></p> 
    <p><font><span style="font-size:14px;"><br></span></font></p> 
    <p><font><span style="font-size:14px;"><br></span></font></p> 
    <p><font><span style="font-size:14px;">本文转自94cool博客园博客，原文链接：http://www.cnblogs.com/94cool/archive/2011/05/26/2058015.html，如需转载请自行联系原作者</span></font></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
