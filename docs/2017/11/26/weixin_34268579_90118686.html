<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>索引原理 « NotBeCN</title>
  <meta name="description" content="                           索引的基本概念           索引是一种特殊类型的数据库对象，它与表有着密切的联系。           索引是为检索而存在的。如一些书籍的末尾就专门附有索引，指明了某个关键字在正文中的出现的页码位置，方便我们查找，但大多数的书籍只有目录，目录不是索引，...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/26/weixin_34268579_90118686.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">索引原理</h1>
    <p class="post-meta">Nov 26, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1></h1> 
   <div class="postBody"> 
    <div class="blogpost-body">
     索引的基本概念
     <br>
     <br> 索引是一种特殊类型的数据库对象，它与表有着密切的联系。
     <br>
     <br> 索引是为检索而存在的。如一些书籍的末尾就专门附有索引，指明了某个关键字在正文中的出现的页码位置，方便我们查找，但大多数的书籍只有目录，目录不是索引，只是书中内容的排序，并不提供真正的检索功能。可见建立索引要单独占用空间；索引也并不是必须要建立的，它们只是为更好、更快的检索和定位关键字而存在。
     <br>
     <br> 再进一步说，我们要在图书馆中查阅图书，该怎么办呢？图书馆的前台有很多叫做索引卡片柜的小柜子，里面分了若干的类别供我们检索图书，比如你可以用书名的笔画顺序或者拼音顺序作为查找的依据，你还可以从作者名的笔画顺序或拼音顺序去查询想要的图书，反正有许多检索方式，但有一点很明白，书库中的书并没有按照这些卡片柜中的顺序排列——虽然理论上可以这样做，事实上，所有图书的脊背上都人工的粘贴了一个特定的编号①，它们是以这个顺序在排列。索引卡片中并没有指明这本书摆放在书库中的第几个书架的第几本，仅仅指明了这个特定的编号。管理员则根据这一编号将请求的图书返回到读者手中。这是很形象的例子，以下的讲解将会反复用到它。
     <br>
     <br> SQLS在安装完成之后，安装程序会自动创建master、model、tempdb等几个特殊的系统数据库，其中master是SQLS的主数据库，用于保存和管理其它系统数据库、用户数据库以及SQLS的系统信息，它在SQLS中的地位与WINDOWS下的注册表相当。
     <br>
     <br> master中有一个名为sysindexes的系统表，专门管理索引。SQLS查询数据表的操作都必须用到它，毫无疑义，它是本文主角之一。
     <br>
     <br> 查看一张表的索引属性，可以在查询分析器中使用以下命令：select * from sysindexes where id=object_id(‘tablename’) ；而要查看表的索引所占空间的大小，可以使用系统存储过程命令：sp_spaceused tablename，其中参数tablename为被索引的表名。
     <br>
     <br>
     <span><strong>三、平衡树</strong></span>
     <br>
     <br> 如果你通过书后的索引知道了一个关键字所在的页码，你有可能通过随机的翻寻，最终到达正确的页码。但更科学更快捷的方法是：首先把书翻到大概二分之一的位置，如果要找的页码比该页的页码小，就把书向前翻到四分之一处，否则，就把书向后翻到四分之三的地方，依此类推，把书页续分成更小的部分，直至正确的页码。这叫“两分法”，微软在官方教程MOC里另有一种说法：叫B树（B-Tree，Balance Tree），即平衡树。
     <br>
     <br> 一个表索引由若干页面组成，这些页面构成了一个树形结构。B树由“根”（root）开始，称为根级节点，它通过指向另外两个页，把一个表的记录从逻辑上分成两个部分：“枝”—--非叶级节点（Non-Leaf Level）；而非叶级节点又分别指向更小的部分：“叶”——叶级节点（Leaf Level）。根节点、非叶级节点和叶级节点都位于索引页中，统称为索引节点，属于索引页的范筹。这些“枝”、“叶”最终指向了具体的数据页（Page）。在根级节点和叶级节点之间的叶又叫数据中间页。
     <br> “根”（root）对应了sysindexes表的Root字段，其中记载了非叶级节点的物理位置（即指针）；非叶级节点位于根节点和叶节点之间，记载了指向叶级节点的指针；而叶级节点则最终指向数据页。这就是“平衡树”。
     <br>
     <br>
     <span><strong><br> 四、聚集索引和非聚集索引</strong></span>
     <br>
     <br> 从形式上而言，索引分为聚集索引（Clustered Indexes）和非聚集索引（NonClustered Indexes）。
     <br>
     <br> 聚集索引相当于书籍脊背上那个特定的编号。如果对一张表建立了聚集索引，其索引页中就包含着建立索引的列的值（下称索引键值），那么表中的记录将按照该索引键值进行排序。比如，我们如果在“姓名”这一字段上建立了聚集索引，则表中的记录将按照姓名进行排列；如果建立了聚集索引的列是数值类型的，那么记录将按照该键值的数值大小来进行排列。
     <br> 非聚集索引用于指定数据的逻辑顺序，也就是说，表中的数据并没有按照索引键值指定的顺序排列，而仍然按照插入记录时的顺序存放。其索引页中包含着索引键值和它所指向该行记录在数据页中的物理位置，叫做行定位符（RID：Row ID）。好似书后面的的索引表，索引表中的顺序与实际的页码顺序也是不一致的。而且一本书也许有多个索引。比如主题索引和作者索引。
     <br> SQL Server在默认的情况下建立的索引是非聚集索引，由于非聚集索引不对表中的数据进行重组，而只是存储索引键值并用一个指针指向数据所在的页面。一个表如果没有聚集索引时,理论上可以建立249个非聚集索引。每个非聚集索引提供访问数据的不同排序顺序。
     <br>
     <br>
     <span><strong>五、数据是怎样被访问的</strong></span>
     <br>
     <br> 若能真正理解了以上索引的基础知识，那么再回头来看索引的工作原理就简单和轻松多了。
     <br>
     <br>
     <strong><span style="font-size:small;">（一）SQLS怎样访问没有建立任何索引数据表：</span></strong>
     <br>
     <br> Heap译成汉语叫做“堆”，其本义暗含杂乱无章、无序的意思，前面提到数据值被写进数据页时，由于每一行记录之间并没地有特定的排列顺序，所以行与行的顺序就是随机无序的，当然表中的数据页也就是无序的了，而表中所有数据页就形成了“堆”，可以说，一张没有索引的数据表，就像一个只有书柜而没有索引卡片柜的图书馆，书库里面塞满了一堆乱七八糟的图书。当读者对管理员提交查询请求后，管理员就一头钻进书库，对照查找内容从头开始一架一柜的逐本查找，运气好的话，在第一个书架的第一本书就找到了，运气不好的话，要到最后一个书架的最后一本书才找到。
     <br>
     <br> SQLS在接到查询请求的时候，首先会分析sysindexes表中一个叫做索引标志符(INDID: Index ID)的字段的值，如果该值为0，表示这是一张数据表而不是索引表，SQLS就会使用sysindexes表的另一个字段——也就是在前面提到过的FirstIAM值中找到该表的IAM页链——也就是所有数据页集合。
     <br>
     <br> 这就是对一个没有建立索引的数据表进行数据查找的方式，是不是很没效率？对于没有索引的表，对于一“堆”这样的记录，SQLS也只能这样做，而且更没劲的是，即使在第一行就找到了被查询的记录，SQLS仍然要从头到尾的将表扫描一次。这种查询称为“遍历”，又叫“表扫描”。
     <br>
     <br> 可见没有建立索引的数据表照样可以运行，不过这种方法对于小规模的表来说没有什么太大的问题，但要查询海量的数据效率就太低了。
     <br>
     <br>
     <strong><span style="font-size:small;">（二）SQLS怎样访问建立了非聚集索引的数据表：</span></strong>
     <br>
     <br> 如前所述，非聚集索引可以建多个,具有B树结构，其叶级节点不包含数据页，只包含索引行。假定一个表中只有非聚集索引，则每个索引行包含了非聚集索引键值以及行定位符（ROW ID,RID），他们指向具有该键值的数据行。每一个RID由文件ID、页编号和在页中行的编号组成。
     <br>
     <br> 当INDID的值在2-250之间时，意味着表中存在非聚集索引页。此时，SQLS调用ROOT字段的值指向非聚集索引B树的ROOT，在其中查找与被查询最相近的值，根据这个值找到在非叶级节点中的页号，然后顺藤摸瓜，在叶级节点相应的页面中找到该值的RID，最后根据这个RID在Heap中定位所在的页和行并返回到查询端。
     <br>
     <br> 例如：假定在Lastname上建立了非聚集索引，则执行Select * From Member Where Lastname=’Ota’时，查询过程是：①SQLS查询INDID值为2；②立即从根出发，在非叶级节点中定位最接近Ota的值“Martin”，并查到其位于叶级页面的第61页；③仅在叶级页面的第61页的Martin下搜寻Ota的RID，其RID显示为N∶706∶4，表示Lastname字段中名为Ota的记录位于堆的第707页的第4行，N表示文件的ID值，与数据无关；④根据上述信息，SQLS立马在堆的第 707页第4行将该记录“揪”出来并显示于前台（客户端）。视表的数据量大小，整个查询过程费时从百分之几毫秒到数毫秒不等。
     <br>
     <br> 在谈到索引基本概念的时候，我们就提到了这种方式：
     <br>
     <br> 图书馆的前台有很多索引卡片柜，里面分了若干的类别，诸如按照书名笔画或拼音顺序、作者笔画或拼音顺序等等，但不同之处有二：① 索引卡片上记录了每本书摆放的具体位置——位于某柜某架的第几本——而不是“特殊编号”；② 书脊上并没有那个“特殊编号”。管理员在索引柜中查到所需图书的具体位置（RID）后，根据RID直接在书库中的具体位置将书提出来。
     <br> 显然，这种查询方式效率很高，但资源占用极大，因为书库中书的位置随时在发生变化，必然要求管理员花费额外的精力和时间随时做好索引更新。
     <br>
     <br>
     <strong><span style="font-size:small;">（三）SQLS怎样访问建立了聚集索引的数据表：</span></strong>
     <br>
     <br> 在聚集索引中，数据所在的数据页是叶级，索引数据所在的索引页是非叶级。
     <br>
     <br> 查询原理和上述对非聚集索引的查询相似，但由于记录是按照聚集索引中索引键值进行排序，换句话说，聚集索引的索引键值也就是具体的数据页。
     <br>
     <br> 这就好比书库中的书就是按照书名的拼音在排序，而且也只按照这一种排序方式建立相应的索引卡片，于是查询起来要比上述只建立非聚集索引的方式要简单得多。仍以上面的查询为例：
     <br>
     <br> 假定在Lastname字段上建立了聚集索引，则执行Select * From Member Where Lastname=’Ota’时，查询过程是：①SQLS查询INDID值为1，这是在系统中只建立了聚集索引的标志；②立即从根出发，在非叶级节点中定位最接近Ota的值“Martin”，并查到其位于叶级页面的第120页；③在位于叶级页面第120页的Martin下搜寻到Ota条目，而这一条目已是数据记录本身；④将该记录返回客户端。
     <br>
     <br> 这一次的效率比第二种方法更高，以致于看起来更美，然而它最大的优点也恰好是它最大的缺点——由于同一张表中同时只能按照一种顺序排列，所以在任何一种数据表中的聚集索引只能建立一个；并且建立聚集索引需要至少相当于源表120%的附加空间，以存放源表的副本和索引中间页！
     <br>
     <br> 难道鱼和熊掌就不能兼顾了吗？办法是有的。
     <br>
     <br>
     <strong><span style="font-size:small;">（四）SQLS怎样访问既有聚集索引、又有非聚集索引的数据表：</span></strong>
     <br>
     <br> 如果我们在建立非聚集索引之前先建立了聚集索引的话，那么非聚集索引就可以使用聚集索引的关键字进行检索，就像在图书馆中，前台卡片柜中的可以有不同类别的图书索引卡，然而每张卡片上都载明了那个特殊编号——并不是书籍存放的具体位置。这样在最大程度上既照顾了数据检索的快捷性，又使索引的日常维护变得更加可行，这是最为科学的检索方法。
     <br>
     <br> 也就是说，在只建立了非聚集索引的情况下，每个叶级节点指明了记录的行定位符（RID）；而在既有聚集索引又有非聚集索引的情况下，每个叶级节点所指向的是该聚集索引的索引键值，即数据记录本身。
     <br>
     <br> 假设聚集索引建立在Lastname上，而非聚集索引建立在Firstname上，当执行Select * From Member Where Firstname=’Mike’时，查询过程是：①SQLS查询INDID值为2；②立即从根出发，在Firstname的非聚集索引的非叶级节点中定位最接近Mike的值“Jose”条目；③从Jose条目下的叶级页面中查到Mike逻辑位置——不是RID而是聚集索引的指针；④根据这一指针所指示位置，直接进入位于Lastname的聚集索引中的叶级页面中到达Mike数据记录本身；⑤将该记录返回客户端。
     <br>
     <br> 这就完全和我们在“索引的基本概念”中讲到的现实场景完全一样了，当数据发生更新的时候，SQLS只负责对聚集索引的健值驾以维护，而不必考虑非聚集索引，只要我们在ID类的字段上建立聚集索引，而在其它经常需要查询的字段上建立非聚集索引，通过这种科学的、有针对性的在一张表上分别建立聚集索引和非聚集索引的方法，我们既享受了索引带来的灵活与快捷，又相对规避了维护索引所导致的大量的额外资源消耗。
     <br>
     <br>
     <span style="font-size:small;"><strong>六、索引的优点和不足</strong></span>
     <br>
     <br> 索引有一些先天不足：1：建立索引，系统要占用大约为表的1.2倍的硬盘和内存空间来保存索引。2：更新数据的时候，系统必须要有额外的时间来同时对索引进行更新，以维持数据和索引的一致性——这就如同图书馆要有专门的位置来摆放索引柜，并且每当库存图书发生变化时都需要有人将索引卡片重整以保持索引与库存的一致。
     <br>
     <br> 当然建立索引的优点也是显而易见的：在海量数据的情况下，如果合理的建立了索引，则会大大加强SQLS执行查询、对结果进行排序、分组的操作效率。
     <br>
     <br> 实践表明，不恰当的索引不但于事无补，反而会降低系统性能。因为大量的索引在进行插入、修改和删除操作时比没有索引花费更多的系统时间。比如在如下字段建立索引应该是不恰当的：1、很少或从不引用的字段；2、逻辑型的字段，如男或女(是或否)等。
     <br>
     <br> 综上所述，提高查询效率是以消耗一定的系统资源为代价的，索引不能盲目的建立，必须要有统筹的规划，一定要在“加快查询速度”与“降低修改速度”之间做好平衡，有得必有失，此消则彼长。这是考验一个DBA是否优秀的很重要的指标。
     <br>
     <br> 至此，我们一直在说SQLS在维护索引时要消耗系统资源，那么SQLS维护索引时究竟消耗了什么资源？会产生哪些问题？究竟应该才能优化字段的索引？
     <br>
     <br>
     <br>
     <br>
     <br>
     <br>
     <br>
     <br>
     <br> 在上篇中，我们就索引的基本概念和数据查询原理作了详细阐述，知道了建立索引时一定要在“加快查询速度”与“降低修改速度”之间做好平衡，有得必有失，此消则彼长。那么，SQLS维护索引时究竟怎样消耗资源？应该从哪些方面对索引进行管理与优化？以下就从七个方面来回答这些问题。
     <br>
     <br>
     <span><strong>一、页分裂</strong></span>
     <br>
     <br> 微软MOC教导我们：当一个数据页达到了8K容量，如果此时发生插入或更新数据的操作，将导致页的分裂(又名页拆分)：
     <br>
     <br> 1、有聚集索引的情况下：聚集索引将被插入和更新的行指向特定的页，该页由聚集索引关键字决定；
     <br>
     <br> 2、只有堆的情况下：只要有空间就可以插入新的行，但是如果我们对行数据的更新需要更多的空间，以致大于了当前页的可用空间，行就被移到新的页中，并且在原位置留下一个转发指针，指向被移动的新行，如果具有转发指针的行又被移动了，那么原来的指针将重新指向新的位置；
     <br>
     <br> 3、如果堆中有非聚集索引，那么尽管插入和更新操作在堆中不会发生页分裂，但是在非聚集索引上仍然产生页分裂。
     <br>
     <br> 无论有无索引，大约一半的数据将保留在老页面，而另一半将放入新页面，并且新页面可能被分配到任何可用的页。所以，频繁页分裂，后果很严重，将使物理表产生大量数据碎片，导致直接造成I/O效率的急剧下降，最后，停止SQLS的运行并重建索引将是我们的唯一选择!
     <br>
     <br>
     <strong>二、填充因子</strong>
     <br>
     <br> 然而在“混沌之初”，就可以在一定程度上避免不愉快出现：在创建索引时，可以为这个索引指定一个填充因子，以便在索引的每个叶级页面上保留一定百分比的空间，将来数据可以进行扩充和减少页分裂。填充因子是从0到100的百分比数值，设为100时表示将数据页填满。只有当不会对数据进行更改时(例如只读表中)才用此设置。值越小则数据页上的空闲空间越大，这样可以减少在索引增长过程中进行页分裂的需要，但这一操作需要占用更多的硬盘空间。
     <br>
     <br> 填充因子只在创建索引时执行，索引创建以后，当表中进行数据的添加、删除或更新时，是不会保持填充因子的，如果想在数据页上保持额外的空间，则有悖于使用填充因子的本意，因为随着数据的输入，SQLS必须在每个页上进行页拆分，以保持填充因子指定的空闲空间。因此，只有在表中的数据进行了较大的变动，才可以填充数据页的空闲空间。这时，可以从容的重建索引，重新指定填充因子，重新分布数据。
     <br>
     <br> 反之，填充因子指定不当，就会降低数据库的读取性能，其降低量与填充因子设置值成反比。例如，当填充因子的值为50时，数据库的读取性能会降低两倍！所以，只有在表中根据现有数据创建新索引，并且可以预见将来会对这些数据进行哪些更改时，设置填充因子才有意义。
     <br>
     <br>
     <strong>三、两道数学题</strong>
     <br>
     <br> 假定数据库设计没有问题，那么是否象上篇中分析的那样，当你建立了众多的索引，在查询工作中SQLS就只能按照“最高指示”用索引处理每一个提交的查询呢？答案是否定的！
     <br>
     <br> 上篇“数据是怎样被访问的”章节中提到的四种索引方案只是一种静态的、标准的和理论上的分析比较，实际上，将在外，军令有所不从，SQLS几乎完全是“自主”的决定是否使用索引或使用哪一个索引！
     <br>
     <br> 这是怎么回事呢？
     <br>
     <br> 让我们先来算一道题：如果某表的一条记录在磁盘上占用1000字节(1K)的话，我们对其中10字节的一个字段建立索引，那么该记录对应的索引大小只有10字节(0.01K)。上篇说过，SQLS的最小空间分配单元是“页（Page）”，一个页面在磁盘上占用8K空间，所以一页只能存储8条“记录”，但可以存储800条“索引”。现在我们要从一个有8000条记录的表中检索符合某个条件的记录(有Where子句)，如果没有索引的话，我们需要遍历8000条×1000字节/8K字节=1000个页面才能够找到结果。如果在检索字段上有上述索引的话，那么我们可以在8000条×10字节/8K字节=10个页面中就检索到满足条件的索引块，然后根据索引块上的指针逐一找到结果数据块，这样I/O访问量肯定要少得多。
     <br>
     <br> 然而有时用索引还不如不用索引快！
     <br>
     <br> 同上，如果要无条件检索全部记录(不用Where子句)，不用索引的话，需要访问8000条×1000字节/8K字节=1000个页面；而使用索引的话，首先检索索引，访问8000条×10字节/8K字节=10个页面得到索引检索结果，再根据索引检索结果去对应数据页面，由于是检索全部数据，所以需要再访问8000条×1000字节/8K字节=1000个页面将全部数据读取出来，一共访问了1010个页面，这显然不如不用索引快。
     <br>
     <br> SQLS内部有一套完整的数据索引优化技术，在上述情况下，SQLS会自动使用表扫描的方式检索数据而不会使用任何索引。那么SQLS是怎么知道什么时候用索引，什么时候不用索引的呢？因为SQLS除了维护数据信息外，还维护着数据统计信息！
     <br>
     <br>
     <strong>四、统计信息</strong>
     <br>
     <br> 打开企业管理器，单击“Database”节点，右击Northwind数据库→单击“属性”→选择“Options”选项卡，观察“Settings”下的各项复选项，你发现了什么？
     <br>
     <br> 从Settings中我们可以看到，在数据库中，SQLS将默认的自动创建和更新统计信息，这些统计信息包括数据密度和分布信息，正是它们帮助SQLS确定最佳的查询策略：建立查询计划和是否使用索引以及使用什么样的索引。
     <br>
     <br> 在创建索引时，SQLS会创建分布数据页来存放有关索引的两种统计信息：分布表和密度表。查询优化器使用这些统计信息估算使用该索引进行查询的成本(Cost)，并在此基础上判断该索引对某个特定查询是否有用。
     <br>
     <br> 随着表中的数据发生变化，SQLS自动定期更新这些统计信息。采样是在各个数据页上随机进行。从磁盘读取一个数据页后，该数据页上的所有行都被用来更新统计信息。统计信息更新的频率取决于字段或索引中的数据量以及数据更改量。比如，对于有一万条记录的表，当1000个索引键值发生改变时，该表的统计信息便可能需要更新，因为1000 个值在该表中占了10%，这是一个很大的比例。而对于有1千万条记录的表来说，1000个索引值发生更改的意义则可以忽略不计，因此统计信息就不会自动更新。
     <br>
     <br> 至于它们帮助SQLS建立查询计划的具体过程，限于篇幅，这里就省略了，请有兴趣的朋友们自己研究。
     <br>
     <br> 顺便多说一句，SQLS除了能自动记录统计信息之外，还可以记录服务器中所发生的其它活动的详细信息，包括I/O 统计信息、CPU 统计信息、锁定请求、T-SQL 和 RPC 统计信息、索引和表扫描、警告和引发的错误、数据库对象的创建/除去、连接/断开、存储过程操作、游标操作等等。这些信息的读取、设置请朋友们在SQLS联机帮助文档(SQL Server Books Online)中搜索字符串“Profiler”查找。
     <br>
     <br>
     <strong>五、索引的人工维护</strong>
     <br>
     <br> 上面讲到,某些不合适的索引将影响到SQLS的性能,随着应用系统的运行,数据不断地发生变化,当数据变化达到某一个程度时将会影响到索引的使用。这时需要用户自己来维护索引。
     <br>
     <br> 随着数据行的插入、删除和数据页的分裂，有些索引页可能只包含几页数据，另外应用在执行大量I/O的时候，重建非聚聚集索引可以维护I/O的效率。重建索引实质上是重新组织B树。需要重建索引的情况有：
     <br>
     <br> 1) 数据和使用模式大幅度变化；
     <br> 2)排序的顺序发生改变；
     <br> 3)要进行大量插入操作或已经完成；
     <br> 4)使用I/O查询的磁盘读次数比预料的要多；
     <br> 5)由于大量数据修改，使得数据页和索引页没有充分使用而导致空间的使用超出估算；
     <br> 6)dbcc检查出索引有问题。
     <br>
     <br>
     <strong>六、索引的使用原则</strong>
     <br>
     <br> 接近尾声的时候，让我们再从另一个角度认识索引的两个重要属性----唯一性索引和复合性索引。
     <br>
     <br> 在设计表的时候，可以对字段值进行某些限制，比如可以对字段进行主键约束或唯一性约束。
     <br>
     <br> 主键约束是指定某个或多个字段不允许重复，用于防止表中出现两条完全相同的记录，这样的字段称为主键，每张表都可以建立并且只能建立一个主键，构成主键的字段不允许空值。例如职员表中“身份证号”字段或成绩表中“学号、课程编号”字段组合。
     <br>
     <br> 而唯一性约束与主键约束类似，区别只在于构成唯一性约束的字段允许出现空值。
     <br>
     <br> 建立在主键约束和唯一性约束上的索引，由于其字段值具有唯一性，于是我们将这种索引叫做“唯一性索引”，如果这个唯一性索引是由两个以上字段的组合建立的，那么它又叫“复合性索引”。
     <br>
     <br> 注意，唯一索引不是聚集索引，如果对一个字段建立了唯一索引，你仅仅不能向这个字段输入重复的值。并不妨碍你可以对其它类型的字段也建立一个唯一性索引，它们可以是聚集的，也可以是非聚集的。
     <br>
     <br> 唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。如果表中已经有一个主键约束或者唯一性约束，那么当创建表或者修改表时，SQLS自动创建一个唯一性索引。但出于必须保证唯一性，那么应该创建主键约束或者唯一性键约束，而不是创建一个唯一性索引。当创建唯一性索引时，应该认真考虑这些规则：当在表中创建主键约束或者唯一性键约束时， SQLS钭自动创建一个唯一性索引；如果表中已经包含有数据，那么当创建索引时，SQLS检查表中已有数据的冗余性，如果发现冗余值，那么SQLS就取消该语句的执行，并且返回一个错误消息，确保表中的每一行数据都有一个唯一值。
     <br>
     <br> 复合索引就是一个索引创建在两个列或者多个列上。在搜索时，当两个或者多个列作为一个关键值时，最好在这些列上创建复合索引。当创建复合索引时，应该考虑这些规则：最多可以把16个列合并成一个单独的复合索引，构成复合索引的列的总长度不能超过900字节，也就是说复合列的长度不能太长；在复合索引中，所有的列必须来自同一个表中，不能跨表建立复合列；在复合索引中，列的排列顺序是非常重要的，原则上，应该首先定义最唯一的列，例如在（COL1，COL2）上的索引与在（COL2，COL1）上的索引是不相同的，因为两个索引的列的顺序不同；为了使查询优化器使用复合索引，查询语句中的WHERE子句必须参考复合索引中第一个列；当表中有多个关键列时，复合索引是非常有用的；使用复合索引可以提高查询性能，减少在一个表中所创建的索引数量。
     <br>
     <br> 综上所述，我们总结了如下索引使用原则：
     <br> 1)逻辑主键使用唯一的成组索引，对系统键（作为存储过程）采用唯一的非成组索引，对任何外键列采用非成组索引。考虑数据库的空间有多大，表如何进行访问，还有这些访问是否主要用作读写。
     <br> 2)不要索引memo/note 字段，不要索引大型字段（有很多字符），这样作会让索引占用太多的存储空间。
     <br> 3)不要索引常用的小型表
     <br> 4)一般不要为小型数据表设置过多的索引，假如它们经常有插入和删除操作就更别这样作了，SQLS对这些插入和删除操作提供的索引维护可能比扫描表空间消耗更多的时间。
     <br>
     <br>
     <strong>七、大结局</strong>
     <br>
     <br> 查询是一个物理过程，表面上是SQLS在东跑西跑，其实真正大部分压马路的工作是由磁盘输入输出系统(I/O)完成，全表扫描需要从磁盘上读表的每一个数据页，如果有索引指向数据值，则I/O读几次磁盘就可以了。但是，在随时发生的增、删、改操作中，索引的存在会大大增加工作量，因此，合理的索引设计是建立在对各种查询的分析和预测上的，只有正确地使索引与程序结合起来,才能产生最佳的优化方案。
     <br>
     <br> 一般来说建立索引的思路是：
     <br>
     <br> (1)主键时常作为where子句的条件，应在表的主键列上建立聚聚集索引，尤其当经常用它作为连接的时候。
     <br> (2)有大量重复值且经常有范围查询和排序、分组发生的列，或者非常频繁地被访问的列，可考虑建立聚聚集索引。　　
     <br> (3)经常同时存取多列，且每列都含有重复值可考虑建立复合索引来覆盖一个或一组查询，并把查询引用最频繁的列作为前导列，如果可能尽量使关键查询形成覆盖查询。
     <br> (4)如果知道索引键的所有值都是唯一的，那么确保把索引定义成唯一索引。
     <br> (5)在一个经常做插入操作的表上建索引时，使用fillfactor(填充因子)来减少页分裂，同时提高并发度降低死锁的发生。如果在只读表上建索引，则可以把fillfactor置为100。
     <br> (6)在选择索引字段时，尽量选择那些小数据类型的字段作为索引键，以使每个索引页能够容纳尽可能多的索引键和指针，通过这种方式，可使一个查询必须遍历的索引页面降到最小。此外，尽可能地使用整数为键值，因为它能够提供比任何数据类型都快的访问速度。
     <br>
     <br> SQLS是一个很复杂的系统，让索引以及查询背后的东西真相大白，可以帮助我们更为深刻的了解我们的系统。一句话，索引就象盐，少则无味多则咸
    </div> 
    <div class="blogpost-body">
     <br>
    </div> 
    <div class="blogpost-body">
     <br>
    </div> 
    <div class="blogpost-body">
     <br>
    </div> 
    <div class="blogpost-body">
     本文转自94cool博客园博客，原文链接：http://www.cnblogs.com/94cool/archive/2010/03/10/1682530.html，如需转载请自行联系原作者&nbsp;
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
