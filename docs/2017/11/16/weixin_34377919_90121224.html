<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++ STL 学习笔记 « NotBeCN</title>
  <meta name="description" content="             #.string 建议    &nbsp; 使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 &nbsp; &nbsp;    &nbsp; string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/16/weixin_34377919_90121224.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C++ STL 学习笔记</h1>
    <p class="post-meta">Nov 16, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.string 建议</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 &nbsp; &nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多线程下你使用任何STL容器都要慎重)。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; string的实现和效率并不一定是你想象的那样，如果你对大量的字符串操作，而且特别关心其效率，那么你有两个选择，首先，你可以看看你使用的STL版本中string实现的源码；另一选择是你自己写一个只提供你需要的功能的类。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; string的data()函数：如果string的size()不为0，返回的指针指向string对应的字符串的第一个字符，大小为size()个；如果string的size()为0，返回一个非null的指针，该指针不能被解引用。 对于c_str() data()函数，返回的指针指向的内容都是const的，内容都是由string本身拥有，不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 尽量去使用操作符，这样可以让程序更加易懂（特别是那些脚本程序员也可以看懂）。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; find()函数都返回一个size_type类型，这个返回值一般都是所找到字符串的位置，如果没有找到，则返回string::npos。有一点需要特别注意，所有和string::npos的比较一定要用string::size_type来使用，不要直接使用int或者unsigned int等类型。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.sort 建议</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 默认的都是从小到大排序</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 1.若需对vector, string, deque, 或 array 容器进行全排序，你可选择sort或stable_sort；</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 2.若只需对vector, string, deque, 或 array 容器中取得top n的元素，部分排序partial_sort是首选. &nbsp; 如：前5个：partial_sort(vect.begin(), vect.begin()+5, vect.end());</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 3.若对于vector, string, deque 或 array 容器，你需要找到第n个位置的元素或者你需要得到top n且不关系top n中的内部顺序，nth_element是最理想的。 &nbsp; 如：找排在第5的位置 nth_element(vect.begin(), vect.begin()+4, vect.end()); //注意是begin()+4</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; partial_sort()和nth_element()都把5个最小的放在前面</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 4.若你需要从标准序列容器或者array中把满足某个条件或者不满足某个条件的元素分开，你最好使用partition或stable_partition。 &nbsp; 如：student exam("pass", 60); stable_partition(vect.begin(), vect.end(), bind2nd(less&lt;student&gt;(), exam));</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 5.若使用的list容器，你可以直接使用partition和stable_partition算法，你可以使用list::sort代替sort和stable_sort排序。若你需要得到partial_sort或nth_element的排序效果，你必须间接使用。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 6.sort, stable_sort, partial_sort, 和nth_element算法都需要以随机迭代器(random access iterators)为参数，因此这些算法能只能用于vector, string, deque, 和array等容器，对于标准的关联容器map、set、multimap、multiset等，这些算法就有必要用了，这些容器本身的比较函数使得容器内所有元素一直都是有序排列的。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 7.对于容器list，看似可以用这些排序算法，其实也是不可用的（其iterator的类型并不是随机迭代器），不过在需要的时候可以使用list自带的排序函数sort(有趣的是list::sort函数和一个“稳定”排序函数的效果一样)。 对一个list容器使用partial_sort或nth_element，只能间接使用: 方法(1)：把list中的元素拷贝到带有随机迭代器的容器中，然后再使用这些算法； 方法(2)：生成一个包含list::iterator的容器，直接对容器内的list::iterator进行排序，然后通过list::iterator得到所指的元素； 方法(3)：借助一个包含iterator的有序容器，然后反复把list中的元素连接到你想要链接的位置。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; list成员函数的行为和它们兄弟的行为经常不同。如想从容器删除对象，调用remove，remove_if和unique算法后，必须接着调用erase才能真正删除对象，但list的remove，remove_if和unique真的删除掉了对象。sort算法不能用于list，但list可以调用自己的sort成员函数。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 8.partition和stable_partition与sort、stable_sort、partial_sort和nth_element不同，它们只需要双向迭代器。因此可以在任何标准序列迭代器上使用partition和stable_partition</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 9.时间和空间复杂度: stable_sort &gt; sort &gt; partial_sort &gt; nth_element &gt; stable_partition &gt; partition</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.删除容器中的特定值</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 1.如果容器是vector string deque，使用erase和remove的惯用法： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; c.erase(remove(c.begin(),c.end(),value),c.end()) &nbsp; remove并不能“真的”删除元素，因为它做不到，如果你真的要删除元素，要在remove上接上erase</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 2.如果容器是list，使用list::remove （ls.remove(value)）</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 3.如果容器是关联容器，用erase删除容器中满足一个特定条件的值：c.erase(c.begin()) &nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 1.如果容器是vector string deque，使用erase和remove_if的惯用法</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 2.如果容器是list，使用list::remove_if</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 3.如果容器是关联容器，用remove_copy_if和swap，或写一个循环遍历容器元素，把迭代器传给erase时后置递增它。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">循环遍历删除容器中的值：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">顺序容器循环遍历容器元素删除值：</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(vector&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;::iterator i=c.begin(); i!=<span style="font-size:12px;line-height:1.5;">c.end(); )
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>( condition(*i) ) i=<span style="font-size:12px;line-height:1.5;">c.erase(i);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> ++<span style="font-size:12px;line-height:1.5;">i;

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">关联容器循环遍历容器元素删除值：关联容器的erase(i)会返回删除元素的个数，这里只关心删除的值</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(map&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;::iterator i=c.begin(); i!=<span style="font-size:12px;line-height:1.5;">c.end(); )
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>( condition(*i) ) c.erase(i++<span style="font-size:12px;line-height:1.5;">);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> ++i;</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.迭代器失效</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">vector：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">1.当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">2.当插入（push_back）一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时begin和end操作返回的迭代器都会失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">3.当进行删除操作（erase，pop_back）后，指向删除点的迭代器失效；指向删除点后面的元素的迭代器也将全部失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">deque迭代器的失效情况：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">1.在deque容器首部（push_front）或者尾部（push_back）插入元素不会使得任何迭代器失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">2.在其首部（pop_front）或尾部（pop_back）删除元素则只会使指向被删除元素的迭代器失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">3.在deque容器的任何其他位置的插入（insert）和删除（erase）操作将使指向该容器元素的所有迭代器失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">list/set/map</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">1.删除时，指向该删除节点的迭代器失效</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">迭代器使用注意事项：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">1.resize 操作可能会使迭代器失效。在 vector 或 deque 容器上做 resize 操作有可能会使其所有的迭代器都失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">2.不要存储 end 操作返回的迭代器。添加或删除 deque 或 vector 容器内的元素都会导致存储的end迭代器失效。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">3.使用越界的下标，或调用空容器的 front 或 back 函数，都会导致程序出现严重的错误。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">4.赋值和 assign 操作使左操作数容器的所有迭代器失效。swap 操作则不会使迭代器失效。完成 swap 操作后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">5.由于 assign 操作首先删除容器中原来存储的所有元素，因此，传递给 assign 函数的迭代器不能指向调用该函数的容器内的元素。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">6.只适用于vector和deque容器的迭代器操作：iter + n、iter - n、iter1 += iter2、&gt;, &gt;=, &lt;, &lt;=</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">7.list 容器的迭代器既不支持算术运算（加法或减法），也不支持关系运算（&lt;=, &lt;, &gt;=, &gt;），它只提供前置和后置的自增、自减运算以及相等（不等）运算。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.使用“交换技巧”来休整过剩容量</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; class Contestant{....}<br> &nbsp; vector&lt;Contestant&gt; v;<br> &nbsp; ....&nbsp; //是v变大然后删除部分<br> &nbsp; vector&lt;Contestant&gt;(v).swap(v); //在v上“收缩到合适”（v.size()=v.capacity()）<br> &nbsp; vector&lt;Contestant&gt;( ).swap(v); //清除v而且最小化它的容量</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; string s;<br> &nbsp; .....&nbsp;&nbsp;&nbsp;&nbsp; //是s变大然后删除部分<br> &nbsp; string(s).swap(s); //在s上“收缩到合适”<br> &nbsp; string( ).swap(s); //清除s而且最小化它的容量</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.为指针的关联容器指定比较类型（不是比较函数）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">set&lt;string*&gt; ssp; //建立一个指针的关联容器，容器会以指针的值排序，所以输出时候string不会按字典顺序</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span> StringLess: <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> binary_function&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>*, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>*, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span>&gt;<span style="font-size:12px;line-height:1.5;">
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>()(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>* ps1,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>* ps2) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> *ps1 &lt; *<span style="font-size:12px;line-height:1.5;">ps2;
    }
};

typedef </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">set</span>&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>*,StringLess&gt;<span style="font-size:12px;line-height:1.5;"> StringPtrSet;
StringPtrSet ssp;</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">或者：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span><span style="font-size:12px;line-height:1.5;"> DereferenceLess
{
    template</span>&lt;typename PtrType&gt;
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>()(PtrType p1, PtrType p2) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> *p1 &lt; *<span style="font-size:12px;line-height:1.5;">p2;
    }
};

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">set</span>&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>*,DereferenceLess&gt; ssp;</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">如果有一个智能指针或迭代器的关联容器，也得为它指定“比较类型”</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.equal_range的用法</strong></p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre> typedef vector&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>&gt;<span style="font-size:12px;line-height:1.5;">::iterator vit; 
 typedef pair</span>&lt;vit,vit&gt;<span style="font-size:12px;line-height:1.5;"> vitpair;
 sort(svec.begin(),svec.end());
 vitpair vp </span>= equal_range(svec.begin(),svec.end(),<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">aaa</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="font-size:12px;line-height:1.5;">);
 </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(vp.first !=<span style="font-size:12px;line-height:1.5;"> vp.second)
    cout</span>&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">\nFind the string\n</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="font-size:12px;line-height:1.5;">;
 </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> cout&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;"> Not find the string\n</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="font-size:12px;line-height:1.5;">;
 </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(vp.first !=<span style="font-size:12px;line-height:1.5;"> vp.second)
    cout</span>&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">There are </span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span>&lt;&lt;distance(vp.first,vp.second)&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;"> aaa \n</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span>;</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.使iterator(i)指向const iterator(ci)</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;&nbsp; typedef vector&lt;int&gt;::iterator Iter;<br> &nbsp;&nbsp; typedef vector&lt;int&gt;::const_iterator ConstIter;<br> &nbsp;&nbsp; 从iterator到const iterator没有隐式类型转换，也不能用Iter i(const_cast&lt;Iter&gt;(ci));因为iterator(i)和const iterator(ci)是两种完全不同的类型<br> &nbsp;&nbsp; 可以用以下技巧：<br> &nbsp;&nbsp; advance(i,distance&lt;ConstIter&gt;(i,ci)); //使i指向ci指向的元素<br> &nbsp;&nbsp; 建议：尽量用iterator代替const_iterator和reverse_iterator</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.只能操作有序数据的算法</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 搜索算法：&nbsp; binary_search,lower_bound,upper_bound,equal_range, &nbsp; set_union,set_intersection,set_difference,set_symmetric_difference &nbsp; merge, inplace_merge includes</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 一般用于有序区间：unique,unique_copy&nbsp;&nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.保证用于算法的比较函数和用于排序的一致</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; sort(v.begin(),v.end(),greater&lt;int&gt;())<br> &nbsp; //bool it = binary_search(v.begin(),v.end(),5); //error 默认的是升序，会导致未定义的行为<br> &nbsp; bool it = binary_search(v.begin(),v.end(),5,greater&lt;int&gt;());</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.用accumulate和for_each来统计区间</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; #include&lt;numeric&gt;&nbsp;&nbsp; //包含accumulate<br> &nbsp; double sum = accumulate(v.begin(),v.end(),0.0);</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.ptr_fun(),mem_fun()和mem_fun_ref()的用法</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; ptr_fun()可以把指向一个函数的指针转化为一个函数对象。函数必须是一元或是二元函数（不能为无参的函数）<br> &nbsp; transform(begin,end,dest,not1(ptr_fun(fun)));</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; mem_fun 与 mem_fun_ref 是为了使 STL 算法可以将成员函数（member functions）当作参数而加入的，如下：<br> &nbsp; list&lt;Widget *&gt; lpw;<br> &nbsp; for_each(lpw.begin(), lpw.end(),mem_fun(&amp;Widget::test)); // pw-&gt;test();</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; vector&lt;Widget&gt; vw;<br> &nbsp; for_each(vw.begin(), vw.end(),mem_fun_ref(&amp;Widget::test)); // w.test();<br> &nbsp; mem_fun_ref的作用和用法跟mem_fun一样，唯一的不同就是：当容器中存放的是对象实体的时候用mem_fun_ref，当容器中存放的是对象的指针的时候用mem_fun。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.避免对 set 及 multiset 的key进行原地修改</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 这里的“键部分(key part)”指的是 set/multiset 存储的对象 T 中对 set/multiset 的排序算法有影响的部分，或者说是参与排序的部分。比如下例中 User::ID：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span><span style="font-size:12px;line-height:1.5;"> User {
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span><span style="font-size:12px;line-height:1.5;">:
    unsigned </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> ID;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span><span style="font-size:12px;line-height:1.5;"> name;
    unsinged </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> age;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>&amp; gettitle() <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> settitle(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">string</span>&amp;<span style="font-size:12px;line-height:1.5;"> title);  
};

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span> UserIDLess : <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> binary_function&lt;User, User, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span>&gt;<span style="font-size:12px;line-height:1.5;"> {
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span><span style="font-size:12px;line-height:1.5;">:
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>() (<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> User &amp;lhs, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> User &amp;rhs) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;"> {
       </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> lhs.ID &lt;<span style="font-size:12px;line-height:1.5;"> rhs.ID;
    }
};
typedef </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">set</span>&lt;User, UserIDLess&gt; IDUserSet;</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">修改 set/multiset 中的对象时，注意不要改变对象的key（对set/multiset的排序算法有影响的部分），否则容器会被破坏。<br> 如果必须改变键部分，采取如下策略：<br> 1. 找到要修改的对象。i = set.find();<br> 2. 复制对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User b(*i);<br> 3. 修改复制的对象。&nbsp; b.changeSome();<br> 4. 删除原对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set.erase(i++); //自增这个迭代器，保持它有效<br> 5. 插入复制的对象。&nbsp; set.insert(i,b);</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.copy_if的正确实现（STL里没有copy_if）</strong></p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>#include &lt;iostream&gt;<span style="font-size:12px;line-height:1.5;">
#include </span>&lt;vector&gt;<span style="font-size:12px;line-height:1.5;">
#include </span>&lt;functional&gt;<span style="font-size:12px;line-height:1.5;">
#include </span>&lt;iterator&gt;<span style="font-size:12px;line-height:1.5;">
#include </span>&lt;algorithm&gt;
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">using</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">namespace</span><span style="font-size:12px;line-height:1.5;"> std;

template</span>&lt;typename InputIterator,typename OutputIterator,typename Predicate&gt;<span style="font-size:12px;line-height:1.5;">
OutputIterator copy_if(InputIterator begin,InputIterator end,OutputIterator destBegin,Predicate p)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(begin!=<span style="font-size:12px;line-height:1.5;">end)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(p(*begin)) *destBegin++=*<span style="font-size:12px;line-height:1.5;">begin;
        </span>++<span style="font-size:12px;line-height:1.5;">begin;
    }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> destBegin;
}

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> main()
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[]={<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">3</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">5</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">4</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">6</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">8</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">7</span>,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">9</span><span style="font-size:12px;line-height:1.5;">};
    vector</span>&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt; v(a,a+<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">sizeof</span>(a)/<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">sizeof</span>(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;">));
    cout</span>&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">\nOutput the number greater than 4:\n</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="font-size:12px;line-height:1.5;">;
    copy_if(v.begin(),v.end(),ostream_iterator</span>&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;(cout,<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span> <span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span>),bind2nd(greater&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;(),<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">4</span><span style="font-size:12px;line-height:1.5;">));
    cout</span>&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">\nOutput the number greater than 4:\n</span><span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">STl里没有copy_of，但有 remove_copy_of</span>
    remove_copy_if(v.begin(),v.end(),ostream_iterator&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;(cout,<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span> <span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span>),bind2nd(less_equal&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;(),<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">4</span><span style="font-size:12px;line-height:1.5;">)); 

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.使仿函数类可适配</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ptr_fun可以使四个标准函数适配器（not1、not2、bind1st和bind2nd）存在某些typedef，提供这些必要的typedef的函数对象称为可适配的。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">operator()带一个实参的仿函数类，要继承的结构是std::unary_function。operator()带有两个实参的仿函数类，要继承的结构是std::binary_function。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">unary_function和binary_function是模板，所以你不能直接继承它们。取而代之的是，你必须从它们产生的类继承，而那就需要你指定一些类型实参，对于unary_function，你必须指定的是由你的仿函数类的operator()所带的参数的类型和它的返回类型。对于binary_function，你要指定三个类型：你的operator的第一个和第二个参数的类型，和你的operator地返回类型。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">两个的例子：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>template&lt;typename T&gt;
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span> MeetsThreshold: <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> unary_function&lt;Widget, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span>&gt;<span style="font-size:12px;line-height:1.5;">
{
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span><span style="font-size:12px;line-height:1.5;">:
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;"> T threshold;

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span><span style="font-size:12px;line-height:1.5;">:
    MeetsThreshold(</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> T&amp;<span style="font-size:12px;line-height:1.5;"> threshold);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>()(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget&amp;) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">;
    ...
};

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span> WidgetNameCompare:<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> binary_function&lt;Widget, Widget, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span>&gt;<span style="font-size:12px;line-height:1.5;">
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>()(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget&amp; lhs, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget&amp; rhs) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">;
};</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">一般来说，传给unary_function或binary_function的非指针类型都去掉了const和引用。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">当operator()的参数是指针时这个规则变了。这里有一个和WidgetNameCompare相似的结构，但这个使用Widget*指针：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span> PtrWidgetNameCompare:<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> binary_function&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget*, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget*, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span>&gt;<span style="font-size:12px;line-height:1.5;"> 
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>()(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget* lhs, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> Widget* rhs) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">;
};</span></pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>#.其他</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">当用某个模板类型下的成员前面需加上typename，但是不能用class更不能用struct<br> typename vector&lt;T&gt;::iterator it = v.begin();</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">用empty()来代替检查size()是否为0</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">给map添加一个元素时，insert比operator[]效率高</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">更新已经在map的元素时，operator[]效率高</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">尽量用算法代替手写循环</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">尽量用成员函数代替同名算法</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">C++中重载[]要两个版本来满足需要：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span> &amp; String::<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>[](<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> data[n];
}

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span> &amp; String::<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">operator</span>[](<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> n) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span><span style="font-size:12px;line-height:1.5;">
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> data[n];
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><br></a></span>
    </div> 
    <div class="cnblogs_code_toolbar"> 
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"> </a></span>
     <div class="cnblogs_code_toolbar">
      <a title="复制代码" style="text-decoration:underline;border:none;">&nbsp; &nbsp; 本文转自阿凡卢博客园博客，原文链接：http://www.cnblogs.com/luxiaoxun/archive/2012/12/05/2803136.html，如需转载请自行联系原作者</a>
     </div> 
     <a title="复制代码" style="text-decoration:underline;border:none;"> </a>
     <div>
      <a title="复制代码" style="text-decoration:underline;border:none;"><br></a>
     </div> 
     <a title="复制代码" style="text-decoration:underline;border:none;"> </a> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
