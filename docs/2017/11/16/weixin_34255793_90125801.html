<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>【转】卢彦的利用xml实现通用web报表打印 « NotBeCN</title>
  <meta name="description" content="              【转】卢彦的利用xml实现通用web报表打印          开发B/S结构的应用程序最头疼的问题可能就是报表打印了，由于只能采用浏览器来作为用户界面进行交互，所以不能精确控制客户端的打印机。而很多B/S结构的应用程序常常需要完成非常复杂的报表打印任务。而靠IE自带的页面打印功能一般...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/16/weixin_34255793_90125801.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">【转】卢彦的利用xml实现通用web报表打印</h1>
    <p class="post-meta">Nov 16, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2> <a id="AjaxHolder_ctl01_TitleUrl" href="http://www.cnblogs.com/0001/archive/2009/06/16/1504637.html" rel="nofollow"><font color="#0000ff">【转】卢彦的利用xml实现通用web报表打印</font></a> </h2> 
   <div class="postCon"> 
    <span style="font-size:10pt;">开发B/S结构的应用程序最头疼的问题可能就是报表打印了，由于只能采用浏览器来作为用户界面进行交互，所以不能精确控制客户端的打印机。而很多B/S结构的应用程序常常需要完成非常复杂的报表打印任务。而靠IE自带的页面打印功能一般不能满足需要。 <br><br> 采用Crystal Report是一种大型报表系统常用和推荐的解决方案，但是如果我们只需要进行一些小规模的报表打印的话，Crystal Report则显得庞大麻烦了一点，可定制性也不太好，它的打印实际上也是利用了IE的打印功能，也不能精确控制打印效果，而且需要您对它进行注册。<br><br> 所以我们这里讨论的是另外一种办法，简单来说，如果您有下列需求中的任何一条，那么就可以尝试采用本方案。<br><br><strong>　　<font>方案适用性</font></strong> <br><br> 1. 远程数据打印。需要打印的数据并不在本地，必须进行远程读取。<br><br> 2. 需要精确控制打印效果，包括页面格式，分页，附加条目，表格等。<br><br> 3. 出于安全性考虑，不能直接连接到数据库。<br><br><strong>　　<font>方案原理</font></strong><br><br> 其实原理很简单，通过XML强大的自定义功能，我们便能方便的自定义出我们所有需要的格式控制标签，在服务器端进行动态编码后通过WEB服务器传到客户端，然后在客户端进行格式解析，根据服务器端定义的打印格式从客户端直接控制打印机打印出我们需要的报表。<br><br><strong>　　<font>技术选择</font></strong><br><br> 由于报表打印比较复杂，为了能够精确控制打印格式，不能采用WEB浏览器页面打印的方式进行报表打印工作，只能采取自编程控制客户端的打印工作。由于.NET framework的winform可以直接嵌入到网页中，我们在这里选用了该技术，但是请注意，我这么做并不代表.NET winform是唯一的选择，其实您可以采用任何客户端代替它，例如Java Applet或者ActiveX，甚至是一个普通的应用程序都能行。<br><br> 不允许直接连接到数据库，因此只能采用XML文件进行中间数据交换格式，通过普通WEB服务器的默认80端口进行数据传输。事实上，我简直找不到其它更理想的方案了，当然，web service也许能算是一种，但是它采用的是SOAP传输数据，从原理上看，应该和我们采用的XML属于同种类技术。<br><br> 再补充说明一下我为什么要采用.NET编写的受控组件，优点在于：<br><br> 1. 它不需要进行客户端注册。相对于ActiveX的一个大优点。<br><br> 2. 比ActiveX安全性高。在.NET Common Language Runtime的控制之下运行<br><br> 3. 编写方便。我喜欢C#和Visual Studio .NET。<br><br> 4. 有很强大的打印控制功能。利用.NET framework类库。<br><br> 5. 直接支持XML技术。<br><br> 6. 和IE兼容性高。同为Microsoft公司产品。<br><br> 另外，需要注意一点就是，在.NET framework sp1和sp2中默认的安全级别是不能直接运行受控组件的，但是在.NET framework 1.1 beta中又改了回来，可以直接运行了。<br><br> 服务器端您则可以采用现有的服务器系统和数据库，不需要新添加任何新硬件设备和新的.NET服务器管理人员，他们往往是些要求拿高薪的家伙。 ：）<br><br> 服务器的工作流程为：<br><br> 1. 接受客户端的标准XML模版查询。<br><br> 2. 需要根据查询要求将数据库数据格式转换成标准的XML数据格式。<br><br> 3. 将XML数据通过80端口发送出去。<br><br> 可行性分析<br><br> 由于现在的大部分数据库都支持XML格式的数据查询和转换，如SQL Server 2000，Oracle 9i，IBM DB2等大型关系型数据库。只需要通过简单的设置就能直接进行XML数据转换工作。如果数据库不能支持直接XML数据转换，也可以籍由一些服务器端脚本程序进行脚本转换工作，比如JSP，ASP，PHP等等。<br><br> 客户端也不需要任何特殊的设置工作，仅需要安装一个大小为21M的.NET framework分发包，然后直接打开网页就可以进行工作。也没有操作系统限制，从windows 98到windows xp都能很好的支持。<br></span>
    <span style="font-size:10pt;"><font color="#ac0000">伸缩性和安全性<br><br></font>　　<strong>伸缩性</strong><br><br> 由于采用的是XML标准数据格式作为中间数据交换，因此本解决方案具有非常好伸缩性，例如，客户端的.NET控件可以采用JAVA APPLET、ACTIVX或者是VB，VC等编写的客户端应用程序直接替换。服务器也可以任意选择采用IIS或APACHE等WEB服务器。数据库也可以采用任意一种数据库。包括SQL Server，Oracle或者是Access等。这点上文已经谈到过，因为文章的长一点并不会使送给我的T恤大一号，这里再强调一遍只是为了加深读者对XML的跨平台性的认识。 ：）<br><br><strong>安全性</strong><br><br> 由于采用的是普通WEB服务器传送数据，因此可以直接采用SSL安全套接字等已经成熟的WEB加密技术。同时还可以对XML进行数据算法加密，在客户端再进行解密，保证了传输的安全性。<br><br> 由于采用的是80端口，不需要再另外新增加专用端口，减少了安全漏洞的可能性，同时还能方便的穿过双方的的网络防火墙等保护设备。<br><br><strong>方案设计图</strong><br></span>
    <br>
    <img width="553" height="288" alt="" src="http://www.yesky.com/20030214/jt-030214-xmlwebreport01.gif">
    <br>
    <br>
    <strong>　　格式定义</strong>
    <br>
    <br> 为了能自己控制打印的格式，我们定义了下列的格式标签，其中在命名上参考了HTML的命名办法，所以基本上熟悉HTML的都能一看就能明白标签的具体含义。如果您觉得这些标签的表达能力还不够强，您还可以自己定义一些更多更精确的格式标签。
    <br>
    <br>
    <strong><font>标签应用示例</font>：</strong>
    <br>
    <br>
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;">＜root＞<br> ＜pagesetting＞<br> ＜Landscape＞true＜/Landscape＞<br> ＜paperkind＞A4＜/paperkind＞<br> ＜paperwidth＞210＜/paperwidth＞<br> ＜paperheight＞297＜/paperheight＞<br> ＜pageleft＞0＜/pageleft＞<br> ＜pageright＞0＜/pageright＞<br> ＜pagetop＞0＜/pagetop＞<br> ＜pagebottom＞0＜/pagebottom＞<br> ＜/pagesetting＞<br> ＜reporttable＞<br> ＜text x="450" y="40" fontname="黑体" fontsize="24" fontcolor="Black" <br> b="true" i="false" u="true"＞最新成交合同信息＜/text＞<br> ＜text x="70" y="100" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="true"＞制表时间：2002年0月10日＜/text＞<br> ＜text x="910" y="100" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="true"＞单位：元＜/text＞<br> ＜table x="65" y="130" border ="1" bordercolor="Black" maxlines="28"＞<br> ＜tablehead＞<br> ＜tr height="25"＞<br> ＜td width="90" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞合同号＜/td＞<br> ＜td width="90" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞产品名称＜/td＞<br> ＜td width="50" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞成交量＜/td＞<br> ＜td width="50" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞成交价＜/td＞<br> ＜td width="50" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞成交金额＜/td＞<br> ＜td width="50" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞挂单量＜/td＞ <br> ＜td width="50" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞起始价＜/td＞<br> ＜td width="330" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞卖方＜/td＞<br> ＜td width="330" align="center" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞买方＜/td＞<br> ＜/tr＞<br> ＜/tablehead＞<br> ＜tablebody＞<br><br> ＜tr height="25"＞<br> ＜td width="100" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞20021010015＜/td＞<br> ＜td width="100" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞CNR＜/td＞<br> ＜td width="70" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞93＜/td＞<br> ＜td width="70" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞6680＜/td＞<br> ＜td width="70" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞621240＜/td＞<br> ＜td width="70" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞93＜/td＞<br> ＜td width="70" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞6680＜/td＞<br> ＜td width="200" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞湖北省国营新星拖拉机厂＜/td＞<br> ＜td width="200" align="left" fontname="宋体" fontsize="12" fontcolor="Black" <br> b="true" i="false" u="false" bgcolor="White"＞中化国际贸易股份有限公司＜/td＞<br> ＜/tr＞<br> ……….<br> ＜/tablebody＞<br> ＜tablefoot＞<br> ＜/tablefoot＞<br> ＜/table＞<br> ＜/reporttable＞<br> ＜/root＞</td>
      </tr>
     </tbody>
    </table>
    <br>
    <strong>注意事项：</strong>
    <br>
    <br> a) 如果采用服务器脚本动态生成XML文档时，发送内容类型应该设置为text/xml（普通html页面为text/html），字符编码应该为UTF-8，否则会出现编码错误问题。
    <br>
    <br> b) 应该严格按照XML规定的格式来生成文件，否则XML解析器将不会予以解析。
    <br>
    <br> 2. 客户端
    <br>
    <br> 可以采用任意应用程序来读取服务器端生成的XML文件，如果采用VB、DELPHI等桌面应用软件开发工具，则可以使用MSXML的COM解析器。推荐采用.NET，内部已经集成了XML解析器，直接就可以通过使用.NET类库调用。既可以做成桌面应用程序形式，通过远程调用；也可以嵌入到IE浏览器中，直接在网页中运行。
    <br>
    <br> 效果示例图
    <br>
    <br>
    <img width="554" height="415" alt="" src="http://www.yesky.com/20030214/jt-030214-xmlwebreport02.gif">
    <br>
    <br> 打印预览
    <br>
    <br>
    <img width="554" height="415" alt="" src="http://www.yesky.com/20030214/jt-030214-xmlwebreport03.gif">
    <br>
    <br> 注意事项：
    <br>
    <br> 1. 如果采用.NET，客户端必须先安装.NET framework1.0运行环境，下载地址为：http://download.microsoft.com/download/.NETframesdk/Redist/1.0/W98NT42KMeXP/EN-US/dotnetredist.exe
    <br>
    <br> 2. 如果采用嵌入到网页中的形式，那么本程序需要编译成一个控件形式（一个扩展名为dll的文件），然后在网页中插入以下标记：
    <br>
    <br> ＜object id="print" classid="http:print.dll#Print.UserControl1" Width="728" Height="460"＞＜/object＞
    <br>
    <br> 将控件嵌入到一个静态或动态网页中。然后将该控件文件拷贝到和该网页相同的目录中（标记中Print.dll为生成的控件文件名，Print.UserControl1为该控件的命名空间NAMESPACE）。
    <br>
    <font><strong>.Net Web控件方案的实现和扩充</strong></font>
    <br>
    <br>
    <strong>软件原理： </strong> 
    <p style="font-size:10pt;">　　该软件的原理其实很简单，就是要方便的解析出定义好的XML格式标记，解读出文件中标记的参数定义，最后将这些信息还原成打印机输出的图形格式。</p> 
    <p style="font-size:10pt;">　　为了能表达出复杂的报表样式，我们需要定义一些标记，在这些标记中附加上具体的样式信息，作用类似HTML的标签，而我们的解析程序就相当于IE浏览器，所不同的是IE将图形输出到屏幕，而我们是将图形输出到打印机，由于打印机相对于显示屏的特殊性（例如分页），因此我们不能直接采用网页浏览器的标签解析功能来打印，需要自己来做一个满足需要的"打印浏览器"。</p> 
    <p style="font-size:10pt;">　　针对大多数报表的功能需要，我只定义了两种格式标签：文本（text）和表格(table)，它们的具体属性定义和另外一些设置性的标签定义请参考前文，这里再补充一幅结构图帮助读者理解。如下所示：<br><br><img width="419" height="509" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint1.gif"></p> 
    <p style="font-size:10pt;"></p> 
    <p style="font-size:10pt;"></p> 
    <p style="font-size:10pt;"></p> 
    <p style="font-size:10pt;">　　<strong>结构设计：</strong></p> 
    <p style="font-size:10pt;">　　为了描述所有的样式标记，我先定义了一个抽象基类PrintElement，它拥有一个虚拟方法Draw，然后对应表格和文本，从PrintElement派生出两个子类，分别是Table和Text，我还创建了一个Parser类用来解析不同的样式标记和创建对应的对象，它拥有一个静态的方法CreateElement，用来根据不同的格式标签创建出对应的对象。结构图如下所示：<br><br><img width="552" height="270" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint2.gif"><br></p> 
    <p style="font-size:10pt;">　　读过《设计模式》的读者一定已经看出来了，这种设计应用了设计模式中的一个非常著名的模式：Abstract Factory。这里使用该模式的好处就是让标签对象和解析器都独立出来，降低了系统的耦合度，有利于今后在需要的时候可以很容易的增加其它的格式标签（下文将会举一个实例）和方便的更换不同的用户界面（图中Client表示Windows应用程序或者是网页插件）。</p> 
    <p style="font-size:10pt;">　　<strong>代码实现：</strong></p> 
    <p style="font-size:10pt;">　　首先，创建一个"Windows控件库"的新项目，在项目名称处写入RemotePrint，如下图所示：<br><br><img width="536" height="349" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint.jpg"><br></p> 
    <p style="font-size:10pt;">　　然后把新建项目中的那个默认的UserControl1类,它的构造函数名和文件名都改成PrintControl。再将它的背景颜色设置为白色，添加三个按纽，并将它们的Enable属性都设置为false，Anchor属性设置为Bottom, Right，再添加一个Label控件用来显示程序状态，它的Anchor属性设置为Left。如下图所示：<br><br><img width="478" height="159" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint4.jpg"><br></p> 
    <p style="font-size:10pt;">　　再从控件栏中拖入三个打印对象：PrintDocument, PageSetupDialog, PrintPreviewDialog,如下图所示：<br><br><img width="506" height="141" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint5.jpg"><br></p> 
    <p style="font-size:10pt;">　　将其中的pageSetupDialog1和printPreviewDialog1的Document属性均设置为printDocument1。</p> 
    <p style="font-size:10pt;">　　然后为项目添加一个PrintElement的新类，代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">using System;<br> using System.Xml;<br> using System.Drawing;</p> <p style="font-size:10pt;">namespace RemotePrint<br> {<br> public class PrintElement<br> {<br> public PrintElement()<br> {<br> }</p> <p style="font-size:10pt;">public virtual bool Draw(Graphics g)<br> {<br> return false;<br> }<br> }<br> }</p> </td>
      </tr>
     </tbody>
    </table>
    <p style="font-size:10pt;">　　该类中只有一个虚拟方法Draw，注意它规定需要返回一个bool值，这个值的作用是用来指示标签是否在页内打印完毕。</p> 
    <p style="font-size:10pt;">　　然后再添一个Table的新类，代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">using System;<br> using System.Xml;<br> using System.Drawing;</p> <p style="font-size:10pt;">namespace RemotePrint<br> {<br> public class Table : PrintElement<br> {<br> private XmlNode table;<br> public static int count = 0, pc = 1;</p> <p style="font-size:10pt;">public Table(XmlNode Table)<br> {<br> table = Table;<br> }</p> <p style="font-size:10pt;">public override bool Draw(Graphics g)<br> {<br> file://表格坐标<br> int tableX = int.Parse(table.Attributes["x"].InnerText);<br> int tableY = int.Parse(table.Attributes["y"].InnerText);<br> int x = tableX, y = tableY;<br> DrawTopLine(g, table);//画表格顶线<br> Pen pen = new Pen(Color.FromName(table.Attributes["bordercolor"].InnerText), <br> float.Parse(table.Attributes["border"].InnerText));<br> int trheight = 0;<br> file://表头<br> foreach(XmlNode tr in table["tablehead"].ChildNodes)<br> {<br> trheight = int.Parse(tr.Attributes["height"].InnerText);<br> DrawTR(x, y, tr, pen, g);<br> y += trheight;<br> }<br> file://表项<br> for(int i = 0; i ＜ int.Parse(table.Attributes["maxlines"].InnerText); i++)<br> {<br> XmlNode tr = table["tablebody"].ChildNodes[count];<br> trheight = int.Parse(tr.Attributes["height"].InnerText);<br> DrawTR(x, y, tr, pen, g);<br> y += trheight;<br> count++;<br> if(count == table["tablebody"].ChildNodes.Count)<br> break;<br> }<br> x = tableX;<br> file://表底<br> foreach(XmlNode tr in table["tablefoot"].ChildNodes)<br> {<br> trheight = int.Parse(tr.Attributes["height"].InnerText);<br> DrawTR(x, y, tr, pen, g);<br> y += trheight;<br> }<br> int currentpage = pc;<br> pc++;<br> bool hasPage = false;</p> <p style="font-size:10pt;">if(count ＜ table["tablebody"].ChildNodes.Count - 1)<br> {<br> hasPage = true;//需要继续打印<br> }<br> else<br> {<br> count = 0;<br> pc = 1;<br> hasPage = false;//表格打印完毕<br> }<br> return hasPage;<br> }</p> <p style="font-size:10pt;">private void DrawTopLine(Graphics g, XmlNode table)<br> {<br> Pen pen = new Pen(Color.FromName(table.Attributes["bordercolor"].InnerText), <br> float.Parse(table.Attributes["border"].InnerText));<br> int width = 0;<br> foreach(XmlNode td in table.FirstChild.FirstChild)<br> {<br> width += int.Parse(td.Attributes["width"].InnerText);<br> }<br> int x = int.Parse(table.Attributes["x"].InnerText);<br> int y = int.Parse(table.Attributes["y"].InnerText);<br> g.DrawLine(pen, x, y, x + width, y);<br> }</p> <p style="font-size:10pt;">file://画表格行<br> private void DrawTR(int x, int y, XmlNode tr, Pen pen, Graphics g)<br> {<br> int height = int.Parse(tr.Attributes["height"].InnerText);<br> int width;<br> g.DrawLine(pen, x, y, x, y + height);//画左端线条<br> foreach(XmlNode td in tr)<br> {<br> width = int.Parse(td.Attributes["width"].InnerText);<br> DrawTD(x, y, width, height, td, g);<br> g.DrawLine(pen, x + width, y, x + width, y + height);//右线<br> g.DrawLine(pen, x, y + height, x + width, y + height);//底线<br> x += width;<br> }<br> }</p> <p style="font-size:10pt;">file://画单元格<br> private void DrawTD(int x, int y, int width, int height, XmlNode td, Graphics g)<br> {<br> Brush brush = new SolidBrush(Color.FromName(td.Attributes["bgcolor"].InnerText));<br> g.FillRectangle(brush, x, y, width, height);<br> FontStyle style = FontStyle.Regular;<br> file://设置字体样式<br> if(td.Attributes["b"].InnerText == "true")<br> style |= FontStyle.Bold;<br> if(td.Attributes["i"].InnerText == "true")<br> style |= FontStyle.Italic;<br> if(td.Attributes["u"].InnerText == "true")<br> style |= FontStyle.Underline;<br> Font font = new Font(td.Attributes["fontname"].InnerText, <br> float.Parse(td.Attributes["fontsize"].InnerText), style);<br> brush = new SolidBrush(Color.FromName(td.Attributes["fontcolor"].InnerText));<br> StringFormat sf = new StringFormat();<br> file://设置对齐方式<br> switch(td.Attributes["align"].InnerText)<br> {<br> case "center":<br> sf.Alignment = StringAlignment.Center;<br> break;<br> case "right":<br> sf.Alignment = StringAlignment.Near;<br> break;<br> default:<br> sf.Alignment = StringAlignment.Far;<br> break;<br> }<br> sf.LineAlignment = StringAlignment.Center;<br> RectangleF rect = new RectangleF( (float)x, (float)y, (float)width, (float)height);<br> g.DrawString(td.InnerText, font, brush, rect, sf);<br> }<br> }<br> }</p> </td>
      </tr>
     </tbody>
    </table>
    <p style="font-size:10pt;">　　Table类将table标签内部的解析和打印独立出来，全部在类的内部完成，这样，我们在对顶层标签解析的时候只要是碰到table标签就直接交给Table类去完成，不需要再关心其实现细节。</p> 
    <p style="font-size:10pt;">　　再添加一个Text类，代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">using System;<br> using System.Xml;<br> using System.Drawing;</p> <p style="font-size:10pt;">namespace RemotePrint<br> {<br> public class Text : PrintElement<br> {<br> private XmlNode text = null;<br> public Text(XmlNode Text)<br> {<br> text = Text;<br> }<br> public override bool Draw(Graphics g)<br> {<br> Font font = new Font(text.Attributes["fontname"].InnerText, <br> int.Parse(text.Attributes["fontsize"].InnerText));<br> Brush brush = new SolidBrush(Color.FromName(text.Attributes["fontcolor"].InnerText));<br> g.DrawString(text.InnerText, font, brush, float.Parse(text.Attributes["x"].InnerText), <br> float.Parse(text.Attributes["y"].InnerText));<br> return false;<br> }<br> }<br> }</p> </td>
      </tr>
     </tbody>
    </table>
    <p style="font-size:10pt;">　　同Table类一样，Text类完成对text标签的解析和打印，不过因为text的简单性，它的代码也少了很多。它们两者同样继承自PrintElement，都重载了Draw方法的实现<br> 最后，我们还需要一个解析器用来解析顶层的标签和生成相应的对象，它在此模式中的作用就是一个"工厂类"，负责生产出用户需要的"产品"。代码如下： </p> 
    <p style="font-size:10pt;"></p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">using System;<br> using System.Xml;</p> <p style="font-size:10pt;">namespace RemotePrint<br> {<br> public class Parser<br> {<br> public Parser()<br> {<br> }<br> public static PrintElement CreateElement(XmlNode element)<br> {<br> PrintElement printElement = null;<br> switch(element.Name)<br> {<br> case "text":<br> printElement = new Text(element);<br> break;<br> case "table":<br> printElement = new Table(element);<br> break;<br> default:<br> printElement = new PrintElement();<br> break;<br> }<br> return printElement;<br> }<br> }<br> }</p> </td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　好了，核心的解析和标签的具体打印方法已经完成了，现在我们回到PrintControl中编写一些代码来测试我们的成果。</p> 
    <p style="font-size:10pt;">　　首先，需要引用两个要用到的名称空间：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">using System.Xml;</p> <p style="font-size:10pt;">using System.Drawing.Printing;</p> </td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　然后，在打印之前，需要根据XML文件中的pagesetting标签来设置一下打印机的页面，所以我们先写一个方法来设置打印机。在PrintControl类中增加一个私有的方法：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;">private void SettingPrinter(XmlNode ps)<br> {<br> file://打印方向（纵/横）<br> this.printDocument1.DefaultPageSettings.Landscape = bool.Parse(ps["landscape"].InnerText);<br> file://设置纸张类型<br> string papername = ps["paperkind"].InnerText;<br> bool fitpaper = false;<br> file://获取打印机支持的所有纸张类型<br> foreach(PaperSize size in this.printDocument1.PrinterSettings.PaperSizes)<br> {<br> if(papername == size.PaperName)//看该打印机是否有我们需要的纸张类型<br> {<br> this.printDocument1.DefaultPageSettings.PaperSize = size;<br> fitpaper = true;<br> }<br> }<br> if(!fitpaper)<br> {<br> file://假如没有我们需要的标准类型,则使用自定义的尺寸<br> this.printDocument1.DefaultPageSettings.PaperSize = <br> new PaperSize("Custom", int.Parse(ps["paperwidth"].InnerText), <br> int.Parse(ps["paperheight"].InnerText));<br> }<br> }</td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　接下来，我们类中添加一个XmlDocument的对象和一个静态变量计算页码：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">private XmlDocument doc = new XmlDocument();</p> <p style="font-size:10pt;">public static int Pages = 1;</p> </td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　然后再控件的Load事件中为该对象加载XML报表数据，代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;">private void PrintControl_Load(object sender, System.EventArgs e)<br> {<br> try<br> {<br> file://装载报表XML数据<br> this.label1.Text = "正在加载报表数据，请稍侯...";<br> doc.Load("http://localhost/report.xml");<br> this.label1.Text = "报表数据加载完毕！";<br> this.button1.Enabled = this.button2.Enabled = this.button3.Enabled = true;<br> }<br> catch(Exception ex)<br> {<br> this.label1.Text = "出现错误：" + ex.Message;<br> }<br> }</td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　请注意，我们这里只是装入了一个本地的测试数据文件，其实，完全可以改成装载网络上任何地方的静态或者动态的XML文件，例如以上的doc.Load("http://localhost/report.xml")可以改写成：</p> 
    <p style="font-size:10pt;">doc.Load("http://www.anywhere.com/report.xml");</p> 
    <p style="font-size:10pt;">doc.Load("http://www.anywhere.com/report.asp");</p> 
    <p style="font-size:10pt;">doc.Load("http://www.anywhere.com/report.jsp？date=xxx");</p> 
    <p style="font-size:10pt;">　　等等，只要装载的数据是符合我们规定的XML数据文档就可以。</p> 
    <p style="font-size:10pt;">　　然后在控件的构造函数中加入打印事件的委托：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">public PrintControl()</p> <p style="font-size:10pt;">{</p> <p style="font-size:10pt;">InitializeComponent();</p> <p style="font-size:10pt;">this.printDocument1.PrintPage += new PrintPageEventHandler(this.pd_PrintPage);</p> <p style="font-size:10pt;">}</p> </td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　该委托方法的代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">private void pd_PrintPage(object sender, PrintPageEventArgs ev) <br> {<br> Graphics g = ev.Graphics;<br> bool HasMorePages = false;<br> PrintElement printElement = null;<br><br> foreach(XmlNode node in doc["root"]["reporttable"].ChildNodes)<br> {<br> printElement = Parser.CreateElement(node);//调用解析器生成相应的对象<br> try<br> {<br> HasMorePages = printElement.Draw(g);//是否需要分页<br> }<br> catch(Exception ex)<br> {<br> this.label1.Text = ex.Message;<br> }<br> }</p> <p style="font-size:10pt;">file://在页底中间输出页码<br> Font font = new Font("黑体", 12.0f);<br> Brush brush = new SolidBrush(Color.Black);<br> g.DrawString("第 " + Pages.ToString() + " 页",<br> font,brush,ev.MarginBounds.Width / 2 + ev.MarginBounds.Left - 30, <br> ev.PageBounds.Height - 60);</p> <p style="font-size:10pt;">if(HasMorePages)<br> {<br> Pages++;<br> }<br> ev.HasMorePages = HasMorePages;<br> }</p> </td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　三个按纽的Click事件代码分别如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;">//页面设置<br> private void button1_Click(object sender, System.EventArgs e)<br> {<br> this.pageSetupDialog1.ShowDialog();<br> this.printDocument1.DefaultPageSettings = this.pageSetupDialog1.PageSettings;<br> }<br> file://打印预览<br> private void button2_Click(object sender, System.EventArgs e)<br> {<br> try<br> {<br> this.printPreviewDialog1.ShowDialog();<br> }<br> catch(Exception ex)<br> {<br> this.label1.Text = ex.Message;<br> }<br> }<br> file://打印<br> private void button3_Click(object sender, System.EventArgs e)<br> {<br> try<br> {<br> this.printDocument1.Print();<br> }<br> catch(Exception ex)<br> {<br> this.label1.Text = ex.Message;<br> }<br> }</td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　好了，我们的打印控件到这里就全部做完了，选择生成一个Release的版本，然后到工程目录下将生成的PrintControl.dll文件拷贝到IIS的虚拟根目录下，然后新建一个remoteprint.htm的HTML格式文件，在合适的地方加上：＜object id="print" classid="http:RemotePrint.dll#RemotePrint.PrintControl" Width="100%" Height="60"＞ ＜/object＞，为了更加形象和美观，还可以将需要打印的数据做成网页形式放在上面，如果需要获取的XML是动态数据源，则可以采用asp等动态脚本来生成该网页表格，如果需要获取的XML是一个静态的文本，则可以采用XSLT直接将XML文件转换成网页表格。</p> 
    <p style="font-size:10pt;">　　打开浏览器，输入：http://localhost/remoteprint.htm，如果您已经跟我一样，事先做好了一个XML报表数据文件的话，您就可以看到下图所示的效果</p> 
    <p style="font-size:10pt;"><img width="554" height="464" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint6.jpg">　　<br><br><img width="554" height="466" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint7.jpg"></p> 
    <p style="font-size:10pt;">　　请注意：该图示例中的所有数据均为笔者随意虚拟，网页中的表格数据和打印数据并非来自同一数据源，也没有刻意去对等，仅仅只是为了演示一下效果，因此网页显示报表跟打印预览中的报表有一些出入是正常的。在实际应用中可以让网页显示数据跟打印输出数据完全一致。<br><strong>方案扩充：</strong> </p> 
    <p style="font-size:10pt;"></p> 
    <p style="font-size:10pt;">　　那么如何打印一些特殊形态的图表，前文中已经提到，采用本方案可以非常方便的定义出自己所需要的标签，在理论上可以打印出任何样式的特殊图表。因此本文打算详细介绍一下增加自己定义的标签扩充打印格式的具体过程。</p> 
    <p style="font-size:10pt;">　　先假设我们的客户看了打印效果后基本上满意，但是还有觉得一点不足，如果需要打印一些图表怎么办？例如折线图、K线图、饼状图、柱状图等等。使用我们现有的标签就不行了，所以我们首先要扩充我们的标签库，让它的表达能力更加强。在这里，我将只打算让我们的打印控件学会画简单的折线图，希望读者能举一反三，创造出其它各种各样的打印效果。</p> 
    <p style="font-size:10pt;">　　最基本的折线图是由X坐标轴、Y坐标轴和一系列点连接成的线构成的，因此，我定义了以下几种标签：</p> 
    <p style="font-size:10pt;">　　1. linechart：跟table，text标签一样，为样式根标签。</p> 
    <p style="font-size:10pt;">　　　属性：无</p> 
    <p style="font-size:10pt;">　　2． coordinate：坐标。</p> 
    <p style="font-size:10pt;">　　　属性：无</p> 
    <p style="font-size:10pt;">　　3． xcoordinate：X轴坐标线</p> 
    <p style="font-size:10pt;">　　　属性：</p> 
    <p style="font-size:10pt;">　　　# x：起点X坐标值 </p> 
    <p style="font-size:10pt;">　　　# y：起点Y坐标值 </p> 
    <p style="font-size:10pt;">　　　# length：长度值 </p> 
    <p style="font-size:10pt;">　　　# stroke：粗细 </p> 
    <p style="font-size:10pt;">　　　# color：颜色 </p> 
    <p style="font-size:10pt;">　　　# arrow：是否有箭头 </p> 
    <p style="font-size:10pt;">　　4． ycoordinate：Y轴坐标线</p> 
    <p style="font-size:10pt;">　　　属性：同xcoordinate。</p> 
    <p style="font-size:10pt;">　　5．scale：刻度线</p> 
    <p style="font-size:10pt;">　　　标签内容：显示在刻度边的文字</p> 
    <p style="font-size:10pt;">　　　属性：</p> 
    <p style="font-size:10pt;">　　　# length：距离起点长度值 </p> 
    <p style="font-size:10pt;">　　　# height：刻度线高度 </p> 
    <p style="font-size:10pt;">　　　# width：刻度线宽度 </p> 
    <p style="font-size:10pt;">　　　# color：颜色 </p> 
    <p style="font-size:10pt;">　　　# fontsize：字体大小 </p> 
    <p style="font-size:10pt;">　　6．chart：图表根</p> 
    <p style="font-size:10pt;">　　　属性：无</p> 
    <p style="font-size:10pt;">　　7．lines：线段</p> 
    <p style="font-size:10pt;">　　　属性值：</p> 
    <p style="font-size:10pt;">　　　# stroke：粗细 </p> 
    <p style="font-size:10pt;">　　　# color：颜色 </p> 
    <p style="font-size:10pt;">　　8． point：点</p> 
    <p style="font-size:10pt;">　　　属性值：</p> 
    <p style="font-size:10pt;">　　　# x：X坐标值 </p> 
    <p style="font-size:10pt;">　　　# y：Y坐标值 </p> 
    <p style="font-size:10pt;">　　　# radius：半径 </p> 
    <p style="font-size:10pt;">　　　# color：颜色 </p> 
    <p style="font-size:10pt;">　　其结构图如下所示：</p> 
    <p style="font-size:10pt;"><img width="504" height="371" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint8.jpg"></p> 
    <p style="font-size:10pt;"><br> 下面是一段用刚才定义的标签制作的XML折线图示例：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;"> <p style="font-size:10pt;">＜linechart＞</p> <p style="font-size:10pt;">＜coordinate＞</p> <p style="font-size:10pt;">＜xcoordinate x="200" y="600" length="800" stroke="2" color="Black" arrow="true"＞</p> <p style="font-size:10pt;">＜scale length="100" height="10" width="1" color="Black" fontsize="9"＞100＜/scale＞</p> <p style="font-size:10pt;">＜scale length="200" height="10" width="1" color="Black" fontsize="9"＞200＜/scale＞</p> <p style="font-size:10pt;">＜scale length="300" height="10" width="1" color="Black" fontsize="9"＞300＜/scale＞</p> <p style="font-size:10pt;">＜scale length="400" height="10" width="1" color="Black" fontsize="9"＞400＜/scale＞</p> <p style="font-size:10pt;">＜scale length="500" height="10" width="1" color="Black" fontsize="9"＞500＜/scale＞</p> <p style="font-size:10pt;">＜scale length="600" height="10" width="1" color="Black" fontsize="9"＞600＜/scale＞</p> <p style="font-size:10pt;">＜scale length="700" height="10" width="1" color="Black" fontsize="9"＞700＜/scale＞</p> <p style="font-size:10pt;">＜/xcoordinate＞</p> <p style="font-size:10pt;">＜ycoordinate x="200" y="600" length="-400" stroke="2" color="Black" arrow="true"＞</p> <p style="font-size:10pt;">＜scale length="-100" height="10" width="1" color="Black" fontsize="9"＞100＜/scale＞</p> <p style="font-size:10pt;">＜scale length="-200" height="10" width="1" color="Black" fontsize="9"＞200＜/scale＞</p> <p style="font-size:10pt;">＜scale length="-300" height="10" width="1" color="Black" fontsize="9"＞300＜/scale＞</p> <p style="font-size:10pt;">＜/ycoordinate＞</p> <p style="font-size:10pt;">＜/coordinate＞</p> <p style="font-size:10pt;">＜chart＞</p> <p style="font-size:10pt;">＜lines stroke="1" color="Blue"＞</p> <p style="font-size:10pt;">＜point x="200" y="600" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="300" y="300" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="400" y="400" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="500" y="500" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="600" y="300" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="700" y="300" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="800" y="600" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="900" y="500" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜/lines＞</p> <p style="font-size:10pt;">＜lines stroke="1" color="Red"＞</p> <p style="font-size:10pt;">＜point x="200" y="400" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="300" y="500" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="400" y="600" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="500" y="300" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="600" y="400" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="700" y="400" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="800" y="500" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜point x="900" y="300" radius="5" color="Black"/＞</p> <p style="font-size:10pt;">＜/lines＞</p> <p style="font-size:10pt;">＜/chart＞</p> <p style="font-size:10pt;">＜/linechart＞</p> </td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　完成了标签的定义，下一步就要来修改我们的程序，让他能"读懂"这些标签。</p> 
    <p style="font-size:10pt;">　　首先，我们先给工程增加一个LineChart的新类，跟Table,Text类一样，它也是继承自PrintElement类，同样重载了Draw虚方法。代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;">using System;<br> using System.Xml;<br> using System.Drawing;<br> using System.Drawing.Drawing2D;<br><br> namespace RemotePrint<br> {<br> public class LineChart : PrintElement<br> {<br> private XmlNode chart;<br> public LineChart(XmlNode Chart)<br> {<br> chart = Chart;<br> }<br> public override bool Draw(Graphics g)<br> {<br> DrawCoordinate(g, chart["coordinate"]);//画坐标轴<br> DrawChart(g, chart["chart"]);<br> return false;<br> }<br> private void DrawCoordinate(Graphics g, XmlNode coo)<br> {<br> DrawXCoor(g, coo["xcoordinate"]);//画X坐标<br> DrawYCoor(g, coo["ycoordinate"]);//画Y坐标<br> }<br> private void DrawXCoor(Graphics g, XmlNode xcoo)<br> {<br> int x = int.Parse(xcoo.Attributes["x"].InnerText);<br> int y = int.Parse(xcoo.Attributes["y"].InnerText);<br> int length = int.Parse(xcoo.Attributes["length"].InnerText);<br> bool arrow = bool.Parse(xcoo.Attributes["arrow"].InnerText);<br> int stroke = int.Parse(xcoo.Attributes["stroke"].InnerText);<br> Color color = Color.FromName(xcoo.Attributes["color"].InnerText);<br> Pen pen = new Pen(color, (float)stroke);<br> if(arrow)//是否有箭头<br> {<br> AdjustableArrowCap Arrow = new AdjustableArrowCap(<br> (float)(stroke * 1.5 + 1.5), <br> (float)(stroke * 1.5 + 2), true);<br> pen.CustomEndCap = Arrow;<br> }<br> g.DrawLine(pen, x, y, x + length, y);//画坐标<br> file://画刻度<br> foreach(XmlNode scale in xcoo.ChildNodes)<br> {<br> int len = int.Parse(scale.Attributes["length"].InnerText);<br> int height = int.Parse(scale.Attributes["height"].InnerText);<br> int width = int.Parse(scale.Attributes["width"].InnerText);<br> int fontsize = int.Parse(scale.Attributes["fontsize"].InnerText);<br> Color clr = Color.FromName(scale.Attributes["color"].InnerText);<br> string name = scale.InnerText;<br><br> Pen p = new Pen(clr, (float)width);<br> g.DrawLine(p, x + len, y, x + len, y - height);<br> Font font = new Font("Arial", (float)fontsize);<br> g.DrawString(<br> name, font, new SolidBrush(clr), <br> (float)(x + len - 10), (float)(y + 10));<br> }<br> }<br> private void DrawYCoor(Graphics g, XmlNode ycoo)<br> {<br> int x = int.Parse(ycoo.Attributes["x"].InnerText);<br> int y = int.Parse(ycoo.Attributes["y"].InnerText);<br> int length = int.Parse(ycoo.Attributes["length"].InnerText);<br> bool arrow = bool.Parse(ycoo.Attributes["arrow"].InnerText);<br> int stroke = int.Parse(ycoo.Attributes["stroke"].InnerText);<br> Color color = Color.FromName(ycoo.Attributes["color"].InnerText);<br> Pen pen = new Pen(color, (float)stroke);<br> if(arrow)//是否有箭头<br> {<br> AdjustableArrowCap Arrow = new AdjustableArrowCap(<br> (float)(stroke * 1.5 + 2), <br> (float)(stroke * 1.5 + 3), <br> true);<br> pen.CustomEndCap = Arrow;<br> }<br> g.DrawLine(pen, x, y, x, y + length);//画坐标<br> file://画刻度<br> foreach(XmlNode scale in ycoo.ChildNodes)<br> {<br> int len = int.Parse(scale.Attributes["length"].InnerText);<br> int height = int.Parse(scale.Attributes["height"].InnerText);<br> int width = int.Parse(scale.Attributes["width"].InnerText);<br> int fontsize = int.Parse(scale.Attributes["fontsize"].InnerText);<br> Color clr = Color.FromName(scale.Attributes["color"].InnerText);<br> string name = scale.InnerText;<br> Pen p = new Pen(clr, (float)width);<br> g.DrawLine(p, x, y + len, x + height, y + len);<br> Font font = new Font("Arial", (float)fontsize);<br> StringFormat sf = new StringFormat();<br> sf.Alignment = StringAlignment.Far;<br> RectangleF rect = new RectangleF(<br> (float)(x - 100), <br> (float)(y + len - 25),<br> 90f, <br> 50f);<br> sf.LineAlignment = StringAlignment.Center;<br> g.DrawString(name, font, new SolidBrush(clr), rect, sf);<br> }<br> }<br> private void DrawChart(Graphics g, XmlNode chart)<br> {<br> foreach(XmlNode lines in chart.ChildNodes)<br> {<br> DrawLines(g, lines);<br> }<br> }<br> private void DrawLines(Graphics g, XmlNode lines)<br> {<br> int Stroke = int.Parse(lines.Attributes["stroke"].InnerText);<br> Point[] points = new Point[lines.ChildNodes.Count];<br> Color linecolor = Color.FromName(lines.Attributes["color"].InnerText);<br> for(int i = 0; i ＜ lines.ChildNodes.Count; i++)<br> {<br> XmlNode node = lines.ChildNodes[i];<br> points[i] = new Point(<br> int.Parse(node.Attributes["x"].InnerText), <br> int.Parse(node.Attributes["y"].InnerText));<br> int Radius = int.Parse(node.Attributes["radius"].InnerText);<br> Color pointcolor = Color.FromName(node.Attributes["color"].InnerText);<br> if(Radius != 0)//画点<br> {<br> g.FillEllipse(new SolidBrush(pointcolor),<br> points[i].X - Radius, <br> points[i].Y - Radius, <br> Radius * 2, <br> Radius * 2);<br> }<br> }<br> Pen pen = new Pen(linecolor);<br> g.DrawLines(pen, points);//画线<br> }<br> }<br> }</td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　然后，为Parser类的CreateElement方法增加一个小case，代码如下：</p> 
    <table>
     <tbody>
      <tr>
       <td style="font-size:10pt;">switch(element.Name)<br> {<br> case "text":<br> printElement = new Text(element);<br> break;<br> case "table":<br> printElement = new Table(element);<br> break;<br> case "linechart"://新增加的linechart<br> printElement = new LineChart(element);<br> break;<br> default:<br> printElement = new PrintElement();<br> break;<br> }</td>
      </tr>
     </tbody>
    </table>
    <p></p> 
    <p style="font-size:10pt;">　　将原来的XML文件中的table标签和其子标签都替换成刚才写的那段linechart，然后编译程序，运行后效果如下所示：</p> 
    <p style="font-size:10pt;"><img width="520" height="381" alt="" src="http://www.yesky.com/20030214/jt-030214-1-xmlwebprint9.jpg"><br><br> 现在，我们的打印控件就能打印折线图了，由于我们采用了Abstract Factory的设计模式，将报表的打印和格式的解析分开，使得本程序有着非常方便的扩充能力，如果需要再增加一种新形式的图表，那么需要定义出标签，写一个解析类，再到Paser中为这个类增加一个case就搞定了，PrintControl内部的代码一行都不需要改写。</p> 
   </div> 
   <div class="clear"></div> 
   <div class="postDesc">
    posted @ 
    <a title="permalink" href="http://www.cnblogs.com/nianshi/archive/2007/07/12/815276.html" rel="nofollow"><font color="#aa7a53">2007-07-12 11:46</font></a> 念时 阅读(206) | 
    <a title="comments, pingbacks, trackbacks" href="http://www.cnblogs.com/nianshi/archive/2007/07/12/815276.html#FeedBack" rel="nofollow"><font color="#aa7a53">评论 (0)</font></a> |&nbsp;
    <a href="http://www.cnblogs.com/nianshi/admin/EditPosts.aspx?postid=815276" rel="nofollow"><font color="#aa7a53">编辑</font></a> 
   </div> 
   <div class="clear">
    <font color="#aa7a53"></font>
   </div> 
   <div class="postSeparator">
    <font color="#aa7a53"></font>
   </div> 
   <div class="postTitle"> 
    <a class="postTitle2" id="homepage1_HomePageDays_ctl00_DayList_ctl18_TitleUrl" href="http://www.cnblogs.com/nianshi/archive/2007/07/10/812989.html" rel="nofollow"><font color="#333333">利用XML实现通用WEB报表打印（实现篇）转载</font></a> 
   </div> 
   <div class="postCon"> 
    <div style="font-size:10pt;"> 
     <div class="text1">
      续：利用XML实现通用WEB报表打印（实现篇）
     </div> 
     <hr>
     <div class="text2">
      摘要：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      本文结合代码详细讲解了《利用XML实现通用WEB报表打印》（以下简称"《利》"）一文中所介绍的报表打印中的.Net Web控件方案的实现及扩充过程。本文为《利》文的续作，文中所举的代码示例均为C#语言编写。
     </div> 
     <hr>
     <div class="text2">
      目录：
     </div> 
     <div class="text4"></div> 
     <ul class="list1">
      <li class="list2"> <strong></strong>引言</li> 
      <li class="list2"> <strong></strong>软件原理</li> 
      <li class="list2"> <strong></strong>结构设计</li> 
      <li class="list2"> <strong></strong>代码实现</li> 
      <li class="list2"> <strong></strong>方案扩充</li> 
      <li class="list2"> <strong></strong>总结 </li> 
     </ul>
     <hr>
     <div class="text2">
      引言：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      在《利》刊出后，有大量的读者发E-Mail给我表示对该方案非常感兴趣，同时还询问具体如何实现报表格式的解析和打印细节并索取该程序的源代码。读者的热情让我始料未及，虽然我一一对来信进行解答和发送了源代码，但是还是深感抱歉和遗憾，因为时间和精力的关系，我不可能对每封信都作出很详细的答复，而且我写的源代码也很乱，事实上，是我花了两个小时赶写出来的（原来的程序因为硬盘故障被销毁了），不但没有什么注解而且还不完善，包括一些标签还没有被实现。
     </div> 
     <div class="text4">
      为了弥补以前的缺憾，我花了一些时间改进了程序的结构，重写了全部的源代码，实现了所有标签的功能，下面就要开始讲解该程序的设计和编码过程，在看此文之前，强烈推荐您先阅读《利》一文来了解一下相关的概念，如果在该文中已经有清楚讲解的部分，本文将不再详细介绍，这里只将主要讲解《利》文没有提及或是介绍得不清楚和读者来信提问最多的部分。
     </div> 
     <hr>
     <div class="text2">
      软件原理：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      该软件的原理其实很简单，就是要方便的解析出定义好的XML格式标记，解读出文件中标记的参数定义，最后将这些信息还原成打印机输出的图形格式。
     </div> 
     <div class="text4">
      为了能表达出复杂的报表样式，我们需要定义一些标记，在这些标记中附加上具体的样式信息，作用类似HTML的标签，而我们的解析程序就相当于IE浏览器，所不同的是IE将图形输出到屏幕，而我们是将图形输出到打印机，由于打印机相对于显示屏的特殊性（例如分页），因此我们不能直接采用网页浏览器的标签解析功能来打印，需要自己来做一个满足需要的"打印浏览器"。
     </div> 
     <div class="text4">
      针对大多数报表的功能需要，我只定义了两种格式标签：文本（text）和表格(table)，它们的具体属性定义和另外一些设置性的标签定义请参考《利》文，这里再补充一幅结构图帮助读者理解。如下所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint1.gif">
     <br>
     <div class="text6"></div> 
     <hr>
     <div class="text2">
      结构设计：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      为了描述所有的样式标记，我先定义了一个抽象基类PrintElement，它拥有一个虚拟方法Draw，然后对应表格和文本，从PrintElement派生出两个子类，分别是Table和Text，我还创建了一个Parser类用来解析不同的样式标记和创建对应的对象，它拥有一个静态的方法CreateElement，用来根据不同的格式标签创建出对应的对象。结构图如下所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint2.gif">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      读过《设计模式》的读者一定已经看出来了，这种设计应用了设计模式中的一个非常著名的模式：Abstract Factory。这里使用该模式的好处就是让标签对象和解析器都独立出来，降低了系统的耦合度，有利于今后在需要的时候可以很容易的增加其它的格式标签（下文将会举一个实例）和方便的更换不同的用户界面（图中Client表示Windows应用程序或者是网页插件）。
     </div> 
     <hr>
     <div class="text2">
      代码实现：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      首先，创建一个"Windows控件库"的新项目，在项目名称处写入RemotePrint，如下图所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      然后把新建项目中的那个默认的UserControl1类,它的构造函数名和文件名都改成PrintControl。再将它的背景颜色设置为白色，添加三个按纽，并将它们的Enable属性都设置为false，Anchor属性设置为Bottom, Right，再添加一个Label控件用来显示程序状态，它的Anchor属性设置为Left。如下图所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint4.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      再从控件栏中拖入三个打印对象：PrintDocument, PageSetupDialog, PrintPreviewDialog,如下图所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint5.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      将其中的pageSetupDialog1和printPreviewDialog1的Document属性均设置为printDocument1。
     </div> 
     <div class="text4">
      然后为项目添加一个PrintElement的新类，代码如下：
     </div> 
     <div>
      <pre class="text5">using System;
using System.Xml;
using System.Drawing;
namespace RemotePrint
{
public class PrintElement
{
public PrintElement()
{
}
public virtual bool Draw(Graphics g)
{
return false;
}
}
}
</pre>
     </div> 
     <div class="text4">
      该类中只有一个虚拟方法Draw，注意它规定需要返回一个bool值，这个值的作用是用来指示标签是否在页内打印完毕。
     </div> 
     <div class="text4">
      然后再添一个Table的新类，代码如下：
     </div> 
     <div>
      <pre class="text5">using System;
using System.Xml;
using System.Drawing;
namespace RemotePrint
{
public class Table : PrintElement
{
private XmlNode table;
public static int count = 0, pc = 1;
public Table(XmlNode Table)
{
table = Table;
}
public override bool Draw(Graphics g)
{
//表格坐标
int tableX = int.Parse(table.Attributes["x"].InnerText);
int tableY = int.Parse(table.Attributes["y"].InnerText);
int x = tableX, y = tableY;
DrawTopLine(g, table);//画表格顶线
Pen pen = new Pen(Color.FromName(table.Attributes["bordercolor"].InnerText),
float.Parse(table.Attributes["border"].InnerText));
int trheight = 0;
//表头
foreach(XmlNode tr in table["tablehead"].ChildNodes)
{
trheight = int.Parse(tr.Attributes["height"].InnerText);
DrawTR(x, y, tr, pen, g);
y += trheight;
}
//表项
for(int i = 0; i &lt; int.Parse(table.Attributes["maxlines"].InnerText); i++)
{
XmlNode tr = table["tablebody"].ChildNodes[count];
trheight = int.Parse(tr.Attributes["height"].InnerText);
DrawTR(x, y, tr, pen, g);
y += trheight;
count++;
if(count == table["tablebody"].ChildNodes.Count)
break;
}
x = tableX;
//表底
foreach(XmlNode tr in table["tablefoot"].ChildNodes)
{
trheight = int.Parse(tr.Attributes["height"].InnerText);
DrawTR(x, y, tr, pen, g);
y += trheight;
}
int currentpage = pc;
pc++;
bool hasPage = false;
if(count &lt; table["tablebody"].ChildNodes.Count - 1)
{
hasPage = true;//需要继续打印
}
else
{
count = 0;
pc = 1;
hasPage = false;//表格打印完毕
}
return hasPage;
}
private void DrawTopLine(Graphics g, XmlNode table)
{
Pen pen = new Pen(Color.FromName(table.Attributes["bordercolor"].InnerText),
float.Parse(table.Attributes["border"].InnerText));
int width = 0;
foreach(XmlNode td in table.FirstChild.FirstChild)
{
width += int.Parse(td.Attributes["width"].InnerText);
}
int x = int.Parse(table.Attributes["x"].InnerText);
int y = int.Parse(table.Attributes["y"].InnerText);
g.DrawLine(pen, x, y, x + width, y);
}
//画表格行
private void DrawTR(int x, int y, XmlNode tr, Pen pen, Graphics g)
{
int height = int.Parse(tr.Attributes["height"].InnerText);
int width;
g.DrawLine(pen, x, y, x, y + height);//画左端线条
foreach(XmlNode td in tr)
{
width = int.Parse(td.Attributes["width"].InnerText);
DrawTD(x, y, width, height, td, g);
g.DrawLine(pen, x + width, y, x + width, y + height);//右线
g.DrawLine(pen, x, y + height, x + width, y + height);//底线
x += width;
}
}
//画单元格
private void DrawTD(int x, int y, int width, int height, XmlNode td, Graphics g)
{
Brush brush = new SolidBrush(Color.FromName(td.Attributes["bgcolor"].InnerText));
g.FillRectangle(brush, x, y, width, height);
FontStyle style = FontStyle.Regular;
//设置字体样式
if(td.Attributes["b"].InnerText == "true")
style |= FontStyle.Bold;
if(td.Attributes["i"].InnerText == "true")
style |= FontStyle.Italic;
if(td.Attributes["u"].InnerText == "true")
style |= FontStyle.Underline;
Font font = new Font(td.Attributes["fontname"].InnerText,
float.Parse(td.Attributes["fontsize"].InnerText), style);
brush = new SolidBrush(Color.FromName(td.Attributes["fontcolor"].InnerText));
StringFormat sf = new StringFormat();
//设置对齐方式
switch(td.Attributes["align"].InnerText)
{
case "center":
sf.Alignment = StringAlignment.Center;
break;
case "right":
sf.Alignment = StringAlignment.Near;
break;
default:
sf.Alignment = StringAlignment.Far;
break;
}
sf.LineAlignment = StringAlignment.Center;
RectangleF rect = new RectangleF( (float)x, (float)y,
(float)width, (float)height);
g.DrawString(td.InnerText, font, brush, rect, sf);
}
}
}
</pre>
     </div> 
     <div class="text4">
      Table类将table标签内部的解析和打印独立出来，全部在类的内部完成，这样，我们在对顶层标签解析的时候只要是碰到table标签就直接交给Table类去完成，不需要再关心其实现细节。
     </div> 
     <div class="text4">
      再添加一个Text类，代码如下：
     </div> 
     <div>
      <pre class="text5">using System;
using System.Xml;
using System.Drawing;
namespace RemotePrint
{
public class Text : PrintElement
{
private XmlNode text = null;
public Text(XmlNode Text)
{
text = Text;
}
public override bool Draw(Graphics g)
{
Font font = new Font(text.Attributes["fontname"].InnerText,
int.Parse(text.Attributes["fontsize"].InnerText));
Brush brush = new SolidBrush(Color.FromName(text.Attributes
["fontcolor"].InnerText));
g.DrawString(text.InnerText, font, brush, float.Parse
(text.Attributes["x"].InnerText),
float.Parse(text.Attributes["y"].InnerText));
return false;
}
}
}
</pre>
     </div> 
     <div class="text4">
      同Table类一样，Text类完成对text标签的解析和打印，不过因为text的简单性，它的代码也少了很多。它们两者同样继承自PrintElement，都重载了Draw方法的实现。
     </div> 
     <div class="text4">
      最后，我们还需要一个解析器用来解析顶层的标签和生成相应的对象，它在此模式中的作用就是一个"工厂类"，负责生产出用户需要的"产品"。代码如下：
     </div> 
     <div>
      <pre class="text5">using System;
using System.Xml;
namespace RemotePrint
{
public class Parser
{
public Parser()
{
}
public static PrintElement CreateElement(XmlNode element)
{
PrintElement printElement = null;
switch(element.Name)
{
case "text":
printElement = new Text(element);
break;
case "table":
printElement = new Table(element);
break;
default:
printElement = new PrintElement();
break;
}
return printElement;
}
}
}
</pre>
     </div> 
     <div class="text4">
      好了，核心的解析和标签的具体打印方法已经完成了，现在我们回到PrintControl中编写一些代码来测试我们的成果。
     </div> 
     <div class="text4">
      首先，需要引用两个要用到的名称空间：
     </div> 
     <div class="text4">
      using System.Xml;
     </div> 
     <div class="text4">
      using System.Drawing.Printing;
     </div> 
     <div class="text4">
      然后，在打印之前，需要根据XML文件中的pagesetting标签来设置一下打印机的页面，所以我们先写一个方法来设置打印机。在PrintControl类中增加一个私有的方法：
     </div> 
     <div>
      <pre class="text5">private void SettingPrinter(XmlNode ps)
{
//打印方向（纵/横）
this.printDocument1.DefaultPageSettings.Landscape = bool.Parse(ps["landscape"].InnerText);
//设置纸张类型
string papername = ps["paperkind"].InnerText;
bool fitpaper = false;
//获取打印机支持的所有纸张类型
foreach(PaperSize size in this.printDocument1.PrinterSettings.PaperSizes)
{
if(papername == size.PaperName)//看该打印机是否有我们需要的纸张类型
{
this.printDocument1.DefaultPageSettings.PaperSize = size;
fitpaper = true;
}
}
if(!fitpaper)
{
//假如没有我们需要的标准类型,则使用自定义的尺寸
this.printDocument1.DefaultPageSettings.PaperSize =
new PaperSize("Custom", int.Parse(ps["paperwidth"].InnerText),
int.Parse(ps["paperheight"].InnerText));
}
}
</pre>
     </div> 
     <div class="text4">
      接下来，我们类中添加一个XmlDocument的对象和一个静态变量计算页码：
     </div> 
     <div class="text4">
      private XmlDocument doc = new XmlDocument();
     </div> 
     <div class="text4">
      public static int Pages = 1;
     </div> 
     <div class="text4">
      然后再控件的Load事件中为该对象加载XML报表数据，代码如下：
     </div> 
     <div>
      <pre class="text5">private void PrintControl_Load(object sender, System.EventArgs e)
{
try
{
//装载报表XML数据
this.label1.Text = "正在加载报表数据，请稍侯...";
doc.Load("http://localhost/report.xml");
this.label1.Text = "报表数据加载完毕！";
this.button1.Enabled = this.button2.Enabled = this.button3.Enabled = true;
}
catch(Exception ex)
{
this.label1.Text = "出现错误：" + ex.Message;
}
}
</pre>
     </div> 
     <div class="text4">
      请注意，我们这里只是装入了一个本地的测试数据文件（该文件的编写请参考《利》文），其实，完全可以改成装载网络上任何地方的静态或者动态的XML文件，例如以上的doc.Load("http://localhost/report.xml")可以改写成：
     </div> 
     <div class="text4">
      doc.Load("http://www.anywhere.com/report.xml");
     </div> 
     <div class="text4">
      doc.Load("http://www.anywhere.com/report.asp");
     </div> 
     <div class="text4">
      doc.Load("http://www.anywhere.com/report.jsp？date=xxx");
     </div> 
     <div class="text4">
      等等，只要装载的数据是符合我们规定的XML数据文档就可以。
     </div> 
     <div class="text4">
      然后在控件的构造函数中加入打印事件的委托：
     </div> 
     <div class="text4">
      public PrintControl()
     </div> 
     <div class="text4">
      {
     </div> 
     <div class="text4">
      InitializeComponent();
     </div> 
     <div class="text4">
      this.printDocument1.PrintPage += new PrintPageEventHandler(this.pd_PrintPage);
     </div> 
     <div class="text4">
      }
     </div> 
     <div class="text4">
      该委托方法的代码如下：
     </div> 
     <div>
      <pre class="text5">private void pd_PrintPage(object sender, PrintPageEventArgs ev)
{
Graphics g = ev.Graphics;
bool HasMorePages = false;
PrintElement printElement = null;
foreach(XmlNode node in doc["root"]["reporttable"].ChildNodes)
{
printElement = Parser.CreateElement(node);//调用解析器生成相应的对象
try
{
HasMorePages = printElement.Draw(g);//是否需要分页
}
catch(Exception ex)
{
this.label1.Text = ex.Message;
}
}
//在页底中间输出页码
Font font = new Font("黑体", 12.0f);
Brush brush = new SolidBrush(Color.Black);
g.DrawString("第 " + Pages.ToString() + " 页",
font,brush,ev.MarginBounds.Width / 2 + ev.MarginBounds.Left - 30,
ev.PageBounds.Height - 60);
if(HasMorePages)
{
Pages++;
}
ev.HasMorePages = HasMorePages;
}
</pre>
     </div> 
     <div class="text4">
      三个按纽的Click事件代码分别如下：
     </div> 
     <div>
      <pre class="text5">//页面设置
private void button1_Click(object sender, System.EventArgs e)
{
this.pageSetupDialog1.ShowDialog();
this.printDocument1.DefaultPageSettings = this.pageSetupDialog1.PageSettings;
}
//打印预览
private void button2_Click(object sender, System.EventArgs e)
{
try
{
this.printPreviewDialog1.ShowDialog();
}
catch(Exception ex)
{
this.label1.Text = ex.Message;
}
}
//打印
private void button3_Click(object sender, System.EventArgs e)
{
try
{
this.printDocument1.Print();
}
catch(Exception ex)
{
this.label1.Text = ex.Message;
}
}
</pre>
     </div> 
     <div class="text4">
      好了，我们的打印控件到这里就全部做完了，选择生成一个Release的版本，然后到工程目录下将生成的PrintControl.dll文件拷贝到IIS的虚拟根目录下，然后新建一个remoteprint.htm的HTML格式文件，在合适的地方加上：&lt;object id="print" classid="http:RemotePrint.dll#RemotePrint.PrintControl" Width="100%" Height="60"&gt; &lt;/object&gt;，为了更加形象和美观，还可以将需要打印的数据做成网页形式放在上面，如果需要获取的XML是动态数据源，则可以采用asp等动态脚本来生成该网页表格，如果需要获取的XML是一个静态的文本，则可以采用XSLT直接将XML文件转换成网页表格。
     </div> 
     <div class="text4">
      打开浏览器，输入：http://localhost/remoteprint.htm，如果您已经跟我一样，事先做好了一个XML报表数据文件的话，您就可以看到下图所示的效果
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint6.jpg">
     <br>
     <div class="text6"></div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint7.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      请注意：该图示例中的所有数据均为笔者随意虚拟，网页中的表格数据和打印数据并非来自同一数据源，也没有刻意去对等，仅仅只是为了演示一下效果，因此网页显示报表跟打印预览中的报表有一些出入是正常的。在实际应用中可以让网页显示数据跟打印输出数据完全一致。
     </div> 
     <hr>
     <div class="text2">
      方案扩充：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      有一部分读者在来信中问到如何打印一些特殊形态的图表，《利》文中已经提到，采用本方案可以非常方便的定义出自己所需要的标签，在理论上可以打印出任何样式的特殊图表。因此本文打算详细介绍一下增加自己定义的标签扩充打印格式的具体过程。
     </div> 
     <div class="text4">
      先假设我们的客户看了打印效果后基本上满意，但是还有觉得一点不足，如果需要打印一些图表怎么办？例如折线图、K线图、饼状图、柱状图等等。使用我们现有的标签就不行了，所以我们首先要扩充我们的标签库，让它的表达能力更加强。在这里，我将只打算让我们的打印控件学会画简单的折线图，希望读者能举一反三，创造出其它各种各样的打印效果。
     </div> 
     <div class="text4">
      最基本的折线图是由X坐标轴、Y坐标轴和一系列点连接成的线构成的，因此，我定义了以下几种标签：
     </div> 
     <div class="text4">
      1. linechart：跟table，text标签一样，为样式根标签。
     </div> 
     <div class="text4">
      属性：无
     </div> 
     <div class="text4">
      2． coordinate：坐标。
     </div> 
     <div class="text4">
      属性：无
     </div> 
     <div class="text4">
      3． xcoordinate：X轴坐标线
     </div> 
     <div class="text4">
      属性：
     </div> 
     <div class="text4">
      # x：起点X坐标值 
     </div> 
     <div class="text4">
      # y：起点Y坐标值 
     </div> 
     <div class="text4">
      # length：长度值 
     </div> 
     <div class="text4">
      # stroke：粗细 
     </div> 
     <div class="text4">
      # color：颜色 
     </div> 
     <div class="text4">
      # arrow：是否有箭头 
     </div> 
     <div class="text4">
      4． ycoordinate：Y轴坐标线
     </div> 
     <div class="text4">
      属性：同xcoordinate。
     </div> 
     <div class="text4">
      5．scale：刻度线
     </div> 
     <div class="text4">
      标签内容：显示在刻度边的文字
     </div> 
     <div class="text4">
      属性：
     </div> 
     <div class="text4">
      # length：距离起点长度值 
     </div> 
     <div class="text4">
      # height：刻度线高度 
     </div> 
     <div class="text4">
      # width：刻度线宽度 
     </div> 
     <div class="text4">
      # color：颜色 
     </div> 
     <div class="text4">
      # fontsize：字体大小 
     </div> 
     <div class="text4">
      6．chart：图表根
     </div> 
     <div class="text4">
      属性：无
     </div> 
     <div class="text4">
      7．lines：线段
     </div> 
     <div class="text4">
      属性值：
     </div> 
     <div class="text4">
      # stroke：粗细 
     </div> 
     <div class="text4">
      # color：颜色 
     </div> 
     <div class="text4">
      8． point：点
     </div> 
     <div class="text4">
      属性值：
     </div> 
     <div class="text4">
      # x：X坐标值 
     </div> 
     <div class="text4">
      # y：Y坐标值 
     </div> 
     <div class="text4">
      # radius：半径 
     </div> 
     <div class="text4">
      # color：颜色 
     </div> 
     <div class="text4">
      其结构图如下所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint8.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      下面是一段用刚才定义的标签制作的XML折线图示例：
     </div> 
     <div class="text4">
      &lt;linechart&gt;
     </div> 
     <div class="text4">
      &lt;coordinate&gt;
     </div> 
     <div class="text4">
      &lt;xcoordinate x="200" y="600" length="800" stroke="2" color="Black" arrow="true"&gt;
     </div> 
     <div class="text4">
      &lt;scale length="100" height="10" width="1" color="Black" fontsize="9"&gt;100&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="200" height="10" width="1" color="Black" fontsize="9"&gt;200&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="300" height="10" width="1" color="Black" fontsize="9"&gt;300&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="400" height="10" width="1" color="Black" fontsize="9"&gt;400&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="500" height="10" width="1" color="Black" fontsize="9"&gt;500&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="600" height="10" width="1" color="Black" fontsize="9"&gt;600&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="700" height="10" width="1" color="Black" fontsize="9"&gt;700&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;/xcoordinate&gt;
     </div> 
     <div class="text4">
      &lt;ycoordinate x="200" y="600" length="-400" stroke="2" color="Black" arrow="true"&gt;
     </div> 
     <div class="text4">
      &lt;scale length="-100" height="10" width="1" color="Black" fontsize="9"&gt;100&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="-200" height="10" width="1" color="Black" fontsize="9"&gt;200&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;scale length="-300" height="10" width="1" color="Black" fontsize="9"&gt;300&lt;/scale&gt;
     </div> 
     <div class="text4">
      &lt;/ycoordinate&gt;
     </div> 
     <div class="text4">
      &lt;/coordinate&gt;
     </div> 
     <div class="text4">
      &lt;chart&gt;
     </div> 
     <div class="text4">
      &lt;lines stroke="1" color="Blue"&gt;
     </div> 
     <div class="text4">
      &lt;point x="200" y="600" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="300" y="300" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="400" y="400" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="500" y="500" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="600" y="300" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="700" y="300" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="800" y="600" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="900" y="500" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;/lines&gt;
     </div> 
     <div class="text4">
      &lt;lines stroke="1" color="Red"&gt;
     </div> 
     <div class="text4">
      &lt;point x="200" y="400" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="300" y="500" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="400" y="600" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="500" y="300" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="600" y="400" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="700" y="400" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="800" y="500" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;point x="900" y="300" radius="5" color="Black"/&gt;
     </div> 
     <div class="text4">
      &lt;/lines&gt;
     </div> 
     <div class="text4">
      &lt;/chart&gt;
     </div> 
     <div class="text4">
      &lt;/linechart&gt;
     </div> 
     <div class="text4">
      完成了标签的定义，下一步就要来修改我们的程序，让他能"读懂"这些标签。
     </div> 
     <div class="text4">
      首先，我们先给工程增加一个LineChart的新类，跟Table,Text类一样，它也是继承自PrintElement类，同样重载了Draw虚方法。代码如下：
     </div> 
     <div>
      <pre class="text5">using System;
using System.Xml;
using System.Drawing;
using System.Drawing.Drawing2D;
namespace RemotePrint
{
public class LineChart : PrintElement
{
private XmlNode chart;
public LineChart(XmlNode Chart)
{
chart = Chart;
}
public override bool Draw(Graphics g)
{
DrawCoordinate(g, chart["coordinate"]);//画坐标轴
DrawChart(g, chart["chart"]);
return false;
}
private void DrawCoordinate(Graphics g, XmlNode coo)
{
DrawXCoor(g, coo["xcoordinate"]);//画X坐标
DrawYCoor(g, coo["ycoordinate"]);//画Y坐标
}
private void DrawXCoor(Graphics g, XmlNode xcoo)
{
int x = int.Parse(xcoo.Attributes["x"].InnerText);
int y = int.Parse(xcoo.Attributes["y"].InnerText);
int length = int.Parse(xcoo.Attributes["length"].InnerText);
bool arrow = bool.Parse(xcoo.Attributes["arrow"].InnerText);
int stroke = int.Parse(xcoo.Attributes["stroke"].InnerText);
Color color = Color.FromName(xcoo.Attributes["color"].InnerText);
Pen pen = new Pen(color, (float)stroke);
if(arrow)//是否有箭头
{
AdjustableArrowCap Arrow = new AdjustableArrowCap(
(float)(stroke * 1.5 + 1.5),
(float)(stroke * 1.5 + 2), true);
pen.CustomEndCap = Arrow;
}
g.DrawLine(pen, x, y, x + length, y);//画坐标
//画刻度
foreach(XmlNode scale in xcoo.ChildNodes)
{
int len = int.Parse(scale.Attributes["length"].InnerText);
int height = int.Parse(scale.Attributes["height"].InnerText);
int width = int.Parse(scale.Attributes["width"].InnerText);
int fontsize = int.Parse(scale.Attributes["fontsize"].InnerText);
Color clr = Color.FromName(scale.Attributes["color"].InnerText);
string name = scale.InnerText;
Pen p = new Pen(clr, (float)width);
g.DrawLine(p, x + len, y, x + len, y - height);
Font font = new Font("Arial", (float)fontsize);
g.DrawString(
name, font, new SolidBrush(clr),
(float)(x + len - 10), (float)(y + 10));
}
}
private void DrawYCoor(Graphics g, XmlNode ycoo)
{
int x = int.Parse(ycoo.Attributes["x"].InnerText);
int y = int.Parse(ycoo.Attributes["y"].InnerText);
int length = int.Parse(ycoo.Attributes["length"].InnerText);
bool arrow = bool.Parse(ycoo.Attributes["arrow"].InnerText);
int stroke = int.Parse(ycoo.Attributes["stroke"].InnerText);
Color color = Color.FromName(ycoo.Attributes["color"].InnerText);
Pen pen = new Pen(color, (float)stroke);
if(arrow)//是否有箭头
{
AdjustableArrowCap Arrow = new AdjustableArrowCap(
(float)(stroke * 1.5 + 2),
(float)(stroke * 1.5 + 3),
true);
pen.CustomEndCap = Arrow;
}
g.DrawLine(pen, x, y, x, y + length);//画坐标
//画刻度
foreach(XmlNode scale in ycoo.ChildNodes)
{
int len = int.Parse(scale.Attributes["length"].InnerText);
int height = int.Parse(scale.Attributes["height"].InnerText);
int width = int.Parse(scale.Attributes["width"].InnerText);
int fontsize = int.Parse(scale.Attributes["fontsize"].InnerText);
Color clr = Color.FromName(scale.Attributes["color"].InnerText);
string name = scale.InnerText;
Pen p = new Pen(clr, (float)width);
g.DrawLine(p, x, y + len, x + height, y + len);
Font font = new Font("Arial", (float)fontsize);
StringFormat sf = new StringFormat();
sf.Alignment = StringAlignment.Far;
RectangleF rect = new RectangleF(
(float)(x - 100),
(float)(y + len - 25),
90f,
50f);
sf.LineAlignment = StringAlignment.Center;
g.DrawString(name, font, new SolidBrush(clr), rect, sf);
}
}
private void DrawChart(Graphics g, XmlNode chart)
{
foreach(XmlNode lines in chart.ChildNodes)
{
DrawLines(g, lines);
}
}
private void DrawLines(Graphics g, XmlNode lines)
{
int Stroke = int.Parse(lines.Attributes["stroke"].InnerText);
Point[] points = new Point[lines.ChildNodes.Count];
Color linecolor = Color.FromName(lines.Attributes["color"].InnerText);
for(int i = 0; i &lt; lines.ChildNodes.Count; i++)
{
XmlNode node = lines.ChildNodes[i];
points[i] = new Point(
int.Parse(node.Attributes["x"].InnerText),
int.Parse(node.Attributes["y"].InnerText));
int Radius = int.Parse(node.Attributes["radius"].InnerText);
Color pointcolor = Color.FromName(node.Attributes["color"].InnerText);
if(Radius != 0)//画点
{
g.FillEllipse(new SolidBrush(pointcolor),
points[i].X - Radius,
points[i].Y - Radius,
Radius * 2,
Radius * 2);
}
}
Pen pen = new Pen(linecolor);
g.DrawLines(pen, points);//画线
}
}
}
</pre>
     </div> 
     <div class="text4">
      然后，为Parser类的CreateElement方法增加一个小case，代码如下：
     </div> 
     <div>
      <pre class="text5">switch(element.Name)
{
case "text":
printElement = new Text(element);
break;
case "table":
printElement = new Table(element);
break;
case "linechart"://新增加的linechart
printElement = new LineChart(element);
break;
default:
printElement = new PrintElement();
break;
}
</pre>
     </div> 
     <div class="text4">
      将原来的XML文件中的table标签和其子标签都替换成刚才写的那段linechart，然后编译程序，运行后效果如下所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint9.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      现在，我们的打印控件就能打印折线图了，由于我们采用了Abstract Factory的设计模式，将报表的打印和格式的解析分开，使得本程序有着非常方便的扩充能力，如果需要再增加一种新形式的图表，那么需要定义出标签，写一个解析类，再到Paser中为这个类增加一个case就搞定了，PrintControl内部的代码一行都不需要改写。
     </div> 
     <hr>
     <div class="text2">
      总结：
     </div> 
     <div class="text4"></div> 
     <div class="text4">
      以上就是如何制作打印控件的详细介绍，基本上解答了读者来信中的大部分问题，另外还有几个被问得很多的问题这里再集中解答一下：
     </div> 
     <div class="text4">
      Q：这种方案是否一定需要客户端装有.Net Framework？
     </div> 
     <div class="text4">
      A：是肯定的，这也是算是本方案一个缺陷。不过我可以肯定，在不远的将来，微软一定会将.Net Framework以升级或者是补丁的形式安装到我们的大多数Windows甚至是Linux操作系统当中。那时便不会有现在的这个遗憾存在。
     </div> 
     <div class="text4">
      Q：我采用Winform应用程序的形式，那么是不是存在着一个部署的问题？例如我增加了一种新的图表格式，那么是否所有的打印客户端都需要升级到新的版本？
     </div> 
     <div class="text4">
      A：是的，不过理论上可以采用.Net Remoting的设计来避免这个问题：因为Graphics类也是从System.MarshalByRefObject继承下来的，因此同样可以通过Remoting序列化，这样我们就可以把解析类（Table,Text,Chart等）和厂类(Paser)都放到服务器端通过Remoting提供远程调用方法，而只把打印控制（PrintControl）放到客户端，那么，当我们新增加图表的时候，就可以不需要对客户端进行任何升级。
     </div> 
     <div class="text4">
      Q：打开网页控件不会运行，只显示一个白框，怎么办？
     </div> 
     <div class="text4">
      A：这个是因为你安装了.Net Framework SP1或者SP2，它们默认的安全策略是不允许控件运行的，这时需要进行以下修改：打开Microsoft .NET Framework Wizards，在"程序"里有，也可以在"管理工具"里面找到它，点击"调整.NET安全性"，如下图所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint10.jpg">
     <br>
     <div class="text6"></div> 
     <div class="text4">
      再将Internet区域的安全级别设置为"完全信任"，如下图所示：
     </div> 
     <img alt="" src="http://www.microsoft.com/china/community/images/TechArticleImages/xmlwebprint11.jpg">
     <br>
    </div> 
   </div> 
   <div class="text4">
    整个方案到这里就介绍完了，读者如果在使用中出现什么问题，请发电子邮件到nluyan@msn.com, nluyan@163.net，或者到微软的中文DotNet新闻组来进行详细讨论。谢谢！
   </div> 
   <hr>
   <div class="text2"></div> 
   <div class="text4"></div> 
   <div class="text4">
    作者：卢彦
   </div> 
   <div class="text4">
    2002-11-8
   </div> 
   <hr>
   <div class="text2">
    版权声明
   </div> 
   <p>凡在本网站发表的文章，作者必须保证是原创文章；如果不是原创文章，由此带来的版权纠纷由作者自己承担。微软有义务对本站点发表的文章进行审核，但您需要考虑这些文章的使用风险。本站点仅提供一个用户相互交换技术信息和学习的园地，并不对来自社区用户的技术文章承担任何风险。</p> 
   <p>&nbsp;</p> 
   <p>&nbsp;</p> 
   <p>本文转自温景良(Jason)博客园博客，原文链接：<a href="http://www.cnblogs.com/wenjl520/archive/2009/06/17/1504698.html" rel="nofollow">http://www.cnblogs.com/wenjl520/archive/2009/06/17/1504698.html</a>，如需转载请自行联系原作者</p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
