<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>swift：高级运算符（位运算符、溢出运算符、优先级和结合性、运算符重载函数）... « NotBeCN</title>
  <meta name="description" content="                  swift：高级运算符           http://www.cocoachina.com/ios/20140612/8794.html             除了基本操作符中所讲的运算符，Swift还有许多复杂的高级运算符，包括了C语和Objective-C中的位运算符...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/16/weixin_33929309_90117594.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">swift：高级运算符（位运算符、溢出运算符、优先级和结合性、运算符重载函数）...</h1>
    <p class="post-meta">Nov 16, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body"> 
    <p><span style="font-family:'Hannotate SC';font-size:18pt;">swift：高级运算符</span></p> 
    <div> 
     <span style="color:rgb(18,69,238);font-family:'Hannotate SC';font-size:large;">http://www.cocoachina.com/ios/20140612/8794.html</span> 
     <div> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">除了<a href="http://www.cocoachina.com/newbie/basic/2014/0611/8767.html?1402556544" rel="nofollow">基本操作符</a>中所讲的运算符，Swift还有许多复杂的高级运算符，包括了C语和Objective-C中的位运算符和移位运算。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">不同于C语言中的数值计算，Swift的数值计算默认是不可溢出的。溢出行为会被捕获并报告为错误。你是故意的？好吧，你可以使用Swift为你准备的另一套默认允许溢出的数值运算符，如可溢出加&amp;+。所有允许溢出的运算符都是以&amp;开始的。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">自定义的结构，类和枚举，是否可以使用标准的运算符来定义操作？当然可以！在Swift中，你可以为你创建的所有类型定制运算符的操作。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">可定制的运算符并不限于那些预设的运算符，自定义有个性的中置，前置，后置及赋值运算符，当然还有优先级和结合性。这些运算符的实现可以运用预设的运算符，也可以运用之前定制的运算符。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">位运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">位操作符通常在诸如图像处理和创建设备驱动等底层开发中使用，使用它可以单独操作数据结构中原始数据的比特位。在使用一个自定义的协议进行通信的时候，运用位运算符来对原始数据进行编码和解码也是非常有效的。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">Swift支持如下所有C语言的位运算符：</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">按位取反运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">按位取反运算符~对一个操作数的每一位都取反。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151518263-1948151894.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个运算符是前置的，所以请不加任何空格地写着操作数之前。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;initialBits:&nbsp;UInt8&nbsp;=&nbsp;0b00001111&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;invertedBits&nbsp;=&nbsp;~initialBits&nbsp;&nbsp;//&nbsp;等于&nbsp;0b11110000&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">UInt8是8位无符整型，可以存储0~255之间的任意数。这个例子初始化一个整型为二进制值00001111(前4位为0，后4位为1)，它的十进制值为15。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">使用按位取反运算~对initialBits操作，然后赋值给invertedBits这个新常量。这个新常量的值等于所有位都取反的initialBits，即1变成0，0变成1，变成了11110000，十进制值为240。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">按位与运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">按位与运算符对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151540575-1331404112.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">以下代码，firstSixBits和lastSixBits中间4个位都为1。对它俩进行按位与运算后，就得到了00111100，即十进制的60。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;firstSixBits:&nbsp;UInt8&nbsp;=&nbsp;0b11111100&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;lastSixBits:&nbsp;UInt8&nbsp;&nbsp;=&nbsp;0b00111111&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;middleFourBits&nbsp;=&nbsp;firstSixBits&nbsp;&amp;&nbsp;lastSixBits&nbsp;&nbsp;//&nbsp;等于&nbsp;00111100&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">按位或运算</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">按位或运算符|比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0(即任意一个为1，或都为1)。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151556669-1563248801.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">如下代码，someBits和moreBits在不同位上有1。按位或运行的结果是11111110，即十进制的254。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;someBits:&nbsp;UInt8&nbsp;=&nbsp;0b10110010&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;moreBits:&nbsp;UInt8&nbsp;=&nbsp;0b01011110&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;combinedbits&nbsp;=&nbsp;someBits&nbsp;|&nbsp;moreBits&nbsp;&nbsp;//&nbsp;等于&nbsp;11111110&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">按位异或运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">按位异或运算符^比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151805357-731616594.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">以下代码，firstBits和otherBits都有一个1跟另一个数不同的。所以按位异或的结果是把它这些位置为1，其他都置为0。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;firstBits:&nbsp;UInt8&nbsp;=&nbsp;0b00010100&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;otherBits:&nbsp;UInt8&nbsp;=&nbsp;0b00000101&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;outputBits&nbsp;=&nbsp;firstBits&nbsp;^&nbsp;otherBits&nbsp;&nbsp;//&nbsp;等于&nbsp;00010001&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">按位左移/右移运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">左移运算符&lt;&lt;和右移运算符&gt;&gt;会把一个数的所有比特位按以下定义的规则向左或向右移动指定位数。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">按位左移和按位右移的效果相当把一个整数乘于或除于一个因子为2的整数。向左移动一个整型的比特位相当于把这个数乘于2，向右移一位就是除于2。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">无符整型的移位操作</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">对无符整型的移位的效果如下：</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">已经存在的比特位向左或向右移动指定的位数。被移出整型存储边界的的位数直接抛弃，移动留下的空白位用零0来填充。这种方法称为逻辑移位。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">以下这张把展示了 11111111 &lt;&lt; 1(11111111向左移1位)，和 11111111 &gt;&gt; 1(11111111向右移1位)。蓝色的是被移位的，灰色是被抛弃的，橙色的0是被填充进来的。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151747310-1506118828.png"></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;shiftBits:&nbsp;UInt8&nbsp;=&nbsp;4&nbsp;&nbsp;&nbsp;//&nbsp;即二进制的00000100&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">shiftBits&nbsp;&lt;&lt;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;00001000&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">shiftBits&nbsp;&lt;&lt;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;00010000&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">shiftBits&nbsp;&lt;&lt;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;10000000&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">shiftBits&nbsp;&lt;&lt;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;00000000&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">shiftBits&nbsp;&gt;&gt;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;00000001&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">你可以使用移位操作进行其他数据类型的编码和解码。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;pink:&nbsp;UInt32&nbsp;=&nbsp;0xCC6699&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;redComponent&nbsp;=&nbsp;(pink&nbsp;&amp;&nbsp;0xFF0000)&nbsp;&gt;&gt;&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;redComponent&nbsp;是&nbsp;0xCC,&nbsp;即&nbsp;204&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;greenComponent&nbsp;=&nbsp;(pink&nbsp;&amp;&nbsp;0x00FF00)&nbsp;&gt;&gt;&nbsp;8&nbsp;&nbsp;&nbsp;//&nbsp;greenComponent&nbsp;是&nbsp;0x66,&nbsp;即&nbsp;102&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;blueComponent&nbsp;=&nbsp;pink&nbsp;&amp;&nbsp;0x0000FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;blueComponent&nbsp;是&nbsp;0x99,&nbsp;即&nbsp;153&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个例子使用了一个UInt32的命名为pink的常量来存储层叠样式表CSS中粉色的颜色值，CSS颜色#CC6699在Swift用十六进制0xCC6699来表示。然后使用按位与(&amp;)和按位右移就可以从这个颜色值中解析出红(CC)，绿(66)，蓝(99)三个部分。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">对0xCC6699和0xFF0000进行按位与&amp;操作就可以得到红色部分。0xFF0000中的0了遮盖了OxCC6699的第二和第三个字节，这样6699被忽略了，只留下0xCC0000。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">然后，按向右移动16位，即 &gt;&gt; 16。十六进制中每两个字符是8比特位，所以移动16位的结果是把0xCC0000变成0x0000CC。这和0xCC是相等的，都是十进制的204。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">同样的，绿色部分来自于0xCC6699和0x00FF00的按位操作得到0x006600。然后向右移动8們，得到0x66，即十进制的102。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">最后，蓝色部分对0xCC6699和0x0000FF进行按位与运算，得到0x000099，无需向右移位了，所以结果就是0x99，即十进制的153。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">有符整型的移位操作</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">有符整型的移位操作相对复杂得多，因为正负号也是用二进制位表示的。(这里举的例子虽然都是8位的，但它的原理是通用的。)</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">有符整型通过第1个比特位(称为符号位)来表达这个整数是正数还是负数。0代表正数，1代表负数。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">其余的比特位(称为数值位)存储其实值。有符正整数和无符正整数在计算机里的存储结果是一样的，下来我们来看+4内部的二进制结构。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151732825-1453091834.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">符号位为0，代表正数，另外7比特位二进制表示的实际值就刚好是4。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">负数呢，跟正数不同。负数存储的是2的n次方减去它的绝对值，n为数值位的位数。一个8比特的数有7个数值位，所以是2的7次方，即128。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">我们来看-4存储的二进制结构。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151825763-310617106.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">现在符号位为1，代表负数，7个数值位要表达的二进制值是124，即128 - 4。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151834779-1004956776.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">负数的编码方式称为二进制补码表示。这种表示方式看起来很奇怪，但它有几个优点。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">首先，只需要对全部8个比特位(包括符号)做标准的二进制加法就可以完成 -1 + -4 的操作，忽略加法过程产生的超过8个比特位表达的任何信息。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151848169-127997591.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">第二，由于使用二进制补码表示，我们可以和正数一样对负数进行按位左移右移的，同样也是左移1位时乘于2，右移1位时除于2。要达到此目的，对有符整型的右移有一个特别的要求：</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">对有符整型按位右移时，使用符号位(正数为0，负数为1)填充空白位。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026151918060-871040277.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">这就确保了在右移的过程中，有符整型的符号不会发生变化。这称为算术移位。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">正因为正数和负数特殊的存储方式，向右移位使它接近于0。移位过程中保持符号会不变，负数在接近0的过程中一直是负数。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">溢出运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">默认情况下，当你往一个整型常量或变量赋于一个它不能承载的大数时，Swift不会让你这么干的，它会报错。这样，在操作过大或过小的数的时候就很安全了。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">例如，Int16整型能承载的整数范围是-32768到32767，如果给它赋上超过这个范围的数，就会报错：</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;potentialOverflow&nbsp;=&nbsp;Int16.max&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;potentialOverflow&nbsp;等于&nbsp;32767,&nbsp;这是&nbsp;Int16&nbsp;能承载的最大整数&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">potentialOverflow&nbsp;+=&nbsp;1&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;噢,&nbsp;出错了&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">对过大或过小的数值进行错误处理让你的数值边界条件更灵活。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">当然，你有意在溢出时对有效位进行截断，你可采用溢出运算，而非错误处理。Swfit为整型计算提供了5个&amp;符号开头的溢出运算符。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">溢出加法 &amp;+</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">溢出减法 &amp;-</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">溢出乘法 &amp;*</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">溢出除法 &amp;/</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">溢出求余 &amp;%</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">值的上溢出</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">下面例子使用了溢出加法&amp;+来解剖的无符整数的上溢出</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;willOverflow&nbsp;=&nbsp;UInt8.max&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;willOverflow&nbsp;等于UInt8的最大整数&nbsp;255&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">willOverflow&nbsp;=&nbsp;willOverflow&nbsp;&amp;+&nbsp;1&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;这时候&nbsp;willOverflow&nbsp;等于&nbsp;0&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">willOverflow用Int8所能承载的最大值255(二进制11111111)，然后用&amp;+加1。然后UInt8就无法表达这个新值的二进制了，也就导致了这个新值上溢出了，大家可以看下图。溢出后，新值在UInt8的承载范围内的那部分是00000000，也就是0。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026152002466-1216841577.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">值的下溢出</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">数值也有可能因为太小而越界。举个例子：</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">UInt8的最小值是0(二进制为00000000)。使用&amp;-进行溢出减1，就会得到二进制的11111111即十进制的255。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026152014700-2066620622.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">Swift代码是这样的:</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;willUnderflow&nbsp;=&nbsp;UInt8.min&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;willUnderflow&nbsp;等于UInt8的最小值0&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">willUnderflow&nbsp;=&nbsp;willUnderflow&nbsp;&amp;-&nbsp;1&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;此时&nbsp;willUnderflow&nbsp;等于&nbsp;255&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">有符整型也有类似的下溢出，有符整型所有的减法也都是对包括在符号位在内的二进制数进行二进制减法的，这在 "按位左移/右移运算符" 一节提到过。最小的有符整数是-128，即二进制的10000000。用溢出减法减去去1后，变成了01111111，即UInt8所能承载的最大整数127。</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026152031732-1982720802.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">来看看Swift代码：</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;signedUnderflow&nbsp;=&nbsp;Int8.min&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;signedUnderflow&nbsp;等于最小的有符整数&nbsp;-128&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">signedUnderflow&nbsp;=&nbsp;signedUnderflow&nbsp;&amp;-&nbsp;1&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;如今&nbsp;signedUnderflow&nbsp;等于&nbsp;127&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">除零溢出</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">一个数除于0 i / 0，或者对0求余数 i % 0，就会产生一个错误。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;x&nbsp;=&nbsp;1&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;y&nbsp;=&nbsp;x&nbsp;/&nbsp;0&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">使用它们对应的可溢出的版本的运算符&amp;/和&amp;%进行除0操作时就会得到0值。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;x&nbsp;=&nbsp;1&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;y&nbsp;=&nbsp;x&nbsp;&amp;/&nbsp;0&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;y&nbsp;等于&nbsp;0&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">优先级和结合性</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">结合性定义相同优先级的运算符在一起时是怎么组合或关联的，是和左边的一组呢，还是和右边的一组。意思就是，到底是和左边的表达式结合呢，还是和右边的表达式结合？</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">在混合表达式中，运算符的优先级和结合性是非常重要的。举个例子，为什么下列表达式的结果为4？</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">2&nbsp;+&nbsp;3&nbsp;*&nbsp;4&nbsp;%&nbsp;5&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;结果是&nbsp;4&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">如果严格地从左计算到右，计算过程会是这样：</span></p> 
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:large;">2 plus 3 equals 5;</span></p> 
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:large;">2 + 3 = 5</span></p> 
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:large;">5 times 4 equals 20;</span></p> 
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:large;">5 * 4 = 20</span></p> 
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:large;">20 remainder 5 equals 0</span></p> 
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:large;">20 / 5 = 4 余 0</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">但是正确答案是4而不是0。优先级高的运算符要先计算，在Swift和C语言中，都是先乘除后加减的。所以，执行完乘法和求余运算才能执行加减运算。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">乘法和求余拥有相同的优先级，在运算过程中，我们还需要结合性，乘法和求余运算都是左结合的。这相当于在表达式中有隐藏的括号让运算从左开始。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">2&nbsp;+&nbsp;((3&nbsp;*&nbsp;4)&nbsp;%&nbsp;5)&nbsp;</span></li>
      </ol>
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">(3 * 4) is 12, so this is equivalent to: 3 * 4 = 12，所以这相当于：</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">2&nbsp;+&nbsp;(12&nbsp;%&nbsp;5)&nbsp;</span></li>
      </ol>
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">(12 % 5) is 2, so this is equivalent to: 12 % 5 = 2，所这又相当于</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">2&nbsp;+&nbsp;2&nbsp;</span></li>
      </ol>
      <p><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">计算结果为 4。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">查阅Swift运算符的优先级和结合性的完整列表，请看表达式。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">注意：Swift的运算符较C语言和Objective-C来得更简单和保守，这意味着跟基于C的语言可能不一样。所以，在移植已有代码到Swift时，注意去确保代码按你想的那样去执行。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">运算符函数</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">让已有的运算符也可以对自定义的类和结构进行运算，这称为运算符重载。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个例子展示了如何用+让一个自定义的结构做加法。算术运算符+是一个两目运算符，因为它有两个操作数，而且它必须出现在两个操作数之间。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">例子中定义了一个名为Vector2D的二维坐标向量 (x，y) 的结构，然后定义了让两个Vector2D的对象相加的运算符函数。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">struct&nbsp;Vector2D&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;x&nbsp;=&nbsp;0.0,&nbsp;y&nbsp;=&nbsp;0.0&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@infix&nbsp;func&nbsp;+&nbsp;(left:&nbsp;Vector2D,&nbsp;right:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Vector2D&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Vector2D(x:&nbsp;left.x&nbsp;+&nbsp;right.x,&nbsp;y:&nbsp;left.y&nbsp;+&nbsp;right.y)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">该运算符函数定义了一个全局的+函数，这个函数需要两个Vector2D类型的参数，返回值也是Vector2D类型。需要定义和实现一个中置运算的时候，在关键字func之前写上属性 @infix 就可以了。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">在这个代码实现中，参数被命名为了left和right，代表+左边和右边的两个Vector2D对象。函数返回了一个新的Vector2D的对象，这个对象的x和y分别等于两个参数对象的x和y的和。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个函数是全局的，而不是Vector2D结构的成员方法，所以任意两个Vector2D对象都可以使用这个中置运算符。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;vector&nbsp;=&nbsp;Vector2D(x:&nbsp;3.0,&nbsp;y:&nbsp;1.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;anotherVector&nbsp;=&nbsp;Vector2D(x:&nbsp;2.0,&nbsp;y:&nbsp;4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;combinedVector&nbsp;=&nbsp;vector&nbsp;+&nbsp;anotherVector&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;combinedVector&nbsp;是一个新的Vector2D,&nbsp;值为&nbsp;(5.0,&nbsp;5.0)&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个例子实现两个向量 (3.0，1.0) 和 (2.0，4.0) 相加，得到向量 (5.0，5.0) 的过程。如下图示：</span></p> 
      <p><img alt="" src="https://images2015.cnblogs.com/blog/791499/201510/791499-20151026152136435-1430665957.png"></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">前置和后置运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">上个例子演示了一个双目中置运算符的自定义实现，同样我们也可以玩标准单目运算符的实现。单目运算符只有一个操作数，在操作数之前就是前置的，如-a; 在操作数之后就是后置的，如i++。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">实现一个前置或后置运算符时，在定义该运算符的时候于关键字func之前标注 @prefix 或 @postfix 属性。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@prefix&nbsp;func&nbsp;-&nbsp;(vector:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Vector2D&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Vector2D(x:&nbsp;-vector.x,&nbsp;y:&nbsp;-vector.y)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">这段代码为Vector2D类型提供了单目减运算-a，@prefix属性表明这是个前置运算符。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">对于数值，单目减运算符可以把正数变负数，把负数变正数。对于Vector2D，单目减运算将其x和y都进进行单目减运算。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;positive&nbsp;=&nbsp;Vector2D(x:&nbsp;3.0,&nbsp;y:&nbsp;4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;negative&nbsp;=&nbsp;-positive&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;negative&nbsp;为&nbsp;(-3.0,&nbsp;-4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;alsoPositive&nbsp;=&nbsp;-negative&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;alsoPositive&nbsp;为&nbsp;(3.0,&nbsp;4.0)&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">组合赋值运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">组合赋值是其他运算符和赋值运算符一起执行的运算。如+=把加运算和赋值运算组合成一个操作。实现一个组合赋值符号需要使用@assignment属性，还需要把运算符的左参数设置成inout，因为这个参数会在运算符函数内直接修改它的值。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@assignment&nbsp;func&nbsp;+=&nbsp;(inout&nbsp;left:&nbsp;Vector2D,&nbsp;right:&nbsp;Vector2D)&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;left&nbsp;=&nbsp;left&nbsp;+&nbsp;right&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">因为加法运算在之前定义过了，这里无需重新定义。所以，加赋运算符函数使用已经存在的高级加法运算符函数来执行左值加右值的运算。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;original&nbsp;=&nbsp;Vector2D(x:&nbsp;1.0,&nbsp;y:&nbsp;2.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;vectorToAdd&nbsp;=&nbsp;Vector2D(x:&nbsp;3.0,&nbsp;y:&nbsp;4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">original&nbsp;+=&nbsp;vectorToAdd&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;original&nbsp;现在为&nbsp;(4.0,&nbsp;6.0)&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">你可以将 @assignment 属性和 @prefix 或 @postfix 属性起来组合，实现一个Vector2D的前置运算符。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@prefix&nbsp;@assignment&nbsp;func&nbsp;++&nbsp;(inout&nbsp;vector:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Vector2D&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;vector&nbsp;+=&nbsp;Vector2D(x:&nbsp;1.0,&nbsp;y:&nbsp;1.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vector&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个前置使用了已经定义好的高级加赋运算，将自己加上一个值为 (1.0，1.0) 的对象然后赋给自己，然后再将自己返回。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;toIncrement&nbsp;=&nbsp;Vector2D(x:&nbsp;3.0,&nbsp;y:&nbsp;4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;afterIncrement&nbsp;=&nbsp;++toIncrement&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;toIncrement&nbsp;现在是&nbsp;(4.0,&nbsp;5.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;afterIncrement&nbsp;现在也是&nbsp;(4.0,&nbsp;5.0)&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">注意：默认的赋值符是不可重载的。只有组合赋值符可以重载。三目条件运算符 a？b：c 也是不可重载。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">比较运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">Swift无所知道自定义类型是否相等或不等，因为等于或者不等于由你的代码说了算了。所以自定义的类和结构要使用比较符==或!=就需要重载。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">定义相等运算符函数跟定义其他中置运算符雷同：</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@infix&nbsp;func&nbsp;==&nbsp;(left:&nbsp;Vector2D,&nbsp;right:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Bool&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(left.x&nbsp;==&nbsp;right.x)&nbsp;&amp;&amp;&nbsp;(left.y&nbsp;==&nbsp;right.y)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@infix&nbsp;func&nbsp;!=&nbsp;(left:&nbsp;Vector2D,&nbsp;right:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Bool&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;!(left&nbsp;==&nbsp;right)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">上述代码实现了相等运算符==来判断两个Vector2D对象是否有相等的值，相等的概念就是他们有相同的x值和相同的y值，我们就用这个逻辑来实现。接着使用==的结果实现了不相等运算符!=。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">现在我们可以使用这两个运算符来判断两个Vector2D对象是否相等。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;twoThree&nbsp;=&nbsp;Vector2D(x:&nbsp;2.0,&nbsp;y:&nbsp;3.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;anotherTwoThree&nbsp;=&nbsp;Vector2D(x:&nbsp;2.0,&nbsp;y:&nbsp;3.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">if&nbsp;twoThree&nbsp;==&nbsp;anotherTwoThree&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;println("这两个向量是相等的.")&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;prints&nbsp;"这两个向量是相等的."&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">自定义运算符</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">标准的运算符不够玩，那你可以声明一些个性的运算符，但个性的运算符只能使用这些字符 / = - + * % &lt; &gt;！&amp; | ^。~。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">新的运算符声明需在全局域使用operator关键字声明，可以声明为前置，中置或后置的。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">operator&nbsp;prefix&nbsp;+++&nbsp;{}&nbsp;</span></li>
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">这段代码定义了一个新的前置运算符叫+++，此前Swift并不存在这个运算符。此处为了演示，我们让+++对Vector2D对象的操作定义为 双自增 这样一个独有的操作，这个操作使用了之前定义的加赋运算实现了自已加上自己然后返回的运算。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">@prefix&nbsp;@assignment&nbsp;func&nbsp;+++&nbsp;(inout&nbsp;vector:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Vector2D&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;vector&nbsp;+=&nbsp;vector&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;vector&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">Vector2D 的 +++ 的实现和 ++ 的实现很接近, 唯一不同的前者是加自己, 后者是加值为 (1.0, 1.0) 的向量.</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">var&nbsp;toBeDoubled&nbsp;=&nbsp;Vector2D(x:&nbsp;1.0,&nbsp;y:&nbsp;4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;afterDoubling&nbsp;=&nbsp;+++toBeDoubled&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;toBeDoubled&nbsp;现在是&nbsp;(2.0,&nbsp;8.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;afterDoubling&nbsp;现在也是&nbsp;(2.0,&nbsp;8.0)&nbsp;</span></li> 
      </ol>
      <p><strong><span style="font-family:'Hannotate SC';font-size:large;">自定义中置运算符的优先级和结合性</span></strong></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">可以为自定义的中置运算符指定优先级和结合性。可以回头看看优先级和结合性解释这两个因素是如何影响多种中置运算符混合的表达式的计算的。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">&nbsp;</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">结合性(associativity)的值可取的值有left，right和none。左结合运算符跟其他优先级相同的左结合运算符写在一起时，会跟左边的操作数结合。同理，右结合运算符会跟右边的操作数结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">结合性(associativity)的值默认为none，优先级(precedence)默认为100。</span></p> 
      <p><span style="font-family:'Hannotate SC';font-size:large;">以下例子定义了一个新的中置符+-，是左结合的left，优先级为140。</span></p> 
      <ol>
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">operator&nbsp;infix&nbsp;+-&nbsp;{&nbsp;associativity&nbsp;left&nbsp;precedence&nbsp;140&nbsp;}&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">func&nbsp;+-&nbsp;(left:&nbsp;Vector2D,&nbsp;right:&nbsp;Vector2D)&nbsp;-&gt;&nbsp;Vector2D&nbsp;{&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Vector2D(x:&nbsp;left.x&nbsp;+&nbsp;right.x,&nbsp;y:&nbsp;left.y&nbsp;-&nbsp;right.y)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">}&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;firstVector&nbsp;=&nbsp;Vector2D(x:&nbsp;1.0,&nbsp;y:&nbsp;2.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;secondVector&nbsp;=&nbsp;Vector2D(x:&nbsp;3.0,&nbsp;y:&nbsp;4.0)&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">let&nbsp;plusMinusVector&nbsp;=&nbsp;firstVector&nbsp;+-&nbsp;secondVector&nbsp;</span></li> 
       <li><span style="color:rgb(128,0,0);font-family:'Hannotate SC';font-size:18px;">//&nbsp;plusMinusVector&nbsp;此时的值为&nbsp;(4.0,&nbsp;-2.0)&nbsp;</span></li> 
      </ol>
      <p><span style="font-family:'Hannotate SC';font-size:large;">这个运算符把两个向量的x相加，把向量的y相减。因为他实际是属于加减运算，所以让它保持了和加法一样的结合性和优先级(left和140)。查阅完整的Swift默认结合性和优先级的设置，请移步表达式;</span></p> 
     </div> 
    </div> 
   </div> 
   <div>
    程序猿神奇的手，每时每刻，这双手都在改变着世界的交互方式！
   </div> 
   <div class="clear"></div> 
   <div> 
    <div>
     分类: 
     <a href="http://www.cnblogs.com/XYQ-208910/category/746981.html" rel="nofollow">Swift开发技术</a> 
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     本文转自当天真遇到现实博客园博客，原文链接：
     <a href="https://yq.aliyun.com/articles/new?spm=5176.100239.blogoption.1.4c037246VgA9hW" rel="nofollow">https://yq.aliyun.com/articles/new?spm=5176.100239.blogoption.1.4c037246VgA9hW</a>，如需转载请自行联系原作者
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
