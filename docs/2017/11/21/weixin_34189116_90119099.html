<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>设计模式Template Method模式(Template Method)摘录 « NotBeCN</title>
  <meta name="description" content="             23种子GOF设计模式一般分为三类：创建模式、结构模型、行为模式。    创建模式抽象的实例。怎样创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化托付给还有一个对象。创建型模式有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些详细...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/21/weixin_34189116_90119099.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">设计模式Template Method模式(Template Method)摘录</h1>
    <p class="post-meta">Nov 21, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><a name="OLE_LINK14" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">23</a>种子GOF设计模式一般分为三类：创建模式、结构模型、行为模式。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">创建模式抽象的实例。怎样创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化托付给还有一个对象。创建型模式有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些详细的类的信息封装起来。第二，它们隐藏了这些类的实例是怎样被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口。因此。创建型模式在什么被创建，谁创建它，它是怎样被创建的。以及何时创建这些方面给予了非常大的灵活性。它们同意用结构和功能区别非常大的“产品”对象配置一个系统。配置能够是静态的(即在编译时指定)。也能够是动态的(在执行时)。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">结构型模式涉及到怎样组合类和对象以获得更大的结构。结构型类模式採用继承机制来组合接口或实现。结构型对象模式不是对接口和实现进行组合，而是描写叙述了怎样对一些对象进行组合。从而实现新功能的一些方法。因为能够在执行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这样的机制用静态类组合是不可能实现的。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">行为模式涉及到算法和对象间职责的分配。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">行为模式不仅描写叙述对象或类的模式，还描写叙述它们之间的通信模式。这些模式刻画了在执行时难以跟踪的复杂的控制流。它们将用户的注意力从控制流转移到对象间的联系方式上来。行为类模式使用继承机制在类间分派行为。行为对象模式使用对象复合而不是继承。一些行为对象模式描写叙述了一组对等的对象怎样相互协作以完毕当中任一个对象都无法单独完毕的任务。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>创建型模式包含</strong>：1、FactoryMethod(工厂方法模式)；2、Abstract Factory(抽象工厂模式)。3、Singleton(单例模式)；4、Builder(建造者模式、生成器模式)。5、Prototype(原型模式).</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>结构型模式包含</strong>：6、Bridge(桥接模式)；7、Adapter(适配器模式)。8、Decorator(装饰模式)。9、Composite(组合模式)。10、Flyweight(享元模式)；11、Facade(外观模式)；12、Proxy(代理模式).</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>行为模式包含</strong>：13、TemplateMethod(模板方法模式)；14、Strategy(策略模式)；15、State(状态模式)。16、Observer(观察者模式)。17、Memento(备忘录模式)；18、Mediator(中介者模式)；19、Command(命令模式)。20、Visitor(訪问者模式)；21、Chain of Responsibility(责任链模式)；22、Iterator(迭代器模式)；23、Interpreter(解释器模式).</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Factory Method</strong>：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Abstract Factory</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们详细的类。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Singleton</strong>：保证一个类仅有一个实例，并提供一个訪问它的全局訪问点。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Builder</strong>：将一个复杂对象的构建与它的表示分离，使得相同的构建过程能够创建不同的表示。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Prototype</strong>：用原型实例指定创建对象的种类。而且通过拷贝这个原型来创建新的对象。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Bridge</strong>：将抽象部分与它的实现部分分离，使它们都能够独立地变化。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Adapter</strong>：将一个类的接口转换成客户希望的另外一个接口。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">Adapter模式使得原本因为接口不兼容而不能一起工作的那些类能够一起工作。</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Decorator</strong>：动态地给一个对象加入一些额外的职责。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">就扩展功能而言， Decorator模式比生成子类方式更为灵活。</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Composite</strong>：将对象组合成树形结构以表示“部分-总体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Flyweight</strong>：运用共享技术有效地支持大量细粒度的对象。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Facade</strong>：为子系统中的一组接口提供一个一致的界面。 Facade模式定义了一个高层接口，这个接口使得这一子系统更加easy使用。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Proxy</strong>：为其它对象提供一个代理以控制对这个对象的訪问。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Template Method</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类能够不改变一个算法的结构就可以重定义该算法的某些特定步骤。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Strategy</strong>：定义一系列的算法,把它们一个个封装起来, 而且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>State</strong>：同意一个对象在其内部状态改变时改变它的行为。对象看起来似乎改动了它所属的类。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Observer</strong>：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,全部依赖于它的对象都得到通知并自己主动刷新。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Memento</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态。并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Mediator</strong>：用一个中介对象来封装一系列的对象交互。中介者使各对象不须要显式地相互引用，从而使其耦合松散，而且能够独立地改变它们之间的交互。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Command</strong>：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行參数化。对请求排队或记录请求日志，以及支持可取消的操作。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Visitor</strong>：表示一个作用于某对象结构中的各元素的操作。它使你能够在不改变各元素的类的前提下定义作用于这些元素的新操作。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Chain of Responsibility</strong>：为解除请求的发送者和接收者之间耦合。而使多个对象都有机会处理这个请求。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">将这些对象连成一条链，并沿着这条链传递该请求。直到有一个对象处理它。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Iterator</strong>：提供一种方法顺序訪问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>Interpreter</strong>：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;color:#FF0000;">Template Method</span>：(1)、意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类能够不改变一个算法的结构就可以重定义该算法的某些特定步骤。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)、适用性：A、一次性实现一个算法的不变的部分。并将可变的行为留给子类来实现。B、各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码反复。C、控制子类扩展。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)、效果：模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4)、注意事项：A、使用C++訪问控制：在C++中，一个模板方法调用的原语操作能够被定义为保护成员。这保证它们仅仅被模板方法调用。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">必须重定义的原语操作须定义为纯虚函数。模板方法自身不需被重定义。因此能够将模板方法定义为一个非虚成员函数。B、尽量降低原语操作：定义模板方法的一个重要目的是尽量降低一个子类详细实现该算法时必须重定义的那些原语操作的数目。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">须要重定义的操作越多，客户程序就越冗长。C、命名约定：能够给应被重定义的那些操作的名字加上一个前缀以识别它们。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5)、相关模式：A、FactoryMethod模式常被模板方法调用。B、模板方法使用继承来改变算法的一部分。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">Strategy使用托付来改变整个算法。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (6)、TemplateMethod:把不变的代码部分都转移到父类中，将可变的代码用virtual留给子类重写。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (7)、Template Method模式实际上就是利用面向对象中多态的概念实现算法实现细节和高层接口的松耦合。能够看到Template Method模式採取的是继承方式实现这一点的。因为继承是一种强约束性的条件。因此也给Template Method模式带来一些很多不方便的地方。其关键是将通用算法(逻辑)封装起来，而将算法细节让子类实现(多态)。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Template Method模式获得一种反向控制结构效果，这也是面向对象系统的分析和设计中一个原则DIP(依赖倒置：Dependency Inversion Principles)。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">其含义就是父类调用子类的操作(高层模块调用低层模块的操作)，低层模块实现高层模块声明的接口。这样控制权在父类(高层模块)。低层模块反而要依赖高层模块。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">演示样例代码1：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

class AbstractClass
{
public:
	void Show()
	{
		cout&lt;&lt;"我是"&lt;&lt;GetName()&lt;&lt;endl;
	}
protected:
	virtual string GetName() = 0;
};

class Naruto : public AbstractClass
{
protected:
	virtual string GetName()
	{
		return "火影史上最帅的六代目----一鸣惊人naruto";
	}
};

class OnePice : public AbstractClass
{
protected:
	virtual string GetName()
	{
		return "我是无恶不作的大海贼----路飞";
	}
};

//client
int main()
{
	Naruto* man = new Naruto();
	man-&gt;Show();

	OnePice* man2 = new OnePice();
	man2-&gt;Show();

	/*result
		我是火影史上最帅的六代目----一鸣惊人naruto
		我是我是无恶不作的大海贼----路飞
	*/

	return 0;
}</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">演示样例代码2：</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">Template.h:</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <pre><code class="language-cpp">#ifndef _TEMPLATE_H_
#define _TEMPLATE_H_

class AbstractClass
{
public:
	virtual ~AbstractClass();
	void TemplateMethod();
protected:
	virtual void PrimitiveOperation1() = 0;
	virtual void PrimitiveOperation2() = 0;
	AbstractClass();
private:
};

class ConcreteClass1 : public AbstractClass
{
public:
	ConcreteClass1();
	~ConcreteClass1();
protected:
	void PrimitiveOperation1();
	void PrimitiveOperation2();
private:
};

class ConcreteClass2 : public AbstractClass
{
public:
	ConcreteClass2();
	~ConcreteClass2();
protected:
	void PrimitiveOperation1();
	void PrimitiveOperation2();
private:
};

#endif//~_TEMPLATE_H_</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">Template.cpp :</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <pre><code class="language-cpp">#include "Template.h"
#include &lt;iostream&gt;

using namespace  std;

AbstractClass::AbstractClass()
{

}

AbstractClass::~AbstractClass()
{

}

void AbstractClass::TemplateMethod()
{
	this-&gt;PrimitiveOperation1();
	this-&gt;PrimitiveOperation2();
}

ConcreteClass1::ConcreteClass1()
{

}

ConcreteClass1::~ConcreteClass1()
{

}

void ConcreteClass1::PrimitiveOperation1()
{
	cout&lt;&lt;"ConcreteClass1 ... PrimitiveOperation1"&lt;&lt;endl;
}

void ConcreteClass1::PrimitiveOperation2()
{
	cout&lt;&lt;"ConcreteClass1 ... PrimitiveOperation2"&lt;&lt;endl;
}

ConcreteClass2::ConcreteClass2()
{

}

ConcreteClass2::~ConcreteClass2()
{

}

void ConcreteClass2::PrimitiveOperation1()
{
	cout&lt;&lt;"ConcreteClass2 ... PrimitiveOperation1"&lt;&lt;endl;
}

void ConcreteClass2::PrimitiveOperation2()
{
	cout&lt;&lt;"ConcreteClass2 ... PrimitiveOperation2"&lt;&lt;endl;
}</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">main.cpp:</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <pre><code class="language-cpp">#include "Template.h"
#include &lt;iostream&gt;

using namespace std;

int main()
{
	AbstractClass* p1 = new ConcreteClass1();
	AbstractClass* p2 = new ConcreteClass2();
	p1-&gt;TemplateMethod();
	p2-&gt;TemplateMethod();

	/*result
		ConcreteClass1 ... PrimitiveOperation1
		ConcreteClass1 ... PrimitiveOperation2
		ConcreteClass2 ... PrimitiveOperation1
		ConcreteClass2 ... PrimitiveOperation2
	*/

	return 0;
}</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">模板方法模式结构图：</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140615153116515" alt="" style="border:0px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">參考文献：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">1、《大话设计模式C++》</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">2、《设计模式精解----GoF23分析设计模式》</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">3、《设计模式----可重用的对象取向软件基础》</p> 
   <div> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;">版权声明：本文博客原创文章。博客，未经同意，不得转载。</p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
    <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></p> 
    <p><font color="#333333"><span style="font-size:12px;"><br></span></font></p> 
    <p><font color="#333333"><span style="font-size:12px;">本文转自mfrbuaa博客园博客，原文链接：http://www.cnblogs.com/mfrbuaa/p/4631224.html，如需转载请自行联系原作者</span></font></p> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
