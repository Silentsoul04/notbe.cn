<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ES6 Generators的异步应用 « NotBeCN</title>
  <meta name="description" content="             ES6 Generators系列：        ES6 Generators基本概念     深入研究ES6 Generators     ES6 Generators的异步应用     ES6 Generators并发       　　通过前面两篇文章，我们已经对ES6 genera...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/11/weixin_34034261_90117076.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">ES6 Generators的异步应用</h1>
    <p class="post-meta">Nov 11, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">ES6 Generators系列：</h4> 
   <ol style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6372809.html%20" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators基本概念</a></li> 
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6379404.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">深入研究ES6 Generators</a></li> 
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6493291.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators的异步应用</a></li> 
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6592210.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators并发</a></li> 
   </ol>
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　通过前面两篇文章，我们已经对ES6 generators有了一些初步的了解，是时候来看看如何在实际应用中发挥它的作用了。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　Generators最主要的特点就是单线程执行，同步风格的代码编写，同时又允许你<strong>将代码的异步特性隐藏在程序的实现细节中</strong>。这使得我们可以用非常自然的方式来表达程序或代码的流程，而不用同时还要兼顾如何编写异步代码。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　也就是说，通过generator函数，我们<strong>将程序具体的实现细节从异步代码中抽离出来</strong>（通过<strong>next(..)</strong>来遍历generator函数），从而很好地实现了功能和关注点的分离。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　其结果就是代码易于阅读和维护，在编写上具有同步风格，但却支持异步特性。那如何才能做到这一点呢？</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">&nbsp;</h3> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">最简单的异步</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　一个最简单的例子，generator函数内部不需要任何异步执行代码即可完成整个异步过程的调用。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　假设你有下面这段代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> makeAjaxCall(url,cb) {
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> ajax请求</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 完成时调用cb(result)</span>
<span style="line-height:1.5;">}

makeAjaxCall( </span>"http://some.url.1", <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(result1){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> data =<span style="line-height:1.5;"> JSON.parse( result1 );

    makeAjaxCall( </span>"http://some.url.2/?id=" + data.id, <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(result2){
        </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> resp =<span style="line-height:1.5;"> JSON.parse( result2 );
        console.log( </span>"The value you asked for: " +<span style="line-height:1.5;"> resp.value );
    });
} );</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　如果使用generator函数来实现上面代码的逻辑：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> request(url) {
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 这里的异步调用被隐藏起来了，</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 通过it.next(..)方法对generator函数进行迭代，</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 从而实现了异步调用与main方法之间的分离</span>
    makeAjaxCall( url, <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(response){
        it.next( response );
    } );
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 注意：这里没有return语句！</span>
<span style="line-height:1.5;">}

</span><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">main() {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result1 = yield request( "http://some.url.1"<span style="line-height:1.5;"> );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> data =<span style="line-height:1.5;"> JSON.parse( result1 );

    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result2 = yield request( "http://some.url.2?id=" +<span style="line-height:1.5;"> data.id );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> resp =<span style="line-height:1.5;"> JSON.parse( result2 );
    console.log( </span>"The value you asked for: " +<span style="line-height:1.5;"> resp.value );
}

</span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> it =<span style="line-height:1.5;"> main();
it.next(); </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 开始</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　解释一下上面的代码是如何运行的。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　方法<strong>request(..)</strong>是对<strong>makeAjaxCall(..)</strong>的封装，确保回调能够调用generator函数的<strong>next(..)</strong>方法。请注意<strong>request(..)</strong>方法中没有return语句（或者说返回了一个<strong>undefined</strong>值），后面我们会讲到为什么要这么做。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　Main函数的第一行，由于<strong>request(..)</strong>方法没有任何返回值，所以这里的<strong>yield request(..)</strong>表达式不会接收任何值进行计算，仅仅暂停了main函数的运行，直到<strong>makeAjaxCall(..)</strong>在ajax的回调中执行<strong>it.next(..)</strong>方法，然后恢复main函数的运行。那这里yield表达式的结果到底是什么呢？我们将什么赋值给了变量<strong>result1</strong>？在Ajax的回调中，<strong>it.next(..)</strong>方法将Ajax请求的返回值传入，这个值会被yield表达式返回给变量<strong>result1</strong>！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　是不是很酷！这里，<strong>result1 = yield request(..)</strong>事实上就是为了<strong>得到ajax的返回结果</strong>，只不过这种写法将回调隐藏起来了，我们完全不用担心，因为其中具体的执行步骤就是异步调用。通过<strong>yield</strong>表达式的暂停功能，我们将程序的异步调用隐藏起来，然后在另一个函数（ajax的回调）中恢复对generator函数的运行，整个过程使得我们的main函数的代码看起来<strong>就像是在同步执行一样</strong>。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　语句<strong>result2 = yield result(..)</strong>的执行过程与上面一样。代码执行过程中，有关generator函数的暂停和恢复完全是透明的，程序最终将我们想要的结果返回回来，而所有的这些都不需要我们将注意力放在异步代码的编写上。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　当然，代码中少不了<strong>yield</strong>关键字，这里暗示着可能会有一个异步调用。不过这和地狱般的嵌套回调（或者promise链）比起来，代码看起来要清晰很多。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　注意上面我说的<strong>yield</strong>关键字的地方是“可能”会出现一个异步调用，而不是一定会出现。在上面的例子中，程序每次都会去调用一个Ajax的异步请求，但如果我们修改了程序，将之前Ajax响应的结果缓存起来，情况会怎样呢？又或者我们在程序的URL请求路由中加入某些逻辑判断，使其立即就返回Ajax请求的结果，而不是真正地去请求服务器，情况又会怎样呢？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我们将上面的代码改成下面这个版本：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">var</span> cache =<span style="line-height:1.5;"> {};

</span><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> request(url) {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;"> (cache[url]) {
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 延迟返回缓存中的数据，以保证当前执行线程运行完成</span>
        setTimeout( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(){
            it.next( cache[url] );
        }, </span>0<span style="line-height:1.5;"> );
    }
    </span><span style="color:rgb(0,0,255);line-height:1.5;">else</span><span style="line-height:1.5;"> {
        makeAjaxCall( url, </span><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(resp){
            cache[url] </span>=<span style="line-height:1.5;"> resp;
            it.next( resp );
        } );
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　注意上面代码中的<strong>setTimeout(..)</strong>语句，它会延迟返回缓存中的数据。如果我们直接调用<strong>it.next(..)</strong>程序会报错，这是因为generator函数目前还不是处于暂停状态。主函数在调用完<strong>request(..)</strong>之后，generator函数才会处于暂停状态。所以，我们不能在<strong>request(..)</strong>函数内部立即执行<strong>it.next(..)</strong>，因为此时的generator函数仍然处于运行中（即yield表达式还没有被处理）。不过我们可以稍后再调用<strong>it.next(..)</strong>，<strong>setTimeout(..)</strong>语句将会在当前执行线程完成后立即执行，也就是在<strong>request(..)</strong>方法执行完后再执行，这正是我们想要的。下面我们会有更好的解决方案。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　现在，我们的main函数的代码依然是这样：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result1 = yield request( "http://some.url.1"<span style="line-height:1.5;"> );
</span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> data =<span style="line-height:1.5;"> JSON.parse( result1 );
..</span></pre>
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　瞧！我们的程序从不带缓存的版本改成了带缓存的版本，但是main函数却不用做任何修改。<strong>*main()</strong>函数依然只是请求一个值，然后暂停运行，直到请求返回一个结果，然后再继续运行。当前程序中，暂停的时间可能会比较长（实际Ajax请求大概会在300-800ms之间），但也可能是0（使用<strong>setTimeout(..0)</strong>延迟的情况）。无论是哪种情况，我们的主流程是不变的。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　这就是<strong>将异步过程抽象为实现细节</strong>的真正力量！</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">&nbsp;</h3> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">改进的异步</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　以上方法仅适用于一些简单异步处理的generator函数，很快你就会发现在大多数实际应用中根本不够用，所以我们需要一个更强大的异步处理机制来匹配generator函数，使其能够发挥更大的作用。这个处理机制是什么呢？答案就是<strong>promises</strong>. 如果你对ES6 Promises还不了解，可以看看这里的一篇文章：&nbsp;<a href="http://blog.getify.com/promises-part-1/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">http://blog.getify.com/promises-part-1/</a></p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在前面的Ajax示例代码中，无一例外都会遇到嵌套回调的问题（我们称之为回调地狱）。到目前为止我们还有一些东西没有考虑到：</p> 
   <ol style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">
    <li style="list-style:decimal;">有关错误处理。在前一篇文章中我们已经介绍过如何在generator函数中处理错误，我们可以在Ajax的回调中判断是否出错，并通过<strong>it.throw(..)</strong>方法将错误传递给generator函数，然后在generator函数中使用<strong>try..catch</strong>语句来处理它。但这无疑会带来许多工作量，而且如果程序中有很多generator函数的话，代码也不容易重用。</li> 
    <li style="list-style:decimal;">如果<strong>makeAjaxCall(..)</strong>函数不在我们的控制范围内，并且它会多次调用回调，或者同时返回success和error等等，那么我们的generator函数将会陷于混乱（未处理的异常，返回意外的值等）。要解决这些问题，你可能需要做很多额外的工作，这显然很不方便。</li> 
    <li style="list-style:decimal;">通常我们需要“并行”来处理多个任务（例如同时发起两个Ajax请求），由于generator函数的<strong>yield</strong>只允许单个暂停，因此两个或多个<strong>yield</strong>不能同时运行，它们必须按顺序一个一个地运行。所以，在不编写大量额外代码的前提下，很难在generator函数的单个<strong>yield</strong>中同时处理多个任务。</li> 
   </ol>
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　上面的这些问题都是可以解决的，但是谁都不想每次都面对这些问题然后从头到尾地解决一遍。我们需要一个功能强大的设计模式，能够作为一个可靠的并且可以重用的解决方案，应用到我们的generator函数的异步编程中。这种模式要能够返回一个<strong>promises</strong>，并且在完成之后恢复generator函数的运行。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　回想一下上面代码中的<strong>yield request(..)</strong>表达式，函数<strong>request(..)</strong>没有任何返回值，但实际上这里我们是不是可以理解为<strong>yield</strong>返回了一个<strong>undefined</strong>呢？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我们将<strong>request(..)</strong>函数改成基于<strong>promises</strong>的，这样它会返回一个promise，所以yield表达式的计算结果也是一个<strong>promise</strong>而不是<strong>undefined</strong>。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> request(url) {
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 注意：现在返回的是一个promise！</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">new</span> Promise( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(resolve,reject){
        makeAjaxCall( url, resolve );
    } );
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　现在，<strong>request(..)</strong>函数会构造一个<strong>Promise</strong>对象，并在Ajax调用完成之后进行解析，然后返回一个promise给yield表达式。然后呢？我们需要一个函数来控制generator函数的迭代，这个函数会接收所有的这些<strong>yield promises</strong>然后恢复generator函数的运行（通过<strong>next(..)</strong>方法）。我们假设这个函数叫<strong>runGenerator(..)</strong>：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 异步调用一个generator函数直到完成</span><span style="color:rgb(0,128,0);line-height:1.5;">
//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 注意：这是最简单的情况，不包含任何错误处理</span>
<span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> runGenerator(g) {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> it =<span style="line-height:1.5;"> g(), ret;

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 异步迭代给定的generator函数</span>
    (<span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> iterate(val){
        ret </span>=<span style="line-height:1.5;"> it.next( val );

        </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (!<span style="line-height:1.5;">ret.done) {
            </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 简单测试返回值是否是一个promise</span>
            <span style="color:rgb(0,0,255);line-height:1.5;">if</span> ("then" <span style="color:rgb(0,0,255);line-height:1.5;">in</span><span style="line-height:1.5;"> ret.value) {
                </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 等待promise返回</span>
<span style="line-height:1.5;">                ret.value.then( iterate );
            }
            </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 立即执行</span>
            <span style="color:rgb(0,0,255);line-height:1.5;">else</span><span style="line-height:1.5;"> {
                </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 避免同步递归调用</span>
                setTimeout( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(){
                    iterate( ret.value );
                }, </span>0<span style="line-height:1.5;"> );
            }
        }
    })();
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　几个关键的点：</p> 
   <ol style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">
    <li style="list-style:decimal;">程序会自动初始化generator函数（创建迭代器<strong>it</strong>）,然后异步运行直到完成（<strong>done:true</strong>）。</li> 
    <li style="list-style:decimal;">查看<strong>yield</strong>是否返回一个<strong>promise</strong>（通过<strong>it.next(..)</strong>返回值中的<strong>value</strong>属性来查看），如果是，则等待promise中的<strong>then(..)</strong>方法执行完。</li> 
    <li style="list-style:decimal;">任何立即执行的代码（非promise类型）将会直接返回结果给generator函数，然后继续运行。</li> 
   </ol>
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　现在我们来看看如何使用它。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>runGenerator( <span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">main(){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result1 = yield request( "http://some.url.1"<span style="line-height:1.5;"> );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> data =<span style="line-height:1.5;"> JSON.parse( result1 );

    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result2 = yield request( "http://some.url.2?id=" +<span style="line-height:1.5;"> data.id );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> resp =<span style="line-height:1.5;"> JSON.parse( result2 );
    console.log( </span>"The value you asked for: " +<span style="line-height:1.5;"> resp.value );
} );</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　等等！<strong>这不是和本文一开始的那个generator函数一样吗？</strong>是的。不过在这个版本中，我们创建了promises并返回给yield，等promise完成之后恢复generator函数继续运行。<strong>所有这些操作都“隐藏”在实现细节中！</strong>不过不是真正的隐藏，我们只是将它从消费代码（这里指的是我们的generator函数中的流程控制）中分离出去而已。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>Yield</strong>接受一个promise，然后等待它完成之后返回最终的结果给<strong>it.next(..)</strong>。通过这种方式，语句<strong>result1 = yield request(..)</strong>能够得到和之前一样的结果。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　现在我们使用promises来管理generator函数中异步调用部分的代码，从而解决了在回调中所遇到的各种问题：</p> 
   <ol style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">
    <li style="list-style:decimal;">拥有内置的错误处理机制。虽然我们并没有在<strong>runGenerator(..)</strong>函数中显示它，但是从promise监听错误并非难事，一旦监听到错误，我们可以通过<strong>it.throw(..)</strong>将错误抛出，然后通过<strong>try..catch</strong>语句捕获和处理这些错误。</li> 
    <li style="list-style:decimal;">我们通过promises来控制所有的流程。这一点毋庸置疑。</li> 
    <li style="list-style:decimal;">在自动处理各种复杂的“并行”任务方面，promises拥有十分强大的抽象能力。例如，<strong>yield Promise.all([..])</strong>接收一个“并行”任务的promises数组，然后<strong>yield</strong>一个单个的promise（返回给generator函数处理），这个单个的promise会等待数组中所有的promises全部处理完之后才会开始，但这些promises的执行顺序无法保证。当所有的promises执行完后，<strong>yield</strong>表达式会接收到另外一个数组，数组中的值是每个promise返回的结果，按照promise被请求的顺序依次排列。</li> 
   </ol>
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　首先我们来看一下错误处理：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 假设：`makeAjaxCall(..)` 是“error-first”风格的回调（为了简洁，省略了部分代码）</span><span style="color:rgb(0,128,0);line-height:1.5;">
//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 假设：`runGenerator(..)` 也具备错误处理的功能（为了简洁，省略了部分代码）</span>

<span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> request(url) {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">new</span> Promise( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(resolve,reject){
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 传入一个error-first风格的回调函数</span>
        makeAjaxCall( url, <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(err,text){
            </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;"> (err) reject( err );
            </span><span style="color:rgb(0,0,255);line-height:1.5;">else</span><span style="line-height:1.5;"> resolve( text );
        } );
    } );
}

runGenerator( </span><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">main(){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">try</span><span style="line-height:1.5;"> {
        </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result1 = yield request( "http://some.url.1"<span style="line-height:1.5;"> );
    }
    </span><span style="color:rgb(0,0,255);line-height:1.5;">catch</span><span style="line-height:1.5;"> (err) {
        console.log( </span>"Error: " +<span style="line-height:1.5;"> err );
        </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;">;
    }
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> data =<span style="line-height:1.5;"> JSON.parse( result1 );

    </span><span style="color:rgb(0,0,255);line-height:1.5;">try</span><span style="line-height:1.5;"> {
        </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result2 = yield request( "http://some.url.2?id=" +<span style="line-height:1.5;"> data.id );
    } </span><span style="color:rgb(0,0,255);line-height:1.5;">catch</span><span style="line-height:1.5;"> (err) {
        console.log( </span>"Error: " +<span style="line-height:1.5;"> err );
        </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;">;
    }
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> resp =<span style="line-height:1.5;"> JSON.parse( result2 );
    console.log( </span>"The value you asked for: " +<span style="line-height:1.5;"> resp.value );
} );</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在<strong>request(..)</strong>函数中，<strong>makeAjaxCall(..)</strong>如果出错，会返回一个promise的rejection，并最终映射到generator函数的error（在<strong>runGenerator(..)</strong>函数中通过<strong>it.throw(..)</strong>方法抛出错误，这部分细节对于消费端来说是透明的），然后在消费端我们通过<strong>try..catch</strong>语句最终捕获错误。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　下面我们来看一下复杂点的使用promises异步调用的情况：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> request(url) {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">new</span> Promise( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(resolve,reject){
        makeAjaxCall( url, resolve );
    } )
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 在ajax调用完之后获取返回值，然后进行下一步操作</span>
    .then( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(text){
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 查看返回值中是否包含URL</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (/^https?:\/\/.+/<span style="line-height:1.5;">.test( text )) {
            </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 如果有则继续调用这个新的URL</span>
            <span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> request( text );
        }
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 否则直接返回调用的结果</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">else</span><span style="line-height:1.5;"> {
            </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span><span style="line-height:1.5;"> text;
        }
    } );
}

runGenerator( </span><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">main(){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> search_terms =<span style="line-height:1.5;"> yield Promise.all( [
        request( </span>"http://some.url.1"<span style="line-height:1.5;"> ),
        request( </span>"http://some.url.2"<span style="line-height:1.5;"> ),
        request( </span>"http://some.url.3"<span style="line-height:1.5;"> )
    ] );

    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> search_results =<span style="line-height:1.5;"> yield request(
        </span>"http://some.url.4?search=" + search_terms.join( "+"<span style="line-height:1.5;"> )
    );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> resp =<span style="line-height:1.5;"> JSON.parse( search_results );

    console.log( </span>"Search results: " +<span style="line-height:1.5;"> resp.value );
} );</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>Promise.all([...])</strong>构造了一个promise对象，它接收三个子promises，当所有的子promises都完成之后，将返回的结果通过<strong>yield</strong>表达式传递给<strong>runGenerator(..)</strong>函数并恢复运行。在<strong>request(..)</strong>函数中，每个子promise通过链式操作对response的值进行解析，如果其中包含另一个URL则继续请求这个URL，如果没有则直接返回response的值。有关promise的链式操作可以查看这篇文章：&nbsp;<a href="http://blog.getify.com/promises-part-5/#the-chains-that-bind-us" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">http://blog.getify.com/promises-part-5/#the-chains-that-bind-us</a></p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　任何复杂的异步处理，你都可以通过在generator函数中使用yield promise来完成（或者promise的promise链式操作），这样代码具有同步风格，看起来更加简洁。<strong>这是目前最佳的处理方式。</strong></p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">&nbsp;</h3> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">runGenerator(..)工具库</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我们需要定义我们自己的<strong>runGenerator(..)</strong>工具来实现上面介绍的generator+promises模式。为了简单，我们甚至可以不用实现所有的功能，因为这其中有很多的细节需要处理，例如错误处理的部分。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　但是你肯定不想亲自来写<strong>runGenerator(..)</strong>函数吧？反正我是不想。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　其实有很多的开源库提供了promise/async工具，你可以免费使用。这里我就不去一一介绍了，推荐看看<strong>Q.spawn(..)</strong>，<strong>co(..)</strong>等。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　这里我想介绍一下我自己写的一个工具库：<a href="http://github.com/getify/asynquence" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">asynquence</a>的插件<a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">runner</a>。因为我认为和其它工具库比起来，这个插件提供了一些独特的功能。我写过<a href="https://davidwalsh.name/asynquence-part-1/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">一个系列文章</a>，是有关asynquence的，如果你有兴趣的话可以去读一读。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　首先，asynquence提供了一系列的工具来自动处理“error-first”风格的回调函数。看下面的代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> request(url) {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span> ASQ( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(done){
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 这里传入了一个error-first风格的回调函数 - done.errfcb</span>
<span style="line-height:1.5;">        makeAjaxCall( url, done.errfcb );
    } );
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　看起来是不是会好很多？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　接下来，asynquence的<strong>runner(..)</strong>插件消费了asynquence序列（异步调用序列）中的generator函数，因此你可以从序列的从上一步中传入消息，然后generator函数可以将这个消息返回，继续传到下一步，并且这其中的任何错误都将自动向上抛出，你不用自己去管理。来看看具体的代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 首先调用`getSomeValues()`创建一个sequence/promise，</span><span style="color:rgb(0,128,0);line-height:1.5;">
//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 然后将sequence中的async链起来</span>
<span style="line-height:1.5;">getSomeValues()

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 使用generator函数来处理获取到的values</span>
.runner( <span style="color:rgb(0,0,255);line-height:1.5;">function</span>*<span style="line-height:1.5;">(token){
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> token.messages数组将会在前一步中赋值</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">var</span> value1 = token.messages[0<span style="line-height:1.5;">];
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> value2 = token.messages[1<span style="line-height:1.5;">];
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> value3 = token.messages[2<span style="line-height:1.5;">];

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 并行调用3个Ajax请求，并等待它们全部执行完（以任何顺序）</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 注意：`ASQ().all(..)`类似于`Promise.all(..)`</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">var</span> msgs =<span style="line-height:1.5;"> yield ASQ().all(
        request( </span>"http://some.url.1?v=" +<span style="line-height:1.5;"> value1 ),
        request( </span>"http://some.url.2?v=" +<span style="line-height:1.5;"> value2 ),
        request( </span>"http://some.url.3?v=" +<span style="line-height:1.5;"> value3 )
    );

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 将message发送到下一步</span>
    yield (msgs[0] + msgs[1] + msgs[2<span style="line-height:1.5;">]);
} )

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 现在，将前一个generator函数的最终结果发送给下一个请求</span>
.seq( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(msg){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">return</span> request( "http://some.url.4?msg=" +<span style="line-height:1.5;"> msg );
} )

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 所有的全部执行完毕！</span>
.val( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(result){
    console.log( result ); </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 成功，全部完成！</span>
<span style="line-height:1.5;">} )

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 或者，有错误发生！</span>
.or( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(err) {
    console.log( </span>"Error: " +<span style="line-height:1.5;"> err );
} );</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　Asynquence&nbsp;<strong>runner(..)</strong>从sequence的上一步中接收一个messages（可选）来启动generator，这样在generator中可以访问<strong>token.messages</strong>数组中的元素。然后，与我们上面演示的<strong>runGenerator(..)</strong>函数一样，<strong>runner(..)</strong>负责监听<strong>yield promise</strong>或者<strong>yield asynquence</strong>（一个<strong>ASQ().all(..)</strong>包含了所有并行的步骤），等待完成之后再恢复generator函数的运行。当generator函数运行完之后，最终的结果将会传递给sequence中的下一步。此外，如果这其中有错误发生，包括在generator函数体内产生的错误，都将会向上抛出或者被错误处理程序捕捉到。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　Asynquence试图将promises和generator融合到一起，使代码编写变得非常简单。只要你愿意，你可以随意地将任何generator函数与基于promise的sequence联系到一起。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">ES7 async</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在ES7的计划中，有一个提案非常不错，它创建了另外一种function：<strong>async function</strong>。有点像generator函数，它会自动包装到一个类似于我们的<strong>runGenerator(..)</strong>函数（或者asynquence的<strong>runner(..)</strong>函数）的utility中。这样，就可以自动地发送<strong>promises</strong>和<strong>async function</strong>并在它们执行完后恢复运行（甚至都不需要generator函数遍历器了！）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　代码看起来就像这样：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>async <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> main() {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result1 = await request( "http://some.url.1"<span style="line-height:1.5;"> );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> data =<span style="line-height:1.5;"> JSON.parse( result1 );

    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> result2 = await request( "http://some.url.2?id=" +<span style="line-height:1.5;"> data.id );
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> resp =<span style="line-height:1.5;"> JSON.parse( result2 );
    console.log( </span>"The value you asked for: " +<span style="line-height:1.5;"> resp.value );
}

main();</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>Async function</strong>可以被直接调用（上面代码中的main()语句），而不用像我们之前那样需要将它包装到<strong>runGenerator(..)</strong>或者<strong>ASQ.runner(..)</strong>函数中。在函数内部，我们不需要<strong>yield</strong>，取而代之的是<strong>await</strong>（另一个新加入的关键字），它会告诉<strong>async function</strong>等待promise完成之后才会继续运行。将来我们会有更多的generator函数库都支持本地语法。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　是不是很酷？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　同时，像asynquence runner这样的库一样，它们会给我们在异步generator函数编程方面带来极大的便利。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">&nbsp;</h3> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">总结</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　一句话，<strong>generator + yield promise(s)</strong>模式功能是如此强大，它们一起使得对同步和异步的流程控制变得行运自如。伴随着使用一些包装库（很多现有的库都已经免费提供了），我们可以自动执行我们的generator函数直到所有的任务全部完成，并且包含了错误处理！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在ES7中，我们很可能将会看到<strong>async function</strong>这种类型的函数，它使得我们在没有第三方库支持的情况下也可以做到上面说的这些（至少对于一些简单情况来说是可以的）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>JavaScript的异步在未来是光明的</strong>，而且只会越来越好！我坚信这一点。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　不过还没完，我们还有最后一个东西需要探索：</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　如果有两个或多个generators函数，如何让它们独立地并行运行，并且各自发送自己的消息呢？这或许需要一些更强大的功能，没错！我们管这种模式叫“CSP”（communicating sequential processes）。我们将在下一篇文章中探讨和揭秘CSP的强大功能。敬请关注！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><br></p> 
   <p><font color="#393939"><span style="font-size:14px;">本文转自Jaxu博客园博客，原文链接：http://www.cnblogs.com/jaxu/p/6493291.html</span></font><span style="font-size:14px;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <div>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
