<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>对象的协作 « NotBeCN</title>
  <meta name="description" content="             面向对象设计的一个重要分析方法是利用对象的职责来驱动设计。对象有了职责，才会成为具体拥有意识的对象，成为对象社区中可以独立完成，或者发出指令委派别的对象协作完成职责的一员。将对象看成是“具有职责的东西”。对象应该自己负责自己，而且应该清楚地定义职责。这就是对象设计的关键。好的软件设计者应...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/17/1557728959877.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">对象的协作</h1>
    <p class="post-meta">Nov 17, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">面向对象设计的一个重要分析方法是利用对象的职责来驱动设计。对象有了职责，才会成为具体拥有意识的对象，成为对象社区中可以独立完成，或者发出指令委派别的对象协作完成职责的一员。将对象看成是“<b>具有职责的东西</b>”。对象应该自己负责自己，而且应该清楚地定义职责。这就是对象设计的关键。好的软件设计者应该像牧羊人一般放牧自己的牛羊，只需要给它们一片丰沃的草地，它们就能自己觅食生活。&nbsp;</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">Rebecca认为：对象在履行职责时有3种选择，你可以任选其一：（1）亲自完成所有的工作。（2）请求其他对象帮忙完成部分工作（和其他对象协作）。（3）将整个服务请求委托给另外的帮助对象。在分析对象职责时，可以考虑“专家”模式，即信奉专业的事情交给专家来完成，既不互相推诿，却也不能越俎代庖。专家有其擅长的领域，如果把专家错放在他不熟悉的领域，不仅会降低工作效率，还可能引入潜在危机。所谓“尺有所长，寸有所短”，含义正在于此。</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">对象的能力总是有限的，正如我们不能将所有的鸡蛋放在一个篮子里，我们也不能将所有的职责交给“上帝”。这既避免单一功能点带来的风险，又能实现职责的分权。Christepher Alexander建议，在遇到设计问题时“尽量少用集权的机制”。软件设计同样如此。职责总是可大可小，面对复杂的职责行为，总是需要多个对象的协作才能完成，就像机器中的零部件，按部就班，各司其职。</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">让我们来设计一个数据分析器，它通过分析算法对输入数据进行分析，并将结果保存在输出集中。根据业务需求的不同，执行的分析算法也不相同。同时，为了提高分析性能，我们还需要采用多线程方式执行分析任务。从调用者的角度来看【即Martin Fowler提到的规约视角】，我们只关心分析需要的数据以及分析后的结果。那么，谁应该来承担分析的职责呢？毫无疑问，我们可以定义分析器对象来履行这一职责。此外，调用者其实并不会关心分析算法的实现以及分析的过程，他希望分析是易于执行的，这一愿望通过有效的封装完全可以满足。我们可以将分析的职责封装在DataAnalyzer类中，同时隐藏具体的分析算法。</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;Client {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">static</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;run(InputData input) {
    <br> DataAnalyzer analyzer =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;DataAnalyzer();
    <br> AnalyticResult result = analyzer.analysis(input);
    <br>
    <br>
    <span style="color:rgb(0,128,0);">//做其它事情</span>
    <br>
    <br>
    <span style="color:rgb(0,128,0);">//处理分析后的数据</span>
    <br> handleOutput(analyzer.output(result));
    <br> }
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;DataAnalyzer {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;AnalyticResult analysis(InputData input) {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData output(AnalyticResult result) {}
    <br> }&nbsp;
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">然而，数据的分析并不是一件简单的事情。分析器虽然是分析的专家，却不精通多线程的执行。它自身无法提供分析的异步操作，这时就需要其他对象的协作。分析器将这一职责委派给TaskScheduler对象。TaskScheduler是一个任务调度器，可以发起任务的运行，并在运行完毕的时候，通知任务的发起者。对于TaskScheduler而言，并不会关心具体执行了何种任务。这样的设计能够遵循Demeter法则，让对象尽量保持无知，以避免不必要的依赖。</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;TaskScheduler {
    <br>
    <span style="color:rgb(0,0,255);">private</span>&nbsp;Task task;
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;AnalyticResult beginRun(Task task) {
    <br> AnalyticResult result =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;AnalyticResultImpl();
    <br> task.setResult(result);
    <br>
    <span style="color:rgb(0,0,255);">this</span>.task = task;
    <br> Thread thread =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;Thread(
    <span style="color:rgb(0,0,255);">this</span>.task);
    <br> thread.start();
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;result;
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData endRun(AnalyticResult result) {
    <br>
    <span style="color:rgb(0,0,255);">while</span>&nbsp;(!result.beFinished()) {
    <br> result.wait();
    <br> }&nbsp;
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;task.getOutputData();
    <br> }&nbsp;
    <br> }&nbsp;
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">TaskScheduler引入AnalyticResult对象的目的是为了判断任务执行的状态。它封装了当前的线程，从而可以获得当前线程的状态，并能够操作线程。</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">interface</span>&nbsp;AnalyticResult {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setCurrentThread(Thread thread);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">boolean</span>&nbsp;isFinished();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;finish();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;wait();
    <br> }
    <br>
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">DataAnalyzer的内部封装了对TaskScheduler对象的调用：</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;DataAnalyzer {
    <br>
    <span style="color:rgb(0,0,255);">private</span>&nbsp;TaskScheduler scheduler =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;TaskScheduler();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;AnalyticResult analysis(InputData input) {
    <br> Task task = createTask(input);
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;scheduler.beginRun(task);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData output(AnalyticResult result) {
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;scheduler.endRun(result);
    <br> }
    <br> }&nbsp;
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">Task任务对象负责完成分析任务。虽然在之前的分析中，我们认为DataAnalyzer对象承担了分析数据的职责。不过，这一职责仅就调用者而言是可行的，对于DataAnalyzer的内部实现则不然。这基于两种原因。其一是分析过程的复杂程度，它需要对输入数据进行多个步骤的处理，包含数据的转换、过滤、运算以及存储。如果让DataAnalyzer一力承担，则可能导致职责过重，形成一个庞大的复杂对象。这既有碍于代码的阅读性，也不利于处理过程或算法的重用。其二是分析过程的可变性。根据不同的输入数据，需要不同的分析算法。DataAnalyzer不应该负责对算法的决策与选择。而且，随着需求的变化，数据分析器可能需要扩展。将任务抽象出来，可以很好地应对变化。</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">引入Task对象可以将DataAnalyzer从繁重的分析任务中解放出来，同时又能够保证它对分析任务的封装，是很好的对象协作表现。由于Task对象需要支持多线程，我们还需要它实现Runnable接口。至于ExecutionCallback是一个回调对象，注册该对象可以在任务执行完毕后调用它：</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">interface</span>&nbsp;Task&nbsp;
    <span style="color:rgb(0,0,255);">extends</span>&nbsp;Runnable {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;InputData getInputData();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setInputData(InputData input);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData getOutputData();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setOutputData(OutputData output);
    <br>
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData execute(InputData input);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setResult(AnalyticResult result);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;ExecutionCallback getCallback();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setCallback(ExecutionCallback callback);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">interface</span>&nbsp;ExecutionCallback {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;callback();
    <br> }
    <br>
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">例如分析销售量波动的任务：</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;SaleWaveTask&nbsp;
    <span style="color:rgb(0,0,255);">implements</span>&nbsp;Task {
    <br>
    <span style="color:rgb(0,0,255);">private</span>&nbsp;InputData inputData;
    <br>
    <span style="color:rgb(0,0,255);">private</span>&nbsp;OutputData outputData;
    <br>
    <span style="color:rgb(0,0,255);">private</span>&nbsp;AnalyticResult result;
    <br>
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData execute(InputData input) {
    <br> inputData = input;
    <br>
    <span style="color:rgb(0,128,0);">//分析输入数据，获得销售量波动的情况</span>
    <br> result.finished();
    <br>
    <span style="color:rgb(0,0,255);">if</span>&nbsp;(getCallback() != null) {
    <br> getCallback().callback();
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;output;
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;run() {
    <br>
    <span style="color:rgb(0,0,255);">this</span>.setOutputData(execute(getInputData());
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;ExecutionCallback getCallback() {
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;ExecutionCallback() {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;callback() {
    <br> System.out.println(
    <br>
    <span style="color:rgb(0,96,128);">"The sale's wave task is completed."</span>);
    <br> }
    <br> }
    <br> }
    <br> }
    <br>
    <br>
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">之所以要在Task中为InputData和OutputData定义get、set访问器，是因为Runnable接口提供的run()方法不允许传入参数和返回结果。而在TaskScheduler中又只接受Task对象，利用这些方法可以在Task中存储和传递这些数据。</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">在DataAnalyzer类的定义中，不能忽略的另一个职责是Task对象的创建。虽然，DataAnalyzer的调用者也可以完成对Task对象的创建，并将创建好的对象传递给DataAnalyzer。然而，更好的做法是DataAnalyzer能够根据传入的InputData来决定创建哪一种Task对象。这样可以减轻调用者的负担。然而，一旦这样定义，DataAnalyzer的职责就显得混淆不清了。一方面它负责执行分析任务，另一方面又要承担创建Task对象的职责。这意味着它既是Task对象的使用者，又是Task对象的创建者。此外，DataAnalyzer对象并没有持有创建Task对象所必须的数据，违背了将数据与行为封装在一起的原则。因此，我们应该将创建的职责委派给其他对象。还有什么对象比得上“工厂专家”更适宜做创建的工作呢？最简单的做法是定义一个静态工厂：</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;TaskFactory {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">static</span>&nbsp;Task create(InputData input) {
    <br> Task task = null;
    <br>
    <span style="color:rgb(0,0,255);">if</span>&nbsp;(input.getType().equals(SALE_WAVE)) {
    <br> task =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;SaleWaveTask();
    <br> task.setInputData(input);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;task;
    <br> }
    <br> }&nbsp;
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">为了更好地应对任务的变化，我们也可以引入配置文件来管理任务。Task对象的创建因配置信息的不同而变化。create()方法能够读取配置文件，然后根据配置信息来决定创建哪一种Task对象。</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">数据的分析任务事实上是按照一定的步骤来完成的。这些步骤可能会采取不同的顺序或组合方式来执行。每一种执行步骤就是一个算法，完成数据的收集、筛选、计算、分析和存储。Task对象负责将这些步骤整合起来，并封装到接口中，将这些算法实现以及执行算法的顺序隐藏起来。为此，我们可以定义一个实现了Task接口的抽象类，统一完成整合分析步骤的工作。</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">abstract</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;AbstractTask&nbsp;
    <span style="color:rgb(0,0,255);">implements</span>&nbsp;Task {
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;AnalyticResult result;
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;List&lt;Algorithm&gt; algos;
    <br>
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;registerAlgorithm(Algorithm algo) {
    <br> algos.add(algo);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData execute(InputData input) {
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AnalyticData data =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;AnalyticData(input,null);&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; processAlgorithms(data);&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afterExecute();
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;data.getOutputData();
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;processAlgorithms(AnalyticData data) {
    <br>
    <span style="color:rgb(0,0,255);">for</span>&nbsp;(Algorithm algo : algos) {
    <br> algo.process(data);
    <br> }&nbsp;
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">private</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;afterExecute() {
    <br> result.finished();
    <br>
    <span style="color:rgb(0,0,255);">if</span>&nbsp;(getCallback() != null) {
    <br> getCallback().callback();
    <br> }
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;run() {
    <br>
    <span style="color:rgb(0,0,255);">this</span>.setOutputData(execute(getInputData());
    <br> }
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;AnalyticData {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;AnalyticData(InputData input, OutputData output) {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;InputData getInputData() {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setInputData(InputData input) {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData getOutputData() {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setOutputData(OutputData output) {}
    <br>
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;prepare() {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;complete() {}
    <br> }
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">任务的执行步骤被抽象为Algorithm接口，而AnalyticData则用于协调输入数据和输出数据，因为Algorithm对象在Task中形成了一条流水线，上一个Algorithm的输出是下一个Algorithm的输入。输入数据和输出数据形成了一种不可协调的共扼性，需要提供prepare()方法和complet()方法来完成二者之间的转换。</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">interface</span>&nbsp;Algorithm {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;process(AnalyticData data);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">abstract</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;AbstractAlgorithm&nbsp;
    <span style="color:rgb(0,0,255);">implements</span>&nbsp;Algorithm {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;process(AnalyticData data) {
    <br> data.prepare();
    <br> process(data.getInputData(), data.getOutputData());
    <br> data.complete();
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;
    <span style="color:rgb(0,0,255);">abstract</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;process(
    <br> InputData input, OutputData output);
    <br> }&nbsp;
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">我们发现Task与AnalyticData都重复定义了InputData与OutputData的get、set方法。在设计和实现时，必须避免这样的重复代码。我们发现，这样的输入输出数据体现了数据池的概念，因此可以定义一个抽象的DataSink接口：</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">interface</span>&nbsp;DataSink {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;InputData getInputData() {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setInputData(InputData input) {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData getOutputData() {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setOutputData(OutputData output) {}
    <br> }
    <br>
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">AnalyticData类实现了该接口，而Task则可以持有该对象。</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;AnalyticData&nbsp;
    <span style="color:rgb(0,0,255);">implements</span>&nbsp;DataSink {}
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">interface</span>&nbsp;Task&nbsp;
    <span style="color:rgb(0,0,255);">extends</span>&nbsp;Runnable {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setDataSink(DataSink dataSink);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData execute(InputData input);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setResult(AnalyticResult result);
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;ExecutionCallback getCallback();
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;setCallback(ExecutionCallback callback);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">abstract</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;AbstractTask&nbsp;
    <span style="color:rgb(0,0,255);">implements</span>&nbsp;Task {
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;DataSink dataSink;
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;AnalyticResult result;
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;List&lt;Algorithm&gt; algos;
    <br>
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;OutputData execute(InputData input) {
    <br> processAlgorithms(dataSink);
    <br> afterExecute();
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;dataSink.getOutputData();
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">protected</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;processAlgorithms(AnalyticData data) {
    <br>
    <span style="color:rgb(0,0,255);">for</span>&nbsp;(Algorithm algo : algos) {
    <br> algo.process(data);
    <br> }&nbsp;
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">void</span>&nbsp;run() {
    <br> execute(dataSink.getInputData());
    <br> }
    <br> }
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">传递InputData对象的方式也发生了变化：</p> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">class</span>&nbsp;TaskFactory {
    <br>
    <span style="color:rgb(0,0,255);">public</span>&nbsp;
    <span style="color:rgb(0,0,255);">static</span>&nbsp;Task create(InputData input) {
    <br> Task task = null;
    <br> DataSink dataSink =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;AnalyticData(input, null);
    <br>
    <span style="color:rgb(0,0,255);">if</span>&nbsp;(input.getType().equals(SALE_WAVE)) {
    <br> task =&nbsp;
    <span style="color:rgb(0,0,255);">new</span>&nbsp;SaleWaveTask();
    <br> task.setDataSink(dataSink);
    <br> }
    <br>
    <span style="color:rgb(0,0,255);">return</span>&nbsp;task;
    <br> }
    <br> }&nbsp;
    <br>
   </div> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">通过对分析器职责的分析，我们引入了DataAnalyzer、TaskScheduler、Task以及Algorithm等对象。这些对象的协作顺序如下图所示：</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><img title="image" height="387" alt="image" src="http://wayfarer.blog.51cto.com/attachment/201101/26/1300239_1296029907CURX.png" width="558" style="border-top:none;border-right:0px none;border-bottom:0px none;border-left:0px none;">DataAnalyzer相当于分析器的外观，它总揽全局，管理着各种对象之间的协作，共同实现分析工作。TaskScheduler是任务的调度器，负责启动任务和结束任务，而它主要的职责则是封装了对多线程的处理，用以完成任务的异步调用。如果未来需求需要强化任务的调度模式，例如增加任务队列，以调度和管理多个任务的执行，则可以修改TaskScheduler而不影响它的调用者。Task对象体现了任务的独立性，同时又利用抽象统一了任务的执行方式，有利于任务的扩展。Algorithm则完成对任务的切分，将任务步骤单独封装，有利于各种算法的重用。这些对象的协作以一种层层委派的方式，实现了职责的分离，避免了“集权式”的对象。不同的职责可以分别演化，又能很好地协作，共同完成数据分析的整体职责。</p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><br></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><br></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><br></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><br></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><br></p> 
   <p style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"><br></p> 
   <p><font color="#333333">本文转自wayfarer51CTO博客，原文链接：http://blog.51cto.com/wayfarer/486277</font><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;">，如需转载请自行联系原作者</span></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
