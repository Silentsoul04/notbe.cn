<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>【转】脉络清晰的BP神经网络讲解，赞 « NotBeCN</title>
  <meta name="description" content="                                     学习是神经网络一种最重要也最令人注目的特点。在神经网络的发展进程中，学习算法的研究有着十分重要的地位。目前，人们所提出的神经网络模型都是和学习算 法相应的。所以，有时人们并不去祈求对模型和算法进行严格的定义或区分。有的模型可以有多种算法．而...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/17/weixin_34001430_90134112.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">【转】脉络清晰的BP神经网络讲解，赞</h1>
    <p class="post-meta">Nov 17, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;"> 
    <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
     <tbody>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">学习是神经网络一种最重要也最令人注目的特点。在神经网络的发展进程中，学习算法的研究有着十分重要的地位。目前，人们所提出的神经网络模型都是和学习算 法相应的。所以，有时人们并不去祈求对模型和算法进行严格的定义或区分。有的模型可以有多种算法．而有的算法可能可用于多种模型。不过，有时人们也称算法 为模型。</p> <p style="line-height:1.5;">自从40年代Hebb提出的学习规则以来，人们相继提出了各种各样的学习算法。其中以在1986年Rumelhart等提出的误差反向传播法，即BP(error BackPropagation)法影响最为广泛。直到今天，BP算法仍然是自动控制上最重要、应用最多的有效算法。</p> <p style="line-height:1.5;">1．2．1 神经网络的学习机理和机构</p> <p style="line-height:1.5;">在神经网络中，对外部环境提供的模式样本进行学习训练，并能存储这种模式，则称为感知器；对外部环境有适应能力，能自动提取外部环境变化特征，则称为认知器。</p> <p style="line-height:1.5;">神经网络在学习中，一般分为有教师和无教师学习两种。感知器采用有教师信号进行学习，而认知器则采用无教师信号学习的。在主要神经网络如BP网 络，Hopfield网络，ART网络和Kohonen网络中；BP网络和Hopfield网络是需要教师信号才能进行学习的；而ART网络和 Kohonen网络则无需教师信号就可以学习。所谓教师信号，就是在神经网络学习中由外部提供的模式样本信号。</p> <p style="line-height:1.5;">一、感知器的学习结构</p> <p style="line-height:1.5;">感知器的学习是神经网络最典型的学习。</p> <p style="line-height:1.5;">目前，在控制上应用的是多层前馈网络，这是一种感知器模型，学习算法是BP法，故是有教师学习算法。</p> <p style="line-height:1.5;">一个有教师的学习系统可以用图1—7表示。这种学习系统分成三个部分：输入部，训练部和输出部。</p> <p align="center" style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht12.gif" alt="" width="610" height="255" style="border:0px;"></p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p align="center" style="line-height:1.5;">图1-7&nbsp; 神经网络学习系统框图</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">输入部接收外来的输入样本X，由训练部进行网络的权系数W调整，然后由输出部输出结果。在这个过程中，期望的输出信号可以作为教师信号输入，由该教师信号与实际输出进行比较，产生的误差去控制修改权系数W。</p> <p style="line-height:1.5;">学习机构可用图1—8所示的结构表示。</p> <p style="line-height:1.5;">在图中，X<sub>l</sub>&nbsp;，X<sub>2</sub>&nbsp;，…，X<sub>n</sub>&nbsp;，是输入样本信号，W<sub>1</sub>&nbsp;，W<sub>2</sub>&nbsp;，…，W<sub>n</sub>&nbsp;是权系数。输入样本信号X<sub>i</sub>&nbsp;可以取离散值“0”或“1”。输入样本信号通过权系数作用，在u产生输出结果 ∑W<sub>i</sub>&nbsp;X<sub>i</sub>&nbsp;，即有：</p> <p style="line-height:1.5;">u=∑W<sub>i</sub>&nbsp;X<sub>i</sub>&nbsp;=W<sub>1</sub>&nbsp;X<sub>1</sub>&nbsp;+W<sub>2</sub>&nbsp;X<sub>2</sub>&nbsp;+…+W<sub>n</sub>&nbsp;X<sub>n</sub></p> <p style="line-height:1.5;">再把期望输出信号Y(t)和u进行比较，从而产生误差信号e。即权值调整机构根据误差e去对学习系统的权系数进行修改，修改方向应使误差e变小，不断进行下去，使到误差e为零，这时实际输出值u和期望输出值Y(t)完全一样，则学习过程结束。</p> <p align="center" style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht11.gif" alt="" width="620" height="365" style="border:0px;"></p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">神经网络的学习一般需要多次重复训练，使误差值逐渐向零趋近，最后到达零。则这时才会使输出与期望一致。故而神经网络的学习是消耗一定时期的，有的学习过程要重复很多次，甚至达万次级。原因在于神经网络的权系数W有很多分量W<sub>1</sub>&nbsp;，W<sub>2</sub>&nbsp;，----W<sub>n</sub>&nbsp;；也即是一个多参数修改系统。系统的参数的调整就必定耗时耗量。目前，提高神经网络的学习速度，减少学习重复次数是十分重要的研究课题，也是实时控制中的关键问题。</p> <p style="line-height:1.5;">二、感知器的学习算法</p> <p style="line-height:1.5;">感知器是有单层计算单元的神经网络，由线性元件及阀值元件组成。感知器如图1-9所示。</p> <p align="center" style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht13.gif" alt="" width="473" height="165" style="border:0px;"></p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p align="center" style="line-height:1.5;">图1-9&nbsp;&nbsp; 感知器结构</p> <p style="line-height:1.5;">感知器的数学模型：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht4.gif" alt="" width="192" height="47" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-12)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：f[.]是阶跃函数，并且有</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht5.gif" alt="" width="340" height="93" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-13)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">θ是阀值。</p> <p style="line-height:1.5;">感知器的最大作用就是可以对输入的样本分类，故它可作分类器，感知器对输入信号的分类如下：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht6.gif" alt="" width="198" height="55" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-14)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">即是，当感知器的输出为1时，输入样本称为A类；输出为-1时，输入样本称为B类。从上可知感知器的分类边界是：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht7.gif" alt="" width="130" height="40" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-15)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">在输入样本只有两个分量X1，X2时，则有分类边界条件：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht8.gif" alt="" width="130" height="40" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-16)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">即</p> <p style="line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp; W<sub>1</sub>&nbsp;X<sub>1</sub>&nbsp;+W<sub>2</sub>&nbsp;X<sub>2</sub>&nbsp;-<span>θ=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1-17)</span></p> <p style="line-height:1.5;">也可写成</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht9.gif" alt="" width="163" height="48" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-18)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">这时的分类情况如固1—10所示。</p> <p style="line-height:1.5;">感知器的学习算法目的在于找寻恰当的权系数w＝(w1．w2，…，Wn)，使系统对一个特 定的样本x＝(xt，x2，…，xn)熊产生期望值d。当x分类为A类时，期望值d＝1；X为B类 时，d=-1。为了方便说明感知器学习算法，把阀值<span><span>θ</span>&nbsp;</span>并人权系数w中，同时，样本x也相应增加一 个分量x<sub>n+1</sub>&nbsp;。故令：</p> <p style="line-height:1.5;">W<sub>n+1</sub>&nbsp;=-<span>θ，X<sub>n+1</sub>&nbsp;=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1-19)</span></p> <p style="line-height:1.5;">则感知器的输出可表示为：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht10.gif" alt="" width="130" height="41" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-20)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">感知器学习算法步骤如下：<br> 1．对权系数w置初值<br> 对权系数w＝(W<sub>1</sub>&nbsp;．W<sub>2</sub>&nbsp;，…，W<sub>n</sub>&nbsp;，W<sub>n+1</sub>&nbsp;)的各个分量置一个较小的零随机值，但W<sub>n+1</sub>&nbsp;＝<br> —g。并记为W<sub>l</sub>&nbsp;(0)，W<sub>2</sub>&nbsp;(0)，…，W<sub>n</sub>&nbsp;(0)，同时有Wn+1(0)＝-<span><span>θ</span>&nbsp;</span>。这里W<sub>i</sub>&nbsp;(t)为t时刻从第i个<br> 输入上的权系数，i＝1，2，…，n。W<sub>n+1</sub>&nbsp;(t)为t时刻时的阀值。</p> <p align="center" style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht1.gif" alt="" width="484" height="335" style="border:0px;"></p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p align="center" style="line-height:1.5;">图1-10 感知器的分类例子</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">2．输入一样本X＝(X<sub>1</sub>&nbsp;，X<sub>2</sub>&nbsp;，…，X<sub>n+1</sub>&nbsp;)以及它的期望输出d。</p> <p style="line-height:1.5;">期望输出值d在样本的类属不同时取值不同。如果x是A类，则取d＝1,如果x是B类，则取-1。期望输出d也即是教师信号。</p> <p style="line-height:1.5;">3．计算实际输出值Y</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht2.gif" alt="" width="185" height="42" style="border:0px;"></p> <p style="line-height:1.5;">4．根据实际输出求误差e</p> <p style="line-height:1.5;">e＝d—Y(t)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1-21)</p> <p style="line-height:1.5;">5．用误差e去修改权系数</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht3.gif" alt="" width="241" height="26" style="border:0px;"></p> <p style="line-height:1.5;">i=1,2,…,n,n+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1-22)</p> <p style="line-height:1.5;">其中，η称为权重变化率，0&lt;η≤1</p> <p style="line-height:1.5;">在式(1—22)中，η的取值不能太大．如果1取值太大则会影响w<sub>i</sub>&nbsp;(t)的稳定；的取值也不能太小，太小则会使W<sub>i</sub>&nbsp;(t)的求取过程收敛速度太慢。</p> <p style="line-height:1.5;">当实际输出和期望值d相同时有：</p> <p style="line-height:1.5;">W<sub>i</sub>&nbsp;(t+1)=W<sub>i</sub>&nbsp;(t)</p> <p style="line-height:1.5;">6．转到第2点，一直执行到一切样本均稳定为止。</p> <p style="line-height:1.5;">从上面式(1—14)可知，感知器实质是一个分类器，它的这种分类是和二值逻辑相应的。因此，感知器可以用于实现逻辑函数。下面对感知器实现逻辑函数的情况作一些介绍。</p> <p style="line-height:1.5;">例：用感知器实现逻辑函数X<sub>1</sub>&nbsp;VX<sub>2</sub>&nbsp;的真值：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> 
            <table border="1" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
             <tbody>
              <tr>
               <td style="border:1px solid #C0C0C0;border-collapse:collapse;">X<sub>1</sub></td> 
               <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>0011</span></td> 
              </tr>
              <tr>
               <td style="border:1px solid #C0C0C0;border-collapse:collapse;">X<sub>2</sub></td> 
               <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>0101</span></td> 
              </tr>
              <tr>
               <td style="border:1px solid #C0C0C0;border-collapse:collapse;">X<sub>1&nbsp;</sub>V X<sub>2</sub></td> 
               <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>0111</span></td> 
              </tr>
             </tbody>
            </table></td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">以X1VX2＝1为A类，以X1VX2=0为B类，则有方程组</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht14.gif" alt="" width="195" height="130" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-23)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;">即有： 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht15.gif" alt="" width="119" height="124" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-24)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">从式(1—24)有：</p> <p style="line-height:1.5;">W<sub>1</sub>&nbsp;≥θ,W<sub>2</sub>&nbsp;≥θ</p> <p style="line-height:1.5;"><span>令 W<sub>1</sub>&nbsp;=1,W<sub>2</sub>&nbsp;=2</span></p> <p style="line-height:1.5;"><span>则有：</span>&nbsp;<span>θ</span>&nbsp;≤1</p> <p style="line-height:1.5;">取&nbsp;&nbsp;&nbsp;<span>θ=0.5</span></p> <p style="line-height:1.5;"><span>则有：X1+X2-0.5=0,分类情况如图1—11所示。</span></p> <p align="center" style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht16.gif" alt="" width="384" height="339" style="border:0px;"></p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p align="center" style="line-height:1.5;">图1-11&nbsp; 逻辑函数X<sub>1</sub>&nbsp;VX<sub>2</sub>&nbsp;的分类</p> <p style="line-height:1.5;">1．2．2 神经网络学习的梯度算法</p> <p style="line-height:1.5;">从感如器的学习算法可知，学习的目的是在于修改网络中的权系数，使到网络对于所输入的模式样本能正确分类。当学习结束时，也即神经网络能正确分类时，显然 权系数就反映了同类输人模式样本的共同特征。换句话讲，权系数就是存储了的输人模式。由于权系数是分散存在的，故神经网络自然而然就有分布存储的特点。</p> <p style="line-height:1.5;">前面的感知器的传递函数是阶跃函数，所以，它可以用作分类器。前面一节所讲的感知器学习算法因其传递函数的简单而存在局限性。</p> <p style="line-height:1.5;">感知器学习算法相当简单，并且当函数线性可分时保证收敛。但它也存在问题：即函数不是线性可分时，则求不出结果；另外，不能推广到一般前馈网络中。</p> <p style="line-height:1.5;">为了克服存在的问题，所以人们提出另一种算法——梯度算法(也即是LMS法)。</p> <p style="line-height:1.5;">为了能实现梯度算法，故把神经元的激发函数改为可微分函数，例如Sigmoid函数，非对称Sigmoid函数为f(X)=1/(1+e<sup>-x</sup>&nbsp;),对称Sigmoid函数f(X)=(1-e<sup>-x</sup>&nbsp;)/(1+e<sup>-x</sup>&nbsp;)；而不采用式(1—13)的阶跃函数。</p> <p style="line-height:1.5;">对于给定的样本集X<sub>i</sub>&nbsp;(i＝1，2，，n)，梯度法的目的是寻找权系数W<sup>*</sup>&nbsp;，使得f[W<sup>*.</sup>&nbsp;X<sub>i</sub>&nbsp;]与期望输出Yi尽可能接近。</p> <p style="line-height:1.5;">设误差e采用下式表示：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht17.gif" alt="" width="167" height="39" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-25)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中，Y<sub>i</sub>&nbsp;＝f〔W<sup>*</sup>&nbsp;·X<sub>i</sub>&nbsp;]是对应第i个样本X<sub>i</sub>&nbsp;的实时输出</p> <p style="line-height:1.5;">Y<sub>i</sub>&nbsp;是对应第i个样本X<sub>i</sub>&nbsp;的期望输出。</p> <p style="line-height:1.5;">要使误差e最小，可先求取e的梯度：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht18.gif" alt="" width="202" height="44" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-26)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：</p> </td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht19.gif" alt="" width="160" height="39" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-27)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">令&nbsp; U<sub>k</sub>&nbsp;=W<sup>.</sup>&nbsp;X<sub>k</sub>&nbsp;,则有：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht20.gif" alt="" width="271" height="71" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-28)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">即有：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht21.gif" alt="" width="266" height="40" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-29)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">最后有按负梯度方向修改权系数W的修改规则：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht22.gif" alt="" width="328" height="41" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-30)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">也可写成：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht23.gif" alt="" width="264" height="45" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-31)</td> 
          </tr>
         </tbody>
        </table><p style="line-height:1.5;">&nbsp;</p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">在上式(1—30)，式(1—31)中，<span><span>μ</span>&nbsp;</span>是权重变化率，它视情况不同而取值不同，一般取0-1之间的小数。<br> 很明显，梯度法比原来感知器的学习算法进了一大步。其关键在于两点：</p> <p style="line-height:1.5;">1．神经元的传递函数采用连续的s型函数，而不是阶跃函数；</p> <p style="line-height:1.5;">2．对权系数的修改采用误差的梯度去控制，而不是采用误差去控制。故而有更好的动态特能，即加强了收敛进程。</p> <p style="line-height:1.5;">但是梯度法对于实际学习来说，仍然是感觉太慢；所以，这种算法仍然是不理想的。</p> <p style="line-height:1.5;">1．2．3 反向传播学习的BP算法</p> <p style="line-height:1.5;">反向传播算法也称BP算法。由于这种算法在本质上是一种神经网络学习的数学模型，所以，有时也称为BP模型。</p> <p style="line-height:1.5;">BP算法是为了解决多层前向神经网络的权系数优化而提出来的；所以，BP算法也通常暗示着神经网络的拓扑结构是一种无反馈的多层前向网络。故而．有时也称无反馈多层前向网络为BP模型。</p> <p style="line-height:1.5;">在这里，并不要求过于严格去争论和区分算法和模型两者的有关异同。感知机学习算法是一种单层网络的学习算法。在多层网络中．它只能改变最后权系数。因此， 感知机学习算法不能用于多层神经网络的学习。1986年，Rumelhart提出了反向传播学习算法，即BP(backpropagation)算法。这 种算法可以对网络中各层的权系数进行修正，故适用于多层网络的学习。BP算法是目前最广泛用的神经网络学习算法之一，在自动控制中是最有用的学习算法。</p> <p style="line-height:1.5;">一、BP算法的原理</p> <p style="line-height:1.5;">BP算法是用于前馈多层网络的学习算法，前馈多层网络的结构一般如图1—12所示</p> <p align="center" style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht24.gif" alt="" width="588" height="449" style="border:0px;"></p> </td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p align="center" style="line-height:1.5;">图1-12&nbsp; 网络学习结构</p> <p style="line-height:1.5;">它含有输人层、输出层以及处于输入输出层之间的中间层。中间层有单层或多层，由于它们和外界没有直接的联系，故也称为隐层。在隐层中的神经元也称隐单元。 隐层虽然和外界不连接．但是，它们的状态则影响输入输出之间的关系。这也是说，改变隐层的权系数，可以改变整个多层神经网络的性能。</p> <p style="line-height:1.5;">设有一个m层的神经网络，并在输入层加有样本X；设第k层的i神经元的输入总和表示为U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;，输出X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;；从第k—1层的第j个神经元到第k层的第i个神经元的权系数为W<sub>ij</sub>&nbsp;各个神经元的激发函数为f，则各个变量的关系可用下面有关数学式表示：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;=f(U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;)&nbsp;&nbsp;</td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-32)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht25.gif" alt="" width="160" height="40" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-33)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">反向传播算法分二步进行，即正向传播和反向传播。这两个过程的工作简述如下。</p> <p style="line-height:1.5;">1．正向传播</p> <p style="line-height:1.5;">输入的样本从输入层经过隐单元一层一层进行处理，通过所有的隐层之后，则传向输出层；在逐层处理的过程中，每一层神经元的状态只对下一层神经元的状态产生影响。在输出层把现行输出和期望输出进行比较，如果现行输出不等于期望输出，则进入反向传播过程。</p> <p style="line-height:1.5;">2．反向传播</p> <p style="line-height:1.5;">反向传播时，把误差信号按原来正向传播的通路反向传回，并对每个隐层的各个神经元的权系数进行修改，以望误差信号趋向最小。</p> <p style="line-height:1.5;">二、BP算法的数学表达</p> <p style="line-height:1.5;">BP算法实质是求取误差函数的最小值问题。这种算法采用非线性规划中的最速下降方法，按误差函数的负梯度方向修改权系数。</p> <p style="line-height:1.5;">为了说明BP算法，首先定义误差函数e。取期望输出和实际输出之差的平方和为误差函数，则有：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht26.gif" alt="" width="176" height="40" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-34)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：Y<sub>i</sub>&nbsp;是输出单元的期望值；它也在这里用作教师信号；</p> <p style="line-height:1.5;">X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;是实际输出；因为第m层是输出层。</p> <p style="line-height:1.5;">由于BP算法按误差函数e的负梯度方向修改权系数，故权系数W<sub>ij</sub>&nbsp;的修改量Aw<sub>ij</sub>&nbsp;，和e</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht27.gif" alt="" width="138" height="48" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-35)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>也可写成</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht28.gif" alt="" width="152" height="51" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-36)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：<span>η</span>&nbsp;为学习速率，即步长。</p> <p style="line-height:1.5;">很明显，根据BP算法原则，求ae/aW<sub>ij</sub>&nbsp;最关键的。下面求ae/aW<sub>ij</sub>&nbsp;；有</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht30.gif" alt="" width="153" height="55" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-37)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>由于</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht31.gif" alt="" width="303" height="63" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-38)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>故而</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht32.gif" alt="" width="159" height="49" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-39)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>从而有</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht33.gif" alt="" width="206" height="100" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-40)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>令</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht34.gif" alt="" width="96" height="46" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-41)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>则有学习公式：</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht35.gif" alt="" width="199" height="29" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-42)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：<span>η</span>&nbsp;为学习速率，即步长，一般取0-1间的数。</p> <p style="line-height:1.5;">从上面可知，d<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;实际仍末给出明显的算法公式，下面求d<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;的计算公式。</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht36.gif" alt="" width="137" height="111" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-43)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">从式(1-32)可知在式(1-43)中，有</p> </td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht37.gif" alt="" width="125" height="54" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-44)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">为了方便进行求导，取f为连续函数。一般取非线性连续函数，例如Sigmoid函数。当取f为非对称Sigmoid函数时，有：</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht38.gif" alt="" width="224" height="48" style="border:0px;"></p> <p style="line-height:1.5;">则有：f'(U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;)=f'(U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;)(1-f(U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;(1-X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1-45)</p> <p style="line-height:1.5;">再考虑式(1—43)中的偏微分项ae／aX<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;，有两种情况需考虑的：</p> <p style="line-height:1.5;">如果k＝m，则是输出层，这时有Y<sub>i</sub>&nbsp;是输出期望值，它是常数。从式(1-34)有</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht39.gif" alt="" width="160" height="82" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-46)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>从而有&nbsp;&nbsp; d<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;=X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;(1-X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;)(X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;-Y<sub>i</sub>&nbsp;)</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-47)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>2．如果k&lt;m，则该层是隐层．这时应考虑上一层对它的作用，故有：</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht40.gif" alt="" width="221" height="51" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-48)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>从式(1—41)中，可知有：</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht41.gif" alt="" width="127" height="45" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-49)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>从式(1—33)中，可知有：</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht42.gif" alt="" width="280" height="55" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-50)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>故而有</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht43.gif" alt="" width="168" height="46" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-51)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><span>最后有：</span></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht44.gif" alt="" width="269" height="35" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-52)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">从上述过程可知：多层网络的训练方法是把一个样本加到输入层，并根据向前传播的规则：</p> <p style="line-height:1.5;">&nbsp;</p> <p style="line-height:1.5;">X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;=f(U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;)</p> <p style="line-height:1.5;">不断一层一层向输出层传递，最终在输出层可以得到输出X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;。</p> <p style="line-height:1.5;">把Xim和期望输出Yi进行比较．如果两者不等，则产生误差信号e，接着则按下面公式反向传播修改权系数：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht46.gif" alt="" width="197" height="31" style="border:0px;">&nbsp;<img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht45.gif" alt="" width="145" height="36" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-53)</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中</p> </td> 
           <td rowspan="3" style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">d<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;=X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;(1-X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;)(X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;-Y<sub>i</sub>&nbsp;)</td>
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht47.gif" alt="" width="256" height="35" style="border:0px;"></td>
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">上面公式中，求取本层d<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;时，要用到高一层的d<sub>i</sub>&nbsp;<sup>k+1</sup>&nbsp;；可见，误差函数的求取是从输出层开始，到输入层的反向传播过程。在这个过程中不断进行递归求误差。</p> <p style="line-height:1.5;">通过多个样本的反复训练，同时向误差渐渐减小的方向对权系数进行修正，以达最终消除误差。从上面公式也可以知道，如果网络的层数较多时，所用的计算量就相当可观，故而收敛速度不快。</p> <p style="line-height:1.5;">为了加快收敛速度，一般考虑上一次的权系数，并以它作为本次修正的依据之一，故而有修正公式：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht48.gif" alt="" width="355" height="28" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-54)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：<span><span>η</span>&nbsp;</span>为学习速率，即步长，<span><span>η</span>&nbsp;</span>＝0．1—0．4左右</p> <p style="line-height:1.5;"><span><span>ɑ</span>&nbsp;</span>为权系数修正常数，取0．7—0．9左右。</p> <p style="line-height:1.5;">在上面，式(1—53)也称为一般化的Delta法则。对于没有隐层的神经网络，可取</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht49.gif" alt="" width="195" height="29" style="border:0px;"></td> 
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">(1-55)</td> 
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">其中：，Y<sub>i</sub>&nbsp;为期望输出；</p> <p style="line-height:1.5;">X<sub>j</sub>&nbsp;为输出层的实际输出；</p> <p style="line-height:1.5;">X<sub>i</sub>&nbsp;为输入层的输入。</p> <p style="line-height:1.5;">这显然是一种十分简单的情况，式(1—55)也称为简单Delta法则。</p> <p style="line-height:1.5;">在实际应用中，只有一般化的Delta法则式(1—53)或式(1—54)才有意义。简单Delta法则式(1—55)只在理论推导上有用。</p> <p style="line-height:1.5;">三、BP算法的执行步骤</p> <p style="line-height:1.5;">在反向传播算法应用于前馈多层网络时，采用Sigmoid为激发面数时，可用下列步骤对网络的权系数W<sub>ij</sub>&nbsp;进行递归求取。注意对于每层有n个神经元的时候，即有i＝1，2，…，n；j＝1，2，…，n。对于第k层的第i个神经元，则有n个权系数W<sub>i1</sub>&nbsp;，W<sub>i2</sub>&nbsp;，…，W<sub>in</sub>&nbsp;，另外取多—个W<sub>in+1</sub>&nbsp;用于表示阀值<span>θ<sub>i</sub>&nbsp;</span>；并且在输入样本X时，取x＝(X<sub>1</sub>&nbsp;，X<sub>2</sub>&nbsp;，…，X<sub>n</sub>&nbsp;，1)。</p> <p style="line-height:1.5;">算法的执行的步骤如下：</p> <p style="line-height:1.5;">1．对权系数W<sub>ij</sub>&nbsp;置初值。</p> <p style="line-height:1.5;">对各层的权系数W<sub>ij</sub>&nbsp;置一个较小的非零随机数，但其中W<sub>i</sub>&nbsp;,n+1=-<span><span>θ</span>&nbsp;</span>。</p> <p style="line-height:1.5;">2．输入一个样本X＝(x<sub>l</sub>&nbsp;，x<sub>2</sub>&nbsp;，…，x<sub>n</sub>&nbsp;，1)，以及对应期望输出Y＝(Y<sub>1</sub>&nbsp;，Y<sub>2</sub>&nbsp;，…，Y<sub>n</sub>&nbsp;)。</p> <p style="line-height:1.5;">3．计算各层的输出</p> <p style="line-height:1.5;">对于第k层第i个神经元的输出X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;，有：</p> 
        <table border="0" style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;">
         <tbody>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht50.gif" alt="" width="431" height="45" style="border:0px;"></td>
          </tr>
          <tr>
           <td style="border:1px solid #C0C0C0;border-collapse:collapse;">X<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;=f(U<sub>i</sub>&nbsp;<sup>k</sup>&nbsp;)</td>
          </tr>
         </tbody>
        </table></td>
      </tr>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">4．求各层的学习误差d<sub>i</sub>&nbsp;<sup>k</sup></p> <p style="line-height:1.5;">对于输出层有k＝m，有</p> <p style="line-height:1.5;">d<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;=X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;(1-X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;)(X<sub>i</sub>&nbsp;<sup>m</sup>&nbsp;-Y<sub>i</sub>&nbsp;)</p> <p style="line-height:1.5;">对于其他各层，有</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht51.gif" alt="" width="256" height="36" style="border:0px;"></p> <p style="line-height:1.5;">5．修正权系数Wij和阀值<span><span>θ</span>&nbsp;</span><br> 用式(1—53)时有：</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht52.gif" alt="" width="292" height="31" style="border:0px;"></p> <p style="line-height:1.5;">用式(1—54)时有：</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht53.gif" alt="" width="397" height="26" style="border:0px;"></p> <p style="line-height:1.5;">其中：</p> <p style="line-height:1.5;"><img src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht54.gif" alt="" width="366" height="57" style="border:0px;"></p> <p style="line-height:1.5;">6．当求出了各层各个权系数之后，可按给定品质指标判别是否满足要求。如果满足要求，则算法结束；如果未满足要求，则返回(3)执行。</p> <p style="line-height:1.5;">这个学习过程，对于任一给定的样本X<sub>p</sub>&nbsp;＝(X<sub>p1</sub>&nbsp;，X<sub>p2</sub>&nbsp;，…X<sub>pn</sub>&nbsp;，1)和期望输出Y<sub>p</sub>&nbsp;=(Y<sub>p1</sub>&nbsp;，Y<sub>p2</sub>&nbsp;，…，Y<sub>pn</sub>&nbsp;)都要执行，直到满足所有输入输出要求为止。</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <div class="clear" style="clear:both;color:rgb(68,68,68);font-family:tahoma, arial, sans-serif;font-size:12px;"></div> 
   <div> 
    <div> 
     <font color="#444444"><span style="font-size:12px;">本文转自编程小翁博客园博客，原文链接：http://www.cnblogs.com/wengzilin/archive/2013/04/24/3041019.html，如需转载请自行联系原作者</span></font>
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
