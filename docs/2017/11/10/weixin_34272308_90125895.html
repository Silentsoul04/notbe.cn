<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>理解 QEMU/KVM 和 Ceph（1）：QEMU-KVM 和 Ceph RBD 的 缓存机制总结 « NotBeCN</title>
  <meta name="description" content="             本系列文章会总结 QEMU/KVM 和 Ceph 之间的整合：    （1）QEMU-KVM 和 Ceph RBD 的 缓存机制总结    （2）QEMU 的 RBD 块驱动（block driver）    （3）存储卷挂接和设备名称    &nbsp;    &nbsp; QEMU-...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/10/weixin_34272308_90125895.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">理解 QEMU/KVM 和 Ceph（1）：QEMU-KVM 和 Ceph RBD 的 缓存机制总结</h1>
    <p class="post-meta">Nov 10, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">本系列文章会总结 QEMU/KVM 和 Ceph 之间的整合：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.cnblogs.com/sammyliu/p/5066895.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（1）QEMU-KVM 和 Ceph RBD 的 缓存机制总结</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.cnblogs.com/sammyliu/p/5095976.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（2）QEMU 的 RBD 块驱动（block driver）</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.cnblogs.com/sammyliu/p/5325492.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（3）存储卷挂接和设备名称</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; QEMU-KVM 的缓存机制的概念很多，Linux/KVM I/O 软件栈的层次也很多，网上介绍其缓存机制的文章很多。边学习边总结。本文结合 Ceph 在 QEMU/KVM 虚机中的使用，总结一下两者结合时缓存的各种选项和原理。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1. QEMU/KVM 缓存机制</h2> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp;先以客户机（Guest OS） 中的应用写本地磁盘为例进行介绍。客户机的本地磁盘，其实是 KVM 主机上的一个镜像文件虚拟出来的，因此，客户机中的应用写其本地磁盘，其实就是写到KVM主机的本地文件内，这些文件是保存在 KVM 主机本地磁盘上。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 先来看看 I/O 协议栈的层次和各层次上的缓存情况。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.1 Linux 内核中的缓存</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 熟悉 Linux Kernel 的人都知道在内核的存储体系中主要有两种缓存，一是 Page Cache，二是 Buffer Cache。Page Cache 是在 Linux IO 栈中为文件系统服务的缓存，而 Buffer Cache 是处于更下层的 Block Device 层，由于应用大部分使用的存储数据都是基于文件系统，因此 Buffer Cache 实际上只是引用了 Page Cache 的数据，而只有在直接使用块设备跳过文件系统时，Buffer Cache 才真正掌握缓存。关于 Page Cache 和 Buffer Cache 更多的讨论参加&nbsp;<a href="http://www.quora.com/Linux-Kernel/What-is-the-major-difference-between-the-buffer-cache-and-the-page-cache" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">What is the major difference between the buffer cache and the page cache?</a>。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 这些 Cache 都由内核中专门的数据回写线程负责来刷新到块设备中，应用可以使用如 fsync, fdatasync（见下面第三部分说明）之类的系统调用来完成强制执行对某个文件数据的回写。像数据一致性要求高的应用如 MySQL 这类数据库服务通常有自己的日志用来保证事务的原子性，日志的数据被要求每次事务完成前通过 fsync 这类系统调用强制写到块设备上，否则可能在系统崩溃后造成数据的不一致。而 fsync &nbsp;的实现取决于文件系统，文件系统会将要求数据从缓存中强制写到持久设备中。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;仔细地看一下 fsync 函数（<a href="http://man7.org/linux/man-pages/man2/fsync.2.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>）：&nbsp;</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre> fsync() transfers (<span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">flushes</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>) all modified <span style="color:rgb(0,0,255);line-height:1.5;">in</span>-<span style="line-height:1.5;">core data of (i.e., modified buffer cache pages </span><span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;">) the file referred to by the file
       descriptor fd to the disk device (or other permanent storage device) so that all changed information can be retrieved even after the  system crashed or was rebooted.  This includes writing through or flushing a disk cache </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;"> present.  The call blocks until the device
       reports that the transfer has completed.  It also flushes metadata information associated with the file (see stat(</span><span style="color:rgb(128,0,128);line-height:1.5;">2</span>)).</pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;它会 flush 系统中所有的 cache，包括 Page cache 和 Disk write cache 以及 RBDCache，将数据放入持久存储。也就说说，操作系统在 flush Page cache 的时候， RBDCache 也会被 flush。&nbsp;</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.2 I/O 协议栈层次及缓存</h3> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1.2.1 组成</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201512/697113-20151222153150546-1315352688.jpg" alt="" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（<a href="http://www.ilsistemista.net/index.php/virtualization/23-kvm-storage-performance-and-cache-settings-on-red-hat-enterprise-linux-62.html?start=2" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>）</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">主要组成部分：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">Guest OS 和 HOST OS Page Cache</li>
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">Page Cache 是客户机和主机操作系统维护的用来提高存储 I/O 性能的缓存，它是 Linux 虚拟文件系统缓存的一部分，位于操作系统内存中，它是易失性的，因此，在操作系统奔溃或者系统掉电时，这些数据会消失。数据是否写入 Page cache 可以被控制。当会写入 page cache 时，当数据被写入 page cache 后，应用就认为写入完成了，随后的读操作也会从 page cache 中读取数据，这样性能会提高。可以使用 fsync 来将数据从 page cache 中拷贝到持久存储。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">在 KVM 环境中，host os 和 guest os 都有 page cache，因此，最好是能绕过一个来提高性能。</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:none;"> 
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">如果 guest os 中的应用使用 direct I/O 方式，guest os 中 page cache 会被绕过。</li> 
      <li style="list-style-type:disc;">如果 guest os 使用 no cache 方式，host os 的 page cache 会被绕过。</li> 
     </ul></li>
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;">该缓存的特点是读的时候，操作系统先检查页缓存里面是否有需要的数据，如果没有就从设备读取，返回给用户的同时，加到缓存一份;写的时候，直接写到缓存去，再由后台的进程定期涮到磁盘去。这样的机制看起来非常的好，在实践中也效果很好。</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">考虑到其易失性，需要考虑它的大小，特别是在 KVM 主机上。现在 KVM 主机的内存可以很大。其内存越大， 那么在 Page cache 中还没有 flush 到磁盘（虚拟或者物理的）的脏数据就越多，其丢失的后果就越严重。默认的话，Linux 2.6.32 在脏数据达到内存的 10% 的时候会自动开始 flush。</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">Guest Disk （virtual disk device）：客户机虚机磁盘设备</li> 
    <li style="list-style-type:disc;">QEMU image：QEMU 镜像文件</li> 
    <li style="list-style-type:disc;">Physical disk cache</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">这是磁盘的 write cache，它会提高数据到存储的写性能。写到 disk write cache 后，写操作会被认为完成了，即使数据还没真正被写入物理磁盘。这样，如果 disk write cache 没有备份电池的话，断电将导致尚未写入物理磁盘的数据丢失。要强制数据被写入磁盘，应用可以通过操作系统可以发出 fsync 命令。因此，disk write cache 会提到写I/O 性能，但是，需要确保应用和存储栈会将数据写入磁盘中。如果 disk write cache 被关闭，那么写性能将下降，但是断电时数据丢失将会避免。</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">Physical disk platter：物理磁盘</li>
   </ul>
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1.2.2 GUEST 应用读 I/O 过程</h4> 
   <ol style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <li style="list-style-type:decimal;">GUEST OS 中的一个应用发出 read request。</li> 
    <li style="list-style-type:decimal;">OS 在 guest page cache 中检查。如果有（hit），则直接将 data 从 guest page cache 拷贝到 application space。</li> 
    <li style="list-style-type:decimal;">如果没有（miss），请求被转到 guest virtual disk。该 request 会被 QEMU 转化为对 host 上镜像文件的 read request。</li> 
    <li style="list-style-type:decimal;">Host OS 在 HOST Page cache 中检查。如果 hit，则通过 QEMU 将 data 从 host page cache 传到 guest page cache，再拷贝到 application space。</li> 
    <li style="list-style-type:decimal;">如果没有（miss），则启动 disk （或者 network）I/O 请求去从实际文件系统中读取数据，读到后再写入 host page cache，在写入 guest page cache，再到 GUEST OS application space。</li> 
   </ol>
   <div class="page" title="Page 2" style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div class="layoutArea"> 
     <div class="column"> 
      <p style="line-height:1.5;">从该过程可以看出：</p> 
      <ul style="list-style:none;font-size:12px;">
       <li style="list-style-type:disc;">两重 page cache 会对数据重复保存，这会带来内存浪费</li> 
       <li style="list-style-type:disc;">两重 page cache 也会提高 hit ratio，因为往往 guest page cache 比 host page cache 会小很多</li> 
      </ul>
      <p style="line-height:1.5;">QEMU-KVM Linux 支持关闭和开启任一一个 Page cache，也就是说有四种组合模式，分别会带来不同的效果。在各种I/O的过程中，最好是绕过一个或者两个 Page cache。</p> 
      <h4 style="font-size:14px;">1.2.3 Guest 应用 写 I/O 过程</h4> 
      <p style="line-height:1.5;">写 I/O 过程比较复杂，本文其余部分会详细阐述。从 1.3 表格总结，基本上</p> 
      <ul style="list-style:none;font-size:12px;">
       <li style="list-style-type:disc;">writeback/unsafe：app ----qemu write----&gt; host page cache &nbsp;--- os flush ---&gt; disk cache --- hw flush ---&gt; disk</li> 
       <li style="list-style-type:disc;">none: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app &nbsp;--- qemu write----&gt; disk write cache &nbsp;---- hw flush ---&gt; disk</li> 
       <li style="list-style-type:disc;">writethrough: &nbsp; &nbsp; &nbsp; &nbsp;app --- qemu write----&gt; host page cache, disk</li> 
       <li style="list-style-type:disc;">directsync: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;app --- qemu write ---&gt; disk</li> 
      </ul>
      <p style="line-height:1.5;">关于 guest os page cache，看起来它主要是作为读缓存，而对于写，没有一种模式是以写入它作为写入结束标志的。</p> 
     </div> 
    </div> 
   </div> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.3 客户机磁盘（drive）的缓存模式</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">在 libvirt xml 中使用 'cache' 参数来指定driver的缓存模式，比如：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>&lt;disk type=<span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">file</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span> device=<span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">disk</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span>&gt;  <span style="color:rgb(0,0,255);line-height:1.5;">#对于 type，'file' 表示是 host 上的文件，'network' 表示通过网络访问，比如Ceph</span>
          &lt;driver name=<span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">qemu</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span> type=<span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">raw</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span> cache=<span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">writeback</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span>/&gt; </pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">QEMU/KVM 支持如下这些缓存模式作为 ‘cache’ 的可选值：</p> 
   <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <tbody>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">缓存模式</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">说明</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">GUEST OS Page cache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Host OS Page cache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Disk write cache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">被认为数据写入成功 &nbsp; &nbsp;</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">数据安全性</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">cache = unsafe</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">跟 writeback 类似，只是会忽略 GUEST OS 的 flush 操作，完全由 HOST OS 控制 flush</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
       <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;width:71px;">
        <tbody>
         <tr>
          <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="line-height:1.5;color:rgb(255,0,0);">Bypass（？不确定）</span><br><br></td>
         </tr>
        </tbody>
       </table></td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Host page cache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">最不安全，只有在特定的场合才会使用</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Cache=writeback</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">I/O 写到 HOST OS Page cache 就算成功，支持 GUEST OS flush 操作。<br> 效率最快，但是也最不安全</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="line-height:1.5;color:rgb(255,0,0);">Bypass</span>（<span style="line-height:1.5;color:rgb(255,0,0);">？不确定</span>）</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Host Page Cache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">不安全. （only for temporary data where potential data loss is not a concern&nbsp;&nbsp;）</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Cache=none</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">客户机的I/O 不会被缓存到 page cache，而是会放在 disk write cache。</p> <p style="line-height:1.5;">这种模式对写效率比较好，因为是写到 disk cache，但是读效率不高，因为没有放到 page cache。因此，可以在大 I/O 写需求时使用这种模式。</p> <p style="line-height:1.5;"><br> 综合考虑下，基本上这是最优模式，而且是支持实时迁移的唯一模式</p> <p style="line-height:1.5;">也就是常说的 O_DIRECT I/O 模式</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;Bypass</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;Bypass</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Disk write cache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">不安全. 如果要保证安全的话，需要disk cache备份电池或者电容，或者使用 fync</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Cache=writethrough</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">I/O 数据会被同步写入 Host Page cache 和 disk。相当于每写一次，就会 flush 一次，将 page cache 中的数据写入持久存储。</p> <p style="line-height:1.5;">这种模式，会将数据放入 Page cache，因此便于将来的读；而绕过 disk write cache，会导致写效率较低。因此，这是较慢的模式，适合于写I/O不大，但是读I/O相对较大的情况，最好是用在小规模的有低 I/O 需求客户机的场景中。<br> 当不需要支持实时迁移时，如果不支持writeback 则可用。</p> <p style="line-height:1.5;">也就是常说的 O_SYNC I/O 模式</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">E</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Bypass</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">disk</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">安全</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Cache=DirectSync</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">&nbsp;跟 writethrough 类似，只是不写入 HOST OS Page cache</p> <p style="line-height:1.5;">也就是常说的 O_DIRECT &amp; O_SYNC 模式</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Bypass</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Bypass</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Bypass</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">disk</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">同 ”O_SYNC“，对一些数据库应用来说，往往会直接使用这种模式，直接将数据写到数据盘</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">cache=default</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">使用各种driver 类型的默认cache 模式</p> <p style="line-height:1.5;">qcow2：默认 writeback</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
     </tr>
    </tbody>
   </table>
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">性能： &nbsp;writeback = unsafe &gt; none &gt; writethrough = directsync</li> 
    <li style="list-style-type:disc;">安全性: writethrough = directsync &gt; none &gt; writeback &gt; unsafe</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">看看性能比较：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201512/697113-20151222160457452-1645729610.jpg" alt="" width="515" height="320" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">基本结论：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">各种模式的性能差别非常大</li> 
    <li style="list-style-type:disc;">对于数据库这样的应用，使用 directsync 模式，数据直接写入物理磁盘才算成功</li> 
    <li style="list-style-type:disc;">对于重要的数据或者小 I/O 的场景，使用 writethrough</li> 
    <li style="list-style-type:disc;">对于一般的应用，或者大 I/O 场景，使用 none。这个可以说是大部分情况下的最优选项。</li> 
    <li style="list-style-type:disc;">对于丢失了也无所谓的数据，可以使用 writeback</li> 
   </ul>
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.4 KVM Write barrier</h3> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1.4.1 什么是 KVM write barrier</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 上面的基本结论中，writethrough 是最安全的，但是效率也是最低的。它将数据放在 HOST Page Cache 中，一方面来支持读缓存，另一方面，在每一个 write 操作后，都执行 fsync，确保数据被写入物理存储。只有在数据被写入磁盘后，写操作才会标记为成功。这种模式下，客户机的 virtual storage adapter 会被通知不会使用 writeback 模式，因此，它不会主动发送 fsync 命令，因为它是重复的，不需要的。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 那还有没有什么办法使它在保持数据可靠性的同时，使它的效率提高一些呢？答案是 KVM Write barrier 功能。新的 KVM 版本中，启用了&nbsp;“barrier-passing” 功能，它能保证在不管是用什么缓存模式下，将客户机上应用写入的数据 100% 写入持久存储。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 好吧，这真是个神器。。那它是如何实现的呢？以 fio 工具为例，在支持 write barrier 的客户机操作系统上，在使用 direct 和 sync 参数的情况下，会使用这种模式。它在写入部分数据以后，会使得操作系统发出一个 fdatasync&nbsp;命令，这样 QEMU-KVM 就会将缓存中的数据 flush 到物理磁盘上。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">基本过程：</p> 
   <ol style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <li style="list-style-type:decimal;">在一个会话中写入数据</li> 
    <li style="list-style-type:decimal;">发出 barrier request</li> 
    <li style="list-style-type:decimal;">会话中的所有数据被 flush 到物理磁盘</li> 
    <li style="list-style-type:decimal;">继续下一个会话</li> 
   </ol>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;看起来和 writethrough 差不多是吧。但是它的效率比 writethrough 高。两者的区别在于，writethrough 是每次 write 都会发 fsync，而 barrier-passing 是在若干个写操作或者一个会话之后发&nbsp;fdatasync 命令，因此其效率更高。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 也可以看到，使用它是有条件的：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">KVM 版本较新</li> 
    <li style="list-style-type:disc;">客户机操作系统支持：在较新的 Linux 发行版中都会支持</li> 
    <li style="list-style-type:disc;">客户机中的文件系统支持 barrier （ext4 支持并默认开启；ext3 支持但默认不开启），而且整个 I/O 协议栈中的各个层次都支持 flush 操作</li> 
    <li style="list-style-type:disc;">应用需要在需要的时候发出 flush 指令。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 也可以看到，应用在需要的时候发出 flush 指令是关键。一方面，Cache 都由内核中专门的数据回写线程负责来刷新到块设备中；另一方面，应用可以使用如 fsync(2), fdatasync(2) 之类的系统调用来完成强制执行对某个文件数据的回写。像数据一致性要求高的应用如 MySQL 这类数据库服务通常有自己的日志用来保证事务的原子性，日志的数据被要求每次事务完成前通过 fsync(2) 这类系统调用强制写到块设备上，否则可能在系统崩溃后造成数据的不一致。而 fsync(2) 的实现取决于文件系统，文件系统会将要求数据从缓存中强制写到持久设备中。类似地，支持 librbd 的QEMU 在适当的时候也会发出 flush 指令。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 以 fio 为例，设置有两个参数时，会有 flush 指令发出：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>fsync=<span style="color:rgb(0,0,255);line-height:1.5;">int</span><span style="line-height:1.5;">
How many I</span>/Os to perform before issuing an fsync(<span style="color:rgb(128,0,128);line-height:1.5;">2</span>) of dirty data. If <span style="color:rgb(128,0,128);line-height:1.5;">0</span>, don<span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">t sync. Default: 0.</span>
fdatasync=<span style="color:rgb(0,0,255);line-height:1.5;">int</span><span style="line-height:1.5;">
Like fsync, but uses fdatasync(</span><span style="color:rgb(128,0,128);line-height:1.5;">2</span>) instead to only sync the data parts of the file. Default: <span style="color:rgb(128,0,128);line-height:1.5;">0</span>.</pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">需要注意的是，频繁的发送（int 值设置的比较小），会影响 IOPS 的值。为了测得最大的IOPS，可以在测试准备阶段发一个sync，然后再收集阶段就不发sync，完全由 RBDCache 自己的机制去 flush；或者需要的话，把 int 值设得比较大，来模拟一些应用场景。</p> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1.4.2 KVM write barrier 和 KVM 缓存模式的结合</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">考虑到 KVM write barrier 的原理和 KVM 各种缓存模式的原理，显而易见，writeback + barrier 的方式下，可以实现&nbsp;<span style="line-height:1.5;text-decoration:underline;">效率最高+数据安全</span>&nbsp;这种最优效果。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201512/697113-20151222161817171-824534877.jpg" alt="" width="580" height="346" style="border:0px;"></p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.5 小结</h3> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">在客户机可以启用&nbsp;write barrier 时，使用&nbsp;write-back or nocache + barrier，然后应用会在合适的时候发出 flush 指令。</li> 
    <li style="list-style-type:disc;">在客户机不支持 write barrier 时，如果对读敏感应用，使用&nbsp;write-back （可以使用 pagecache）；对需要同步数据的应用，使用 noncache；最安全的情况下，使用 writethrough。</li> 
    <li style="list-style-type:disc;"> <span style="line-height:1.5;">对于一些能过备用电池或者别的技术（比如设备上有电容等）保证了在掉电情况下数据也不会丢失的情况下，barrier 最好被禁止。比如企业存储的Adatper，或者 SSD。</span>
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">”If the device does not need cache flushes it should not report requiring flushes, in which case nobarrier will be a noop.“</li> 
      <li style="list-style-type:disc;">”With a RAID controller with battery backed controller cache and cache in write back mode, you should turn off barriers - they are unnecessary in this case, and if the controller honors the cache flushes, it will be harmful to performance. But then you *must* disable the individual hard disk write cache in order to ensure to keep the filesystem intact after a power failure.“。</li> 
      <li style="list-style-type:disc;">一个例子是，Ceph OSD 节点上的 SSD 分区，一般都使用 ”nobarrier“参数 来禁用 barrier。&nbsp;</li> 
     </ul></li> 
   </ul>
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.6 Linux page cache 补充</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">Linux 系统中被用于 Page cache 的主内存可以通过 free -m 命令来查看：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>root@controller:~# free -<span style="line-height:1.5;">m
             total       used       free     shared    buffers     <span style="color:rgb(0,0,255);line-height:1.5;">cached</span>
Mem:          </span><span style="color:rgb(128,0,128);line-height:1.5;">4867</span>       <span style="color:rgb(128,0,128);line-height:1.5;">3586</span>       <span style="color:rgb(128,0,128);line-height:1.5;">1280</span>          <span style="color:rgb(128,0,128);line-height:1.5;">0</span>        <span style="color:rgb(128,0,128);line-height:1.5;">193</span>        <span style="color:rgb(0,0,255);line-height:1.5;">557</span>
-/+ buffers/cache:       <span style="color:rgb(128,0,128);line-height:1.5;">2834</span>       <span style="color:rgb(128,0,128);line-height:1.5;">2032</span><span style="line-height:1.5;">
Swap:         </span><span style="color:rgb(128,0,128);line-height:1.5;">2022</span>          <span style="color:rgb(128,0,128);line-height:1.5;">0</span>       <span style="color:rgb(128,0,128);line-height:1.5;">2022</span></pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">写 Page cache：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（1）当数据被写时，通常情况下，它首先会被写入 page cache，被当作一个 &nbsp;dirty page 来管理。’dirty‘ 的意思是，数据还保存在 page cache 中，还需要被写入底下的持久存储。dirty pages 中的内容会被系统周期性地、以及使用诸如 sync 或者 fsync 的系统调用来写入持久存储。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>root@controller:~# cat /proc/meminfo |<span style="line-height:1.5;"> grep Dirty
Dirty:               </span><span style="color:rgb(128,0,128);line-height:1.5;">148</span><span style="line-height:1.5;"> kB
root@controller:</span>~<span style="line-height:1.5;"># sync
root@controller:</span>~# cat /proc/meminfo |<span style="line-height:1.5;"> grep Dirty
Dirty:                 </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span> kB</pre>
   </div> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">sync</span> writes any data buffered <span style="color:rgb(0,0,255);line-height:1.5;">in</span> memory <span style="color:rgb(0,0,255);line-height:1.5;">out</span> to disk. This can include (but <span style="color:rgb(0,0,255);line-height:1.5;">is</span> not limited to) modified superblocks, modified inodes, and delayed reads and writes. </pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（2）当数据被从持久性存储读出时，它也会被写入 page cache。因此，当连续两次读时，第二次会比第一次快，因为第一次读后把数据写入了 page cache，第二次就直接从这里读了。完整过程如下：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201512/697113-20151228132028026-708700731.jpg" alt="" width="609" height="350" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">需要注意的是，需要结合应用的需要，来决定是否在写数据时一并写入 page cache。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2. QEMU+RBDCache</h2> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;&nbsp;QEMU 能够支持将主机的一个块设备映射给客户机，但是从 0.15 版本开始，就不再需要先将一个 Ceph volume 映射到主机再给客户机了。现在，QEMU 可以直接通过 librbd 来象 virtual block device 一样访问 Ceph image。这既提高了性能，也使得可以使用 RBDCache 了。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; RBDCache 是 Ceph 的块存储接口实现库 Librbd 用来在客户端侧缓存数据的目的，它主要提供了<span style="line-height:1.5;text-decoration:underline;">读数据</span>缓存，<span style="line-height:1.5;text-decoration:underline;">写数据汇聚写回</span>的目的，用来提高顺序读写的性能。需要说明的是，Ceph 既支持以内核模块的方式来实现对 Linux 动态增加块设备，也支持以 QEMU Block Driver 的形式给使用 QEMU 虚拟机增加虚拟块设备，而且两者使用不同的库，前者是内核模块的形式，后者是普通的用户态库，本文讨论的 RBDCache 针对后者，前者使用内核的 Page Cache 达到目的。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.1 librbd I/O 协议栈</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201512/697113-20151222162430671-964971698.jpg" alt="" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 从这个栈可以看出来，RBDCache 类似于磁盘的 write cache。它应该有三个功能：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">写缓存：开启时，librdb 将数据写入 RBDCache，然后在被 flush 到 Ceph 集群，其效果就是多个写操作被合并，但是有一定的时间延迟。</li> 
    <li style="list-style-type:disc;">读缓存：数据会在缓存中被保留一段时间，这期间的 librbd 读数据的话，会直接从缓存中读取，提高读效率。</li> 
    <li style="list-style-type:disc;">合并写操作：对同一个 OSD 上的多个写操作，应该会合并为一个大的写操作，提高写入效率。 ”Due to several objects map to the same physical disks, the original logical sequential IO streams mix together (green, orange, blue and read blocks). &nbsp;<a href="https://software.intel.com/en-us/blogs/2013/11/20/measure-ceph-rbd-performance-in-a-quantitative-way-part-ii" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>“</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 因此，需要注意的是，理论上，RBDCache 对顺序写的效率提升应该非常有帮助，而对随机写的效率提升应该没那么大，其原因应该是后者合并写操作的效率没前者高（也就是能够合并的写操作的百分比比较少）。具体效果待测试。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 在使用 QEMU 实现的 VM 来使用 RBD 块设备，那么 Linux Kernel 中的块设备驱动是 virtio_blk，它会对块设备各种请求封装成一个消息通过 virtio 框架提供的队列发送到 QEMU 的 IO 线程，QEMU 收到请求后会转给相应的 QEMU Block Driver 来完成请求。当 QEMU Block Driver 是 RBD 时，缓存就会交给 Librbd 自身去维护，也就是一直所说的 RBDCache；用户在使用本地文件或者 Host 提供的 LVM 分区时，跟 RBDCache 同样性质的缓存包括了 Guest Cache 和 Host Page Cache，见本文第一部分的描述。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.2 RBDCache 的原理</h3> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2.2.1 RBDCache 的配置</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 在 ceph.conf 中，设置&nbsp;<span class="pre" style="line-height:1.5;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = true 即可以启用 RBDCache。它有以下几个主要的配置参数：</span></span></p> 
   <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <tbody>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">配置项</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">含义</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">默认值</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache</span> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">是否启用 RBDCache</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">0.87 版本开始：true，启用</p> <p style="line-height:1.5;">0.87 版本之前：false，禁用</p> </td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd_cache_size</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">Librbd 能使用的最大缓存大小</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">32 MiB</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd_cache_max_dirty</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">缓存中允许脏数据的最大值，用来控制回写大小，不能超过 rbd_cache_size。超过的话，应用的写入应该会被阻塞，</p> <p style="line-height:1.5;">这时候IOPS就会下降</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">24 MiB</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd_cache_target_dirty</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">开始执行回写过程的脏数据大小，不能超过 rbd_cache_max_dirty</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">16MiB</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd_cache_max_dirty_age</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">缓存中单个脏数据最大的存在时间，避免可能的脏数据因为迟迟未达到开始回写的要求而长时间存在</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">1 秒</td> 
     </tr>
    </tbody>
   </table>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 可见，默认情况下：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">在主机操作系统内内存内会分配 32MiB 的空间用于 RBD 做缓存使用</li> 
    <li style="list-style-type:disc;">允许最大的脏数据大小为 24MiB，超过的话，可能会阻止继续写入（需要确认）</li> 
    <li style="list-style-type:disc;">在脏数据总共有 16MiB 时，开始回写过程，将数据写入Ceph集群</li> 
    <li style="list-style-type:disc;">在单个脏数据（目前在 Librbd 用户态库中主要以 Object Buffer Extent 为基本单位进行缓存，这里的粒度应该是&nbsp;Object Buffer Extent）存在超过 1 秒时，对它启用回写</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 也能看出，RBDCache 从空间和时间来方面，在效率和数据有效性之间做平衡。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">几个重要的注意事项：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（1）QEMU 和 ceph 配置项的相互覆盖问题</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a id="yui_3_10_3_1_1450853854963_285" href="http://ceph.com/docs/master/rbd/qemu-rbd/#qemu-cache-options" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://ceph.com/docs/master/rbd/qemu-rbd/#qemu-cache-options</a></p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">在没有在 Ceph 配置文件中显式配置 RBD Cache 的参数（尽管Ceph 支持配置项的默认值，但是，看起来，是否在Ceph配置文件中写还是不写，会有不同的效果。。真绕啊。。）时，QEMU 的 cache 配置会覆盖 Ceph 的默认配置。 
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">qemu driver 'writeback' 相当于&nbsp;<span style="line-height:1.5;font-family:'Courier New';">rbd_cache&nbsp;</span><span class="o" style="line-height:1.5;font-family:'Courier New';">=&nbsp;<span class="n" style="line-height:1.5;">true</span></span> </li> 
      <li style="list-style-type:disc;"><span class="o" style="line-height:1.5;font-family:'Courier New';"><span class="n" style="line-height:1.5;">qemu driver ‘writethrough’ 相当于 ‘rbd_cache = true,rbd_cache_max_dirty = 0’</span></span></li> 
      <li style="list-style-type:disc;"><span class="o" style="line-height:1.5;font-family:'Courier New';"><span class="n" style="line-height:1.5;">qemu driver ‘none’ 相当于&nbsp;rbd_cache&nbsp;<span class="o" style="line-height:1.5;">= false</span></span></span></li> 
      <li style="list-style-type:disc;">一个典型场景是，在 nova.conf 中配置了 ”cache=writeback”，而没有在客户端节点上配置 Ceph 配置文件，这时候将直接打开 RBDCache 并使用 writeback 模式，而不是先 writethrough 后 writeback。</li> 
     </ul></li> 
    <li style="list-style-type:disc;">在在 Ceph 配置文件中显式配置了缓存模式的时候，Ceph 的 cache 配置会覆盖 QEMU 的 cache 配置。</li> 
    <li style="list-style-type:disc;">如果在 QEMU 的命令行中使用了 cache 配置，则它会覆盖 Ceph 配置文件中的配置。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">优先级：QEMU 命令行中的配置 &gt; Ceph 文件中的显式配置 &gt; QEMU 配置 &gt; Ceph 默认配置</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">（2）在启用 RBDCache 时，必须在 QEMU 中配置&nbsp;”cache=writeback”，否则可能会导致数据丢失。在使用文件系统的情况下，这可能会导致文件系统损坏。</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">Important<span class="foldable-quoted" style="line-height:1.5;">&nbsp;</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">If you set rbd_cache=true, you must set cache=writeback or risk data loss. Without cache=writeback, QEMU will not send flush requests to librbd. If QEMU exits uncleanly in this configuration, filesystems on top of rbd can be corrupted.</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;"><a href="http://ceph.com/docs/master/rbd/qemu-rbd/#running-qemu-with-rbd" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://ceph.com/docs/master/rbd/qemu-rbd/#running-qemu-with-rbd</a></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">（3）使用 raw 格式的 Ceph 卷设备 “&nbsp;&lt;driver name='qemu' type='raw' cache='writeback'/&gt;“</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;"><a href="http://ceph.com/docs/master/rbd/qemu-rbd/#creating-images-with-qemu" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://ceph.com/docs/master/rbd/qemu-rbd/#creating-images-with-qemu</a></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">理论上，你可以使用其他 QEMU 支持的格式比如 qcow2 或者 vmdk，但是它们会带来 overhead<br><span class="foldable-quoted" style="line-height:1.5;">The raw data format is really the only sensible format option to use with RBD. Technically, you could use other QEMU-supported formats (such as qcow2 or vmdk), but doing so would add additional overhead, and would also render the volume unsafe for virtual machine live migration when caching (see below) is enabled.</span></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">（4）在新版本的 Ceph 中（将来的版本，尚不知版本号），Ceph 配置项 rbd cache 将会被删除，RBDCache 是否开启将由 QEMU 配置项决定。</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">也就是说，如果 QEMU 中设置 cache 为 ‘none’ 的话， RBDCache 将不会被使用；设置为 ‘writeback’ 的话，RBDCache 将会被启用。参考链接：<a href="https://forum.proxmox.com/threads/ceph-client-rbd-cache-true-override-qemu-cache-none-writeback.22459/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">ceph : [client] rbd cache = true override qemu cache=none|writeback</a>。</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span class="foldable-quoted" style="line-height:1.5;">（5）对 Nova 来说，不设置 disk_cachemode 值的话，默认的 driver 的 cache 模式是 ‘none’。但是，在不支持 ‘none’ 模式的存储系统上，会改为使用 ‘writethrough’ 模式。（<a href="https://review.openstack.org/#/c/5606/5/nova/virt/libvirt/connection.py" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>）</span></p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="line-height:1.5;">def disk_cachemode(self):
        </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> self._disk_cachemode <span style="color:rgb(0,0,255);line-height:1.5;">is</span><span style="line-height:1.5;"> None:
            # We prefer </span><span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">none</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span> <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> consistent performance, host crash
            # safety </span>&amp;<span style="line-height:1.5;"> migration correctness by avoiding host page cache.
            # Some filesystems (eg GlusterFS via FUSE) don</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">t support</span>
            # O_DIRECT though. For those we fallback to <span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="color:rgb(128,0,0);line-height:1.5;">writethrough</span><span style="color:rgb(128,0,0);line-height:1.5;">'</span><span style="line-height:1.5;">
            # which gives host crash safety, and </span><span style="color:rgb(0,0,255);line-height:1.5;">is</span> safe <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> migration
            # provided the filesystem </span><span style="color:rgb(0,0,255);line-height:1.5;">is</span><span style="line-height:1.5;"> cache coherant (cluster filesystems
            # typically are, but things like NFS are not).
            self._disk_cachemode </span>= <span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">none</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>
            <span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;"> not self._supports_direct_io(FLAGS.instances_path):
                self._disk_cachemode </span>= <span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">writethrough</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">return</span> self._disk_cachemode</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2.2.2 缓存中的数据被 flush 到 Ceph cluster</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 有两种类型的 flush：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">RBD 主动的，在 RBDCache 规定的空间或者数据保存时间达到阈值之后，会触发回写</li> 
    <li style="list-style-type:disc;"> <span style="line-height:1.5;">RBD 被动的，librbd 的 flush 接口被调用，全部缓存中的数据也会被回写。又可以细分为两种类型：</span>
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">QEMU 在合适的时候会自动发出 flush：QEMU 作为最终使用 Librbd 中 RBDCache 的用户，它在 VM 关闭、QEMU 支持的热迁移操作或者 RBD 块设备卸载时都会调用 QEMU Block Driver 的 Flush 接口，确保数据不会被丢失。因此，此时，需要用户在使用了开启 RBDCache 的 RBD 块设备 VM 时需要给 QEMU 传入 “cache=writeback” 确保 QEMU 知晓有缓存的存在，不然 QEMU 会认为后端并没有缓存而选择将 Flush Request 忽略。</li> 
      <li style="list-style-type:disc;">应用发出 flush，比如 fio，可以设置 fdatasync 为一个大于零的整数，从而在若干次写操作后执行fdatasync。（&nbsp;fdatasync=int&nbsp;Like fsync, but uses fdatasync(2) instead to only sync the data parts of the file. Default: 0“</li> 
     </ul></li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 关于第二种 flush，这里的一个问题是，什么时候会有这种主动 flush 指定发出。有文章说，”QEMU 作为最终使用 Librbd 中 RBDCache 的用户，它在 VM 关闭、QEMU 支持的热迁移操作或者 RBD 块设备卸载时都会调用 QEMU Block Driver 的 Flush 接口“。同时，一些对数据的安全性敏感的应用也可以通过操作系统在需要的时候发出 flush 指定，比如一些数据库系统。你可以使用 fio 工具的&nbsp;fdatasync 参数在指定的写入操作后发出&nbsp;fdatasync 指令。具体效果还待测试。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; librados 的 flush API：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>CEPH_RADOS_API <span style="color:rgb(0,0,255);line-height:1.5;">int</span><span style="line-height:1.5;"> rados_aio_flush(rados_ioctx_t io)
Block until all pending writes </span><span style="color:rgb(0,0,255);line-height:1.5;">in</span><span style="line-height:1.5;"> an io context are safe

This </span><span style="color:rgb(0,0,255);line-height:1.5;">is</span> not equivalent to calling rados_aio_wait_for_safe() on all write completions, since <span style="color:rgb(0,0,255);line-height:1.5;">this</span> waits <span style="color:rgb(0,0,255);line-height:1.5;">for</span> the associated callbacks to complete <span style="color:rgb(0,0,255);line-height:1.5;">as</span><span style="line-height:1.5;"> well.
</span><span style="line-height:1.5;">
Parameters
io </span>-<span style="line-height:1.5;">
the context to flush</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 下面是一个 Linux 系统上文件操作的伪代码（<a href="http://www.orczhou.com/index.php/2009/08/innodb_flush_method-file-io/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>）。可见，该程序知道只有在&nbsp;fdatasync 执行成功后，数据才算写入成功。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>#include   <span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">stdlib.h</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>           <span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;"> for exit </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><span style="line-height:1.5;">
#include   </span><span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">unistd.h</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>           <span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;"> for write fdatasync</span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><span style="line-height:1.5;">
#include    </span><span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">fcntl.h</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>           <span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;"> for open  </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,0,255);line-height:1.5;">int</span> main(<span style="color:rgb(0,0,255);line-height:1.5;">void</span><span style="line-height:1.5;">){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">int</span><span style="line-height:1.5;"> fd;
    </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span>((fd=open(<span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">/home/zzx/test.file</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>,O_WRONLY|O_APPEND|O_DSYNC))&lt;<span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">){
        exit(</span><span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">);
        }
    </span><span style="color:rgb(0,0,255);line-height:1.5;">char</span> buff[]=<span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">abcdef</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(write(fd,buff,<span style="color:rgb(128,0,128);line-height:1.5;">6</span>)!= <span style="color:rgb(128,0,128);line-height:1.5;">6</span><span style="line-height:1.5;">){
        exit(</span><span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;">);
    }
    </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span>(fdatasync(fd)==-<span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">){
        exit(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span><span style="line-height:1.5;">);
    }
    exit(</span><span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">);
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2.2.3 RBDCache 中数据的易失性和 librbd&nbsp;rbd_cache_writethrough_until_flush 配置项</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 因为 RBDCache 是利用内存来缓存数据，因此数据也是易失性的。那么，最安全的是，设置&nbsp;rbd_cache_max_dirty = 0，就是不缓存数据，相当于 writethrough 的效果。很明显，这没有实现 RBDCache 的目的。&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 另外，Ceph 还提供&nbsp;rbd_cache_writethrough_until_flush 选项，它使得 RBDCache 在收到第一个 flush 指令之前，使用 writethrough 模式，透传数据，避免数据丢失；在收到第一个 flush 指令后，开始 writeback 模式，通过 KVM barrier 功能来保证数据的可靠性。&nbsp; &nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 该选项的含义：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="line-height:1.5;">This option enables the cache for reads but does writethrough until we observe a FLUSH command come through, which implies that the guest OS is issuing barriers.  This doesn't guarantee they are doing it properly, of course, but it means they are at least trying.  Once we see a flush, we infer that writeback is safe.</span></pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 该选项的默认值到底是 true 还是 false 比较坑爹：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">ceph/librbd 在 0.80 版本中添加该选项，默认值是 false （<a href="https://github.com/ceph/ceph/blob/v0.80.10/src/common/config_opts.h" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">代码</a>）</li> 
    <li style="list-style-type:disc;">ceph/librbd 在 0.87 版本中将默认值修改为 true （<a href="https://github.com/ceph/ceph/blob/v0.87/src/common/config_opts.h" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">代码</a>）</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 因此，你在使用不同版本的 librbd 情况下使用默认配置时，其 IOPS 性能是有很大的区别的：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">0.80 版本中，一直是 writeback，IOPS 会从头就很好；</li> 
    <li style="list-style-type:disc;">0.87 版本中，开始是 writethrough，在收到第一个操作系统发来的 flush 后，转为 writeback，因此，IOPS 是先差后好。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 在实现上，</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（1）收到第一个flush 之前，相当于&nbsp;rbd_cache_max_dirty 被设置为0 了：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>uint64_t init_max_dirty = cct-&gt;_conf-&gt;<span style="line-height:1.5;">rbd_cache_max_dirty;
      </span><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (cct-&gt;_conf-&gt;<span style="line-height:1.5;">rbd_cache_writethrough_until_flush)
    init_max_dirty </span>= <span style="color:rgb(128,0,128);line-height:1.5;">0</span>;</pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（2）收到第一个 flush 之后，就转为 writeback 了</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">if</span> (object_cacher &amp;&amp; cct-&gt;_conf-&gt;<span style="line-height:1.5;">rbd_cache_writethrough_until_flush) {
      md_lock.get_read();
      </span><span style="color:rgb(0,0,255);line-height:1.5;">bool</span> flushed_before =<span style="line-height:1.5;"> flush_encountered;
      md_lock.put_read();
      uint64_t max_dirty </span>= cct-&gt;_conf-&gt;rbd_cache_max_dirty;</pre>
   </div> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.3 小结</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 各种配置下的Ceph RBD 缓存效果：</p> 
   <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <tbody>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">配置</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd_cache_writethrough_until_flush 的值</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">缓存效果</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = false</span> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">N/A</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">没有读写缓存，等同于 directsync</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = true</span></p> <p style="line-height:1.5;"><span class="pre" style="line-height:1.5;">rbd_cache_max_dirty = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">N/A &nbsp;</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">只有读缓存，没有写缓存，等同于 writethrough</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = true</span></p> <p style="line-height:1.5;">rbd_cache_max_dirty &gt; 0</p> <p style="line-height:1.5;">“cache=writeback”&nbsp;</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">True</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">在收到 QEMU 发出的第一个 flush 前，</p> <p style="line-height:1.5;">使用 writethrough 模式；收到后，使用 writeback 模式</p> </td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = true</span></p> <p style="line-height:1.5;">rbd_cache_max_dirty &gt; 0</p> <p style="line-height:1.5;">“cache=writeback”&nbsp;</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">False</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">一直使用 writeback 模式，QEMU 会在特定时候发出 flush，可能会导致数据丢失</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = true</span></p> <p style="line-height:1.5;">rbd_cache_max_dirty &gt; 0</p> <p style="line-height:1.5;">“cache=none”&nbsp;</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">True</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">一直使用 writethrough 模式，没有写缓存，只有读缓存</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">rbd&nbsp;<span class="pre" style="line-height:1.5;">cache = true</span></p> <p style="line-height:1.5;">rbd_cache_max_dirty &gt; 0</p> <p style="line-height:1.5;">“cache=writeback”&nbsp;</p> </td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">False</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">一直使用 writeback 模式，QEMU 会发出 flush 使缓存数据写入Ceph 集群</td> 
     </tr>
    </tbody>
   </table>
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">&nbsp;3. Linux 系统 I/O &lt;补记于 2016/05/28&gt;</h2> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp; 备注：主要内容引用自 2016/05/27 发表于&nbsp;Linux内核之旅 微信公众号的&nbsp;<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664602044&amp;idx=1&amp;sn=f6afa80a6a601eda53fc70cd9f8fc9ab&amp;scene=4#wechat_redirect" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">系统和进程信息与文件IO缓冲</a>&nbsp;一文。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp; 忽略文件打开的过程，通常我们会说“写文件”有两个阶段，一个是调用 write 我们称为写数据阶段（其实是受open的参数影响），调用 fsync（或者fdatasync）我们称为flush阶段。Linux上的块设备的操作可以分为两类：出于速度和效率的考虑。系统 I/O 调用(即内核)和标准 C语言库 I/O 函数，在操作磁盘文件时会对数据进行缓冲。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">3.1 stdio 缓冲的类型和设置</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">使用 C 标准库中的 fopen/fread/fwrite 系列的函数，我们可以称其为 buffered I/O。具体的I/O path如下：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">Application &lt;-&gt;&nbsp;<span style="line-height:1.5;text-decoration:underline;">Library Buffer</span>&nbsp;&lt;-&gt; Operation System Cache &lt;-&gt; File System/Volume Manager &lt;-&gt; Device</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">其中，library buffer 是标准库提供的用户空间的 buffer，可以通过 setvbuf 改变其大小。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;">设置方法如下：</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（1）通过 setvbuf 函数，结合不同的mode，可以设置缓冲的类型，和大小：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201605/697113-20160528212817522-993973779.jpg" alt="" style="border:0px;"></p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">不缓冲：不对 I/O 进行缓冲，等同于write或read忽略其buf和size参数，分别指定为NULL和0。stderr默认属于这个类型。</li> 
    <li style="list-style-type:disc;">行缓冲：对于输出流，在输出一个换行符前(除非缓冲区满了)将缓冲数据，对于输入流，每次读取一行数据。</li> 
    <li style="list-style-type:disc;">全缓冲：对于输出流，会一直缓冲数据知道缓冲区满为止。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（2）我们也可以通过<code>fflush</code>来刷新缓冲区。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201605/697113-20160528212859897-746665169.jpg" alt="" style="border:0px;"></p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">3.2 内核缓冲</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">使用 Linux 的系统调用的 open/read/write 系列的函数，我们可以称其为 non-buffered I/O。其I/O 路径为：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">Application&lt;-&gt;&nbsp;<span style="line-height:1.5;text-decoration:underline;">Operation System Cache</span>&nbsp;&lt;-&gt; File System/Volume Manager &lt;-&gt;Device</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">OS Cache 即内核缓冲的缓冲区，它是在内核态的，没办法通过像 stdio 库的 setvbuf 那样给它指定一个用户态的缓冲区，只能控制缓冲区的刷新策略等。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="http://mmbiz.qpic.cn/mmbiz/SeWfibBcBT0FVXDvFoiah6l7tFt918H2nPBxfb7dBibvWib7IKonYLLxwB1ZOhglicoCVpApzxMxBmpJS5h4EwXaI4w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="" style="border:0px;"></p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;"> <code>fsync&nbsp;</code>用于将描述符 fd 相关的所有元数据都刷新到磁盘上，相当于强制使文件处于同步I/O文件完整性。&nbsp;</li> 
    <li style="list-style-type:disc;"> <code>fdatasync 的</code>作用类似于 fsync，只是强制文件处于数据完整性，确保数据已经传递到磁盘上。</li> 
    <li style="list-style-type:disc;"> <code>sync&nbsp;</code>仅在所有数据(数据块，元数据)已传递到磁盘上时才返回。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">这些函数都只能刷新一次缓冲，此后每次发生的I/O操作都需要再次调用上面的三个系统调用来刷新缓冲，为此可以通过设置描述符的属性来保证每次IO的刷新缓冲。</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">打开文件的时候设置&nbsp;<code>O_SYNC</code>，相当于<span style="line-height:1.5;text-decoration:underline;">每次</span>发生 IO 操作后都调用&nbsp;<code>fsync&nbsp;</code>和&nbsp;<code>fdatasync&nbsp;</code>系统调用。[写操作只有在数据和元数据比如修改时间等被写入磁盘后才返回]</li> 
    <li style="list-style-type:disc;">使用&nbsp;<code>O_DSYNC&nbsp;</code>标志则要求写操作是同步 I/O 数据完整性的也就是相当于调用&nbsp;<code>fdatasync。[写操作必须等到数据被写入磁盘后才返回，此时元数据可以没有被写入磁盘，比如文件的 inode 信息尚未被写入时]</code> </li> 
    <li style="list-style-type:disc;"> <code>O_RSYNC&nbsp;</code>标志需要结合&nbsp;<code>O_DSYNC&nbsp;</code>和&nbsp;<code>O_SYNC&nbsp;</code>标志一起使用。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">将这些标志的写操作作用结合到读操作中，也就说在读操作之前，会先按照<code>O_DSYNC</code>或<code>O_SYNC</code>对写操作的要求，完成所有待处理的写操作后才开始读。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">更详细信息，可以参考&nbsp;<a href="http://man7.org/linux/man-pages/man2/open.2.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://man7.org/linux/man-pages/man2/open.2.html</a>。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">3.3 Direct I/O（O_DIRECT 标志）</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp;Linux 允许应用程序在执行磁盘 I/O 时绕过缓冲区高速缓存（Host OS Page Cache），从用户空间直接将数据传递到文件或磁盘设备上（其实是 Disk cache 中），这我们称之为直接 I/O，或者裸 I/O。直接 I/O 只适用于特定 I/O 需求的应用，例如:<a title="MySQL知识库">数据库</a>系统，其高速缓存和I/O优化机制自成一体，无需内核消耗CPU时间和内存去完成相同任务。通过在打开文件的时候指定&nbsp;<code>O_DIRECT&nbsp;</code>标志设置文件读写为直接IO的方式。使用直接 IO 存在一个问题，就是I/O得对齐限制，因为直接 I/O 涉及对磁盘的直接访问，所以在执行I/O时，必须遵守一些限制：</p> 
   <ul class="list-paddingleft-2" style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;"> <p style="line-height:1.5;">用于传递数据的缓冲区，其内存边界必须对齐为块大小的整数倍。</p> </li> 
    <li style="list-style-type:disc;"> <p style="line-height:1.5;">数据传输的开始点，亦即文件和设备的偏移量，必须是块大小的整数倍。</p> </li> 
    <li style="list-style-type:disc;"> <p style="line-height:1.5;">待传递数据的 buffer 必须是块大小的整数倍。</p> </li> 
   </ul>
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">3.4 总结</h3> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">3.4.1 I/O 栈</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="http://mmbiz.qpic.cn/mmbiz/SeWfibBcBT0FVXDvFoiah6l7tFt918H2nP3uQEGkEJ7XnUNIt57H5Aic1ndCm322CSwETFdfQ2vSTp3NDXAI8HA7g/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="" style="border:0px;"></p> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">3.4.2 MySQL 中的 I/O 模式</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">对于 MySQL 来说，该数据库系统是基于文件系统的，其性能和设备读写的机制有密切的关系。和数据库性能密切相关的文件I/O操作的三个操作：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">open 打开文件：比如，<span style="line-height:1.5;font-family:'Courier New';font-size:12px;">open("test.file",O_WRONLY|O_APPDENT|O_SYNC))</span> </li> 
    <li style="list-style-type:disc;">write 写文件：比如，<span style="line-height:1.5;font-family:'Courier New';font-size:12px;">write(fd,buf,6)</span> </li> 
    <li style="list-style-type:disc;">fdatasync flush操作（将文件缓存刷到磁盘上）：比如，<span style="line-height:1.5;font-family:'Courier New';font-size:12px;">fdatasync(fd) == -1，表示&nbsp;write操作后，我们调用了 fdatasync 来确保文件数据 flush 到了 disk上。fdatasync&nbsp;返回成功后，那么可以认为数据已经写到了磁盘上。像这样的flush的函数还有fsync、sync。</span> </li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;font-family:'Courier New';font-size:12px;">MySQL 的 innodb_flush_log_at_trx_commit 参数确定日志文件何时 write 和 flush。innodb_flush_method 则确定日志及数据文件如何 write、flush。在Linux下，innodb_flush_method可以取如下值：fdatasync, O_DSYNC, O_DIRECT，那这三个值分别是如何影响文件写入的？</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;font-family:'Courier New';font-size:12px;"><img src="https://images2015.cnblogs.com/blog/697113/201605/697113-20160529082208975-550200995.jpg" alt="" style="border:0px;"></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">fdatasync 被认为是安全的，因为在 MySQL 总会调用 fsync 来 flush 数据。</li> 
    <li style="list-style-type:disc;">使用 O_DSYNC 是有些风险的，有些 OS 会忽略该参数 O_SYNC。</li> 
    <li style="list-style-type:disc;">我们看到 O_DIRECT 和 fdatasync和 很类似，但是它会使用 O_DIRECT 来打开数据文件。有数据表明，如果是大量随机写入操作，O_DIRECT 会提升效率。但是顺序写入和读取效率都会降低。所以使用O_DIRECT需要谨慎。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">简单的，InnoDB 在每次提交事务时，为了保证数据已经持久化到磁盘（Durable），需要调用一次 fsync（或者是 fdatasync、或者使用 O_DIRECT 选项等）来告知文件系统将可能在缓存中的数据刷新到磁盘（更多关于<a href="http://www.orczhou.com/index.php/2009/08/innodb_flush_method-file-io/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">fsync</a>）。而 fsync 操作本身是非常“昂贵”的（关于“昂贵”：消耗较多的IO资源，响应较慢）：传统硬盘（10K转/分钟）大约每秒支撑150个fsync操作，SSD（Intel X25-M）大约每秒支撑1200个fsync操作。所以，如果每次事务提交都单独做fsync操作，那么这里将是系统TPS的一个瓶颈。所以就有了Group Commit的概念。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">当多个事务并发时，我们让多个都在等待 fsync 的事务一起合并为仅调用一次 fsync 操作。这样的一个简单的优化将大大提高系统的吞吐量，Yoshinori Matsunobu的<a href="http://yoshinorimatsunobu.blogspot.com/2009/08/great-performance-effect-of-fixing.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">实验</a>表明，这将带来五到六倍的性能提升。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">4. I/O Cache 与 Linux write barrier</h2> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">4.1 I/O Cache</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">一个典型的存储 I/O 路径：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://monolight.cc/uploads/2011/06/storage.png" alt="" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">一些组件有自己的cache：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://monolight.cc/uploads/2011/06/caches.png" alt="" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">其中：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">page cache 是 VFS cache 的一部分，buffer cache 是内存中，两者都是易失性的。但是，buffer cache 的容量往往很大。</li> 
    <li style="list-style-type:disc;">storage controller write cache 存在于绝大多数中高端存储控制器中。</li> 
    <li style="list-style-type:disc;">Write cache on physical media 存在于磁盘中，绝大多数也是易失性的。一些SSD含有备份电容。现代磁盘往往带有 16 - 64 MB cache。</li> 
   </ul>
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">4.2 Linux write barrier</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&lt;作者注：作者对本文中的一些概念还有一些疑惑或者不解，因此，本文内容会持续更新&gt;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">参考资料：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;"><a href="http://www.wzxue.com/rbdcache/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">解析Ceph: RBDCache 背后的世界</a></li> 
    <li style="list-style-type:disc;"><a href="http://docs.ceph.com/docs/hammer/rbd/rbd-config-ref/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://docs.ceph.com/docs/hammer/rbd/rbd-config-ref/</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.ilsistemista.net/index.php/virtualization/23-kvm-storage-performance-and-cache-settings-on-red-hat-enterprise-linux-62.html?start=2" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">KVM storage performance and cache settings on Red Hat Enterprise Linux 6.2</a></li> 
    <li style="list-style-type:disc;"><a href="http://linux.die.net/man/1/fio" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://linux.die.net/man/1/fio</a></li> 
    <li style="list-style-type:disc;"><a href="http://xfs.org/index.php/XFS_FAQ#Write_barrier_support." rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://xfs.org/index.php/XFS_FAQ#Write_barrier_support.</a></li> 
    <li style="list-style-type:disc;"><a href="https://libvirt.org/formatdomain.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">https://libvirt.org/formatdomain.html</a></li> 
    <li style="list-style-type:disc;"><a href="https://www.quora.com/What-is-the-major-difference-between-the-buffer-cache-and-the-page-cache" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">https://www.quora.com/What-is-the-major-difference-between-the-buffer-cache-and-the-page-cache</a></li> 
    <li style="list-style-type:disc;"><a href="https://bugs.launchpad.net/charms/+source/nova-compute/+bug/1412856" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">https://bugs.launchpad.net/charms/+source/nova-compute/+bug/1412856</a></li> 
    <li style="list-style-type:disc;"><a href="http://duartes.org/gustavo/blog/post/page-cache-the-affair-between-memory-and-files/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://duartes.org/gustavo/blog/post/page-cache-the-affair-between-memory-and-files/</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.orczhou.com/index.php/2010/08/time-to-group-commit-1/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.orczhou.com/index.php/2010/08/time-to-group-commit-1/</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.orczhou.com/index.php/2009/08/innodb_flush_method-file-io/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.orczhou.com/index.php/2009/08/innodb_flush_method-file-io/</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.thesubodh.com/2013/07/what-are-exactly-odirect-osync-flags.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.thesubodh.com/2013/07/what-are-exactly-odirect-osync-flags.html</a></li> 
    <li style="list-style-type:disc;"><a href="https://monolight.cc/2011/06/barriers-caches-filesystems/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">https://monolight.cc/2011/06/barriers-caches-filesystems/</a></li> 
   </ul>
   <div>
    <font color="#4b4b4b"><span style="font-size:15px;"><br></span></font>
   </div> 
   <div> 
    <font color="#4b4b4b"><span style="font-size:15px;">&nbsp; &nbsp; 本文转自SammyLiu博客园博客，原文链接：http://www.cnblogs.com/sammyliu/p/5066895.html</span></font>
    <span style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
   </div> 
   <div>
    <font color="#4b4b4b"><span style="font-size:15px;"><br></span></font>
   </div> 
   <div>
    <font color="#4b4b4b"><span style="font-size:15px;"><br></span></font>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
