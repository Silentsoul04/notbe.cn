<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>.Net Discovery 系列之四--深入理解.Net垃圾收集机制(下) « NotBeCN</title>
  <meta name="description" content="                        　第二节．GC关键方法解析                  　　1.Dispose()方法            　　Dispose可用于释放所有资源，包括托管的和非托管的，需要自己实现。            　　大多数的非托管资源都要求手动释放，我们应当为释放...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/10/weixin_34032827_90131321.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">.Net Discovery 系列之四--深入理解.Net垃圾收集机制(下)</h1>
    <p class="post-meta">Nov 10, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <div style="background-image:url(&quot;http://images.cnblogs.com/cnblogs_com/isline/174919/o_back.gif&quot;);"> 
     <p align="left" style="line-height:19.5px;"><strong><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　第</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">二</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">节</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">．</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">关键方法解析</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></strong></p> 
     <p><strong></strong></p> 
     <strong></strong> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　1.</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"><span style="line-height:1.5;color:rgb(136,136,136);"><span style="line-height:1.5;color:rgb(255,0,0);">Dispose</span></span>()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　Dispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">可用于释放所有资源，包括托管的和非托管的，需要自己实现。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　大多数的非托管资源都要求手动释放，我们应当为释放非托管资源公开一个方法，实现释放非托管资源的方法有很多种，实现</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">IDispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">接口的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法是最好的，这可以给使用你</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">类库</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的程序员以明确的说明，让他们知道怎样释放你的资源；而且</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">C#</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中用到的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">语句快，也是在离开语句块时自动调用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　这里需要注意的是，如果基类实现了</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">IDispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">接口，那么它的派生类也必须实现自己的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">IDispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，并在其</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法中调用基类中</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法。只有这样的才能保证当你使用派生类实例后，释放资源时，连同基类中的非托管资源一起释放掉。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　插曲：使用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">与</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">try+finally</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的区别</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　可以说</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">2</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">者没有任何区别，因为</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">只是编辑器级的优化，它与</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">try+finally</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">有着相同的作用，以下是一段使用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的代码，它在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">IL</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">阶段也是以</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">try+finally</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">呈现的：</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　C#</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">：</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:1.5;font-size:12pt;color:#0000FF;font-family:'新宋体';">　　</span></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:1.5;font-size:12pt;font-family:'新宋体';"></span></p> 
     <p></p> 
     <span style="line-height:1.5;font-size:12pt;font-family:'新宋体';">　　MSIL：<br></span> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:1.5;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　但是，</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">的优点是，在代码离开</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">块时，</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">using</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">会自动调用</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">I</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">d</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">ispose</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">接口的</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">()</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法。</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span>
     <p></p> 
     <p style="line-height:1.5;"></p> 
     <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
      <img align="top" width="11" src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" height="16" style="border:0px;" alt="ContractedBlock.gif">
      <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span> 
     </div> 
     <p align="left" style="line-height:19.5px;">&nbsp;</p> 
     <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
      <img align="top" width="11" src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" height="16" style="border:0px;" alt="ContractedBlock.gif">
      <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span> 
     </div> 
     <p align="left" style="line-height:19.5px;">&nbsp;</p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　2. GC.<span style="line-height:1.5;color:rgb(255,0,0);">Collect</span>()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　如果我们在程序中显式的调用了垃圾收集器的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">collect</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">接口，那么垃圾收集器会立即运行，完成内存对象的标记、压缩与清除工作，使用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC.Collect(i)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">还可以指定回收的代，然而</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">aicken</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">并不赞成各位同学显式调用它：</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　⑴</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">. GC.Collect()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">做的并不只是回收内存，就像第一节中介绍的，在回收了内存之后，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">会重新整理内存，修正对象指针，让空闲内存连续，供</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">CLR</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">顺序分配内存，提高新建对象的效率。内存压缩整理工作非常耗用计算资源。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　⑵</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">.</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">很少有人会关心到</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">除了在内存吃紧以及资源空闲时运行，还会在什么时候运行。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">&nbsp;</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">其实</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的运行时机，还要受到一个叫做“策略引擎”的部件控制，它会观察</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的收集频率、效率等等。它会根据</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">回收效果，调整</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">运行的频率：即当某次</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">回收效果颇丰时，它便会增加</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">运行的频率，反之亦然。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　所以如果刚刚发生了一次自然的收集，垃圾对象就会非常之少，而此时程序又显式的进行了收集调用，那么自然，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">&nbsp;</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">虽然小有收获，但是策略引擎就会认为：这很不值得，才收集了这么点垃圾，也许该减少</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的次数。这样一来，垃圾收集器努力保持的自然节奏就被打乱了。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　同时，对象类型的创建效率与频率，也会被“策略引擎”捕捉到，从而改变代的数量与容量。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　所以，额外的调用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，代价高昂，甚至会降低效率。显示的调用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC.Collect()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，实质是在用“时间换空间”，而通常在程序设计中，我们推荐的设计原则是“空间换时间”，比如使用各种各样的缓存。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　也有例外，如果你掌握了整个应用程序的情况，明确的知道何时会产生大量垃圾，也是可以显示调用该方法的。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　综上，尽量不要显示调用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC.Collect()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，因为服务器的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">CPU</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">比内存要贵的多！</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　3.</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">&nbsp;</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">析构函数</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"><span style="line-height:1.5;color:rgb(255,0,0);">Finalize</span>()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　我们知道，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">只负责释放托管资源，非托管资源</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">是无法释放的。类似文件操作、数据库连接等都会产用非托管资源。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法是用于释放非托管资源的，等同于</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">C#</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中是析构函数，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">C#</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">编译器在编译构造函数时，会隐式的将析构函数编译为</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">对应的代码，并确定在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">finally</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">块中执行了</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">base.</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　析构函数中只能释放非托管资源</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">,</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">而不要</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">任何托管资源进行</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">析构</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，原因如下：</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　⑴</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">你无法预测析构函数的运行时机，它不是按顺序执行的。当析构函数被执行的时候，也许你进行操作的托管资源已经被释放了。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　⑵</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">包含</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的对象，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">需要</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">两次处理才能删除。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　⑶</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">CLR</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">会在单独的线程上执行所有对象的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法，无疑，如果频繁的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，会降低系统的性能。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　下面我们来重点说说第</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">⑵</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">点，为何包含</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的对象，需要两次</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">才能被清除。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　首先要了解与</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">相关的两个队列：<span style="line-height:1.5;color:rgb(255,0,0);">终止队列</span></span><span style="line-height:1.5;color:rgb(255,0,0);"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(Finalization Queue)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">与<span style="line-height:1.5;color:rgb(255,0,0);">可达队列</span></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"><span style="line-height:1.5;color:rgb(255,0,0);">(Freachable Queue</span>)</span></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"><span style="line-height:1.5;color:rgb(255,0,0);">，</span>这两个队列存储了一组指向对象的指针。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　当程序中在托管堆上分配空间时</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(new)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，如果该类含有析构函数，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">将在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中添加一个指向该对象的指针。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">首次运行时，会在已经被确认为垃圾的对象中遍历，如果</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">某个</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">垃圾对象的指针被</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">包含，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">将这个对象从垃圾中分离出来，将它的指针储存到</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Freachable Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中，并在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">删除这个对象的指针记录，这时该对象就不是垃圾了——这个过程被称为是对象的复生（</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Resurrection</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">）。当</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Freachable Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">一旦被添加了指针之后，它就会去执行对象的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法，清除对象占用的资源。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　当</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">再次运行时，便会再次发现这个含有</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">垃圾</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">对象，但此时它在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中已经没有记录了</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">首次运行时删掉了它的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">记录</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，那么这个对象就会被回收了。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　至此，通过</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">两次运行，终于回收了带有析构函数的对象。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　复活实例：</span></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">&nbsp;</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
      <img align="top" width="11" src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" height="16" style="border:0px;" alt="ContractedBlock.gif">
      <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span> 
     </div> 
     <p align="left" style="line-height:19.5px;">&nbsp;</p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:1.5;font-size:9pt;font-family:'新宋体';"><span style="line-height:1.5;">&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-size:9pt;font-family:'新宋体';"><span style="line-height:1.5;">&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　看了上面的代码，大家应该了解什么是复活了吧！</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">那么为什么要复生呢？因为</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">首次</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">时，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">这个对象的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法还没有被执行，如果不经过复生就被</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">掉，那么就连它的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">一起回收了，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">就无法运行了，所以必须先复生，以执行它的</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，然后再回收。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　还有两个方法</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">ReRegisterForFinalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">和</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">SuppressFinalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">需要讲一讲，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">ReRegisterForFinalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">是将指向对象的指针重新添加到</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">即召唤系统执行</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">SuppressFinalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">是将对象的指针从</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalization Queue</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">中移除</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">即拒绝系统执行</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Finalize()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　SuppressFinalize</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">用于那些即有析构函数来释放资源，又实现了</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法释放资源的情况下</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">：将</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">G</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">C.SuppressFinalize(this)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">添加至</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法中，以确保程序员调用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose()</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">后，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">就不必再次收集了，例如以下代码：</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:1.5;font-size:12pt;font-family:'宋体';">　　</span></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　即实现</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">Idisposable</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">中的</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">Dispose</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">()</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';">方法，又使用析构函数，一个双保险，大家不要迷惑，其实在释放非托管资源时，使用一个即可，推荐使用前者。</span>
     <span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span>
     <p></p> 
     <p style="line-height:1.5;"></p> 
     <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
      <img align="top" width="11" src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" height="16" style="border:0px;" alt="ContractedBlock.gif">
      <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span> 
     </div> 
     <p align="left" style="line-height:19.5px;">&nbsp;</p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　4</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">．</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">弱引用</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">(</span><span style="line-height:1.5;color:rgb(255,0,0);"><span style="line-height:1.5;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">We</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"><span style="line-height:1.5;color:rgb(255,0,0);">akReference</span></span></span></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">)</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　最后一个话题：弱引用。在编程中，对于那些大对象建议使用这种引用方式，这种引用不影响</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">回收：我们用过了某个对象，然后将其至</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">null</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，这样</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">就可以快速回收它了，但是没过多久我们又需要这个对象了，没办法，只好重新创建实例，这样就浪费了创建实例所需的计算资源；而如果不至</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">null</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">，就会浪费内存资源。对于这种情况，我们可以创建一个这个大对象的弱引用，这样在内存不够时</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">可以快速回收，而在没有被</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">回收前我们还可以再次利用该对象。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:1.5;font-size:12pt;font-family:'宋体';">　　</span><span style="line-height:1.5;font-size:12pt;font-family:'宋体';"></span></p> 
     <p>&nbsp;</p> 
     <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
      <img align="top" width="11" src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" height="16" style="border:0px;" alt="ContractedBlock.gif">
      <span class="cnblogs_code_Collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;">Code</span> 
     </div> 
     <p align="left" style="line-height:19.5px;">&nbsp;</p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　看到没，在</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">so</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">&nbsp;= null;</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">后，它的弱引用依然是可用的。所以对于大对象的使用，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">aicken</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">建议使用此种方式。另外，弱引用有长短之分：长弱引用在对象终结后，依然追踪对象；短弱引用则反之，</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">aicken</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">不建议人为干预</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">的工作成果，所以推荐使用短弱引用，即上面代码中的方式。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">通过以上的讲解，相信大家已经能够很全面的了解</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">.Net GC</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">方面的知识了。</span></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">&nbsp;</span></p> 
     <p align="left" style="line-height:19.5px;"><span style="line-height:24px;font-size:12pt;font-family:'宋体';">　　我是<span style="line-height:1.5;color:rgb(255,0,0);">李鸣(Aicken)&nbsp;</span></span><span style="line-height:24px;font-size:12pt;font-family:'宋体';">请您继续关注我的下一篇文章。</span><span style="line-height:24px;font-size:12pt;font-family:'宋体';"></span></p> 
     <p></p> 
     <p style="line-height:1.5;">&nbsp;</p> 
    </div> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:13px;">
    <br>
   </div> 
   <div> 
    <font color="#000e00"><b><span style="font-size:13px;">本文转自Aicken(李鸣)博客园博客，原文链接：http://www.cnblogs.com/isline/archive/2009/03/04/1402713.html，如需转载请自行联系原作者</span></b></font>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
