<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>寻找单链表中的环的入口结点 « NotBeCN</title>
  <meta name="description" content="             一，问题描述    给定一个单链表，单链表中有环，请找出这个环的入口结点。比如，如下单链表：        入口结点是，结点4.    &nbsp;    二，实现思路    如果仅仅是寻找入口结点，可以更改结点元素的值的话，只需要扫描一遍就可以找到入口结点了。        比如，假设...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/07/weixin_33946605_90129145.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">寻找单链表中的环的入口结点</h1>
    <p class="post-meta">Nov 7, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p><strong>一，问题描述</strong></p> 
   <p>给定一个单链表，单链表中有环，请找出这个环的入口结点。比如，如下单链表：</p> 
   <p><img width="402" height="94" alt="" src="data:image/png;base64,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"></p> 
   <p>入口结点是，结点4.</p> 
   <p>&nbsp;</p> 
   <p><strong>二，实现思路</strong></p> 
   <p>如果仅仅是寻找入口结点，可以更改结点元素的值的话，只需要扫描一遍就可以找到入口结点了。</p> 
   <p><img width="377" height="116" alt="" src="data:image/png;base64,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7LU1//3wbItrfraDHvQRUtVxrozMmRuuukdIn327ZH74a2HBZCc72cNlP+0nn+8PTLZyuRqT7E7VcXMbkmveevYmgx70j0DeHFs2VyV1T9DMXdhn3y7FqGCyk53s3tkb/vRvdaNgstt5hS6YXXzNW8/uNegh/ghk7W6ru3/iwZNXjus+ePLq0uBUw3e8zQWTnexkb5r949GF9wcmb40tm+CO644vPjOX54nPvnoGa362gx7uj0AO339c9yNv024rP/yNvmCyk53sTbObx0oNs48vPkt2dvMzktMOrTszz0GvhLznujOzaq5QTLWXBqdaaVenYLKTnew+spvgXUd/d7CrL/vHkbnaBXuCs9e+xRSbQW8SL/hvtcaoYLKTnexkj1325oOuG0+3YLKTnexkj1F2r0H3+RUl+0MGRXayk53scczefNDD/RFIq0IGRXayk53scczuNeiK9x3qBZOd7GQne+yyew+62n2HBQWTnexkJ3vMsnsOugXx1AomuwUH2clO9kC8Bl09m2LB6pHJTnaykz0oBp3sZCc72fVTi2Rn0MlOdrILZd/fb9/sdvTuNehWHa2EDEo9LNnJHsfssz/7+a/+8M/2zG5J76cOOgAE8NVXbkeHe/Wq9utoaww6AAnvvON2dLhvveWWy9ovpX0x6ABaZi7PzXHrlvaraV8MOoCWmctzc7z9NhfpWhh0AK159Mg9f949f97t6Dj8j4UF7dfUphh0AEI62BNlFABACIOujQIACGHQtVEAACEMujYKACCEQddGAQCEMOjaKACAEAZdGwUAEMKga6MAAEIYdG0UAEAIg66NAgAIYdC1UQAAIQy6NgoAIIRB10YBAIQw6NooAIAQBl0bBQAQwqBrowAAQhh0bRQAQAiDro0CAAhh0LVRAAAhDLo2CgAghEHXRgEAhDDo2igAgBAGXRsFABDCoGujAABCGHRtFABACIOujQIACGHQtVEAACEMujYKACCEQddGAQCEMOjaKACAEAZdGwUAEMKga6MAAEIYdG0UAEAIg66NAgAIYdC1UQAAIQy6NgoAIIRB10YBAIQw6NooAIAQBl0bBQAQwqBrowAAQhh0bRQAQAiDro0CAAhh0LVRAAAhDLo2CgAghEHXRgEAhDDo2igAgBAGXRsFABDCoGujAABCGHRtFABACIOujQIACGHQtVEAACEMujYKACDk3Xe1X0G7Y9ABICEYdABICAYdABKCQQeAhGDQASAhGHQASAgGHQASgkEHgIRg0AEgIRh0AEiI/wM2u9KMBBfBWwAAAABJRU5ErkJggg=="></p> 
   <p>比如，假设所有的结点值都是正数，从头开始，那么在扫描过程中，<span style="color:rgb(255,0,0);"><em>将扫描的结点的值与 0 比较，如果不是0，则置为0；如果是0，则说明这个结点就是入口结点。</em></span></p> 
   <p>这种方式非常简单高效，<strong>只需要扫描一遍链表就可以找到入口结点了</strong>。缺点是：它修改了链表中结点的值。</p> 
   <p>&nbsp;</p> 
   <p>如果不允许修改结点的值，处理相对复杂一点。</p> 
   <p>1）假设单链表中的环有N个结点（在上面的示例图中环有3个结点），<span style="color:rgb(255,0,0);"><strong>可以设置两个指针p1 和 p2，初始时，p1 和 p2 都指向表头，指针p1 先在 链表中移动 N 步，然后 p1 和 p2 再以相同的速度向前移动</strong></span>(每次向前移动一个结点)，当p2指向环的入口结点时，p1已经沿着环走了一圈又回到了入口结点。也即：当两个结点相遇时，相遇时共同指向的这个结点就是环的入口结点。</p> 
   <p>&nbsp;</p> 
   <p>2）那么，现在的问题变成了：<strong>如何找出单链表中的环包含几个结点？[</strong>参考：钟表的分针是如何追上时针的？]</p> 
   <p><em>比如，下面的单链表中的环包含了3个结点。</em></p> 
   <p>设置两个指针 q1 和 q2，让 q1 移动的速度是 q2 的两倍，即：q1 每次移动两个结点，q2 每次移动 一个结点。</p> 
   <p>初始时，q1 和 q2 都指向头结点，然后 q1 和 q2 开始移动，当 q1 再次 与 q2 相遇时，它们一定是在环中的某个结点上相遇的。</p> 
   <p><img width="449" height="137" alt="" src="data:image/png;base64,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"></p> 
   <p>然后，再固定 q1 不动，让 q2 遍历链表，<span style="color:rgb(255,0,0);">并记录它遍历的结点个数。当 q2 再次与q1相遇时，它所遍历的结点个数就是环中结点的个数了。</span></p> 
   <p>&nbsp;</p> 
   <p><strong>三，代码实现</strong></p> 
   <p>上面用到了单链表，因此得有结点的定义，这里结点类以内部类实现。</p> 
   <div class="cnblogs_code"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> EntryNode {
    
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">class</span> Node{
        <span style="color:rgb(0,0,255);">int</span> ele;
        Node next;
        
        <span style="color:rgb(0,0,255);">public</span> Node(<span style="color:rgb(0,0,255);">int</span> ele) {
            <span style="color:rgb(0,0,255);">this</span>.ele = ele;
            next = <span style="color:rgb(0,0,255);">null</span>;
        }
    }
    
    <span style="color:rgb(0,0,255);">private</span> Node head;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">头结点
</span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">other code.....</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
   </div> 
   <p>&nbsp;</p> 
   <p>首先，得构造一个带环的单链表。通过insert()方法和 makeEntry()方法来构造带环的单链表。</p> 
   <div class="cnblogs_code"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
    <pre>    <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">采用头插法,插入结点</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> insert(<span style="color:rgb(0,0,255);">int</span> ele){
        Node newNode = <span style="color:rgb(0,0,255);">new</span> Node(ele);
        <span style="color:rgb(0,0,255);">if</span>(head == <span style="color:rgb(0,0,255);">null</span>)
            head = newNode;
        <span style="color:rgb(0,0,255);">else</span>
        {
            newNode.next = head.next;
            head.next = newNode;
        }
    }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
   </div> 
   <p>insert()采用“头插法”方式将结点插入到链表中</p> 
   <p>&nbsp;</p> 
   <div class="cnblogs_code"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);">/*</span><span style="color:rgb(0,128,0);">ele 就是入口结点的值
     * 构造一个带环的链表.如果 ele 不属于链表中的值,则抛出IllegalArgumentException
     * point 用来遍历链表,prePoint记录遍历链表时的前驱结点.
     * 当 point.ele == ele时, 指定 当前 point 指向的结点作为 入口 结点
     * 
     * 然后 point 继续遍历,直到遍历到尾结点. 然后最终由prePoint记录尾结点, 并将尾结点的next指针指向入口结点
     </span><span style="color:rgb(0,128,0);">*/</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> makeEntry(<span style="color:rgb(0,0,255);">int</span> ele){
        <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">assume ele in Node List</span>
        Node point,prePoint;
        prePoint = point = head;
        Node entry = <span style="color:rgb(0,0,255);">null</span>;
        <span style="color:rgb(0,0,255);">while</span>(point != <span style="color:rgb(0,0,255);">null</span>)
        {
            <span style="color:rgb(0,0,255);">if</span>(point.ele == ele)
                entry = point;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">entry is circle's first node(entry node)</span>
            prePoint = point;
            point = point.next;
        }
        <span style="color:rgb(0,0,255);">if</span>(entry == <span style="color:rgb(0,0,255);">null</span>)<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);"> ele does not in list, can not make a circle</span>
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> IllegalArgumentException(ele + " does not in list, can not make a circle");
        prePoint.next = entry;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">prePoint is last node</span>
    }</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
   </div> 
   <p>makeEntry()方法，负责让单链表的表尾结点 的next指针 指向 链表中的某个结点，从而构成了一个环。</p> 
   <p>&nbsp;</p> 
   <p>findEntry()方法找出入口结点的值。整个完整代码实现如下：</p> 
   <div class="cnblogs_code"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> EntryNode {
    
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">class</span> Node{
        <span style="color:rgb(0,0,255);">int</span> ele;
        Node next;
        
        <span style="color:rgb(0,0,255);">public</span> Node(<span style="color:rgb(0,0,255);">int</span> ele) {
            <span style="color:rgb(0,0,255);">this</span>.ele = ele;
            next = <span style="color:rgb(0,0,255);">null</span>;
        }
    }
    
    <span style="color:rgb(0,0,255);">private</span> Node head;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">头结点
    
    </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">采用头插法,插入结点</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> insert(<span style="color:rgb(0,0,255);">int</span> ele){
        Node newNode = <span style="color:rgb(0,0,255);">new</span> Node(ele);
        <span style="color:rgb(0,0,255);">if</span>(head == <span style="color:rgb(0,0,255);">null</span>)
            head = newNode;
        <span style="color:rgb(0,0,255);">else</span>
        {
            newNode.next = head.next;
            head.next = newNode;
        }
    }
    
    <span style="color:rgb(0,128,0);">/*</span><span style="color:rgb(0,128,0);">ele 就是入口结点的值
     * 构造一个带环的链表.如果 ele 不属于链表中的值,则抛出IllegalArgumentException
     * point 用来遍历链表,prePoint记录遍历链表时的前驱结点.
     * 当 point.ele == ele时, 指定 当前 point 指向的结点作为 入口 结点
     * 
     * 然后 point 继续遍历,直到遍历到尾结点. 然后最终由prePoint记录尾结点, 并将尾结点的next指针指向入口结点
     </span><span style="color:rgb(0,128,0);">*/</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> makeEntry(<span style="color:rgb(0,0,255);">int</span> ele){
        <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">assume ele in Node List</span>
        Node point,prePoint;
        prePoint = point = head;
        Node entry = <span style="color:rgb(0,0,255);">null</span>;
        <span style="color:rgb(0,0,255);">while</span>(point != <span style="color:rgb(0,0,255);">null</span>)
        {
            <span style="color:rgb(0,0,255);">if</span>(point.ele == ele)
                entry = point;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">entry is circle's first node(entry node)</span>
            prePoint = point;
            point = point.next;
        }
        <span style="color:rgb(0,0,255);">if</span>(entry == <span style="color:rgb(0,0,255);">null</span>)<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);"> ele does not in list, can not make a circle</span>
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> IllegalArgumentException(ele + " does not in list, can not make a circle");
        prePoint.next = entry;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">prePoint is last node</span>
    }
    
    
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">int</span> findEntry(){
        
        <span style="color:rgb(0,0,255);">if</span>(head == <span style="color:rgb(0,0,255);">null</span>)
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> IllegalArgumentException();
        
        <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">如果链表中只有一个节点,不需要求解环中节点的个数</span>
        <span style="color:rgb(0,0,255);">if</span>(head.next == head)
            <span style="color:rgb(0,0,255);">return</span> head.ele;
        
        <span style="color:rgb(0,0,255);">int</span> circleNumber = circleNumbers();
        
        <span style="color:rgb(0,0,255);">assert</span> circleNumber &gt; 0;
        Node next_k, current;
        next_k = current = head;
        <span style="color:rgb(0,0,255);">for</span>(<span style="color:rgb(0,0,255);">int</span> i = 1; i &lt;= circleNumber; i++)
            next_k = next_k.next;
        
        <span style="color:rgb(0,0,255);">while</span>(current != next_k)
        {
            current = current.next;
            next_k = next_k.next;
        }
        
        <span style="color:rgb(0,0,255);">return</span> next_k.ele;
    }
    
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">int</span> circleNumbers(){
        Node pre,next;
        pre = next = head;
        next = next.next.next;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">next 先走2步
        </span><span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">每个节点往后移</span>
        <span style="color:rgb(0,0,255);">while</span>(pre != next)
        {
            pre = pre.next;
            next = next.next.next;
        }
        
        <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">now pre and next pointer all point same node</span>
        
        <span style="color:rgb(0,0,255);">int</span> circleNumber = 0;
        circleNumber++;
        
        next = next.next;<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">next forward one step</span>
        <span style="color:rgb(0,0,255);">while</span>(next != pre)
        {
            circleNumber++;
            next = next.next;
        }
        <span style="color:rgb(0,0,255);">return</span> circleNumber;
    }
    
    <span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">hapjin test</span>
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> main(String[] args) {
        EntryNode entryNode = <span style="color:rgb(0,0,255);">new</span> EntryNode();
        <span style="color:rgb(0,0,255);">int</span>[] eles = {1，2，3，4，5，6};
        <span style="color:rgb(0,0,255);">for</span> (<span style="color:rgb(0,0,255);">int</span> ele : eles) {
            entryNode.insert(ele);
        }
        
        entryNode.makeEntry(4);<span style="color:rgb(0,128,0);">//</span><span style="color:rgb(0,128,0);">至此,构造完了一个带环的链表</span>
        
        System.out.println("入口结点的值为: " + entryNode.findEntry());
    }
}</pre> 
    <pre>本文转自hapjin博客园博客，原文链接：http://www.cnblogs.com/hapjin/，如需转载请自行联系原作者<br></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
    </div> 
   </div> 
   <p>&nbsp;</p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
