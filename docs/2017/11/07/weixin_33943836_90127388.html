<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ACM_几何] Metal Cutting(POJ1514)半平面割与全排暴力切割方案 « NotBeCN</title>
  <meta name="description" content="             [                   Description            In order to build a ship to travel to Eindhoven, The Netherlands, various sheet metal parts have to b...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/07/weixin_33943836_90127388.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">ACM_几何] Metal Cutting(POJ1514)半平面割与全排暴力切割方案</h1>
    <p class="post-meta">Nov 7, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1 style="font-size:14px;line-height:1.5em;clear:both;font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;"><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/zjutlitao/p/3526893.html" rel="nofollow" style="color:rgb(51,51,51);text-decoration:none;">[</a></h1> 
   <div class="clear" style="clear:both;font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:14px;"></div> 
   <div class="postBody"> 
    <div class="blogpost-body"> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">Description</p> 
     <div class="ptx" style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:14px;">
      In order to build a ship to travel to Eindhoven, The Netherlands, various sheet metal parts have to be cut from rectangular pieces of sheet metal. Each part is a convex polygon with at most 8 vertices. Each rectangular piece of sheet metal has width n and height m, so that the four corners of the sheet can be specified by the Cartesian coordinates (0, 0), (0, m), (n, m) and (n, 0) in clockwise order. The cutting machine available can make only straight-line cuts completely through the metal. That is, it cannot cut halfway through the sheet, turn, and then cut some more. You are asked to write a program to determine the minimum total length of cuts this machine has to make in order to cut out the polygon. The cuts must be along the edges of the poligon.&nbsp;
      <br>
      <br> For example, if n = m = 100, and the polygon has vertices (80, 80), (70, 30), (20, 20) and (20, 80), the following diagram shows the optimal cut (the thick lines). The numbers show the order in which the cuts are made.&nbsp;
      <br>
      <img src="http://poj.org/images/1514_1.jpg" alt="" style="border:0px;">
     </div> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">Input</p> 
     <div class="ptx" style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:14px;">
      The first line of input contains the two integers n and m where 0 &lt; n, m &lt;= 500. The next line contains p, the number of vertices in the polygon, where 3 &lt;= p &lt;= 8. Each of the next p lines contains two integers x and y where 0 &lt; x &lt; n and 0 &lt; y &lt; m, specifying the vertices of the polygon. The vertices are listed in clockwise order. You may assume that the polygon does not intersect itself, and that no three consecutive vertices are colinear.
     </div> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">Output</p> 
     <div class="ptx" style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:14px;">
      Print the minimum total length of cuts required to cut out the given polygon, accurate to 3 decimal places.
     </div> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">Sample Input</p> 
     <pre class="sio">100 100
4
80 80
70 30
20 20
20 80</pre> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">Sample Output</p> 
     <pre class="sio">Minimum total length = 312.575</pre> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">Source</p> 
     <div class="ptx" style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:14px;">
      <a href="http://poj.org/searchproblem?field=source&amp;key=East+Central+North+America+1998" rel="nofollow" style="color:rgb(51,51,51);">East Central North America 1998</a>
     </div> 
     <div class="ptx" style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:14px;">
      &nbsp;
     </div> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;"><span style="line-height:1.5;font-family:'黑体';"><strong><span style="line-height:1.5;font-size:14pt;"><span style="line-height:1.5;color:rgb(51,102,255);">题目大意：</span>给你一个长为m宽为n的木板再给你一个凸的p边形的p个坐标点，求最短切割路径长度(这里割只能一刀子到头，不能停不能弯）。</span></strong></span></p> 
     <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;"><span style="line-height:1.5;font-family:'黑体';"><strong><span style="line-height:1.5;font-size:14pt;"><span style="line-height:1.5;color:rgb(51,102,255);">Wrong啦：</span>这题由于最多为8边形，所以果断采用暴力方法，枚举所有切割次序，注意这里的切割最好用半平面法来做，不然要考虑的情况特别多，其中我刚开始拿到这题就当成普通的几何问题来做，把每个割痕分为3部分l1、l2、l3再利用深搜动态的调整每一个割痕对应的l1/l2/l3的值，同时考虑边界切割问题和l1或l3为0的情况，结果都不能过，最后发现少考虑了一种最坑的情况，即：非常大木板与非常小正六边形问题（这里会产生新割痕对旧割痕的影响，所以不得不换用另一种思路！</span></strong></span></p> 
     <div class="ptx"> 
      <div class="cnblogs_code" style="font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
       <img class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" style="border:0px;vertical-align:middle;">&nbsp;
       <span class="cnblogs_code_collapse" style="border-width:1px;border-style:solid;border-color:#808080;line-height:1.5;font-size:12px;">错误代码</span> 
      </div> 
      <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;"><strong><span style="line-height:1.5;font-size:14pt;font-family:'黑体';"><span style="line-height:1.5;color:rgb(51,102,255);">半平面法</span>：</span></strong><strong style="line-height:1.5;"><span style="line-height:1.5;font-size:14pt;font-family:'黑体';">最后想到了<strong><span style="line-height:1.5;"><span style="line-height:1.5;">半平面的方法,</span></span></strong></span></strong><strong style="line-height:1.5;"><span style="line-height:1.5;font-size:14pt;font-family:'黑体';">就是把木板看成一个4个顶点的凸包，切出里面的p多边形即依次枚举切割顺序，对于每一次切割肯定沿着某一条边，这样最多8！种情况。然后每一次切割我用点集st[]维护每次切过后剩下的部分（新的凸包），np维护新凸包的顶点数。这里的维护就采用了半平面割的方法：</span></strong></p> 
      <div class="cnblogs_code" style="font-family:'Courier New';font-size:12px;border:1px solid rgb(204,204,204);"> 
       <div class="cnblogs_code_toolbar">
        <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(51,51,51);text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
       </div> 
       <pre><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  1</span> #include &lt;cmath&gt;
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  2</span> #include &lt;cstdio&gt;
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  3</span> #include&lt;algorithm&gt;
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  4</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">using</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">namespace</span><span style="line-height:1.5;font-size:12px;"> std;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  5</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">const</span>  <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">int</span> maxn = <span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">100</span><span style="line-height:1.5;font-size:12px;">;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  6</span> 
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  7</span> 
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  8</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> min(<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> a,<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> b){<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> a&lt;b?a:b;}<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">求2个double中较小的一个</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">  9</span> 
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 10</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">const</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> eps = 1e-<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">8</span><span style="line-height:1.5;font-size:12px;">;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 11</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> sgn(<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> x) {<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> fabs(x)&lt;eps?<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>:(x&gt;<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>?<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span>:-<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span>);}<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">经典比较2个double类数的方法，相等0，大于1，小于-1
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 12</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">------------------------------------------------------------------
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 13</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">2维几何模板
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 14</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">------------------------------------------------------------------</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 15</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">struct</span> Point{<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">点类(x,y)构造函数+==重定义</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 16</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span><span style="line-height:1.5;font-size:12px;"> x,y;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 17</span>     Point(<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> tx=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>,<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> ty=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>){x=tx;y=<span style="line-height:1.5;font-size:12px;">ty;}
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 18</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">bool</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">operator</span> == (<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">const</span> Point&amp; t) <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">const</span><span style="line-height:1.5;font-size:12px;"> {
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 19</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> sgn(x-t.x)==<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span> &amp;&amp; sgn(y-t.y)==<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span><span style="line-height:1.5;font-size:12px;">;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 20</span> <span style="line-height:1.5;font-size:12px;">    }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 21</span> <span style="line-height:1.5;font-size:12px;">}p[maxn],Set[maxn],st[maxn],tmp[maxn],pp[maxn];
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 22</span> 
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 23</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> dist(Point a,Point b){<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">a、b两点的距离</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 24</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> cross(Point a,Point b,Point c){<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);}<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">向量ab和向量ac的差积</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 25</span> 
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 26</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">struct</span> Seg{Point s,e;};<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">射线se</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 27</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">bool</span> outside(Seg seg,Point p){<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> cross(seg.s,seg.e,p)&gt;eps;}<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">点p在射线seg左</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 28</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">bool</span> inside(Seg seg,Point p){<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> cross(seg.s,seg.e,p)&lt;-eps;}<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">点p在射线seg右</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 29</span> 
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 30</span> Point Intersect(Point p1, Point p2, Point p3, Point p4, Point&amp;<span style="line-height:1.5;font-size:12px;"> p) {
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 31</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span><span style="line-height:1.5;font-size:12px;"> a1, b1, c1, a2, b2, c2, d;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 32</span>     a1 = p1.y - p2.y; b1 = p2.x - p1.x; c1 = p1.x*p2.y - p2.x*<span style="line-height:1.5;font-size:12px;">p1.y;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 33</span>     a2 = p3.y - p4.y; b2 = p4.x - p3.x; c2 = p3.x*p4.y - p4.x*<span style="line-height:1.5;font-size:12px;">p3.y;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 34</span>     d = a1*b2 - a2*<span style="line-height:1.5;font-size:12px;">b1;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 35</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">if</span> ( fabs(d) &lt; eps )    <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">false</span><span style="line-height:1.5;font-size:12px;">;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 36</span>     p.x = (-c1*b2 + c2*b1) /<span style="line-height:1.5;font-size:12px;"> d;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 37</span>     p.y = (-a1*c2 + a2*c1) /<span style="line-height:1.5;font-size:12px;"> d;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 38</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span><span style="line-height:1.5;font-size:12px;"> p;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 39</span> }<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">直线p1p2和p3p4的交点存在p中(当且仅当Cross(p1p2,p3p4)非0)
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 40</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">-----------------------------------------------------------------</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 41</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span><span style="line-height:1.5;font-size:12px;"> W,H;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 42</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">int</span> a[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">10</span><span style="line-height:1.5;font-size:12px;">],n,pn;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 43</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span><span style="line-height:1.5;font-size:12px;"> CUT(Seg seg,Point p[]){
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 44</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">int</span> i,j,tot=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span><span style="line-height:1.5;font-size:12px;">;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 45</span> <span style="line-height:1.5;font-size:12px;">    Point A,B;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 46</span>     A=B=Point(<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>,<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span><span style="line-height:1.5;font-size:12px;">);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 47</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">bool</span><span style="line-height:1.5;font-size:12px;"> s,e;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 48</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">for</span>(i=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>;i&lt;pn;i++){<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">这里A、B交替存储seg与动态凸包p[]的交点，并把新凸包保存在pp中，新的凸包点数保存在tot中</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 49</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">if</span>(!outside(seg,p[i]))pp[tot++]=p[i];<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">p[i]在射线seg右或上</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 50</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">else</span><span style="line-height:1.5;font-size:12px;"> {
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 51</span>             <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">if</span>(i==<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>&amp;&amp;!outside(seg,p[pn-<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span>])){<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">当前p[i]p[i-1]和seg的交点(当i==0时要特殊处理一下)</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 52</span>                 B=<span style="line-height:1.5;font-size:12px;">A;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 53</span>                 pp[tot++]=Intersect(seg.s,seg.e,p[i],p[pn-<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span><span style="line-height:1.5;font-size:12px;">],A);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 54</span> <span style="line-height:1.5;font-size:12px;">            }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 55</span>             <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">if</span>(i!=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>&amp;&amp;!outside(seg,p[i-<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span><span style="line-height:1.5;font-size:12px;">])) {
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 56</span>                 B=<span style="line-height:1.5;font-size:12px;">A;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 57</span>                 pp[tot++]=Intersect(seg.s,seg.e,p[i],p[i-<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span><span style="line-height:1.5;font-size:12px;">],A);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 58</span> <span style="line-height:1.5;font-size:12px;">            }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 59</span>             <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">if</span>(!outside(seg,p[i+<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span>])) {<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">当前p[i]p[i+1]和seg的交点(因为我们已经令p[最后一个的后一个]=p[0]所以不必特殊处理)</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 60</span>                 B=<span style="line-height:1.5;font-size:12px;">A;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 61</span>                 pp[tot++]=Intersect(seg.s,seg.e,p[i],p[i+<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span><span style="line-height:1.5;font-size:12px;">],A);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 62</span> <span style="line-height:1.5;font-size:12px;">            }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 63</span> <span style="line-height:1.5;font-size:12px;">        }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 64</span> <span style="line-height:1.5;font-size:12px;">    }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 65</span>     pp[tot]=pp[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>];<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">特殊处理尾部</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 66</span>     pn=tot;memcpy(st,pp,<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">sizeof</span>(pp));<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">更新p[]和pn</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 67</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> dist(A,B);<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">返回割痕长度</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 68</span> <span style="line-height:1.5;font-size:12px;">}
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 69</span> <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">int</span><span style="line-height:1.5;font-size:12px;"> main(){
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 70</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">int</span><span style="line-height:1.5;font-size:12px;"> i;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 71</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">while</span>(scanf(<span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">%lf%lf</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span>,&amp;W,&amp;H)!=<span style="line-height:1.5;font-size:12px;">EOF){
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 72</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> ans=<span style="line-height:1.5;font-size:12px;">1e20;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 73</span>         st[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">4</span>]=st[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>]=Point(<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>,<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>);<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">tmp[100]是用来保存原来矩形凸包外四个顶点的，</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 74</span>         st[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span>]=Point(<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>,H);      <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">st[100]是切割过程中凸包的顶点</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 75</span>         st[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">2</span>]=Point(W,H);      <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">因此对于每种切割方案，刚开始都要将st设为原始矩形凸包，这也是tmp存在的原因</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 76</span>         st[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">3</span>]=Point(W,<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span><span style="line-height:1.5;font-size:12px;">);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 77</span>         memcpy(tmp,st,<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">sizeof</span><span style="line-height:1.5;font-size:12px;">(st));
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 78</span>         scanf(<span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">%d</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span>,&amp;n);Seg ts[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">100</span><span style="line-height:1.5;font-size:12px;">];
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 79</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">for</span>(i=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>;i&lt;n;i++<span style="line-height:1.5;font-size:12px;">) {
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 80</span>             scanf(<span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">%lf%lf</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span>,&amp;p[i].x,&amp;<span style="line-height:1.5;font-size:12px;">p[i].y);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 81</span>             a[i]=i;<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">0、1、2.....后面对其全排枚举实现所有切割方法的暴力枚举</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 82</span>         }p[n]=p[<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span><span style="line-height:1.5;font-size:12px;">];
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 83</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">for</span>(i=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>;i&lt;n;i++) ts[i].s=p[i],ts[i].e=p[i+<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">1</span><span style="line-height:1.5;font-size:12px;">];
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 84</span>         <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">do</span><span style="line-height:1.5;font-size:12px;">{
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 85</span>             <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">double</span> tlen=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>;<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">切割长度</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 86</span>             memcpy(st,tmp,<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">sizeof</span><span style="line-height:1.5;font-size:12px;">(tmp));
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 87</span>             pn=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">4</span>;<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">pn和st[100]一样是计算过程中的量(对于每种切割方案，其开始要更新为原来的，其过程要变化，pn即凸包st的点数)</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 88</span>             <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">for</span>(i=<span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span>;i&lt;n;i++){<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">按照获得的全排序列切割</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 89</span>                 tlen+=<span style="line-height:1.5;font-size:12px;">CUT(ts[a[i]],st);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 90</span> <span style="line-height:1.5;font-size:12px;">            }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 91</span>             ans=min(ans,tlen);<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">求出最小值，保存在ans里</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 92</span>         }<span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">while</span>(next_permutation(a,a+n));<span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">//</span><span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">暴力枚举所有情况next_permutation(a,a+n)是将数组全排列找出</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 93</span>         printf(<span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">Minimum total length = %.3lf\n</span><span style="line-height:1.5;color:rgb(128,0,0);font-size:12px;">"</span><span style="line-height:1.5;font-size:12px;">,ans);
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 94</span> <span style="line-height:1.5;font-size:12px;">    }
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 95</span>     <span style="line-height:1.5;color:rgb(0,0,255);font-size:12px;">return</span> <span style="line-height:1.5;color:rgb(128,0,128);font-size:12px;">0</span><span style="line-height:1.5;font-size:12px;">;
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 96</span> <span style="line-height:1.5;font-size:12px;">}
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 97</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">/*</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 98</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">线的交点
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;"> 99</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">1&gt;直线可以用直线上一点P0和方向向量v来表示:直线上所有点P满足P=P0+t*v,其中t为参数;如果已知直线上的2个不同的点A、B，则方向向量
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">100</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">为B-A,所以参数方程为A+(B-A)*t;参数方程可以方便的表示出直线射线和线段，区别仅在于t的范围：直线t无范围，射线t&gt;0,线段t在0~1之间
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">101</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">2&gt;直线交点：设直线分别为P+t*v,Q+t*w,u=PQ,交点在第一条直线上的参数为t1、在第二条直线上的参数为t2,则x、y的坐标可以列出一个方程，
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">102</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">截得：t1=cross(w,u)/cross(v,w),t2=cross(v,u)/cross(v,w),前提要确保分母不为0!!
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">103</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">*/</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">104</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">/*</span>
<span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">105</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">在STL中，除了next_permutation外，还有一个函数prev_permutation，两者都是用来计算排列组合的函数。
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">106</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">前者是求出下一个排列组合，而后者是求出上一个排列组合。所谓“下一个”和“上一个”，书中举了一个
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">107</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">简单的例子：对序列 {a, b, c}，每一个元素都比后面的小，按照字典序列，固定a之后，a比bc都小，c比b大，
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">108</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">它的下一个序列即为{a, c, b}，而{a, c, b}的上一个序列即为{a, b, c}，同理可以推出所有的六个序列为：
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">109</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">{a, b, c}、{a, c, b}、{b, a, c}、{b, c, a}、{c, a, b}、{c, b, a}，其中{a, b, c}没有上一个元素，
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">110</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">{c, b, a}没有下一个元素。
</span><span style="line-height:1.5;color:rgb(0,128,128);font-size:12px;">111</span> <span style="line-height:1.5;color:rgb(0,128,0);font-size:12px;">*/</span></pre> 
       <div class="cnblogs_code_toolbar">
        <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(51,51,51);text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
       </div> 
      </div> 
      <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;">&nbsp;</p> 
      <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;"><br></p> 
      <p style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;font-size:15px;line-height:1.5;"><br></p> 
      <p style="line-height:1.5;"><font>本文转自beautifulzzzz博客园博客，原文链接：http://www.cnblogs.com/zjutlitao/p/3526893.html</font><span style="font-family:verdana, 'ms song', '微软雅黑', Arial, '微软雅黑', Helvetica, sans-serif;">，如需转载请自行联系原作者</span></p> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
