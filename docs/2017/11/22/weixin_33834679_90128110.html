<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>KMP(Knuth-Morris-Pratt)算法 « NotBeCN</title>
  <meta name="description" content="             一、朴素匹配算法        也就是暴力匹配算法。设匹配字符串的长度为n，模式串的长度为m，在最坏情况下，朴字符串匹配算法执行时间为O((n - m + 1)m)。    假设m = n / 2， 那么该算法的复杂度就是Θ(n ^ 2)。因为不须要预处理。朴素字符串匹配算法执行时间即为...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/22/weixin_33834679_90128110.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">KMP(Knuth-Morris-Pratt)算法</h1>
    <p class="post-meta">Nov 22, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">一、朴素匹配算法</span></h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:12px;">也就是暴力匹配算法。设匹配字符串的长度为n，模式串的长度为m，在最坏情况下，朴字符串匹配算法执行时间为O((n - m + 1)m)。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设m = n / 2， 那么该算法的复杂度就是<strong><span style="line-height:1.8;font-size:12px;">Θ(n ^ 2)</span></strong>。因为不须要预处理。朴素字符串匹配算法执行时间即为其匹配时间。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:12px;">strstr()函数就能够用这种方法实现，虽然效率不高：</span></p> 
   <pre><code class="language-cpp">//strstr函数
char *strStr(const char *str, const char *substr) {
	if (substr == NULL || str == NULL)
		return NULL;
	if (!*substr)
		return const_cast&lt;char*&gt;(str);
	const char *p1 = str;
	const char *p2 = substr;
	const char *p1_advance = str;
	//p1_advance指针前进strlen(substr)-1位
	//由于当str中还未匹配的位数小于substr的长度时，肯定不可能再匹配成功了
	for (p2 = substr + 1; *p2; ++p2)
		++p1_advance;

	for (p1 = str; *p1_advance; p1_advance++) {
		char *p1_old = (char *)p1;
		p2 = substr;
		while (*p1 &amp;&amp; *p2 &amp;&amp; *p1 == *p2) {
			++p1;
			++p2;
		}
		if (!*p2)
			return p1_old;
		p1 = p1_old + 1;
	}
	return NULL;
}

int main() {
	char str[100] = {'\0'};
	char substr[100] = {'\0'};
	scanf("%s %s", str, substr);
	if (strStr(str, substr) != NULL)
		printf("true\n");
	else
		printf("false\n");
}&lt;/span&gt;</code></pre> 
   <span style="line-height:1.8;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:12px;"><br></span>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></span> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">二、KMP算法</span></h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">參考文章：<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html</a></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:12px;">July的文章把该算法讲得挺透彻了：<a href="http://blog.csdn.net/v_JULY_v/article/details/7041827#t3" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">KMP算法</a>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:12px;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设匹配字符串的长度为n，模式串的长度为m。该算法的匹配时间为<span style="line-height:1.8;">Θ(n)，用到了一个辅助函数GetNext()，它在</span></strong></span><span style="line-height:1.8;font-size:12px;"><strong><span style="line-height:1.8;">Θ(m)时间内依据模式预先计算出来，而且存储在数组next[0...m]中。模式的前缀函数GetNext包括模式与其自身的偏移进行匹配的信息。</span></strong></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>这些信息可用于在朴素的字符串匹配算法中避免对没用的偏移进行检測。KMP利用模式串中已知的匹配信息。不再把搜索位置移动到比較过的位置（即不做没用的匹配）。这样提高了效率。</strong></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">KMP完整代码例如以下：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <pre><code class="language-cpp">void GetNext(char* pattern,int next[]) {  
	int k = -1;  
	int j = 0;  
	int length_pattern = strlen(pattern);  
	next[0] = -1;  
	while (j &lt; length_pattern - 1) {  
		//p[k]表示前缀。p[j]表示后缀  
		if (k == -1 || pattern[j] == pattern[k]) {  
			++k;  
			++j;  
			next[j] = k;  
		}  
		else
			k = next[k];
	}  
}

int KmpSearch(char* text, char* pattern) {  
	int i = 0;  
	int j = 0;  
	int length_text = strlen(text);  
	int length_pattern = strlen(pattern);
	int *next = new int[length_pattern];
	GetNext(pattern, next);

	for (int i = 0; i &lt; length_pattern; ++i) 
		cout &lt;&lt; next[i] &lt;&lt; " ";
	cout &lt;&lt; endl;

	while (i &lt; length_text &amp;&amp; j &lt; length_pattern) {  
		//①假设j = -1,或者当前字符匹配成功(即text[i] == pattern[j]),令i++。j++      
		if (j == -1 || text[i] == pattern[j]) {  
			++i;
			++j;
		}
		else
			//②假设j != -1,且当前字符匹配失败(即text[i] != pattern[j]),
			//则令i不变,j = next[j]。next[j]即为j所相应的next值        
			j = next[j]; 
	}  
	delete[] next;
	if (j == length_pattern)  
		return i - j;  
	else  
		return -1;  
}  

//int main() {
//	char str[100] = {'\0'};
//	char substr[100] = {'\0'};
//	scanf("%s %s", str, substr);
//	for (int i = 0 ; i &lt; 10; ++i)
//		cout &lt;&lt; substr[i] &lt;&lt; " ";
//	cout &lt;&lt; endl;
//	cout &lt;&lt; KmpSearch(str, substr) &lt;&lt; endl;
//}</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">因为须要依据自己的理解对文章内容进行标注，所以将july的文章摘录例如以下：<br></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">-----------------------下面为july文章--------------------------------<br></h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">从头到尾彻底理解KMP</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">作者：July</span>
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">时间：最初写于2011年12月，2014年7月21日晚10点 所有删除重写成此文，随后的半个多月不断重复改进。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t1" style="border-bottom:1px dotted rgb(51,51,51);"></a>1. 引言</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 本KMP原文最初写于2年多前的2011年12月，因当时初次接触KMP，思路混乱导致写也写得混乱。所以一直想找机会又一次写下KMP，但苦于一直以来对KMP的理解始终不够，故才迟迟没有改动本文。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 然最近因在北京开了个<a href="http://www.julyedu.com/course/index/category/algorithm.html#m10" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">算法班</a>。专门解说数据结构、面试、算法，才再次细致回想了这个KMP，在综合了一些网友的理解、以及跟我一起讲算法的两位讲师朋友曹博、邹博的理解之后，写了9张PPT，发在<a href="http://weibo.com/1580904460/BeCCYrKz3#_rnd1405961034764" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">微博</a>上。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">随后，一不做二不休。索性将PPT上的内容整理到了本文之中（<span style="line-height:1.8;font-size:12px;">后来文章越写越完整。所含内容早已不再是九张PPT 那样简单了</span>）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; KMP本身不复杂，但网上绝大部分的文章（包含本文的2011年版本号）把它讲混乱了。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">以下。咱们从暴力匹配算法讲起，随后阐述KMP的流程 步骤、next 数组的简单求解 递推原理 代码求解。接着基于next 数组匹配。谈到有限状态自己主动机。next 数组的优化，KMP的时间复杂度分析。最后简要介绍两个KMP的扩展算法。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 全文力图给你一个最为完整最为清晰的KMP，希望很多其它的人不再被KMP折磨或纠缠，不再被一些混乱的文章所混乱。有何疑问。欢迎随时留言评论。thanks。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t2" style="border-bottom:1px dotted rgb(51,51,51);"></a>2. 暴力匹配算法</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 如果如今我们面临这样一个问题：有一个文本串S。和一个模式串P，如今要查找P在S中的位置。怎么查找呢？</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 如果用暴力匹配的思路，并如果如今文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;">假设当前字符匹配成功（即S[i] == P[j]），则i++，j++。继续匹配下一个字符；</li> 
    <li style="list-style:disc;">假设失配（即S[i]! = P[j]），令i = i - (j - 1)。j = 0。 <p></p> <p>相当于每次匹配失败时。i 回溯。j 被置为0。</p> <p></p> </li> 
   </ul>
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 理清楚了暴力匹配算法的流程及内在的逻辑，咱们能够写出暴力匹配的代码，例如以下：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div class="dp-highlighter bg_cpp" style="font-family:Consolas, 'Courier New', Courier, mono, serif;font-size:12px;"> 
     <ol style="border:none;color:rgb(92,92,92);">
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);"><span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;ViolentMatch(</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;s,&nbsp;</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;p)&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">{&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;sLen&nbsp;=&nbsp;strlen(s);&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;pLen&nbsp;=&nbsp;strlen(p);&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">while</span><span style="line-height:1.8;border:none;">&nbsp;(i&nbsp;&lt;&nbsp;sLen&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;pLen)&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(s[i]&nbsp;==&nbsp;p[j])&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//①假设当前字符匹配成功（即S[i]&nbsp;==&nbsp;P[j]），则i++，j++&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//②假设失配（即S[i]!&nbsp;=&nbsp;P[j]），令i&nbsp;=&nbsp;i&nbsp;-&nbsp;(j&nbsp;-&nbsp;1)。j&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;i&nbsp;-&nbsp;j&nbsp;+&nbsp;1;&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//匹配成功，返回模式串p在文本串s中的位置。否则返回-1</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;==&nbsp;pLen)&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">return</span><span style="line-height:1.8;border:none;">&nbsp;i&nbsp;-&nbsp;j;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">return</span><span style="line-height:1.8;border:none;">&nbsp;-1;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">}&nbsp;&nbsp;</span></li> 
     </ol>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 举个样例。假设给定文本串S“BBC ABCDAB ABCDABCDABDE”。和模式串P“ABCDABD”，如今要拿模式串P去跟文本串S匹配，整个步骤例如以下所看到的：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Comic Sans MS';">1.</span></em>&nbsp;S[0]为B。P[0]为A，不匹配，运行第②条指令：“假设失配（即S[i]! = P[j]），令i = i - (j - 1)。j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1。j=0）</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140723224710203" alt="" style="border:0px;">
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<span style="line-height:1.8;font-family:'Courier New';"><em>2</em></span>. S[1]跟P[0]还是不匹配，继续运行第②条指令：“假设失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的运行“令i = i - (j - 1)。j = 0”，i从2变到4。j一直为0）</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213551553" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;</span>
   <span style="line-height:1.8;color:rgb(51,51,51);font-size:14px;font-family:'Comic Sans MS';"><em>3</em></span>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">. 直到S[4]跟P[0]匹配成功（i=4，j=0）。此时依照上面的暴力匹配算法的思路，转而运行第①条指令：“假设当前字符匹配成功（即S[i] == P[j]），则i++。j++”，可得S[i]为S[5]。P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1）</span>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p>&nbsp; &nbsp; &nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213602848" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;</span>
   <em style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'Comic Sans MS';">4</span></em>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">. S[5]跟P[1]匹配成功，继续运行第①条指令：“假设当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2）。如此进行下去</span>
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p>&nbsp; &nbsp;&nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213343578" alt="" style="border:0px;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<span style="line-height:1.8;font-family:'Comic Sans MS';"><em>5</em></span>. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6）。由于不匹配。又一次运行第②条指令：“假设失配（即S[i]! = P[j]）。令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0）</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p>&nbsp; &nbsp; &nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213353687" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;</span>
   <em style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'Comic Sans MS';">6</span></em>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">. 至此，我们能够看到，假设依照暴力匹配算法的思路，虽然之前文本串和模式串已经分别匹配到了S[9]、P[5]，但由于S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="margin-left:40px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;border:none;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213631208" alt="" style="border:0px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 而S[5]肯定跟P[0]失配。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">为什么呢？由于在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A。即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必定会导致失配。那有没有一种算法。让i 不往回退，仅仅须要移动j 就可以呢？<br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 答案是肯定的。这样的算法就是本文的主旨KMP算法。它利用之前已经部分匹配这个有效信息。保持i 不回溯。通过改动j 的位置。让模式串尽量地移动到有效的位置。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t3" style="border-bottom:1px dotted rgb(51,51,51);"></a>3. KMP算法</h2> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t4" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.1 定义</h3> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp;&nbsp;Knuth-Morris-Pratt 字符串查找算法。简称为 “KMP算法”，经常使用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 
    <p></p> 
    <p></p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 以下先直接给出KMP的算法流程（
    <span style="line-height:1.8;"><span style="line-height:1.8;font-family:'Microsoft YaHei';">假设感到一点点不适，没关系。坚持下，稍后会有详细步骤及解释。越往后看越会柳暗花明</span></span>）：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;">如果如今文本串S匹配到 i 位置，模式串P匹配到 j 位置 
      <ul>
       <li style="list-style:disc;">假设j = -1，或者当前字符匹配成功（即S[i] == P[j]）。都令i++，j++，继续匹配下一个字符；</li> 
       <li style="list-style:disc;">假设j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。 <p></p> <p>此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</p> 
        <ul>
         <li style="list-style:disc;">换言之，当匹配失败时。模式串向右移动的位数为：失配字符所在位置 - 失配字符相应的next 值（next 数组的求解会在下文的<a href="http://blog.csdn.net/v_july_v/article/details/7041827#t9" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">3.3.3节</a>中具体阐述）。即<span style="line-height:1.8;font-family:'Comic Sans MS';"><strong>移动的实际位数为：j - next[j]</strong></span>。且此值大于等于1。</li>
        </ul></li> 
      </ul></li>
    </ul> &nbsp; &nbsp; 非常快，你也会意识到
    <strong>next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的同样前缀后缀。比如假设next [j] = k，代表j 之前的字符串中有最大长度为<em>k</em>&nbsp;的同样前缀后缀。</strong> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp;&nbsp;
    <strong>&nbsp; 此也意味着在某个字符失配时，该字符相应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。假设next [j] 等于0或-1。则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0。代表下次匹配跳到j 之前的某个字符，而不是跳到开头。且详细跳过了k 个字符。 </strong>
    <p><strong></strong></p> 
    <strong> </strong> 
    <p><strong></strong></p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 转换成代码表示，则是：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div class="dp-highlighter bg_cpp" style="font-family:Consolas, 'Courier New', Courier, mono, serif;font-size:12px;"> 
     <ol style="border:none;color:rgb(92,92,92);">
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);"><span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;KmpSearch(</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;s,&nbsp;</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;p)&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">{&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;sLen&nbsp;=&nbsp;strlen(s);&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;pLen&nbsp;=&nbsp;strlen(p);&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">while</span><span style="line-height:1.8;border:none;">&nbsp;(i&nbsp;&lt;&nbsp;sLen&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;pLen)&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//①假设j&nbsp;=&nbsp;-1，或者当前字符匹配成功（即S[i]&nbsp;==&nbsp;P[j]），都令i++，j++&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;==&nbsp;-1&nbsp;||&nbsp;s[i]&nbsp;==&nbsp;p[j])&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//②假设j&nbsp;!=&nbsp;-1，且当前字符匹配失败（即S[i]&nbsp;!=&nbsp;P[j]）。则令&nbsp;i&nbsp;不变。j&nbsp;=&nbsp;next[j]&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//next[j]即为j所相应的next值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;next[j];&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;==&nbsp;pLen)&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">return</span><span style="line-height:1.8;border:none;">&nbsp;i&nbsp;-&nbsp;j;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">return</span><span style="line-height:1.8;border:none;">&nbsp;-1;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">}&nbsp;&nbsp;</span></li> 
     </ol>
    </div> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 继续拿之前的样例来说。当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是运行第②条指令：“假设j != -1。且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，即j 从6变到2（后面我们将求得P[6]。即字符D相应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] =&nbsp;6-2 = 4）。 
    <p></p> 
    <p></p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <blockquote style="background:none;border:none;"> 
     <div>
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213353687" alt="" style="border:0px;">
     </div> 
    </blockquote>&nbsp; &nbsp; 向右移动4位后。S[10]跟P[2]继续匹配。为什么要向右移动4位呢。由于移动4位后，模式串中又有个“AB”能够继续跟S[8]S[9]相应着，从而不用让i 回溯。
    <strong>相当于在除去字符D的模式串子串中寻找同样的前缀和后缀，然后依据前缀后缀求出next 数组，最后基于next 数组进行匹配</strong>（不关心next 数组是怎么求来的，仅仅想看匹配过程是咋样的，可直接跳到下文
    <a href="http://blog.csdn.net/v_july_v/article/details/7041827#t10" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">3.3.4节</a>）。
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <blockquote style="background:none;border:none;"> 
     <div>
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223539765" alt="" style="border:0px;">
     </div> 
    </blockquote> 
    <h3 style="color:rgb(0,0,0);font-size:16px;line-height:1.5;"> <a name="t5" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.2 步骤</h3> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;">①</span>寻找前缀后缀最长公共元素长度 
      <ul>
       <li style="list-style:disc;">对于P = p0 p1 ...pj-1 pj。寻找模式串P中长度最大且相等的前缀和后缀。假设存在<span style="line-height:1.8;font-family:'Comic Sans MS';">p0 p1 ...pk-1 pk = pj- k pj-k+1...pj-1 pj。那么在<span style="line-height:1.8;">包括pj</span>的模式串中有最大长度为k+1的同样前缀后缀</span>。 <p></p> <p>举个样例，假设给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度例如以下表格所看到的：</p> </li>
      </ul></li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p style="margin-left:40px;border:none;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140819173639786" alt="" style="border:0px;"></p> 
    <p style="margin-left:40px;border:none;">比方对于字符串aba来说。它有长度为1的同样前缀后缀a。而对于字符串abab来说，它有长度为2的同样前缀后缀ab（同样前缀后缀的长度为k + 1。k + 1 = 2）。<br></p> 
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;">②</span>求next数组 
      <ul>
       <li style="list-style:disc;">next 数组考虑的是除当前字符外的最长同样前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，仅仅要稍作变形就可以：将第①步骤中求得的值总体右移一位，然后初值赋为-1，例如以下表格所看到的：</li>
      </ul></li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p style="margin-left:40px;border:none;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140819173649739" alt="" style="border:0px;"></p> 
    <p style="margin-left:40px;border:none;">比方对于aba来说。第3个字符a之前的字符串ab中有长度为0的同样前缀后缀，所以第3个字符a相应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的同样前缀后缀a，所以第4个字符b相应的next值为1（同样前缀后缀的长度为k，k = 1）。</p> 
    <p><br></p> 
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;">③依据next数组进行匹配</span> 
      <ul>
       <li style="list-style:disc;">匹配失配，j = next [j]。模式串向右移动的位数为：j - next[j]。换言之。当模式串的后缀pj-k pj-k+1, ..., pj-1 跟文本串si-k si-k+1, ..., si-1匹配成功，但pj 跟si匹配失败时，由于<span style="line-height:1.8;font-family:'Comic Sans MS';">next[j] = k，相当于在<span style="line-height:1.8;">不包括pj</span>的模式串中有最大长度为k 的同样前缀后缀，即p0 p1 ...pk-1 = pj-k pj-k+1...pj-1</span>，故令j = next[j]，从而让模式串右移j - next[j] 位。使得模式串的前缀p0 p1, ..., pk-1相应着文本串 si-k si-k+1, ..., si-1，而后让pk 跟si 继续匹配。 <p></p> <p>例如以下图所看到的：</p> </li>
      </ul></li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div> 
     <div> 
      <div>
       <blockquote style="background:none;border:none;">
        <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140812223633281" alt="" style="border:0px;">
       </blockquote>
      </div> 
     </div> 
    </div> 
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div>
     <br>
    </div> 
    <div>
     &nbsp; &nbsp; 综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时。下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。 
     <p></p> 
     <p></p> 
    </div> 
    <div>
     &nbsp; &nbsp; 接下来，分别详细解释上述3个步骤。
    </div> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t6" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3 解释</h3> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t7" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.1 寻找最长前缀后缀</h4> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 假设给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别例如以下表格所看到的：
    <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140725231726921" alt="" style="border:0px;">
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 也就是说，原模式串子串相应的各个前缀后缀的公共元素的最大长度表为（
    <strong>下简称《最大长度表》</strong>）：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <blockquote style="background:none;border:none;"> 
     <div>
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721222801918" alt="" style="border:0px;">
     </div> 
     <div>
      <br>
     </div> 
    </blockquote> 
    <h4 style="color:rgb(0,0,0);"> <a name="t8" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.2 基于《最大长度表》匹配</h4> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <span style="line-height:1.8;font-family:'Microsoft YaHei';"><strong>&nbsp; &nbsp;</strong></span>
    <span style="line-height:1.8;font-family:Arial;">&nbsp;由于模式串中首尾可能会有反复的字符。故可得出下述结论：</span> 
   </div> 
   <div style="color:rgb(51,51,51);font-size:14px;font-weight:bold;">
    <blockquote style="background:none;border:none;"> 
     <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;">
      <tbody>
       <tr>
        <td style="border:1px solid #C0C0C0;border-collapse:collapse;">失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所相应的最大长度值</td>
       </tr>
      </tbody>
     </table>
    </blockquote>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Arial;">&nbsp; &nbsp; 以下，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。假设给定文本串“BBC ABCDAB ABCDABCDABDE”。和模式串“ABCDABD”，如今要拿模式串去跟文本串匹配，<span style="line-height:1.8;">例如以下图所看到的：</span></span></span></p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140723224710203" alt="" style="border:0px;"></p> 
   </blockquote> 
   <em style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></em>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></span> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';">1</span>. 由于模式串中的字符A跟文本串中的字符B、B、C、空格一開始就不匹配。所以不必考虑结论，直接将模式串不断的右移一位就可以。直到模式串中的字符A跟文本串的第5个字符A匹配成功：</li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213602848" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;"><em><span style="line-height:1.8;font-family:'Courier New';">2</span></em><span style="line-height:1.8;font-family:'Comic Sans MS';">.</span></span>继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串须要向右移动。但向右移动多少位呢？由于此时已经匹配的字符数为6个（ABCDAB），然后依据《最大长度表》可得失配字符D的上一位字符B相应的长度值为2。所以依据之前的结论，可知须要向右移动6 - 2 = 4 位。</li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <div> 
      <div>
       <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223809617" alt="" style="border:0px;">
      </div> 
     </div> 
    </blockquote>
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;"><em><span style="line-height:1.8;font-family:'Comic Sans MS';">3</span></em></span>. 模式串向右移动4位后。发现C处再度失配，由于此时已经匹配了2个字符（AB），且上一位字符B相应的最大长度值为0，所以向右移动：2 - 0 =2 位。 <p></p> <p></p> </li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div> 
     <div>
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223539765" alt="" style="border:0px;">
     </div> 
    </div> 
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div> 
     <ul>
      <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';"><em>4</em></span>. A与空格失配，向右移动1 位。</li>
     </ul>
    </div> 
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div>
     <blockquote style="background:none;border:none;"> 
      <div>
       <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223823548" alt="" style="border:0px;">
      </div> 
     </blockquote>
    </div> 
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';"><em>5</em></span>. 继续比較。发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B相应的最大长度2，即向右移动6 - 2 = 4 位。</li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div> 
     <div>
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223558140" alt="" style="border:0px;">
     </div> 
    </div> 
   </blockquote> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';"><em>6</em></span>. 经历第5步后。发现匹配成功，过程结束。</li>
    </ul>
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223611515" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 通过上述匹配过程能够看出，问题的关键就是寻找模式串中最大长度的同样前缀和后缀，找到了模式串中每一个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。</span> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t9" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.3 依据《最大长度表》求next 数组</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 由上文。我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721230517324" alt="" style="border:0px;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 并且。依据这个表能够得出下述结论</p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;">失配时。模式串向右移动的位数为：已匹配<span style="line-height:1.8;">字符数</span>&nbsp;- 失配字符的上一位字符所相应的最大长度值</li>
   </ul>
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 上文利用这个表和结论进行匹配时。我们发现。当匹配到一个字符失配时。事实上不是必需考虑当前失配的字符。更何况我们每次失配时。都是看的失配字符的上一位字符相应的最大长度值。如此，便引出了next 数组。
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 给定字符串“ABCDABD”，可求得它的next 数组例如以下：
   </div> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721230250468" alt="" style="border:0px;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 把next 数组跟之前求得的最大长度表对照后，不难发现。<strong>next 数组相当于“最大长度值” 总体向右移动一位，然后初始值赋为-1</strong>。意识到了这一点，你会惊呼原来next 数组的求解居然如此简单：就是找最大对称长度的前缀后缀，然后总体右移一位，初值赋为-1（当然。你也能够直接<span style="line-height:1.8;color:rgb(255,0,0);">计算某个字符相应的next值，就是看这个字符之前的字符串中有多大长度的同样前缀后缀</span>）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别例如以下：</p> 
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728110939595" alt="" style="border:0px;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 依据最大长度表求出了next 数组后。从而有</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;">
     <tbody>
      <tr>
       <td style="border:1px solid #C0C0C0;border-collapse:collapse;">失配时，模式串向右移动的位数为：失配字符所在<span style="line-height:1.8;">位置</span>&nbsp;- 失配字符相应的next 值</td>
      </tr>
     </tbody>
    </table>
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 而后，你会发现。不管是基于《最大长度表》的匹配。还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？由于：</p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;">依据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值</li> 
    <li style="list-style:disc;">而依据《next 数组》。失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符相应的next 值 
     <ul>
      <li style="list-style:disc;">当中，从0開始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符相应的next 值 =&nbsp;失配字符的上一位字符的最大长度值，两相比較，结果必定全然一致。</li>
     </ul></li> 
   </ul>
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 所以，你能够把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是能够的，差别只是是怎么用的问题。</p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t10" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.4 通过代码递推计算next 数组</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 接下来，咱们来写代码求下next 数组。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 基于之前的理解，可知计算next 数组的方法能够採用递推：</p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <em><span style="line-height:1.8;font-family:'Comic Sans MS';">1</span></em>.&nbsp;<span style="line-height:1.8;color:rgb(0,153,0);">假设<strong>对于值k。已有p0 p1, ..., pk-1 = pj-k pj-k+1, ..., pj-1，相当于next[j] = k</strong>。</span> 
     <ul>
      <li style="list-style:disc;"> <span style="line-height:1.8;color:rgb(0,153,0);">此意味着什么呢？究其本质，<strong>next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的同样前缀和后缀</strong>。 </span><p></p> <p>有了这个next 数组。在KMP匹配中。当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配。相当于模式串向右移动j - next[j] 位。</p> </li>
     </ul></li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p style="margin-left:40px;border:none;">举个样例，例如以下图，依据模式串“ABCDABD”的next 数组可知失配位置的字符D相应的next 值为2。代表字符D前有长度为2的同样前缀和后缀（这个同样的前缀后缀即为“AB”），失配后，模式串须要向右移动j - next [j] = 6 - 2 =4位。</p> 
     <p></p> 
     <p style="margin-left:40px;border:none;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223809617" alt="" style="border:0px;"></p> 
     <p style="margin-left:40px;border:none;">向右移动4位后，模式串中的字符C继续跟文本串匹配。</p> 
    </blockquote>
   </blockquote> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;">
     <blockquote style="background:none;border:none;">
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223539765" alt="" style="border:0px;">
     </blockquote>
    </blockquote>
   </blockquote> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <strong><span style="line-height:1.8;font-family:'Courier New';">2</span></strong>. 以下的问题是：<span style="line-height:1.8;color:rgb(0,153,0);">已知next [0, ..., j]，怎样求出next [j + 1]呢？</span> </li>
   </ul>
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 对于P的前j+1个序列字符：<br></p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;">若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</li> 
    <li style="list-style:disc;">若p[k ] ≠ p[j]，假设此时p[&nbsp;next[k]&nbsp;] == p[j ]，则next[ j + 1 ] = &nbsp;next[k]&nbsp;+ 1，否则继续递归前缀索引k = next[k]，而后反复此过程。 <p></p> <p>&nbsp;相当于在字符p[j+1]之前不存在长度为k+1的前缀"p0 p1, …, pk-1 pk"跟后缀“pj-k pj-k+1, …, pj-1 pj"相等，那么是否可能存在还有一个值t+1 &lt; k+1。使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？假设存在。那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, ..., k, ..., j]）进行P串前缀跟P串后缀的匹配。</p> <p></p> </li> 
   </ul>
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp;一般的文章或教材可能就此一笔带过，但大部分的刚開始学习的人可能还是不能非常好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 例如以下图所看到的。假定给定模式串ABCDABCE。且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，能够看出k为2），现要求next [j + 1]等于多少？由于pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（能够看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的同样前缀后缀。 
    <p></p> 
    <p></p> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140729182154066" alt="" style="border:0px;">
     <br>
    </blockquote>
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 但
    <strong><span style="line-height:1.8;font-family:'Comic Sans MS';">假设pk != pj 呢</span></strong>？说明“p0 pk-1 pk” &nbsp;≠ “pj-k pj-1 pj”。换言之。当pk != pj后，字符E前有多大长度的同样前缀后缀呢？非常明显，由于C不同于D，所以ABC 跟 ABD不同样，即字符E前的模式串没有长度为k+1的同样前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们仅仅能去寻找长度更短一点的同样前缀后缀。
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <blockquote style="background:none;border:none;"> 
     <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140729181940812" alt="" style="border:0px;">
     <br>
    </blockquote> 
    <div> 
     <div>
      &nbsp; &nbsp; 结合上图来讲，若能
      <strong><span style="line-height:1.8;font-family:'Comic Sans MS';">在前缀</span></strong>
      <span style="line-height:1.8;font-family:'Comic Sans MS';"><strong>“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj。且满足p0 pk'-1 pk' = pj-k' pj-1 pj，则最大同样的前缀后缀长度为k' + 1</strong></span>，从而next [j + 1] = k’ + 1 = next [k' ] + 1。否则前缀中没有D。则代表没有同样的前缀后缀。next [j + 1] = 0。
     </div> 
     <div>
      &nbsp; &nbsp;&nbsp;
      <span style="line-height:1.8;font-family:Arial;">那<span style="line-height:1.8;color:rgb(255,0,0);">为何递归前缀索引k = next[k]，就能找到长度更小的同样前缀后缀呢</span>？这又归根到next数组的含义。</span>
      <span style="line-height:1.8;color:rgb(0,153,0);"><span style="line-height:1.8;font-family:'Comic Sans MS';"><strong>为了寻找长度同样的前缀后缀，我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配。假设pk 跟pj 失配。下一步就是用p[next[k]] 去跟pj 继续匹配。假设p[ next[k] ]跟pj还是不匹配。则下一步用p[ next[ next[k] ] ]去跟pj匹配</strong></span><span style="line-height:1.8;font-family:Arial;">。 </span></span>
      <p></p> 
      <p>相当于模式串的自我匹配，所以不断的递归k = next[k]。直到要么找到长度更小的同样前缀后缀。要么没有长度更小的同样前缀后缀。</p> 
     </div> 
     <div>
      &nbsp; &nbsp; 所以，因终于在前缀ABC中没有找到D。故E的next 值为0：
     </div> 
     <div>
      <br>
     </div> 
     <blockquote style="background:none;border:none;">
      <blockquote style="background:none;border:none;">
       模式串的后缀：AB
       <span style="line-height:1.8;">DE</span> 
      </blockquote>
     </blockquote> 
     <blockquote style="background:none;border:none;">
      <blockquote style="background:none;border:none;">
       模式串的前缀：AB
       <span style="line-height:1.8;">C</span> 
      </blockquote>
     </blockquote> 
     <blockquote style="background:none;border:none;"> 
      <blockquote style="background:none;border:none;">
       前缀右移两位： &nbsp; &nbsp;&nbsp;
       <span style="line-height:1.8;">A</span>BC
      </blockquote> 
      <blockquote style="background:none;border:none;">
       <br>
      </blockquote> 
     </blockquote> 
    </div> &nbsp; &nbsp; 读到此，有的读者可能又有疑问了，那是否能举一个能在前缀中找到字符D的样例呢？OK。咱们便来看一个能在前缀中找到字符D的样例。例如以下图所看到的：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <div>
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140809163257703" alt="" style="border:0px;">
     </div> 
    </blockquote>
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 给定模式串DABCDABDE，我们非常顺利的求得字符D之前的“DABCDAB”的各个子串的最长同样前缀后缀的长度分别为0 0 0 0 1 2 3。但当遍历到字符D，要求包含D在内的“DABCDABD”最长同样前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之。前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不同样，所以不存在长度为4的同样前缀后缀。
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 怎么办呢？既然没有长度为4的同样前缀后缀。咱们能够寻找长度短点的同样前缀后缀。终于，因在p0处发现也有个字符D，p0 = pj。所以p[j]相应的长度值为1，相当于E相应的next 值为1。
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 综上，能够通过递推求得next 数组，代码例如以下所看到的：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div class="dp-highlighter bg_cpp" style="font-family:Consolas, 'Courier New', Courier, mono, serif;font-size:12px;"> 
     <ol style="border:none;color:rgb(92,92,92);">
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);"><span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">void</span><span style="line-height:1.8;border:none;">&nbsp;GetNext(</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;p,</span><span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;next[])&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">{&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;pLen&nbsp;=&nbsp;strlen(p);&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;next[0]&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;k&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">while</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;&lt;&nbsp;pLen&nbsp;-&nbsp;1)&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//p[k]表示前缀，p[j]表示后缀</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(k&nbsp;==&nbsp;-1&nbsp;||&nbsp;p[j]&nbsp;==&nbsp;p[k])&nbsp;&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++k;&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++j;&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next[j]&nbsp;=&nbsp;k;&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;&nbsp;</span></span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;next[k];&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
      <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">}&nbsp;&nbsp;</span></li> 
     </ol>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;<span style="line-height:1.8;">&nbsp;用代码又一次计算下<span style="line-height:26px;font-family:Arial;">“ABCDABD”的next 数组</span>，以验证之前通过“最长同样前缀后缀长度值右移一位。然后初值赋为-1”得到的next 数组是否正确。计算结果例如以下表格所看到的：</span></p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140812004705968" alt="" style="border:0px;"><br></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 从上述表格能够看出，不管是之前通过“最长同样前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组，还是之后通过代码递推计算求得的next 数组，结果是全然一致的。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t11" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.5 基于《next 数组》匹配</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 以下，我们来基于next 数组进行匹配。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721231622000" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 还是给定</span>
   <span style="line-height:26px;color:rgb(51,51,51);font-size:14px;font-family:Arial;">文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，如今要拿模式串去跟文本串匹配。例如以下图所看到的：</span>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></span>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140723224710203" alt="" style="border:none;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 在正式匹配之前，让我们来再次回想下上文2.1节所述的KMP算法的匹配流程：</p> 
   <ul style="color:rgb(51,51,51);font-size:14px;font-family:Arial;line-height:26px;">
    <li style="list-style:disc;"> <span style="line-height:1.8;font-size:18px;"><strong>“</strong></span><span style="line-height:1.8;">如果如今文本串S匹配到 i 位置。模式串P匹配到 j 位置</span> 
     <ul>
      <li style="list-style:disc;">假设j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li> 
      <li style="list-style:disc;"> <span style="line-height:1.8;">假设j != -1。且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</span> 
       <ul>
        <li style="list-style:disc;"> <span style="line-height:1.8;">换言之。当匹配失败时。模式串向右移动的位数为：失配字符所在位置 - 失配字符相应的next 值，即</span><span style="line-height:1.8;font-family:'Comic Sans MS';"><strong>移动的实际位数为：j - next[j]</strong></span><span style="line-height:1.8;">。且此值大于等于1。</span><span style="line-height:1.8;font-size:18px;"><strong>”</strong></span> </li>
       </ul></li> 
     </ul></li>
   </ul>
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <em><span style="line-height:1.8;font-family:'Comic Sans MS';">1</span></em>. 最開始匹配时 
     <ul>
      <li style="list-style:disc;">P[0]跟S[0]匹配失败 
       <ul>
        <li style="list-style:disc;">所以运行“假设j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，所以j = -1，故转而运行“假设j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”，得到i = 1。j = 0，即P[0]继续跟S[1]匹配。</li>
       </ul></li> 
      <li style="list-style:disc;">P[0]跟S[1]又失配，j再次等于-1。i、j继续自增，从而P[0]跟S[2]匹配。 <p></p> <p></p> </li> 
      <li style="list-style:disc;">P[0]跟S[2]失配后，P[0]又跟S[3]匹配。</li> 
      <li style="list-style:disc;">P[0]跟S[3]再失配。直到P[0]跟S[4]匹配成功。開始运行此条指令的后半段：“假设j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++。j++”。</li> 
     </ul></li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140726213602848" alt="" style="border:0px;">
   </blockquote> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Courier New';">2</span>. P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, ...，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），因为P[6]处的D相应的next 值为<strong>2</strong>，所下面一步用<strong>P[2]</strong>处的字符C继续跟S[10]匹配，相当于向右移动：j - next[j] = 6 - 2 =4 位。 <p></p> <p></p> </li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223809617" alt="" style="border:0px;"></p> 
   </blockquote> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <em><span style="line-height:1.8;font-family:'Comic Sans MS';">3</span></em>. 向右移动4位后，P[2]处的C再次失配，因为C相应的next值为<strong>0</strong>，所下面一步用<strong>P[0]</strong>处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。</li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223539765" alt="" style="border:0px;"></p> 
   </blockquote> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';"><em>4</em></span>. 移动两位之后，A 跟空格不匹配，模式串后移1 位。</li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223823548" alt="" style="border:0px;"></p> 
   </blockquote> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';"><em>5</em></span>. P[6]处的D再次失配。由于P[6]相应的next值为<strong>2</strong>。故下一步用<strong>P[2]</strong>继续跟文本串匹配，相当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。</li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223558140" alt="" style="border:0px;">
   </blockquote> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;"> <span style="line-height:1.8;font-family:'Comic Sans MS';"><em>6</em></span>. 匹配成功，过程结束。 <p></p> <p></p> </li>
   </ul>
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140721223611515" alt="" style="border:0px;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 匹配过程一模一样。也从側面佐证了，next 数组确实是仅仅要将各个最大前缀后缀的公共元素的长度值右移一位。且把初值赋为-1 就可以。</p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t12" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.6 基于《最大长度表》与基于《next 数组》等价</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 我们已经知道。利用next 数组进行匹配失配时。模式串向右移动 j - next [ j ] 位，等价于已匹配字符数&nbsp;- 失配字符的上一位字符所相应的最大长度值。原因是：</p> 
   <ol style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:decimal;">j 从0開始计数，那么当数到失配字符时，j 的数值就是已匹配的字符数。</li> 
    <li style="list-style:decimal;">因为next 数组是由最大长度值表总体向右移动一位（且初值赋为-1）得到的，那么失配字符的上一位字符所相应的最大长度值。即为当前失配字符的next 值。 <p></p> <p></p> </li> 
   </ol>
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 但为何本文不直接利用next 数组进行匹配呢？由于next 数组不好求。而一个字符串的前缀后缀的公共元素的最大长度值非常easy求。比如若给定模式串“ababa”。要你高速口算出其next 数组，乍一看，每次求相应字符的next值时。还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的同样前缀后缀，此过程不够直接。而假设让你求其前缀后缀公共元素的最大长度，则非常easy直接得出结果：0 0 1 2 3。例如以下表格所看到的：</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140725232020608" alt="" style="border:0px;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 然后这5个数字 所有总体右移一位。且初值赋为-1，即得到其next 数组：-1 0 0 1 2。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t13" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.7 Next 数组与有限状态自己主动机</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; next 负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]位和主串匹配。就像打了张“表”。此外，next 也能够看作有限状态自己主动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是实用的。<br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140805003320486" alt="" style="border:0px;"><br></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t14" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.3.8 Next 数组的优化</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp; 行文至此。咱们全面了解了暴力匹配的思路、KMP算法的原理、流程、流程之间的内在逻辑联系，以及next 数组的简单求解（《最大长度表》总体右移一位，然后初值赋为-1）和代码求解。最后基于《next 数组》的匹配，看似洋洋洒洒。清晰透彻，但以上忽略了一个小问题。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 比方，假设用之前的next 数组方法求模式串“abab”的next 数组。可得其next 数组为-1 0 0 1（0 0 1 2总体右移一位，初值赋为-1）。当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p><img src="http://hi.csdn.net/attachment/201106/14/8394323_1308075859Zfue.jpg" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 右移2位后，b又跟c失配。其实。由于在上一步的匹配中。已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必定失配。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">问题出在哪呢？</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p>&nbsp; &nbsp;<img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必定是p[ next [j]] 跟s[i]匹配，假设p[j] = p[ next[j] ]，必定导致后一步匹配失败（由于p[j]已经跟s[i]失配。然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，非常显然。必定失配），所以<strong>不能同意p[j] = p[ next[j ]]</strong>。假设出现了p[j] = p[ next[j] ]咋办呢？假设出现了，则须要再次递归，即令next[j] = next[ next[j] ]。</p> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 所以。咱们得改动下求next 数组的代码。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <div class="dp-highlighter bg_cpp" style="font-family:Consolas, 'Courier New', Courier, mono, serif;font-size:12px;color:rgb(51,51,51);"> 
    <ol style="border:none;color:rgb(92,92,92);">
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);"><span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//优化过后的next&nbsp;数组求法</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);"><span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">void</span><span style="line-height:1.8;border:none;">&nbsp;GetNextval(</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;p,&nbsp;</span><span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;next[])&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">{&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;pLen&nbsp;=&nbsp;strlen(p);&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;next[0]&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;k&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">while</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;&lt;&nbsp;pLen&nbsp;-&nbsp;1)&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//p[k]表示前缀。p[j]表示后缀&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(k&nbsp;==&nbsp;-1&nbsp;||&nbsp;p[j]&nbsp;==&nbsp;p[k])&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++j;&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++k;&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//较之前next数组求法。修改在以下4行</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(p[j]&nbsp;!=&nbsp;p[k])&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next[j]&nbsp;=&nbsp;k;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//之前仅仅有这一行</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//由于不能出现p[j]&nbsp;=&nbsp;p[&nbsp;next[j&nbsp;]]，所以当出现时须要继续递归，k&nbsp;=&nbsp;next[k]&nbsp;=&nbsp;next[next[k]]</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next[j]&nbsp;=&nbsp;next[k];&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;=&nbsp;next[k];&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">}&nbsp;&nbsp;</span></li> 
    </ol>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 利用优化过后的next 数组求法。可知模式串“abab”的新next数组为：-1 0 -1 0。可能有些读者会问：原始next 数组是前缀后缀最长公共元素长度值右移一位。 然后初值赋为-1而得，那么优化后的next 数组怎样高速心算出呢？实际上，仅仅要求出了原始next 数组，便能够依据原始next 数组高速求出优化后的next 数组。还是以abab为例。例如以下表格所看到的：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140801160510832" alt="" style="border:0px;"></p> 
   <p style="text-indent:15.75pt;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;">仅仅要出现了<span style="line-height:1.8;font-family:Arial;">p[next[j]]&nbsp;=&nbsp;p[j]</span><span style="line-height:1.8;">的情况，则把</span><span style="line-height:1.8;font-family:Arial;">next[j]</span><span style="line-height:1.8;">的值再次递归。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">比如在求模式串“<span style="line-height:1.8;font-family:Arial;">abab</span><span style="line-height:1.8;font-family:'宋体';">”的第</span><span style="line-height:1.8;font-family:Arial;">2</span><span style="line-height:1.8;font-family:'宋体';">个</span><span style="line-height:1.8;font-family:Arial;">a</span><span style="line-height:1.8;font-family:'宋体';">的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;font-family:'宋体';">值时，假设是未优化的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;font-family:'宋体';">值的话。第</span><span style="line-height:1.8;font-family:Arial;">2</span><span style="line-height:1.8;font-family:'宋体';">个</span><span style="line-height:1.8;font-family:Arial;">a</span><span style="line-height:1.8;font-family:'宋体';">相应的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;font-family:'宋体';">值为</span><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;"><strong>0</strong></span><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;">，相当于第<span style="line-height:1.8;font-family:Arial;">2</span><span style="line-height:1.8;">个</span><span style="line-height:1.8;font-family:Arial;">a</span><span style="line-height:1.8;">失配时。下一步匹配模式串会用</span></span><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;"><strong>p[0]</strong></span><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;">处的<span style="line-height:1.8;font-family:Arial;">a</span><span style="line-height:1.8;">再次跟文本串匹配，必定失配。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">所以求第<span style="line-height:1.8;font-family:Arial;">2</span><span style="line-height:1.8;font-family:'宋体';">个</span><span style="line-height:1.8;font-family:Arial;">a</span><span style="line-height:1.8;font-family:'宋体';">的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;font-family:'宋体';">值时。须要再次递归：</span><span style="line-height:1.8;font-family:Arial;">next[2]&nbsp;=&nbsp;next[&nbsp;next[2]&nbsp;]&nbsp;=&nbsp;next[0]&nbsp;=&nbsp;-1</span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;">（</span><span style="line-height:1.8;font-size:12px;"><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;">此后，依据优化后的新next值</span><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;">可知</span></span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;">。</span><span style="line-height:1.8;font-size:12px;"><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;text-indent:15.75pt;">第<span style="line-height:1.8;font-family:Arial;">2</span>个<span style="line-height:1.8;font-family:Arial;">a</span>失配时，运行“</span><span style="line-height:1.8;font-family:Arial;letter-spacing:0pt;text-indent:15.75pt;">假设j&nbsp;=&nbsp;-1<span style="line-height:1.8;font-family:'宋体';">，或者当前字符匹配成功（即</span>S[i]&nbsp;==&nbsp;P[j]<span style="line-height:1.8;font-family:'宋体';">），都令</span>i++<span style="line-height:1.8;font-family:'宋体';">，</span>j++<span style="line-height:1.8;font-family:'宋体';">，继续匹配下一个字符</span></span><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;text-indent:15.75pt;">”</span></span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">）</span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">。同理，第</span><span style="line-height:1.8;font-family:Arial;font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">2</span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">个</span><span style="line-height:1.8;font-family:Arial;font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">b</span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">相应的</span><span style="line-height:1.8;font-family:Arial;font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">next</span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">值为</span><span style="line-height:1.8;font-family:Arial;font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">0</span><span style="line-height:1.8;font-family:'宋体';font-size:10.5pt;letter-spacing:0pt;text-indent:15.75pt;">。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="text-indent:15.75pt;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;">对于优化后的<span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;">数组能够发现一点：假设模式串的后缀跟前缀同样，那么它们的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;">值也是同样的。比如模式串</span><span style="line-height:1.8;font-family:Arial;">abcabc</span><span style="line-height:1.8;">。它的前缀后缀都是</span><span style="line-height:1.8;font-family:Arial;">abc</span><span style="line-height:1.8;">。其优化后的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;">数组为：</span><span style="line-height:1.8;font-family:Arial;">-1&nbsp;0&nbsp;0&nbsp;-1&nbsp;0&nbsp;0</span><span style="line-height:1.8;">，前缀后缀</span><span style="line-height:1.8;font-family:Arial;">abc</span><span style="line-height:1.8;">的</span><span style="line-height:1.8;font-family:Arial;">next</span><span style="line-height:1.8;">值都为</span><span style="line-height:1.8;font-family:Arial;">-1&nbsp;0&nbsp;0</span><span style="line-height:1.8;">。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';letter-spacing:0pt;font-size:10.5pt;"></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 然后引用下之前3.1节的KMP代码：</p> 
   <div class="dp-highlighter bg_cpp" style="font-family:Consolas, 'Courier New', Courier, mono, serif;font-size:12px;color:rgb(51,51,51);"> 
    <ol style="border:none;color:rgb(92,92,92);">
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);"><span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;KmpSearch(</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;s,&nbsp;</span><span class="datatypes" style="line-height:1.8;border:none;">char</span><span style="line-height:1.8;border:none;">*&nbsp;p)&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">{&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;j&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;sLen&nbsp;=&nbsp;strlen(s);&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="datatypes" style="line-height:1.8;border:none;">int</span><span style="line-height:1.8;border:none;">&nbsp;pLen&nbsp;=&nbsp;strlen(p);&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">while</span><span style="line-height:1.8;border:none;">&nbsp;(i&nbsp;&lt;&nbsp;sLen&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;&nbsp;pLen)&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//①假设j&nbsp;=&nbsp;-1，或者当前字符匹配成功（即S[i]&nbsp;==&nbsp;P[j]），都令i++，j++&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;==&nbsp;-1&nbsp;||&nbsp;s[i]&nbsp;==&nbsp;p[j])&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++;&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//②假设j&nbsp;!=&nbsp;-1，且当前字符匹配失败（即S[i]&nbsp;!=&nbsp;P[j]）。则令&nbsp;i&nbsp;不变。j&nbsp;=&nbsp;next[j]&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment" style="line-height:1.8;border:none;color:rgb(0,130,0);">//next[j]即为j所相应的next值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;next[j];&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">if</span><span style="line-height:1.8;border:none;">&nbsp;(j&nbsp;==&nbsp;pLen)&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">return</span><span style="line-height:1.8;border:none;">&nbsp;i&nbsp;-&nbsp;j;&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">else</span><span style="line-height:1.8;border:none;">&nbsp;&nbsp;</span></span></li> 
     <li class="alt" style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword" style="line-height:1.8;border:none;color:rgb(0,102,153);font-weight:bold;">return</span><span style="line-height:1.8;border:none;">&nbsp;-1;&nbsp;&nbsp;</span></span></li> 
     <li style="list-style-type:decimal;border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);line-height:1.6;list-style-position:outside;"><span style="line-height:1.8;border:none;color:rgb(0,0,0);">}&nbsp;&nbsp;</span></li> 
    </ol>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 接下来。咱们继续拿之前的样例说明。整个匹配步骤例如以下：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Comic Sans MS';">1</span></em>. S[3]与P[3]匹配失败。<br></p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p><img src="http://hi.csdn.net/attachment/201106/14/8394323_130807585714lW.jpg" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;<em><span style="line-height:1.8;font-family:'Courier New';">&nbsp;2</span></em>. S[3]保持不变。P的下一个匹配位置是P[next[3]]。而next[3]=0，所以P[next[3]]=P[0]与S[3]匹配。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p><img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758571390.jpg" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Comic Sans MS';">3</span></em>.&nbsp;&nbsp;因为上一步骤中P[0]与S[3]还是不匹配。此时i=3，j=next [0]=-1，因为满足条件j==-1。所以运行“++i, ++j”，即主串指针下移一个位置。P[0]与S[4]開始匹配。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">最后j==pLen，跳出循环，输出结果i - j = 4（即模式串第一次在文本串中出现的位置），匹配成功。算法结束。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <p>&nbsp; &nbsp;<img src="http://hi.csdn.net/attachment/201106/14/8394323_1308075857e40u.jpg" alt="" style="border:0px;"></p> 
    </blockquote>
   </blockquote> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t15" style="border-bottom:1px dotted rgb(51,51,51);"></a>3.4 KMP的时间复杂度分析</h3> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    &nbsp; &nbsp; 相信大部分读者读完上文之后，已经发觉事实上理解KMP很easy，无非是循序渐进把握好以下几点：
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ol>
     <li style="list-style:decimal;">假设模式串中存在同样前缀和后缀。即pj-k&nbsp;pj-k+1, ..., pj-1 = p0&nbsp;p1, ..., pk-1，那么在pj跟si失配后，让模式串的前缀p0&nbsp;p1...pk-1相应着文本串si-k&nbsp;si-k+1...si-1，而后让pk跟si继续匹配。</li> 
     <li style="list-style:decimal;">之前本应是pj跟si匹配，结果失配了。失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。</li> 
     <li style="list-style:decimal;">由于k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之。失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]。所以，j = next[j]。等价于把模式串向右移动j - next [j] 位。</li> 
     <li style="list-style:decimal;">而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的同样前缀后缀所决定，假设j 之前的模式串子串中（不含j）有最大长度为k的同样前缀后缀，那么next&nbsp;[j]&nbsp;= k。</li> 
    </ol>
    <div>
     &nbsp; &nbsp; 如之前的图所看到的：
    </div> 
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <blockquote style="background:none;border:none;"> 
     <div> 
      <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140812223633281" alt="" style="border:0px;">
      <br>
     </div> 
    </blockquote>
   </div> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <div>
     &nbsp; &nbsp; 接下来。咱们来分析下KMP的时间复杂度。分析之前，先来回想下KMP匹配算法的流程：
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><strong>“</strong></span>KMP的算法流程：</p> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <ul>
     <li style="list-style:disc;">如果如今文本串S匹配到 i 位置。模式串P匹配到 j 位置 
      <ul>
       <li style="list-style:disc;">假设j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++。j++，继续匹配下一个字符。</li> 
       <li style="list-style:disc;">假设j != -1，且当前字符匹配失败（即S[i] != P[j]）。则令 i 不变，j = next[j]。 <p></p> <p>此举意味着失配时。模式串P相对于文本串S向右移动了j - next [j] 位。</p> <p><span style="line-height:1.8;font-size:18px;">”</span></p> </li> 
      </ul></li>
    </ul>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 我们发现假设某个字符匹配成功。模式串首字符的位置保持不动。不过i++、j++。假设匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i&nbsp;- j的位置时才匹配成功，算法结束。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br> &nbsp; &nbsp; 所以，假设文本串的长度为n。模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间。KMP的总体时间复杂度为O(m + n)。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t16" style="border-bottom:1px dotted rgb(51,51,51);"></a>4. 扩展1：BM算法</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; KMP的匹配是从模式串的开头開始匹配的，而1977年。德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">该算法从模式串的尾部開始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; BM算法定义了两个规则：</p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;">坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时。我们称文本串中的这个失配字符为坏字符，此时模式串须要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。 <p></p> <p>此外，假设"坏字符"不包括在模式串之中，则最右出现位置为-1。</p> </li> 
    <li style="list-style:disc;">好后缀规则：当字符失配时。后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且假设好后缀在模式串中没有再次出现，则为-1。</li> 
   </ul>
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 以下举例说明BM算法。比如。给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，假设存在，返回模式串在文本串中的位置。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Comic Sans MS';">1</span></em>.&nbsp;首先，"文本串"与"模式串"头部对齐。从尾部開始比較。"S"与"E"不匹配。这时，"S"就被称为"坏字符"（bad character），即不匹配的字符，它相应着模式串的第6位。且"S"不包括在模式串"EXAMPLE"之中（相当于最右出现位置是-1）。这意味着能够把模式串后移6-(-1)=7位。从而直接移到"S"的后一位。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728192101322" alt="" style="border:0px;"><br></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Courier New';">2</span></em>.&nbsp;依旧从尾部開始比較，发现"P"与"E"不匹配，所以"P"是"坏字符"。可是，"P"包括在模式串"EXAMPLE"之中。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">由于“P”这个“坏字符”相应着模式串的第6位（从0開始编号），且在模式串中的最右出现位置为4，所以。将模式串后移6-4=2位。两个"P"对齐。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728192109185" alt="" style="border:0px;"><br></p> 
   </blockquote> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728192118623" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;</span>
   <em style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'Comic Sans MS';">3</span></em>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">.&nbsp;依次比較。得到 “MPLE”匹配。称为"好后缀"（good suffix），即全部尾部匹配的字符串。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">注意。"MPLE"、"PLE"、"LE"、"E"都是好后缀。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728193254930" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;</span>
   <em style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'Comic Sans MS';">4</span></em>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">.&nbsp;发现“I”与“A”不匹配：“I”是坏字符。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设是依据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728193420403" alt="" style="border:0px;"></p> 
   </blockquote> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728193428671" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;</span>
   <em style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'Comic Sans MS';">5</span></em>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">. 更优的移法是利用好后缀规则：当字符失配时。后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且假设好后缀在模式串中没有再次出现。则为-1。</span>
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 全部的“好后缀”（MPLE、PLE、LE、E）之中，仅仅有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。</span>
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 能够看出。“坏字符规则”仅仅能移3位，“好后缀规则”能够移6位。每次后移这两个规则之中的较大值。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这两个规则的移动位数。仅仅与模式串有关，与原文本串无关。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728194226031" alt="" style="border:0px;"></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<span style="line-height:1.8;font-family:'Comic Sans MS';"><em><span style="line-height:1.8;">6</span></em></span>.&nbsp;继续从尾部開始比較。“P”与“E”不匹配。因此“P”是“坏字符”。依据“坏字符规则”。后移 6 - 4 = 2位。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">由于是最后一位就失配，尚未获得好后缀。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <blockquote style="background:rgb(255,255,255) none;border:none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20140728194006343" alt="" style="border:0px;"></p> 
   </blockquote> 
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 由上可知，BM算法不仅效率高，并且构思巧妙。easy理解。</span> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t17" style="border-bottom:1px dotted rgb(51,51,51);"></a>5. 扩展2：Sunday算法</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">但实际上。KMP算法并不比最简单的c库函数strstr()快多少，而BM算法尽管通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法。本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法非常相似：</p> 
   <ul style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:disc;">仅仅只是Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中參加匹配的最末位字符的下一位字符。 <p></p> <p></p> 
     <ul>
      <li style="list-style:disc;">假设该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；</li> 
      <li style="list-style:disc;">否则，其移动位数&nbsp;= 模式串中最右端的该字符到末尾的距离+1。</li> 
     </ul></li>
   </ul>
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 以下举个样例说明下Sunday算法。假定如今要在文本串"substring searching algorithm"中查找模式串"search"。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Comic Sans MS';"><span style="line-height:1.8;">1</span></span></em>. 刚開始时，把模式串与文本串左边对齐：<br><span style="line-height:1.8;"></span><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:Calibri;">substr<strong>i</strong>ng&nbsp;searching&nbsp;algorithm</span></span><br style="font-family:Arial;font-size:13px;line-height:26px;"><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:Calibri;">search</span></span><br style="font-family:Arial;font-size:13px;line-height:26px;"><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:Calibri;">^</span></span><br> &nbsp; &nbsp;&nbsp;<span style="line-height:1.8;font-family:'Courier New';"><em><span style="line-height:1.8;">2</span></em></span>. 结果发如今第2个字符处发现不匹配。不匹配时关注文本串中參加匹配的最末位字符的下一位字符，即标粗的字符 i，由于模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7。从 i 之后的那个字符（即字符n）開始下一步的匹配，例如以下图：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"></span><span style="line-height:26px;font-family:Arial;"><span style="line-height:1.8;font-size:13px;"><span style="line-height:1.8;font-family:Calibri;">substri<u><span style="line-height:1.8;color:rgb(255,0,0);">n</span>g&nbsp;sea</u><strong>r</strong>ching&nbsp;algorithm</span><br></span></span><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:'宋体';color:#000000;">　　　</span><span style="line-height:1.8;font-family:Calibri;color:#000000;">&nbsp;</span><span style="line-height:1.8;font-family:Calibri;"><span style="line-height:1.8;color:rgb(255,0,0);">s</span></span><span style="line-height:1.8;font-family:Calibri;color:#000000;">earch</span></span><span style="line-height:26px;font-family:Arial;"><br></span><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:'宋体';color:#000000;">　　　　</span><span style="line-height:1.8;font-family:Calibri;color:#000000;">^</span></span><br> &nbsp; &nbsp;&nbsp;<span style="line-height:1.8;font-family:'Comic Sans MS';"><em><span style="line-height:1.8;">3</span></em></span>. 结果第一个字符就不匹配，再看文本串中參加匹配的最末位字符的下一位字符，是'r'，它出如今模式串中的倒数第3位。于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3）。使两个'r'对齐，例如以下：<br><span style="line-height:26px;font-family:Arial;"><span style="line-height:1.8;font-size:13px;"><span style="line-height:1.8;font-family:Calibri;"></span></span></span><span style="line-height:26px;font-family:Arial;"><span style="line-height:1.8;font-size:13px;"><span style="line-height:1.8;font-family:Calibri;">substring&nbsp;searching&nbsp;algorithm</span><br></span></span><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:'宋体';color:#000000;">　　　　</span><span style="line-height:1.8;font-family:Calibri;color:#000000;">&nbsp;&nbsp;search</span></span><span style="line-height:26px;font-family:Arial;"><br></span><span style="line-height:26px;font-family:Arial;font-size:13px;"><span style="line-height:1.8;font-family:'宋体';color:#000000;">　　　　　　　</span><span style="line-height:1.8;font-family:Calibri;color:#000000;">^</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<em><span style="line-height:1.8;font-family:'Comic Sans MS';"><span style="line-height:1.8;">4</span></span></em>. 匹配成功。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 回想整个过程，我们仅仅移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比較大。效率非常高。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">完。<br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t18" style="border-bottom:1px dotted rgb(51,51,51);"></a>6. 參考文献</h2> 
   <ol style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style:decimal;">《算法导论》的第十二章：字符串匹配；</li> 
    <li style="list-style:decimal;">本文中模式串“ABCDABD”的部分图来自于此文：<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a>；</li> 
    <li style="list-style:decimal;">本文3.3.7节中有限状态自己主动机的图由微博网友@龚陆安 绘制：<a href="http://d.pr/i/NEiz" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://d.pr/i/NEiz</a>。</li> 
    <li style="list-style:decimal;">北京7月暑假班邹博半小时KMP视频：<a href="http://www.julyedu.com/video/play/id/5" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.julyedu.com/video/play/id/5</a>；</li> 
    <li style="list-style:decimal;">北京7月暑假班邹博第二次课的PPT：<a href="http://yun.baidu.com/s/1mgFmw7u" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://yun.baidu.com/s/1mgFmw7u</a>；</li> 
    <li style="list-style:decimal;">理解KMP 的9张PPT：<a href="http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876</a>。</li> 
    <li style="list-style:decimal;">具体解释KMP算法（多图）：<a href="http://www.cnblogs.com/yjiyjige/p/3263858.html" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.cnblogs.com/yjiyjige/p/3263858.html</a>；</li> 
    <li style="list-style:decimal;">本文第4部分的BM算法參考自此文：<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html</a>；</li> 
    <li style="list-style:decimal;"> <a href="http://youlvconglin.blog.163.com/blog/static/5232042010530101020857/" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://youlvconglin.blog.163.com/blog/static/5232042010530101020857</a>；<br></li> 
    <li style="list-style:decimal;">《数据结构 第二版》，严蔚敏 &amp; 吴伟民编著；</li> 
    <li style="list-style:decimal;"> <a href="http://blog.csdn.net/v_JULY_v/article/details/6545192" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://blog.csdn.net/v_JULY_v/article/details/6545192</a>。<br></li> 
    <li style="list-style:decimal;"> <a href="http://blog.csdn.net/v_JULY_v/article/details/6111565" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://blog.csdn.net/v_JULY_v/article/details/6111565</a>；<br></li> 
    <li style="list-style:decimal;">Sunday算法的原理与实现：<a href="http://blog.chinaunix.net/uid-22237530-id-1781825.html" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://blog.chinaunix.net/uid-22237530-id-1781825.html</a>；<br></li> 
    <li style="list-style:decimal;">模式匹配之Sunday算法：<a href="http://blog.csdn.net/sunnianzhong/article/details/8820123" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://blog.csdn.net/sunnianzhong/article/details/8820123</a>。</li> 
    <li style="list-style:decimal;">一篇KMP的英文介绍：<a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm</a>。</li> 
    <li style="list-style:decimal;">我2014年9月3日在西安电子科技大学的面试&amp;算法讲座视频（第36分钟~第94分钟讲KMP）：<a href="http://www.julyedu.com/video/play/id/7" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://www.julyedu.com/video/play/id/7</a>。 <p></p> <p></p> </li> 
   </ol>
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <a name="t19" style="border-bottom:1px dotted rgb(51,51,51);"></a>7. 后记 &nbsp; &nbsp;</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 对之前混乱的文章给广大读者带来的困扰表示致歉，对又一次写就后的本文即将给读者带来的清晰表示欣慰。希望大部分的刚開始学习的人，甚至少部分的非计算机专业读者也能看懂此文。有不论什么问题。欢迎随时批评指正，thanks。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; July、二零一四年八月二十二日晚九点。</p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p><font color="#333333"><span style="font-size:14px;"><br></span></font></p> 
   <p><font color="#333333"><span style="font-size:14px;">本文转自mfrbuaa博客园博客，原文链接：http://www.cnblogs.com/mfrbuaa/p/5125044.html，如需转载请自行联系原作者</span></font></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
