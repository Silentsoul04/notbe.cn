<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Android输入法扩展之外接键盘中文输入 « NotBeCN</title>
  <meta name="description" content="             &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 大家想不想要这样一台Android&nbsp;&nbsp;Surface平板，看着就过瘾吧。    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/22/weixin_34378922_90135141.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Android输入法扩展之外接键盘中文输入</h1>
    <p class="post-meta">Nov 22, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp; &nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">&nbsp; &nbsp; 大家想不想要这样一台Android&nbsp;&nbsp;Surface平板，看着就过瘾吧。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20140611220318953?%3C/p%3E%3Cp%3Ewatermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSVRsZWFrcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style="border:0px;"><br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp; 我们知道，android眼下的输入都是通过软键盘实现的，用外接键盘的少。这个在手机上是能够理解的。当手机接上外接键盘后。总体会显得头重脚轻。而且用键盘输入时。人离手机的距离就远了，自然不太适合看清手机上的内容。那在平板上呢？假设平板仅仅是平时用来浏览看视频，不进行大量输入。自然也用不上外接键盘。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">那到底什么时候须要用到外接键盘呢？本人认为首先要满足例如以下两个条件。</p> 
   <blockquote style="background:rgb(255,255,255) none;border:2px solid rgb(239,239,239);color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><span style="line-height:1.8;font-size:18px;">1)&nbsp;&nbsp;&nbsp;平板和外接键盘完美融合，组合后非常像笔记本使用模式。类似上面Android Surface的机器，平板和键盘通过磁性自己主动粘合，变身笔记本模式</span></p> 
    <p><span style="line-height:1.8;font-size:18px;">2)&nbsp;&nbsp;&nbsp;&nbsp;Android用在类办公等须要高速输入场景，比方写文章。长时间聊qq等。事实上linux一直以来没法进入桌面系统的关键原因是window在这方面太优秀，它垄断了用户的办公习惯，即用Microsoft office系列软件办公。可是如今类linux。尤其Android在这边已经有了非常大进步，一方面，ubuntu帮组linux积累了一部分用户。比方libre office体验好多了。同一时候据说微软正在为Android开发Microsoft office的响应产品，这个是利好消息。</span></p> 
    <p></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp; 从上面看来。事实上市面上已经有满足上面两个条件的机器了。比方联想的A10&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20140611220356750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSVRsZWFrcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="border:0px;"></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp; &nbsp; &nbsp;</span><span style="line-height:1.8;font-size:18px;">&nbsp;它是一台超级本, 但它支持翻转，当翻转过来就是平板。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp; &nbsp; &nbsp; 那为啥这样的Android超极本就不够火呢？当然有非常多原因啊，比方平板本身需求量小，Android本身就不适合办公。当然肯定也有另外一个小原因。它这个物理键盘居然不能中文输入。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">因此，Android平板要进入办公领域并流行，须要实现类似PC端中文输入的体验。</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp; &nbsp; &nbsp;本文说到的外接键盘中文输入，重在中文两字。其实，Android本身是支持外接键盘的。可是仅仅可以实现英文输入。其实。我们在前几篇文章已经说到了输入法，也已经分析到，Android要想输入中文，必须通过输入法。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">那为啥Android的中文输入法不能像PC那样直接通过外接键盘输入呢？以下一一分析。</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"></span>&nbsp;</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><br></span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">Android没法通过外接键盘中文输入原因</span></h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;">输入法和外接键盘不能共存</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">Android系统里，当有外接键盘时。输入法就会消失。这样自然没法通过输入法输入中文。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这个是由Configuration的keyboard配置项决定的。正常情况下。Configuration的keyboard值是nokeys,而当系统检測到外接键盘(蓝牙键盘等等)插入时，就会更新系统的Configuration,并将当中的keyboard置为非nokeys(比方Configuration.KEYBOARD_QWERTY),然后系统会将新的Configuration通知给全部程序，包含输入法。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">当输入法程序检測到新的Configuration时，它会运行更新操作，然后发现已经有外接设备就会隐藏自己。这样输入法就不见了。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">详细逻辑例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;</span></p> 
   <pre><code class="language-java">    
    //系统端 :WindowManagerService.java
    boolean computeScreenConfigurationLocked(Configuration config, boolean forceRotate) {
            final InputDevice[] devices = mInputManager.getInputDevices();
            final int len = devices.length;
            for (int i = 0; i &lt; len; i++) {
                InputDevice device = devices[i];
                if (!device.isVirtual()) {
                    final int sources = device.getSources();
                    final int presenceFlag = device.isExternal() ?
                            WindowManagerPolicy.PRESENCE_EXTERNAL :
                                    WindowManagerPolicy.PRESENCE_INTERNAL;

                    if (device.getKeyboardType() == InputDevice.KEYBOARD_TYPE_ALPHABETIC) {
                        //检測到外接键盘
                        config.keyboard = Configuration.KEYBOARD_QWERTY;
                        keyboardPresence |= presenceFlag;
                    }
                }
            }

            // Determine whether a hard keyboard is available and enabled.
            boolean hardKeyboardAvailable = config.keyboard != Configuration.KEYBOARD_NOKEYS;
            if (hardKeyboardAvailable != mHardKeyboardAvailable) {
                mHardKeyboardAvailable = hardKeyboardAvailable;
                mHardKeyboardEnabled = hardKeyboardAvailable;
                mH.removeMessages(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);
                mH.sendEmptyMessage(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);
            }
            if (!mHardKeyboardEnabled) {
                config.keyboard = Configuration.KEYBOARD_NOKEYS;
            }
        }
        return true;
    }

    //输入法端: InputMethodService.java
    @Override public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        
        if (visible) {
            if (showingInput) {
                // onShowInputRequested就会影响输入法的显示
                //当有外接键盘时，它会返回false
                if (onShowInputRequested(showFlags, true)) {
                    showWindow(true);
                } else {
                    doHideWindow();
                }
            }
            // onEvaluateInputViewShown也会影响输入法的显示
            //当有外接键盘时，它会返回false
            boolean showing = onEvaluateInputViewShown();
            mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? 
IME_VISIBLE : 0), mBackDisposition);
        }
    }
    

   public boolean onEvaluateInputViewShown() {
        Configuration config = getResources().getConfiguration();
        //检測Configuration是否标示了有外接键盘
        return config.keyboard == Configuration.KEYBOARD_NOKEYS
                || config.hardKeyboardHidden ==
             Configuration.HARDKEYBOARDHIDDEN_YES;
    }

    public boolean onShowInputRequested(int flags, boolean configChange) {
        if (!onEvaluateInputViewShown()) {
            return false;
        }
        if ((flags&amp;InputMethod.SHOW_EXPLICIT) == 0) {
            Configuration config = getResources().getConfiguration();
            //检測Configuration是否标示了有外接键盘
            if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
                return false;
            }
        }
        if ((flags&amp;InputMethod.SHOW_FORCED) != 0) {
            mShowInputForced = true;
        }
        return true;
    }

</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;">输入法没法获得按键事件</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">&nbsp;我们知道，假设要想输入法通过外接键盘输出中文，它肯定须要从外接键盘读取到英文输入。而在<span style="line-height:1.8;font-family:Calibri;">Android</span>系统中，按键等<span style="line-height:1.8;font-family:Calibri;">key</span>事件仅仅发送给焦点程序，可是输入法本身没法获得焦点，因此它自然就没法读取到外接键盘的输入。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><br></span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">问题的解决</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;">让输入法和外接键盘共存</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">从上面的分析可知。输入法和外接键盘没法共存的根本原因是，输入法会读取configuration里的键盘属性值。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">解决问题有两个方法：</p> 
   <blockquote style="background:rgb(255,255,255) none;border:medium none;color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><span style="line-height:1.8;font-size:18px;">1) &nbsp;改动用到Configuration的相关函数，比方onEvaluateInputViewShown ，onShowInputRequested函数的实现</span></p> 
    <p><span style="line-height:1.8;font-size:18px;">这种方法看起来可行，可是不行。由于非常多地方可能用到了这个Configuration，改动量比較大，且非常多函数并不是protected或者public,子类是没法直接改动的。</span></p> 
    <p></p> 
    <p><span style="line-height:1.8;font-size:18px;">2) &nbsp;改动输入法的Configuration的值</span></p> 
    <p><span style="line-height:1.8;font-size:18px;">这种方法可行。从源头上攻克了这个问题，这样InputMethodService觉得系统没有外接键盘。自然就不会隐藏输入法了。</span></p> 
   </blockquote> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">方法2详细实现例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在输入法初始化和更新Configuration的点主动改动输入法的Configuration。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br><span style="line-height:1.8;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p> 
   <pre><code class="language-java">public class RemoteInputMethod extends InputMethodService { 
   @Override 
   public void onCreate() {
    super.onCreate();
    	updateResources();
   }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        updateResources();
    }

	public void updateResources() {
		Configuration config = new Configuration(getResources().getConfiguration());
        //改动Configuration,让输入法觉得系统中没有外接键盘
		config.keyboard = Configuration.KEYBOARD_NOKEYS;
		getResources().updateConfiguration(config, getResources().getDisplayMetrics());
	}
}
</code></pre> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">让输入法获取外接键盘输入</span></h2> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <br>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 输入法实现输入有两部分。一是获取按键事件。二是获取输入目标</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><br></span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:18px;">获取按键事件</span></h3> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="line-height:1.8;font-size:18px;"><br></span>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;上面已经提到过。输入法window是没法获取外接键盘事件的。怎么办？非常好办，让输入法service创建另外一个普通的window（本文称作bridge window），并将这个window标示为可接受key事件的window，当它是最top的可接受key事件的window时, 它就能够获得焦点并获得外接键盘的输入。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这样，它作为中间桥梁就能将外接键盘事件传给输入法 (同一程序里，非常好做的)。输入法然后进行翻译，比方拼音转为中文。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><br></span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:18px;">获取并更新输入目标</span></h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">输入法的输入目标是textView的通信接口InputConnection。它是在程序获得焦点时候或焦点程序中的焦点view发生变化的时候。焦点程序传递给输入法的。</span></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，问题来了？一旦上面的bridge window获得焦点后，输入法的输入目标就跟着更新了，变成了bridge window的view的InputConnection。这样即使输入法完毕了英文到中文的转换，最后也仅仅能将中文发送给bridge window，并不能发送给用户想输入的程序。怎么解？还好Android系统有一个特殊window flag-----WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,当一个window设置了这个flag, 它成为焦点时。输入法并不会将输入目标切换为当前焦点window的InputConnection，而是仍旧保持原来的InputConnection。这为我们带来了希望，也就是说，我们仅仅需将我们的bridge window加入这个flag就可以，其实确实如此。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可是还存在一个问题。我们知道InputConnection是相应textView的一个通信接口，当用户改变输入view时，输入法中的InputConnection是须要改动的，可是如今因为目标程序已经不是焦点程序了，当用户触摸目标程序其它textView导致输入view改变时，系统并不会通知输入法去更新InputConnection，这样一来，输入法的中文始终仅仅能传递给一个textView了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">又怎么解呢？灵光一动，继续解。当用户触摸时。我们能够让bridge window临时失去焦点，这样目标程序就又一次获取了焦点，然后输入view切换时，输入法就能得到通知，也就是能又一次获取到新的textView的InputConnection。然后。bridge window又一次获取焦点，也就是非常短时间后它继续能够接受外接键盘的输入了。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp; 这个方法的重点在bridge window的实现：实现的重点有两个：</span></p> 
   <blockquote style="background:rgb(255,255,255) none;border:2px solid rgb(239,239,239);color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"> 
    <p><span style="line-height:1.8;font-size:18px;">1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加入WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM flag</span></p> 
    <p><span style="line-height:1.8;font-size:18px;">2）&nbsp; 监听OUT_SIDE事件，这样，当用户单击目标程序。切换焦点view时，bridge window可以提前获知，然后释放焦点，</span></p> 
    <p><span style="line-height:1.8;font-size:18px;">&nbsp;&nbsp; 让目标程序成为焦点，然后完毕焦点view的切换，进而完毕输入法中的输入目标InputConnection的更新。</span></p> 
    <p></p> 
   </blockquote> 
   <pre><code class="language-java">   public class BridgeWindow extends Dialog {
	private static final boolean DEBUG = false;
	private static final String TAG = "MDialog";

	private static final int flagsNask = WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM 
    		| WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
    		| WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
    		| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
	
	private static final int flags = WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM 
    		| WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
    		| WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
	private static final int flags_nofocus = WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM 
    		| WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
    		| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;

	
	private Window mWindow = null;
	private Handler mHandler = new Handler();
	private MInputMethod mAttachedInputMethod = null;

	public BridgeWindow (Context context) {
		super(context);
		// TODO Auto-generated constructor stub
		init();
	}
	
	public void setAttachedInputMethod(MInputMethod inputMethod) {
		mAttachedInputMethod = inputMethod;
	}

	View mRootView = null;
	public void setContentView(View view) {
		super.setContentView(view);
		mRootView = view;
	}
	
    private void init() {
		// TODO Auto-generated method stub
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setTitle("HardInputMethod");
    	mWindow = this.getWindow();
        LayoutParams lp = mWindow.getAttributes();
        lp.gravity = Gravity.LEFT|Gravity.TOP;
        lp.x = 0;
        lp.y = 0;
    	mWindow.setType(WindowManager.LayoutParams.TYPE_PHONE);
        //初始化window的flag
    	mWindow.setFlags(flags, flagsNask);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {
            //检測到用户触摸了bridge window外的区域，那么焦点view可能要发生
            //变化了，输入法的InputConnection须要更新了。所以在此临时取消自己
            //的focus
        	if (DEBUG) Log.d(TAG, "release focus");
        	releaseFocus();
        }
        return super.onTouchEvent(event);
    }
	
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
    	if (DEBUG) Log.d(TAG, "onKeyDown" + keyCode);
        //将事件传递给输入法
        mAttachedInputMethod.onKeyDown(keyCode,  event);
        return super.onKeyDown(keyCode, event);
    }
    
	protected void releaseFocus() {
		// TODO Auto-generated method stub
               //将自己配置成不可获取焦点来让自己失去焦点
		mWindow.setFlags(flags_nofocus, flagsNask);
		mHandler.removeCallbacks(mFocusRunnable);
               //1s钟后。让自己又一次获取焦点
		mHandler.postDelayed(mFocusRunnable, 1000);
	}
	
	Runnable mFocusRunnable = new Runnable() {
		@Override
		public void run() {
		// TODO Auto-generated method stub
			mWindow.setFlags(flags, flagsNask);
		}
	};
	
	Point mDownPosition = new Point();
	public void onDown(int x, int y) {
		// TODO Auto-generated method stub
		int[] loc = new int[2];
		mRootView.getLocationOnScreen(loc);
		mDownPosition.x = loc[0];
		mDownPosition.y = loc[1] - 50;
		if (DEBUG) Log.d(TAG, "on down position x:" + loc[0] + " y:" + loc[1]);
	}

	public void onMove(int offsetX, int offsetY) {
		// TODO Auto-generated method stub
		updatePositioin(mDownPosition.x + offsetX, mDownPosition.y + offsetY);
	}
	
	private void updatePositioin(int x, int y) {
		LayoutParams lp = mWindow.getAttributes();
            lp.x = x;
            lp.y = y;
            mWindow.setAttributes(lp);
	}
}
</code></pre> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">完美解决方式</span></h1> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="line-height:1.8;"><br></span>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="line-height:1.8;font-size:18px;">上面的解决方式是直接在输入法程序内部改动达到实现外接键盘输入中文。属于应用程范畴。可是仍有一些问题，而这些问题在程序端是没法解决的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">那该怎么完美解决呢。Andorid后来的版本号已经攻克了这个。是怎样解决的？</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">即全部的按键事件先发送给程序。然后程序端的代码会先将key发送给输入法，即让输入法有一个翻译转换过程的机会，然后输入法再将转化过的key或者字符发送回程序，也就是说key事件绕了一圈。最后再让程序端处理。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">附录</span></h1> 
   <div style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <span style="line-height:1.8;"><br></span>
   </div> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 近期工作比較忙。代码还没有整理好，等整理好后，我会将源代码发出来。大家能够一起学习。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:1.8;font-family:SimSun;">/********************************</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:19px;"><span style="line-height:1.8;font-family:SimSun;font-size:18px;">* 本文来自博客 &nbsp;“爱踢门”</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;"><span style="line-height:19px;"><span style="line-height:1.8;font-size:18px;">* 转载请标明出处</span></span><span style="line-height:19px;"><span style="line-height:1.8;font-size:18px;">:<a href="http://blog.csdn.net/itleaks" rel="nofollow" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);">http://blog.csdn.net/itleaks</a></span></span><br></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:19px;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;">******************************************/</span></span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:19px;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;"><br></span></span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:19px;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;"><br></span></span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:19px;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;"><br></span></span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:19px;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;"><br></span></span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-size:18px;"><span style="line-height:19px;font-size:14px;"><span style="line-height:1.8;font-family:SimSun;"></span></span></span></p> 
   <p><font color="#333333"><span style="font-size:14px;">本文转自mfrbuaa博客园博客，原文链接：http://www.cnblogs.com/mfrbuaa/p/5114169.html，如需转载请自行联系原作者</span></font></p> 
   <div>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
