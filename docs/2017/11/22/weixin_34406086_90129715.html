<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>内部排序法总结 « NotBeCN</title>
  <meta name="description" content="             1.冒泡排序（Bubble Sort）    冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/22/weixin_34406086_90129715.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">内部排序法总结</h1>
    <p class="post-meta">Nov 22, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>1.冒泡排序（Bubble Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。<br> 冒泡排序是稳定的。算法时间复杂度是O(n^2)。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">冒泡排序（相邻比较法）</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> BubbleSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[],<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i,j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> temp;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i &lt; n-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; i++<span style="font-size:12px;line-height:1.5;">)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(j = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; j &lt; n-i-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; j++<span style="font-size:12px;line-height:1.5;">)
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(a[j] &gt; a[j+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">])
            {
                temp </span>=<span style="font-size:12px;line-height:1.5;"> a[j];
                a[j] </span>= a[j+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">];
                a[j</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> temp;
            }
}
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">改进的冒泡排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> ImprovedBubbleSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i,j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> temp;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> change = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i &lt; n-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; i++<span style="font-size:12px;line-height:1.5;">)
    {
        change </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> j = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; j &lt; n-i-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; j++<span style="font-size:12px;line-height:1.5;">)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(a[j] &gt; a[j+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">])
        {
            temp </span>=<span style="font-size:12px;line-height:1.5;"> a[j];
            a[j] </span>= a[j+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">];
            a[j</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> temp;
            change </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> ( !change ) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">break</span><span style="font-size:12px;line-height:1.5;">;
    }
}
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">双向冒泡排序（鸡尾酒排序）</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> CocktailSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> top = n - <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> bottom = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> flag = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i, j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span><span style="font-size:12px;line-height:1.5;">(flag)
    {
        flag </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">从小到大，升序</span>
         <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = bottom; i &lt; top; i++<span style="font-size:12px;line-height:1.5;">)
        {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(a[i] &gt; a[i+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">])
            {
                swap(a[i], a[i</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">]);
                flag </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
            }
        }
        top</span>--<span style="font-size:12px;line-height:1.5;">;

        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">从大到小，降序</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(j = top; j &gt; bottom; j--<span style="font-size:12px;line-height:1.5;">)
        {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(a[j] &lt; a[j-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">])
            {
                swap(a[j], a[j</span>-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">]);
                flag </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
            }
        }
        bottom</span>++<span style="font-size:12px;line-height:1.5;">;
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/i/434101/201406/211610038177789.gif" alt="" style="border:none;"></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">An example of bubble sort. Starting from the beginning of the list, compare every adjacent pair, swap their position if they are not in the right order (the latter one is smaller than the former one). After each iteration, one less element (the last one) is needed to be compared until there are no more elements left to be compared.</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>2.选择排序（Selection Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。<br> 选择排序是不稳定的。算法复杂度是O(n^2 )。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">选择排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> SelectSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[],<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> temp;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i,j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i &lt; n; i++<span style="font-size:12px;line-height:1.5;">)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> k =<span style="font-size:12px;line-height:1.5;"> i;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(j = i+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; j &lt; n; j++<span style="font-size:12px;line-height:1.5;">)
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(a[j] &lt; a[k]) k =<span style="font-size:12px;line-height:1.5;"> j;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(k !=<span style="font-size:12px;line-height:1.5;"> i)
        {
           temp </span>=<span style="font-size:12px;line-height:1.5;"> a[i];
           a[i] </span>=<span style="font-size:12px;line-height:1.5;"> a[k];
           a[k] </span>=<span style="font-size:12px;line-height:1.5;"> temp;
        }
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/i/434101/201406/211611556616557.gif" alt="" style="border:none;"></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">Selection sort animation. Red is current min. Yellow is sorted list. Blue is current item.</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>3.插入排序（Insertion Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i]又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]&lt;=L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1&lt;=j&lt;=i-1)，使得L[j] &lt;=L[j+1]时为止。<br> 直接插入排序是稳定的。算法时间复杂度是O(n^2)。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">插入排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> InsertSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i, j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> temp;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; i &lt; n; i++<span style="font-size:12px;line-height:1.5;">)
    {
        temp </span>=<span style="font-size:12px;line-height:1.5;"> a[i];
        j </span>= i-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(j &gt;= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span> &amp;&amp; a[j] &gt;<span style="font-size:12px;line-height:1.5;"> temp;)
        {
            a[j</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> a[j];
            </span>--<span style="font-size:12px;line-height:1.5;">j;
        }
        a[j</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> temp;
    }
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">递归的插入排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> RecursiveInsertSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i, j, key;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(n &gt; <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">)
    {
        RecursiveInsertSort(a,n</span>-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
    }
    key </span>= a[n-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">];
    i </span>= n-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i &gt;= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span> &amp;&amp; a[i] &gt;<span style="font-size:12px;line-height:1.5;"> key)
    {
        a[i</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> a[i];
        i</span>--<span style="font-size:12px;line-height:1.5;">;
    }
    a[i</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> key;
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">折半插入排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> BinInsertSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i,j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; i &lt; n; i++<span style="font-size:12px;line-height:1.5;">)
    {
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 在a[0..i-1]中折半查找插入位置使a[high]&lt;=a[i]&lt;a[high+1..i-1]</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> low = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>, high = i-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>, m = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(low &lt;=<span style="font-size:12px;line-height:1.5;"> high)
        {
            m </span>= m + (high-low)/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (a[i] &lt; a[m]) high = m-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> low = m+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
        }
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 向后移动元素a[high+1..i-1]，在a[high+1]处插入a[i]</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> x =<span style="font-size:12px;line-height:1.5;"> a[i];
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span> (j = i-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; j &gt; high; j--<span style="font-size:12px;line-height:1.5;">)
            a[j</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] =<span style="font-size:12px;line-height:1.5;"> a[j];
        a[high</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] = x;     <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 完成插入</span>
<span style="font-size:12px;line-height:1.5;">    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/i/434101/201406/211612364118073.gif" alt="" style="border:none;"></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">A graphical example of insertion sort.</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>4.希尔排序（Shell Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">先将待排序列分割成若干个子序列，分别进行直接插入排序，基本有序后再对整个序列进行直接插入排序。<br> 希尔排序是不稳定的。时间复杂度大约为O(n^3/2)。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">希尔排序：shell排序的核心仍然使用插入排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> ShellSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> dk = n/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i,j;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(dk &gt;= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">)
    {
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 一趟希尔排序，对dk个序列分别进行插入排序</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = dk; i &lt; n; ++<span style="font-size:12px;line-height:1.5;">i)
        {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> x =<span style="font-size:12px;line-height:1.5;"> a[i];
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span> (j = i-dk; j &gt;= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span> &amp;&amp; a[j] &gt; x; j -=<span style="font-size:12px;line-height:1.5;"> dk )
                a[j</span>+dk] =<span style="font-size:12px;line-height:1.5;"> a[j];
            a[j</span>+dk] =<span style="font-size:12px;line-height:1.5;"> x;
        }
        dk </span>= dk/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>;  <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 缩小增量</span>
<span style="font-size:12px;line-height:1.5;">    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>5.堆排序（Heap Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">堆排序是一种树形选择排序，在排序过程中，将A[n]看成是完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。对N个元素从小到大排序建立大根堆，然后交换堆顶与最后一个元素，将剩下的N-1个元素调整为大根堆，执行N-1此这样的操作。<br> 堆排序是不稳定的。算法时间复杂度O(nlogn)。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">调整大根堆</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> HeapAdjust(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> data[],<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> nStart, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> nLen)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> nMaxChild = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> Temp;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>((<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>*nStart+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>) &lt;<span style="font-size:12px;line-height:1.5;"> nLen)
    {
        nMaxChild </span>= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>*nStart+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>((<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>*nStart+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>) &lt;<span style="font-size:12px;line-height:1.5;"> nLen)
        {
            </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">比较左子树和右子树,记录最大值的Index</span>
            <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (data[<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>*nStart+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>] &lt; data[<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>*nStart+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">])
            {
                nMaxChild </span>= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>*nStart+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
            }
        }
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">change data</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(data[nStart] &lt;<span style="font-size:12px;line-height:1.5;"> data[nMaxChild])
        {
            </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">交换nStart与nMaxChild的数据</span>
              Temp =<span style="font-size:12px;line-height:1.5;"> data[nStart];
            data[nStart] </span>=<span style="font-size:12px;line-height:1.5;"> data[nMaxChild];
            data[nMaxChild] </span>=<span style="font-size:12px;line-height:1.5;"> Temp;

            </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">堆被破坏,需要重新调整</span>
              nStart =<span style="font-size:12px;line-height:1.5;"> nMaxChild;
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span><span style="font-size:12px;line-height:1.5;">
        {
            </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">比较左右孩子均小则堆未破坏,不再需要调整</span>
              <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">break</span><span style="font-size:12px;line-height:1.5;">;
        }
    }
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">堆排序 从小到大排序建立大顶堆</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> HeapSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> data[],<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> nLen)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> nTemp;
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">建立堆</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = nLen/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span>-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; i &gt;= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i--<span style="font-size:12px;line-height:1.5;">)
    {
        HeapAdjust(data, i, nLen);
    }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = nLen-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; i &gt; <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i--<span style="font-size:12px;line-height:1.5;">)
    {
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">交换堆顶元素和最后一个元素</span>
         nTemp = data[<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">];
        data[</span><span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>] =<span style="font-size:12px;line-height:1.5;"> data[i];
        data[i] </span>=<span style="font-size:12px;line-height:1.5;"> nTemp;

        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">将data[0...i]重写建成大根堆</span>
         HeapAdjust(data, <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">, i);
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/i/434101/201406/211615182079436.gif" alt="" style="border:none;"></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>6.快速排序（Quick Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">快速排序是不稳定的。最理想情况算法时间复杂度O(nlog2n)，最坏O(n^2)。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">快速排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> QuickSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> low, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> high)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(low &lt;<span style="font-size:12px;line-height:1.5;"> high)
    {
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 划分</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> pivot =<span style="font-size:12px;line-height:1.5;"> a[low];
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> i = low; <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> j =<span style="font-size:12px;line-height:1.5;"> high;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i &lt;<span style="font-size:12px;line-height:1.5;"> j)
        {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i&lt;j &amp;&amp; a[j] &gt;= pivot)  j--<span style="font-size:12px;line-height:1.5;">;
            a[i] </span>=<span style="font-size:12px;line-height:1.5;"> a[j];
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i&lt;j &amp;&amp; a[i] &lt;= pivot)  i++<span style="font-size:12px;line-height:1.5;">;
            a[j] </span>=<span style="font-size:12px;line-height:1.5;"> a[i];
        }
        a[i] </span>=<span style="font-size:12px;line-height:1.5;"> pivot;
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 对子序列快排</span>
        QuickSort(a, low, i-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
        QuickSort(a, i</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">, high);
    }
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">快速排序法的划分操作</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> Partition(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> vec[],<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> low,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> high)
{
     </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">任选元素作为轴，这里选首元素</span>
     <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> pivot =<span style="font-size:12px;line-height:1.5;"> vec[low];
     </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(low &lt;<span style="font-size:12px;line-height:1.5;"> high)
     {
         </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(low &lt; high &amp;&amp; vec[high] &gt;=<span style="font-size:12px;line-height:1.5;"> pivot)
             high</span>--<span style="font-size:12px;line-height:1.5;">;
         vec[low] </span>=<span style="font-size:12px;line-height:1.5;"> vec[high];
         </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(low &lt; high &amp;&amp; vec[low] &lt;=<span style="font-size:12px;line-height:1.5;"> pivot)
             low</span>++<span style="font-size:12px;line-height:1.5;">;
         vec[high] </span>=<span style="font-size:12px;line-height:1.5;"> vec[low];
     }
     </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">此时low==high</span>
     vec[low] =<span style="font-size:12px;line-height:1.5;"> pivot;
     </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> low;
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">in-place partition algorithm
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);text-decoration:underline;font-size:12px;line-height:1.5;">http://en.wikipedia.org/wiki/Quicksort</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> in_place_partition(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>* array, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> left, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> right)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> pivot_index = (right-left)/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> pivot =<span style="font-size:12px;line-height:1.5;"> array[pivot_index];
    swap(array[pivot_index], array[right]);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> index =<span style="font-size:12px;line-height:1.5;"> left;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> i = left; i &lt; right; i++<span style="font-size:12px;line-height:1.5;">)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (array[i] &lt; pivot)    <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">升序</span>
<span style="font-size:12px;line-height:1.5;">         {
            swap(array[index], array[i]);
            </span>++<span style="font-size:12px;line-height:1.5;">index;
        }
    }
    swap(array[right], array[index]);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> index;
}

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> Qsort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>* array, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> left, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> right)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (left &gt;=<span style="font-size:12px;line-height:1.5;"> right)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> index =<span style="font-size:12px;line-height:1.5;"> Partition(array, left, right);
    Qsort(array, left, index </span>- <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
    Qsort(array, index </span>+ <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">, right);
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">非递归的快速排序：用栈保存每个待排序子串的首尾元素下标，下一次循环时取出这个范围，对这段子序列进行partition操作，直到所有的子串都排好序，栈也为空了。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">非递归快速排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> QuickSort2(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> vec[],<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> low,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> high)
{
    stack</span>&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;<span style="font-size:12px;line-height:1.5;"> st;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(low &gt;= high) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> mid =<span style="font-size:12px;line-height:1.5;"> Partition(vec,low,high);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(low &lt; mid-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">)
    {
        st.push(low);
        st.push(mid</span>-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
    }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(mid+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span> &lt;<span style="font-size:12px;line-height:1.5;"> high)
    {
        st.push(mid</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
        st.push(high);
    }
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">用栈保存每个待排序子串的首尾元素下标，下一次循环时取出这个范围，对这段子序列进行partition操作</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(!<span style="font-size:12px;line-height:1.5;">st.empty())
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> q =<span style="font-size:12px;line-height:1.5;"> st.top();
        st.pop();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> p=<span style="font-size:12px;line-height:1.5;">st.top();
        st.pop();
        mid </span>=<span style="font-size:12px;line-height:1.5;"> Partition(vec,p,q);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(p &lt; mid-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">)
        {
            st.push(p);
            st.push(mid</span>-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(mid+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span> &lt;<span style="font-size:12px;line-height:1.5;"> q)
        {
            st.push(mid</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
            st.push(q);
        }
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong><img src="https://images0.cnblogs.com/i/434101/201406/211616073328144.gif" alt="" style="border:none;"></strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>7.归并排序（Merge Sort）</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">基本思想是合并两个有序表，设有两个有序（升序）序列存储在同一数组中相邻的位置上，不妨设为A[l..m]，A[m+1..h]，将它们归并为一个有序数列，并存储在A[l..h]。<br> 归并排序的时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlog2n)。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">归并排序是稳定的排序算法。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">将有序序列a[low..mid]和a[mid+1..high]归并到a[low..high]。</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> Merge(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> low, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> mid, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> high)
{
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 归并到b[]</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> i =<span style="font-size:12px;line-height:1.5;"> low;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> j = mid+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> k = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> *b = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>[high-low+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">];
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i &lt;= mid &amp;&amp; j &lt;=<span style="font-size:12px;line-height:1.5;"> high)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (a[i] &lt;= a[j]) { b[k++] = a[i++<span style="font-size:12px;line-height:1.5;">]; }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span>  { b[k++] = a[j++<span style="font-size:12px;line-height:1.5;">]; }
    }
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 归并剩余元素</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i &lt;= mid)  b[k++] = a[i++<span style="font-size:12px;line-height:1.5;">];
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(j &lt;= high)  b[k++] = a[j++<span style="font-size:12px;line-height:1.5;">];
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 从b[]复制回a[]</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i &lt;= high-low; ++<span style="font-size:12px;line-height:1.5;">i)
        a[low</span>+i] =<span style="font-size:12px;line-height:1.5;"> b[i];
    delete []b;
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">归并排序
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);text-decoration:underline;font-size:12px;line-height:1.5;">http://en.wikipedia.org/wiki/Mergesort</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> MergeSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> low, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> high)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(low &gt;= high)  <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span><span style="font-size:12px;line-height:1.5;">
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> mid = (low+high)/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
        MergeSort(a,low,mid);
        MergeSort(a,mid</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">,high);
        Merge(a,low,mid,high);
    }
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">自底向上的归并排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> MergeSort2(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> a[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> s,i,t = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(t &lt;<span style="font-size:12px;line-height:1.5;"> n)
    {
        s </span>= t;  t = s*<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(i=<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i+t&lt;=n; i+=<span style="font-size:12px;line-height:1.5;">t)
            Merge(a,i,i</span>+s-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>,i+t-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(i+s &lt;<span style="font-size:12px;line-height:1.5;"> n)
            Merge(a,i,i</span>+s-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>,n-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">归并排序在最坏的情况下都是O(NlogN)的时间复杂度，缺点是Merge的时候要有O(N)的额外的空间，如何改进？</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">使用原地归并排序 In-place Merge Sort:&nbsp;<a href="http://www.ahathinking.com/archives/103.html" rel="nofollow" style="color:rgb(0,0,0);">http://www.ahathinking.com/archives/103.html</a></p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">reverse array</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> reverse(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> arr[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> size)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> left = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> right = size -<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(left &lt;<span style="font-size:12px;line-height:1.5;"> right)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> temp =<span style="font-size:12px;line-height:1.5;"> arr[left];
        arr[left</span>++] =<span style="font-size:12px;line-height:1.5;"> arr[right];
        arr[right</span>--] =<span style="font-size:12px;line-height:1.5;"> temp;
    }
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> swap [arr,arr+headSize) and [arr+headSize,arr+headSize+endSize)</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> SwapMemory(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> arr[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> headSize, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> endSize)
{
    reverse(arr, headSize);
    reverse(arr </span>+<span style="font-size:12px;line-height:1.5;"> headSize, endSize);
    reverse(arr, headSize </span>+<span style="font-size:12px;line-height:1.5;"> endSize);
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">原地归并</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> Inplace_Merge(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> arr[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> beg, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> mid, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> end)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> i = beg;     <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 指示有序串1</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> j = mid + <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 指示有序串2</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i &lt; j &amp;&amp; j &lt;=<span style="font-size:12px;line-height:1.5;"> end)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(i &lt; j &amp;&amp; arr[i] &lt;=<span style="font-size:12px;line-height:1.5;"> arr[j])
        {
            </span>++<span style="font-size:12px;line-height:1.5;">i;
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> index =<span style="font-size:12px;line-height:1.5;"> j;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(j &lt;= end &amp;&amp; arr[j] &lt;=<span style="font-size:12px;line-height:1.5;"> arr[i])
        {
            </span>++<span style="font-size:12px;line-height:1.5;">j;
        }
        SwapMemory(</span>&amp;arr[i], index-i, j-index);<span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">swap [i,index) and [index,j)</span>
        i += (j-<span style="font-size:12px;line-height:1.5;">index);
    }
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">原地归并排序</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> Inplace_MergeSort(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> arr[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> beg, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> end)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(beg &lt;<span style="font-size:12px;line-height:1.5;"> end)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> mid = (beg + end) / <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
        Inplace_MergeSort(arr, beg, mid);
        Inplace_MergeSort(arr, mid</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">, end);
        Inplace_Merge(arr, beg, mid, end);
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;<img src="https://images0.cnblogs.com/i/434101/201406/211618103951809.gif" alt="" style="border:none;"></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">An example of merge sort. First divide the list into the smallest unit (1 element), then compare each element with the adjacent list to sort and merge the two adjacent lists. Finally all the elements are sorted and merged.</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">参考：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">http://en.wikipedia.org/wiki/Sorting_algorith</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p><font color="#333333">&nbsp; &nbsp; 本文转自阿凡卢博客园博客，原文链接：http://www.cnblogs.com/luxiaoxun/archive/2012/09/01/2666677.html</font><span style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
