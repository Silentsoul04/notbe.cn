<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C#基础回顾：正则表达式 « NotBeCN</title>
  <meta name="description" content="             &nbsp;&nbsp;写在前面：本文根据笔者的学习体会结合相关书籍资料对正则表达式的语法和使用（C#）进行基本的介绍。适用于初学者。    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;摘要：正则表达式(Regular Expressions)，相信做软件开发...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/22/weixin_34304013_90134150.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C#基础回顾：正则表达式</h1>
    <p class="post-meta">Nov 22, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;<a id="anchorTop" name="anchorTop"></a><strong>写在前面：</strong>本文根据<a href="http://stg609.cnblogs.com/" rel="nofollow" style="color:rgb(120,175,211);">笔者</a>的学习体会结合相关书籍资料对正则表达式的语法和使用（C#）进行基本的介绍。适用于初学者。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>摘要：</strong>正则表达式(Regular Expressions)，相信做软件开发的朋友或多或少都对其有所了解，但是你是否可以用其来解决一些问题呢？本文将带着读者从基本的正则语法入手，先向大家展示语法的全貌，然后通过实例演示来对部分语法进行详细介绍。并在结尾给出一些综合性的实例，以便大家参考。<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>索引</strong>：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.cnblogs.com/stg609/archive/2009/06/03/1492709.html#anchorA" rel="nofollow" style="color:rgb(120,175,211);">1.正则表达式语法概述<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.cnblogs.com/stg609/archive/2009/06/03/1492709.html#anchorB" rel="nofollow" style="color:rgb(120,175,211);">2.正则匹配模式</a><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.cnblogs.com/stg609/archive/2009/06/03/1492709.html#anchorC" rel="nofollow" style="color:rgb(120,175,211);">3.Dot Net正则核心对象[部分]<br></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.cnblogs.com/stg609/archive/2009/06/03/1492709.html#anchorD" rel="nofollow" style="color:rgb(120,175,211);">4.部分语法演示</a><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.cnblogs.com/stg609/archive/2009/06/03/1492709.html#anchorE" rel="nofollow" style="color:rgb(120,175,211);">5.综合实例介绍</a></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="anchorA" name="anchorA"></a><strong style="font-size:12pt;"><span style="text-decoration:underline;">1.正则表达式语法概述(下表摘自网络)</span></strong><strong><br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下表基本介绍了在进行正则匹配中会用到的一些元字符以及相应的描述。这个可以当作字典来用，并不要求一下子全部记住。<strong>元字符</strong>：具有特定含义的字符，而不是解释为字符本身的含义，如转义字符'\'等。元字符是区分大小写的。</p> 
   <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">
    <tbody>
     <tr>
      <th style="border:1px solid #C0C0C0;border-collapse:collapse;">元字符</th> 
      <th style="border:1px solid #C0C0C0;border-collapse:collapse;">描述</th> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">^</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配输入字符串的开始位置。如果设置了正则对象的&nbsp;<strong>Multiline</strong>&nbsp;模式，^ 也匹配 '\n' 或 '\r' 之后的位置。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">$</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配输入字符串的结束位置。如果设置了正则对象的&nbsp;<strong>Multiline</strong>&nbsp;模式，$ 也匹配 '\n' 或 '\r' 之前的位置。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">*</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">+</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">?</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">{<em>n</em>}</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <em>n</em>&nbsp;是一个非负整数。匹配确定的&nbsp;<em>n</em>&nbsp;次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">{<em>n</em>,}</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <em>n</em>&nbsp;是一个非负整数。至少匹配<em>n</em>&nbsp;次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">{<em>n</em>,<em>m</em>}</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <em>m</em>&nbsp;和&nbsp;<em>n</em>&nbsp;均为非负整数，其中<em>n</em>&nbsp;&lt;=&nbsp;<em>m</em>。最少匹配&nbsp;<em>n</em>&nbsp;次且最多匹配&nbsp;<em>m</em>&nbsp;次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">?</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">当该字符紧跟在任何一个其他限制符 (*, +, ?, {<em>n</em>}, {<em>n</em>,}, {<em>n</em>,<em>m</em>}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">.</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。当设置了正则对象的<strong>Singleline</strong>模式，也匹配"\n"</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">(<em>表达式</em>)</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配&nbsp;<em><em>表达式</em>&nbsp;</em>并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用&nbsp;<strong>SubMatches</strong>&nbsp;集合，在JScript 中则使用&nbsp;<strong>$0</strong>…<strong>$9</strong>&nbsp;属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">(?:<em>表达式</em>)</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配&nbsp;<em>表达式</em>&nbsp;但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">(?=<em>表达式</em>)</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">正向预查，在任何匹配&nbsp;<em>表达式</em>&nbsp;的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">(?!<em>表达式</em>)</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">负向预查，在任何不匹配&nbsp;<em>表达式</em>&nbsp;的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <em>x</em>|<em>y</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配&nbsp;<em>x</em>&nbsp;或&nbsp;<em>y</em>。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">[<em>xyz</em>]</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">[^<em>xyz</em>]</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">[<em>a-z</em>]</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">[^<em>a-z</em>]</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\b</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\B</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\c<em>x</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配由&nbsp;<em>x&nbsp;</em>指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。<em>x</em>&nbsp;的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\d</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个数字字符。等价于 [0-9]。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\D</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个非数字字符。等价于 [^0-9]。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\f</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个换页符。等价于 \x0c 和 \cL。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\n</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个换行符。等价于 \x0a 和 \cJ。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\r</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个回车符。等价于 \x0d 和 \cM。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\s</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [&nbsp;\f\n\r\t\v]。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\S</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配任何非空白字符。等价于 [^&nbsp;\f\n\r\t\v]。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\t</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个制表符。等价于 \x09 和 \cI。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\v</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\w</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\W</td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\x<em>n</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配&nbsp;<em>n</em>，其中&nbsp;<em>n</em>&nbsp;为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' &amp; "1"。正则表达式中可以使用 ASCII 编码。.</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\<em>num</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配&nbsp;<em>num</em>，其中&nbsp;<em>num</em>&nbsp;是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\<em>n</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">标识一个八进制转义值或一个向后引用。如果 \<em>n</em>&nbsp;之前至少&nbsp;<em>n</em>&nbsp;个获取的子表达式，则&nbsp;<em>n</em>&nbsp;为向后引用。否则，如果&nbsp;<em>n</em>&nbsp;为八进制数字 (0-7)，则&nbsp;<em>n</em>&nbsp;为一个八进制转义值。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\<em>nm</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">标识一个八进制转义值或一个向后引用。如果 \<em>nm</em>&nbsp;之前至少有&nbsp;<em>nm</em>&nbsp;个获得子表达式，则&nbsp;<em>nm</em>&nbsp;为向后引用。如果 \<em>nm</em>&nbsp;之前至少有&nbsp;<em>n</em>&nbsp;个获取，则&nbsp;<em>n</em>&nbsp;为一个后跟文字&nbsp;<em>m&nbsp;</em>的向后引用。如果前面的条件都不满足，若&nbsp;<em>n</em>&nbsp;和&nbsp;<em>m</em>&nbsp;均为八进制数字 (0-7)，则 \<em>nm</em>&nbsp;将匹配八进制转义值&nbsp;<em>nm</em>。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\<em>nml</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">如果&nbsp;<em>n</em>&nbsp;为八进制数字 (0-3)，且&nbsp;<em>m</em>&nbsp;和&nbsp;<em>l</em>&nbsp;均为八进制数字 (0-7)，则匹配八进制转义值&nbsp;<em>nml。</em> </td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">\u<em>n</em> </td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">匹配&nbsp;<em>n</em>，其中&nbsp;<em>n</em>&nbsp;是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (©)。</td> 
     </tr>
    </tbody>
   </table>
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="anchorB" name="anchorB"></a><strong style="font-size:12pt;"><span style="text-decoration:underline;">2.正则匹配模式</span></strong><strong><br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正则匹配中，一般有三种匹配模式：单行、多行和忽略大小写。除了忽略大小写这个之外，其余2个模式很容易误导使用者（包括我自己在内），初学者会下意识的认为此2者不能共存，其实不然。这2个模式的作用效果并不冲突，使用这2个模式只会改变某几个元字符（或者称关键字）的意义，从而使得匹配的时候产生不同的效果。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.1 单行模式（Singleline）<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果观察上表，会发现已经在描述[.]元字符的时候对单行模式的作用进行了解释：使得点[.]可以用来解释换行符。这在多行应用中会有很大的便捷性。试想，原来如果你需要匹配&lt;script&gt;&lt;/script&gt;标签内容你会如何操作：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <span style="color:rgb(0,0,255);line-height:1.5;">&lt;</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">script</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">&gt;</span>
    <span style="line-height:1.5;"><br></span>
    <span style="color:rgb(0,0,255);line-height:1.5;">function</span>
    <span style="line-height:1.5;">&nbsp;js()<br> {<br> &nbsp;&nbsp;&nbsp;alert(</span>
    <span style="line-height:1.5;">'</span>
    <span style="line-height:1.5;">恶意代码</span>
    <span style="line-height:1.5;">'</span>
    <span style="line-height:1.5;">)<br> }<br></span>
    <span style="color:rgb(0,0,255);line-height:1.5;">&lt;/</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">script</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">&gt;</span> 
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为，[.]不解释换行符，这将使得你需要手动输入换行符来进行匹配。当启用了单行模式后，你就可以简单的一句话搞定：&lt;script&gt;.*?&lt;/script&gt;。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.2 多行模式（Multiline）<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样上表中已经有关于多行模式的解释即：使得"^"和"$"元字符匹配每一行的开头和结尾。相比未采用该模式的时候，这两个字符匹配的则是整个字符串的开头和结尾。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.3 忽略大小写(IgnoreCase)<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个相信不需要多讲，如果未采用该模式，为了匹配全部所需的结果，可能你要在表达式中罗列所有大小写情况，现在你只需要启用该模式就可以省了很多麻烦。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>本节内容可以参考：</span><a id="AjaxHolder_ctl01_TitleUrl" class="postTitle2" href="http://www.cnblogs.com/Rainy/archive/2006/08/05/468227.html" rel="nofollow" style="border-bottom-style:dotted;border-bottom-width:0px;border-bottom-color:rgb(239,239,239);color:rgb(120,175,211);text-decoration:none;"><span>正则表达式的3种匹配模式</span></a></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="anchorC" name="anchorC"></a><strong><span style="text-decoration:underline;">3.Dot Net正则核心对象[部分]<br></span></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命名空间：using System.Text.RegularExpressions;</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.1 Regex类<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类是Dot Net正则表达式的核心。其中包括了若干静态方法，这使得我们可以不构造Regex对象就可以使用其功能。Regex 类是不可变（只读）的，并且具有固有的线程安全性。可以在任何线程上创建 Regex 对象，并在线程间共享。一般可以利用该类的构造函数来定义所需要的表达式及匹配模式。演示（摘自MSDN）：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <img src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" alt="" width="11" height="16" align="top" style="border:0px;">
    <span class="cnblogs_code_Collapse" style="border:1px solid #808080;line-height:1.5;">Regex使用演示</span> 
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.2 Match类<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>该类用于表示单个正则表达式的匹配。可以通过多种方式来得到该对象：1）利用Regex.Match()方法返回一个Match对象；2）利用Match对象本身的NextMatch（）方法来返回一个新的Match对象。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Match对象的主要属性及方法：</p> 
   <div class="MTPS_CollapsibleSection" style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"> 
    <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;">
     <tbody>
      <tr>
       <th style="border:1px solid #C0C0C0;border-collapse:collapse;">属性名称</th> 
       <th style="border:1px solid #C0C0C0;border-collapse:collapse;">说明</th> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Captures</span>&nbsp;</td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">按从里到外、从左到右的顺序获取由捕获组匹配的所有捕获的集合（如果正则表达式用&nbsp;<span style="color:rgb(0,51,204);">RegexOptions.RightToLeft</span>&nbsp;选项修改了，则顺序为按从里到外、从右到左）。该集合可以有零个或更多的项。（从&nbsp;<span style="color:rgb(0,51,204);">Group</span>&nbsp;继承。）</td> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="color:rgb(0,51,204);">Empty</span></td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">获取空组。所有失败的匹配都返回此空匹配。</td> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="color:rgb(0,51,204);">Groups</span></td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">获取由正则表达式匹配的组的集合。</td> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Index</span>&nbsp;</td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">原始字符串中发现捕获的子字符串的第一个字符的位置。（从&nbsp;<span style="color:rgb(0,51,204);">Capture</span>&nbsp;继承。）</td> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Length</span>&nbsp;</td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">捕获的子字符串的长度。（从&nbsp;<span style="color:rgb(0,51,204);">Capture</span>&nbsp;继承。）</td> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Success</span>&nbsp;</td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">获取一个值，该值指示匹配是否成功。（从&nbsp;<span style="color:rgb(0,51,204);">Group</span>&nbsp;继承。）</td> 
      </tr>
      <tr>
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Value</span>&nbsp;</td> 
       <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">从输入字符串中获取捕获的子字符串。（从&nbsp;<span style="color:rgb(0,51,204);">Capture</span>&nbsp;继承。）</td> 
      </tr>
     </tbody>
    </table>
   </div> 
   <div class="MTPS_CollapsibleSection" style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">
    &nbsp;
   </div> 
   <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">
    <tbody>
     <tr>
      <th style="border:1px solid #C0C0C0;border-collapse:collapse;">方法名称</th> 
      <th style="border:1px solid #C0C0C0;border-collapse:collapse;">说明</th> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="color:rgb(128,0,128);">NextMatch</span></td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">从上一个匹配结束的位置（即在上一个匹配字符之后的字符）开始返回一个包含下一个匹配结果的新&nbsp;<strong>Match</strong>。</td> 
     </tr>
     <tr>
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="color:rgb(0,51,204);">Result</span></td> 
      <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">返回已传递的替换模式的扩展。例如，如果替换模式为 $1$2，则&nbsp;<strong>Result</strong>&nbsp;返回&nbsp;<strong>Groups[1].Value 和 Groups[2].Value</strong>（在 Visual Basic 中为&nbsp;<strong>Groups[1].Value 和 Groups[2].Value</strong>）的串联。</td> 
     </tr>
    </tbody>
   </table>
   <div style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">
    &nbsp;
   </div> 
   <div style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">
    &nbsp;
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.3 Group类<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从Match类的主要属性中可以看出有一部分属性是继承自Group类，如果你看了Group类，则会发现Match和Group很类似。</p> 
   <div class="MTPS_CollapsibleRegion" style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"> 
    <div class="MTPS_CollapsibleSection"> 
     <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;">
      <tbody>
       <tr>
        <th style="border:1px solid #C0C0C0;border-collapse:collapse;">属性名称</th> 
        <th style="border:1px solid #C0C0C0;border-collapse:collapse;">说明</th> 
       </tr>
       <tr>
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="color:rgb(0,51,204);">Captures</span></td> 
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">按从里到外、从左到右的顺序获取由捕获组匹配的所有捕获的集合（如果正则表达式用&nbsp;<span style="color:rgb(0,51,204);">RegexOptions.RightToLeft</span>&nbsp;选项修改了，则顺序为按从里到外、从右到左）。该集合可以有零个或更多的项。</td> 
       </tr>
       <tr>
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Index</span>&nbsp;</td> 
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">原始字符串中发现捕获的子字符串的第一个字符的位置。（从&nbsp;<span style="color:rgb(0,51,204);">Capture</span>&nbsp;继承。）</td> 
       </tr>
       <tr>
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Length</span>&nbsp;</td> 
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">捕获的子字符串的长度。（从&nbsp;<span style="color:rgb(0,51,204);">Capture</span>&nbsp;继承。）</td> 
       </tr>
       <tr>
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"><span style="color:rgb(0,51,204);">Success</span></td> 
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">获取一个值，该值指示匹配是否成功。</td> 
       </tr>
       <tr>
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;"> <span style="color:rgb(0,51,204);">Value</span>&nbsp;</td> 
        <td style="font-size:12px;border:1px solid #C0C0C0;border-collapse:collapse;">从输入字符串中获取捕获的子字符串。（从&nbsp;<span style="color:rgb(0,51,204);">Capture</span>&nbsp;继承。）</td> 
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="MTPS_CollapsibleSection"> 
     <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
     <span>这里只列出了常用的核心对象，其它对象请大家参考：</span>
     <span><a href="http://msdn.microsoft.com/zh-cn/library/system.text.regularexpressions(VS.80).aspx" rel="nofollow" style="color:rgb(120,175,211);">MSDN</a></span> 
    </div> 
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="anchorD" name="anchorD"></a><strong style="font-size:12pt;"><span style="text-decoration:underline;">4.部分语法演示</span></strong><strong><br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.1 匹配纯文本<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个是最简单的正则匹配，但是实际场景中很少会单独进行纯文本的匹配，一般都会与其它情况相结合。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：This is a&nbsp;test&nbsp;.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：test<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：This is a&nbsp;<span>t</span><span>est</span>&nbsp;.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <span style="line-height:1.5;">Regex&nbsp;r&nbsp;</span>
    <span style="line-height:1.5;">=</span>
    <span style="line-height:1.5;">&nbsp;</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">new</span>
    <span style="line-height:1.5;">&nbsp;Regex(</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">test</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="line-height:1.5;">);</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">构造表达式</span>
    <span style="color:rgb(0,128,0);line-height:1.5;"><br></span>
    <span style="line-height:1.5;">Match&nbsp;m&nbsp;</span>
    <span style="line-height:1.5;">=</span>
    <span style="line-height:1.5;">&nbsp;r.Match(</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">This&nbsp;is&nbsp;a&nbsp;test&nbsp;.</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="line-height:1.5;">);</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">匹配源文本</span>
    <span style="color:rgb(0,128,0);line-height:1.5;"><br></span>
    <span style="color:rgb(0,0,255);line-height:1.5;">if</span>
    <span style="line-height:1.5;">(m.Success)<br> {</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">匹配成功</span>
    <span style="color:rgb(0,128,0);line-height:1.5;"><br></span>
    <span style="line-height:1.5;">&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(m.Value);</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">获取捕获的字符串</span>
    <span style="color:rgb(0,128,0);line-height:1.5;"><br></span>
    <span style="line-height:1.5;">}</span> 
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.2 匹配任意字符<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配纯文本，并没有显示出正则表达式的魅力，接着来看看如何匹配任意字符。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：1）点[.]字符，可以用来匹配任何单个字符，除换行符。只有当选择单行模式的时候，才可以匹配换行符；2）*号用来表示重复多次匹配[会在后面介绍]<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：afewf@#$%^&amp;"'./,:~!123 sffsf<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：.*<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>afewf@#$%^&amp;"'./,:~!123 sffsf</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <span style="line-height:1.5;">Regex&nbsp;r&nbsp;</span>
    <span style="line-height:1.5;">=</span>
    <span style="line-height:1.5;">&nbsp;</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">new</span>
    <span style="line-height:1.5;">&nbsp;Regex(</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">.*</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="line-height:1.5;">);<br> Match&nbsp;m&nbsp;</span>
    <span style="line-height:1.5;">=</span>
    <span style="line-height:1.5;">&nbsp;r.Match(</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">afewf@#$%^&amp;</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">"'</span>
    <span style="color:rgb(128,0,0);line-height:1.5;">./,:~!123&nbsp;sffsf");</span>
    <span style="color:rgb(128,0,0);line-height:1.5;"><br></span>
    <span style="color:rgb(0,0,255);line-height:1.5;">if</span>
    <span style="line-height:1.5;">(m.Success)<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine(m.Value);<br> }</span> 
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.3 匹配特殊字符<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要匹配特定的某个字符，该怎么办？如果你还记得4.1的演示，就应该知道可以直接用该字符去匹配。可是，如果要匹配的那个字符是元字符，那这个办法就无效了，因为它被解释为其它含义，而非字符本身。这个时候，需要用到转义字符‘\’。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：使用转义字符对元字符进行转义。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：C:\windows&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：C:\\windows<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>C:\windows</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.4 匹配字符集合</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有的时候，我们要匹配的字符有多种可能的情形，比如大小写不同的字符或者干脆就是完全不同的字符。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：使用“[”和“]”元字符来囊括所有可能出现的字符情形。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：1.txt 2.txt 3.txt a1.txt a2.txt 4b.txt 4B.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：[123bB]\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>1.txt</span>&nbsp;<span>2.txt</span>&nbsp;<span>3.txt</span>&nbsp;a<span>1.txt</span>&nbsp;a<span>2.txt</span>&nbsp;4<span>b.txt</span>&nbsp;4<span>B.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分析</strong>：“[”和“]”本身不匹配任何字符，只负责定义一个字符集合。这两个符号之间的所有组成部分都是字符。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>技巧</strong>：在使用字符集合的时候，可能会经常使用[0123456789]、[abcdefgh]等等连接的集合，这个时候我们可以利用一个“-”连字符来简化。如[0-9]、[a-h]等。需要注意的是：1）避免让这个区间的尾字符小于它的首字符，如[z-a]；2）“-”连字符只有出现在“[”和“]”之间才被视为元字符，在其它情况下，它只是一个普通的字符。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.5 匹配数字</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0-9]可以用来匹配任何一个数字，还可以有更简化的写法"\d"。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：1.txt 2.txt 3.txt&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\d\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>1.txt</span>&nbsp;<span>2.txt</span>&nbsp;<span>3.txt</span>&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6 匹配字母和数字<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字母、数字及下划线经常用作文件名的规范，可以用"\w"来匹配这三种情形，类似于[a-zA-Z0-9_]。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：1.txt 2.txt 3.txt a.txt&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\w\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>1.txt</span>&nbsp;<span>2.txt</span>&nbsp;<span>3.txt</span>&nbsp;<span>a.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.7 匹配一个或多个字符</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.6 所示的文件名都只有一个字符，但是更多的情况是会出现多个字符如"abc.txt"、 "a2a2.txt"。这种情况就需要我们匹配多个字符。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：想要匹配一个字符的多次出现。可以使用“+”元字符。“+”元字符用来匹配字符的一次或多次重复。比如可以用a+\.txt来匹配a.txt、aa.txt、aaaaaaa.txt。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：a234_234.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\w+\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>a234_234.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分析</strong>：上述匹配时，\w作为整一个元字符被进行一次或多次重复。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.8 匹配零个或多个字符</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与4.7不同的是可以匹配零个字符。而4.7必须要匹配到一个字符。如果将4.7的表达式改成\w*\.txt，仍可以匹配成功。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：匹配零个或多个，可以使用“*”元字符。可以利用a*\.txt来匹配.txt、a.txt、aa.txt。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：a234_234.txt、.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\w*\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>a234_234.txt</span>、<span>.txt<br></span><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.9 匹配零个或１个字符</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：“?”元字符，可以用来匹配零个或1个字符。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：a234_234.txt、.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\w?\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：a234_23<span>4.txt</span>、<span>.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.10 匹配的重复次数</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+、*都可以进行多次重复匹配，但是无法限制匹配次数，如果只需要匹配有限次数，该怎么办呢？<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：“{”和“}”之间的数字可以用来限制匹配的最小、最大次数。1）{2}表示匹配2次；2）{2，}表示至少匹配2次，最多不限；3）{2，4}表示至少匹配2次，最多匹配4次。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：a234_234.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\w{2,4}\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：a234<span>_234.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.11 贪婪型匹配与懒惰型匹配<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述4.7、4.8、4.10中的{n, }都属于贪婪型元字符。之所以称之为贪婪型，是由于*、+、{n, }在匹配的时候都是按多匹配、多多益善而不是适可而止。如，使用&lt;title&gt;.*&lt;/title&gt;匹配"&lt;title&gt;this is title&lt;/title&gt; aaaa &lt;/title&gt; ssss"，则匹配的结果并不是所希望的&lt;title&gt;this is title&lt;/title&gt;而是""&lt;title&gt;this is title&lt;/title&gt; aaaa &lt;/title&gt;"。那么如何才能让匹配适可而止呢？<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：在贪婪型匹配元字符后加上“?”元字符，就可以成为懒惰型匹配，进行适可而止的匹配。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：&lt;title&gt;this is title&lt;/title&gt; aaaa &lt;/title&gt; ssss<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：&lt;title&gt;.*?&lt;/title&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>&lt;title&gt;this is title&lt;/title&gt;</span>&nbsp;aaaa &lt;/title&gt; ssss<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.12 子表达式</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义，子表达式自然是整个表达式的一部分。就好像我们小学数学的算式一样：1+2*（3+4）+3，其中（3+4）就是一个子表达式。可以把子表达式看成是一个小的整体。子表达式，会在许多场合使用到，且允许嵌套。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：abcabcabc.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：(abc){3}\.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>abcabcabc.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.13 回溯引用匹配</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回溯即要前后呼应，比如&lt;H1&gt;test&lt;/H1&gt;，开始标签是&lt;H1&gt;，结束标签也要是&lt;/H1&gt;。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：利用子表达式作为参数，根据子表达式出现的顺序进行相应的查找。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：&lt;H1&gt;this is Test&lt;/H1&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：&lt;H([1-6])&gt;.*?&lt;/H(\1)&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>&lt;H1&gt;this is Test&lt;/H1&gt;</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分析</strong>：([1-6])作为一个子表达式，相当于一个参数。(\1)中的"1"表示第一个子表达式，但是1只是一个普通的字符，因此需要\1对1进行转义，使之表示第一个表达式所匹配到的结果。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.14 向前查找<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有的时候，我们需要匹配的是某一个字符之前的一段字符串，比如我们需要匹配stg609@163.com中@前面的一段字符串，该如何呢？<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：向前查找，实际上就是匹配一个必须匹配但并不返回该结果的匹配方法，使用(?=)来实现。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：stg609@163.com<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\w+?(?=@)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：<span>stg609</span>@163.com<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.15 向后查找<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你明白了向前查找，那向后查找就很容易了。区别的只是元字符的不同。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：使用(?&lt;=)来实现。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：stg609@163.com<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：(?&lt;=@)[\w\.]+<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：stg609@<span>163.com</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.16 单词边界</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看过上面几个例子，你是不是觉得有什么不妥？是否发现我们匹配出来的结果有的时候只是某个单词的一部分，我想这应该不是你希望得到的结果。那么如何来匹配一个完整的单词呢？下面我们对4.10进行改进<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：使用\b来匹配一个单词的开始与结束。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：a234_234.txt、234.txt<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：\b\w{2,4}\.txt\b<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：a234_234.txt、<span>234.txt</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分析</strong>：因为增加了单词边界的限制，所以a234_234.txt就不能得到匹配。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：类似于4.1的代码，不在缀述。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.17 分组匹配<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个URL，如果你想同时获取这个URL的协议部分和域名部分，该怎么做呢？<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>要点</strong>：通过(?name)来定义一个分组。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>源文本</strong>：this is a url :&nbsp;<a href="http://stg609.cnblogs.com/" rel="nofollow" style="color:rgb(120,175,211);">http://stg609.cnblogs.com/</a><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表达式</strong>：(?&lt;Protocol&gt;\w+?)://(?&lt;Address&gt;[\w\.]+)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>匹配结果</strong>：this is a url :&nbsp;<span>http://stg609.cnblogs.com/</span><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分组1名称：Protocol&nbsp; 分组1捕获：http<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分组2名称：Address&nbsp; 分组2捕获：stg609.cnblogs.com<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分析</strong>：(?&lt;Protocol&gt;\w+?)用来捕获http，其中&lt;Protocol&gt;是分组的名称，\w+?则是普通的表达式。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>C# Code</strong>：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <img src="https://www.cnblogs.com/Images/OutliningIndicators/ContractedBlock.gif" alt="" width="11" height="16" align="top" style="border:0px;">
    <span class="cnblogs_code_Collapse" style="border:1px solid #808080;line-height:1.5;">分组匹配</span> 
   </div> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id="anchorE" name="anchorE"></a><strong style="font-size:12pt;"><span style="text-decoration:underline;">5.综合性实例</span></strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下实例按照每一个示例所写的“规则”，进行正则匹配。其中的“规则”不一定严密，只为举例所用，实际应用中，请大家根据具体的“规则”编写正则表达式。<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>5</strong><strong>.1 匹配邮箱地址<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;邮箱命名规则：1）邮箱用户名可由英文字母、数字、连接符即[减号-]、下划线、点[.]组成，但开头只能用英文字母或数字。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）必须包含一个"@"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）在"@"后面的字符串至少包含一个点[.]号<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配表达式：[\w\d]+[\w._-\d]*@[\w._-\d]+\.[\w._-\d]+<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点分析：[\w\d]+用来匹配开头1个或多个字母、数字；[\w._-\d]*用来匹配0个或多个字母、数字、下划线、连接符、点；@用来匹配<a href="mailto:' rel=" nofollow"@'" style="color:rgb(120,175,211);">'@'</a>；</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>5.2 匹配IP地址</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IPv4地址规则：1）每一个数字范围为0-255<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 共有4个数字，每相邻的2个数字之间通过点[.]分隔<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配表达式：((1\d{2}|25[0-5]|2[0-4]\d|\d{1,2})\.){3}(1\d{2}|25[0-5]|2[0-4]\d|\d{1,2})<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点分析：(1\d{2}|25[0-5]|2[0-4]\d|\d{1,2})利用分支语法提供4种可选的数字即1XX、250-255、20X-24X、XX；<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要点：分支条件根据从左到右的顺序进行匹配，如果已经找到适合的匹配，则不再进行其它分支的匹配。因此，要把\d{1,2}作为最后一个分支条件，否则可能会丢失对某些3位数的匹配。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><strong>5</strong>.3 匹配HTML注释</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML注释规则：注释必须放在&lt;!--和--&gt;标签之间<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配表达式：&lt;!--.*?--&gt;</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><strong>5</strong>.4 匹配HTML标签对</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTML标签对规则：1）标签必须由'&lt;'和'&gt;'包括<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2）结束标签必须由'&lt;/'和'&gt;'包括<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配表达式：&lt;td\s*?.*?&gt;.*?&lt;/td&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配模式：单行模式、忽略大小写<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要点：此表达式中，通过?来限制重复度，防止过度匹配。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>5.5 匹配HTML标签对2<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标题标签(&lt;H1&gt;-&lt;H6&gt;)规则：开始标签必须与结束标签相同<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配表达式：&lt;h([1-6])&gt;.*?&lt;/h(\1)&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配模式：单行模式、忽略大小写<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点分析：（[1-6]）用来表示一个子表达式（分组）；（\1）用来回溯引用整个表达式前半部分中定义的子表达式，\1表示是第一个子表达式，\2表示第二个表达式，依次类推。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要点：使用回溯引用来难保前后一致。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>5.6 匹配&lt;Title&gt;&lt;/Title&gt;标签对之间的内容</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配表达式：(?&lt;=&lt;Title&gt;).*?(?=&lt;/Title&gt;)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;匹配模式：单行模式、忽略大小写<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点分析：(?&lt;=&lt;Title&gt;)用来向后匹配&lt;Title&gt;开头的字符串，但是并不消费&lt;Title&gt;本身；(?=&lt;/Title&gt;)用来向前匹配&lt;/Title&gt;结尾的字条串，但是并不消费&lt;/Title&gt;本身；最终返回的匹配结果包含且仅包含该标签对之间的文字；<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要点：使用向前?=、向后?&lt;=查找来进行匹配。</p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考资料：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) Ben Forta,《正则表达式必知必会》,[M],2007.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;<a class="postTitle2" href="http://www.cnblogs.com/Rainy/archive/2006/08/05/468227.html" rel="nofollow" style="border-bottom-style:dotted;border-bottom-width:0px;border-bottom-color:rgb(239,239,239);color:rgb(120,175,211);text-decoration:none;">正则表达式的3种匹配模式</a><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)&nbsp;<a href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html" rel="nofollow" style="color:rgb(120,175,211);"><span style="color:rgb(0,102,170);">正则表达式30分钟入门教程</span></a><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)&nbsp;<a href="http://msdn.microsoft.com/zh-cn/library/system.text.regularexpressions(VS.80).aspx" rel="nofollow" style="color:rgb(120,175,211);">MSDN</a></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br></p> 
   <p style="font-family:'black Verdana', Arial, Helvetica, sans-serif;font-size:14px;line-height:21px;"><br></p> 
   <p><font><span style="font-size:14px;line-height:21px;">本文转自stg609博客园博客，原文链接：http://www.cnblogs.com/stg609/archive/2009/06/03/1492709.html，如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
