<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>程序猿必知的10大经典基础有用算法 « NotBeCN</title>
  <meta name="description" content="                 程序猿必知的10大经典基础实用算法                      算法一：高速排序算法                       　　高速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比較。在最坏状况下则须要Ο(n2)...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/22/weixin_34138255_90131796.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">程序猿必知的10大经典基础有用算法</h1>
    <p class="post-meta">Nov 22, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div style="font-size:14px;text-align:center;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><span style="line-height:1.8;"><strong><span style="line-height:1.8;font-size:24px;">程序猿必知的10大经典基础实用算法</span></strong><br></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><span style="line-height:1.8;"><strong><br></strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><span style="line-height:1.8;"><strong>算法一：高速排序算法</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　高速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比較。在最坏状况下则须要Ο(n2) 次比較，但这样的状况并不常见。其实，高速排序通常明显比其它Ο(n log n) 算法更快，由于它的内部循环（inner loop）能够在大部分的架构上很有效率地被实现出来。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　高速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　1 从数列中挑出一个元素，称为 “基准”（pivot）。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　2 又一次排序数列，全部元素比基准值小的摆放在基准前面。全部元素比基准值大的摆在基准的后面（相同的数能够到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。 </span>
    <p></p> 
    <p>这个称为分区（partition）操作。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，可是这个算法总会退出。由于在每次的迭代（iteration）中。它至少会把一个元素摆到它最后的位置去。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <p style="margin-left:auto;text-align:center;"><a href="http://www.apkbus.com/data/attachment/portal/201406/20/141124qmx0m6jm806dzmmx.gif" rel="nofollow" style="color:rgb(51,51,51);border-bottom:1px dotted rgb(51,51,51);"><img src="http://www.apkbus.com/data/attachment/portal/201406/20/141124qmx0m6jm806dzmmx.gif" alt="" style="border:none;"></a></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　<span style="line-height:1.8;">　<strong>算法二：堆排序算法</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　堆排序（Heapsort）是指利用堆这样的数据结构所设计的一种排序算法。 </span>
    <p></p> 
    <p>堆积是一个近似全然二叉树的结构，并同一时候满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　堆排序的平均时间复杂度为Ο(nlogn) 。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">&nbsp; &nbsp; 1. &nbsp;创建一个堆H[0..n-1]</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">&nbsp; &nbsp; 2. &nbsp;把堆首（最大值）和堆尾互换</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　3. &nbsp;把堆的尺寸缩小1，并调用 shift_down (0)，目的是把新的数组顶端数据调整到相应位置</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　4. &nbsp;反复步骤2。直到堆的尺寸为1</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <p style="margin-left:auto;text-align:center;"><a href="http://www.apkbus.com/data/attachment/portal/201406/20/141124cxlknb7i732aqki4.gif" rel="nofollow" style="color:rgb(51,51,51);border-bottom:1px dotted rgb(51,51,51);"><img src="http://www.apkbus.com/data/attachment/portal/201406/20/141124cxlknb7i732aqki4.gif" alt="" style="border:none;"></a></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;"><strong>算法三：归并排序</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　归并排序（Merge sort。台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是採用分治法（Divide and Conquer）的一个很典型的应用。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　1. &nbsp;申请空间，使其大小为两个已经排序序列之和。该空间用来存放合并后的序列</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　2. &nbsp;设定两个指针，最初位置分别为两个已经排序序列的起始位置</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　3. &nbsp;比較两个指针所指向的元素，选择相对小的元素放入到合并空间。并移动指针到下一位置</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　4. &nbsp;反复步骤 3 直到某一指针达到序列尾</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　5. &nbsp;将还有一序列剩下的全部元素直接拷贝到合并序列尾</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <p style="margin-left:auto;text-align:center;"><a href="http://www.apkbus.com/data/attachment/portal/201406/20/141125dedgeaomaeoodce3.gif" rel="nofollow" style="color:rgb(51,51,51);border-bottom:1px dotted rgb(51,51,51);"><img src="http://www.apkbus.com/data/attachment/portal/201406/20/141125dedgeaomaeoodce3.gif" alt="" style="border:none;"></a></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;"><strong>算法四：二分查找算法</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。 </span>
    <p></p> 
    <p>搜素过程从数组的中间元素開始，假设中间元素正好是要查找的元素，则搜素过程结束；假设某一特定元素大于或者小于中间元素。则在数组大于或小于中间元素的那一半中查找，并且跟開始一样从中间元素開始比較。</p> 
    <p>假设在某一步骤数组为空，则代表找不到。这样的搜索算法每一次比較都使搜索范围缩小一半。折半搜索每次把搜索区域降低一半。时间复杂度为Ο(logn) 。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;"><strong>算法五：BFPRT(线性查找算法)</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　BFPRT 算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素。通过巧妙的分析，BFPRT 能够保证在最坏情况下仍为线性时间复杂度。该算法的思想与高速排序思想类似，当然，为使得算法在最坏情况下，依旧能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　1. &nbsp;将n个元素每 5 个一组，分成n/5(上界)组。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　2. &nbsp;取出每一组的中位数，随意排序方法，比方插入排序。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　3. &nbsp;递归的调用 selection 算法查找上一步中全部中位数的中位数。设为x，偶数个中位数的情况下设定为选取中间小的一个。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　4. &nbsp;用x来切割数组，设小于等于x的个数为k，大于x的个数即为n-k。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　5. &nbsp;若i==k，返回x。若i&lt;k，在小于x的元素中递归查找第i小的元素。若i&gt;k。在大于x的元素中递归查找第i-k 小的元素。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　终止条件：n=1 时。返回的即是i小元素。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　<span style="line-height:1.8;">　<strong>算法六：DFS（深度优先搜索）</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的全部边都己被探寻过。搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的全部节点为止。 </span>
    <p></p> 
    <p>假设还存在未被发现的节点，则选择当中一个作为源节点并反复以上过程，整个进程反复进行直到全部节点都被訪问为止。</p> 
    <p>DFS 属于盲目搜索。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　深度优先搜索是图论中的经典算法，利用深度优先搜索算法能够产生目标图的相应拓扑排序表，利用拓扑排序表能够方便的解决很多相关的图论问题。如最大路径问题等等。一般用堆数据结构来辅助实现 DFS 算法。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">深度优先遍历图算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　1. &nbsp;訪问顶点v；</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　2. &nbsp;依次从v的未被訪问的邻接点出发。对图进行深度优先遍历；直至图中和v有路径相通的顶点都被訪问。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　3. &nbsp;若此时图中尚有顶点未被訪问。则从一个未被訪问的顶点出发，又一次进行深度优先遍历，直到图中全部顶点均被訪问过为止。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　上述描写叙述可能比較抽象，举个实例：</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　DFS 在訪问图中某一起始顶点 v 后，由 v 出发。訪问它的任一邻接顶点 w1。再从 w1 出发。訪问与 w1 邻 接但还没有訪问过的顶点 w2；然后再从 w2 出发，进行类似的訪问，… 如此进行下去，直至到达全部的邻接顶点都被訪问过的顶点 u 为止。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　接着，退回一步，退到前一次刚訪问过的顶点，看是否还有其它没有被訪问的邻接顶点。假设有，则訪问此顶点。之后再从此顶点出发。进行与前述类似的訪问；假设没有。就再退回一步进行搜索。反复上述过程，直到连通图中全部顶点都被訪问过为止。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;"><strong>算法七：BFS (广度优先搜索)</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说。BFS 是从根节点開始，沿着树(图)的宽度遍历树(图)的节点。假设全部节点均被訪问，则算法中止。BFS 相同属于盲目搜索。一般用队列数据结构来辅助实现 BFS 算法。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　1. &nbsp;首先将根节点放入队列中。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　2. &nbsp;从队列中取出第一个节点。并检验它是否为目标。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">假设找到目标。则结束搜寻并回传结果。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">否则将它全部尚未检验过的直接子节点增加队列中。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　3. &nbsp;若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　4. &nbsp;反复步骤2。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <p style="margin-left:auto;text-align:center;"><a href="http://www.apkbus.com/data/attachment/portal/201406/20/141125e3v484nr4q4lq66a.gif" rel="nofollow" style="color:rgb(51,51,51);border-bottom:1px dotted rgb(51,51,51);"><img src="http://www.apkbus.com/data/attachment/portal/201406/20/141125e3v484nr4q4lq66a.gif" alt="" style="border:none;"></a></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;"><strong>算法八：Dijkstra算法</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　戴克斯特拉算法（Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法终于得到一个最短路径树。该算法经常使用于路由算法或者作为其它图算法的一个子模块。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　该算法的输入包括了一个有权重的有向图 G，以及G中的一个来源顶点 S。 </span>
    <p></p> 
    <p>我们以 V 表示 G 中全部顶点的集合。每个图中的边，都是两个顶点所形成的有序元素对。</p> 
    <p>(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中全部边的集合。而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重能够想像成两个顶点之间的距离。</p> 
    <p>任两点间路径的权重，就是该路径上全部边的权重总和。</p> 
    <p>已知有 V 中有顶点 s 及 t，Dijkstra 算法能够找到 s 到 t的最低权重路径(比如，最短路径)。这个算法也能够在一个图中，找到从一个顶点 s 到不论什么其它顶点的最短路径。对于不含负权的有向图。Dijkstra 算法是眼下已知的最快的单源最短路径算法。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　1. &nbsp;初始时令 S={V0},T={其余顶点}，T中顶点相应的距离值</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　若存在&lt;V0,Vi&gt;，d(V0,Vi)为&lt;V0,Vi&gt;弧上的权值</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　若不存在&lt;V0,Vi&gt;。d(V0,Vi)为∞</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　2. &nbsp;从T中选取一个其距离值为最小的顶点W且不在S中，增加S</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　3. &nbsp;对其余T中顶点的距离值进行改动：若加进W作中间顶点，从 V0 到 Vi 的距离值缩短。则改动此距离值</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　反复上述步骤2、3，直到S中包括全部顶点，即W=Vi 为止</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <p style="margin-left:auto;text-align:center;"><a href="http://www.apkbus.com/data/attachment/portal/201406/20/141125w1p2t48ewt22t6tw.gif" rel="nofollow" style="color:rgb(51,51,51);border-bottom:1px dotted rgb(51,51,51);"><img src="http://www.apkbus.com/data/attachment/portal/201406/20/141125w1p2t48ewt22t6tw.gif" alt="" style="border:none;"></a></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">&nbsp; &nbsp;<span style="line-height:1.8;">&nbsp;<strong>算法九：动态规划算法</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的。通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 </span>
    <p></p> 
    <p>动态规划经常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　动态规划背后的基本思想很easy。大致上。若要解一个给定问题，我们须要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常很多子问题很类似。为此动态规划法试图仅仅解决每个子问题一次，从而降低计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储。以便下次须要同一个子问题解之时直接查表。 这样的做法在反复子问题的数目关于输入的规模呈指数增长时特别实用。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　关于动态规划最经典的问题当属背包问题。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;">算法步骤：</span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　1. &nbsp;最优子结构性质。假设问题的最优解所包括的子问题的解也是最优的。我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决这个问题提供了重要线索。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　2. &nbsp;子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时。每次产生的子问题并不总是新问题，有些子问题会被反复计算多次。 </span>
    <p></p> 
    <p>动态规划算法正是利用了这样的子问题的重叠性质，对每个子问题仅仅计算一次，然后将其计算结果保存在一个表格中，当再次须要计算已经计算过的子问题时，仅仅是在表格中简单地查看一下结果，从而获得较高的效率。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　<span style="line-height:1.8;"><strong>算法十：朴素贝叶斯分类算法</strong></span></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，怎样完毕推理和决策任务。 </span>
    <p></p> 
    <p>概率推理是与确定性推理相相应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其它特征都不相关。</p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';">　　朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得很好的分类效果。在很多实际应用中，朴素贝叶斯模型參数预计使用最大似然预计方法。换言之朴素贝叶斯模型能工作并没实用到贝叶斯概率或者不论什么贝叶斯模型。 </span>
    <p></p> 
    <p></p> 
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';">　　虽然是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。</span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
    <span style="line-height:1.8;font-family:'宋体';"><br></span>
   </div> 
   <div style="font-size:14px;color:rgb(85,85,85);font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;"> 
    <span style="line-height:1.8;font-family:'宋体';"> </span>
    <div style="font-family:Tahoma, 'Microsoft Yahei', Simsun;line-height:25px;">
     本文转自mfrbuaa博客园博客，原文链接：http://www.cnblogs.com/mfrbuaa/p/5092673.html，如需转载请自行联系原作者
    </div> 
    <div>
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
