<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>KVM 介绍（2）：CPU 和内存虚拟化 « NotBeCN</title>
  <meta name="description" content="             学习 KVM 的系列文章：&nbsp;        （1）介绍和安装     （2）CPU 和 内存虚拟化     （3）I/O QEMU 全虚拟化和准虚拟化（Para-virtulizaiton）     （4）I/O PCI/PCIe设备直接分配和 SR-IOV     （5）li...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/13/weixin_33755554_90130805.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">KVM 介绍（2）：CPU 和内存虚拟化</h1>
    <p class="post-meta">Nov 13, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">学习 KVM 的系列文章：&nbsp;<br></p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4543110.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（1）介绍和安装</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4543597.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（2）CPU 和 内存虚拟化</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4543657.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（3）I/O QEMU 全虚拟化和准虚拟化（Para-virtulizaiton）</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4548194.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（4）I/O PCI/PCIe设备直接分配和 SR-IOV</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4558638.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（5）libvirt 介绍</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4568188.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（6）Nova 通过 libvirt 管理 QEMU/KVM 虚机</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4468757.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（7）快照 （snapshot）</a></li> 
    <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4572287.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（8）迁移 （migration）</a></li> 
   </ul>
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1. 为什么需要 CPU 虚拟化</h2> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div> 
     <span style="line-height:1.5;font-size:14px;">X86 操作系统是设计在直接运行在裸硬件设备上的，因此它们自动认为它们完全占有计算机硬件。x86 架构提供四个特权级别给操作系统和应用程序来访问硬件。&nbsp;</span>Ring 是指 CPU 的运行级别，Ring 0是最高级别，Ring1次之，Ring2更次之……&nbsp;就 Linux+x86 来说，&nbsp;
    </div> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;">操作系统（内核）需要直接访问硬件和内存，因此它的代码需要运行在最高运行级别 &nbsp;Ring0上，这样它可以使用特权指令，控制中断、修改页表、访问设备等等。&nbsp;</li> 
     <li style="list-style-type:disc;">应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换。</li> 
    </ul>
    <div>
     &nbsp;
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011405050662145.jpg" alt="" style="border:0px;">
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     那么，
     <span style="line-height:1.5;text-decoration:underline;">虚拟化在这里就遇到了一个难题</span>，因为宿主操作系统是工作在 ring0 的，客户操作系统就不能也在 ring0 了，但是它不知道这一点，以前执行什么指令，现在还是执行什么指令，但是没有执行权限是会出错的。所以这时候虚拟机管理程序（VMM）需要避免这件事情发生。 虚机怎么通过 VMM 实现 Guest CPU 对硬件的访问，根据其原理不同有三种实现技术：
    </div> 
    <div> 
     <div>
      1. 全虚拟化
     </div> 
     <div>
      2. 半虚拟化
     </div> 
     <div>
      3. 硬件辅助的虚拟化
      <span style="line-height:1.5;">&nbsp;</span> 
     </div> 
    </div> 
    <div></div> 
    <div>
     &nbsp;
    </div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.1 基于二进制翻译的全虚拟化（Full Virtualization with Binary Translation）</h3> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011406053161018.jpg" alt="" style="border:0px;">
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     客户操作系统运行在&nbsp;Ring 1，它在执行特权指令时，会触发异常（CPU的机制，没权限的指令会触发异常），然后 VMM 捕获这个异常，在异常里面做翻译，模拟，最后返回到客户操作系统内，客户操作系统认为自己的特权指令工作正常，继续运行。但是这个性能损耗，就非常的大，简单的一条指令，执行完，了事，现在却要通过复杂的异常处理过程。
    </div> 
    <div></div> 
    <div>
     &nbsp;
    </div> 
    <div>
     异常 “捕获（trap）-翻译（handle）-模拟（emulate）” 过程：
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011407133943983.jpg" alt="" style="border:0px;">
    </div> 
    <div></div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.2. 超虚拟化（或者半虚拟化/操作系统辅助虚拟化 Paravirtualization）&nbsp;</h3> 
    <div>
     &nbsp; 半虚拟化的思想就是，
     <span style="line-height:1.5;">修改操作系统内核，替换掉不能虚拟化的指令，<span style="line-height:1.5;text-decoration:underline;">通过超级调用（hypercall</span><span style="line-height:1.5;"><span style="line-height:1.5;text-decoration:underline;">）直接和底层的虚拟化层hypervisor</span><span style="line-height:1.5;"><span style="line-height:1.5;text-decoration:underline;">来通讯</span>，hypervisor&nbsp;<span style="line-height:1.5;">同时也提供了超级调用接口来满足其他关键内核操作，比如内存管理、中断和时间保持。</span></span></span></span> 
    </div> 
    <div>
     <span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp; 这种做法省去了全虚拟化中的捕获和模拟，大大提高了效率。所以像XEN这种半虚拟化技术，客户机操作系统都是有一个专门的定制内核版本，和x86、mips、arm这些内核版本等价。这样以来，就不会有捕获异常、翻译、模拟的过程了，性能损耗非常低。这就是XEN这种半虚拟化架构的优势。这也是为什么XEN只支持虚拟化Linux，无法虚拟化windows原因，微软不改代码啊。</span></span></span></span>
    </div> 
    <div>
     <span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011408208321118.jpg" alt="" style="border:0px;"></span></span></span></span>
    </div> 
    <div></div> 
    <div>
     &nbsp;
    </div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;"> <span style="line-height:1.5;font-size:14px;">1.3. 硬件辅助的全虚拟化</span>&nbsp;</h3> 
    <div>
     &nbsp; &nbsp; 2005年后，CPU厂商Intel 和 AMD&nbsp;开始支持虚拟化了。 Intel 引入了 Intel-VT （Virtualization Technology）技术。 这种 CPU，有 VMX root operation 和 VMX non-root operation两种模式，两种模式都支持Ring 0 ~ Ring 3 共&nbsp;4 个运行级别。这样，VMM 可以运行在 VMX root operation模式下，客户 OS 运行在VMX non-root operation模式下。
    </div> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011409366449146.jpg" alt="" style="border:0px;">
    </div> 
    <div></div> 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     &nbsp; 而且两种操作模式可以互相转换。运行在 VMX root operation 模式下的 VMM 通过显式调用 VMLAUNCH 或 VMRESUME 指令切换到 VMX non-root operation 模式，硬件自动加载 Guest OS 的上下文，于是 Guest OS 获得运行，这种转换称为 VM entry。Guest OS 运行过程中遇到需要 VMM 处理的事件，例如外部中断或缺页异常，或者主动调用 VMCALL 指令调用 VMM 的服务的时候（与系统调用类似），硬件自动挂起 Guest OS，切换到 VMX root operation 模式，恢复 VMM 的运行，这种转换称为 VM exit。VMX root operation 模式下软件的行为与在没有 VT-x 技术的处理器上的行为基本一致；而VMX non-root operation 模式则有很大不同，最主要的区别是此时运行某些指令或遇到某些事件时，发生 VM exit。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     也就说，硬件这层就做了些区分，这样全虚拟化下，那些靠“捕获异常-翻译-模拟”的实现就不需要了。而且CPU厂商，支持虚拟化的力度越来越大，靠硬件辅助的全虚拟化技术的性能逐渐逼近半虚拟化，再加上全虚拟化不需要修改客户操作系统这一优势，全虚拟化技术应该是未来的发展趋势。
    </div> 
    <div>
     &nbsp;
    </div> 
    <table border="1" style="border:1px solid #C0C0C0;border-collapse:collapse;">
     <tbody>
      <tr>
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <strong>&nbsp;</strong>
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div> 
         <strong><span style="line-height:1.5;">利用二进制翻译</span></strong>
         <strong><span style="line-height:1.5;">的全虚拟化</span></strong> 
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <strong><span style="line-height:1.5;">硬件辅助虚拟化</span></strong>
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div> 
         <strong><span style="line-height:1.5;">操作系统协助</span></strong>
         <strong>/</strong>
         <strong><span style="line-height:1.5;">半虚拟化</span></strong> 
        </div> </td> 
      </tr>
      <tr>
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"><strong><span style="line-height:1.5;">实现技术</span></strong></td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         BT
         <span style="line-height:1.5;">和直接执行</span> 
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <span style="line-height:1.5;">遇到特权指令转到root<span style="line-height:1.5;">模式执行</span></span>
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         Hypercall
        </div> </td> 
      </tr>
      <tr>
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <strong><span style="line-height:1.5;">客户操作系统修改</span></strong><strong>/</strong><strong><span style="line-height:1.5;">兼容性</span></strong> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <span style="line-height:1.5;">无需修改客户操作系统，最佳兼容性</span>
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <span style="line-height:1.5;">无需修改客户操作系统，最佳兼容性</span>
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <span style="line-height:1.5;">客户操作系统需要修改来支持hypercall<span style="line-height:1.5;">，因此它不能运行在物理硬件本身或其他的hypervisor上<span style="line-height:1.5;">，兼容性差，不支持Windows</span></span></span>
        </div> </td> 
      </tr>
      <tr>
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"><strong><span style="line-height:1.5;">性能</span></strong></td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <span style="line-height:1.5;">差</span>
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         全虚拟化下，CPU需要在两种模式之间切换，带来性能开销；但是，其性能在逐渐逼近半虚拟化。
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         <span style="line-height:1.5;">好。半虚拟化下CPU性能开销几乎为0，虚机的性能接近于物理机。</span>
        </div> </td> 
      </tr>
      <tr>
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"><strong><span style="line-height:1.5;">应用厂商</span></strong></td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         VMware Workstation/QEMU/Virtual PC
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         VMware ESXi/Microsoft Hyper-V/Xen 3.0/KVM
        </div> </td> 
       <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
        <div>
         Xen
        </div> </td> 
      </tr>
     </tbody>
    </table>
   </div> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2. KVM CPU 虚拟化</h2> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">KVM 是基于CPU 辅助的全虚拟化方案，它需要CPU虚拟化特性的支持。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.1. CPU 物理特性</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">这个命令查看主机上的CPU 物理情况：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>[s1@rh65 ~]$ numactl --<span style="line-height:1.5;">hardware
available: </span><span style="color:rgb(128,0,128);line-height:1.5;">2</span> nodes (<span style="color:rgb(128,0,128);line-height:1.5;">0</span>-<span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">) <span style="color:rgb(0,0,255);line-height:1.5;">//2颗CPU</span>
node </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span> cpus: <span style="color:rgb(128,0,128);line-height:1.5;">0</span> <span style="color:rgb(128,0,128);line-height:1.5;">1</span> <span style="color:rgb(128,0,128);line-height:1.5;">2</span> <span style="color:rgb(128,0,128);line-height:1.5;">3</span> <span style="color:rgb(128,0,128);line-height:1.5;">4</span> <span style="color:rgb(128,0,128);line-height:1.5;">5</span> <span style="color:rgb(128,0,128);line-height:1.5;">12</span> <span style="color:rgb(128,0,128);line-height:1.5;">13</span> <span style="color:rgb(128,0,128);line-height:1.5;">14</span> <span style="color:rgb(128,0,128);line-height:1.5;">15</span> <span style="color:rgb(128,0,128);line-height:1.5;">16</span> <span style="color:rgb(128,0,128);line-height:1.5;">17 <span style="color:rgb(0,0,255);line-height:1.5;">//这颗 CPU 有8个内核</span></span><span style="line-height:1.5;">
node </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span> size: <span style="color:rgb(128,0,128);line-height:1.5;">12276</span><span style="line-height:1.5;"> MB
node </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span> free: <span style="color:rgb(128,0,128);line-height:1.5;">7060</span><span style="line-height:1.5;"> MB
node </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span> cpus: <span style="color:rgb(128,0,128);line-height:1.5;">6</span> <span style="color:rgb(128,0,128);line-height:1.5;">7</span> <span style="color:rgb(128,0,128);line-height:1.5;">8</span> <span style="color:rgb(128,0,128);line-height:1.5;">9</span> <span style="color:rgb(128,0,128);line-height:1.5;">10</span> <span style="color:rgb(128,0,128);line-height:1.5;">11</span> <span style="color:rgb(128,0,128);line-height:1.5;">18</span> <span style="color:rgb(128,0,128);line-height:1.5;">19</span> <span style="color:rgb(128,0,128);line-height:1.5;">20</span> <span style="color:rgb(128,0,128);line-height:1.5;">21</span> <span style="color:rgb(128,0,128);line-height:1.5;">22</span> <span style="color:rgb(128,0,128);line-height:1.5;">23</span><span style="line-height:1.5;">
node </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span> size: <span style="color:rgb(128,0,128);line-height:1.5;">8192</span><span style="line-height:1.5;"> MB
node </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span> free: <span style="color:rgb(128,0,128);line-height:1.5;">6773</span><span style="line-height:1.5;"> MB
node distances:
node   </span><span style="color:rgb(128,0,128);line-height:1.5;">0</span>   <span style="color:rgb(128,0,128);line-height:1.5;">1</span> 
  <span style="color:rgb(128,0,128);line-height:1.5;">0</span>:  <span style="color:rgb(128,0,128);line-height:1.5;">10</span>  <span style="color:rgb(128,0,128);line-height:1.5;">21</span> 
  <span style="color:rgb(128,0,128);line-height:1.5;">1</span>:  <span style="color:rgb(128,0,128);line-height:1.5;">21</span>  <span style="color:rgb(128,0,128);line-height:1.5;">10</span> </pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">要支持 KVM， Intel CPU 的 vmx 或者 AMD CPU 的 svm 扩展必须生效了：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>[root@rh65 s1]# egrep <span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">(vmx|svm)</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span> /proc/<span style="line-height:1.5;">cpuinfo
flags        : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl <span style="color:rgb(0,0,255);line-height:1.5;">vmx</span> smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 popcnt aes lahf_lm arat epb dts tpr_shadow vnmi flexpriority ept vpid</span></pre>
   </div> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.2 多 CPU 服务器架构：SMP，NMP，NUMA</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">从系统架构来看，目前的商用服务器大体可以分为三类：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">多处理器结构 (SMP ： Symmetric Multi-Processor)：所有的CPU共享全部资源，如总线，内存和I/O系统等，操作系统或管理数据库的复本只有一个，这种系统有一个最大的特点就是共享所有资源。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。SMP 服务器的主要问题，那就是它的扩展能力非常有限。实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU 。</li> 
    <li style="list-style-type:disc;">海量并行处理结构 (MPP ： Massive Parallel Processing)&nbsp;：NUMA 服务器的基本特征是具有多个 CPU 模块，每个 CPU 模块由多个 CPU( 如 4 个 ) 组成，并且具有独立的本地内存、 I/O 槽口等。在一个物理服务器内可以支持上百个 CPU 。但 NUMA 技术同样有一定缺陷，由于访问远地内存的延时远远超过本地内存，因此当 CPU 数量增加时，系统性能无法线性增加。</li> 
    <li style="list-style-type:disc;">MPP 模式则是一种分布式存储器模式，能够将更多的处理器纳入一个系统的存储器。一个分布式存储器模式具有多个节点，每个节点都有自己的存储器，可以配置为SMP模式，也可以配置为非SMP模式。单个的节点相互连接起来就形成了一个总系统。MPP可以近似理解成一个SMP的横向扩展集群，MPP一般要依靠软件实现。</li> 
    <li style="list-style-type:disc;">非一致存储访问结构 (NUMA ： Non-Uniform Memory Access)：它由多个 SMP 服务器通过一定的节点互联网络进行连接，协同工作，完成相同的任务，从用户的角度来看是一个服务器系统。其基本特征是由多个 SMP 服务器 ( 每个 SMP 服务器称节点 ) 通过节点互联网络连接而成，每个节点只访问自己的本地资源 ( 内存、存储等 ) ，是一种完全无共享 (Share Nothing) 结构。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">详细描述可以参考&nbsp;<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html" rel="nofollow" style="text-decoration:none;color:rgb(26,139,200);">SMP、NUMA、MPP体系结构介绍</a>。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">查看你的服务器的 CPU 架构：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>[root@rh65 s1]# uname -<span style="line-height:1.5;">a
Linux rh65 </span><span style="color:rgb(128,0,128);line-height:1.5;">2.6</span>.<span style="color:rgb(128,0,128);line-height:1.5;">32</span>-<span style="color:rgb(128,0,128);line-height:1.5;">431</span>.el6.x86_64 #<span style="color:rgb(128,0,128);line-height:1.5;">1</span> <span style="color:rgb(0,0,255);line-height:1.5;">SMP</span> Sun Nov <span style="color:rgb(128,0,128);line-height:1.5;">10</span> <span style="color:rgb(128,0,128);line-height:1.5;">22</span>:<span style="color:rgb(128,0,128);line-height:1.5;">19</span>:<span style="color:rgb(128,0,128);line-height:1.5;">54</span> EST <span style="color:rgb(128,0,128);line-height:1.5;">2013</span> x86_64 x86_64 x86_64 GNU/Linux <span style="color:rgb(0,0,255);line-height:1.5;">#这服务器是 SMP 架构</span><span style="line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</span></pre>
   </div> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.2 KVM CPU 虚拟化</h3> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2.2.1 KVM 虚机的创建过程</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201509/697113-20150913090819231-757181338.jpg" alt="" width="688" height="351" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">可见：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（1）qemu-kvm 通过对 /dev/kvm 的 一系列 ICOTL 命令控制虚机，比如</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>open(<span style="color:rgb(128,0,0);line-height:1.5;">"</span><span style="color:rgb(128,0,0);line-height:1.5;">/dev/kvm</span><span style="color:rgb(128,0,0);line-height:1.5;">"</span>, O_RDWR|O_LARGEFILE)    = <span style="color:rgb(128,0,128);line-height:1.5;">3</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_GET_API_VERSION, <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)        = <span style="color:rgb(128,0,128);line-height:1.5;">12</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0x19</span>)     = <span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CREATE_VM, <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)              = <span style="color:rgb(128,0,128);line-height:1.5;">4</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0x4</span>)      = <span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0x4</span>)      = <span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">4</span>, KVM_SET_TSS_ADDR, <span style="color:rgb(128,0,128);line-height:1.5;">0xfffbd000</span>)  = <span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0x25</span>)     = <span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0xb</span>)      = <span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">4</span>, KVM_CREATE_PIT, <span style="color:rgb(128,0,128);line-height:1.5;">0xb</span>)           = <span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0xf</span>)      = <span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0x3</span>)      = <span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)        = <span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">4</span>, KVM_CREATE_IRQCHIP, <span style="color:rgb(128,0,128);line-height:1.5;">0</span>)         = <span style="color:rgb(128,0,128);line-height:1.5;">0</span><span style="line-height:1.5;">
ioctl(</span><span style="color:rgb(128,0,128);line-height:1.5;">3</span>, KVM_CHECK_EXTENSION, <span style="color:rgb(128,0,128);line-height:1.5;">0x1a</span>)     = <span style="color:rgb(128,0,128);line-height:1.5;">0</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;font-size:12px;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;font-size:14px;">（2）一个</span><span style="line-height:1.5;font-size:14px;">&nbsp;KVM 虚机即一个 Linux qemu-kvm 进程，与其他 Linux 进程一样被Linux 进程调度器调度。</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（3）KVM 虚机包括虚拟内存、虚拟CPU和虚机 I/O设备，其中，内存和 CPU 的虚拟化由 KVM 内核模块负责实现，I/O 设备的虚拟化由 QEMU 负责实现。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（3）KVM户机系统的内存是 qumu-kvm 进程的地址空间的一部分。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（4）KVM 虚机的 vCPU 作为 线程运行在 qemu-kvm 进程的上下文中。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">vCPU、QEMU 进程、LInux 进程调度和物理CPU之间的逻辑关系：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011509285517859.jpg" alt="" style="border:0px;"></p> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2.2.2 因为 CPU 中的虚拟化功能的支持，并不存在虚拟的 CPU，KVM Guest 代码是运行在物理 CPU 之上</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp; 根据上面的 1.3 章节，支持虚拟化的 CPU 中都增加了新的功能。以 Intel VT 技术为例，它增加了两种运行模式：VMX root 模式和&nbsp;VMX nonroot 模式。通常来讲，主机操作系统和 VMM 运行在 VMX root 模式中，客户机操作系统及其应用运行在 VMX nonroot 模式中。因为两个模式都支持所有的 ring，因此，客户机可以运行在它所需要的 ring 中（OS 运行在 ring 0 中，应用运行在 ring 3 中），VMM 也运行在其需要的 ring 中 （对 KVM 来说，QEMU 运行在 ring 3，KVM 运行在 ring 0）。CPU 在两种模式之间的切换称为 VMX 切换。从 root mode 进入 nonroot mode，称为 VM entry；从 nonroot mode 进入 root mode，称为 VM exit。可见，CPU 受控制地在两种模式之间切换，轮流执行 VMM 代码和 Guest OS 代码。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 对 KVM 虚机来说，运行<span style="line-height:1.5;font-size:14px;">在 VMX Root Mode 下的 VMM 在需要执行 Guest OS 指令时执行&nbsp;</span><span style="line-height:1.5;font-size:14px;">VMLAUNCH 指令将 CPU 转换到 VMX non-root mode，开始执行客户机代码，即 VM entry 过程；在 Guest OS 需要退出该 mode 时，CPU 自动切换到 VMX Root mode，即 VM exit 过程。可见，KVM 客户机代码是受 VMM 控制直接运行在物理 CPU 上的。QEMU 只是通过 KVM 控制虚机的代码被 CPU 执行，但是它们本身并不执行其代码。也就是说，CPU 并没有真正的被虚级化成虚拟的 CPU 给客户机使用。</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;font-size:14px;">&nbsp;<a href="http://frankdenneman.nl/2013/09/18/vcpu-configuration-performance-impact-between-virtual-sockets-and-virtual-cores/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>&nbsp;是关于 vSphere 中 CPU 虚拟化的，我觉得它和 KVM CPU 虚拟化存在很大的一致。下图是使用 2 socket 2 core 共 4 个 vCPU 的情形：</span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;font-size:14px;"><img src="https://images2015.cnblogs.com/blog/697113/201509/697113-20150915144822773-366209755.jpg" alt="" width="295" height="420" style="border:0px;"></span></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;<span style="line-height:1.5;font-size:14px;">&nbsp; 几个概念：socket （颗，CPU 的物理单位），core （核，每个 CPU 中的物理内核），thread （超线程，通常来说，一个 CPU core 只提供一个 thread，这时客户机就只看到一个 CPU；但是，超线程技术实现了 CPU 核的虚拟化，一个核被虚拟化出多个逻辑 CPU，可以同时运行多个线程）。</span>&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; 上图分三层，他们分别是是VM层，VMKernel层和物理层。对于物理服务器而言，所有的CPU资源都分配给单独的操作系统和上面运行的应用。应用将请求先发送给操作系统，然后操作系统调度物理的CPU资源。<span style="line-height:1.5;">在虚拟化平台比如 KVM 中，在VM层和物理层之间加入了VMkernel层，从而允许所有的VM共享物理层的资源。VM上的应用将请求发送给VM上的操作系统，然后操纵系统调度Virtual CPU资源（操作系统认为Virtual CPU和物理 CPU是一样的），然后VMkernel层对多个物理CPU Core进行资源调度，从而满足Virtual CPU的需要。在虚拟化平台中OS CPU Scheduler和Hyperviisor CPU Scheduler都在各自的领域内进行资源调度。</span>&nbsp;</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><span style="line-height:1.5;font-size:14px;">&nbsp; &nbsp;KVM 中，可以指定 socket，core 和 thread 的数目，比如 设置 “-smp 5,sockets=5,cores=1,threads=1”，则 vCPU 的数目为 5*1*1 = 5。客户机看到的是基于 KVM vCPU 的 CPU 核，而 vCPU 作为 QEMU 线程被 Linux 作为普通的线程/轻量级进程调度到物理的 CPU 核上。至于你是该使用多 socket 和 多core，<a href="http://frankdenneman.nl/2013/09/18/vcpu-configuration-performance-impact-between-virtual-sockets-and-virtual-cores/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>&nbsp;有仔细的分析，其结论是在 VMware ESXi 上，性能没什么区别，只是某些客户机操作系统会限制物理 CPU 的数目，这种情况下，可以使用少 socket 多 core。</span></p> 
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-size:14px;">2.2.3 客户机系统的代码是如何运行的</span></h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;一个普通的 Linux 内核有两种执行模式：内核模式（Kenerl）和用户模式 （User）。为了支持带有虚拟化功能的 CPU，KVM 向 Linux 内核增加了第三种模式即客户机模式（Guest），该模式对应于 CPU 的 VMX non-root mode。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011325268792961.jpg" alt="" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">KVM 内核模块作为 User mode 和 Guest mode 之间的桥梁：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">User mode 中的 QEMU-KVM 会通过 ICOTL 命令来运行虚拟机</li> 
    <li style="list-style-type:disc;">KVM 内核模块收到该请求后，它先做一些准备工作，比如将 VCPU 上下文加载到 VMCS （virtual machine control structure）等，然后驱动 CPU 进入 VMX non-root 模式，开始执行客户机代码</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">三种模式的分工为：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">Guest 模式：执行客户机系统非 I/O 代码，并在需要的时候驱动 CPU 退出该模式</li> 
    <li style="list-style-type:disc;">Kernel 模式：负责将 CPU 切换到 Guest mode 执行 Guest OS 代码，并在 CPU 退出 &nbsp;Guest mode 时回到 Kenerl 模式</li> 
    <li style="list-style-type:disc;">User 模式：代表客户机系统执行 I/O 操作</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201509/697113-20150913103334731-1698421672.jpg" alt="" width="606" height="457" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">(<a href="http://www.cnblogs.com/popsuper1982/p/3815398.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>)</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">QEMU-KVM 相比原生 QEMU 的改动：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">原生的 QEMU 通过指令翻译实现 CPU 的完全虚拟化，但是修改后的 QEMU-KVM 会调用 ICOTL 命令来调用 KVM 模块。</li> 
    <li style="list-style-type:disc;">原生的 QEMU 是单线程实现，QEMU-KVM 是多线程实现。</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">主机 Linux 将一个虚拟视作一个 QEMU 进程，该进程包括下面几种线程：</p> 
   <ul style="list-style:none;font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">
    <li style="list-style-type:disc;">I/O 线程用于管理模拟设备</li> 
    <li style="list-style-type:disc;">vCPU 线程用于运行 Guest 代码</li> 
    <li style="list-style-type:disc;">其它线程，比如处理 event loop，offloaded tasks 等的线程</li> 
   </ul>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">在我的测试环境中（RedHata Linux 作 Hypervisor）：</p> 
   <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <tbody>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">smp 设置的值</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">线程数</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">线程</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">4</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">8</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> <p style="line-height:1.5;">1 个主线程（I/O 线程）、4 个 vCPU 线程、3 个其它线程</p> </td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">6</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">10</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">1 个主线程（I/O 线程）、6 个 vCPU 线程、3 个其它线程</td> 
     </tr>
    </tbody>
   </table>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://blog.chinaunix.net/uid-26000137-id-3761114.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>&nbsp;谈谈了这些线程的情况。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201509/697113-20150913104025450-1757886147.jpg" alt="" width="590" height="446" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">(<a href="http://www.cnblogs.com/popsuper1982/p/3815398.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">来源</a>)</p> 
   <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <tbody>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">客户机代码执行（客户机线程）</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">I/O 线程</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">非 I/O 线程</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">虚拟CPU（主机 QEMU 线程）</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">QEMU I/O 线程</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">QEMU vCPU 线程</td> 
     </tr>
     <tr>
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">物理 CPU</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">物理 CPU 的 VMX non-root 模式中</td> 
      <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">物理 CPU 的 VMX non-root 模式中<br><br></td> 
     </tr>
    </tbody>
   </table>
   <h4 style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2.2.4 从客户机线程到物理 CPU 的两次调度</h4> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">要将客户机内的线程调度到某个物理 CPU，需要经历两个过程：</p> 
   <ol style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <li style="list-style-type:decimal;"> <span style="line-height:1.5;font-size:1em;">客户机线程调度到客户机物理CPU 即 KVM vCPU，</span><span style="line-height:1.5;font-size:1em;">该调度由客户机操作系统负责，每个客户机操作系统的实现方式不同。在 KVM 上，vCPU 在客户机系统看起来就像是物理 CPU，因此其调度方法也没有什么不同。</span> </li> 
    <li style="list-style-type:decimal;">vCPU 线程调度到物理 CPU 即主机物理 CPU，该调度由 Hypervisor 即 Linux 负责。</li> 
   </ol>
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp; KVM 使用标准的 Linux 进程调度方法来调度 vCPU 进程。Linux 系统中，线程和进程的区别是 进程有独立的内核空间，线程是代码的执行单位，也就是调度的基本单位。Linux 中，线程是就是轻量级的进程，也就是共享了部分资源(地址空间、文件句柄、信号量等等)的进程，所以线程也按照进程的调度方式来进行调度。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（1）Linux 进程调度原理可以参考&nbsp;<a href="http://criticalblue.com/news/wp-content/uploads/2013/12/linux_scheduler_notes_final.pdf" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>&nbsp;和&nbsp;<a href="http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>。通常情况下，在SMP系统中，Linux内核的进程调度器根据自有的调度策略将系统中的一个可运行（runable）进程调度到某个CPU上执行。下面是 Linux 进程的状态机：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images2015.cnblogs.com/blog/697113/201509/697113-20150913104951106-1477750383.jpg" alt="" style="border:0px;"></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">（2）处理器亲和性：可以设置 vCPU 在指定的物理 CPU 上运行，具体可以参考<a href="http://blog.chinaunix.net/uid-26000137-id-3695749.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>&nbsp;和&nbsp;<a href="http://frankdenneman.nl/2011/01/11/beating-a-dead-horse-using-cpu-affinity/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp; &nbsp; 根据 Linux 进程调度策略，可以看出，在 Linux 主机上运行的 KVM 客户机 的总 vCPU 数目最好是不要超过物理 CPU 内核数，否则，会出现线程间的 CPU 内核资源竞争，导致有虚机因为 vCPU 进程等待而导致速度很慢。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">关于这两次调度，业界有很多的研究，比如上海交大的论文&nbsp;<a href="http://ipads.se.sjtu.edu.cn/_media/publications/vcpu-bal-apsys13.pdf" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">Schedule Processes, not VCPUs</a>&nbsp;提出动态地减少 vCPU 的数目即减少第二次调度。</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">另外，<a href="http://www.vmware.com/files/pdf/techpaper/VMware-vSphere-CPU-Sched-Perf.pdf" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>&nbsp;谈到的是 vSphere CPU 的调度方式，有空的时候可以研究下并和 KVM vCPU 的调度方式进行比较。</p> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.3 客户机CPU结构和模型</h3> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">KVM 支持 SMP 和 NUMA 多CPU架构的主机和客户机。对 SMP 类型的客户机，使用 “-smp”参数：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>-smp &lt;n&gt;[,cores=&lt;ncores&gt;][,threads=&lt;nthreads&gt;][,sockets=&lt;nsocks&gt;][,maxcpus=&lt;maxcpus&gt;]</pre>
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">对 NUMA 类型的客户机，使用 “-numa”参数：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>-numa &lt;nodes&gt;[,mem=&lt;size&gt;][,cpus=&lt;cpu[-cpu&gt;]][,nodeid=&lt;node&gt;]&nbsp;</pre>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Times New Roman';font-size:small;">CPU 模型 （models）定义了哪些主机的 CPU 功能 （features）会被暴露给客户机操作系统。为了在具有不同 CPU 功能的主机之间做安全的迁移，qemu-kvm 往往不会将主机CPU的所有功能都暴露给客户机。其</span>
    <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Times New Roman';font-size:small;">原理如下：</span> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Times New Roman';font-size:small;"><img src="https://images201506.cnblogs.com/blog201506/697113/201506/021358040558873.jpg" alt="" style="border:0px;"></span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;color:rgb(1,1,1);font-family:'Times New Roman';font-size:small;">你可以运行&nbsp;<span style="line-height:1.5;text-decoration:underline;">qemu-kvm -cpu ?</span>&nbsp;命令来获取主机所支持的 CPU 模型列表。</span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
     <pre>[root@rh65 s1]# kvm -cpu ?<span style="line-height:1.5;">
x86       Opteron_G5  AMD Opteron 63xx </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> CPU                      
x86       Opteron_G4  AMD Opteron 62xx </span><span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> CPU                      
x86       Opteron_G3  AMD Opteron 23xx (Gen </span><span style="color:rgb(128,0,128);line-height:1.5;">3</span><span style="line-height:1.5;"> Class Opteron)          
x86       Opteron_G2  AMD Opteron 22xx (Gen </span><span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;"> Class Opteron)          
x86       Opteron_G1  AMD Opteron </span><span style="color:rgb(128,0,128);line-height:1.5;">240</span> (Gen <span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;"> Class Opteron)           
x86          Haswell  Intel Core Processor (Haswell)                  
x86      SandyBridge  Intel Xeon E312xx (Sandy Bridge)                
x86         Westmere  Westmere E56xx</span>/L56xx/X56xx (Nehalem-<span style="line-height:1.5;">C)          
x86          Nehalem  Intel Core i7 9xx (Nehalem Class Core i7)       
x86           Penryn  Intel Core </span><span style="color:rgb(128,0,128);line-height:1.5;">2</span> Duo P9xxx (Penryn Class Core <span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;">)    
x86           Conroe  Intel Celeron_4x0 (Conroe</span>/Merom Class Core <span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;">)   
x86      cpu64</span>-rhel5  QEMU Virtual CPU version (cpu64-<span style="line-height:1.5;">rhel5)          
x86      cpu64</span>-rhel6  QEMU Virtual CPU version (cpu64-<span style="line-height:1.5;">rhel6)          
x86             n270  Intel(R) Atom(TM) CPU N270   @ </span><span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">.60GHz          
x86           athlon  QEMU Virtual CPU version </span><span style="color:rgb(128,0,128);line-height:1.5;">0.12</span>.<span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">                 
x86         pentium3                                                  
x86         pentium2                                                  
x86          pentium                                                  
x86              </span><span style="color:rgb(128,0,128);line-height:1.5;">486</span><span style="line-height:1.5;">                                                  
x86          coreduo  Genuine Intel(R) CPU           T2600  @ </span><span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;">.16GHz 
x86           qemu32  QEMU Virtual CPU version </span><span style="color:rgb(128,0,128);line-height:1.5;">0.12</span>.<span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">                 
x86            kvm64  Common KVM processor                            
x86         core2duo  Intel(R) Core(TM)</span><span style="color:rgb(128,0,128);line-height:1.5;">2</span> Duo CPU     T7700  @ <span style="color:rgb(128,0,128);line-height:1.5;">2</span><span style="line-height:1.5;">.40GHz 
x86           phenom  AMD Phenom(tm) </span><span style="color:rgb(128,0,128);line-height:1.5;">9550</span> Quad-<span style="line-height:1.5;">Core Processor         
x86           qemu64  QEMU Virtual CPU version </span><span style="color:rgb(128,0,128);line-height:1.5;">0.12</span>.<span style="color:rgb(128,0,128);line-height:1.5;">1</span><span style="line-height:1.5;">                 

Recognized CPUID flags:
  f_edx: pbe ia64 tm ht ss sse2 sse fxsr mmx acpi ds clflush pn pse36 pat cmov mca pge mtrr sep apic cx8 mce pae msr tsc pse de vme fpu
  f_ecx: hypervisor rdrand f16c avx osxsave xsave aes tsc</span>-deadline popcnt movbe x2apic sse4.<span style="color:rgb(128,0,128);line-height:1.5;">2</span>|sse4_2 sse4.<span style="color:rgb(128,0,128);line-height:1.5;">1</span>|sse4_1 dca pcid pdcm xtpr cx16 fma cid ssse3 tm2 est smx vmx ds_cpl monitor dtes64 pclmulqdq|pclmuldq pni|<span style="line-height:1.5;">sse3
  extf_edx: 3dnow 3dnowext lm</span>|i64 rdtscp pdpe1gb fxsr_opt|ffxsr fxsr mmx mmxext nx|<span style="line-height:1.5;">xd pse36 pat cmov mca pge mtrr syscall apic cx8 mce pae msr tsc pse de vme fpu
  extf_ecx: perfctr_nb perfctr_core topoext tbm nodeid_msr tce fma4 lwp wdt skinit xop ibs osvw 3dnowprefetch misalignsse sse4a abm cr8legacy extapic svm cmp_legacy lahf_lm
[root@rh65 s1]# </span></pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(26,139,200);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
     </div> 
    </div> 
    <p style="line-height:1.5;">&nbsp; &nbsp; 每个 Hypervisor 都有自己的策略，来定义默认上哪些CPU功能会被暴露给客户机。至于哪些功能会被暴露给客户机系统，取决于客户机的配置。qemu32 和 qemu64 是基本的客户机 CPU 模型，但是还有其他的模型可以使用。你可以使用 qemu-kvm 命令的 -cpu &lt;model&gt; 参数来指定客户机的 CPU 模型，还可以附加指定的 CPU 特性。"-cpu" 会将该指定 CPU 模型的所有功能全部暴露给客户机，即使某些特性在主机的物理CPU上不支持，这时候QEMU/KVM 会模拟这些特性，因此，这时候也许会出现一定的性能下降。&nbsp;</p> 
    <p style="line-height:1.5;">RedHat Linux 6 上使用默认的 cpu64-rhe16 作为客户机 CPU model：</p> 
    <p style="line-height:1.5;"><img src="https://images201506.cnblogs.com/blog201506/697113/201506/021504207586046.jpg" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">你可以指定特定的 CPU model 和 feature：</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
     <pre><span style="line-height:1.5;">qemu</span>-kvm -cpu Nehalem,+aes</pre>
    </div> 
    <p style="line-height:1.5;">&nbsp;<img src="https://images0.cnblogs.com/blog2015/697113/201506/021659499307313.jpg" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">你也可以直接使用 -cpu host，这样的话会客户机使用和主机相同的 CPU model。</p> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.4 客户机 vCPU 数目的分配方法</h3> 
    <ol>
     <li style="list-style-type:decimal;">不是客户机的 vCPU 越多，其性能就越好，因为线程切换会耗费大量的时间；应该根据负载需要分配最少的 vCPU。</li> 
     <li style="list-style-type:decimal;">主机上的客户机的 vCPU 总数不应该超过物理 CPU 内核总数。不超过的话，就不存在 CPU 竞争，每个 vCPU 线程在一个物理 CPU 核上被执行；超过的话，会出现部分线程等待 CPU 以及一个 CPU 核上的线程之间的切换，这会有 overhead。</li> 
     <li style="list-style-type:decimal;">将负载分为计算负载和 I/O 负载，对计算负载，需要分配较多的 vCPU，甚至考虑 CPU 亲和性，将指定的物理 CPU 核分给给这些客户机。</li> 
    </ol>
    <p style="line-height:1.5;">这篇文章 （<a href="http://my.oschina.net/chape/blog/173981" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://my.oschina.net/chape/blog/173981</a>） 介绍了一些指导性方法，摘要如下：</p> 
    <p style="line-height:1.5;">我们来假设一个主机有 2 个socket，每个 socket 有 4 个core。主频2.4G MHZ 那么一共可用的资源是&nbsp;2*4*2.4G= 19.2G MHZ。假设主机上运行了三个VM，VM1和VM2设置为1socket*1core，VM3设置为1socket*2core。那么VM1和VM2分别有1个vCPU，而VM3有2个vCPU。假设其他设置为缺省设置。</p> 
    <p style="line-height:1.5;">那么三个VM获得该主机CPU资源分配如下：VM1：25%； VM2：25%； VM3:50%</p> 
    <p style="line-height:1.5;">&nbsp;假设运行在VM3上的应用支持多线程，那么该应用可以充分利用到所非配的CPU资源。2vCPU的设置是合适的。假设运行在VM3上的应用不支持多线程，该应用根本无法同时使用利用2个vCPU. 与此同时，VMkernal层的CPU Scheduler必须等待物理层中两个空闲的pCPU，才开始资源调配来满足2个vCPU的需要。在仅有2vCPU的情况下，对该VM的性能不会有太大负面影响。但如果分配4vCPU或者更多，这种资源调度上的负担有可能会对该VM上运行的应用有很大负面影响。</p> 
    <p style="line-height:1.5;">确定 vCPU 数目的步骤。<span style="line-height:1.5;">假如我们要创建一个VM，以下几步可以帮助确定合适的vCPU数目</span></p> 
    <p style="line-height:1.5;">1 了解应用并设置初始值</p> 
    <p style="line-height:1.5;">&nbsp; &nbsp; 该应用是否是关键应用，是否有Service Level Agreement。一定要对运行在虚拟机上的应用是否支持多线程深入了解。咨询应用的提供商是否支持多线程和SMP（Symmetricmulti-processing）。参考该应用在物理服务器上运行时所需要的CPU个数。如果没有参照信息，可设置1vCPU作为初始值，然后密切观测资源使用情况。</p> 
    <p style="line-height:1.5;">2 观测资源使用情况</p> 
    <p style="line-height:1.5;">&nbsp; &nbsp; 确定一个时间段，观测该虚拟机的资源使用情况。时间段取决于应用的特点和要求，可以是数天，甚至数周。不仅观测该VM的CPU使用率，而且观测在操作系统内该应用对CPU的占用率。特别要区分CPU使用率平均值和CPU使用率峰值。</p> 
    <p style="line-height:1.5;">&nbsp; &nbsp; &nbsp;假如分配有4个vCPU，如果在该VM上的应用的CPU</p> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;">使用峰值等于25%， 也就是仅仅能最多使用25%的全部CPU资源，说明该应用是单线程的，仅能够使用一个vCPU （4 * 25% = 1 ）</li> 
     <li style="list-style-type:disc;">平均值小于38%，而峰值小于45%，考虑减少 vCPU 数目</li> 
     <li style="list-style-type:disc;">平均值大于75%，而峰值大于90%，考虑增加 vCPU 数目</li> 
    </ul>
    <p style="line-height:1.5;">3 更改vCPU数目并观测结果</p> 
    <p style="line-height:1.5;">每次的改动尽量少，如果可能需要4vCPU，先设置2vCPU在观测性能是否可以接受。</p> 
   </div> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2. KVM 内存虚拟化</h2> 
   <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.1 内存虚拟化的概念</h3> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;">&nbsp; &nbsp; 除了 CPU&nbsp;<span style="line-height:1.5;">虚拟化，另一个关键是内存虚拟化，通过内存虚拟化共享物理系统内存，动态分配给虚拟机。虚拟机的内存虚拟化很象现在的操作系统支持的虚拟内存方式，应用程序看到邻近的内存地址空间，这个地址空间无需和下面的物理机器内存直接对应，操作系统保持着虚拟页到物理页的映射。现在所有的 x86 CPU&nbsp;<span style="line-height:1.5;">都包括了一个称为内存管理的模块MMU<span style="line-height:1.5;">（Memory Management Unit<span style="line-height:1.5;">）和&nbsp;TLB(Translation Lookaside Buffer)<span style="line-height:1.5;">，通过MMU<span style="line-height:1.5;">和TLB<span style="line-height:1.5;">来优化虚拟内存的性能。</span></span></span></span></span></span></span></span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;">&nbsp; &nbsp;KVM 实现客户机内存的方式是，利用mmap系统调用，在QEMU主线程的虚拟地址空间中申明一段连续的大小的空间用于客户机物理内存映射。</span></span></span></span></span></span></span></span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><img src="https://images2015.cnblogs.com/blog/697113/201509/697113-20150915141926742-1526227034.jpg" alt="" width="521" height="299" style="border:0px;"></span></span></span></span></span></span></span></span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;">（<a href="http://blog.csdn.net/lux_veritas/article/details/9383643" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">图片来源</a>&nbsp;HVA 同下面的 MA，GPA 同下面的 PA，GVA 同下面的 VA）</span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    在有两个虚机的情况下，情形是这样的：
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <span style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011413028483143.jpg" alt="" style="border:0px;"></span>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <span style="line-height:1.5;">可见，KVM 为了在一台机器上运行多个虚拟机，需要增加一个新的内存虚拟化层，也就是说，必须虚拟&nbsp;MMU&nbsp;<span style="line-height:1.5;">来支持客户操作系统，来实现 VA -&gt; PA -&gt; MA 的翻译。</span></span>
    <span style="line-height:1.5;"><span style="line-height:1.5;">客户操作系统继续控制虚拟地址到客户内存物理地址的映射 （VA -&gt; PA），但是客户操作系统不能直接访问实际机器内存，因此VMM 需要<span style="line-height:1.5;">负责映射客户物理内存到实际机器内存 （PA -&gt; MA）。</span></span></span> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div>
     &nbsp;
    </div> 
    <div> 
     <div>
      VMM 内存虚拟化的实现方式：
     </div> 
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">软件方式：通过软件实现内存地址的翻译，比如&nbsp;Shadow page table （影子页表）技术</li> 
      <li style="list-style-type:disc;">硬件实现：基于 CPU 的辅助虚拟化功能，比如 AMD 的 NPT 和 Intel 的 EPT 技术<span style="line-height:1.5;">&nbsp;</span> </li> 
     </ul>
    </div> 
    <div>
     <span style="line-height:1.5;font-size:14px;">影子页表技术：</span>
    </div> 
    <div>
     <span style="line-height:1.5;font-size:14px;">&nbsp;</span>
    </div> 
    <div> 
     <div>
      <img src="https://images0.cnblogs.com/blog2015/697113/201506/011415310351681.jpg" alt="" style="border:0px;">
     </div> 
     <div>
      &nbsp;
     </div> 
     <div>
      &nbsp;
     </div> 
     <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.2 KVM 内存虚拟化</h3> 
     <div>
      &nbsp;KVM 中，虚机的物理内存即为 qemu-kvm 进程所占用的内存空间。KVM 使用 CPU 辅助的内存虚拟化方式。在 Intel 和 AMD 平台，其内存虚拟化的实现方式分别为：
     </div> 
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">AMD 平台上的 NPT （Nested Page Tables） 技术</li> 
      <li style="list-style-type:disc;">Intel 平台上的 EPT （Extended Page Tables）技术</li> 
     </ul>
     <div> 
      <p style="line-height:1.5;">EPT 和 NPT采用类似的原理，都是作为&nbsp;CPU 中新的一层，用来将客户机的物理地址翻译为主机的物理地址。关于 EPT， Intel 官方文档中的技术如下（实在看不懂...）</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011445076768587.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">EPT的好处是，它的两阶段记忆体转换，特点就是将 Guest Physical Address → System Physical Address，VMM不用再保留一份 SPT (Shadow Page Table)，以及以往还得经过 SPT 这个转换过程。除了降低各部虚拟机器在切换时所造成的效能损耗外，硬体指令集也比虚拟化软体处理来得可靠与稳定。</p> 
      <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.3 KSM （Kernel SamePage Merging 或者&nbsp;Kernel Shared Memory）</h3> 
      <p style="line-height:1.5;">KSM 在 Linux&nbsp;2.6.32 版本中被加入到内核中。</p> 
      <h4 style="font-size:14px;">2.3.1 原理</h4> 
      <p style="line-height:1.5;"><span style="line-height:1.5;font-size:14px;">其原理是，</span><span style="line-height:1.5;font-size:14px;">KSM 作为内核中的守护进程（称为 ksmd）存在，它定期执行页面扫描，识别副本页面并合并副本，释放这些页面以供它用。因此，</span><span style="line-height:1.5;font-size:14px;">在多个进程中，Linux将内核相似的内存页合并成一个内存页。这个特性，被KVM用来减少多个相似的虚拟机的内存占用，提高内存的使用效率。由于内存是共享的，所以多个虚拟机使用的内存减少了。这个特性，对于虚拟机使用相同镜像和操作系统时，效果更加明显。但是，事情总是有代价的，使用这个特性，都要增加内核开销，用时间换空间。所以为了提高效率，可以将这个特性关闭。</span></p> 
      <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;"><span style="line-height:1.5;font-size:14px;">2.3.2 好处</span></h3> 
      <p style="line-height:1.5;"><span style="line-height:1.5;font-size:14px;">其好处是，在运行类似的客户机操作系统时，通过 KSM，可以节约大量的内存，从而可以实现更多的内存超分，运行更多的虚机。&nbsp;</span></p> 
      <h4 style="font-size:14px;">2.3.3 合并过程</h4> 
      <p style="line-height:1.5;">（1）初始状态：</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011432570661017.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">（2）合并后：</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011433302547754.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">（3）Guest 1 写内存后：</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/011434087852627.jpg" alt="" style="border:0px;"></p> 
      <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.4 &nbsp;KVM Huge Page Backed Memory （巨页内存技术）</h3> 
      <div> 
       <p style="line-height:1.5;">这是KVM虚拟机的又一个优化技术.。<span style="line-height:1.5;font-size:14px;">Intel 的 x86 CPU 通常使用4Kb内存页，当是经过配置，也能够使用巨页(huge page):&nbsp;</span><span style="line-height:1.5;font-size:14px;">(4MB on x86_32, 2MB on x86_64 and x86_32 PAE)</span></p> 
      </div> 
      <div class="page view"> 
       <div class="wiki-content"> 
        <p style="line-height:1.5;">使用巨页，KVM的虚拟机的页表将使用更少的内存，并且将提高CPU的效率。最高情况下，可以提高20%的效率！</p> 
        <p style="line-height:1.5;">使用方法，需要三部：</p> 
        <pre>mkdir /dev/hugepages</pre> 
        <pre>mount -t hugetlbfs hugetlbfs /dev/hugepages
</pre> 
        <pre>#保留一些内存给巨页
sysctl vm.nr_hugepages=2048 （使用 x86_64 系统时，这相当于从物理内存中保留了2048 x 2M = 4GB 的空间来给虚拟机使用）</pre> 
        <pre>#给 kvm 传递参数 hugepages
qemu-kvm - qemu-kvm -mem-path /dev/hugepages</pre> 
        <p style="line-height:1.5;">也可以在配置文件里加入：</p> 
        <pre>&lt;memoryBacking&gt;
&lt;hugepages/&gt;
&lt;/memoryBacking&gt;
</pre> 
        <p style="line-height:1.5;">验证方式，当虚拟机正常启动以后，在物理机里查看：</p> 
        <pre>cat /proc/meminfo |grep -i hugepages</pre> 
       </div> 
      </div> 
      <p style="line-height:1.5;">&nbsp;老外的<a href="http://humblec.com/give-hugepage-memory-for-guests/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">一篇文档</a>，他使用的是libvirt方式，先让libvirtd进程使用hugepages空间，然后再分配给虚拟机。</p> 
     </div> 
    </div> 
    <div>
     &nbsp;
    </div> 
   </div> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">参考资料：</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.cnblogs.com/xusongwei/archive/2012/07/30/2615592.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.cnblogs.com/xusongwei/archive/2012/07/30/2615592.html</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vt/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">https://www.ibm.com/developerworks/cn/linux/l-cn-vt/</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.slideshare.net/HwanjuKim/3cpu-virtualization-and-scheduling" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.slideshare.net/HwanjuKim/3cpu-virtualization-and-scheduling</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.cse.iitb.ac.in/~puru/courses/autumn12/cs695/classes/kvm-overview.pdf" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.cse.iitb.ac.in/~puru/courses/autumn12/cs695/classes/kvm-overview.pdf</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.linux-kvm.com/content/using-ksm-kernel-samepage-merging-kvm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.linux-kvm.com/content/using-ksm-kernel-samepage-merging-kvm</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://blog.csdn.net/summer_liuwei/article/details/6013255" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://blog.csdn.net/summer_liuwei/article/details/6013255</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://blog.pchome.net/article/458429.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://blog.pchome.net/article/458429.html</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://blog.chinaunix.net/uid-20794164-id-3601787.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://blog.chinaunix.net/uid-20794164-id-3601787.html</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">虚拟化技术性能比较和分析，周斌，张莹</p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://wiki.qemu.org/images/c/c8/Cpu-models-and-libvirt-devconf-2014.pdf" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://wiki.qemu.org/images/c/c8/Cpu-models-and-libvirt-devconf-2014.pdf</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://frankdenneman.nl/2011/01/11/beating-a-dead-horse-using-cpu-affinity/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://frankdenneman.nl/2011/01/11/beating-a-dead-horse-using-cpu-affinity/</a></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p style="line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p style="line-height:1.5;"><font color="#4b4b4b"><span style="font-size:15px;">&nbsp; &nbsp; 本文转自SammyLiu博客园博客，原文链接：http://www.cnblogs.com/sammyliu/p/4543597.html</span></font><span style="font-size:15px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <div>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
