<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>KVM 介绍（3）：I/O 全虚拟化和准虚拟化 [KVM I/O QEMU Full-Virtualizaiton Para-virtualization]... « NotBeCN</title>
  <meta name="description" content="                  学习 KVM 的系列文章：&nbsp;          （1）介绍和安装      （2）CPU 和 内存虚拟化      （3）I/O QEMU 全虚拟化和准虚拟化（Para-virtulizaiton）      （4）I/O PCI/PCIe设备直接分配和 SR-IOV...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/20/weixin_34054931_90131027.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">KVM 介绍（3）：I/O 全虚拟化和准虚拟化 [KVM I/O QEMU Full-Virtualizaiton Para-virtualization]...</h1>
    <p class="post-meta">Nov 20, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <p style="line-height:1.5;">学习 KVM 的系列文章：&nbsp;</p> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4543110.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（1）介绍和安装</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4543597.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（2）CPU 和 内存虚拟化</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4543657.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（3）I/O QEMU 全虚拟化和准虚拟化（Para-virtulizaiton）</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4548194.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（4）I/O PCI/PCIe设备直接分配和 SR-IOV</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4558638.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（5）libvirt 介绍</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4568188.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（6）Nova 通过 libvirt 管理 QEMU/KVM 虚机</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4468757.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（7）快照 （snapshot）</a></li> 
     <li style="list-style-type:disc;"><a href="http://www.cnblogs.com/sammyliu/p/4572287.html%20" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">（8）迁移 （migration）</a></li> 
    </ul>
    <p style="line-height:1.5;">&nbsp;</p> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    在 QEMU/KVM 中，客户机可以使用的设备大致可分为三类：
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    1. 模拟设备：完全由 QEMU 纯软件模拟的设备。
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    2. Virtio 设备：实现 VIRTIO API 的半虚拟化设备。
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    3. PCI 设备直接分配&nbsp;（PCI device assignment） 。
   </div> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">1. 全虚拟化 I/O 设备</h2> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div>
     KVM 在 IO 虚拟化方面，传统或者默认的方式是使用 QEMU 纯软件的方式来模拟 I/O 设备，包括键盘、鼠标、显示器，硬盘 和 网卡 等。模拟设备可能会使用物理的设备，或者使用纯软件来模拟。模拟设备只存在于软件中。&nbsp;
    </div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.1 原理<span style="line-height:1.5;font-size:14px;"><br></span> </h3> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <img src="https://images0.cnblogs.com/blog2015/697113/201506/011755339109600.jpg" alt="" style="border:0px;">
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div>
     过程：
    </div> 
    <ol>
     <li style="list-style-type:decimal;">客户机的设备驱动程序发起 I/O 请求操作请求</li> 
     <li style="list-style-type:decimal;">KVM 模块中的 I/O 操作捕获代码拦截这次 I/O 请求</li> 
     <li style="list-style-type:decimal;">经过处理后将本次 I/O 请求的信息放到&nbsp;I/O 共享页 （sharing page），并通知用户空间的&nbsp;QEMU 程序。</li> 
     <li style="list-style-type:decimal;">QEMU 程序获得 I/O 操作的具体信息之后，交由硬件模拟代码来模拟出本次 I/O 操作。</li> 
     <li style="list-style-type:decimal;">完成之后，QEMU 将结果放回 I/O 共享页，并通知 KMV 模块中的 I/O 操作捕获代码。</li> 
     <li style="list-style-type:decimal;">KVM 模块的捕获代码读取 I/O 共享页中的操作结果，并把结果放回客户机。<span style="line-height:1.5;font-size:14px;">&nbsp;</span> </li> 
    </ol>
    <div>
     注意：当客户机通过DMA （Direct Memory Access）访问大块I/O时，QEMU 模拟程序将不会把结果放进共享页中，而是通过内存映射的方式将结果直接写到客户机的内存中共，然后通知KVM模块告诉客户机DMA操作已经完成。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     这种方式的优点是可以模拟出各种各样的硬件设备；其缺点是每次 I/O 操作的路径比较长，需要多次上下文切换，也需要多次数据复制，所以性能较差。&nbsp;
    </div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.2 QEMU 模拟网卡的实现</h3> 
    <p style="line-height:1.5;">Qemu 纯软件的方式来模拟I/O设备，其中包括经常使用的网卡设备。Guest OS启动命令中没有传入的网络配置时，QEMU默认分配 rtl8139 类型的虚拟网卡类型，使用的是默认用户配置模式，这时候由于没有具体的网络模式的配置，Guest的网络功能是有限的。 全虚拟化情况下，KVM虚机可以选择的网络模式包括：</p> 
    <ol>
     <li style="list-style-type:decimal;">默认用户模式（User）；</li> 
     <li style="list-style-type:decimal;">基于网桥(Bridge)的模式；</li> 
     <li style="list-style-type:decimal;">基于NAT(Network Address Translation)的模式；</li> 
    </ol>
    <p style="line-height:1.5;">分别使用的 qemu-kvm 参数为：</p> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;"> <strong>-net user[,vlan=n]：</strong>使用用户模式网络堆栈,这样就不需要管理员权限来运行.如果没有指 定-net选项,这将是默认的情况.<strong>-net tap[,vlan=n][,fd=h]</strong> </li> 
     <li style="list-style-type:disc;"> <strong>-net nic[,vlan=n][,macaddr=addr]：</strong>创建一个新的网卡并与VLAN n(在默认的情况下n=0)进行连接。作为可选项的项目,MAC地址可以进行改变.如果 没有指定-net选项,则会创建一个单一的NIC.</li> 
     <li style="list-style-type:disc;"> <strong>-net tap[,vlan=n][,fd=h][,ifname=name][,script=file]：</strong>将TAP网络接口 name 与 VLAN n 进行连接,并使用网络配置脚本文件进行 配置。默认的网络配置脚本为/etc/qemu-ifup。如果没有指定name,OS 将会自动指定一个。fd=h可以用来指定一个已经打开的TAP主机接口的句柄。</li> 
    </ul>
    <p style="line-height:1.5;">网桥模式是目前比较简单，也是用的比较多的模式，下图是网桥模式下的 VM的收发包的流程。</p> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/021747352275846.jpg" alt="" style="border:0px;">
    </div> 
    <div> 
     <p style="line-height:1.5;">如图中所示，红色箭头表示数据报文的入方向，步骤：</p> 
     <ol>
      <li style="list-style-type:decimal;">网络数据从 Host 上的物理网卡接收，到达网桥；</li> 
      <li style="list-style-type:decimal;">由于 eth0 与 tap1 均加入网桥中，根据二层转发原则，br0 将数据从 tap1 口转发出去，即数据由 Tap设备接收；</li> 
      <li style="list-style-type:decimal;">Tap 设备通知对应的 fd 数据可读；</li> 
      <li style="list-style-type:decimal;">fd 的读动作通过 tap 设备的字符设备驱动将数据拷贝到用户空间，完成数据报文的前端接收。</li> 
     </ol>
     <p style="line-height:1.5;">（引用自&nbsp;<a href="http://luoye.me/2014/07/17/netdev-virtual-1/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://luoye.me/2014/07/17/netdev-virtual-1/</a>）</p> 
    </div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;"><span style="line-height:1.5;font-size:14px;">&nbsp;1.3 RedHat Linux 6 中提供的模拟设备</span></h3> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;">模拟显卡：提供2块模拟显卡。</li> 
     <li style="list-style-type:disc;">系统组件： 
      <ul style="list-style:none;">
       <li style="list-style-type:disc;">ntel i440FX host PCI bridge</li> 
       <li style="list-style-type:disc;">PIIX3 PCI to ISA bridge</li> 
       <li style="list-style-type:disc;">PS/2 mouse and keyboard</li> 
       <li style="list-style-type:disc;">EvTouch USB Graphics Tablet</li> 
       <li style="list-style-type:disc;">PCI UHCI USB controller and a virtualized USB hub</li> 
       <li style="list-style-type:disc;">Emulated serial ports</li> 
       <li style="list-style-type:disc;">EHCI controller, virtualized USB storage and a USB mouse</li> 
      </ul></li> 
     <li style="list-style-type:disc;"><span style="line-height:1.5;font-size:14px;">模拟的声卡：intel-hda</span></li> 
     <li style="list-style-type:disc;">模拟网卡：e1000，模拟 Intel E1000 网卡；rtl8139，模拟 RealTeck 8139 网卡。</li> 
     <li style="list-style-type:disc;">模拟存储卡：两块模拟 PCI IDE 接口卡。KVM &nbsp;限制每个虚拟机最多只能有4块虚拟存储卡。还有模拟软驱。</li> 
    </ul>
    <p align="left" style="line-height:1.5;">注意：RedHat Linux KVM 不支持 SCSI 模拟。</p> 
    <div> 
     <div> 
      <div> 
       <div> 
        <div>
         在不显式指定使用其它类型设备的情况下，KVM 虚机将使用这些默认的虚拟设备。比如上面描述的默认情况下 KVM 虚机默认使用rtl8139网卡。比如，在 RedHat Linxu 6.5 主机上启动KVM RedHat Linux 6.4 虚机后，登录虚机，查看 pci 设备，可以看到这些模拟设备：
        </div> 
        <div>
         <img src="https://images0.cnblogs.com/blog2015/697113/201506/022002166339526.jpg" alt="" style="border:0px;">
        </div> 
        <div>
         &nbsp;
        </div> 
        <div>
         当使用 “-net nic,model=e1000” 指定网卡model 为 e1000 时，
        </div> 
        <div>
         <img src="https://images0.cnblogs.com/blog2015/697113/201506/022003362422715.jpg" alt="" style="border:0px;">
        </div> 
        <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">1.4 qemu-kvm 关于磁盘设备和网络的主要选项</h3> 
        <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;">
         <tbody>
          <tr>
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">类型</td> 
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">选项</td> 
          </tr>
          <tr>
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">磁盘设备（软盘、硬盘、CDROM等）</td> 
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"><pre><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><span style="line-height:1.5;"><strong>-</strong><span style="line-height:1.5;"><strong>drive</strong> option[,option[,option[,...]]]：定义一个硬盘设备；可用子选项有很多。 file=/path/to/<span style="line-height:1.5;">somefile：硬件映像文件路径； if=interface<span style="line-height:1.5;">：指定硬盘设备所连接的接口类型，即控制器类型，如ide、scsi、sd、mtd、floppy、pflash及virtio等； index=<span style="line-height:1.5;">index：设定同一种控制器类型中不同设备的索引号，即标识号； media=<span style="line-height:1.5;">media：定义介质类型为硬盘(disk)还是光盘(cdrom)； <span style="line-height:1.5;"><span style="line-height:1.5;"> format=format：指定映像文件的格式，具体格式可参见qemu-<span style="line-height:1.5;">img命令； -<strong>boot</strong> [order=drives][,once=drives][,menu=on|off]：定义启动设备的引导次序，每种设备使用一个字符表示；不同的架构所支持的设备及其表示字符不尽相同，在x86 PC架构上，a、b表示软驱、c表示第一块硬盘，d表示第一个光驱设备，n-<span style="line-height:1.5;">p表示网络适配器；默认为硬盘设备(-boot order=dc,once=d)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></td> 
          </tr>
          <tr>
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">网络</td> 
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
            <div class="line number1 index0 alt2">
             <code class="as3 plain"><strong>-net&nbsp;nic</strong>[,vlan=n][,macaddr=mac][,model=type][,name=name][,addr=addr][,vectors=v]：创建一个新的网卡设备并连接至vlan&nbsp;n中；PC架构上默认的NIC为e1000，macaddr用于为其指定MAC地址，name用于指定一个在监控时显示的网上设备名称；emu可以模拟多个类型的网卡设备；可以使用“qemu-kvm&nbsp;-net&nbsp;nic,model=?”来获取当前平台支持的类型；</code>
            </div> 
            <div class="line number2 index1 alt1">
             <code class="as3 plain"><strong>-net&nbsp;tap</strong>[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile]：通过物理机的TAP网络接口连接至vlan&nbsp;n中，使用script=file指定的脚本(默认为/etc/qemu-ifup)来配置当前网络接口，并使用downscript=file指定的脚本(默认为/etc/qemu-ifdown)来撤消接口配置；使用script=no和downscript=no可分别用来禁止执行脚本；</code>
            </div> 
            <div class="line number3 index2 alt2">
             <code class="as3 plain"><strong>-net&nbsp;user</strong>[,option][,option][,...]：在用户模式配置网络栈，其不依赖于管理权限；有效选项有：</code>
            </div> 
            <div class="line number4 index3 alt1"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">vlan=n：连接至vlan&nbsp;n，默认n=</code>
             <code class="as3 value">0</code>
             <code class="as3 plain">；</code> 
            </div> 
            <div class="line number5 index4 alt2"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">name=name：指定接口的显示名称，常用于监控模式中；</code> 
            </div> 
            <div class="line number6 index5 alt1"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">net=addr[/mask]：设定GuestOS可见的IP网络，掩码可选，默认为</code>
             <code class="as3 value">10.0</code>
             <code class="as3 plain">.</code>
             <code class="as3 value">2.0</code>
             <code class="as3 plain">/</code>
             <code class="as3 value">8</code>
             <code class="as3 plain">；</code> 
            </div> 
            <div class="line number7 index6 alt2"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">host=addr：指定GuestOS中看到的物理机的IP地址，默认为指定网络中的第二个，即x.x.x.</code>
             <code class="as3 value">2</code>
             <code class="as3 plain">；</code> 
            </div> 
            <div class="line number8 index7 alt1"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">dhcpstart=addr：指定DHCP服务地址池中</code>
             <code class="as3 value">16</code>
             <code class="as3 plain">个地址的起始IP，默认为第</code>
             <code class="as3 value">16</code>
             <code class="as3 plain">个至第</code>
             <code class="as3 value">31</code>
             <code class="as3 plain">个，即x.x.x.</code>
             <code class="as3 value">16</code>
             <code class="as3 plain">-x.x.x.</code>
             <code class="as3 value">31</code>
             <code class="as3 plain">；</code> 
            </div> 
            <div class="line number9 index8 alt2"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">dns=addr：指定GuestOS可见的dns服务器地址；默认为GuestOS网络中的第三个地址，即x.x.x.</code>
             <code class="as3 value">3</code>
             <code class="as3 plain">；</code> 
            </div> 
            <div class="line number10 index9 alt1"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">tftp=dir：激活内置的tftp服务器，并使用指定的dir作为tftp服务器的默认根目录；</code> 
            </div> 
            <div class="line number11 index10 alt2"> 
             <code class="as3 spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
             <code class="as3 plain">bootfile=file：BOOTP文件名称，用于实现网络引导GuestOS；如：qemu&nbsp;-hda&nbsp;linux.img&nbsp;-boot&nbsp;n&nbsp;-net&nbsp;user,tftp=/tftpserver/pub,bootfile=/pxelinux.</code>
             <code class="as3 value">0</code> 
            </div> </td> 
          </tr>
         </tbody>
        </table>
        <p style="line-height:1.5;">&nbsp;对于网卡来说，你可以使用 modle 参数指定虚拟网络的类型。 RedHat Linux 6 所支持的虚拟网络类型有：</p> 
        <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
         <pre>[root@rh65 isoimages]# kvm -net nic,model=?<span style="line-height:1.5;">
qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><span style="line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</span></pre>
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">2. 准虚拟化 （Para-virtualizaiton） I/O 驱动 virtio</h2> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div>
     在 KVM 中可以使用准虚拟化驱动来提供客户机的I/O 性能。目前 KVM 采用的的是&nbsp;virtio 这个 Linux 上的设备驱动标准框架，它提供了一种 Host 与 Guest 交互的 IO 框架。
    </div> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.1 virtio 的架构</h3> 
    <div>
     &nbsp;KVM/QEMU 的 vitio 实现采用在 Guest OS 内核中安装前端驱动 （Front-end driver）和在 QEMU 中实现后端驱动（Back-end）的方式。前后端驱动通过 vring 直接通信，这就绕过了经过 KVM 内核模块的过程，达到提高 I/O 性能的目的。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011805499882916.jpg" alt="" width="541" height="311" style="border:0px;">
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     纯软件模拟的设备和 Virtio 设备的区别：virtio 省去了纯模拟模式下的异常捕获环节，Guest OS 可以和 QEMU 的 I/O 模块直接通信。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011807259737673.jpg" alt="" width="522" height="294" style="border:0px;">
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     使用 Virtio 的完整虚机 I/O流程：
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/011809286761592.jpg" alt="" width="463" height="287" style="border:0px;">
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     Host 数据发到 Guest：
    </div> 
    <div>
     1. KVM 通过中断的方式通知 QEMU 去获取数据，放到 virtio queue 中
    </div> 
    <div>
     2. KVM 再通知 Guest 去 virtio queue 中取数据。
    </div> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.2 Virtio 在 Linux 中的实现</h3> 
    <div>
     &nbsp;Virtio 是在半虚拟化管理程序中的一组通用模拟设备的抽象。这种设计允许管理程序通过一个应用编程接口 （API）对外提供一组通用模拟设备。通过使用半虚拟化管理程序，客户机实现一套通用的接口，来配合后面的一套后端设备模拟。后端驱动不必是通用的，只要它们实现了前端所需的行为。因此，Virtio 是一个在&nbsp;Hypervisor 之上的抽象API接口，让客户机知道自己运行在虚拟化环境中，进而根据 virtio 标准与 Hypervisor 协作，从而客户机达到更好的性能。
    </div> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;">前端驱动：客户机中安装的驱动程序模块</li> 
     <li style="list-style-type:disc;">后端驱动：在 QEMU 中实现，调用主机上的物理设备，或者完全由软件实现。</li> 
     <li style="list-style-type:disc;">virtio 层：虚拟队列接口，从概念上连接前端驱动和后端驱动。驱动可以根据需要使用不同数目的队列。比如 virtio-net 使用两个队列，virtio-block只使用一个队列。该队列是虚拟的，实际上是使用&nbsp;virtio-ring 来实现的。</li> 
     <li style="list-style-type:disc;">virtio-ring：实现虚拟队列的环形缓冲区</li> 
    </ul>
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    <img src="https://images0.cnblogs.com/blog2015/697113/201506/011759218327598.jpg" alt="" style="border:0px;">
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
    &nbsp;
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;"> 
    <div>
     Linux 内核中实现的五个前端驱动程序：
    </div> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;">块设备（如磁盘）</li> 
     <li style="list-style-type:disc;">网络设备</li> 
     <li style="list-style-type:disc;">PCI 设备</li> 
     <li style="list-style-type:disc;">气球驱动程序（动态管理客户机内存使用情况）</li> 
     <li style="list-style-type:disc;">控制台驱动程序</li> 
    </ul>
    <div>
     Guest OS 中，在不使用 virtio 设备的时候，这些驱动不会被加载。只有在使用某个 virtio 设备的时候，对应的驱动才会被加载。每个前端驱动器具有在管理程序中的相应的后端的驱动程序。
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     以 virtio-net 为例，解释其原理：
    </div> 
    <div> 
     <p style="line-height:1.5;">（1）virtio-net 的原理：</p> 
     <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022013482737327.jpg" alt="" width="355" height="280" style="border:0px;"></p> 
     <div> 
      <div>
       它使得：
      </div> 
      <ol>
       <li style="list-style-type:decimal;">多个虚机共享主机网卡 eth0</li> 
       <li style="list-style-type:decimal;">QEMU 使用标准的 tun/tap 将虚机的网络桥接到主机网卡上</li> 
       <li style="list-style-type:decimal;">每个虚机看起来有一个直接连接到主机PCI总线上的私有&nbsp;virtio 网络设备</li> 
       <li style="list-style-type:decimal;">需要在虚机里面安装&nbsp;virtio驱动</li> 
      </ol>
      <p style="line-height:1.5;">（2）virtio-net 的流程：</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022011246173106.jpg" alt="" width="549" height="244" style="border:0px;"></p> 
     </div> 
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     总结 Virtio 的优缺点：
    </div> 
    <ul style="list-style:none;font-size:12px;">
     <li style="list-style-type:disc;">优点：更高的IO性能，几乎可以和原生系统差不多。</li> 
     <li style="list-style-type:disc;">缺点：客户机必须安装特定的 virtio 驱动。一些老的 Linux 还没有驱动支持，一些 Windows 需要安装特定的驱动。不过，较新的和主流的OS都有驱动可以下载了。Linux 2.6.24+ 都默认支持 virtio。可以使用 lsmod | grep virtio 查看是否已经加载。</li> 
    </ul>
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.3 使用 virtio 设备 （以 virtio-net 为例）</h3> 
    <p style="line-height:1.5;">使用 virtio 类型的设备比较简单。较新的 Linux 版本上都已经安装好了 virtio 驱动，而 Windows 的驱动需要自己下载安装。</p> 
    <p style="line-height:1.5;">（1）检查主机上是否支持 virtio 类型的网卡设备</p> 
    <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
     <pre>[root@rh65 isoimages]# kvm -net nic,model=?<span style="line-height:1.5;">
qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,<span style="color:rgb(0,0,255);line-height:1.5;">virtio</span></span></pre>
    </div> 
    <p style="line-height:1.5;">（2）指定网卡设备model 为 virtio，启动虚机</p> 
    <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022004576486718.jpg" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">（3）通过 vncviewer 登录虚机，能看到被加载了的 virtio-net 需要的内核模块</p> 
    <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022006055396925.jpg" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">（4）查看 pci 设备</p> 
    <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022006442114840.jpg" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022007176339350.jpg" alt="" style="border:0px;"></p> 
    <p style="line-height:1.5;">其它 virtio 类型的设备的使用方式类似 virtio-net。</p> 
    <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;"><span style="line-height:1.5;font-size:1.17em;">2.4 vhost-net （kernel-level virtio server）</span></h3> 
    <div> 
     <p style="line-height:1.5;"><span style="line-height:1.5;font-size:14px;">&nbsp; 前面提到 virtio 在宿主机中的后端处理程序（backend）一般是由用户空间的QEMU提供的，然而如果对于网络 I/O 请求的后端处理能够在在内核空间来完成，则效率会更高，会提高网络吞吐量和减少网络延迟。在比较新的内核中有一个叫做 “vhost-net” 的驱动模块，它是作为一个内核级别的后端处理程序，将virtio-net的后端处理任务放到内核空间中执行，减少内核空间到用户空间的切换，从而提高效率。</span></p> 
     <p style="line-height:1.5;">根据 KVM 官网的<a href="http://www.linux-kvm.org/page/UsingVhost" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">这篇文章</a>，vhost-net 能提供更低的延迟（latency）（比 e1000 虚拟网卡低 10%），和更高的吞吐量（throughput）（8倍于普通 virtio，大概&nbsp;&nbsp;7~8 Gigabits/sec )。</p> 
     <p style="line-height:1.5;">vhost-net 与 virtio-net 的比较：</p> 
     <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022016033364356.jpg" alt="" style="border:0px;"></p> 
     <p style="line-height:1.5;">vhost-net 的要求：</p> 
     <ul style="list-style:none;font-size:12px;">
      <li style="list-style-type:disc;">qemu-kvm-0.13.0 或者以上</li> 
      <li style="list-style-type:disc;">主机内核中设置&nbsp;CONFIG_VHOST_NET=y 和在虚机操作系统内核中设置&nbsp;CONFIG_PCI_MSI=y （Red Hat Enterprise Linux 6.1 开始支持该特性）</li> 
      <li style="list-style-type:disc;">在客户机内使用 virtion-net 前段驱动</li> 
      <li style="list-style-type:disc;">在主机内使用网桥模式，并且启动 vhost_net</li> 
     </ul>
     <p style="line-height:1.5;"><span style="line-height:1.5;">qemu-kvm 命令的 -net tap&nbsp;有几个选项和 vhost-net 相关的:&nbsp;-net tap,[,vnet_hdr=on|off][,vhost=on|off][,vhostfd=</span><em style="line-height:1.5;">h</em><span style="line-height:1.5;">][,vhostforce=on|off]</span></p> 
     <div> 
      <ul style="list-style:none;font-size:12px;">
       <li style="list-style-type:disc;"> <strong>vnet_hdr =on|off：</strong>设置是否打开TAP设备的“IFF_VNET_HDR”标识。“vnet_hdr=off”表示关闭这个标识；“vnet_hdr=on”则强制开启这个标识，如果没有这个标识的支持，则会触发错误。IFF_VNET_HDR是tun/tap的一个标识，打开它则允许发送或接受大数据包时仅仅做部分的校验和检查。打开这个标识，可以提高virtio_net驱动的吞吐量。</li> 
       <li style="list-style-type:disc;"> <strong>vhost=on|off：</strong>设置是否开启vhost-net这个内核空间的后端处理驱动，它只对使用MIS-X中断方式的virtio客户机有效。</li> 
       <li style="list-style-type:disc;"> <strong>vhostforce=on|off：</strong>设置是否强制使用 vhost 作为非MSI-X中断方式的Virtio客户机的后端处理程序。</li> 
       <li style="list-style-type:disc;"> <strong>vhostfs=h：</strong>设置为去连接一个已经打开的vhost网络设备。</li> 
      </ul>
      <p style="line-height:1.5;">vhost-net 的使用实例：</p> 
      <p style="line-height:1.5;">（1）确保主机上 vhost-net 内核模块被加载了</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/030911335703305.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">（2）启动一个虚拟机，在客户机中使用 -net 定义一个 virtio-net 网卡，在主机端使用 -netdev 启动 vhost</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/031232536023390.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">（3）在虚拟机端，看到 virtio 网卡使用的 TAP 设备为 tap0。</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/031235009612598.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">（4）在宿主机中看 vhost-net 被加载和使用了，以及 Linux 桥 br0，它连接物理网卡 eth1 和 客户机使用的 TAP 设备 tap0</p> 
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/031236349774254.jpg" alt="" style="border:0px;"></p> 
      <p style="line-height:1.5;">&nbsp;</p> 
      <p style="line-height:1.5;"><span style="line-height:1.5;">一般来说，使用 vhost-net 作为后端处理驱动可以提高网络的性能。不过，对于一些网络负载类型使用 vhost-net 作为后端，却可能使其性能不升反降。特别是从宿主机到其中的客户机之间的UDP流量，如果客户机处理接受数据的速度比宿主机发送的速度要慢，这时就容易出现性能下降。在这种情况下，使用vhost-net将会是UDP socket的接受缓冲区更快地溢出，从而导致更多的数据包丢失。故这种情况下，不使用vhost-net，让传输速度稍微慢一点，反而会提高整体的性能。</span></p> 
      <p style="line-height:1.5;">使用 qemu-kvm 命令行，加上“vhost=off”（或没有vhost选项）就会不使用vhost-net，而在使用libvirt时，需要对客户机的配置的XML文件中的网络配置部分进行如下的配置，指定后端驱动的名称为“qemu”（而不是“vhost”）。</p> 
      <div> 
       <p style="line-height:1.5;">&lt;interface type=”network”&gt;</p> 
       <p style="line-height:1.5;">…</p> 
       <p style="line-height:1.5;">&nbsp; &nbsp; &lt;model type=”virtio”/&gt;</p> 
       <p style="line-height:1.5;">&nbsp; &nbsp; &lt;driver name=”qemu”/&gt;</p> 
       <p style="line-height:1.5;">…</p> 
       <p style="line-height:1.5;">&lt;/interface&gt;</p> 
      </div> 
     </div> 
     <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.6 virtio-balloon</h3> 
     <p style="line-height:1.5;">另一个比较特殊的 virtio 设备是 virtio-balloon。通常来说，要改变客户机所占用的宿主机内存，要先关闭客户机，修改启动时的内存配置，然后重启客户机才可以实现。而 内存的 ballooning （气球）技术可以在客户机运行时动态地调整它所占用的宿主机内存资源，而不需要关闭客户机。该技术能够：</p> 
     <div> 
      <ul style="list-style:none;font-size:12px;">
       <li style="list-style-type:disc;">当宿主机内存紧张时，可以请求客户机回收利用已分配给客户机的部分内存，客户机就会释放部分空闲内存。若其内存空间不足，可能还会回收部分使用中的内存，可能会将部分内存换到交换分区中。</li> 
       <li style="list-style-type:disc;">当客户机内存不足时，也可以让客户机的内存气球压缩，释放出内存气球中的部分内存，让客户机使用更多的内存。</li> 
      </ul>
      <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/030704019615428.jpg" alt="" width="428" height="367" style="border:0px;"></p> 
      <div> 
       <div>
        目前很多的VMM，包括 KVM, Xen，VMware 等都对 ballooning 技术提供支持。其中，KVM 中的 Ballooning 是通过宿主机和客户机协同来实现的，在宿主机中应该使用 2.6.27 及以上版本的 Linux内核（包括KVM模块），使用较新的 qemu-kvm（如0.13版本以上），在客户机中也使用 2.6.27 及以上内核且将“CONFIG_VIRTIO_BALLOON”配置为模块或编译到内核。在很多Linux发行版中都已经配置有“CONFIG_VIRTIO_BALLOON=m”，所以用较新的Linux作为客户机系统，一般不需要额外配置virtio_balloon驱动，使用默认内核配置即可。
       </div> 
       <div>
        &nbsp;
       </div> 
       <div>
        原理：
       </div> 
       <ol>
        <li style="list-style-type:decimal;">KVM 发送请求给 VM 让其归还一定数量的内存给KVM。</li> 
        <li style="list-style-type:decimal;">VM 的 virtio_balloon 驱动接到该请求。</li> 
        <li style="list-style-type:decimal;">VM 的驱动是客户机的内存气球膨胀，气球中的内存就不能被客户机使用。</li> 
        <li style="list-style-type:decimal;">VM 的操作系统归还气球中的内存给VMM</li> 
        <li style="list-style-type:decimal;">KVM 可以将得到的内存分配到任何需要的地方。</li> 
        <li style="list-style-type:decimal;">KM 也可以将内存返还到客户机中。</li> 
       </ol>
       <p style="line-height:1.5;">优势和不足：</p> 
       <div>
        &nbsp;
       </div> 
       <div> 
        <table border="0" style="border:1px solid #C0C0C0;border-collapse:collapse;">
         <tbody>
          <tr>
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">优势</td> 
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;">不足</td> 
          </tr>
          <tr>
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
            <ol>
             <li style="list-style-type:decimal;">ballooning 可以被控制和监控</li> 
             <li style="list-style-type:decimal;">对内存的调节很灵活，可多可少。</li> 
             <li style="list-style-type:decimal;">KVM 可以归还内存给客户机，从而缓解其内存压力。</li> 
            </ol></td> 
           <td style="font-size:12px;color:rgb(69,69,69);border:1px solid #C0C0C0;border-collapse:collapse;"> 
            <ol>
             <li style="list-style-type:decimal;">需要客户机安装驱动</li> 
             <li style="list-style-type:decimal;">大量内存被回收时，会降低客户机的性能。</li> 
             <li style="list-style-type:decimal;">目前没有方便的自动化的机制来管理 ballooning，一般都在 QEMU 的 monitor 中执行命令来实现。</li> 
             <li style="list-style-type:decimal;">内存的动态增加或者减少，可能是内存被过度碎片化，从而降低内存使用性能。</li> 
            </ol></td> 
          </tr>
         </tbody>
        </table>
        <p style="line-height:1.5;">在QEMU monitor中，提供了两个命令查看和设置客户机内存的大小。</p> 
        <ul style="list-style:none;font-size:12px;">
         <li style="list-style-type:disc;">(qemu) info balloon &nbsp; &nbsp;#查看客户机内存占用量（Balloon信息）</li> 
         <li style="list-style-type:disc;">(qemu) balloon&nbsp;<em>num</em>&nbsp;&nbsp;&nbsp;#设置客户机内存占用量为<em>num</em>MB</li> 
        </ul> 使用实例：
       </div> 
       <p style="line-height:1.5;">&nbsp;（1）启动一个虚机，内存为 2048M，启用 virtio-balloon</p> 
       <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022030368833762.jpg" alt="" style="border:0px;"></p> 
       <p style="line-height:1.5;">（2）通过 vncviewer 进入虚机，查看 pci 设备</p> 
       <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022031525397276.jpg" alt="" style="border:0px;"></p> 
       <p style="line-height:1.5;">（3）看看内存情况，共 2G 内存</p> 
       <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022032300397732.jpg" alt="" style="border:0px;"></p> 
       <p style="line-height:1.5;">（4）进入 QEMU Monitor，调整 balloon 内存为 500M</p> 
       <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022159143055031.jpg" alt="" style="border:0px;"></p> 
       <p style="line-height:1.5;">（5）回到虚机，查看内存，变为 500 M</p> 
       <p style="line-height:1.5;"><img src="https://images0.cnblogs.com/blog2015/697113/201506/022159573369677.jpg" alt="" style="border:0px;"></p> 
       <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;"> <span style="line-height:1.5;font-size:14px;">&nbsp;2.7 RedHat 的 多队列 Virtio （</span><span style="line-height:1.5;font-size:14px;">multi-queue）</span> </h3> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
     <span style="line-height:1.5;">&nbsp; &nbsp; 目前的高端服务器都有多个处理器，虚拟使用的虚拟CPU数目也不断增加。默认的 virtio-net&nbsp;不能并行地传送或者接收网络包，因为 virtio_net 只有一个TX 和 RX 队列。而多队列 virtio-net 提供了一个随着虚机的虚拟CPU增加而增强网络性能的方法，通过使得 virtio 可以同时使用多个 virt-queue 队列。</span>
    </div> 
    <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
     <img src="https://images0.cnblogs.com/blog2015/697113/201506/030659103984455.jpg" alt="" style="border:0px;">
    </div> 
    <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:15px;">
     &nbsp;
    </div> 
    <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;"> 
     <div style="font-size:15px;">
      它在以下情况下具有明显优势：
     </div> 
     <ol style="font-size:15px;">
      <li style="list-style-type:decimal;">网络流量非常大</li> 
      <li style="list-style-type:decimal;">虚机同时有非常多的网络连接，包括虚拟机之间的、虚机到主机的、虚机到外部系统的等</li> 
      <li style="list-style-type:decimal;">virtio 队列的数目和虚机的虚拟CPU数目相同。这是因为多队列能够使得一个队列独占一个虚拟CPU。</li> 
     </ol>
     <div style="font-size:15px;">
      注意：对队列 virtio-net 对流入的网络流工作得非常好，但是对外发的数据流偶尔会降低性能。打开对队列&nbsp;virtio 会增加中的吞吐量，这相应地会增加CPU的负担。 在实际的生产环境中需要做必须的测试后才确定是否使用。
     </div> 
     <div style="font-size:15px;">
      &nbsp;
     </div> 
     <div style="font-size:15px;">
      在&nbsp;RedHat 中，要使用多队列&nbsp;virtio-net，在虚机的&nbsp;XML 文件中增加如下配置：
     </div> 
     <div style="font-size:15px;">
      <img src="https://images0.cnblogs.com/blog2015/697113/201506/030700197423906.jpg" alt="" style="border:0px;">
     </div> 
     <div style="font-size:15px;"></div> 
     <div style="font-size:15px;">
      然后在主机上运行下面的命令：
     </div> 
     <div style="font-size:15px;"> 
      <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);color:rgb(0,0,0);font-family:'Courier New';font-size:12px;">
       <pre>ethtool -L eth0 combined M ( <span style="color:rgb(128,0,128);line-height:1.5;">1</span> &lt;= M &lt;= N)</pre>
      </div> 
     </div> 
     <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">2.8 Windows 客户机的 virtio 前端驱动</h3> 
     <div style="font-size:15px;">
      Windows 客户机下的 virtio 前端驱动必须下载后手工安装。&nbsp;RedHat Linux
      <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Host_Configuration_and_Guest_Installation_Guide/form-Virtualization_Host_Configuration_and_Guest_Installation_Guide-Para_virtualized_drivers-Mounting_the_image_with_virt_manager.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">&nbsp;这篇文章</a>&nbsp;说明了在 Windows 客户机内安装virtio 驱动的方法。
     </div> 
     <div style="font-size:15px;">
      &nbsp;
     </div> 
     <h2 style="font-size:21px;line-height:1.5;">3. 一些测试数据</h2> 
     <h3 style="font-size:16px;color:rgb(102,102,102);background-image:none;background-repeat:no-repeat;font-family:Verdana;line-height:1.5;">3.1 virtio 和 ide 的对比</h3> 
     <p style="font-size:15px;line-height:1.5;"><img src="https://images2017.cnblogs.com/blog/697113/201712/697113-20171215141647636-511877991.png" alt="" style="border:0px;"></p> 
     <p style="font-size:15px;line-height:1.5;">Virtio半虚拟化驱动的方式可以获得很好的I/O性能，比纯软件模拟高于4倍多，其性能几乎可以达到和Native（即非虚拟化环境中的原生系统）差不多的I/O性能。所以，在使用KVM之时，如果宿主机内核和客户机都支持VirtIO的情况下，一般推荐使用Virtio达到更好的性能。</p> 
     <p style="font-size:15px;line-height:1.5;"><img src="https://images2017.cnblogs.com/blog/697113/201712/697113-20171215141806621-1062219983.png" alt="" style="border:0px;"></p> 
     <p style="font-size:15px;line-height:1.5;">VirtIO半虚拟化驱动的方式可以获得很好的IO延迟，从另一个层面验证了半虚拟化驱动在KVM发挥的性格优势。&nbsp;</p> 
     <div style="font-size:15px;">
      &nbsp;
     </div> 
     <div style="font-size:15px;">
      <strong>参考文档：</strong>
     </div> 
     <ul style="font-size:12px;list-style:none;">
      <li style="list-style-type:disc;"><a href="http://linux.web.cern.ch/linux/centos7/docs/rhel/Red_Hat_Enterprise_Linux-7-Virtualization_Tuning_and_Optimization_Guide-en-US.pdf" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://linux.web.cern.ch/linux/centos7/docs/rhel/Red_Hat_Enterprise_Linux-7-Virtualization_Tuning_and_Optimization_Guide-en-US.pdf</a></li> 
      <li style="list-style-type:disc;"><a href="http://toast.djw.org.uk/qemu.html" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;font-size:14px;line-height:1.5;">http://toast.djw.org.uk/qemu.html</a></li> 
      <li style="list-style-type:disc;">KVM 官方文档</li> 
      <li style="list-style-type:disc;"><span style="line-height:1.5;">KVM 虚拟化技术实战与解析 任永杰、单海涛 著</span></li> 
      <li style="list-style-type:disc;"><span style="line-height:1.5;">RedHat Linux 6 官方文档</span></li> 
      <li style="list-style-type:disc;"> <a href="http://www.slideshare.net/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;line-height:1.5;">http://www.slideshare.net</a><span style="line-height:1.5;">&nbsp;中关于 KVM 的一些文档</span> </li> 
      <li style="list-style-type:disc;"><a href="http://www.linux-kvm.org/page/Multiqueue" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;line-height:1.5;">http://www.linux-kvm.org/page/Multiqueue</a></li> 
      <li style="list-style-type:disc;">以及部分来自于网络，比如&nbsp;<a href="http://smilejay.com/2012/11/use-ballooning-in-kvm/" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://smilejay.com/2012/11/use-ballooning-in-kvm/</a> </li> 
      <li style="list-style-type:disc;"><a href="http://www.h3c.com/cn/d_201311/804193_30008_0.htm" rel="nofollow" style="color:rgb(26,139,200);text-decoration:none;">http://www.h3c.com/cn/d_201311/804193_30008_0.htm</a></li> 
     </ul>
     <div>
      <span style="font-size:12px;"><br></span>
     </div> 
    </div> 
    <div> 
     <div> 
      <font color="#4b4b4b"><span style="font-size:12px;">&nbsp; &nbsp; 本文转自SammyLiu博客园博客，原文链接：http://www.cnblogs.com/sammyliu/p/4543657.html</span></font>
      <span style="font-size:12px;color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span> 
     </div> 
     <div style="color:rgb(75,75,75);font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:12px;">
      <br>
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
