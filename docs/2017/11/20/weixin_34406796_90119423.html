<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Java学习——资源管理 « NotBeCN</title>
  <meta name="description" content="             46、包/套件/package    Java提供package机制，它就像是一个管理容器，可以将您所 定义的名称区隔管理在package下，而不会有相互冲突的发生，例如您定义了一个 dimension2d与dimension3d的package，在它们之下都有一个Point类别，但由于...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/20/weixin_34406796_90119423.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Java学习——资源管理</h1>
    <p class="post-meta">Nov 20, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">46、包/套件/package</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Java提供package机制，它就像是一个管理容器，可以将您所 定义的名称区隔管理在package下，而不会有相互冲突的发生，例如您定义了一个 dimension2d与dimension3d的package，在它们之下都有一个Point类别，但由于属于不同的package，所以这两个名称 并不会有所冲突。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Java的package被设计为与档案系统结构相对应，如果您的package设定是only.caterpillar，则该类别应该在指定目录（或jar）的onlyfun/caterpillar下可以找到，为了要能建立与package相对应的档案系统结构，您在编译时可以加入-d 参数，并指定要建立在哪一个目录之下。<br><br></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">下面这个程序<span style="color:rgb(255,0,0);">使用"package"关键词来建立package</span>以管理我们所定义的类别：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">package</span><span style="font-size:12px;line-height:1.5;"> onlyfun.caterpillar;
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span><span style="font-size:12px;line-height:1.5;"> UsePackage {
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span><span style="font-size:12px;line-height:1.5;"> main(String[] args) {
        System.out.println(</span>"Hello! World!"<span style="font-size:12px;line-height:1.5;">);
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在编译时要使用以下的指令：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre>$ javac -d . UsePackage.java </pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在编译时使用 "-d" 参数，并指定在<span style="color:rgb(255,0,0);">现行目录 "."</span>中建立档案与系统结构，则编译完成之后，在现行目录中会出现onlyfun/caterpillar目录，而当中有一个UsePackage.class 档案，在编译完成之后，package的指定就成为class名称的一部份了，在执行时可以这么下指令：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span style="font-size:12px;line-height:1.5;">$ java onlyfun.caterpillar.UsePackage 
Hello</span>! World! </pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">可以为类别建立package管理，举下面的例子来说：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">package</span><span style="font-size:12px;line-height:1.5;"> onlyfun.caterpillar;
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span><span style="font-size:12px;line-height:1.5;"> Point2D {
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> x, y;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> Point2D() {x = 0; y = 0<span style="font-size:12px;line-height:1.5;">;}
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> Point2D(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> x, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> y) {<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span>.x = x; <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span>.y =<span style="font-size:12px;line-height:1.5;"> y;}
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> getX() {<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> x;}
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> getY() {<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> y;}
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">这个类别建立在Point2D.java档案中，可以先用以下的指令来编译它：</p> 
   <pre class="code">$ javac -d .&nbsp; Point2D.java</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">之前说过，package名称为类别名称的一部份，除非您重新编译类别，否则的话无法改变这个名称，为了要使用这个类别，方法之一是使用完全描述（Fully qualified）名称，也就是完整的指出package与类别名称，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UsePackage.java</h5> 
   <pre class="code">public class UsePackage {
	public static void main(String[] args) {
		onlyfun.caterpillar.Point2D p1 = new
		onlyfun.caterpillar.Point2D(10, 20);
		System.out.printf("p1: (x, y) = (%d, %d)%n",
		p1.getX(), p1.getY());
	}
}
</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">当然这个方法在使用上不是很方便，您可以使用"import"关键词，告知编译器要使用的类别是位于哪一个package之下，如此可以少打一些 字，让编译器多作一些事，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UsePackage.java</h5> 
   <pre class="code">import onlyfun.caterpillar.Point2D;
public class UsePackage {
	public static void main(String[] args) {
		Point2D p1 = new Point2D(10, 20);
		System.out.printf("p1: (x, y) = (%d, %d)%n",
		p1.getX(), p1.getY());
	}
}
</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">您在使用"import"时可以指定类别的完整描述，如果您会使用到某个package下的许多类别，您可以使用 '*'，表示您可能使用到某个package下的某些类别，再让编译器作更多事</span>，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UsePackage.java</h5> 
   <pre class="code">import onlyfun.caterpillar.*;
public class UsePackage {
	public static void main(String[] args) {
		Point2D p1 = new Point2D(10, 20);
		System.out.printf("p1: (x, y) = (%d, %d)%n",
		p1.getX(), p1.getY());
	}
}
</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br> 但要注意的是，<span style="color:rgb(255,0,0);">如果您import之后，出现类别名称有同名冲突时，编译器就不知道如何处理了</span>，例如：</p> 
   <pre class="code">import java.util.Arrays;
import onlyfun.caterpillar.Arrays;
public class SomeClass {
	....
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">在这个例子中，编译器发现有两个Arrays类别，它不确定若遇到Arrays时您要使用的是java.util.Arrays，或是 onlyfun.caterpillar.Arrays，它只好回报以下讯息：</span></p> 
   <pre class="code">java.util.Arrays is already defined in a single-type import
import onlyfun.caterpillar.Arrays;
^
1 error</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">这个时候您就要考虑换一下类别名称了（如果您有权更动那些类别的话），或者是不使用"import"，直接使用完整描述</span>；<span style="color:rgb(255,0,0);">在"import"时尽量不使用 '*' 也可以减少这种情况发生</span>。<br><br> 注意<span style="color:rgb(255,0,0);">如果您提供的类别若不位于相同的package中，您的类别必须宣告为"public"，若不宣告则类别预设只能于同一个package中被存取</span>，例如将之前Point2D类别的public拿掉，则编译UsePackage.java档案时，会出现以下的错误：</p> 
   <pre class="code">UsePackage.java:5: caterpillar.demo.Point2D is not public in caterpillar.demo;cannot be accessed from outside package</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果定义类别成员时<span style="color:rgb(255,0,0);">没有指定public、protected或private的存取修饰，则为预设（Default）权 限</span>，成员将只能于同一个package中被直接存取，通常称之为package-friendly或package-private，且该成员将无法于子 类别中被直接存取。<em><br><br></em>要存取package的class也与CLASSPATH的设定有关，建议您也看看官方网站上的文章，您对package的了解会更深入：</p> 
   <ul style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style-type:disc;">Setting the class path (Windows)</li> 
    <li style="list-style-type:disc;">Setting the class path (Solaris and Linux)&nbsp;</li> 
   </ul>
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">Java平台的classes是被储存在Java安装目录的jre/lib/下的rt.jar，另外额外的第三组件（Third- party）可以放在/jre/lib/ext/中，在之前的例子中，使用"import"就是在告知编译器我们的类别位于哪一个package下，这些类别必须设定好CLASSPATH才可以被编译器找到，预设上是jre/lib/下的rt.jar、jre/lib/ext/中相关扩充组件与现行工作目录</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">47、预设建构子</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">当您在Java中定义一个类别，但没有定义建构子时，编译器会自动帮您产生一个预设建构子。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在继承时，如果您没有使用super()指定要使用父类别的哪个建构子，则预设会寻找无参数的建构子。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">预设建构子的存取权限是跟随着类别的存取权限。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">48、存取权限与修饰</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在这边整理一下private、protected、public与default与类别及套件的存取关系：</p> 
   <table style="border-collapse:collapse;border-spacing:0px;border:1px solid #C0C0C0;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <tbody>
     <tr>
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>存取修饰</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>同一类别</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>同一套件</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>子类别</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>全域</p> </td> 
     </tr>
     <tr>
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>private</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
     </tr>
     <tr>
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>default</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
     </tr>
     <tr>
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>protected</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;">&nbsp;</td> 
     </tr>
     <tr>
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>public</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
      <td style="border:1px solid #C0C0C0;border-collapse:collapse;"> <p>OK</p> </td> 
     </tr>
    </tbody>
   </table>
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">49、常数设置</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">有时候您会需要定义一些常数供程序使用，您可以使用接口或类别来定义，例如定义操作常数：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">OpConstants.java</h5> 
   <pre class="code">public interface OpConstants {
	public static final int TURN_LEFT = 1;
	public static final int TURN_RIGHT = 2;
	public static final int SHOOT = 3;
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">常数必须是可以直接取用，并且不可被修改的，所以我们在宣告时加上&nbsp;<a href="http://www.iteedu.com//plang/java/javadiary/38.php" rel="nofollow" style="color:rgb(0,0,0);">static</a>&nbsp;与&nbsp;<a href="http://www.iteedu.com//plang/java/javadiary/50.php" rel="nofollow" style="color:rgb(0,0,0);">final</a>，事实上，对于接口来说，当中的常数预设就为public、static、final，即使您没有明确指定修饰，例如下例与上例是一样的：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">OpConstants.java</h5> 
   <pre class="code">public interface OpConstants { 
int TURN_LEFT = 1; 
int TURN_RIGHT = 2; 
int SHOOT = 3; 
} </pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">这意谓着如果您实作的接口中有定义常数，您不可以重新指定该常数值，例如下例是错误的…</p> 
   <pre class="code">interface ISome {
	int const = 10;
	...
}
public class Some implements ISome {
	public Some() {
		const = 20; // 这行是错的
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">宣告常数之后，就可以在程序中直接使用 OperateConstants.TURN_LEFT之类的名称来取代常数值，例如：</p> 
   <pre class="code">public void someMethod() {
	....
	doOp(OpConstants.TURN_RIGHT);
	....
}
public void doOp(int op) {
	switch(op) {
		case OpConstants.TURN_LEFT:
		System.out.println("向左转");
		break;
		case OpConstants.TURN_RIGHT:
		System.out.println("向右转");
		break;
		case OpConstants.SHOOT:
		System.out.println("射击");
		break;
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果使用类别来宣告的话，方法也是类似，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">OpConstants.java</h5> 
   <pre class="code">public class OpConstants {
	public static final int TURN_LEFT = 1;
	public static final int TURN_RIGHT = 2;
	public static final SHOOT = 3;
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">对于简单的常数设置，上面的作法已经足够了，不过在&nbsp;<cite>J2SE 5.0</cite>&nbsp;中新增了&nbsp;<a href="http://www.iteedu.com//plang/java/javadiary/63.php" rel="nofollow" style="color:rgb(0,0,0);">列举型态（Enumerated Types）</a>，使用列举型态，除常数设定的功能之外，您还可以获得像编译时期型态检查等的更多好处。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">50、Static import</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在&nbsp;<cite>J2SE 5.0</cite>&nbsp;后新增了"import static" ，它的作用与&nbsp;<a href="http://www.iteedu.com//plang/java/javadiary/54.php" rel="nofollow" style="color:rgb(0,0,0);">套件 （package）</a>&nbsp;中介绍的"import"类似，都是为了让您可以省一些打字功夫，让编译器多作一点事而存在的。<br><br> "import static"是使用时的语法，国外网站上的文章或原文书中介绍这个功能时，大都用static import描述这个功能，编译器讯息也这么写，这边就还是用static import来作为原文时的描述，但为了比较彰显这个功能的作用，我称之为「import 静态成员」。<br><br> 使用"import static"语法，您可以import类别或接口中的静态成员，例如来看看这个Hello! World!程序：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">HelloWorld.java</h5> 
   <pre class="code">import static java.lang.System.out;
public class HelloWorld {
	public static void main(String[] args) {
		out.println("Hello! World!");
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在这边您将java.lang.System类别中的out静态成员import至程序中，编译时编译器遇到out名称，就会自动展开为System.out，所以这还是编译器给的蜜糖（Compiler suger）。<br><br> 再来看一个例子，<a href="http://www.iteedu.com//plang/java/javadiary/25.php" rel="nofollow" style="color:rgb(0,0,0);">Arrays 类别</a>&nbsp;中有很多的静态方法，为了使用方便，可使用"import static"将这些静态方法import至程序中，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseImportStatic.java</h5> 
   <pre class="code">import static java.lang.System.out;
import static java.util.Arrays.sort;
public class UseImportStatic {
	public static void main(String[] args) {
		int[] array = {2, 5, 3, 1, 7, 6, 8};
		sort(array);
		for(int i : array) {
			out.print(i + " ");
		}
	}
}
</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果您想要import类别下所有的静态成员，可以使用 '*' 字符，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseImportStatic.java</h5> 
   <pre class="code">import static java.lang.System.*;
import static java.util.Arrays.*;
public class UseImportStatic {
	public static void main(String[] args) {
		int[] array = {2, 5, 3, 1, 7, 6, 8};
		sort(array);
		for(int i : array) {
			out.print(i + " ");
		}
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">与import一样，import 静态成员（static import）这个功能是为了方便，可以让您少打一些字，您把少打的字交给编译器来判断并自动为您补上，但是您要注意名称冲突问题，有些名称冲突编译器可 能透过以下的几个方法来解决：</p> 
   <ul style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style-type:disc;">成员覆盖&nbsp;<br> 如果类别中有同名的field或方法名称，则优先选用它们。</li> 
    <li style="list-style-type:disc;">区域变量覆盖<br> 如果方法中有同名的变量名或自变量名，则选用它们。</li> 
    <li style="list-style-type:disc;">重载（Overload）方法 上的比对<br> 对于被使用import static的各个静态成员，若有同名冲突，尝试透用重载机制判断，也就是透过方法名称及自变量列的比对来选择适当的方法。</li> 
   </ul>
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果编译器无法判断，则会回报错误，例如若您定义的sort()方法与Arrays的sort()方法冲突，且编译器也无法判别时，会出现以下的讯息：</p> 
   <pre class="code"> reference to sort is ambiguous,
 both method sort(float[]) in onlyfun.caterpillar.Arrays and
 method sort(float[]) in java.util.Arrays match</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">总之，package与类别等可以用于管理一些资源，避免同名冲突发生，而"import"与"import staic"则是反其道而行，让您可以获得一些方便，如果同名冲突发生了，这种方便性的使用就有考虑的必要了。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">51、异常处理</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">Java的例外处理藉由"try"、"catch"、"finally"三个关键词组合的语言来达到，其语法基本结构如下：</p> 
   <pre class="code">try {
	// 陈述句
}
catch(例外型态 名称) {
	// 例外处理
}
finally {
	// 一定会处理的区块
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">一个"try"所包括的区块，必须有对应的"catch"区块，它可以有多个"catch"区域，而"finally"可有可无，如果没有定义"catch"区块，则一定要有"finally"区块</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">先来看个实例，了解如何使用try...catch来处理使用者输入的错误：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseException.java</h5> 
   <pre class="code">import java.io.*;
public class UseException {
	public static void main(String[] args) {
		try {
			int input;
			BufferedReader buf = new BufferedReader(
			new InputStreamReader(System.in));
			System.out.print("请输入整数: ");
			input = Integer.parseInt(buf.readLine());
			System.out.println("input x 10 = " + (input*10));
		}
		catch(IOException e) {
			System.out.println("I/O错误");
		}
		catch(NumberFormatException e) {
			System.out.println("输入格式有误");
		}
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">例外处理是程序在执行但发生错误并无法处理时，会丢出一个例外对象，在这个程序中，您特意&nbsp;<a href="http://www.iteedu.com//plang/java/javadiary/5.php" rel="nofollow" style="color:rgb(0,0,0);">使用 BufferedReader 取得输入</a>，当使用 BufferedReader类别时，若发生I/O错误会丢出IOException例外，这个例外您必须处理。<br><br> 您试着从使用者输入取得一个整数值，由BufferedReader对象所读取到的输入是个字符串，您使用Integer类别的 parseInt()方法试着剖析该字符串为整数，如果无法剖析，则会发生错误并丢出一个NumberFormatException例外对象，当这个例外丢出后，程序会离开目前执行的位置，而如果设定的"catch"有捕捉这个例外，则会执行对应区块中的陈述句，注意当例外一但丢出，就不会再回到例外的丢出点了。<br><br> 来看看这个程序的执行范例：</p> 
   <pre class="code">$ java UseException 
请输入整数: 10 
input x 10 = 100 
$ java UseException 
请输入整数: XX 
输入格式有误</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果程序中设定有"finally"区块，则无论例外是否有发生，则一定会执行"finally"区块中所定义的陈述句，"finally"区块使用时机 的例子之一，就是当您开启了某个档案时，在读/写的过程中发生错误，在使用"catch"区块处理相对应的例外之后，最后在"finally"区块中定义 一些关闭档案的动作，让关闭档案的动作一定会被执行。<br><br> 使用例外处理的好处是您可以将程序逻辑与错误处理分开，使得程序易于撰写、阅读与维护，由于例外处理是在程序执行时发生错误，而没有办法处理之时才产生例外对象，所以与使用判断式来避免例外的方式比起来，例外处理会有比较好的执行效能。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">52、throw、throws</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">当程序发生错误而无法处理的时候，会丢出对应的例外对象，除此之外，在某些时刻，您可能会想要自行丢出例外，例如在例外处理结束后，再将例外丢出，让下一层例外处理区块来捕捉，若想要自行丢出例外，您可以使用"throw"关键词，并生成指定的例外对象，例如：</p> 
   <pre class="code">throw new ArithmeticException();</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">举个例子来说明，在Java的除法中，允许除数为浮点数0.0，所得到的是Infinity，即无穷数，如果您想要自行检验除零错误，可以自行丢出例外，最接近这个条件的是ArithmeticException，当除数为整数且为0时，就会引发这个例外，您可以如下丢出例外：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseThrow.java</h5> 
   <pre class="code">public class UseThrow {
	public static void main(String[] args) {
		double dblzero = 0.0;
		try {
			System.out.println("浮点数除以零: "
			+ (100 / dblzero));
			if(dblzero == 0)
			throw new ArithmeticException();
		}
		catch(ArithmeticException e) {
			System.out.println("发生除零例外");
		}
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">执行结果：</p> 
   <pre class="code">浮点数除以零: Infinity 
发生除零例外</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">每个例外都必须有一个"catch"区块来捕捉，在巢状的try...catch时，必须注意该例外是由何者引发并由何者捕捉，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseThrow.java</h5> 
   <pre class="code">public class UseThrow {
	public static void main(String[] args) {
		try {
			try {
				throw new ArrayIndexOutOfBoundsException();
			}
			catch(ArrayIndexOutOfBoundsException e) {
				System.out.println(
				"ArrayIndexOutOfBoundsException/内层try-catch");
			}
			throw new ArithmeticException();
		}
		catch(ArithmeticException e) {
			System.out.println("发生ArithmeticException");
		}
		catch(ArrayIndexOutOfBoundsException e) {
			System.out.println(
			"ArrayIndexOutOfBoundsException/外层try-catch");
		}
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">执行结果：</p> 
   <pre class="code">ArrayIndexOutOfBoundsException/内层try-catch 
发生ArithmeticException?</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在这个程序中，ArrayIndexOutOfBoundsException由内层try-catch丢出并捕捉，由于内层 已经捕捉了例外，所以外层的try-catch中之ArrayIndexOutOfBoundsException并不会捕捉到内层所丢出的例外，但如果 内层的try-catch并没有捕捉到这个例外，则外层try-catch就有机会捕捉这个例外，例如：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseThrow.java</h5> 
   <pre class="code">public class UseThrow {
	public static void main(String[] args) {
		try {
			try {
				throw new ArrayIndexOutOfBoundsException();
			}
			catch(ArithmeticException e) {
				System.out.println(
				"ArrayIndexOutOfBoundsException/内层try-catch");
			}
			throw new ArithmeticException();
		}
		catch(ArithmeticException e) {
			System.out.println("发生ArithmeticException");
		}
		catch(ArrayIndexOutOfBoundsException e) {
			System.out.println(
			"ArrayIndexOutOfBoundsException/外层try-catch");
		}
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">执行结果：</p> 
   <pre class="code">ArrayIndexOutOfBoundsException/外层try-catch</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);">程序中会订定许多方法（Method），这些方法中可能会因某些错误而引发例外，但您不希望直接在这个方法中处理这些例外，而希望呼叫这个它的方法来统一处理，这时候您可以使用"throws"关键词来宣告这个方法将会丢出例外</span>，例如：</p> 
   <pre class="code">private void arrayMethod(int[] arr)
			throws ArrayIndexOutOfBoundsException,ArithmeticException {
	// 实作
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;注意如果会丢出多种可能的例外时，中间使用逗点分隔；当有方法上使用"throws"宣告例外时，意味着呼叫该方法的呼叫者必须处理这些例外，而被呼叫方法可以保持程序逻辑的简洁，下面这个范例是"throws"的一个简单示范：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">UseThrows.java</h5> 
   <pre class="code">public class UseThrows {
	public static void main(String[] args) {
		try {
			throwsTest();
		}
		catch(ArithmeticException e) {
			System.out.println("捕捉例外");
		}
	}
	private static void throwsTest()
	throws ArithmeticException {
		System.out.println("这只是一个测试");
		// 程序处理过程假设发生例外
		throw new ArithmeticException();
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">执行结果：</p> 
   <pre class="code">这只是一个测试
捕捉例外</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">简单的说，您要不就在方法中直接处理例外，要不就在方法上宣告该方法会丢回例外，由呼叫它的呼叫者来处理例外，另一方面，在方法上使用 "throws"宣告可丢出的例外，也表示了您只能丢出所宣告类型的例外，其它的例外您必须在方法中处理完，或是重新包装为所宣告的例外再丢出。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">如果使用继承时，在父类别的某个方法上宣告了throws某些例外，而在子类别中重新定义该方法时，您可以：</p> 
   <ul style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style-type:disc;">不处理例外（重新定义时不设定throws）</li> 
    <li style="list-style-type:disc;">可仅throws父类别中被重新定义的方法上之某些例外</li> 
    <li style="list-style-type:disc;">可throws被重新定义的方法上之例外之子类别</li> 
   </ul>
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">但是您不可以：</p> 
   <ul style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">
    <li style="list-style-type:disc;">throws出额外的例外</li> 
    <li style="list-style-type:disc;">throws被重新定义的方法上之例外之父类别</li> 
   </ul>
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">51、断言（Assertion）</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">例外是程序中非预期的错误，例外处理是在这些错误发生时所采取的措施。<br><br> 有些时候，您预期程序中应该会处于何种状态，例如某些情况下某个值必然是多少，这称之为一种断言（Assertion），断言有两种情况：成立或不成立。当预期结果与实际执行相同时，断言成立，否则断言失败。<br><br> Java在JDK 1.4之后提供断言陈述，有两种使用的语法：</p> 
   <pre class="code">assert &lt;BOOLEAN_EXPRESSION&gt;;
assert &lt;BOOLEAN_EXPRESSION&gt; : &lt;DETAIL_EXPRESSION&gt;;</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">boolean_expression如果为true，则什么事都不会发生，如果为false，则会发生 java.lang.AssertionError，此时若采取的是第二个语法，则会将detail_expression的结果显示出来，如果是个物 件，则呼叫它的toString()显示文字描述结果。<br><br><span style="color:rgb(255,0,0);">一个使用断言的时机是内部不变量（Internal invarant）的判断，例如在某个时间点上，或某个状况发生时，您判断某个变量必然要是某个值</span>，举个例子来说：</p> 
   <h5 style="font-size:12px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">AssertionDemo.java</h5> 
   <pre class="code">public class AssertionDemo {
	public static void main(String[] args) {
		if(args.length &gt; 0) {
			System.out.println(args[0]);
		}
		else {
			assert args.length == 0;
			System.out.println("没有输入自变量");
		}
	}
}</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">在正常的预期中，数组长度是不会小于0的，所以一但执行至else区块，数组长度必然只有一个可能，就是等于0，您断言args.length==0结果 必然成立，else之中的程序代码也只有在断言成立的状况下才能执行，如果不成立，表示程序运行存在错误，else区块不应被执行，您要停下来检查程序的错 误，事实上断言主要的目的通常是在开发时期才使用。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">另一个使用断言的时机为控制流程不变量（Control flow invariant）的判断，例如在使用switch时，假设您已经列出了所有的可能常数：</p> 
   <pre class="code">...
switch(var) {
	case Constants.Con1:
	...
	break;
	case Constants.Con2:
	...
	break;
	case Constants.Con3:
	...
	break;
	default:
	assert false : "非定义的常数";
}
...</pre> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设您已经在switch中列出了所有的常数，即var不该出现Constants.Con1、Constants.Con2、 Constants.Con3以外的常数，则如果发生default被执行的情况，表示程序的状态与预期不符，此时由于assert false必然断言失败。<br><br> 总结就是，<span style="color:rgb(255,0,0);">断言是判定程序中的某个执行点必然是某个状态，所以它不能当作像if之类的判断式使用，简单的说它不应是程序执行流程的一部份</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">本文转自ZH奶酪博客园博客，原文链接：http://www.cnblogs.com/CheeseZH/archive/2012/11/24/2785628.html，如需转载请自行联系原作者</p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
