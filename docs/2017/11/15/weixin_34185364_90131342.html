<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Java并发集合的实现原理 « NotBeCN</title>
  <meta name="description" content="             本文简要介绍Java并发编程方面常用的类和集合，并介绍下其实现原理。    AtomicInteger    可以用原子方式更新int值。类&nbsp;AtomicBoolean、AtomicInteger、AtomicLong&nbsp;和&nbsp;AtomicReference&n...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/15/weixin_34185364_90131342.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Java并发集合的实现原理</h1>
    <p class="post-meta">Nov 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">本文简要介绍Java并发编程方面常用的类和集合，并介绍下其实现原理。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>AtomicInteger</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">可以用原子方式更新<code>int</code>值。类&nbsp;<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>&nbsp;和&nbsp;<code>AtomicReference</code>&nbsp;的实例各自提供对相应类型单个变量的访问和更新。基本的原理都是使用CAS操作：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> compareAndSet(expectedValue, updateValue);</pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">如果此方法（在不同的类间参数类型也不同）当前保持expectedValue，则以原子方式将变量设置为updateValue，并在成功时报告true。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">循环CAS，参考AtomicInteger中的实现：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> getAndIncrement() {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span><span style="font-size:12px;line-height:1.5;"> (;;) {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> current =<span style="font-size:12px;line-height:1.5;"> get();
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> next = current + 1<span style="font-size:12px;line-height:1.5;">;
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span><span style="font-size:12px;line-height:1.5;"> (compareAndSet(current, next))
                </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> current;
        }
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> compareAndSet(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> expect, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> update) {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> unsafe.compareAndSwapInt(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">, valueOffset, expect, update);
    }</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ABA问题</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<br> 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span><span style="font-size:12px;line-height:1.5;"> compareAndSet(
        V      expectedReference,</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">预期引用</span>
        V      newReference,<span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">更新后的引用</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>    expectedStamp, <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">预期标志</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>    newStamp) <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">更新后的标志</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>ArrayBlockingQueue</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部是在队列中存在时间最长的元素。队列的尾部是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性(fairness)设置为true而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">一些源代码参考：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Main lock guarding all access </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span><span style="font-size:12px;line-height:1.5;"> ReentrantLock lock;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> put(E e) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> InterruptedException {
        checkNotNull(e);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock lock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.lock;
        lock.lockInterruptibly();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">try</span><span style="font-size:12px;line-height:1.5;"> {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span> (count ==<span style="font-size:12px;line-height:1.5;"> items.length)
                notFull.await();
            insert(e);
        } </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">finally</span><span style="font-size:12px;line-height:1.5;"> {
            lock.unlock();
        }
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span><span style="font-size:12px;line-height:1.5;"> insert(E x) {
        items[putIndex] </span>=<span style="font-size:12px;line-height:1.5;"> x;
        putIndex </span>=<span style="font-size:12px;line-height:1.5;"> inc(putIndex);
        </span>++<span style="font-size:12px;line-height:1.5;">count;
        notEmpty.signal();
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> inc(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i) {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> (++i == items.length) ? 0<span style="font-size:12px;line-height:1.5;"> : i;
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> E take() <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> InterruptedException {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock lock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.lock;
        lock.lockInterruptibly();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">try</span><span style="font-size:12px;line-height:1.5;"> {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span> (count == 0<span style="font-size:12px;line-height:1.5;">)
                notEmpty.await();
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> extract();
        } </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">finally</span><span style="font-size:12px;line-height:1.5;"> {
            lock.unlock();
        }
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span><span style="font-size:12px;line-height:1.5;"> E extract() {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> Object[] items = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.items;
        E x </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span>.&lt;E&gt;<span style="font-size:12px;line-height:1.5;">cast(items[takeIndex]);
        items[takeIndex] </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">null</span><span style="font-size:12px;line-height:1.5;">;
        takeIndex </span>=<span style="font-size:12px;line-height:1.5;"> inc(takeIndex);
        </span>--<span style="font-size:12px;line-height:1.5;">count;
        notFull.signal();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> x;
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> dec(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> i) {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> ((i == 0) ? items.length : i) - 1<span style="font-size:12px;line-height:1.5;">;
    }

    @SuppressWarnings(</span>"unchecked"<span style="font-size:12px;line-height:1.5;">)
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span> &lt;E&gt;<span style="font-size:12px;line-height:1.5;"> E cast(Object item) {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> (E) item;
    }</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ArrayBlockingQueue只使用了一个lock来控制互斥访问，所有的互斥访问都在这个lock的try finally中实现。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>LinkedBlockingQueue</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">一个基于已链接节点的、范围任意的blocking queue。此队列按 FIFO（先进先出）排序元素。队列的头部是在队列中时间最长的元素。队列的尾部是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。如果未指定容量，则它等于Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">一些实现代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>    <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> The capacity bound, or Integer.MAX_VALUE if none </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> capacity;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Current number of elements </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> AtomicInteger count = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> AtomicInteger(0<span style="font-size:12px;line-height:1.5;">);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Lock held by take, poll, etc </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock takeLock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> ReentrantLock();

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Wait queue for waiting takes </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> Condition notEmpty =<span style="font-size:12px;line-height:1.5;"> takeLock.newCondition();

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Lock held by put, offer, etc </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock putLock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> ReentrantLock();

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/**</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Wait queue for waiting puts </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> Condition notFull =<span style="font-size:12px;line-height:1.5;"> putLock.newCondition();

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> put(E e) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> InterruptedException {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (e == <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">null</span>) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throw</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> NullPointerException();
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Note: convention in all put/take/etc is to preset local var
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> holding count negative to indicate failure unless set.</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> c = -1<span style="font-size:12px;line-height:1.5;">;
        Node</span>&lt;E&gt; node = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> Node(e);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock putLock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.putLock;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> AtomicInteger count = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.count;
        putLock.lockInterruptibly();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">try</span><span style="font-size:12px;line-height:1.5;"> {
            </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">/*</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">
             * Note that count is used in wait guard even though it is
             * not protected by lock. This works because count can
             * only decrease at this point (all other puts are shut
             * out by lock), and we (or some other waiting put) are
             * signalled if it ever changes from capacity. Similarly
             * for all other uses of count in other wait guards.
             </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">*/</span>
            <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span> (count.get() ==<span style="font-size:12px;line-height:1.5;"> capacity) {
                notFull.await();
            }
            enqueue(node);
            c </span>=<span style="font-size:12px;line-height:1.5;"> count.getAndIncrement();
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (c + 1 &lt;<span style="font-size:12px;line-height:1.5;"> capacity)
                notFull.signal();
        } </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">finally</span><span style="font-size:12px;line-height:1.5;"> {
            putLock.unlock();
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (c == 0<span style="font-size:12px;line-height:1.5;">)
            signalNotEmpty();
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> E take() <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> InterruptedException {
        E x;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> c = -1<span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> AtomicInteger count = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.count;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock takeLock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.takeLock;
        takeLock.lockInterruptibly();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">try</span><span style="font-size:12px;line-height:1.5;"> {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span> (count.get() == 0<span style="font-size:12px;line-height:1.5;">) {
                notEmpty.await();
            }
            x </span>=<span style="font-size:12px;line-height:1.5;"> dequeue();
            c </span>=<span style="font-size:12px;line-height:1.5;"> count.getAndDecrement();
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (c &gt; 1<span style="font-size:12px;line-height:1.5;">)
                notEmpty.signal();
        } </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">finally</span><span style="font-size:12px;line-height:1.5;"> {
            takeLock.unlock();
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (c ==<span style="font-size:12px;line-height:1.5;"> capacity)
            signalNotFull();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> x;
    }</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">从源代码实现来看，LinkedBlockingQueue使用了2个lock，一个takelock和一个putlock，读和写用不同的lock来控制，这样并发效率更高。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>ConcurrentLinkedQueue</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ArrayBlockingQueue和LinkedBlockingQueue都是使用lock来实现的，也就是阻塞式的队列，而ConcurrentLinkedQueue使用CAS来实现，是非阻塞式的“lock-free”实现。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentLinkedQueue源代码的实现有点复杂，具体的可看这篇文章的分析：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" rel="nofollow" style="color:rgb(0,0,0);">http://www.infoq.com/cn/articles/ConcurrentLinkedQueue</a></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>ConcurrentHashMap</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">HashMap不是线程安全的。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">HashTable容器使用synchronized来保证线程安全，在线程竞争激烈的情况下HashTable的效率非常低下。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentHashMap采用了Segment分段技术，容器里有多把锁，每把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentHashMap结构：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><img src="https://images0.cnblogs.com/blog2015/434101/201507/111510488468226.jpg" alt="" style="border:none;"></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentHashMap的实现原理分析：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" rel="nofollow" style="color:rgb(0,0,0);">http://www.infoq.com/cn/articles/ConcurrentHashMap</a></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> hash(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> h) {
        h </span>+= (h &lt;&lt; 15) ^ 0xffffcd7d<span style="font-size:12px;line-height:1.5;">;
        h </span>^= (h &gt;&gt;&gt; 10<span style="font-size:12px;line-height:1.5;">);
        h </span>+= (h &lt;&lt; 3<span style="font-size:12px;line-height:1.5;">);
        h </span>^= (h &gt;&gt;&gt; 6<span style="font-size:12px;line-height:1.5;">);
        h </span>+= (h &lt;&lt; 2) + (h &lt;&lt; 14<span style="font-size:12px;line-height:1.5;">);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> h ^ (h &gt;&gt;&gt; 16<span style="font-size:12px;line-height:1.5;">);
    }</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentHashMap的get操作：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span><span style="font-size:12px;line-height:1.5;"> V get(Object key) {
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> hash =<span style="font-size:12px;line-height:1.5;"> hash(key.hashCode());
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> segmentFor(hash).get(key, hash);
}</span></pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">transient</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">volatile</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> count;
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">volatile</span> V value;</pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre>hash &gt;&gt;&gt; segmentShift) &amp; segmentMask <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">定位Segment所使用的hash算法</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> index = hash &amp; (tab.length - 1); <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 定位HashEntry所使用的hash算法</span></pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentHashMap的put操作：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ConcurrentHashMap的size操作：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>CopyOnWriteArrayList</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。类似的有CopyOnWriteArraySet。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span><span style="font-size:12px;line-height:1.5;"> add(T e) {
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> ReentrantLock lock = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">this</span><span style="font-size:12px;line-height:1.5;">.lock;
    lock.lock();
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">try</span><span style="font-size:12px;line-height:1.5;"> {
        Object[] elements </span>=<span style="font-size:12px;line-height:1.5;"> getArray();
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> len =<span style="font-size:12px;line-height:1.5;"> elements.length;
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 复制出新数组</span>
        Object[] newElements = Arrays.copyOf(elements, len + 1<span style="font-size:12px;line-height:1.5;">);
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 把新元素添加到新数组里</span>
        newElements[len] =<span style="font-size:12px;line-height:1.5;"> e;
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 把原数组引用指向新数组</span>
<span style="font-size:12px;line-height:1.5;">        setArray(newElements);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
    } </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">finally</span><span style="font-size:12px;line-height:1.5;"> {
        lock.unlock();
    }
}
 
</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span><span style="font-size:12px;line-height:1.5;"> setArray(Object[] a) {
    array </span>=<span style="font-size:12px;line-height:1.5;"> a;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> E get(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> index) {
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> get(getArray(), index);
}</span></pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>AbstractQueuedSynchronizer&nbsp;</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。子类必须定义更改此状态的受保护方法，并定义哪种状态对于此对象意味着被获取或被释放。假定这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。子类可以维护其他状态字段，但只是为了获得同步而只追踪使用 getState()、setState(int) 和 compareAndSetState(int, int) 方法来操作以原子方式更新的 int 值。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">使用示例<br> 以下是一个非再进入的互斥锁类，它使用值 0 表示未锁定状态，使用 1 表示锁定状态。当非重入锁定不严格地需要当前拥有者线程的记录时，此类使得使用监视器更加方便。它还支持一些条件并公开了一个检测方法：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span> Mutex <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">implements</span><span style="font-size:12px;line-height:1.5;"> Lock, java.io.Serializable {

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Our internal helper class</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">class</span> Sync <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">extends</span><span style="font-size:12px;line-height:1.5;"> AbstractQueuedSynchronizer {
      </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Report whether in locked state</span>
      <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">protected</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span><span style="font-size:12px;line-height:1.5;"> isHeldExclusively() { 
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> getState() == 1<span style="font-size:12px;line-height:1.5;">; 
      }

      </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Acquire the lock if state is zero</span>
      <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> tryAcquire(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> acquires) {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">assert</span> acquires == 1; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Otherwise unused</span>
       <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (compareAndSetState(0, 1<span style="font-size:12px;line-height:1.5;">)) {
         setExclusiveOwnerThread(Thread.currentThread());
         </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
       }
       </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;
      }

      </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Release the lock by setting state to zero</span>
      <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">protected</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> tryRelease(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> releases) {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">assert</span> releases == 1; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Otherwise unused</span>
        <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (getState() == 0) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throw</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> IllegalMonitorStateException();
        setExclusiveOwnerThread(</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">null</span><span style="font-size:12px;line-height:1.5;">);
        setState(</span>0<span style="font-size:12px;line-height:1.5;">);
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
      }
       
      </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Provide a Condition</span>
      Condition newCondition() { <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> ConditionObject(); }

      </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Deserialize properly</span>
      <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span><span style="font-size:12px;line-height:1.5;"> readObject(ObjectInputStream s) 
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> IOException, ClassNotFoundException {
        s.defaultReadObject();
        setState(</span>0); <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> reset to unlocked state</span>
<span style="font-size:12px;line-height:1.5;">      }
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> The sync object does all the hard work. We just forward to it.</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">private</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">final</span> Sync sync = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> Sync();

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> lock()                { sync.acquire(1<span style="font-size:12px;line-height:1.5;">); }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> tryLock()          { <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> sync.tryAcquire(1<span style="font-size:12px;line-height:1.5;">); }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> unlock()              { sync.release(1<span style="font-size:12px;line-height:1.5;">); }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> Condition newCondition()   { <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> sync.newCondition(); }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> isLocked()         { <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> sync.isHeldExclusively(); }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> hasQueuedThreads() { <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> sync.hasQueuedThreads(); }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> lockInterruptibly() <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> InterruptedException { 
      sync.acquireInterruptibly(</span>1<span style="font-size:12px;line-height:1.5;">);
    }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">boolean</span> tryLock(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">long</span><span style="font-size:12px;line-height:1.5;"> timeout, TimeUnit unit) 
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">throws</span><span style="font-size:12px;line-height:1.5;"> InterruptedException {
      </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> sync.tryAcquireNanos(1<span style="font-size:12px;line-height:1.5;">, unit.toNanos(timeout));
    }
 }</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><strong>ThreadPoolExecutor</strong></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ThreadPoolExecutor&nbsp;的内部工作原理，整个思路总结起来就是&nbsp;5&nbsp;句话：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">1.&nbsp;&nbsp;如果当前池大小&nbsp;poolSize&nbsp;小于&nbsp;corePoolSize&nbsp;，则创建新线程执行任务。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">2.&nbsp;&nbsp;如果当前池大小&nbsp;poolSize&nbsp;大于&nbsp;corePoolSize&nbsp;，且等待队列未满，则进入等待队列</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">3.&nbsp;&nbsp;如果当前池大小&nbsp;poolSize&nbsp;大于&nbsp;corePoolSize&nbsp;且小于&nbsp;maximumPoolSize&nbsp;，且等待队列已满，则创建新线程执行任务。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">4.&nbsp;&nbsp;如果当前池大小&nbsp;poolSize&nbsp;大于&nbsp;corePoolSize&nbsp;且大于&nbsp;maximumPoolSize&nbsp;，且等待队列已满，则调用拒绝策略来处理该任务。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">5.&nbsp;&nbsp;线程池里的每个线程执行完任务后不会立刻退出，而是会去检查下等待队列里是否还有线程任务需要执行，如果在&nbsp;keepAliveTime&nbsp;里等不到新的任务了，那么线程就会退出。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">排队有三种通用策略：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">直接提交。工作队列的默认选项是SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">无界队列。使用无界队列（例如，不具有预定义容量的LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ThreadFactory&nbsp;和&nbsp;RejectedExecutionHandler是ThreadPoolExecutor的两个属性，也&nbsp;可以认为是两个简单的扩展点.&nbsp;ThreadFactory&nbsp;是创建线程的工厂。默认的线程工厂会创建一个带有“&nbsp;pool-poolNumber-thread-threadNumber&nbsp;”为名字的线程，如果我们有特别的需要，如线程组命名、优先级等，可以定制自己的ThreadFactory&nbsp;。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">RejectedExecutionHandler&nbsp;是拒绝的策略。常见有以下几种：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">AbortPolicy&nbsp;：不执行，会抛出&nbsp;RejectedExecutionException&nbsp;异常。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">CallerRunsPolicy&nbsp;：由调用者（调用线程池的主线程）执行。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">DiscardOldestPolicy&nbsp;：抛弃等待队列中最老的。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">DiscardPolicy:&nbsp;不做任何处理，即抛弃当前任务。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ScheduleThreadPoolExecutor&nbsp;是对ThreadPoolExecutor的集成。增加了定时触发线程任务的功能。需要注意从内部实现看，ScheduleThreadPoolExecutor&nbsp;使用的是&nbsp;&nbsp;corePoolSize&nbsp;&nbsp;线程和一个无界队列的固定大小的池，所以调整&nbsp;maximumPoolSize&nbsp;&nbsp;没有效果。无界队列是一个内部自定义的&nbsp;DelayedWorkQueue&nbsp;。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">FixedThreadPool</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span> ExecutorService newFixedThreadPool(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> nThreads) {  
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> ThreadPoolExecutor(nThreads, nThreads,  
                                  </span>0L<span style="font-size:12px;line-height:1.5;">, TimeUnit.MILLISECONDS,  
                                  </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> LinkedBlockingQueue&lt;Runnable&gt;<span style="font-size:12px;line-height:1.5;">());  
}  </span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">实际上就是个不支持keepalivetime，且corePoolSize和maximumPoolSize相等的线程池。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">SingleThreadExecutor</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span><span style="font-size:12px;line-height:1.5;"> ExecutorService newSingleThreadExecutor() {  
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> FinalizableDelegatedExecutorService  
        (</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> ThreadPoolExecutor(1, 1<span style="font-size:12px;line-height:1.5;">,  
                                </span>0L<span style="font-size:12px;line-height:1.5;">, TimeUnit.MILLISECONDS,  
                                </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> LinkedBlockingQueue&lt;Runnable&gt;<span style="font-size:12px;line-height:1.5;">()));  
}  </span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">实际上就是个不支持keepalivetime，且corePoolSize和maximumPoolSize都等1的线程池。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">CachedThreadPool</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span><span style="font-size:12px;line-height:1.5;"> ExecutorService newCachedThreadPool() {  
      </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> ThreadPoolExecutor(0<span style="font-size:12px;line-height:1.5;">, Integer.MAX_VALUE, 
                                  </span>60L<span style="font-size:12px;line-height:1.5;">, TimeUnit.SECONDS,  
                                  </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> SynchronousQueue&lt;Runnable&gt;<span style="font-size:12px;line-height:1.5;">());  
}  </span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">实际上就是个支持keepalivetime时间是60秒（线程空闲存活时间），且corePoolSize为0，maximumPoolSize无穷大的线程池。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">SingleThreadScheduledExecutor</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span><span style="font-size:12px;line-height:1.5;"> ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {  
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> DelegatedScheduledExecutorService  
        (</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> ScheduledThreadPoolExecutor(1<span style="font-size:12px;line-height:1.5;">, threadFactory));  
}  </span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">实际上是个corePoolSize为1的ScheduledExecutor。上文说过ScheduledExecutor采用无界等待队列，所以maximumPoolSize没有作用。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">ScheduledThreadPool</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';">
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">public</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">static</span> ScheduledExecutorService newScheduledThreadPool(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> corePoolSize) {  
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> ScheduledThreadPoolExecutor(corePoolSize);  
}  </span></pre>
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">实际上是corePoolSize课设定的ScheduledExecutor。上文说过ScheduledExecutor采用无界等待队列，所以maximumPoolSize没有作用。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">参考：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">《java并发编程的艺术》</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p><font color="#333333"><span style="font-size:15px;">&nbsp; &nbsp; 本文转自阿凡卢博客园博客，原文链接：http://www.cnblogs.com/luxiaoxun/p/4638748.html</span></font><span style="font-size:15px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <div>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
