<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>理解 JavaScript 闭包 « NotBeCN</title>
  <meta name="description" content="             要成为高级 JavaScript 程序员，就必须理解闭包。    本文结合 ECMA 262 规范详解了闭包的内部工作机制，让 JavaScript 编程人员对闭包的理解从“嵌套的函数”深入到“标识符解析、执行环境和作用域链”等等 JavaScript 对象背后的运行机制当中，真正领会到...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/15/weixin_33734785_90128910.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">理解 JavaScript 闭包</h1>
    <p class="post-meta">Nov 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">要成为高级 JavaScript 程序员，就必须理解闭包。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">本文结合 ECMA 262 规范详解了闭包的内部工作机制，让 JavaScript 编程人员对闭包的理解从“嵌套的函数”深入到“标识符解析、执行环境和作用域链”等等 JavaScript 对象背后的运行机制当中，真正领会到闭包的实质。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">原文链接：<a title="javascript closures" href="http://www.jibbering.com/faq/faq_notes/closures.html" rel="nofollow" style="color:#0000FF;text-decoration:none;">JavaScript Closures</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">可打印版：<a title="JavaScript 闭包－－打印版" href="http://www.cn-cuckoo.com/wordpress/wp-content/uploads/2007/08/JavaScriptClosures.html" rel="nofollow" style="color:#0000FF;text-decoration:none;">JavaScript 闭包</a></p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;">目录</h2> 
   <ul style="color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;line-height:32px;">
    <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clIntro" rel="nofollow" style="color:#0000FF;text-decoration:none;">简介</a></li> 
    <li style="list-style:disc;"> <a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clResO" rel="nofollow" style="color:#0000FF;text-decoration:none;">对象属性名解析</a> 
     <ul>
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clResA" rel="nofollow" style="color:#0000FF;text-decoration:none;">值的赋予</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clResR" rel="nofollow" style="color:#0000FF;text-decoration:none;">值的读取</a></li> 
     </ul></li> 
    <li style="list-style:disc;"> <a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clIRExSc" rel="nofollow" style="color:#0000FF;text-decoration:none;">标识符解析、执行环境和作用域链</a> 
     <ul>
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clExCon" rel="nofollow" style="color:#0000FF;text-decoration:none;">执行环境</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clScCh" rel="nofollow" style="color:#0000FF;text-decoration:none;">作用域链与 [[scope]]</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clIdRes" rel="nofollow" style="color:#0000FF;text-decoration:none;">标识符解析</a></li> 
     </ul></li> 
    <li style="list-style:disc;"> <a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clClose" rel="nofollow" style="color:#0000FF;text-decoration:none;">闭包</a> 
     <ul>
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clAtGb" rel="nofollow" style="color:#0000FF;text-decoration:none;">自动垃圾收集</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clFrmC" rel="nofollow" style="color:#0000FF;text-decoration:none;">构成闭包</a></li> 
     </ul></li> 
    <li style="list-style:disc;"> <a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clClDo" rel="nofollow" style="color:#0000FF;text-decoration:none;">通过闭包可以做什么？</a> 
     <ul>
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clSto" rel="nofollow" style="color:#0000FF;text-decoration:none;">例 1：为函数引用设置延时</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clObjI" rel="nofollow" style="color:#0000FF;text-decoration:none;">例 2：通过对象实例方法关联函数</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clEncap" rel="nofollow" style="color:#0000FF;text-decoration:none;">例 3：包装相关的功能</a></li> 
      <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clOtE" rel="nofollow" style="color:#0000FF;text-decoration:none;">其他例子</a></li> 
     </ul></li> 
    <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clAc" rel="nofollow" style="color:#0000FF;text-decoration:none;">意外的闭包</a></li> 
    <li style="list-style:disc;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clMem" rel="nofollow" style="color:#0000FF;text-decoration:none;">Internet Explorer 的内存泄漏问题</a></li> 
   </ul>
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clIntro" title="clIntro" name="clIntro" style="color:#0000FF;"></a>简介</h2> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <blockquote style="border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;background:rgb(255,255,255) url(&quot;images/comment.gif&quot;) no-repeat 25px 0px;">
    <dl>
     <dt> 
      <a id="clDefN" title="clDefN" name="clDefN" style="color:#0000FF;"></a>Closure
     </dt> 
     <dd style="text-decoration:line-through;">
      所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。
     </dd> 
     <dd>
      “闭包”是一个表达式（一般是函数），它具有自由变量以及绑定这些变量的环境（该环境“封闭了”这个表达式）。
     </dd> 
     <dd>
      （闭包，就是封闭了外部函数作用域中变量的内部函数。但是，如果外部函数不返回这个内部函数，闭包的特性无法显现。如果外部函数返回这个内部函 数，那么返回的内部函数就成了名副其实的闭包。此时，闭包封闭的外部变量就是自由变量，而由于该自由变量存在，外部函数即便返回，其占用的内存也得不到释 放。——译者注，2010年4月3日）
     </dd> 
    </dl>
   </blockquote> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">闭包是 ECMAScript （JavaScript）最强大的特性之一，但用好闭包的前提是必须理解闭包。闭包的创建相对容易，人们甚至会在不经意间创建闭包，但这些无意创建的闭包 却存在潜在的危害，尤其是在比较常见的浏览器环境下。如果想要扬长避短地使用闭包这一特性，则必须了解它们的工作机制。而闭包工作机制的实现很大程度上有 赖于标识符（或者说对象属性）解析过程中作用域的角色。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">关于闭包，最简单的描述就是 ECMAScript 允许使用内部函数－－即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明 的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。也就是说，内部函数会在外部函数返回后被执行。而当这个内部 函数执行时，它仍然必需访问其外部函数的局部变量、参数以及其他内部函数。这些局部变量、参数和函数声明（最初时）的值是外部函数返回时的值，但也会受到 内部函数的影响。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">遗憾的是，要适当地理解闭包就必须理解闭包背后运行的机制，以及许多相关的技术细节。虽然本文的前半部分并没有涉及 ECMA 262 规范指定的某些算法，但仍然有许多无法回避或简化的内容。对于个别熟悉对象属性名解析的人来说，可以跳过相关的内容，但是除非你对闭包也非常熟悉，否则最 好是不要跳下面几节。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clResO" title="clResO" name="clResO" style="color:#0000FF;"></a>对象属性名解析</h2> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">ECMAScript 认可两类对象：原生（Native）对象和宿主（Host）对象，其中宿主对象包含一个被称为内置对象的原生对象的子类（ECMA 262 3rd Ed Section 4.3）。原生对象属于语言，而宿主对象由环境提供，比如说可能是文档对象、DOM 等类似的对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">原生对象具有松散和动态的命名属性（对于某些实现的内置对象子类别而言，动态性是受限的－－但这不是太大的问题）。对象的命名属性用于保存值，该值 可以是指向另一个对象（Objects）的引用（在这个意义上说，函数也是对象），也可以是一些基本的数据类型，比如：String、Number、 Boolean、Null&nbsp;或 Undefined。其中比较特殊的是 Undefined 类型，因为可以给对象的属性指定一个 Undefined 类型的值，而不会删除对象的相应属性。而且，该属性只是保存着&nbsp;<span style="font-family:'Courier New';">undefined&nbsp;</span>值。&nbsp;<code style="color:rgb(44,62,80);"></code></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">下面简要介绍一下如何设置和读取对象的属性值，并最大程度地体现相应的内部细节。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clResA" title="clResA" name="clResA" style="color:#0000FF;"></a>值的赋予</h3> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">对象的命名属性可以通过为该命名属性赋值来创建，或重新赋值。即，对于：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var objectRef = new Object(); //创建一个普通的 JavaScript 对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">可以通过下面语句来创建名为 “testNumber” 的属性：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">objectRef.testNumber = 5;<br> /* – 或- */<br> objectRef["testNumber"] = 5;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">在赋值之前，对象中没有“testNumber” 属性，但在赋值后，则创建一个属性。之后的任何赋值语句都不需要再创建这个属性，而只会重新设置它的值：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">objectRef.testNumber = 8;<br> /* – or:- */<br> objectRef["testNumber"] = 8;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">稍后我们会介绍，Javascript 对象都有原型（prototypes）属性，而这些原型本身也是对象，因而也可以带有命名的属性。但是，原型对象命名属性的作用并不体现在赋值阶段。同 样，在将值赋给其命名属性时，如果对象没有该属性则会创建该命名属性，否则会重设该属性的值。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clResR" title="clResR" name="clResR" style="color:#0000FF;"></a>值的读取</h3> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">当读取对象的属性值时，原型对象的作用便体现出来。如果对象的原型中包含属性访问器（property accessor）所使用的属性名，那么该属性的值就会返回：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">/* 为命名属性赋值。如果在赋值前对象没有相应的属性，那么赋值后就会得到一个：*/<br> objectRef.testNumber = 8;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">/* 从属性中读取值 */<br> var val = objectRef.testNumber;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">/* 现在， – val – 中保存着刚赋给对象命名属性的值 8*/</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">而且，由于所有对象都有原型，而原型本身也是对象，所以原型也可能有原型，这样就构成了所谓的原型链。原型链终止于链中原型为 null 的对象。<code style="color:rgb(44,62,80);">Object</code>&nbsp;构造函数的默认原型就有一个 null 原型，因此：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var objectRef = new Object(); //创建一个普通的 JavaScript 对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">创建了一个原型为&nbsp;<code style="color:rgb(44,62,80);">Object.prototype</code>&nbsp;的对象，而该原型自身则拥有一个值为 null 的原型。也就是说，<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;的原型链中只包含一个对象－－&nbsp;<code style="color:rgb(44,62,80);">Object.prototype</code>。但对于下面的代码而言：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">/* 创建 – MyObject1 – 类型对象的函数*/<br> function MyObject1(formalParameter){<br> /* 给创建的对象添加一个名为 – testNumber – 的属性<br> 并将传递给构造函数的第一个参数指定为该属性的值：*/<br> this.testNumber = formalParameter;<br> }<br> /* 创建 – MyObject2 – 类型对象的函数*/<br> function MyObject2(formalParameter){<br> /* 给创建的对象添加一个名为 – testString – 的属性<br> 并将传递给构造函数的第一个参数指定为该属性的值：*/<br> this.testString = formalParameter;<br> }</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">/* 接下来的操作用 MyObject1 类的实例替换了所有与 MyObject2 类的实例相关联的原型。而且，为 MyObject1 构造函数传递了参数 – 8 – ，因而其 – testNumber – 属性被赋予该值：*/<br> MyObject2.prototype = new MyObject1( 8 );</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">/* 最后，将一个字符串作为构造函数的第一个参数，创建一个 – MyObject2 – 的实例，并将指向该对象的引用赋给变量 – objectRef – ：*/<br> var objectRef = new MyObject2( “String_Value” );</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">被变量&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;所引用的&nbsp;<code style="color:rgb(44,62,80);">MyObject2</code>&nbsp;的实例拥有一个原型链。该链中的第一个对象是在创建后被指定给<code style="color:rgb(44,62,80);">MyObject2</code>&nbsp;构造函数的&nbsp;<code style="color:rgb(44,62,80);">prototype</code>&nbsp;属性的&nbsp;<code style="color:rgb(44,62,80);">MyObject1</code>&nbsp;的一个实例。<code style="color:rgb(44,62,80);">MyObject1</code>&nbsp;的实例也有一个原型，即与<code style="color:rgb(44,62,80);">Object.prototype</code>&nbsp;所引用的对象对应的默认的 Object 对象的原型。最后，&nbsp;<code style="color:rgb(44,62,80);">Object.prototype</code>&nbsp;有一个值为 null 的原型，因此这条原型链到此结束。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">当某个属性访问器尝试读取由&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;所引用的对象的属性值时，整个原型链都会被搜索。在下面这种简单的情况下：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var val = objectRef.testString;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">因为&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;所引用的&nbsp;<code style="color:rgb(44,62,80);">MyObject2</code>&nbsp;的实例有一个名为“testString”的属性，因此被设置为“String_Value”的该属性的值被赋给了变量&nbsp;<code style="color:rgb(44,62,80);">val</code>。但是：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var val = objectRef.testNumber;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">则不能从&nbsp;<code style="color:rgb(44,62,80);">MyObject2</code>&nbsp;实例自身中读取到相应的命名属性值，因为该实例没有这个属性。然而，变量&nbsp;<code style="color:rgb(44,62,80);">val</code>&nbsp;的值仍然被设置为&nbsp;<code style="color:rgb(44,62,80);">8</code>，而不是未定义－－这是因为在该实例中查找相应的命名属性失败后，解释程序会继续检查其原型对象。而该实例的原型对象是&nbsp;<code style="color:rgb(44,62,80);">MyObject1</code>&nbsp;的实例，这个实例有一个名为“testNumber”的属性并且值为&nbsp;<code style="color:rgb(44,62,80);">8</code>，所以这个属性访问器最后会取得值&nbsp;<code style="color:rgb(44,62,80);">8</code>。而且，虽然&nbsp;<code style="color:rgb(44,62,80);">MyObject1</code>&nbsp;和&nbsp;<code style="color:rgb(44,62,80);">MyObject2</code>&nbsp;都没有定义&nbsp;<code style="color:rgb(44,62,80);">toString</code>&nbsp;方法，但是当属性访问器通过&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;读取&nbsp;<code style="color:rgb(44,62,80);">toString</code>&nbsp;属性的值时：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var val = objectRef.toString;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">变量&nbsp;<code style="color:rgb(44,62,80);">val</code>&nbsp;也会被赋予一个函数的引用。这个函数就是在&nbsp;<code style="color:rgb(44,62,80);">Object.prototype</code>&nbsp;的&nbsp;<code style="color:rgb(44,62,80);">toString</code>&nbsp;属性中所保存的函数。之所以会返回这个函数，是因为发生了搜索&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;原型链的过程。当在作为对象的&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>&nbsp;中发现没有“toString”属性存在时，会搜索其原型对象，而当原型对象中不存在该属性时，则会继续搜索原型的原型。而原型链中最终的原型是&nbsp;<code style="color:rgb(44,62,80);">Object.prototype</code>，这个对象确实有一个&nbsp;<code style="color:rgb(44,62,80);">toString</code>&nbsp;方法，因此该方法的引用被返回。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">最后：</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var val = objectRef.madeUpProperty;</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">返回&nbsp;<code style="color:rgb(44,62,80);">undefined</code>，因为在搜索原型链的过程中，直至&nbsp;<code style="color:rgb(44,62,80);">Object.prototype</code>&nbsp;的原型－－null，都没有找到任何对象有名为“madeUpPeoperty”的属性，因此最终返回&nbsp;<code style="color:rgb(44,62,80);">undefined</code>。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">不论是在对象或对象的原型中，读取命名属性值的时候只返回首先找到的属性值。而当为对象的命名属性赋值时，如果对象自身不存在该属性则创建相应的属性。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">这意味着，如果执行像&nbsp;<code style="color:rgb(44,62,80);">objectRef.testNumber = 3</code>&nbsp;这样一条赋值语句，那么这个&nbsp;<code style="color:rgb(44,62,80);">MyObject2</code>&nbsp;的实例自身也会创建一个名为“testNumber”的属性，而之后任何读取该命名属性的尝试都将获得相同的新值。这时候，属性访问器不会再进一步搜索原型链，但&nbsp;<code style="color:rgb(44,62,80);">MyObject1</code>&nbsp;实例值为&nbsp;<code style="color:rgb(44,62,80);">8</code>&nbsp;的“testNumber”属性并没有被修改。给&nbsp;<code style="color:rgb(44,62,80);">objectRef</code>对象的赋值只是遮挡了其原型链中相应的属性。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">注意：ECMAScript 为 Object 类型定义了一个内部&nbsp;<code style="color:rgb(44,62,80);">[[prototype]]</code>&nbsp;属性。这个属性不能通过脚本直接访问，但在属性访问器解析过程中，则需要用到这个内部&nbsp;<code style="color:rgb(44,62,80);">[[prototype]]</code>&nbsp;属性所引用的对象链－－即原型链。可以通过一个公共的&nbsp;<code style="color:rgb(44,62,80);">prototype</code>&nbsp;属性，来对与内部的&nbsp;<code style="color:rgb(44,62,80);">[[prototype]]</code>&nbsp;属性对应的原型对象进行赋值或定义。这两者之间的关系在 ECMA 262（3rd edition）中有详细描述，但超出了本文要讨论的范畴。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clIRExSc" title="clIRExSc" name="clIRExSc" style="color:#0000FF;"></a>标识符解析、执行环境和作用域链</h2> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clExCon" title="clExCon" name="clExCon" style="color:#0000FF;"></a>执行环境</h3> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">执行环境是 ECMAScript 规范（ECMA 262 第 3 版）用于定义 ECMAScript 实现必要行为的一个抽象的概念。对如何实现执行环境，规范没有作规定。但由于执行环境中包含引用规范所定义结构的相关属性，因此执行环境中应该保有（甚至 实现）带有属性的对象－－即使属性不是公共属性。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">所有 JavaScript 代码都是在一个执行环境中被执行的。全局代码（作为内置的JS 文件执行的代码，或者&nbsp;<code style="color:rgb(44,62,80);">HTML</code>页面加载的代码）是在我称之为“全局执行环境”的执行环境中执行的，而对函数的每次调用（<br> 有可能是作为构造函数）同样有关联的执行环境。通过&nbsp;<code style="color:rgb(44,62,80);">eval</code>&nbsp;函数执行的代码也有截然不同的执行环境，但因为 JavaScript 程序员在正常情况下一般不会使用&nbsp;<code style="color:rgb(44,62,80);">eval</code>，所以这里不作讨论。有关执行环境的详细说明请参阅 ECMA 262（3rd edition）第 10.2 节。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">当调用一个 JavaScript 函数时，该函数就会进入相应的执行环境。如果又调用了另外一个函数（或者递归地调用同一个函数），则又会创建一个新的执行环境，并且在函数调用期间执行过 程都处于该环境中。当调用的函数返回后，执行过程会返回原始执行环境。因而，运行中的 JavaScript 代码就构成了一个执行环境栈。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">在创建执行环境的过程中，会按照定义的先后顺序完成一系列操作。首先，在一个函数的执行环境中，会创建一个“活动”对象。活动对象是规范中规定的另 外一种机制。之所以称之为对象，是因为它拥有可访问的命名属性，但是它又不像正常对象那样具有原型（至少没有预定义的原型），而且不能通过 JavaScript 代码直接引用活动对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">为函数调用创建执行环境的下一步是创建一个&nbsp;<code style="color:rgb(44,62,80);">arguments</code>&nbsp;对象，这是一个类似数组的对象，它以整数索引的数组成员一一对应地保存着调用函数时所传递的参数。这个对象也有&nbsp;<code style="color:rgb(44,62,80);">length</code>&nbsp;和&nbsp;<code style="color:rgb(44,62,80);">callee</code>&nbsp;属性（这两个属性与我们讨论的内容无关，详见规范）。然后，会为活动对象创建一个名为“arguments”的属性，该属性引用前面创建的<code style="color:rgb(44,62,80);">arguments</code>对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">接着，为执行环境分配作用域。作用域由对象列表（链）组成。每个函数对象都有一个内部的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性（该属性我们稍后会详细介绍），这个属性也由对象列表（链）组成。指定给一个函数调用执行环境的作用域，由该函数对象的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性所引用的对象列表（链）组成，同时，活动对象被添加到该对象列表的顶部（链的前端）。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">之后会发生由 ECMA 262 中所谓“可变”对象完成的“变量实例化”的过程。只不过此时使用活动对象作为可变对象（这里很重要，请注意：它们是同一个对象）。此时会将函数的形式参数 创建为可变对象的命名属性，如果调用函数时传递的参数与形式参数一致，则将相应参数的值赋给这些命名属性（否则，会给命名属性赋&nbsp;<code style="color:rgb(44,62,80);">undefined</code>值）。对于定义的内部函数，会以其声明时所用名称为可变对象创建同名属性，而相应的内部函数则被创建为函数对象并指定给该属性。变量实例化的最后一步是将在函数内部声明的所有局部变量创建为可变对象的命名属性。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">根据声明的局部变量创建的可变对象的属性在变量实例化过程中会被赋予&nbsp;<code style="color:rgb(44,62,80);">undefined</code>&nbsp;值。在执行函数体内的代码、并计算相应的赋值表达式之前不会对局部变量执行真正的实例化。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">事实上，拥有&nbsp;<code style="color:rgb(44,62,80);">arguments</code>&nbsp;属性的活动对象和拥有与函数局部变量对应的命名属性的可变对象是同一个对象。因此，可以将标识符&nbsp;<code style="color:rgb(44,62,80);">arguments</code>&nbsp;作为函数的局部变量来看待。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">最后，要为使用&nbsp;<code style="color:rgb(44,62,80);">this</code>&nbsp;关键字而赋值。如果所赋的值引用一个对象，那么前缀以&nbsp;<code style="color:rgb(44,62,80);">this</code>&nbsp;关键字的属性访问器就是引用该对象的属性。如果所赋（内部）值是 null，那么&nbsp;<code style="color:rgb(44,62,80);">this</code>&nbsp;关键字则引用全局对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">创建全局执行环境的过程会稍有不同，因为它没有参数，所以不需要通过定义的活动对象来引用这些参数。但全局执行环境也需要一个作用域，而它的作用域 链实际上只由一个对象－－全局对象－－组成。全局执行环境也会有变量实例化的过程，它的内部函数就是涉及大部分 JavaScript 代码的、常规的顶级函数声明。而且，在变量实例化过程中全局对象就是可变对象，这就是为什么全局性声明的函数是全局对象属性的原因。全局性声明的变量同样 如此。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">全局执行环境也会使用&nbsp;<code style="color:rgb(44,62,80);">this</code>&nbsp;对象来引用全局对象。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clScCh" title="clScCh" name="clScCh" style="color:#0000FF;"></a>作用域链与 [[scope]]</h3> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">调用函数时创建的执行环境会包含一个作用域链，这个作用域链是通过将该执行环境的活动（可变）对象添加到保存于所调用函数对象的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性中的作用域链前端而构成的。所以，理解函数对象内部的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性的定义过程至关重要。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">在 ECMAScript 中，函数也是对象。函数对象在变量实例化过程中会根据函数声明来创建，或者是在计算函数表达式或调用&nbsp;<code style="color:rgb(44,62,80);">Function</code>&nbsp;构造函数时创建。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">通过调用&nbsp;<code style="color:rgb(44,62,80);">Function</code>&nbsp;构造函数创建的函数对象，其内部的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性引用的作用域链中始终只包含全局对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">通过函数声明或函数表达式创建的函数对象，其内部的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性引用的则是创建它们的执行环境的作用域链。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">在最简单的情况下，比如声明如下全局函数：-</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">function exampleFunction(formalParameter){<br> … // 函数体内的代码<br> }</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">- 当为创建全局执行环境而进行变量实例化时，会根据上面的函数声明创建相应的函数对象。因为全局执行环境的作用域链中只包含全局对象，所以它就给自己创建的、并以名为“exampleFunction”的属性引用的这个函数对象的内部&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性，赋予了只包含全局对象的作用域链。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">当在全局环境中计算函数表达式时，也会发生类似的指定作用域链的过程：-</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">var exampleFuncRef = function(){<br> …&nbsp;<span>// 函数体代码<br> }</span></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><span>在这种情况下，不同的是在全局执行环境的变量实例化过程中，会先为全局对象创建一个命名属性。而 在计算赋值语句之前，暂时不会创建函数对象，也不会将该函数对象的引用指定给全局对象的命名属性。但是，最终还是会在全局执行环境中创建这个函数对象（当 计算函数表达式时。译者注），而为这个创建的函数对象的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性指定的作用域链中仍然只包含全局对象。</span>内部的函数声明或表达式会导致在包含它们的外部函数的执行环境中创建相应的函数对象，因此这些函数对象的作用域链会稍微复杂一些。在下面的代码中，先定义了一个带有内部函数声明的外部函数，然后调用外部函数：</p> 
   <pre> /* 创建全局变量 - y - 它引用一个对象：- */<br>
var y = {x:5}; // 带有一个属性 - x - 的对象直接量<br>
function exampleFuncWith(){<br>
var z;<br>
/* 将全局对象 - y - 引用的对象添加到作用域链的前端：- */<br>
with(y){<br>
/* 对函数表达式求值，以创建函数对象并将该函数对象的引用指定给局部变量 - z - :- */<br>
z = function(){<br>
... // 内部函数表达式中的代码;<br>
}<br>
}<br>
...<br>
}<br>
/* 执行 - exampleFuncWith - 函数:- */<br></pre> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">exampleFuncWith();在调用&nbsp;<code style="color:rgb(44,62,80);">exampleFuncWith</code>&nbsp;函数创建的执行环境中包含一个由其活动对象后跟全局对象构成的作用域链。而在执行&nbsp;<code style="color:rgb(44,62,80);">with</code>&nbsp;语句时，又会把全局变量&nbsp;<code style="color:rgb(44,62,80);">y</code>&nbsp;引用的对象添加到这个作用域链的前端。在对其中的函数表达式求值的过程中，所创建函数对象的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性与创建它的执行环境的作用域保持一致－－即，该属性会引用一个由对象&nbsp;<code style="color:rgb(44,62,80);">y</code>&nbsp;后跟调用外部函数时所创建执行环境的活动对象，后跟全局对象的作用域链。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">当与&nbsp;<code style="color:rgb(44,62,80);">with</code>&nbsp;语句相关的语句块执行结束时，执行环境的作用域得以恢复（<code style="color:rgb(44,62,80);">y</code>&nbsp;会被移除），但是已经创建的函数对象（<code style="color:rgb(44,62,80);">z</code>。译者注）的&nbsp;<code style="color:rgb(44,62,80);">[[scope]]</code>&nbsp;属性所引用的作用域链中位于最前面的仍然是对象&nbsp;<code style="color:rgb(44,62,80);">y</code>。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clEncap" title="clEncap" name="clEncap" style="color:#0000FF;"></a>例 3：包装相关的功能</h3> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">闭包可以用于创建额外的作用域，通过该作用域可以将相关的和具有依赖性的代码组织起来，以便将意外交互的风险降到最低。假设有一个用于构建字符串的 函数，为了避免重复性的连接操作（和创建众多的中间字符串），我们的愿望是使用一个数组按顺序来存储字符串的各个部分，然后再使用&nbsp;<code style="color:rgb(44,62,80);">Array.prototype.join</code>&nbsp;方法（以空字符串作为其参数）输出结果。这个数组将作为输出的缓冲器，但是将数组作为函数的局部变量又会导致在每次调用函数时都重新创建一个新数组，这在每次调用函数时只重新指定数组中的可变内容的情况下并不是必要的。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">一种解决方案是将这个数组声明为全局变量，这样就可以重用这个数组，而不必每次都建立新数组。但这个方案的结果是，除了引用函数的全局变量会使用这 个缓冲数组外，还会多出一个全局属性引用数组自身。如此不仅使代码变得不容易管理，而且，如果要在其他地方使用这个数组时，开发者必须要再次定义函数和数 组。这样一来，也使得代码不容易与其他代码整合，因为此时不仅要保证所使用的函数名在全局命名空间中是唯一的，而且还要保证函数所依赖的数组在全局命名空 间中也必须是唯一的。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">而通过闭包可以使作为缓冲器的数组与依赖它的函数关联起来（优雅地打包），同时也能够维持在全局命名空间外指定的缓冲数组的属性名，免除了名称冲突和意外交互的危险。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">其中的关键技巧在于通过执行一个单行（in-line）函数表达式创建一个额外的执行环境，而将该函数表达式返回的内部函数作为在外部代码中使用的 函数。此时，缓冲数组被定义为函数表达式的一个局部变量。这个函数表达式只需执行一次，而数组也只需创建一次，就可以供依赖它的函数重复使用。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">下面的代码定义了一个函数，这个函数用于返回一个&nbsp;<span>HTML</span>&nbsp;字符串，其中大部分内容都是常量，但这些常量字符序列中需要穿插一些可变的信息，而可变的信息由调用函数时传递的参数提供。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">通过执行单行函数表达式返回一个内部函数，并将返回的函数赋给一个全局变量，因此这个函数也可以称为全局函数。而缓冲数组被定义为外部函数表达式的一个局部变量。它不会暴露在全局命名空间中，而且无论什么时候调用依赖它的函数都不需要重新创建这个数组。</p> 
   <pre>/* 声明一个全局变量 - getImgInPositionedDivHtml -<br>
并将一次调用一个外部函数表达式返回的内部函数赋给它。      <br><br>
这个内部函数会返回一个用于表示绝对定位的 DIV 元素<br>
包围着一个 IMG 元素 的 <span>HTML</span> 字符串，这样一来，<br>
所有可变的属性值都由调用该函数时的参数提供：<br>
*/<br>
var getImgInPositionedDivHtml = (function(){<br>
/* 外部函数表达式的局部变量 - buffAr - 保存着缓冲数组。<br>
这个数组只会被创建一次，生成的数组实例对内部函数而言永远是可用的<br>
因此，可供每次调用这个内部函数时使用。      <br><br>
其中的空字符串用作数据占位符，相应的数据<br>
将由内部函数插入到这个数组中：<br>
*/<br>
var buffAr = [<br>
'&lt;div id="',<br>
'',   //index 1, DIV ID 属性<br>
'" style="position:absolute;top:',<br>
'',   //index 3, DIV 顶部位置<br>
'px;left:',<br>
'',   //index 5, DIV 左端位置<br>
'px;width:',<br>
'',   //index 7, DIV 宽度<br>
'px;height:',<br>
'',   //index 9, DIV 高度<br>
'px;overflow:hidden;\"&gt;&lt;img src=\"',<br>
'',   //index 11, IMG URL<br>
'\" width=\"',<br>
'',   //index 13, IMG 宽度<br>
'\" height=\"',<br>
'',   //index 15, IMG 高度<br>
'\" alt=\"',<br>
'',   //index 17, IMG alt 文本内容<br>
'\"&gt;&lt;/div&gt;'<br>
];<br>
/* 返回作为对函数表达式求值后结果的内部函数对象。<br>
这个内部函数就是每次调用执行的函数<br>
- getImgInPositionedDivHtml( ... ) -<br>
*/<br>
return (function(url, id, width, height, top, left, altText){<br>
/* 将不同的参数插入到缓冲数组相应的位置：*/<br>
buffAr[1] = id;<br>
buffAr[3] = top;<br>
buffAr[5] = left;<br>
buffAr[13] = (buffAr[7] = width);<br>
buffAr[15] = (buffAr[9] = height);<br>
buffAr[11] = url;<br>
buffAr[17] = altText;<br>
/* 返回通过使用空字符串（相当于将数组元素连接起来）<br>
连接数组每个元素后形成的字符串：<br>
*/<br>
return buffAr.join('');<br>
}); //:内部函数表达式结束。<br>
})();<br>
/*^^- :单行外部函数表达式。*/<br></pre> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">如果一个函数依赖于另一（或多）个其他函数，而其他函数又没有必要被其他代码直接调用，那么可以运用相同的技术来包装这些函数，而通过一个公开暴露的函数来调用它们。这样，就将一个复杂的多函数处理过程封装成了一个具有移植性的代码单元。</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clOtE" title="clOtE" name="clOtE" style="color:#0000FF;"></a>其他例子</h3> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">有关闭包的一个可能是最广为人知的应用是&nbsp;<a href="http://www.crockford.com/javascript/private.html" rel="nofollow" style="color:#0000FF;text-decoration:none;">Douglas Crockford’s technique for the emulation of private instance variables in ECMAScript objects</a>。这种应用方式可以扩展到各种嵌套包含的可访问性（或可见性）的作用域结构，包括&nbsp;<a href="http://www.litotes.demon.co.uk/js_info/private_static.html" rel="nofollow" style="color:#0000FF;text-decoration:none;">the emulation of private static members for ECMAScript objects</a>。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">闭包可能的用途是无限的，可能理解其工作原理才是把握如何使用它的最好指南。</p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clAc" title="clAc" name="clAc" style="color:#0000FF;"></a>意外的闭包</h2> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">在创建可访问的内部函数的函数体之外解析该内部函数就会构成闭包。这表明闭包很容易创建，但这样一来可能会导致一种结果，即没有认识到闭包是一种语 言特性的 JavaScript 作者，会按照内部函数能完成多种任务的想法来使用内部函数。但他们对使用内部函数的结果并不明了，而且根本意识不到创建了闭包，或者那样做意味着什么。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">正如下一节谈到 IE 中内存泄漏问题时所提及的，意外创建的闭包可能导致严重的负面效应，而且也会影响到代码的性能。问题不在于闭包本身，如果能够真正做到谨慎地使用它们，反而会有助于创建高效的代码。换句话说，使用内部函数会影响到效率。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">使用内部函数最常见的一种情况就是将其作为 DOM 元素的事件处理器。例如，下面的代码用于向一个链接元素添加 onclick 事件处理器：</p> 
   <pre>/* 定义一个全局变量，通过下面的函数将它的值<br>
作为查询字符串的一部分添加到链接的 - href - 中：<br>
*/<br>
var quantaty = 5;<br>
/* 当给这个函数传递一个链接（作为函数中的参数 - linkRef -）时，<br>
会将一个 onclick 事件处理器指定给该链接，该事件处理器<br>
将全局变量 - quantaty - 的值作为字符串添加到链接的 - href -<br>
属性中，然后返回 true 使该链接在单击后定位到由  - href -<br>
属性包含的查询字符串指定的资源：<br>
*/<br>
function addGlobalQueryOnClick(linkRef){<br>
/* 如果可以将参数 - linkRef - 通过类型转换为 ture<br>
（说明它引用了一个对象）：<br>
*/<br>
if(linkRef){<br>
/* 对一个函数表达式求值，并将对该函数对象的引用<br>
指定给这个链接元素的 onclick 事件处理器：<br>
*/<br>
linkRef.onclick = function(){<br>
/* 这个内部函数表达式将查询字符串<br>
添加到附加事件处理器的元素的 - href - 属性中：<br>
*/<br>
this.href += ('?quantaty='+escape(quantaty));<br>
return true;<br>
};<br>
}<br>
}<br></pre> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">无论什么时候调用&nbsp;<code style="color:rgb(44,62,80);">addGlobalQueryOnClick</code>&nbsp;函数，都会创建一个新的内部函数（通过赋值构成了闭包）。从效率的角度上看，如果只是调用一两次&nbsp;<code style="color:rgb(44,62,80);">addGlobalQueryOnClick</code>&nbsp;函数并没有什么大的妨碍，但如果频繁使用该函数，就会导致创建许多截然不同的函数对象（每对内部函数表达式求一次值，就会产生一个新的函数对象）。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">上面例子中的代码没有关注内部函数在创建它的函数外部可以访问（或者说构成了闭包）这一事实。实际上，同样的效果可以通过另一种方式来完成。即单独 地定义一个用于事件处理器的函数，然后将该函数的引用指定给元素的事件处理属性。这样，只需创建一个函数对象，而所有使用相同事件处理器的元素都可以共享 对这个函数的引用：</p> 
   <pre>/* 定义一个全局变量，通过下面的函数将它的值<br>
作为查询字符串的一部分添加到链接的 - href - 中：<br>
*/<br>
var quantaty = 5;<br>
/* 当把一个链接（作为函数中的参数 - linkRef -）传递给这个函数时，<br>
会给这个链接添加一个 onclick 事件处理器，该事件处理器会<br>
将全局变量  - quantaty - 的值作为查询字符串的一部分添加到<br>
链接的 - href -  中，然后返回 true，以便单击链接时定位到由<br>
作为 - href - 属性值的查询字符串所指定的资源：<br>
*/<br>
function addGlobalQueryOnClick(linkRef){<br>
/* 如果 - linkRef - 参数能够通过类型转换为 true<br>
（说明它引用了一个对象）：<br>
*/<br>
if(linkRef){<br>
/* 将一个对全局函数的引用指定给这个链接<br>
的事件处理属性，使函数成为链接元素的事件处理器：<br>
*/<br>
linkRef.onclick = forAddQueryOnClick;<br>
}<br>
}<br>
/* 声明一个全局函数，作为链接元素的事件处理器，<br>
这个函数将一个全局变量的值作为要添加事件处理器的<br>
链接元素的  - href - 值的一部分：<br>
*/<br>
function forAddQueryOnClick(){<br>
this.href += ('?quantaty='+escape(quantaty));<br>
return true;<br>
}<br></pre> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">在上面例子的第一个版本中，内部函数并没有作为闭包发挥应有的作用。在那种情况下，反而是不使用闭包更有效率，因为不用重复创建许多本质上相同的函数对象。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">类似地考量同样适用于对象的构造函数。与下面代码中的构造函数框架类似的代码并不罕见：</p> 
   <pre>function ExampleConst(param){<br>
/* 通过对函数表达式求值创建对象的方法，<br>
并将求值所得的函数对象的引用赋给要创建对象的属性：<br>
*/<br>
this.method1 = function(){<br>
... // 方法体。<br>
};<br>
this.method2 = function(){<br>
... // 方法体。<br>
};<br>
this.method3 = function(){<br>
... // 方法体。<br>
};<br>
/* 把构造函数的参数赋给对象的一个属性：*/<br>
this.publicProp = param;<br>
}<br></pre> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">每当通过&nbsp;<code style="color:rgb(44,62,80);">new ExampleConst(n)</code>&nbsp;使用这个构造函数创建一个对象时，都会创建一组新的、作为对象方法的函数对象。因此，创建的对象实例越多，相应的函数对象也就越多。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">Douglas Crockford 提出的模仿 JavaScript 对象私有成员的技术，就利用了将对内部函数的引用指定给在构造函数中构造对象的公共属性而形成的闭包。如果对象的方法没有利用在构造函数中形成的闭包，那 么在实例化每个对象时创建的多个函数对象，会使实例化过程变慢，而且将有更多的资源被占用，以满足创建更多函数对象的需要。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">这那种情况下，只创建一次函数对象，并把它们指定给构造函数&nbsp;<code style="color:rgb(44,62,80);">prototype</code>&nbsp;的相应属性显然更有效率。这样一来，它们就能被构造函数创建的所有对象共享了：</p> 
   <pre>function ExampleConst(param){<br>
/* 将构造函数的参数赋给对象的一个属性：*/<br>
this.publicProp = param;<br>
}<br>
/* 通过对函数表达式求值，并将结果函数对象的引用<br>
指定给构造函数原型的相应属性来创建对象的方法：<br>
*/<br>
ExampleConst.prototype.method1 = function(){<br>
... // 方法体。<br>
};<br>
ExampleConst.prototype.method2 = function(){<br>
... // 方法体。<br>
};<br>
ExampleConst.prototype.method3 = function(){<br>
... // 方法体。<br>
};<br></pre> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;"> <a id="clMem" title="clMem" name="clMem" style="color:#0000FF;"></a>Internet Explorer 的内存泄漏问题</h2> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">返回目录</a></p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">Internet Explorer Web 浏览器（在 IE 4 到 IE 6 中核实）的垃圾收集系统中存在一个问题，即如果 ECMAScript 和某些宿主对象构成了 “循环引用”，那么这些对象将不会被当作垃圾收集。此时所谓的宿主对象指的是任何 DOM 节点（包括 document 对象及其后代元素）和 ActiveX 对象。如果在一个循环引用中包含了一或多个这样的对象，那么这些对象直到浏览器关闭都不会被释放，而它们所占用的内存同样在浏览器关闭之前都不会交回系统 重用。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">当两个或多个对象以首尾相连的方式相互引用时，就构成了循环引用。比如对象 1 的一个属性引用了对象 2 ，对象 2 的一个属性引用了对象 3，而对象 3 的一个属性又引用了对象 1。对于纯粹的 ECMAScript 对象而言，只要没有其他对象引用对象 1、2、3，也就是说它们只是相互之间的引用，那么仍然会被垃圾收集系统识别并处理。但是，在 Internet Explorer 中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会发现它们之间的循环关系与系统中的其他对象是隔离的并释放它们。最终它们将被保留在内存中，直到浏览器关闭。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">闭包非常容易构成循环引用。如果一个构成闭包的函数对象被指定给，比如一个 DOM 节点的事件处理器，而对该节点的引用又被指定给函数对象作用域中的一个活动（或可变）对象，那么就存在一个循环引用。DOM_Node.onevent -&gt;function_object.[[scope]] -&gt;scope_chain -&gt;Activation_object.nodeRef -&gt;DOM_Node。形成这样一个循环引用是轻而易举的，而且稍微浏览一下包含类似循环引用代码的网站（通常会出现在网站的每个页面中），就会消耗大量（甚至全部）系统内存。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;">多加注意可以避免形成循环引用，而在无法避免时，也可以使用补偿的方法，比如使用 IE 的 onunload 事件来来清空（null）事件处理函数的引用。时刻意识到这个问题并理解闭包的工作机制是在 IE 中避免此类问题的关键。</p> 
   <p style="text-indent:2em;line-height:32px;color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;"><a href="http://www.jibbering.com/faq/faq_notes/faq_notes.html#toc" rel="nofollow" style="color:#0000FF;text-decoration:none;">comp.lang.javascript FAQ notes T.O.C.</a></p> 
   <ul style="color:rgb(68,68,68);font-family:'微软雅黑', tahoma, arial, sans-serif;font-size:16px;line-height:32px;list-style-type:none;">
    <li style="list-style:disc;">撰稿&nbsp;Richard Cornford，2004 年 3 月</li> 
    <li style="list-style:disc;">修改建议来自：
     <ul style="list-style-type:none;">
      <li style="list-style:disc;">Martin Honnen.</li> 
      <li style="list-style:disc;">Yann-Erwan Perio (Yep).</li> 
      <li style="list-style:disc;">Lasse Reichstein Nielsen. (<a href="http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clDefN" rel="nofollow" style="color:#0000FF;text-decoration:none;">definition of closure</a>)</li> 
      <li style="list-style:disc;">Mike Scirocco.</li> 
      <li style="list-style:disc;">Dr John Stockton.</li> 
     </ul></li> 
   </ul>
   <div>
    <font color="#444444"><span style="line-height:32px;"><br></span></font>
   </div> 
   <div>
    <font color="#444444"><span style="line-height:32px;"><br></span></font>
   </div> 
   <div>
    <font color="#444444"><span style="line-height:32px;"><br></span></font>
   </div> 
   <div>
    <font color="#444444"><span style="line-height:32px;"><br></span></font>
   </div> 
   <div>
    <font color="#444444"><span style="line-height:32px;">本文转自豪情博客园博客，原文链接：http://www.cnblogs.com/jikey/archive/2010/08/05/1792809.html，如需转载请自行联系原作者</span><br></font>
   </div> 
   <div>
    <font color="#444444"><span style="line-height:32px;"><br></span></font>
   </div> 
   <div>
    <font color="#444444"><span style="line-height:32px;"><br></span></font>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
