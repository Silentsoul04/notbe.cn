<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>OpenGL编程轻松入门（四） « NotBeCN</title>
  <meta name="description" content="                 1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 曲面和曲线           &nbsp;&nbsp;&nbsp;&nbsp; 前面我们讲了如何绘制平面的图形，这一节我们学习如何绘制曲线和曲面。     例10：绘制一个曲面...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/15/1557728877450.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">OpenGL编程轻松入门（四）</h1>
    <p class="post-meta">Nov 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 曲面和曲线
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    &nbsp;&nbsp;&nbsp;&nbsp; 前面我们讲了如何绘制平面的图形，这一节我们学习如何绘制曲线和曲面。
    <br> 例10：绘制一个曲面，本程序使用二维求值器绘制一个曲面。本例中也有一些特殊效果的操作。
    <br> #include &lt;windows.h&gt;
    <br> #include &lt;GL/GLAUX.h&gt;
    <br> #include &lt;GL/glut.h&gt;
    <br> #include &lt;math.h&gt;
    <br> &nbsp;
    <br> GLfloat ctrlpoints[5][5][3] = {{{-2,0,0},{-1,1,0},{0,0,0},{1,-1,0},{2,0,0}},
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{-2,0,-1},{-1,1,-1},{0,0,-1},{1,-1,-1},{2,0,-1}},
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{-2,0,-2},{-1,1,-2},{0,0,-2},{1,-1,-2},{2,0,-2}},
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{-2,0,-3},{-1,1,-3},{0,0,-3},{1,-1,-3},{2,0,-3}},
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {{-2,0,-4},{-1,1,-4},{0,0,-4},{1,-1,-4},{2,0,-4}}};
    <br> &nbsp;
    <br> GLfloat mat_ambient[] = {0.1,0.1,0.1,1.0};
    <br> GLfloat mat_diffuse[] = {1.0,0.6,0.0,1.0};
    <br> GLfloat mat_specular[] = {1.0,1.0,1.0,1.0};
    <br> &nbsp;
    <br> GLfloat light_ambient[] = {0.1,0.1,0.1,1.0};
    <br> GLfloat light_diffuse[] = {1.0,1.0,1.0,0.0};
    <br> GLfloat light_specular[] = {1.0,1.0,1.0,0.0};
    <br> GLfloat light_position[] = {2.0,23.0,-4.0,1.0};
    <br> &nbsp;
    <br> void myInit(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(0.0,0.0,0.0,0.0);//设置背景色
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*为光照模型指定材质参数*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_AMBIENT,mat_ambient);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialf(GL_FRONT,GL_SHININESS,60.0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置光源参数*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_AMBIENT,light_ambient);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_DIFFUSE,light_diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_SPECULAR,light_specular);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,light_position);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*enable depth comparisons and update the depth buffer*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置特殊效果*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glHint(GL_LINE_SMOOTH_HINT,GL_DONT_CARE);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_BLEND);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_AUTO_NORMAL);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_NORMALIZE);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glFrontFace(GL_CW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glShadeModel(GL_SMOOTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LINE_SMOOTH);
    <br> }
    <br> &nbsp;
    <br> void myDisplay(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.0,-1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glRotatef(50.0,1.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*绘制曲面*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_MAP2_VERTEX_3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMap2f(GL_MAP2_VERTEX_3,0,1,3,5,0,1,15,5,&amp;ctrlpoints[0][0][0]);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMapGrid2f(10.0,0.0,1.0,10.0,0.0,1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalMesh2(GL_FILL,0,10.0,0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutSwapBuffers();
    <br> }
    <br> &nbsp;
    <br> void myReshape(GLsizei w,GLsizei h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,w,h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluPerspective(60.0,(GLfloat)w/(GLfloat)h,1.0,100.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.0,0.0,-5.0);
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(400,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(200,200);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow("lighted Bezier surface");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*绘制与显示*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myInit();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return(0);
    <br> }
    <br> &nbsp;
    <br> myInit（）中的几个有关特殊效果的操作。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBlendFunc（GLenum sfactor，GLenum dfactor） 指定像素算法。sfactor指定红，绿，蓝及alpha源混合因素是如何计算的。dfactor指定红，绿，蓝及alpha目标混合因素是如何计算的。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glHint（GLenum target，GLenum mode）指定操作线索。
    <br> Target为需要控制的符号常量。mode为所希望的行为符号常数。本例中GL_LINE_SMOOTH_HINT指定反走样线段的采样质量。GL_DONT_CARE指对选项不做考虑。
    <br> myDisplay（）中的曲面操作
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void glMap2f（GLenum target，GLfloat u1,GLfloat u2,Glint ustride, Glint uorder, GLfloat&nbsp; v1, GLfloat v2, Glint vstride, Glint vorder, const GLfloat *points）;定义2维求值器。
    <br> target指定求值器生成的数值类型。本例中的GL_MAP2_VERTEX_3 指明每一个控制点为x、y、z表示的三个浮点值。
    <br> u1，u2指定线性映射。
    <br> ustride 指定控制点Rij的起始点和控制点 R（i+1）j的的起始点之间单精度或双精度浮点值的个数。这里i和j分别是u和v控制点索引，它允许控制点装入任意的数据结构中。唯一的限制是对于特定控制点的数值必须存在连续的内存单元。
    <br> uorder控制点数组在u轴方向上的维数。
    <br> v1，v2指定线性映射v
    <br> vstride指定控制点Rij的起始点和控制点 Ri（j+ 1）的起始点之间单精度或双精度浮点值的个数。这里i和j分别是u和v控制点索引，它允许控制点装入任意的数据结构中。唯一的限制是对于特定控制点的数值必须存在连续的内存单元。
    <br> vorder控制点数组在v轴方向上的维数。
    <br> points 一个指向控制点数组的指针。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMapGrid定义一维或二维网格。void glMapGrid2f（Glint un, GLfloat u1, GLfloat u2,Glint vn, GLfloat v1,GLfloat v2）;
    <br> un 在网格[u1，u2]中的分段数目。
    <br> u1，u2 指定整数网格范围 i= 0；i= un的映射。
    <br> vn在网格[v1，v2]中的分段数目。
    <br> v1，v2 指定整数网格范围 j = 0；j= vn的映射。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glEvalMesh 计算一维或二维点或线网格。本例中为2维。void glEvalMesh2（GLenum mode，Glint i1，Glint i2，Glint j1，Glint j2）；
    <br> mode 指定是否计算二维点、线或多边形的网格。
    <br> i1，i2 分别为网格定义域变量i的第一个和最后一个整数值。
    <br> j1，j2分别为网格定义域变量j的第一个和最后一个整数值。
    <br> glMapGrid和glEvalMesh用来生成并求取一系列等间隔的网格点，glEvalMesh逐步计算一维或二维网格，他的定义范围由glMap指定。mode决定最终计算的顶点是绘制为点、线还是充实的多边形。具体的映射关系及有关图形方面的知识，你可以很方便的在MSDN、互联网及有关书籍中查到，本文就不详述这方面的内容。
    <br> 2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 绘制NURBS曲线和曲面
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    上一节讲了一般的曲线与曲面的绘制，本节讲NURBS曲线和曲面的绘制。
    <br> 例11：此例绘制两个相同形状的NURBS曲面，不同之处是一个为线框式，一个是由实多边形组成。运行后可以看到其中的区别。
    <br> #include &lt;windows.h&gt;
    <br> #include &lt;GL/glut.h&gt;
    <br> &nbsp;
    <br> GLUnurbsObj *theNurb1;
    <br> GLUnurbsObj *theNurb2;
    <br> &nbsp;
    <br> GLfloat ctrlpoints[5][5][3] = {{{-3,0.5,0},{-1,1.5,0},{-2,2,0},{1,-1,0},{-5,0,0}},
    <br> {{-3,0.5,-1},{-1,1.5,-1},{-2,2,-1},{1,-1,-1},{-5,0,-1}},
    <br> {{-3,0.5,-2},{-1,1.5,-2},{-2,2,-2},{1,-1,-2},{-5,0,-2}},
    <br> {{-3,0.5,-3},{-1,1.5,-3},{-2,2,-3},{1,-1,-3},{-5,0,-3}},
    <br> {{-3,0.5,-4},{-1,1.5,-4},{-2,2,-4},{1,-1,-4},{-5,0,-4}}};//控制点
    <br> &nbsp;
    <br> GLfloat mat_diffuse[] = {1.0,0.5,0.1,1.0};
    <br> GLfloat mat_specular[] = {1.0,1.0,1.0,1.0};
    <br> GLfloat mat_shininess[] = {100.0};
    <br> GLfloat light_position[] = {0.0,-10.0,0.0,1.0};
    <br> &nbsp;
    <br> void myInit(void)
    <br> {
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(1.0,1.0,1.0,0.0);//设置背景色
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*为光照模型指定材质参数*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_FRONT,GL_POSITION,light_position);//设置光源参数
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_TRUE);//设置光照模型参数
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp; /*激活光照*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glDepthFunc(GL_LEQUAL);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LEQUAL);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_AUTO_NORMAL);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_NORMALIZE);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置特殊效果*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glHint(GL_LINE_SMOOTH_HINT,GL_DONT_CARE);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_BLEND);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glFrontFace(GL_CW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glShadeModel(GL_SMOOTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LINE_SMOOTH);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; theNurb1 = gluNewNurbsRenderer();//创建NURBS对象theNurb1
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb1,GLU_SAMPLING_TOLERANCE,25.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb1,GLU_DISPLAY_MODE,GLU_OUTLINE_POLYGON);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; theNurb2 = gluNewNurbsRenderer();//创建NURBS对象theNurb2
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb2,GLU_SAMPLING_TOLERANCE,25.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb2,GLU_DISPLAY_MODE,GLU_FILL);
    <br> }
    <br> &nbsp;
    <br> int spin = 0;
    <br> &nbsp;
    <br> /*接收键盘指令*/
    <br> static void myKey(unsigned char key,int x,int y)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; switch(key)
    <br> &nbsp;&nbsp;&nbsp;&nbsp; {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case'd':
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin = spin + 1;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(spin,1.0,1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 27:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; default:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; }
    <br> }
    <br> &nbsp;
    <br> /*绘制曲面*/
    <br> void myDisplay(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; GLfloat knots[10] = {0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0};
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glRotatef(50.0,1.0,1.0,0.0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*第一个曲面*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(1.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginSurface(theNurb1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*定义曲面形状*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsSurface(theNurb1,10,knots,10,knots,5*3,3,&amp;ctrlpoints[0][0][0],5,5,GL_MAP2_VERTEX_3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluEndSurface(theNurb1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*第二个曲面*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(7.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginSurface(theNurb2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*定义曲面形状*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsSurface(theNurb2,10,knots,10,knots,5*3,3,&amp;ctrlpoints[0][0][0],5,5,GL_MAP2_VERTEX_3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluEndSurface(theNurb2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutSwapBuffers();
    <br> }
    <br> &nbsp;
    <br> void myReshape(GLsizei w,GLsizei h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,w,h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluPerspective(50.0,(GLfloat)w/(GLfloat)h,1.0,15.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.0,0.0,-9.0);
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(600,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(200,200);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow("NURBS surface");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制与显示*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myInit();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutKeyboardFunc(myKey);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return(0);
    <br> }
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GLUnurbsObj* glNewNurbsRenderer（）创建一个NURBS对象，并返回一个指向该对象的指针。如果没有足够的内存分配给该对象，则返回值为0。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluNurbsProperty(GLUnurbsObj* nobj, GLenum property, GLfloat value)设置NURBS属性。
    <br> nobj 指向NURBS对象的指针。
    <br> property需设置的属性。
    <br> value 设置指定属性的值。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBeginSurface及gluEndSurface两个函数一起限定一个NURBS面的定义。返回值均为void，参数均为GLUnurbsObj* nobj，为指向NURBS对象的指针。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluNurbsSurface(GLUnurbsObj *nobj, Glint knot_count, GLfloat tknot_count, GLfloat *tknot, Glint s_stride, Glint t_stride, GLfloat *ctlarry, GLint sorder, GLint torder,GLenum type) 定义NURBS曲面形状。
    <br> nobj 指向NURBS对象的指针。
    <br> sknot_count 参数化u方向上的节点数。
    <br> sknot 参数化u方向上的非递减节点值。
    <br> tknot_count 参数化v方向上的节点数。
    <br> tknot 参数化v方向上的非递减节点值。
    <br> s_stride在ctlarry中参数化u方向上相邻控制点的偏移量。
    <br> t_stride在ctlarry中参数化v方向上相邻控制点的偏移量。
    <br> ctlarryNURBS的控制点数组。
    <br> sorder参数化u方向上NURBS的阶数，阶数比维数大1。
    <br> torder参数化v方向上NURBS的阶数，阶数比维数大1。
    <br> type曲面类型。
    <br> 例12：绘制一个彩色的曲线，曲线闭合成圆。在曲线的边缘绘制8个点。
    <br> #include &lt;windows.h&gt;
    <br> #include &lt;GL/glut.h&gt;
    <br> &nbsp;
    <br> GLUnurbsObj *theNurb;
    <br> &nbsp;
    <br> GLfloat ctrlpoints[12][3] = {{4,0,0},{2.828,2.828,0},{0,4,0},{-2.828,2.828,0},
    <br> {-4,0,0},{-2.828,-2.828,0},{0,-4,0},{2.828,-2.828,0},
    <br> {4,0,0},{2.828,2.828,0},{0,4,0},{2.828,2.828,0}};//控制点
    <br> &nbsp;
    <br> GLfloat color[12][3]={{1.0,0.0,0.0},{1.0,1.0,0.0},{0.0,1.0,0.0},{-1.0,1.0,0.0},
    <br> {-1.0,0.0,0.0},{-1.0,-1.0,0.0},{0.0,-1.0,0.0},{1.0,-1.0,0.0},
    <br> {1.0,0.0,0.0},{1.0,1.0,0.0},{0.0,1.0,0.0},{1.0,1.0,0.0}};
    <br> &nbsp;
    <br> GLfloat knots[15] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
    <br> &nbsp;
    <br> void myInit(void)
    <br> {
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(1.0,1.0,1.0,0.0);//设置背景色
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; theNurb = gluNewNurbsRenderer();//创建NURBS对象theNurb
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluNurbsProperty(theNurb,GLU_SAMPLING_TOLERANCE,10);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> }
    <br> &nbsp;
    <br> &nbsp;
    <br> /*绘制曲线*/
    <br> void myDisplay(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; int i;
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;&nbsp;&nbsp; glColor3f(0.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLineWidth(3.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制曲线*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluBeginCurve(theNurb);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsCurve(theNurb,15,knots,3,&amp;ctrlpoints[0][0],3,GL_MAP1_VERTEX_3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNurbsCurve(theNurb,15,knots,3,&amp;ctrlpoints[0][0],3,GL_MAP1_COLOR_4);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluEndCurve(theNurb);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制点*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPointSize(5.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_POINTS);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0;i &lt; 8;i++)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2fv(&amp;ctrlpoints[i][0]);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnd();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutSwapBuffers();
    <br> }
    <br> &nbsp;
    <br> void myReshape(GLsizei w,GLsizei h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,w,h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; if(w &lt;=h)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-10.0,10.0,-10.0*(GLfloat)h/(GLfloat)w,10.0*(GLfloat)h/(GLfloat)w,-10.0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; else
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-10.0*(GLfloat)w/(GLfloat)h,10.0*(GLfloat)w/(GLfloat)h,-10.0,10.0,-10.0,10.0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.0,0.0,-9.0);
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(600,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(200,200);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow("NURBS curve");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制与显示*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myInit();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return(0);
    <br> }
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluBeginCurve，gluEndCurve限定NURBS曲面。返回值均为void，参数均为GLUnurbsObj* nobj，为指向NURBS对象的指针。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluNurbsCurve（GLUnurbsObj *nobj， GLint nknots， GLfloat *knot， Glint stride， GLfloat *ctlarray， GLint order，GLenum type）定义曲线形状。
    <br> nobj 指向NURBS对象的指针。
    <br> nknots 节点数，节点数等于控制点数加上阶数。
    <br> knot nknots数组非递减节点值。
    <br> stride相邻控制点的偏移量。
    <br> Ctlarry指向NURBS的控制点数组的指针。
    <br> order NURBS曲线的阶数，阶数比维数大1。
    <br> type曲面类型。
    <br> 3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 二次几何体
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    这一章我们讲一下二次几何物体的绘制。二次几何物体的绘制有几种不同的方式，在本例中可以看出不同的绘制方式的不同效果。
    <br> 例13：本例使用GLU库函数绘制了四个几何物体，分别为圆柱体、球体、圆盘和部分圆盘。
    <br> #include &lt;windows.h&gt;
    <br> #include &lt;GL/glut.h&gt;
    <br> #include &lt;math.h&gt;
    <br> &nbsp;
    <br> /*声明四个二次曲面物体*/
    <br> GLUquadricObj *quadObj1;
    <br> GLUquadricObj *quadObj2;
    <br> GLUquadricObj *quadObj3;
    <br> GLUquadricObj *quadObj4;
    <br> &nbsp;
    <br> static float light_ambient[] = {0.1,0.1,0.1,1.0};
    <br> static float light_diffuse[] = {0.5,1.0,1.0,1.0};
    <br> static float light_position[] = {90.0,90.0,150.0,0.0};
    <br> &nbsp;
    <br> static float front_mat_shininess[] = {60.0};
    <br> static float front_mat_specular[] = {0.2,0.2,0.2,1.0};
    <br> static float front_mat_diffuse[] = {0.5,0.5,0.28,1.0};
    <br> &nbsp;
    <br> static float back_mat_shininess[] = {60.0};
    <br> static float back_mat_specular[] = {0.5,0.5,0.2,1.0};
    <br> static float back_mat_diffuse[] = {1.0,0.9,0.2,1.0};
    <br> &nbsp;
    <br> static float Imodel_ambient[] = {1.0,1.0,1.0,1.0};
    <br> static float Imodel_twoside[] = {GL_TRUE};
    <br> static float Imodel_oneside[] = {GL_FALSE};
    <br> &nbsp;
    <br> void myInit(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置背景色*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(0.0,0.0,0.0,1.0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_DEPTH_TEST);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glDepthFunc(GL_LEQUAL);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置光照*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_AMBIENT,light_ambient);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_DIFFUSE,light_diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightfv(GL_LIGHT0,GL_POSITION,light_position);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置材质*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,front_mat_diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SPECULAR,front_mat_specular);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_SHININESS,front_mat_shininess);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_BACK,GL_DIFFUSE,back_mat_diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_BACK,GL_SPECULAR,back_mat_specular);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_BACK,GL_SHININESS,back_mat_shininess);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*设置光照模型参数*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightModelfv(GL_LIGHT_MODEL_AMBIENT,Imodel_ambient);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE,Imodel_twoside);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*激活关照*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHTING);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnable(GL_LIGHT0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glShadeModel(GL_SMOOTH);&nbsp;&nbsp;
    <br> }
    <br> &nbsp;
    <br> void myDisplay(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建四个二次曲面物体*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; quadObj1 = gluNewQuadric();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; quadObj2 = gluNewQuadric();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; quadObj3 = gluNewQuadric();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; quadObj4 = gluNewQuadric();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制一个圆柱体*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricDrawStyle(quadObj1,GLU_FILL);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricNormals(quadObj1,GL_FLAT);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricOrientation(quadObj1,GLU_INSIDE);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricTexture(quadObj1,GL_TRUE);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(30,1.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(40,0.0,1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluCylinder(quadObj1,2.0,2.0,9.0,20.0,8.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制一个球体*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricDrawStyle(quadObj2,GLU_SILHOUETTE);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(-5.0,-1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluSphere(quadObj2,3.0,20.0,20.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制一个圆盘*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricDrawStyle(quadObj3,GLU_LINE);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(-2.0,4.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluDisk(quadObj3,2.0,5.0,15.0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制一个部分圆盘*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluQuadricDrawStyle(quadObj4,GLU_POINT);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(-3.0,-7.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluPartialDisk(quadObj4,2.0,5.0,15.0,10.0,10.0,100.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*删除四个二次曲面物体对象*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluDeleteQuadric(quadObj1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluDeleteQuadric(quadObj2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluDeleteQuadric(quadObj3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluDeleteQuadric(quadObj4);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glFlush();
    <br> }
    <br> &nbsp;
    <br> void myReshape(int w,int h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,(GLsizei)w,(GLsizei)h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; gluPerspective(45.0,(GLfloat)w/(GLfloat)h,1.0,50.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(0.0,0.0,-25.0);
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(400,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(100,100);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow(" DRAW QUADRIC OBJECTS ");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*绘制与显示*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; myInit();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return 0;
    <br> }
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluNewQuadric创建一个二次对象。这个函数创建并返回一个指向新的二次对象的指针。当调用二次描述和控制函数是指向这个对象。如果返回值为0则表明没有足够的空间分配给该对象。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glQuadricDrawStyle函数指定二次对象的绘制方式。本例中圆柱体的绘制方式为GLU_FILL。含义为用多边形原绘制本二次对象，多边形的绘制方式为逆时针。球体的绘制方式为GL_SILHOUETTE,即除边界外用一系列线来绘制二次对象。圆盘的绘制方式为GL_LINE,即用一系列线来绘制二次对象。部分圆盘的绘制方式为GL_POINT,即用一系列点来绘制二次对象。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glQuadricNormals，指定二次对象使用的法向量类型。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glQuadricOrientation，指定二次对象的内面或外面方位。GLU_OUTSIDE为缺省值，表明使用指向内面的法相量绘出二次对象,GLU_INSIDE表明使用指向外面的法相量绘出二次对象。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glQuadricTexture指定二次对象是否使用纹理。GL_FALSE为缺省值。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluCylinder（GLUquadricObj *qobj，GLdouble baseRadius，GLdouble topRadius，GLdouble height，Glint slices，Glint stacks）绘制一个圆柱体。
    <br> qobj指明是哪个二次对象。
    <br> baseRadius圆柱体在z=0时的半径。
    <br> topRadius圆柱体在z=height时的半径。
    <br> height圆柱体的高。
    <br> slices围绕着z轴分片的个数。
    <br> stacks顺着z轴分片的个数。stacks和slices垂直。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluSphere（GLUquadricObj *qobj，GLdouble radius，Glint slices，Glint stacks）绘制一个球形。
    <br> qobj指明是哪个二次对象。
    <br> radius球体半径。
    <br> slices围绕着z轴分片的个数。
    <br> stacks顺着z轴分片的个数。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluDisk（GLUquadricObj *qobj，GLdouble innerRadius，GLdouble outerRadius，Glint slices，Glint loops）绘制一个圆盘。
    <br> qobj指明是哪个二次对象。
    <br> innerRadius圆盘的内部半径，可能为0。
    <br> outerRadius圆盘的外部半径。
    <br> slices围绕着z轴分片的个数。
    <br> loops圆盘同心圆个数。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void gluPartialDisk（GLUquadricObj *qobj，GLdouble innerRadius，GLdouble outerRadius，Glint slices，Glint loops，GLdouble startAngle，GLdouble sweepAngle）绘制一个圆盘的一部分。
    <br> startAngle起始角度，单位为度。
    <br> sweepAngle扫描角，单位为度。
    <br> 4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 像素操作
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    &nbsp;&nbsp;&nbsp;&nbsp; 本节讲解像素操作。
    <br> 例14：本例在窗口绘制一个三角形，然后利用glCopyPixel函数拷贝了五次该图形，并将这五个三角形放置在窗口的不同位置。
    <br> #include &lt;stdlib.h&gt;
    <br> #include &lt;GL/glut.h&gt;
    <br> &nbsp;
    <br> /*设置背景色*/
    <br> void myInit(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(1.0,1.0,1.0,1.0);
    <br> }
    <br> &nbsp;
    <br> /*绘制彩色三角形*/
    <br> void triangle(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_TRIANGLES);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(10.0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,0.3,1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(20.0,30.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(30.0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnd();
    <br> }
    <br> &nbsp;
    <br> void myDisplay()
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; int i;
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glTranslatef(10.0,100.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; triangle();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0;i &lt; 5;i++)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRasterPos2i(20+i*30,10+i*5);//为像素操作指定光栅位置
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glCopyPixels(50,200,500,500,GL_COLOR);//在缓存中拷贝像素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glFlush();
    <br> }
    <br> &nbsp;
    <br> void myReshape(int w,int h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,(GLsizei)w,(GLsizei)h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; if( w &lt;= h)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluOrtho2D(0.0,150,0.0,150.0*(GLfloat)h/(GLfloat)w);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; else
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluOrtho2D(0.0,150*(GLfloat)w/(GLfloat)h,0.0,150.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(500,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(100,100);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow(" copy ");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; myInit();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return 0;
    <br> }
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRasterPos在像素操作中指定光栅位置。同样后面的数字表示坐标维数，2表示坐标为x、y，3表示、，y、z。数字后面的字母表示参数类型。最后带V表示参数为指针。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void glCopyPixels（GLint x, Glint y, GLsizei width, GLsizei height, GLenum type）函数将像素拷贝到缓存中。
    <br> x，y指定被拷贝像素的右下角坐标。
    <br> width，heigth指定被拷贝像素矩形区域的大小。
    <br> type指定拷贝数值的类型。值为颜色、深度或膜板值。本例中为颜色。
    <br> &nbsp;
    <br> 例15：此例在窗口左下角写单词FILE。
    <br> #include &lt;stdlib.h&gt;
    <br> #include &lt;GL/glut.h&gt;
    <br> &nbsp;
    <br> /*字母F*/
    <br> GLubyte f_rasters[12] = {0xc0,0xc0,0xc0,0xc0,0xc0,0xfc,
    <br> 0xfc,0xc0,0xc0,0xc0,0xff,0xff};
    <br> &nbsp;
    <br> /*字母I*/
    <br> GLubyte i_rasters[12] = {0xff,0xff,0x18,0x18,0x18,0x18,
    <br> 0x18,0x18,0x18,0x18,0xff,0xff};
    <br> &nbsp;
    <br> /*字母L*/
    <br> GLubyte l_rasters[12] = {0xff,0xff,0xc0,0xc0,0xc0,0xc0,
    <br> 0xc0,0xc0,0xc0,0xc0,0xc0,0xc0};
    <br> &nbsp;
    <br> /*字母E*/
    <br> GLubyte e_rasters[12] = {0xff,0xff,0xc0,0xc0,0xc0,0xff,
    <br> 0xff,0xc0,0xc0,0xc0,0xff,0xff};
    <br> &nbsp;
    <br> void myInit(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPixelStorei(GL_UNPACK_ALIGNMENT,1);//设置像素存储模式
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(1.0,1.0,1.0,1.0);//设置背景为白色
    <br> }
    <br> &nbsp;
    <br> void myDisplay()
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glColor3f(0.0,0.0,0.0);//设置像素颜色为黑色
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glRasterPos2i(20,20);//为像素指定位置
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制位图*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBitmap(8,12,0.0,0.0,14.0,0.0,f_rasters);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBitmap(8,12,0.0,0.0,14.0,0.0,i_rasters);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBitmap(8,12,0.0,0.0,14.0,0.0,l_rasters);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBitmap(8,12,0.0,0.0,14.0,0.0,e_rasters);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glFlush();
    <br> }
    <br> &nbsp;
    <br> void myReshape(int w,int h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,(GLsizei)w,(GLsizei)h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glOrtho(0,w,0,h,-1.0,1.0);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(500,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(100,100);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow(" BitMap");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制图形*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; myInit();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();//进入GLUT事件处理循环
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return 0;
    <br> }
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glBitmap（GLsizei width，GLsizei height，GLfloat xorig，GLfloat yorig，GLfloat xmove，GLfloat ymove，const GLubyte *bitmap）函数绘制一个位图。
    <br> width，height分别指定位图图像的宽度和高度。
    <br> xorig，yorig位图图像的原点位置。原点为位图的左下角。向右和向上为坐标轴的正向。
    <br> xmove，ymove绘制完位图后x，y相对于当前光栅的位移。
    <br> bitmap位图图像的地址。
    <br> 你可以改变此函数的参数，观察不同大小不同位置的效果。
    <br> 5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 动画
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    &nbsp;&nbsp;&nbsp; 到目前为止我们所做的图形全部都是静止的。而OpenGL的是一个可以制作大型3D图形、动画的工具。下面我们做一个可以旋转的立方体。
    <br> 例16：一个旋转的立方体
    <br> #include &lt;GL/glut.h&gt;
    <br> &nbsp;
    <br> GLfloat X&nbsp; = 10.0f;
    <br> GLfloat Y = 1.0f;
    <br> GLfloat Z = 5.0f;
    <br> &nbsp;
    <br> void myDisplay(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; GLfloat diffuse[] = {0.7,0.7,0.0,1.0};
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,1.0,1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*绘制立方体*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPushMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(X,1.0,0.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(Y,0.0,1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glRotatef(Z,0.0,0.0,1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glMaterialfv(GL_FRONT,GL_DIFFUSE,diffuse);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glutSolidCube(1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glPopMatrix();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glFlush();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutSwapBuffers();//交换当前窗口使用层的缓存
    <br> }
    <br> &nbsp;
    <br> void myReshape(int w,int h)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glViewport(0,0,w,h);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_PROJECTION);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gluOrtho2D(-1.5,1.5,-1.5,1.5);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; if(w &lt;= h)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-2.25,2.25,-2.25*h/w,2.25*h/w,-10.0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; else
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-2.25*w/h,2.25*w/h,-2.25,2.25,-10.0,10.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glMatrixMode(GL_MODELVIEW);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glLoadIdentity();
    <br> }
    <br> &nbsp;
    <br> void myAnimate(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X += 1.0;　
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y += 1.0;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z += 1.0；
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutPostRedisplay();//标记当前窗口需要重新绘制
    <br> &nbsp;
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(400,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(200,200);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow("color");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*绘制与显示*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutReshapeFunc(myReshape);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDisplay);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutIdleFunc(myAnimate);//设置全局空闲回调函数
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return(0);
    <br> }
    <br> myDisplay函数中有一个glutSwapBuffers()函数。此函数交换当前窗口使用层的缓存，它将后台缓存中的内容交换到前台缓存中，该函数执行的结果直到显示器垂直回行扫描后才看得到。必须使用双缓存结构，否则此函数不起任何作用。
    <br> myAanimate函数中glutPostRedisplay()函数标记当前窗口需要重新绘制。在glutMainLoop函数的事件处理循环的下一个反复中，将调用该窗口的显示回调函数重绘该窗口的图像层。
    <br> 在main函数中glutInitDisplayMode中为GLUT_DOUBLE，而我们以前的很多例子为GLUT_SINGLE。main函数中还调用了glutIdleFunc，此函数设置全局空闲回调函数。，从而使GLUT程序可以执行后台任务或连续动画。
    <br> 6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 菜单管理
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    &nbsp;&nbsp;&nbsp; 菜单是我们经常使用的工具，很方便，直观。本节讨论在OpenGL中如何进行菜单管理。
    <br> 例17：本例在蓝色的背景上绘制一个白色的正方形，在窗口内单击鼠标右键，弹出菜单，当选择不同菜单项时命令窗口会显示出是哪个菜单的哪个菜单相被激活。本例一个主菜单，主菜单有3个菜单条目及两个子菜单。两个子菜单都有3个菜单条目。
    <br> #include &lt;GL/glut.h&gt;
    <br> #include &lt;stdio.h&gt;
    <br> &nbsp;
    <br> int menu,subMenu1,subMenu2;
    <br> &nbsp;
    <br> /*在蓝色的背景上绘制一个白色的正方形*/
    <br> void myDraw(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClearColor(0.0,0.0,1.0,0.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glColor3f(1.0,1.0,1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glOrtho(-1.0,1.0,-1.0,1.0,-1.0,1.0);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glBegin(GL_POLYGON);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(-0.5,-0.5);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(-0.5,0.5);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.5,0.5);
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; glVertex2f(0.5,-0.5);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glEnd();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutSwapBuffers();
    <br> }
    <br> &nbsp;
    <br> /*写出当前是哪个菜单*/
    <br> void GetCurrentMenu(void)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; int nMenu;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; nMenu = glutGetMenu();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; if(nMenu == menu)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("The current menu is Main Menu.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp; if(nMenu == subMenu1)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("The current menu is SubMenu1.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp; if(nMenu == subMenu2)
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("The current menu is SubMenu2.\n");
    <br> }
    <br> &nbsp;
    <br> /*子菜单1*/
    <br> void SubMenuFunc1(int data)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; GetCurrentMenu();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; switch(data)
    <br> &nbsp;&nbsp;&nbsp;&nbsp; {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 1:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SubMenu1's item 1 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 2:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SubMenu1's item 2 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 3:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SubMenu1's item 3 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; }
    <br> }
    <br> &nbsp;
    <br> /*子菜单2*/
    <br> void SubMenuFunc2(int data)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; GetCurrentMenu();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; switch(data)
    <br> &nbsp;&nbsp;&nbsp;&nbsp; {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 1:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SubMenu2's item 1 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 2:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SubMenu2's item 2 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 3:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("SubMenu2's item 3 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; }
    <br> }
    <br> &nbsp;
    <br> /*主菜单*/
    <br> void MenuFunc(int data)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; GetCurrentMenu();
    <br> &nbsp;&nbsp;&nbsp;&nbsp; switch(data)
    <br> &nbsp;&nbsp;&nbsp;&nbsp; {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 1:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("MainMenu's item 1 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 2:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("MainMenu's item 2 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; case 3:
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("MainMenu's item 3 is triggered.\n");
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; }
    <br> }
    <br> &nbsp;
    <br> int main(int argc,char ** argv)
    <br> {
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*初始化*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInit(&amp;argc,argv);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowSize(500,400);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutInitWindowPosition(100,100);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建窗口*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutCreateWindow(" MENU");
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutDisplayFunc(myDraw);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建子菜单1并加入菜单条目*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; subMenu1 = glutCreateMenu(SubMenuFunc1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("SubMenu1's item1",1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("SubMenu1's item2",2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("SubMenu1's item3",3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAttachMenu(GLUT_RIGHT_BUTTON);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建子菜单2并加入菜单条目*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; subMenu2 = glutCreateMenu(SubMenuFunc2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("SubMenu2's item1",1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("SubMenu2's item2",2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("SubMenu2's item3",3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAttachMenu(GLUT_RIGHT_BUTTON);
    <br> &nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; /*创建主菜单并加入菜单条目及子菜单*/
    <br> &nbsp;&nbsp;&nbsp;&nbsp; menu = glutCreateMenu(MenuFunc);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("Item1",1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("Item2",2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddMenuEntry("Item3",3);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddSubMenu("SubMenu 1",subMenu1);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAddSubMenu("SubMenu 2",subMenu2);
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutAttachMenu(GLUT_RIGHT_BUTTON);&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <br> &nbsp;&nbsp;&nbsp;&nbsp; glutMainLoop();//进入GLUT事件处理循环
    <br> &nbsp;&nbsp;&nbsp;&nbsp; return 0;
    <br> }
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int glutCreateMenu（void（*func）（int value））创建一个新的弹出式菜单并返回一个唯一标识此菜单的整型表示符。func指明此菜单的功能。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int glutAddMenuEntry（char *name，int value）在当前菜单底部增加一个菜单条目。
    <br> name指定显示在新菜单条目上的ASCII码字符串。
    <br> value指定当选择该菜单条目时传递到菜单回调函数中的数值。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void glutAddSubMenu（char *name，int menu）在当前菜单的底部增加一个子菜单触发条目。
    <br> name指定显示在新菜单触发条目上的ASCII码字符串。
    <br> meun当选择该子菜单触发条目时弹出的子菜单的标识符。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void glutAttachMenu（int button）把当前窗口的一个鼠标按键与当前菜单的标识符联系起来。
    <br> button指明鼠标的哪个按键。GLUT_LEFT_BUTTON、GLUT_MIDDLE_BUTTON及GLUT_RIGHT_BUTTON，分别表明鼠标左、中及右键。
    <br> l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int glutGetMenu（void）获取当前菜单的标识符，如果没有菜单存在或前一个当前菜单被删除了，glutGetMenu则返回0值。
    <br> 7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 小结
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    本文介绍了有关OpenGL的基本知识，主要涉及颜色、绘制几何体、坐标变换、堆栈操作、显示列表、光照和材质、纹理映射、特殊效果、曲面和曲线的绘制、二次几何体绘制、像素操作、如何绘制动画物体及菜单管理。OpenGL查询函数、网格化以及互操作等许多方面都未涉及。即使涉及的有关方面也比较浅显。但是通过对本文及本文中例子的理解消化，你可以较容易的掌握OpenGL其他知识点。相信，通过一段时间的学习，你将很快得成为OpenGL的高手。
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    <br>
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    <br>
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);"> 
    <div>
     &nbsp;本文转自 21cnbao 51CTO博客，原文链接：http://blog.51cto.com/21cnbao/120261，如需转载请自行联系原作者
    </div> 
    <div>
     <br>
    </div> 
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    <br>
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    <br>
   </div> 
   <div style="font-family:'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;font-size:16px;color:rgb(51,51,51);">
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
