<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Device Tree（三）：代码分析【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://www.wowotech.net/linux_kenrel/dt-code-analysis.html    Device Tree（三）：代码分析    作者：linuxer&nbsp;发布于：2014-6-6 16:03 分类：统一设备模型    一、前言    ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/15/weixin_33728708_90128178.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Device Tree（三）：代码分析【转】</h1>
    <p class="post-meta">Nov 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">转自：<a href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">http://www.wowotech.net/linux_kenrel/dt-code-analysis.html</a></p> 
   <h2 style="font-size:21px;line-height:1.5;color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';">Device Tree（三）：代码分析</h2> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">作者：<a title="linuxer" href="http://www.wowotech.net/author/3" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">linuxer</a>&nbsp;发布于：2014-6-6 16:03 分类：<a href="http://www.wowotech.net/sort/device_model" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">统一设备模型</a></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">一、前言</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">Device Tree总共有三篇，分别是：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">1、为何要引入Device Tree，这个机制是用来解决什么问题的？（请参考<a href="http://www.wowotech.net/linux_kenrel/why-dt.html" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">引入Device Tree的原因</a>）</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">2、Device Tree的基础概念（请参考<a href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">DT基础概念</a>）</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">3、ARM linux中和Device Tree相关的代码分析（这是本文的主题）</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">本文主要内容是：以Device Tree相关的数据流分析为索引，对ARM linux kernel的代码进行解析。主要的数据流包括：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">1、初始化流程。也就是扫描dtb并将其转换成Device Tree Structure。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">2、传递运行时参数传递以及platform的识别流程分析</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">3、如何将Device Tree Structure并入linux kernel的设备驱动模型。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">注：本文中的linux kernel使用的是3.14版本。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">&nbsp;</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">二、如何通过Device Tree完成运行时参数传递以及platform的识别功能？</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">1、汇编部分的代码分析</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">linux/arch/arm/kernel/head.S文件定义了bootloader和kernel的参数传递要求：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags or dtb pointer.</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">目前的kernel支持旧的tag list的方式，同时也支持device tree的方式。r2可能是device tree binary file的指针（bootloader要传递给内核之前要copy到memory中），也可以能是tag list的指针。在ARM的汇编部分的启动代码中（主要是head.S和head-common.S），machine type ID和指向DTB或者atags的指针被保存在变量__machine_arch_type和__atags_pointer中，这么做是为了后续c代码进行处理。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">2、和device tree相关的setup_arch代码分析</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">具体的c代码都是在setup_arch中处理，这个函数是一个总的入口点。具体代码如下（删除了部分无关代码）：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>void __init setup_arch(char **cmdline_p)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; const struct machine_desc *mdesc;</p> 
    <p>……</p> 
    <p>&nbsp;&nbsp;&nbsp; mdesc = setup_machine_fdt(__atags_pointer);&nbsp;<br> &nbsp;&nbsp;&nbsp; if (!mdesc)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);&nbsp;<br> &nbsp;&nbsp;&nbsp; machine_desc = mdesc;&nbsp;<br> &nbsp;&nbsp;&nbsp; machine_name = mdesc-&gt;name;</p> 
    <p>……&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">对于如何确定HW platform这个问题，旧的方法是静态定义若干的machine描述符（struct machine_desc ），在启动过程中，通过machine type ID作为索引，在这些静态定义的machine描述符中扫描，找到那个ID匹配的描述符。在新的内核中，首先使用setup_machine_fdt来setup machine描述符，如果返回NULL，才使用传统的方法setup_machine_tags来setup machine描述符。传统的方法需要给出__machine_arch_type（bootloader通过r1寄存器传递给kernel的）和tag list的地址（用来进行tag parse）。__machine_arch_type用来寻找machine描述符；tag list用于运行时参数的传递。随着内核的不断发展，相信有一天linux kernel会完全抛弃tag list的机制。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">3、匹配platform（machine描述符）</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">setup_machine_fdt函数的功能就是根据Device Tree的信息，找到最适合的machine描述符。具体代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; const struct machine_desc *mdesc, *mdesc_best = NULL;</p> 
    <p>&nbsp;&nbsp;&nbsp; if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</p> 
    <p>&nbsp;&nbsp;&nbsp; mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);</p> 
    <p>&nbsp;&nbsp;&nbsp; if (!mdesc) {&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 出错处理&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; /* Change machine number to match the mdesc we're using */&nbsp;<br> &nbsp;&nbsp;&nbsp; __machine_arch_type = mdesc-&gt;nr;</p> 
    <p>&nbsp;&nbsp;&nbsp; return mdesc;&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">early_init_dt_scan函数有两个功能，一个是为后续的DTB scan进行准备工作，另外一个是运行时参数传递。具体请参考下面一个section的描述。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">of_flat_dt_match_machine是在machine描述符的列表中scan，找到最合适的那个machine描述符。我们首先看如何组成machine描述符的列表。和传统的方法类似，也是静态定义的。DT_MACHINE_START和MACHINE_END用来定义一个machine描述符。编译的时候，compiler会把这些machine descriptor放到一个特殊的段中（.arch.info.init），形成machine描述符的列表。machine描述符用下面的数据结构来标识（删除了不相关的member）：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>struct machine_desc {&nbsp;<br> &nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* architecture number&nbsp;&nbsp;&nbsp; */&nbsp;<br> &nbsp;&nbsp;&nbsp; const char *const&nbsp;&nbsp;&nbsp;&nbsp; *dt_compat;&nbsp;&nbsp;&nbsp; /* array of device tree 'compatible' strings&nbsp;&nbsp;&nbsp; */</p> 
    <p>……</p> 
    <p>&nbsp;&nbsp; };</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">nr成员就是过去使用的machine type ID。内核machine描述符的table有若干个entry，每个都有自己的ID。bootloader传递了machine type ID，指明使用哪一个machine描述符。目前匹配machine描述符使用compatible strings，也就是dt_compat成员，这是一个string list，定义了这个machine所支持的列表。在扫描machine描述符列表的时候需要不断的获取下一个machine描述符的compatible字符串的信息，具体的代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static const void * __init arch_get_next_mach(const char *const **match)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; static const struct machine_desc *mdesc = __arch_info_begin;&nbsp;<br> &nbsp;&nbsp;&nbsp; const struct machine_desc *m = mdesc;</p> 
    <p>&nbsp;&nbsp;&nbsp; if (m &gt;= __arch_info_end)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</p> 
    <p>&nbsp;&nbsp;&nbsp; mdesc++;&nbsp;<br> &nbsp;&nbsp;&nbsp; *match = m-&gt;dt_compat;&nbsp;<br> &nbsp;&nbsp;&nbsp; return m;&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">__arch_info_begin指向machine描述符列表第一个entry。通过mdesc++不断的移动machine描述符指针（Note：mdesc是static的）。match返回了该machine描述符的compatible string list。具体匹配的算法倒是很简单，就是比较字符串而已，一个是root node的compatible字符串列表，一个是machine描述符的compatible字符串列表，得分最低的（最匹配的）就是我们最终选定的machine type。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">4、运行时参数传递</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">运行时参数是在扫描DTB的chosen node时候完成的，具体的动作就是获取chosen node的bootargs、initrd等属性的value，并将其保存在全局变量（boot_command_line，initrd_start、initrd_end）中。使用tag list方法是类似的，通过分析tag list，获取相关信息，保存在同样的全局变量中。具体代码位于early_init_dt_scan函数中：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>bool __init early_init_dt_scan(void *params)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; if (!params)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 全局变量initial_boot_params指向了DTB的header*/&nbsp;<br> &nbsp;&nbsp;&nbsp; initial_boot_params = params;</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 检查DTB的magic，确认是一个有效的DTB */&nbsp;<br> &nbsp;&nbsp;&nbsp; if (be32_to_cpu(initial_boot_params-&gt;magic) != OF_DT_HEADER) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial_boot_params = NULL;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 扫描 /chosen node，保存运行时参数（bootargs）到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中 */&nbsp;<br> &nbsp;&nbsp;&nbsp; of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 扫描根节点，获取 {size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中 */&nbsp;<br> &nbsp;&nbsp;&nbsp; of_scan_flat_dt(early_init_dt_scan_root, NULL);</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 扫描DTB中的memory node，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。*/&nbsp;<br> &nbsp;&nbsp;&nbsp; of_scan_flat_dt(early_init_dt_scan_memory, NULL);</p> 
    <p>&nbsp;&nbsp;&nbsp; return true;&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">设定meminfo（该全局变量确定了物理内存的布局）有若干种途径：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">1、通过tag list（tag是ATAG_MEM）传递memory bank的信息。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">2、通过command line（可以用tag list，也可以通过DTB）传递memory bank的信息。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">3、通过DTB的memory node传递memory bank的信息。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">目前当然是推荐使用Device Tree的方式来传递物理内存布局信息。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">&nbsp;</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">三、初始化流程</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">在系统初始化的过程中，我们需要将DTB转换成节点是device_node的树状结构，以便后续方便操作。具体的代码位于setup_arch-&gt;unflatten_device_tree中。</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>void __init unflatten_device_tree(void)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; __unflatten_device_tree(initial_boot_params, &amp;of_allnodes,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; early_init_dt_alloc_memory_arch);</p> 
    <p>&nbsp;&nbsp;&nbsp; /* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */&nbsp;<br> &nbsp;&nbsp;&nbsp; of_alias_scan(early_init_dt_alloc_memory_arch);&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">我们用struct device_node 来抽象设备树中的一个节点，具体解释如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>struct device_node {&nbsp;<br> &nbsp;&nbsp;&nbsp; const char *name;－－－－－－－－－－－－－－－－－－－－－－device node name&nbsp;<br> &nbsp;&nbsp;&nbsp; const char *type;－－－－－－－－－－－－－－－－－－－－－－－对应device_type的属性&nbsp;<br> &nbsp;&nbsp;&nbsp; phandle phandle;－－－－－－－－－－－－－－－－－－－－－－－对应该节点的phandle属性&nbsp;<br> &nbsp;&nbsp;&nbsp; const char *full_name; －－－－－－－－－－－－－－－－从“/”开始的，表示该node的full path</p> 
    <p>&nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; property *properties;－－－－－－－－－－－－－该节点的属性列表&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; property *deadprops; －－－－－－－－－－如果需要删除某些属性，kernel并非真的删除，而是挂入到deadprops的列表&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *parent;－－－－－－parent、child以及sibling将所有的device node连接起来&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *child;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *sibling;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *next;&nbsp; －－－－－－－－通过该指针可以获取相同类型的下一个node&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; device_node *allnext;－－－－－－－通过该指针可以获取node global list下一个node&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; proc_dir_entry *pde;－－－－－－－－开放到userspace的proc接口信息&nbsp;<br> &nbsp;&nbsp;&nbsp; struct&nbsp;&nbsp;&nbsp; kref kref;－－－－－－－－－－－－－该node的reference count&nbsp;<br> &nbsp;&nbsp;&nbsp; unsigned long _flags;&nbsp;<br> &nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp; *data;&nbsp;<br> };</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">unflatten_device_tree函数的主要功能就是扫描DTB，将device node被组织成：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">1、global list。全局变量struct device_node *of_allnodes就是指向设备树的global list</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">2、tree。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">这些功能主要是在__unflatten_device_tree函数中实现，具体代码如下（去掉一些无关紧要的代码）：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static void __unflatten_device_tree(struct boot_param_header *blob,－－－需要扫描的DTB&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_node **mynodes,－－－－－－－－－global list指针&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * (*dt_alloc)(u64 size, u64 align))－－－－－－内存分配函数&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; unsigned long size;&nbsp;<br> &nbsp;&nbsp;&nbsp; void *start, *mem;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct device_node **allnextp = mynodes;</p> 
    <p>&nbsp;&nbsp;&nbsp; 此处删除了health check代码，例如检查DTB header的magic，确认blob的确指向一个DTB。</p> 
    <p>&nbsp;&nbsp;&nbsp; /* scan过程分成两轮，第一轮主要是确定device-tree structure的长度，保存在size变量中 */&nbsp;<br> &nbsp;&nbsp;&nbsp; start = ((void *)blob) + be32_to_cpu(blob-&gt;off_dt_struct);&nbsp;<br> &nbsp;&nbsp;&nbsp; size = (unsigned long)unflatten_dt_node(blob, 0, &amp;start, NULL, NULL, 0);&nbsp;<br> &nbsp;&nbsp;&nbsp; size = ALIGN(size, 4);</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 初始化的时候，并不是扫描到一个node或者property就分配相应的内存，实际上内核是一次性的分配了一大片内存，这些内存包括了所有的struct device_node、node name、struct property所需要的内存。*/&nbsp;<br> &nbsp;&nbsp;&nbsp; mem = dt_alloc(size + 4, __alignof__(struct device_node));&nbsp;<br> &nbsp;&nbsp;&nbsp; memset(mem, 0, size);</p> 
    <p>&nbsp;&nbsp;&nbsp; *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);&nbsp;&nbsp; //用来检验后面unflattening是否溢出</p> 
    <p>&nbsp;&nbsp;&nbsp; /* 这是第二轮的scan，第一次scan是为了得到保存所有node和property所需要的内存size，第二次就是实打实的要构建device node tree了 */&nbsp;<br> &nbsp;&nbsp;&nbsp; start = ((void *)blob) + be32_to_cpu(blob-&gt;off_dt_struct);&nbsp;<br> &nbsp;&nbsp;&nbsp; unflatten_dt_node(blob, mem, &amp;start, NULL, &amp;allnextp, 0);&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;</p> 
    <p>&nbsp;&nbsp;&nbsp; 此处略去校验溢出和校验OF_DT_END。&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">具体的scan是在unflatten_dt_node函数中，如果已经清楚地了解DTB的结构，其实代码很简单，这里就不再细述了。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">四、如何并入linux kernel的设备驱动模型</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">在linux kernel引入统一设备模型之后，bus、driver和device形成了设备模型中的铁三角。在驱动初始化的时候会将代表该driver的一个数据结构（一般是xxx_driver）挂入bus上的driver链表。device挂入链表分成两种情况，一种是即插即用类型的bus，在插入一个设备后，总线可以检测到这个行为并动态分配一个device数据结构（一般是xxx_device，例如usb_device），之后，将该数据结构挂入bus上的device链表。bus上挂满了driver和device，那么如何让device遇到“对”的那个driver呢？那么就要靠缘分了，也就是bus的match函数。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">上面是一段导论，我们还是回到Device Tree。导致Device Tree的引入ARM体系结构的代码其中一个最重要的原因的太多的静态定义的表格。例如：一般代码中会定义一个static struct platform_device *xxx_devices的静态数组，在初始化的时候调用platform_add_devices。这些静态定义的platform_device往往又需要静态定义各种resource，这导致静态表格进一步增大。如果ARM linux中不再定义这些表格，那么一定需要一个转换的过程，也就是说，系统应该会根据Device tree来动态的增加系统中的platform_device。当然，这个过程并非只是发生在platform bus上（具体可以参考<a href="http://www.wowotech.net/linux_kenrel/platform_device.html" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">“Platform Device”的设备</a>），也可能发生在其他的非即插即用的bus上，例如AMBA总线、PCI总线。一言以蔽之，如果要并入linux kernel的设备驱动模型，那么就需要根据device_node的树状结构（root是of_allnodes）将一个个的device node挂入到相应的总线device链表中。只要做到这一点，总线机制就会安排device和driver的约会。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">当然，也不是所有的device node都会挂入bus上的设备链表，比如cpus node，memory node，choose node等。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">1、cpus node的处理</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">这部分的处理可以参考setup_arch-&gt;arm_dt_init_cpu_maps中的代码，具体的代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>void __init arm_dt_init_cpu_maps(void)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; scan device node global list，寻找full path是“/cpus”的那个device node。cpus这个device node只是一个容器，其中包括了各个cpu node的定义以及所有cpu node共享的property。&nbsp;<br> &nbsp;&nbsp;&nbsp; cpus = of_find_node_by_path("/cpus");</p> 
    <p>&nbsp;</p> 
    <p>&nbsp;&nbsp;&nbsp; for_each_child_of_node(cpus, cpu) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 遍历cpus的所有的child node&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 hwid;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (of_node_cmp(cpu-&gt;type, "cpu"))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们只关心那些device_type是cpu的node&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</p> 
    <p><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (of_property_read_u32(cpu, "reg", &amp;hwid)) {&nbsp;&nbsp;&nbsp; 读取reg属性的值并赋值给hwid&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reg的属性值的8 MSBs必须设置为0，这是ARM CPU binding定义的。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hwid &amp; ~MPIDR_HWID_BITMASK)&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不允许重复的CPU id，那是一个灾难性的设定&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j = 0; j &lt; cpuidx; j++)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (WARN(tmp_map[j] == hwid, "Duplicate /cpu reg "&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "properties in the DT\n"))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p> 
    <p>数组tmp_map保存了系统中所有CPU的MPIDR值（CPU ID值），具体的index的编码规则是： tmp_map[0]保存了booting CPU的id值，其余的CPU的ID值保存在1～NR_CPUS的位置。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hwid == mpidr) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bootcpu_valid = true;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = cpuidx++;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp_map[i] = hwid;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>根据DTB中的信息设定cpu logical map数组。</p> 
    <p>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; cpuidx; i++) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_cpu_possible(i, true);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cpu_logical_map(i) = tmp_map[i];&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">要理解这部分的内容，需要理解ARM CUPs binding的概念，可以参考linux/Documentation/devicetree/bindings/arm目录下的CPU.txt文件的描述。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">2、memory的处理</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">这部分的处理可以参考setup_arch-&gt;setup_machine_fdt-&gt;early_init_dt_scan-&gt;early_init_dt_scan_memory中的代码。具体如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>int __init early_init_dt_scan_memory(unsigned long node, const char *uname,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int depth, void *data)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; char *type = of_get_flat_dt_prop(node, "device_type", NULL); 获取device_type属性值&nbsp;<br> &nbsp;&nbsp;&nbsp; __be32 *reg, *endp;&nbsp;<br> &nbsp;&nbsp;&nbsp; unsigned long l;</p> 
    <p>&nbsp;&nbsp;&nbsp; 在初始化的时候，我们会对每一个device node都要调用该call back函数，因此，我们要过滤掉那些和memory block定义无关的node。和memory block定义有的节点有两种，一种是node name是memory@形态的，另外一种是node中定义了device_type属性并且其值是memory。&nbsp;<br> &nbsp;&nbsp;&nbsp; if (type == NULL) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (depth != 1 || strcmp(uname, "memory@0") != 0)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br> &nbsp;&nbsp;&nbsp; } else if (strcmp(type, "memory") != 0)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p> 
    <p>&nbsp;&nbsp;&nbsp; 获取memory的起始地址和length的信息。有两种属性和该信息有关，一个是linux,usable-memory，不过最新的方式还是使用reg属性。</p> 
    <p>reg = of_get_flat_dt_prop(node, "linux,usable-memory", &amp;l);&nbsp;<br> &nbsp;&nbsp;&nbsp; if (reg == NULL)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reg = of_get_flat_dt_prop(node, "reg", &amp;l);&nbsp;<br> &nbsp;&nbsp;&nbsp; if (reg == NULL)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p> 
    <p>&nbsp;&nbsp;&nbsp; endp = reg + (l / sizeof(__be32));</p> 
    <p>reg属性的值是address，size数组，那么如何来取出一个个的address/size呢？由于memory node一定是root node的child，因此dt_root_addr_cells（root node的#address-cells属性值）和dt_root_size_cells（root node的#size-cells属性值）之和就是address，size数组的entry size。</p> 
    <p>&nbsp;&nbsp;&nbsp; while ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u64 base, size;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base = dt_mem_next_cell(dt_root_addr_cells, ®);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = dt_mem_next_cell(dt_root_size_cells, ®);</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; early_init_dt_add_memory_arch(base, size);&nbsp; 将具体的memory block信息加入到内核中。&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">&nbsp;</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">3、interrupt controller的处理</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">初始化是通过start_kernel-&gt;init_IRQ-&gt;machine_desc-&gt;init_irq()实现的。我们用S3C2416为例来描述interrupt controller的处理过程。下面是machine描述符的定义。</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>DT_MACHINE_START(S3C2416_DT, "Samsung S3C2416 (Flattened Device Tree)")&nbsp;<br> ……&nbsp;<br> &nbsp;&nbsp;&nbsp; .init_irq&nbsp;&nbsp;&nbsp; = irqchip_init,&nbsp;<br> ……&nbsp;<br> MACHINE_END</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">在driver/irqchip/irq-s3c24xx.c文件中定义了两个interrupt controller，如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>IRQCHIP_DECLARE(s3c2416_irq, "samsung,s3c2416-irq", s3c2416_init_intc_of);</p> 
    <p>IRQCHIP_DECLARE(s3c2410_irq, "samsung,s3c2410-irq", s3c2410_init_intc_of);</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">当然，系统中可以定义更多的irqchip，不过具体用哪一个是根据DTB中的interrupt controller node中的compatible属性确定的。在driver/irqchip/irqchip.c文件中定义了irqchip_init函数，如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>void __init irqchip_init(void)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; of_irq_init(__irqchip_begin);&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">__irqchip_begin就是所有的irqchip的一个列表，of_irq_init函数是遍历Device Tree，找到匹配的irqchip。具体的代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>void __init of_irq_init(const struct of_device_id *matches)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; struct device_node *np, *parent = NULL;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct intc_desc *desc, *temp_desc;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct list_head intc_desc_list, intc_parent_list;</p> 
    <p>&nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;intc_desc_list);&nbsp;<br> &nbsp;&nbsp;&nbsp; INIT_LIST_HEAD(&amp;intc_parent_list);</p> 
    <p>&nbsp;&nbsp;&nbsp; 遍历所有的node，寻找定义了interrupt-controller属性的node，如果定义了interrupt-controller属性则说明该node就是一个中断控制器。</p> 
    <p>&nbsp;&nbsp;&nbsp; for_each_matching_node(np, matches) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!of_find_property(np, "interrupt-controller", NULL) ||&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !of_device_is_available(np))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> 
    <p>分配内存并挂入链表，当然还有根据interrupt-parent建立controller之间的父子关系。对于interrupt controller，它也可能是一个树状的结构。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = kzalloc(sizeof(*desc), GFP_KERNEL);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (WARN_ON(!desc))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;dev = np;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;interrupt_parent = of_irq_find_parent(np);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (desc-&gt;interrupt_parent == np)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc-&gt;interrupt_parent = NULL;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_add_tail(&amp;desc-&gt;list, &amp;intc_desc_list);&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; 正因为interrupt controller被组织成树状的结构，因此初始化的顺序就需要控制，应该从根节点开始，依次递进到下一个level的interrupt controller。&nbsp;<br> &nbsp;&nbsp;&nbsp; while (!list_empty(&amp;intc_desc_list)) {&nbsp; intc_desc_list链表中的节点会被一个个的处理，每处理完一个节点就会将该节点删除，当所有的节点被删除，整个处理过程也就是结束了。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct of_device_id *match;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ret;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_irq_init_cb_t irq_init_cb;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最开始的时候parent变量是NULL，确保第一个被处理的是root interrupt controller。在处理完root node之后，parent变量被设定为root interrupt controller，因此，第二个循环中处理的是所有parent是root interrupt controller的child interrupt controller。也就是level 1（如果root是level 0的话）的节点。</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (desc-&gt;interrupt_parent != parent)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; －－－－－从链表中删除&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match = of_match_node(matches, desc-&gt;dev);－－－－－匹配并初始化&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (WARN(!match-&gt;data,－－－－－－－－－－match-&gt;data是初始化函数&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "of_irq_init: no init function for %s\n",&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match-&gt;compatible)) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_init_cb = (of_irq_init_cb_t)match-&gt;data;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent);－－－－－执行初始化函数&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ret) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 处理完的节点放入intc_parent_list链表，后面会用到&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_add_tail(&amp;desc-&gt;list, &amp;intc_parent_list);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于level 0，只有一个root interrupt controller，对于level 1，可能有若干个interrupt controller，因此要遍历这些parent interrupt controller，以便处理下一个level的child node。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; desc = list_first_entry_or_null(&amp;intc_parent_list,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof(*desc), list);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!desc) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_err("of_irq_init: children remain, but no parents\n");&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parent = desc-&gt;dev;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc);&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, list) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc);&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> err:&nbsp;<br> &nbsp;&nbsp;&nbsp; list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list_del(&amp;desc-&gt;list);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(desc);&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">只有该node中有interrupt-controller这个属性定义，那么linux kernel就会分配一个interrupt controller的描述符（struct intc_desc）并挂入队列。通过interrupt-parent属性，可以确定各个interrupt controller的层次关系。在scan了所有的Device Tree中的interrupt controller的定义之后，系统开始匹配过程。一旦匹配到了interrupt chip列表中的项次后，就会调用相应的初始化函数。如果CPU是S3C2416的话，匹配到的是irqchip的初始化函数是s3c2416_init_intc_of。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">OK，我们已经通过compatible属性找到了适合的interrupt controller，那么如何解析reg属性呢？我们知道，对于s3c2416的interrupt controller而言，其#interrupt-cells的属性值是4，定义为&lt;ctrl_num type="" ctrl_irq="" parent_irq=""&gt;。每个域的解释如下：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">（1）ctrl_num表示使用哪一种类型的interrupt controller，其值的解释如下：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 0 ... main controller&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 1 ... sub controller&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 2 ... second main controller</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">（2）parent_irq。对于sub controller，parent_irq标识了其在main controller的bit position。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">（3）ctrl_irq标识了在controller中的bit位置。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">（4）type标识了该中断的trigger type，例如：上升沿触发还是电平触发。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">为了更顺畅的描述后续的代码，我需要简单的介绍2416的中断控制器，其block diagram如下：</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><a href="http://www.wowotech.net/content/uploadfile/201406/1fae6636c0a85be88e3177559936bad420140606080337.gif" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;"><img title="2416intc" src="http://www.wowotech.net/content/uploadfile/201406/af17f85d8a8d3d689caf5c62fcb8ea1420140606080340.gif" alt="2416intc" width="821" height="376" style="border:none;"></a></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">53个Samsung2416的中断源被分成两种类型，一种是需要sub寄存器进行控制的，例如DMA，系统中的8个DMA中断是通过两级识别的，先在SRCPND寄存器中得到是DMA中断的信息，具体是哪一个channel的DMA中断需要继续查询SUBSRC寄存器。那些不需要sub寄存器进行控制的，例如timer，5个timer的中断可以直接从SRCPND中得到。&nbsp;<br> 中断MASK寄存器可以控制产生的中断是否要报告给CPU，当一个中断被mask的时候，虽然SRCPND寄存器中，硬件会set该bit，但是不会影响到INTPND寄存器，从而不会向CPU报告该中断。对于SUBMASK寄存器，如果该bit被set，也就是该sub中断被mask了，那么即便产生了对应的sub中断，也不会修改SRCPND寄存器的内容，只是修改SUBSRCPND中寄存器的内容。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">不过随着硬件的演化，更多的HW block加入到SOC中，这使得中断源不够用了，因此中断寄存器又被分成两个group，一个是group 1（开始地址是0X4A000000，也就是main controller了），另外一个是group2（开始地址是0X4A000040，叫做second main controller）。group 1中的sub寄存器的起始地址是0X4A000018（也就是sub controller）。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">了解了上面的内容后，下面的定义就比较好理解了：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static struct s3c24xx_irq_of_ctrl s3c2416_ctrl[] = {&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "intc", －－－－－－－－－－－main controller&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0,&nbsp;<br> &nbsp;&nbsp;&nbsp; }, {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "subintc", －－－－－－－－－sub controller&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0x18,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .parent = &amp;s3c_intc[0],&nbsp;<br> &nbsp;&nbsp;&nbsp; }, {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .name = "intc2", －－－－－－－－－－second main controller&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .offset = 0x40,&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> };</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">对于s3c2416而言，irqchip的初始化函数是s3c2416_init_intc_of，s3c2416_ctrl作为参数传递给了s3c_init_intc_of，大部分的处理都是在s3c_init_intc_of函数中完成的，由于这个函数和中断子系统非常相关，这里就不详述了，后续会有一份专门的文档描述之。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">4、GPIO controller的处理</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">暂不描述，后续会有一份专门的文档描述GPIO sub system。</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">5、machine初始化</p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">machine初始化的代码可以沿着start_kernel-&gt;rest_init-&gt;kernel_init-&gt;kernel_init_freeable-&gt;do_basic_setup-&gt;do_initcalls路径寻找。在do_initcalls函数中，kernel会依次执行各个initcall函数，在这个过程中，会调用customize_machine，具体如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static int __init customize_machine(void)&nbsp;<br> {&nbsp;<br><br> &nbsp;&nbsp;&nbsp; if (machine_desc-&gt;init_machine)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; machine_desc-&gt;init_machine();&nbsp;<br> &nbsp;&nbsp;&nbsp; else&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);&nbsp;<br><br> &nbsp;&nbsp;&nbsp; return 0;&nbsp;<br> }&nbsp;<br> arch_initcall(customize_machine);</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">在这个函数中，一般会调用machine描述符中的init_machine callback函数来把各种Device Tree中定义的platform device设备节点加入到系统（即platform bus的所有的子节点，对于device tree中其他的设备节点，需要在各自bus controller初始化的时候自行处理）。如果machine描述符中没有定义init_machine函数，那么直接调用of_platform_populate把所有的platform device加入到kernel中。对于s3c2416，其machine描述符中的init_machine callback函数就是s3c2416_dt_machine_init，代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static void __init s3c2416_dt_machine_init(void)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; of_platform_populate(NULL, --------传入NULL参数表示从root node开始scan</p> 
    <p>of_default_bus_match_table, s3c2416_auxdata_lookup, NULL);</p> 
    <p>&nbsp;&nbsp;&nbsp; s3c_pm_init(); －－－－－－－－power management相关的初始化&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">由此可见，最终生成platform device的代码来自of_platform_populate函数。该函数的逻辑比较简单，遍历device node global list中所有的node，并调用of_platform_bus_create处理，of_platform_bus_create函数代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static int of_platform_bus_create(struct device_node *bus,-------------要创建的那个device node&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct of_device_id *matches,-------要匹配的list&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct of_dev_auxdata *lookup,------附属数据&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent, bool strict)---------------parent指向父节点。strict是否要求完全匹配&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; const struct of_dev_auxdata *auxdata;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct device_node *child;&nbsp;<br> &nbsp;&nbsp;&nbsp; struct platform_device *dev;&nbsp;<br> &nbsp;&nbsp;&nbsp; const char *bus_id = NULL;&nbsp;<br> &nbsp;&nbsp;&nbsp; void *platform_data = NULL;&nbsp;<br> &nbsp;&nbsp;&nbsp; int rc = 0;</p> 
    <p>删除确保device node有compatible属性的代码。</p> 
    <p>&nbsp;&nbsp;&nbsp; auxdata = of_dev_lookup(lookup, bus);&nbsp; 在传入的lookup table寻找和该device node匹配的附加数据&nbsp;<br> &nbsp;&nbsp;&nbsp; if (auxdata) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus_id = auxdata-&gt;name;-----------------如果找到，那么就用附加数据中的静态定义的内容&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platform_data = auxdata-&gt;platform_data;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>ARM公司提供了CPU core，除此之外，它设计了AMBA的总线来连接SOC内的各个block。符合这个总线标准的SOC上的外设叫做ARM Primecell Peripherals。如果一个device node的compatible属性值是arm,primecell的话，可以调用of_amba_device_create来向amba总线上增加一个amba device。</p> 
    <p>&nbsp;&nbsp;&nbsp; if (of_device_is_compatible(bus, "arm,primecell")) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_amba_device_create(bus, bus_id, platform_data, parent);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; 如果不是ARM Primecell Peripherals，那么我们就需要向platform bus上增加一个platform device了</p> 
    <p>&nbsp;&nbsp;&nbsp; dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);&nbsp;<br> &nbsp;&nbsp;&nbsp; if (!dev || !of_match_node(matches, bus))&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p> 
    <p>&nbsp;&nbsp;&nbsp; 一个device node可能是一个桥设备，因此要重复调用of_platform_bus_create来把所有的device node处理掉。</p> 
    <p>&nbsp;&nbsp;&nbsp; for_each_child_of_node(bus, child) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_debug("&nbsp;&nbsp; create child: %s\n", child-&gt;full_name);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc) {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of_node_put(child);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; return rc;&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;">具体增加platform device的代码在of_platform_device_create_pdata中，代码如下：</p> 
   <blockquote style="background-image:none;border:2px solid rgb(239,239,239);line-height:1.6em;color:rgb(51,51,51);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"> 
    <p>static struct platform_device *of_platform_device_create_pdata(&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device_node *np,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *bus_id,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *platform_data,&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct device *parent)&nbsp;<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; struct platform_device *dev;</p> 
    <p>&nbsp;&nbsp;&nbsp; if (!of_device_is_available(np))---------check status属性，确保是enable或者OK的。&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</p> 
    <p>&nbsp;&nbsp;&nbsp; of_device_alloc除了分配struct platform_device的内存，还分配了该platform device需要的resource的内存（参考struct platform_device 中的resource成员）。当然，这就需要解析该device node的interrupt资源以及memory address资源。</p> 
    <p>&nbsp;&nbsp;&nbsp; dev = of_device_alloc(np, bus_id, parent);&nbsp;<br> &nbsp;&nbsp;&nbsp; if (!dev)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</p> 
    <p>设定platform_device 中的其他成员&nbsp;<br> &nbsp;&nbsp;&nbsp; dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(32);&nbsp;<br> &nbsp;&nbsp;&nbsp; if (!dev-&gt;dev.dma_mask)&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;&nbsp;<br> &nbsp;&nbsp;&nbsp; dev-&gt;dev.bus = &amp;platform_bus_type;&nbsp;<br> &nbsp;&nbsp;&nbsp; dev-&gt;dev.platform_data = platform_data;</p> 
    <p>&nbsp;&nbsp;&nbsp; if (of_device_add(dev) != 0) {------------------把这个platform device加入统一设备模型系统中&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platform_device_put(dev);&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;&nbsp;<br> &nbsp;&nbsp;&nbsp; }</p> 
    <p>&nbsp;&nbsp;&nbsp; return dev;&nbsp;<br> }</p> 
   </blockquote> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><em>原创文章，转发请注明出处。蜗窝科技</em>，<a href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html" rel="nofollow" style="color:rgb(51,51,51);font-weight:inherit;line-height:inherit;">www.wowotech.net。</a></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p style="color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';font-size:14px;"><br></p> 
   <p><font color="#666666"><span style="font-size:14px;">本文转自张昺华-sky博客园博客，原文链接：http://www.cnblogs.com/sky-heaven/p/6052949.html</span></font><span style="font-size:14px;color:rgb(102,102,102);font-family:'Microsoft YaHei', Arial, Helvetica, sans-serif, '宋体';">，如需转载请自行联系原作者</span></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
