<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>二叉树笔试题 « NotBeCN</title>
  <meta name="description" content="             题目：输入两棵二叉树A和B，判断树B是不是A的子结构                       bool IsChildTree(Node * father, Node * son){    if(father == NULL &amp;&amp; son == NULL)      ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/15/weixin_33919950_90119875.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">二叉树笔试题</h1>
    <p class="post-meta">Nov 15, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：输入两棵二叉树A和B，判断树B是不是A的子结构</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> IsChildTree(Node * father, Node *<span style="font-size:12px;line-height:1.5;"> son)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(father == NULL &amp;&amp; son ==<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(father == NULL &amp;&amp; son !=<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(father != NULL &amp;&amp; son ==<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
    
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果当前结点相同，判断左右子树是否子结构</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(father-&gt;data == son-&gt;<span style="font-size:12px;line-height:1.5;">data )
    {
         </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> IsChildTree(father-&gt;left, son-&gt;left) &amp;&amp; IsChildTree(father-&gt;right, son-&gt;<span style="font-size:12px;line-height:1.5;">right);
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">判断son子树是否是左子树的子结构</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(IsChildTree(father-&gt;<span style="font-size:12px;line-height:1.5;">left, son))
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">判断son子树是否是右子树的子结构</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(IsChildTree(father-&gt;<span style="font-size:12px;line-height:1.5;">right, son))
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：寻找最近公共祖先LCA（Lowest Common Ancestor）</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>Node* getLCA(Node* root, Node* x, Node*<span style="font-size:12px;line-height:1.5;"> y)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root == NULL) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> NULL;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(x == root || y ==<span style="font-size:12px;line-height:1.5;"> root)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> root;

    Node</span>* pleft = getLCA(root-&gt;<span style="font-size:12px;line-height:1.5;">left, x, y);
    Node</span>* pright = getLCA(root-&gt;<span style="font-size:12px;line-height:1.5;">right, x, y);

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pleft ==<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> pright;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pright ==<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> pleft;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> root;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">分别得到根节点root到结点x的路径和到结点y的路径，由于这个路径是从跟结点开始的，最低的共同父结点就是路径中的最后一个共同结点，即是LCA。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">得到根节点pHead到pNode的路径</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> GetNodePath(Node* pHead, Node* pNode, std::list&lt;Node*&gt;&amp;<span style="font-size:12px;line-height:1.5;"> path)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pHead ==<span style="font-size:12px;line-height:1.5;"> pNode)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;

    path.push_back(pHead);

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> found = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pHead-&gt;left !=<span style="font-size:12px;line-height:1.5;"> NULL)
        found </span>= GetNodePath(pHead-&gt;<span style="font-size:12px;line-height:1.5;">left, pNode, path);

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(!found &amp;&amp; pHead-&gt;<span style="font-size:12px;line-height:1.5;">right)
        found </span>= GetNodePath(pHead-&gt;<span style="font-size:12px;line-height:1.5;">right, pNode, path);

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(!<span style="font-size:12px;line-height:1.5;">found)
        path.pop_back();

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> found;
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> 从两个列表path1和path2中得到最后一个共同的结点</span>
TreeNode* LastCommonNode(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> std::list&lt;TreeNode*&gt;&amp; path1, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">const</span> std::list&lt;TreeNode*&gt;&amp;<span style="font-size:12px;line-height:1.5;"> path2)
{
    std::list</span>&lt;TreeNode*&gt;::const_iterator iterator1 =<span style="font-size:12px;line-height:1.5;"> path1.begin();
    std::list</span>&lt;TreeNode*&gt;::const_iterator iterator2 =<span style="font-size:12px;line-height:1.5;"> path2.begin();    
    TreeNode</span>* pLast =<span style="font-size:12px;line-height:1.5;"> NULL;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(iterator1 != path1.end() &amp;&amp; iterator2 !=<span style="font-size:12px;line-height:1.5;"> path2.end())
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(*iterator1 == *<span style="font-size:12px;line-height:1.5;">iterator2)
            pLast </span>= *<span style="font-size:12px;line-height:1.5;">iterator1;
        iterator1</span>++<span style="font-size:12px;line-height:1.5;">;
        iterator2</span>++<span style="font-size:12px;line-height:1.5;">;
    }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> pLast;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：寻找二叉搜索树（BST）的最低公共祖先（LCA）</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">利用BST的性质：从根结点开始搜索，当第一次遇到当前结点的值介于两个给定的结点值之间时，这个当前结点就是要找的LCA。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>Node* FindLCA(Node* root,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> x, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> y)
{
    Node </span>* t =<span style="font-size:12px;line-height:1.5;"> root;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(t-&gt;data &gt; x &amp;&amp; t-&gt;data &gt;<span style="font-size:12px;line-height:1.5;"> y)
            t </span>= t-&gt;<span style="font-size:12px;line-height:1.5;">left;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(t-&gt;data &lt; x &amp;&amp; t-&gt;data &lt;<span style="font-size:12px;line-height:1.5;"> y)
            t </span>= t-&gt;<span style="font-size:12px;line-height:1.5;">right;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> t;
    }
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：寻找BST中序遍历序列中第k个元素</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> findK(Node* p, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&amp;<span style="font-size:12px;line-height:1.5;"> k) 
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(!p || k &lt; <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;
    findK(p</span>-&gt;<span style="font-size:12px;line-height:1.5;">left, k);
    </span>--<span style="font-size:12px;line-height:1.5;"> k;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(k == <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">) 
    { 
        print p</span>-&gt;<span style="font-size:12px;line-height:1.5;">data;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;  
    } 
    findK(p</span>-&gt;<span style="font-size:12px;line-height:1.5;">right, k); 
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：求二叉树中相距最远的两个节点之间的距离</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">求两节点的最远距离，实际就是求二叉树的直径。本问题可以转化为求“二叉树每个节点的左右子树高度和的最大值”。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> TreeHeight(Node* root, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&amp;<span style="font-size:12px;line-height:1.5;"> max_distance)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root ==<span style="font-size:12px;line-height:1.5;"> NULL)
    {
        max_distance </span>= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> left_height,right_height;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;<span style="font-size:12px;line-height:1.5;">left)
        left_height </span>= TreeHeight(root-&gt;left,max_distance)+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span><span style="font-size:12px;line-height:1.5;">
        left_height </span>= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;<span style="font-size:12px;line-height:1.5;">right)
        right_height </span>= TreeHeight(root-&gt;right,max_distance)+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span><span style="font-size:12px;line-height:1.5;">
        right_height </span>= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> distance = left_height +<span style="font-size:12px;line-height:1.5;"> right_height;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (max_distance &lt; distance) max_distance =<span style="font-size:12px;line-height:1.5;"> distance;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> (left_height &gt; right_height ?<span style="font-size:12px;line-height:1.5;"> left_height : right_height);
}

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> TreeDiameter(Node*<span style="font-size:12px;line-height:1.5;"> root)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> max_distance = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span><span style="font-size:12px;line-height:1.5;">(root) TreeHeight(root, max_distance);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> max_distance;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：求二叉树中节点的最大距离：如果我们把二叉树看成一个图，父子节点之间的连线看成是双向的，定义“距离”为两节点之间边的个数。（此题就是求二叉树中相距最远的两个节点之间的距离，代码来自《编程之美》）</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">结点的定义</span>
typedef <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span><span style="font-size:12px;line-height:1.5;"> Node
{
    Node </span>*<span style="font-size:12px;line-height:1.5;"> left;
    Node </span>*<span style="font-size:12px;line-height:1.5;"> right;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> maxLeft;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> maxRight;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span><span style="font-size:12px;line-height:1.5;"> chValue;
}Node,</span>*<span style="font-size:12px;line-height:1.5;">pNode;

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">最大距离</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> maxLen = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">寻找二叉树中节点的最大距离</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> findMaxLength(Node*<span style="font-size:12px;line-height:1.5;"> root)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root == NULL) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果左子树为空，则该节点左边最长距离为0 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;left == NULL)     root-&gt;maxLeft = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果右子树为空，则该节点右边最长距离为0 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;right == NULL)    root-&gt;maxRight = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果左子树不为空，递归寻找左边最长距离 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;left != NULL)     findMaxLength(root-&gt;<span style="font-size:12px;line-height:1.5;">left);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果右子树不为空，递归寻找右边最长距离 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;right != NULL)    findMaxLength(root-&gt;<span style="font-size:12px;line-height:1.5;">right);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">计算左子树最长节点距离 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;left !=<span style="font-size:12px;line-height:1.5;"> NULL) 
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> tempMax = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;left-&gt;maxLeft &gt; root-&gt;left-&gt;<span style="font-size:12px;line-height:1.5;">maxRight)
            tempMax </span>= root-&gt;left-&gt;<span style="font-size:12px;line-height:1.5;">maxLeft;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> tempMax = root-&gt;left-&gt;<span style="font-size:12px;line-height:1.5;">maxRight;
        root</span>-&gt;maxLeft = tempMax+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">计算右子树最长节点距离 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;right !=<span style="font-size:12px;line-height:1.5;"> NULL) 
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> tempMax = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;right-&gt;maxLeft &gt; root-&gt;right-&gt;<span style="font-size:12px;line-height:1.5;">maxRight)
            tempMax </span>= root-&gt;right-&gt;<span style="font-size:12px;line-height:1.5;">maxLeft;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span> tempMax = root-&gt;right-&gt;<span style="font-size:12px;line-height:1.5;">maxRight;
        root</span>-&gt;maxRight = tempMax+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">更新最长距离 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;maxLeft+root-&gt;maxRight &gt;<span style="font-size:12px;line-height:1.5;"> maxLen)
        maxLen </span>= root-&gt;maxLeft+root-&gt;<span style="font-size:12px;line-height:1.5;">maxRight;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：重建二叉树，通过先序遍历和中序遍历的序列可以唯一确定一棵二叉树（通过中序和后序遍历的序列也可以唯一确定一棵二叉树，但是不能通过先序和后序遍历序列唯一确定二叉树）</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">通过先序遍历和中序遍历的序列重建二叉树</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> ReBuild(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span>* pPreOrder,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span>* pInOrder,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> nTreeLen,Node**<span style="font-size:12px;line-height:1.5;"> pRoot)
{
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">检查边界条件 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pPreOrder == NULL || pInOrder ==<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">获得前序遍历的第一个节点 </span>
    Node* temp = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> Node;
    temp</span>-&gt;data = *<span style="font-size:12px;line-height:1.5;">pPreOrder;
    temp</span>-&gt;left =<span style="font-size:12px;line-height:1.5;"> NULL;
    temp</span>-&gt;right =<span style="font-size:12px;line-height:1.5;"> NULL;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果节点为空，把当前节点复制到根节点 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(*pRoot == NULL) *pRoot =<span style="font-size:12px;line-height:1.5;"> temp;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">如果当前树长为1，那么已经是最后一个节点 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(nTreeLen == <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">寻找子树长度 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span>* pOrgInOrder =<span style="font-size:12px;line-height:1.5;"> pInOrder;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">char</span>* pLeftEnd =<span style="font-size:12px;line-height:1.5;"> pInOrder;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> nTempLen = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">找到左子树的结尾 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(*pPreOrder != *<span style="font-size:12px;line-height:1.5;">pLeftEnd)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pPreOrder == NULL || pLeftEnd ==<span style="font-size:12px;line-height:1.5;"> NULL)
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">记录临时长度，以免溢出 </span>
        nTempLen++<span style="font-size:12px;line-height:1.5;">;
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(nTempLen &gt; nTreeLen) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">break</span><span style="font-size:12px;line-height:1.5;">;
        pLeftEnd</span>++<span style="font-size:12px;line-height:1.5;">;
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">寻找左子树长度 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> nLeftLen = (<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>)(pLeftEnd-<span style="font-size:12px;line-height:1.5;">pOrgInOrder);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">寻找右子树长度 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> nRightLen = nTreeLen-nLeftLen-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">重建左子树 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(nLeftLen &gt; <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">)
        ReBuild(pPreOrder</span>+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>,pInOrder,nLeftLen,&amp;((*pRoot)-&gt;<span style="font-size:12px;line-height:1.5;">left));

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">重建右子树 </span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(nRightLen &gt; <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">)
        ReBuild(pPreOrder</span>+nLeftLen+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>,pInOrder+nLeftLen+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>,nRightLen,&amp;((*pRoot)-&gt;<span style="font-size:12px;line-height:1.5;">right));
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：输入一个整数和一棵二元树。从树的根结点开始往下访问一直到叶结点所经过的所有结点形成一条路径。打印出和与输入整数相等的所有路径。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">例如输入整数22和如下二元树</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp; 12<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;7&nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">则打印出两条路径：10, 12和10, 5, 7。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">分析：这是百度的一道笔试题，考查对树这种基本数据结构以及递归函数的理解。 当访问到某一结点时，把该结点添加到路径上，并累加当前结点的值。如果当前结点为叶结点并且当前路径的和刚好等于输入的整数，则当前的路径符合要求，把它打印出来。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到父结点。因此我们在函数退出之前要在路径上删除当前结点并减去当前结点的值，以确保返回父结点时路径刚好是根结点到父结点的路径。我们不难看出保存路径的数据结构实际上是一个栈结构，因为路径要与递归调用状态一致，而递归调用本质就是一个压栈和出栈的过程。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>#include &lt;iostream&gt;<span style="font-size:12px;line-height:1.5;">
#include </span>&lt;vector&gt;
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">using</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">namespace</span><span style="font-size:12px;line-height:1.5;"> std;

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span><span style="font-size:12px;line-height:1.5;"> Node
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> value;
    Node</span>*<span style="font-size:12px;line-height:1.5;"> left;
    Node</span>*<span style="font-size:12px;line-height:1.5;"> right;
    Node(){ left </span>= NULL; right =<span style="font-size:12px;line-height:1.5;"> NULL; }
    Node(</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> v){ value = v; left = NULL; right =<span style="font-size:12px;line-height:1.5;"> NULL; }
};

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> findpath(Node* root,vector&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;&amp; nodes,<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> sum)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root == NULL) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;
    nodes.push_back(root</span>-&gt;<span style="font-size:12px;line-height:1.5;">value);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;left == NULL &amp;&amp; root-&gt;right ==<span style="font-size:12px;line-height:1.5;"> NULL)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;value ==<span style="font-size:12px;line-height:1.5;"> sum)
        {
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> i=<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>; i&lt;nodes.size(); i++<span style="font-size:12px;line-height:1.5;">)
                cout</span>&lt;&lt;nodes[i]&lt;&lt;<span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span> <span style="color:rgb(128,0,0);font-size:12px;line-height:1.5;">"</span><span style="font-size:12px;line-height:1.5;">;
            cout</span>&lt;&lt;<span style="font-size:12px;line-height:1.5;">endl;
        }
    }
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span><span style="font-size:12px;line-height:1.5;">
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;left !=<span style="font-size:12px;line-height:1.5;"> NULL)
        {
            findpath(root</span>-&gt;left,nodes,sum-root-&gt;<span style="font-size:12px;line-height:1.5;">value);
        }
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(root-&gt;right !=<span style="font-size:12px;line-height:1.5;"> NULL)
        {
            findpath(root</span>-&gt;right,nodes,sum-root-&gt;<span style="font-size:12px;line-height:1.5;">value);
        }
    }
    nodes.pop_back();
}

</span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> main()
{
    Node </span>*<span style="font-size:12px;line-height:1.5;">tmp ;
    Node</span>* root = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> Node(<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">10</span><span style="font-size:12px;line-height:1.5;">);
    tmp </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> Node(<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">5</span><span style="font-size:12px;line-height:1.5;">);
    root</span>-&gt;left =<span style="font-size:12px;line-height:1.5;"> tmp ;
    tmp </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> Node(<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">12</span><span style="font-size:12px;line-height:1.5;">);
    root</span>-&gt;right =<span style="font-size:12px;line-height:1.5;"> tmp;
    tmp </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> Node(<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">4</span><span style="font-size:12px;line-height:1.5;">);
    root</span>-&gt;left-&gt;left =<span style="font-size:12px;line-height:1.5;"> tmp;
    tmp </span>= <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span> Node(<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">7</span><span style="font-size:12px;line-height:1.5;">);
    root</span>-&gt;left-&gt;right =<span style="font-size:12px;line-height:1.5;"> tmp;
    vector</span>&lt;<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>&gt;<span style="font-size:12px;line-height:1.5;"> v;
    findpath(root,v,</span><span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">22</span><span style="font-size:12px;line-height:1.5;">); 
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
} </span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：输入一个整数数组，判断该数组是不是某二元查找树的后序遍历的结果。如果是返回true，否则返回false。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">例如输入5、7、6、9、11、10、8，由于这一整数序列是如下树的后序遍历结果：</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; \<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; 10<br> &nbsp;&nbsp;&nbsp;&nbsp; / \&nbsp;&nbsp;&nbsp; &nbsp;/&nbsp; \<br> &nbsp;&nbsp;&nbsp;5&nbsp;&nbsp; 7&nbsp; 9&nbsp;&nbsp;&nbsp; 11</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">因此返回true。如果输入7、4、6、5，没有哪棵树的后序遍历的结果是这个序列，因此返回false。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">分析：在后续遍历得到的序列中，最后一个元素为树的根结点。从头开始扫描这个序列，比根结点小的元素都应该位于序列的左半部分；从第一个大于根节点开始到根结点前面的一个元素为止，所有元素都应该大于根结点，因为这部分元素对应的是树的右子树。根据这样的划分，把序列划分为左右两部分，我们递归地确认序列的左、右两部分是不是都是二元查找树。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> verifySquenceOfBST(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> squence[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> length)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(squence == NULL || length &lt;= <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> root of a BST is at the end of post order traversal squence</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> root = squence[length - <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">];

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> the nodes in left sub-tree are less than the root</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> i = <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(; i &lt; length - <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; ++<span style="font-size:12px;line-height:1.5;"> i)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(squence[i] &gt;<span style="font-size:12px;line-height:1.5;"> root)
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">break</span><span style="font-size:12px;line-height:1.5;">;
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> the nodes in the right sub-tree are greater than the root</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> j =<span style="font-size:12px;line-height:1.5;"> i;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">for</span>(; j &lt; length - <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span>; ++<span style="font-size:12px;line-height:1.5;"> j)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(squence[j] &lt;<span style="font-size:12px;line-height:1.5;"> root)
            </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">;
    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> verify whether the left sub-tree is a BST</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> left = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(i &gt; <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span><span style="font-size:12px;line-height:1.5;">)
        left </span>=<span style="font-size:12px;line-height:1.5;"> verifySquenceOfBST(squence, i);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> verify whether the right sub-tree is a BST</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span> right = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(i &lt; length - <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">)
        right </span>= verifySquenceOfBST(squence + i, length - i - <span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> (left &amp;&amp;<span style="font-size:12px;line-height:1.5;"> right);
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：怎样编写一个程序，把一个有序整数数组放到二叉搜索树中？</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">分析：本题考察二叉搜索树的建树方法。关于树的算法设计一定要联想到递归，因为树本身就是递归的定义。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>Node* array_to_tree(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> array[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> start, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> end)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (start &gt; end) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> NULL;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> m = start + (end-start)/<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">2</span><span style="font-size:12px;line-height:1.5;">;
    Node</span>* root = <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">new</span><span style="font-size:12px;line-height:1.5;"> Node(array[m]);
    root</span>-&gt;left = array_to_tree(array, start, m-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
    root</span>-&gt;right = array_to_tree(array, m+<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">, end);
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> root;
}

Node</span>* array2Tree(<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span> array[], <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span><span style="font-size:12px;line-height:1.5;"> n)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> array_to_tree(array,<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">0</span>,n-<span style="color:rgb(128,0,128);font-size:12px;line-height:1.5;">1</span><span style="font-size:12px;line-height:1.5;">);
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">题目：输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。要求不能创建任何新的结点，只调整指针的指向。比如将二元查找树</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp;&nbsp; \<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; \&nbsp;&nbsp;&nbsp;&nbsp; /　 \<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　4&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp; 12 　16</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">转换成双向链表 4=6=8=10=12=14=16。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">　　分析：本题是微软的面试题。很多与树相关的题目都是用递归的思路来解决，本题也不例外。下面我们用两种不同的递归思路来分析。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">　　思路一：当我们到达某一结点准备调整以该结点为根结点的子树时，先调整其左子树，将左子树转换成一个排好序的左子链表，再调整其右子树转换右子链表。最后链接左子链表的最右结点（左子树的最大结点）、当前结点和右子链表的最左结点（右子树的最小结点）。从树的根结点开始递归调整所有结点。</p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">　　思路二：我们可以中序遍历整棵树。按照这个方式遍历树，比较小的结点先访问。如果我们每访问一个结点，假设之前访问过的结点已经调整成一个排序双向链表，我们再把调整当前结点的指针将其链接到链表的末尾。当所有结点都访问过之后，整棵树也就转换成一个排序双向链表了。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre>    <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">定义二元查找树结点的数据结构如下：</span>
   <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">struct</span> BSTreeNode <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> a node in the binary search tree</span>
<span style="font-size:12px;line-height:1.5;">    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">int</span>        m_nValue; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> value of node</span>
        BSTreeNode *m_pLeft; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> left child of node</span>
        BSTreeNode *m_pRight; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> right child of node</span>
    };</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">思路一对应的代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Covert a sub binary-search-tree into a sorted double-linked list
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Input: pNode - the head of the sub tree
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">        asRight - whether pNode is the right child of its parent
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Output: if asRight is true, return the least node in the sub-tree
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">         else return the greatest node in the sub-tree</span>
BSTreeNode* ConvertNode(BSTreeNode* pNode, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">bool</span><span style="font-size:12px;line-height:1.5;"> asRight)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(!pNode) <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> NULL;

    BSTreeNode </span>*pLeft =<span style="font-size:12px;line-height:1.5;"> NULL;
    BSTreeNode </span>*pRight =<span style="font-size:12px;line-height:1.5;"> NULL;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Convert the left sub-tree</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pNode-&gt;<span style="font-size:12px;line-height:1.5;">m_pLeft)
        pLeft </span>= ConvertNode(pNode-&gt;m_pLeft, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">false</span><span style="font-size:12px;line-height:1.5;">);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Connect the greatest node in the left sub-tree to the current node</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span><span style="font-size:12px;line-height:1.5;">(pLeft)
    {
        pLeft</span>-&gt;m_pRight = pNode; <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">m_pRight pointer works as the "next" pointer</span>
        pNode-&gt;m_pLeft = pLeft;  <span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">m_pLeft pointer works as the "previous" pointer</span>
<span style="font-size:12px;line-height:1.5;">    }

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Convert the right sub-tree</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pNode-&gt;<span style="font-size:12px;line-height:1.5;">m_pRight)
        pRight </span>= ConvertNode(pNode-&gt;m_pRight, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Connect the least node in the right sub-tree to the current node</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span><span style="font-size:12px;line-height:1.5;">(pRight)
    {
        pNode</span>-&gt;m_pRight =<span style="font-size:12px;line-height:1.5;"> pRight;
        pRight</span>-&gt;m_pLeft =<span style="font-size:12px;line-height:1.5;"> pNode;
    }

    BSTreeNode </span>*pTemp =<span style="font-size:12px;line-height:1.5;"> pNode;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> If the current node is the right child of its parent, 
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> return the least node in the tree whose root is the current node</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span><span style="font-size:12px;line-height:1.5;">(asRight)
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(pTemp-&gt;<span style="font-size:12px;line-height:1.5;">m_pLeft)
            pTemp </span>= pTemp-&gt;<span style="font-size:12px;line-height:1.5;">m_pLeft;
    }
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> If the current node is the left child of its parent, 
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> return the greatest node in the tree whose root is the current node</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">else</span><span style="font-size:12px;line-height:1.5;">
    {
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(pTemp-&gt;<span style="font-size:12px;line-height:1.5;">m_pRight)
            pTemp </span>= pTemp-&gt;<span style="font-size:12px;line-height:1.5;">m_pRight;
    }

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> pTemp;
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Covert a binary search tree into a sorted double-linked list
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Input: the head of tree
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Output: the head of sorted double-linked list</span>
BSTreeNode* Convert(BSTreeNode*<span style="font-size:12px;line-height:1.5;"> pHeadOfTree)
{
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> As we want to return the head of the sorted double-linked list,
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> we set the second parameter to be true</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span> ConvertNode(pHeadOfTree, <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">true</span><span style="font-size:12px;line-height:1.5;">);
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">思路二对应的代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-size:15px;font-family:'Courier New';"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Covert a sub binary-search-tree into a sorted double-linked list
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Input: pNode - the head of the sub tree
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">        pLastNodeInList - the tail of the double-linked list</span>
<span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">void</span> ConvertNode(BSTreeNode* pNode, BSTreeNode*&amp;<span style="font-size:12px;line-height:1.5;"> pLastNodeInList)
{
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pNode ==<span style="font-size:12px;line-height:1.5;"> NULL)
        </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;">;

    BSTreeNode </span>*pCurrent =<span style="font-size:12px;line-height:1.5;"> pNode;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Convert the left sub-tree</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (pCurrent-&gt;m_pLeft !=<span style="font-size:12px;line-height:1.5;"> NULL)
        ConvertNode(pCurrent</span>-&gt;<span style="font-size:12px;line-height:1.5;">m_pLeft, pLastNodeInList);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Put the current node into the double-linked list</span>
    pCurrent-&gt;m_pLeft =<span style="font-size:12px;line-height:1.5;"> pLastNodeInList; 
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span>(pLastNodeInList !=<span style="font-size:12px;line-height:1.5;"> NULL)
        pLastNodeInList</span>-&gt;m_pRight =<span style="font-size:12px;line-height:1.5;"> pCurrent;

    pLastNodeInList </span>=<span style="font-size:12px;line-height:1.5;"> pCurrent;

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Convert the right sub-tree</span>
    <span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">if</span> (pCurrent-&gt;m_pRight !=<span style="font-size:12px;line-height:1.5;"> NULL)
        ConvertNode(pCurrent</span>-&gt;<span style="font-size:12px;line-height:1.5;">m_pRight, pLastNodeInList);
}

</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Covert a binary search tree into a sorted double-linked list
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Input: pHeadOfTree - the head of tree
</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Output: the head of sorted double-linked list</span>
BSTreeNode* Convert(BSTreeNode*<span style="font-size:12px;line-height:1.5;"> pHeadOfTree)
{
    BSTreeNode </span>*pLastNodeInList =<span style="font-size:12px;line-height:1.5;"> NULL;
    ConvertNode(pHeadOfTree, pLastNodeInList);

    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> Get the head of the double-linked list
    </span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;">//</span><span style="color:rgb(0,128,0);font-size:12px;line-height:1.5;"> m_pLeft pointer works as the "previous" pointer in the double-linked list</span>
    BSTreeNode *pHeadOfList =<span style="font-size:12px;line-height:1.5;"> pLastNodeInList;
    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">while</span>(pHeadOfList &amp;&amp; pHeadOfList-&gt;<span style="font-size:12px;line-height:1.5;">m_pLeft)
        pHeadOfList </span>= pHeadOfList-&gt;<span style="font-size:12px;line-height:1.5;">m_pLeft;

    </span><span style="color:rgb(0,0,255);font-size:12px;line-height:1.5;">return</span><span style="font-size:12px;line-height:1.5;"> pHeadOfList;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="font-size:12px;line-height:1.5;"><a title="复制代码" style="text-decoration:underline;border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;">参考：<br> 《编程之美》<br> 《剑指Offer》<a href="http://zhedahht.blog.163.com/" rel="nofollow" style="color:rgb(0,0,0);">http://zhedahht.blog.163.com</a></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"><br></p> 
   <p><font color="#333333"><span style="font-size:15px;">&nbsp; &nbsp; 本文转自阿凡卢博客园博客，原文链接：http://www.cnblogs.com/luxiaoxun/archive/2012/11/11/2765116.html</span></font><span style="font-size:15px;color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <div>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
