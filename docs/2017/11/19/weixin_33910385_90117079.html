<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ES6 Generators并发 « NotBeCN</title>
  <meta name="description" content="             ES6 Generators系列：        ES6 Generators基本概念     深入研究ES6 Generators     ES6 Generators的异步应用     ES6 Generators并发       　　如果你已经读过这个系列的前三篇文章，那么你肯定对...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/19/weixin_33910385_90117079.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">ES6 Generators并发</h1>
    <p class="post-meta">Nov 19, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">ES6 Generators系列：</h4> 
   <ol style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6372809.html%20" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators基本概念</a></li> 
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6379404.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">深入研究ES6 Generators</a></li> 
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6493291.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators的异步应用</a></li> 
    <li style="list-style:decimal;"><a href="http://www.cnblogs.com/jaxu/p/6592210.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators并发</a></li> 
   </ol>
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　如果你已经读过这个系列的前三篇文章，那么你肯定对ES6 generators非常了解了。希望你能从中有所收获并让generator发挥它真正的作用。最后我们要探讨的这个主题可能会让你血脉喷张，让你绞尽脑汁（说实话，写这篇文章让我很费脑子）。花点时间看下文章中的这些例子，相信对你还是很有帮助的。在学习上的投资会让你将来受益无穷。我完全相信，在未来，JS中那些复杂的异步能力将起源于我这里的一些想法。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">CSP（Communicating Sequential Processes）</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　首先，我写这一系列文章完全是受<a href="http://github.com/swannodette" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Nolen</a>&nbsp;<a href="http://twitter.com/swannodette" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">@swannodette</a>出色工作的启发。说真的，他写的所有文章都值得去读一读。我这里有一些链接可以分享给你：</p> 
   <ul style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">
    <li style="list-style:disc;"><a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Communicating Sequential Processes</a></li> 
    <li style="list-style:disc;"><a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators Deliver Go Style Concurrency</a></li> 
    <li style="list-style:disc;"><a href="http://swannodette.github.io/2013/07/31/extracting-processes/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Extracting Processes</a></li> 
   </ul>
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　好了，让我们正式开始对这个主题的探讨。我不是一个从具有Clojure（<a href="http://baike.baidu.com/link?url=g0tHN74Qu1FTqMSQPLHvIzk8rLntwjb502-qUNOzx8i5i0lT6mrAi9QGhJz_z7z6C0X-zFDqCQkDA47nNaBzhq" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Clojure</a>是一种运行在Java平台上的 Lisp 方言）背景转投到JS阵营的程序员，而且我也没有任何Go或者ClojureScript的经验。我发现自己在读这些文章的时候很快就会失去兴趣，因此我不得不做很多的实验并从中了解到一些有用的东西。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在这个过程中，我觉得我已经有了一些相同的思想，并追求同样的目标，而这些都源自于一个不那么古板的思维方式。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我尝试创建了一个更简单的Go风格的CSP（以及ClojureScript core.async）APIs，同时我希望能保留大部分的底层功能。也许有大神会看到我文章中遗漏的地方，这完全有可能。如果真是这样的话，我希望我的探索能够得到进一步的发展和演变，而我也将和大家一起来分享这个过程！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">详解CSP原理（一点点）</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　到底什么是CSP？说它是"communicating"，"Sequential"，"processes"到底是什么意思呢？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　首先，CSP一词源自于Tony Hoare所著的“<a href="http://www.usingcsp.com/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Communicating Sequential Processes</a>”一书。里面全是有关CS的理论，如果你对学术方面的东西感兴趣的话，这本书绝对值得一读。我决不打算以一种让人难以理解的，深奥的，计算机科学的方式来阐述这个主题，而是会以一种轻松的非正式的方式来进行。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　那我们就从"Sequential"开始吧！这部分你应该已经很熟悉了。这是另外一种谈论有关单线程和ES6 generators异步风格代码的方式。我们来回忆一下generators的语法：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;">
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">main() {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> x = yield 1<span style="line-height:1.5;">;
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> y =<span style="line-height:1.5;"> yield x;
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> z = yield (y * 2<span style="line-height:1.5;">);
}</span></pre>
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　上面代码中的每一条语句都会按顺序一个一个地执行。<strong>Yield</strong>关键字标明了代码中被阻塞的点（只能被generator函数自己阻塞，外部代码不能阻塞generator函数的执行），但是不会改变<strong>*main()</strong>函数中代码的执行顺序。这段代码很简单！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　接下来我们来讨论一下"processes"。这个是什么呢？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　基本上，generator函数有点像一个虚拟的"process"，它是我们程序的一个独立的部分，如果JavaScript允许，它完全可以与程序的其它部分并行执行。这听起来似乎有点儿荒唐！如果generator函数访问共享内存（即，如果它访问除了自己内部定义的局部变量之外的“自由变量”），那么它就不是一个独立的部分。现在我们假设有一个不访问外部变量的generator函数（在FP（Functional Programming函数式编程）的理论中我们将它称之为一个"combinator"），因此从理论上来说它可以在自己的process中运行，或者说作为自己的process来运行。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　但是我们说的是"processes"，注意这个单词用的是复数，这是因为会存在两个或多个process在同一时间运行。换句话说，两个或多个generators函数会被放到一起来协同工作，通常是为了完成一项较大的任务。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　为什么要用多个单独的generator函数，而不是把它们都放到一个generator函数里呢？一个最重要的原因就是：<strong>功能和关注点的分离</strong>。对于一个任务XYZ来说，如果你将它分解成子任务X，Y和Z，那么在每个子任务自己的generator函数中来实现功能将会使代码更容易理解和维护。这和将函数<strong>XYZ()</strong>拆分成<strong>X()</strong>，<strong>Y()</strong>，和<strong>Z()</strong>，然后在<strong>X()</strong>中调用<strong>Y()</strong>，在<strong>Y()</strong>中调用<strong>Z()</strong>是一样的道理。我们将函数分解成一个个独立的子函数，降低代码的耦合度，从而使程序更加容易维护。</p> 
   <h4 style="font-size:14px;color:rgb(51,51,51);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">对于多个generators函数来说我们也可以做到这一点</h4> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　这就要说到"communicating"了。这个又是什么呢？就是合作。如果我们将多个generators函数放在一些协同工作，它们彼此之间需要一个通信信道（不仅仅是访问共享的作用域，而是一个真正的可以被它们访问的独占式共享通信信道）。这个通信信道是什么呢？不管你发送什么内容（数字，字符串等），事实上你都不需要通过信道发送消息来进行通信。通信会像合作那样简单，就像将程序的控制权从一个地方转移到另外一个地方。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　为什么需要转移控制？这主要是因为JS是单线程的，意思是说在任意给定的一个时间片段内只会有一个程序在运行，而其它程序都处在暂停状态。也就是说其它程序都处在它们各自任务的中间状态，不过只是被暂停执行，必要时会恢复并继续运行。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　任意独立的"processes"之间可以神奇地进行通信和合作，这听起来有点不靠谱。这种解耦的想法是好的，但是有点不切实际。相反，似乎任何一个成功的CSP的实现都是对那些问题领域中已存在的、众所周知的逻辑集的有意分解，其中每个部分都被特殊设计过从而使得各部分之间都能良好工作。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　或许我的理解完全是错的，但是我还没有看到任何一个切实可行的方法，能够让两个随机给定的generator函数可以以某种方式轻易地聚合在一起形成CSP对。它们都需要被设计成能够与其它部分一起工作，需要遵照彼此间的通信协议等等。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">JS中的CSP</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在将CSP的理论应用到JS中，有一些非常有趣的探索。前面提到的David Nolen，他有几个很有趣的项目，包括<a href="https://github.com/swannodette/om" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Om</a>，以及<a href="http://www.hakkalabs.co/articles/core-async-a-clojure-library/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">core.async</a>。<a href="http://koajs.com/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Koa</a>库（node.js）主要通过它的<strong>use(..)</strong>方法体现了这一点。而另外一个对core.async/Go CSP API十分忠实的库是<a href="https://github.com/ubolonton/js-csp" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">js-csp</a>。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　你确实应该去看看这些伟大的项目，看看其中的各种方法和例子，了解它们是如何在JS中实现CSP的。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">异步的runner(..)：设计CSP</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　因为我一直在努力探索将并行的CSP模式应用到我自己的JS代码中，所以对于使用CSP来扩展我自己的异步流程控制库<a href="http://github.com/getify/asynquence" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">asynquence</a>来说就是一件顺理成章的事。我写过的runner(..)插件（看上一篇文章：<a href="http://www.cnblogs.com/jaxu/p/6493291.html" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">ES6 Generators的异步应用</a>）就是用来处理generators函数的异步运行的，我发现它可以很容易被扩展用来处理多generators函数在同一时间运行，<a href="https://github.com/getify/asynquence/tree/master/contrib#csp-style-concurrency" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">就像CSP的方式那样</a>。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我要解决的第一个设计问题是：如何才能知道哪个generator函数将获得下一个控制权？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　要解决各个generators函数之间的消息或控制权的传递，每个generator函数都必须拥有一个能让其它generators函数知道的ID，这看起来似乎过于笨拙。经过各种尝试，我设定了一个简单的循环调度方法。如果你匹配了三个generators函数A，B和C，那么A将先获得控制权，当A yield时B将接管A的控制权，然后当B yield时C将接管B，然后又是A，以此类推。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　但是如何才能实际转移generator函数的控制权呢？应该有一个显式的API吗？我再次进行了各种尝试，然后设定了一个更加隐式的方法，看起来和Koa有点类似（完全是以外）：每个generator函数都获得一个共享"token"的引用，当yield时就表示要将控制权进行转移。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　另一个问题是消息通道应该长什么样。一种是非常正式的通信API如core.async和js-csp（<strong>put(..)</strong>和<strong>take(..)</strong>）。但是在我经过各种尝试之后，我比较倾向于另一种不太正式的方法（甚至都谈不上API，而只是一个共享的数据结构，例如数组），它看起来似乎是比较靠谱的。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我决定使用数组（称之为<strong>消息</strong>），你可以根据需要决定如何填充和清空数组的内容。你可以<strong>push()</strong>消息到数组中，从数组中<strong>pop()</strong>消息，按照约定将不同的消息存放到数组中特定的位置，并在这些位置存放更复杂的数据结构等。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我的疑惑是有些任务需要传递简单的消息，而有些则需要传递复杂的消息，因此不要在一些简单的情况下强制这种复杂度，我选择不拘泥于消息通道的形式而使用<strong>数组</strong>（除<strong>数组</strong>本身外这里没有任何API）。在某些情况下它很容易在额外的形式上对消息传递机制进行分层，这对我们来说很有用（参见下面的状态机示例）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　最终，我发现这些generator "processes"仍然得益于那些<a href="https://davidwalsh.name/async-generators/" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">独立的generators可以使用的异步功能</a>。也就是说，如果不<strong>yield</strong>控制token，而<strong>yield</strong>一个Promise（或者一个异步队列），则<strong>runner(..)</strong>的确会暂停以等待返回值，<strong>但不会转移控制权</strong>，它会将结果返回给当前的process（generator）而保留控制权。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　最后一点也许是最有争议或与本文中其它库差别最大的（如果我解释正确的话）。也许真正的CSP对这些方法不屑一顾，但是我发现我的选择还是很有用的。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">一个愚蠢的FooBar示例</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　好了，理论的东西讲得差不多了。我们来看看具体的代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 注意：为了简洁，省略了虚构的`multBy20(..)`和`addTo2(..)`异步数学函数</span>

<span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">foo(token) {
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 从通道的顶部获取消息</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">var</span> value = token.messages.pop(); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 2</span>

    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 将另一个消息存入通道</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> `multBy20(..)`是一个promise-generating函数，它会延迟返回给定值乘以`20`的计算结果</span>
<span style="line-height:1.5;">    token.messages.push( yield multBy20( value ) );

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 转移控制权</span>
<span style="line-height:1.5;">    yield token;

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 从CSP运行中的最后的消息</span>
    yield "meaning of life: " + token.messages[0<span style="line-height:1.5;">];
}

</span><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">bar(token) {
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 从通道的顶部获取消息</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">var</span> value = token.messages.pop(); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 40</span>

    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 将另一个消息存入通道</span>
    <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> `addTo2(..)` 是一个promise-generating函数，它会延迟返回给定值加上`2`的计算结果</span>
<span style="line-height:1.5;">    token.messages.push( yield addTo2( value ) );

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 转移控制权</span>
<span style="line-height:1.5;">    yield token;
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　上面的代码中有两个generator "processes"，<strong>*foo()</strong>和<strong>*bar()</strong>。它们都接收并处理一个<strong>令牌</strong>（当然，如果你愿意你可以随意叫什么都行）。<strong>令牌</strong>上的属性<strong>messages</strong>就是我们的共享消息通道，当CSP运行时它会获取初始化传入的消息值进行填充（后面会讲到）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>yield token</strong>显式地将控制权转移到“下一个”generator函数（循环顺序）。但是，<strong>yield multBy20(value)</strong>和<strong>yield addTo2(value)</strong>都是yield一个promises（从这两个虚构的延迟计算函数中返回的），这表示generator函数此时是处于暂停状态直到promise完成。一旦promise完成，当前处于控制中的generator函数会恢复并继续运行。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　无论最终<strong>yield</strong>会返回什么，上面的例子中<strong>yield返回的是一个表达式</strong>，都表示我们的CSP运行完成的消息（见下文）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　现在我们有两个CSP process generators，我们来看看如何运行它们？使用asynquence：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 开始一个sequence，初始message的值是2</span>
ASQ( 2<span style="line-height:1.5;"> )

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 将两个CSP processes进行配对一起运行</span>
<span style="line-height:1.5;">.runner(
    foo,
    bar
)

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 无论接收到的message是什么，都将它传入sequence中的下一步</span>
.val( <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(msg){
    console.log( msg ); </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 最终返回42</span>
} );</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　这只是一个很简单的例子，但我觉得它能很好地用来解释上面的这些概念。你可以<a href="http://jsbin.com/tunec/2/edit?js,console" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">尝试一下</a>（试着改变一些值），这有助于你理解这些概念并自己动手编写代码！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">另一个例子Toy Demo</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　让我们来看一个经典的CSP例子，但只是从我们目前已有的一些简单的发现开始，而不是从我们通常所说的纯粹学术的角度来展开讨论。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>Ping-pong</strong>。一个很有趣的游戏，对吗？也是我最喜欢的运动。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　让我们来想象一下你已经完成了这个乒乓球游戏的代码，你通过一个循环来运行游戏，然后有两部分代码（例如在<strong>if</strong>或<strong>switch</strong>语句中的分支），每一部分代表一个对应的玩家。代码运行正常，你的游戏运行起来就像是一个乒乓球冠军！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　但是按照我们上面讨论过的，CSP在这里起到了什么样的作用呢？<strong>就是功能和关注点的分离</strong>。那么具体到我们的乒乓球游戏中，这个分离指的就是<em>两个不同的玩家</em>！</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　那么，我们可以在一个非常高的层面上用两个"processes"（generators）来模拟我们的游戏，每个玩家一个"process"。当我们实现代码细节的时候，我们会发现在两个玩家之家存在控制的切换，我们称之为"glue code"（胶水代码（译：在计算机编程领域，胶水代码也叫粘合代码，用途是粘合那些可能不兼容的代码。可以使用与胶合在一起的代码相同的语言编写，也可以用单独的胶水语言编写。胶水代码不实现程序要求的任何功能，它通常出现在代码中，使现有的库或者程序在外部函数接口（如Java本地接口）中进行互操作。胶水代码在快速原型开发环境中非常高效，可以让几个组件被快速集成到单个语言或者框架中。）），这个任务本身可能需要第三个generator的代码，我们可以将它模拟成游戏的<em>裁判</em>。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我们打算跳过各种特定领域的问题，如计分、游戏机制、物理原理、游戏策略、人工智能、操作控制等。这里我们唯一需要关心的部分就是模拟打乒乓球的往复过程（这实际上也代表了我们CSP的控制转移）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　想看demo的话可以在<a href="http://jsbin.com/qutabu/1/edit?js,output" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">这里</a>运行（注意：在支持ES6 JavaScript的最新版的FireFox nightly或Chrome中查看generators是如何工作的）。现在，让我们一起来看看代码。首先，来看看asynquence sequence长什么样？</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="line-height:1.5;">ASQ(
    [</span>"ping","pong"], <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 玩家姓名</span>
    { hits: 0 } <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 球</span>
<span style="line-height:1.5;">)
.runner(
    referee,
    player,
    player
)
.val( </span><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(msg){
    message( </span>"referee", msg );</pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　我们初始化了一个messages sequence：<strong>["ping", "pong"]</strong>和<strong>{hits: 0}</strong>。一会儿会用到。然后，我们设置了一个包含3个processes运行的CSP（相互协同工作）：一个<strong>*referee()</strong>和两个<strong>*player()</strong>实例。在游戏结束时最终的message会被传递给sequence中的下一步，作为referee的输出message。下面是referee的实现代码：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">referee(table){
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> alarm = <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> referee通过秒表（10秒）为游戏设置了一个计时器</span>
    setTimeout( <span style="color:rgb(0,0,255);line-height:1.5;">function</span>(){ alarm = <span style="color:rgb(0,0,255);line-height:1.5;">true</span>; }, 10000<span style="line-height:1.5;"> );

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 当计时器警报响起时游戏停止</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">while</span> (!<span style="line-height:1.5;">alarm) {
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 玩家继续游戏</span>
<span style="line-height:1.5;">        yield table;
    }

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 通知玩家游戏已结束</span>
    table.messages[2] = "CLOSED"<span style="line-height:1.5;">;

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 裁判宣布时间到了</span>
    yield "Time's up!"<span style="line-height:1.5;">;
}
} );</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　这里我们用<strong>table</strong>来模拟控制令牌以解决我们上面说的那些特定领域的问题，这样就能很好地来描述当一个玩家将球打回去的时候控制权被yield给另一个玩家。<strong>*referee()</strong>中的<strong>while</strong>循环表示只要秒表没有停，程序就会一直<strong>yield table</strong>（将控制权转移给另一个玩家）。当计时器结束时退出while循环，referee将会接管控制权并宣布"<strong>Time's up!</strong>"游戏结束了。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　再来看看<strong>*player()</strong>&nbsp;generator的实现代码（我们使用两个实例）：</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span> *<span style="line-height:1.5;">player(table) {
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> name = table.messages[0<span style="line-height:1.5;">].shift();
    </span><span style="color:rgb(0,0,255);line-height:1.5;">var</span> ball = table.messages[1<span style="line-height:1.5;">];

    </span><span style="color:rgb(0,0,255);line-height:1.5;">while</span> (table.messages[2] !== "CLOSED"<span style="line-height:1.5;">) {
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 击球</span>
        ball.hits++<span style="line-height:1.5;">;
        message( name, ball.hits );

        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 模拟将球打回给另一个玩家中间的延迟</span>
        yield ASQ.after( 500<span style="line-height:1.5;"> );

        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 游戏继续？</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (table.messages[2] !== "CLOSED"<span style="line-height:1.5;">) {
            </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 球现在回到另一个玩家那里</span>
<span style="line-height:1.5;">            yield table;
        }
    }

    message( name, </span>"Game over!"<span style="line-height:1.5;"> );
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　第一个玩家将他的名字从message数组的第一个元素中移除（"<strong>ping</strong>"），然后第二个玩家取他的名字（"<strong>pong</strong>"），以便他们都能正确地识别自己（译：注意这里是两个*player()的实例，在两个不同的实例中，通过<strong>table.messages[0].shift()</strong>可以获取各自不同的玩家名字）。同时两个玩家都保持对<strong>共享球</strong>的引用（使用<strong>hits</strong>计数器）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　当玩家还没有听到裁判说结束，就“击球”并<strong>累加计数器</strong>（并输出一个message来通知它），然后等待<strong>500</strong>毫秒（假设球以光速运行不占用任何时间）。如果游戏还在继续，他们就yield table到另一个玩家那里。就是这样。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在<a href="http://jsbin.com/qutabu/1/edit?js,output" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">这里</a>可以查看完整代码，从而了解代码的各部分是如何工作的。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">状态机：Generator协同程序</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　最后一个例子：将一个<a href="http://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">状态机</a>定义为由一个简单的helper驱动的一组generator协同程序。<a href="http://jsbin.com/luron/1/edit?js,console" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">Demo</a>（注意：在支持ES6 JavaScript的最新版的FireFox nightly或Chrome中查看generators是如何工作的）。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　首先，我们定义一个helper来控制有限的状态处理程序。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> state(val,handler) {
    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 管理状态的协同处理程序（包装器）</span>
    <span style="color:rgb(0,0,255);line-height:1.5;">return</span> <span style="color:rgb(0,0,255);line-height:1.5;">function</span>*<span style="line-height:1.5;">(token) {
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 状态转换处理程序</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;"> transition(to) {
            token.messages[</span>0] =<span style="line-height:1.5;"> to;
        }

        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 默认初始状态（如果还没有设置）</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (token.messages.length &lt; 1<span style="line-height:1.5;">) {
            token.messages[</span>0] =<span style="line-height:1.5;"> val;
        }

        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 继续运行直到最终的状态为true</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">while</span> (token.messages[0] !== <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">) {
            </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 判断当前状态是否和处理程序匹配</span>
            <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (token.messages[0] ===<span style="line-height:1.5;"> val) {
                </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 委托给状态处理程序</span>
                yield *<span style="line-height:1.5;">handler( transition );
            }

            </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 将控制权转移给另一个状态处理程序</span>
            <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (token.messages[0] !== <span style="color:rgb(0,0,255);line-height:1.5;">false</span><span style="line-height:1.5;">) {
                yield token;
            }
        }
    };
}</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<strong>state(..)</strong>&nbsp;helper为特定的状态值创建了一个<a href="https://davidwalsh.name/es6-generators-dive#delegating-generators" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">delegating-generator</a>包装器，这个包装器会自动运行状态机，并在每个状态切换时转移控制权。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　依照惯例，我决定使用共享<strong>token.messages[0]</strong>的位置来保存我们状态机的当前状态。这意味着你可以通过从序列中前一步传入的message来设定初始状态。但是如果没有传入初始值的话，我们会简单地将第一个状态作为默认的初始值。同样，依照惯例，最终的状态会被假设为<strong>false</strong>。这很容易修改以适合你自己的需要。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　状态值可以是任何你想要的值：<strong>numbers</strong>，<strong>strings</strong>等。只要该值可以被<strong>===</strong>运算符严格测试通过，你就可以使用它作为你的状态。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　在下面的示例中，我展示了一个状态机，它可以按照特定的顺序在四个数值状态间进行转换：<strong>1-&gt;4-&gt;3-&gt;2</strong>。为了演示，这里使用了一个计数器，因此可以实现多次循环转换。当我们的generator状态机到达最终状态时（<strong>false</strong>），asynquence序列就会像你所期望的那样移动到下一步。</p> 
   <div class="cnblogs_code" style="border:1px solid rgb(204,204,204);font-family:'Courier New';font-size:12px;"> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
    <pre><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 计数器（仅用作演示）</span>
<span style="color:rgb(0,0,255);line-height:1.5;">var</span> counter = 0<span style="line-height:1.5;">;

ASQ( </span><span style="color:rgb(0,128,0);line-height:1.5;">/*</span><span style="color:rgb(0,128,0);line-height:1.5;"> 可选：初始状态值 </span><span style="color:rgb(0,128,0);line-height:1.5;">*/</span><span style="line-height:1.5;"> )

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 运行状态机，转换顺序：1 -&gt; 4 -&gt; 3 -&gt; 2</span>
<span style="line-height:1.5;">.runner(

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 状态`1`处理程序</span>
    state( 1, <span style="color:rgb(0,0,255);line-height:1.5;">function</span>*<span style="line-height:1.5;">(transition){
        console.log( </span>"in state 1"<span style="line-height:1.5;"> );
        yield ASQ.after( </span>1000 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 暂停1s</span>
        yield transition( 4 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 跳到状态`4`</span>
<span style="line-height:1.5;">    } ),

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 状态`2`处理程序</span>
    state( 2, <span style="color:rgb(0,0,255);line-height:1.5;">function</span>*<span style="line-height:1.5;">(transition){
        console.log( </span>"in state 2"<span style="line-height:1.5;"> );
        yield ASQ.after( </span>1000 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 暂停1s</span>

        <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 仅用作演示，在状态循环中保持运行</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">if</span> (++counter &lt; 2<span style="line-height:1.5;">) {
            yield transition( </span>1 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 跳转到状态`1`</span>
<span style="line-height:1.5;">        }
        </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 全部完成！</span>
        <span style="color:rgb(0,0,255);line-height:1.5;">else</span><span style="line-height:1.5;"> {
            yield </span>"That's all folks!"<span style="line-height:1.5;">;
            yield transition( </span><span style="color:rgb(0,0,255);line-height:1.5;">false</span> ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 跳转到最终状态</span>
<span style="line-height:1.5;">        }
    } ),

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 状态`3`处理程序</span>
    state( 3, <span style="color:rgb(0,0,255);line-height:1.5;">function</span>*<span style="line-height:1.5;">(transition){
        console.log( </span>"in state 3"<span style="line-height:1.5;"> );
        yield ASQ.after( </span>1000 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 暂停1s</span>
        yield transition( 2 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 跳转到状态`2`</span>
<span style="line-height:1.5;">    } ),

    </span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 状态`4`处理程序</span>
    state( 4, <span style="color:rgb(0,0,255);line-height:1.5;">function</span>*<span style="line-height:1.5;">(transition){
        console.log( </span>"in state 4"<span style="line-height:1.5;"> );
        yield ASQ.after( </span>1000 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 暂停1s</span>
        yield transition( 3 ); <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 跳转到状态`3`</span>
<span style="line-height:1.5;">    } )

)

</span><span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;"> 状态机完成，移动到下一步</span>
.val(<span style="color:rgb(0,0,255);line-height:1.5;">function</span><span style="line-height:1.5;">(msg){
    console.log( msg );
});</span></pre> 
    <div class="cnblogs_code_toolbar">
     <span class="cnblogs_code_copy" style="line-height:1.5;"><a title="复制代码" style="color:rgb(216,77,45);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="border:none;"></a></span>
    </div> 
   </div> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　应该很容易地跟踪上面的代码来查看到底发生了什么。<strong>yield ASQ.after(1000)</strong>显示了这些generators可以根据需要做任何类型的基于promise/sequence的异步工作，就像我们在前面所看到的一样。<strong>yield transition(...)</strong>表示如何转换到一个新的状态。上面代码中的<strong>state(..)</strong>&nbsp;helper完成了处理<strong>yield*</strong>&nbsp;<a href="https://davidwalsh.name/es6-generators-dive#delegating-generators" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">delegation</a>和状态转换的主要工作，然后整个程序的主要流程看起来十分简单，表述也很清晰流畅。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <h3 style="font-size:16px;line-height:1.5;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">总结</h3> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　CSP的关键是将两个或更多的generator "processes"连接在一起，给它们一个共享的通信信道，以及一种可以在彼此间传输控制的方法。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　JS中有很多的库都或多或少地采用了相当正式的方法来与Go和Clojure/ClojureScript APIs或语义相匹配。这些库的背后都有着非常棒的开发者，对于进一步探索CSP来说他们都是非常好的资源。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　<a href="http://github.com/getify/asynquence" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">asynquence</a>试图采用一种不太正式而又希望仍然能够保留主要结构的方法。如果没有别的 ，asynquence的<a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">runner(..)&nbsp;</a>可以作为你实验和学习<a href="https://github.com/getify/asynquence/tree/master/contrib#csp-style-concurrency" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">CSP-like generators</a>的入门。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　最好的部分是asynquence CSP与其它异步功能（promises，generators，流程控制等）在一起工作。如此一来，你便可以掌控一切，使用任何你手头上合适的工具来完成任务，而所有的这一切都只在一个小小的lib中。</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">　　现在我们已经在这四篇文章中详细探讨了generators，我希望你能够从中受益并获得灵感以探索如何革新自己的异步JS代码！你将用generators来创造什么呢？</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">原文地址：<a href="https://davidwalsh.name/es6-generators" rel="nofollow" style="color:rgb(216,77,45);text-decoration:none;">https://davidwalsh.name/es6-generators</a></p> 
   <p style="color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><br></p> 
   <p><font color="#393939"><span style="font-size:14px;">本文转自Jaxu博客园博客，原文链接：http://www.cnblogs.com/jaxu/p/6592210.html</span></font><span style="font-size:14px;color:rgb(57,57,57);font-family:'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <div>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
