<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Spark RDD概念学习系列之Spark的算子的分类（十一） « NotBeCN</title>
  <meta name="description" content="             Spark的算子的分类    &nbsp;    &nbsp;    　　　从大方向来说Spark 算子大致可以分为以下两类:    &nbsp; &nbsp; &nbsp;1Transformation 变换/转换算子这种变换并不触发提交作业完成作业中间过程处理。    　　　　　Tr...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/14/weixin_33709219_90124318.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Spark RDD概念学习系列之Spark的算子的分类（十一）</h1>
    <p class="post-meta">Nov 14, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);font-size:18pt;"><strong>Spark的算子的分类</strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　从大方向来说Spark 算子大致可以分为以下两类:</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp;1<span style="color:rgb(255,0,0);">Transformation 变换/转换算子</span>这种变换并不触发提交作业<span style="color:rgb(0,0,255);">完成作业中间过程处理</span>。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　Transformation 操作是延迟计算的也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行需要等到有 Action 操作的时候才会真正触发运算。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp;2Action 行动算子这类算子会<span style="color:rgb(0,0,255);">触发 SparkContext 提交 Job 作业</span>。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　 &nbsp;　　Action 算子会触发 Spark 提交作业Job并将数据输出 Spark系统。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　</strong>从小方向来说Spark 算子大致可以分为以下三类:</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　1Value数据类型的Transformation算子这种变换并不触发提交作业针对处理的数据项是Value型的数据。<br> 2Key-Value数据类型的Transfromation算子这种变换并不触发提交作业针对处理的数据项是Key-Value型的数据对。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　3Action算子这类算子会触发SparkContext提交Job作业。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="color:rgb(255,0,0);font-size:18pt;">1Value数据类型的Transformation算子　　</span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　一、输入分区与输出分区一对一型</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　1、map算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　2、flatMap算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　3、mapPartitions算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　4、glom算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　二、输入分区与输出分区多对一型　</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　5、union算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　6、cartesian算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　三、输入分区与输出分区多对多型</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　7、grouBy算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　四、输出分区为输入分区子集型</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　8、filter算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　9、distinct算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　10、subtract算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　11、sample算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>&nbsp; &nbsp; &nbsp;　　 12、takeSample算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　五、Cache型</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　13、cache算子　　</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　14、persist算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">2Key-Value数据类型的Transfromation算子</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　一、输入分区与输出分区一对一</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　15、mapValues算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　二、对单个RDD或两个RDD聚集</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　单个RDD聚集</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　16、combineByKey算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　17、reduceByKey算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　18、partitionBy算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　两个RDD聚集</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　<strong>　19、Cogroup算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　</strong>三、连接</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　20、join算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　21、leftOutJoin和 rightOutJoin算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　Spark算子的作用详细见</strong>&nbsp;<strong><a href="http://www.cnblogs.com/zlslch/p/5723979.html" rel="nofollow" style="color:#000000;">http://www.cnblogs.com/zlslch/p/5723979.html</a></strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">&nbsp;3Action算子</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　一、无输出</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　<strong>22、foreach算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong style="line-height:1.5;">　　</strong>二、HDFS</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong style="line-height:1.5;">　　　　23、saveAsTextFile算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong style="line-height:1.5;">　　　　24、saveAsObjectFile算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　三、Scala集合和数据类型</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　25、collect算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　26、collectAsMap算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　　 &nbsp;<strong>27、reduceByKeyLocally算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　<strong>　 &nbsp;28、lookup算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　29、count算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　30、top算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　31、reduce算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　32、fold算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　　　33、aggregate算子</strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong>　　<strong>Spark算子的作用详细见</strong><strong>http://www.cnblogs.com/zlslch/p/5723979.html</strong></strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">&nbsp;1. Transformations 算子</span></strong></span><br> 1&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">map</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　将原来 RDD 的每个数据项通过&nbsp;<span style="color:rgb(255,0,0);">map 中的用户自定义函数 f</span>&nbsp;映射转变为一个新的元素。源码中 map 算子相当于初始化一个 RDD 新 RDD 叫做 MappedRDD(this, sc.clean(f))。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp;图 1中每个方框表示一个 RDD 分区左侧的分区经过用户<span style="color:rgb(255,0,0);">自定义函数 f:T-&gt;U</span>&nbsp;映射为右侧的新 RDD 分区。但是实际只有等到 Action算子触发后这个 f 函数才会和其他函数在一个stage 中对数据进行运算。在图 1 中的第一个分区数据记录 V1 输入 f通过 f 转换输出为转换后的分区中的数据记录 V'1。<br> &nbsp; &nbsp;&nbsp;<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731201803075-1566603859.png" alt="" style="border:0px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<br><br></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图1 &nbsp; &nbsp;map 算子对 RDD 转换　　　　　　　　　　　　　　　　　　　</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 2&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">flatMap</span></strong></span><br> &nbsp; &nbsp; &nbsp;将原来 RDD 中的每个元素通过函数 f 转换为新的元素并将生成的 RDD 的每个集合中的元素<span style="color:rgb(255,0,0);">合并为一个集合</span>内部创建 FlatMappedRDD(thissc.clean(f))。<br> 图 2 表 示 RDD 的 一 个 分 区 进 行 flatMap函 数 操 作 flatMap 中 传 入 的 函 数 为 f:T-&gt;U&nbsp;<span style="color:rgb(255,0,0);">T和 U 可以是任意的数据类型。</span>将分区中的数据通过用户自定义函数 f 转换为新的数据。外部大方框可以认为是一个 RDD 分区小方框代表一个集合。 V1、 V2、 V3 在一个集合作为 RDD 的一个数据项可能存储为数组或其他容器转换为V'1、 V'2、 V'3 后将原来的数组或容器结合拆散拆散的数据形成为 RDD 中的数据项。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731201828294-509624797.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　图2 &nbsp; &nbsp;　flapMap 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br> &nbsp; &nbsp;&nbsp;3&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">mapPartitions</span></strong></span><br> &nbsp; &nbsp; &nbsp; mapPartitions 函 数 获 取 到 每 个 分 区 的 迭 代器在 函 数 中 通 过 这 个 分 区 整 体 的 迭 代 器 对整 个 分 区 的 元 素 进 行 操 作。 内 部 实 现 是 生 成<br> MapPartitionsRDD。图 3 中的方框代表一个 RDD 分区。图 3 中<span style="color:rgb(255,0,0);">用户通过函数 f (iter)=&gt;iter.f ilter(_&gt;=3) 对分区中所有数据进行过滤大于和等于 3 的数据保留</span>。一个方块代表一个 RDD 分区含有 1、 2、 3 的分区过滤只剩下元素 3。<br><br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731202140622-1302550096.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　图3 &nbsp;mapPartitions 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　4<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">glom</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　<span style="color:rgb(255,0,0);">glom函数将每个分区形成一个数组</span>内部实现是返回的GlommedRDD。 图4中的每个方框代表一个RDD分区。图4中的方框代表一个分区。 该图表示含有V1、 V2、 V3的分区通过函数glom形成一数组Array[V1V2V3]。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731220004841-310104312.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图 4 &nbsp;&nbsp;glom算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp;5&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">union</span></strong></span><br> &nbsp; &nbsp; &nbsp; 使用 union 函数时需要保证两个 RDD 元素的数据类型相同<span style="color:rgb(255,0,0);">返回的 RDD 数据类型和被合并的 RDD 元素数据类型相同</span>并不进行去重操作保存所有元素。如果想去重<br> 可以使用 distinct()。同时 Spark 还提供更为简洁的使用 union 的 API<span style="color:rgb(255,0,0);">通过 ++ 符号相当于 union 函数操作</span>。<br> &nbsp; &nbsp; &nbsp;图 5 中左侧大方框代表两个 RDD大方框内的小方框代表 RDD 的分区。右侧大方框代表合并后的 RDD大方框内的小方框代表分区。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　含有V1、V2、U1、U2、U3、U4的RDD和含有V1、V8、U5、U6、U7、U8的RDD合并所有元素形成一个RDD。V1、V1、V2、V8形成一个分区U1、U2、U3、U4、U5、U6、U7、U8形成一个分区。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731202333106-98840694.png" alt="" style="border:0px;"><br> 图 5 &nbsp;union 算子对 RDD 转换　</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br><br> 6&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">cartesian</span></strong></span><br> &nbsp; &nbsp; &nbsp; &nbsp;对 两 个 RDD 内 的 所 有 元 素&nbsp;<span style="color:rgb(255,0,0);">进 行 笛 卡 尔 积 操 作</span>。 操 作 后 内 部 实 现 返 回CartesianRDD。图6中左侧大方框代表两个 RDD大方框内的小方框代表 RDD 的分区。右侧大方框代表合并后的 RDD大方框内的小方框代表分区。图6中的大方框代表RDD大方框中的小方框代表RDD分区。<br> &nbsp; &nbsp; &nbsp; 例 如 V1 和 另 一 个 RDD 中 的 W1、 W2、 Q5 进 行 笛 卡 尔 积 运 算 形 成 (V1,W1)、(V1,W2)、 (V1,Q5)。<br> &nbsp; &nbsp; &nbsp;<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731202551341-260166576.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp; &nbsp;图 6 &nbsp;cartesian 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　7&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">groupBy</span></strong></span><br> groupBy <span style="color:rgb(255,0,0);">将元素通过函数生成相应的 Key数据就转化为 Key-Value 格式之后将 Key 相同的元素分为一组。</span><br> 函数实现如下<br> 1将用户函数预处理<br> val cleanF = sc.clean(f)<br> 2对数据 map 进行函数操作最后再进行 groupByKey 分组操作。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp;this.map(t =&gt; (cleanF(t), t)).groupByKey(p)<br> 其中 p 确定了分区个数和分区函数也就决定了并行化的程度。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　图7 中方框代表一个 RDD 分区相同key 的元素合并到一个组。例如 V1 和 V2 合并为 V Value 为 V1,V2。形成 V,Seq(V1,V2)。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731203150309-1392947847.png" alt="" style="border:0px;"><br> 图 7&nbsp;groupBy 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　8&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">filter</span></strong></span><br> &nbsp; &nbsp; filter 函数功能是<span style="color:rgb(255,0,0);">对元素进行过滤</span>对每个 元 素 应 用 f 函 数 返 回 值 为 true 的 元 素 在RDD 中保留返回值为 false 的元素将被过滤掉。 内 部 实 现 相 当 于 生 成 FilteredRDD(thissc.clean(f))。<br> &nbsp; &nbsp; 下面代码为函数的本质实现<br> &nbsp; &nbsp;&nbsp;deffilter(f:T=&gt;Boolean):RDD[T]=newFilteredRDD(this,sc.clean(f))<br> 图 8 中每个方框代表一个 RDD 分区 T 可以是任意的类型。通过用户自定义的过滤函数 f对每个数据项操作将满足条件、返回结果为 true 的数据项保留。例如过滤掉 V2 和 V3 保留了 V1为区分命名为 V'1。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731224355278-1057893706.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　图 8 &nbsp;filter 算子对 RDD 转换<br> &nbsp; &nbsp; &nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　9<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">distinct</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　distinct<span style="color:rgb(255,0,0);">将RDD中的元素进行去重操作</span>。图9中的每个方框代表一个RDD分区通过distinct函数将数据去重。 例如重复数据V1、 V1去重后只保留一份V1。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731220649481-586314519.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　图9 &nbsp;distinct算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　10<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">subtract</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　subtract相当于<span style="color:rgb(255,0,0);">进行集合的差操作</span>RDD 1去除RDD 1和RDD 2交集中的所有元素。图10中左侧的大方框代表两个RDD大方框内的小方框代表RDD的分区。 右侧大方框<br> 代表合并后的RDD大方框内的小方框代表分区。 V1在两个RDD中均有根据差集运算规则新RDD不保留V2在第一个RDD有第二个RDD没有则在新RDD元素中包含V2。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731220749841-222338560.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　图10 &nbsp; subtract算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　11&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">sample</span></strong></span><br> &nbsp; &nbsp; &nbsp; &nbsp;sample 将 RDD 这个集合内的元素<span style="color:rgb(255,0,0);">进行采样</span>获取所有元素的子集。用户可以设定是否有放回的抽样、百分比、随机种子进而决定采样方式。内部实现是生成 SampledRDD(withReplacement fraction seed)。<br> 函数参数设置<br> 　　withReplacement=true表示有放回的抽样。<br> 　　withReplacement=false表示无放回的抽样。<br> 图 11中 的 每 个 方 框 是 一 个 RDD 分 区。 通 过 sample 函 数 采 样 50% 的 数 据。V1、 V2、 U1、 U2、U3、U4 采样出数据 V1 和 U1、 U2 形成新的 RDD。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp; &nbsp;&nbsp;<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731204116606-30482327.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　图11 &nbsp;sample 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　12<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">takeSample</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　takeSample函数和上面的sample函数是一个原理但是<span style="color:rgb(255,0,0);">不使用相对比例采样</span><span style="color:rgb(255,0,0);">而是按设定的采样个数进行采样</span>同时返回结果不再是RDD而是相当于对采样后的数据进行<br> Collect返回结果的集合为单机的数组。<br> 图12中左侧的方框代表分布式的各个节点上的分区右侧方框代表单机上返回的结果数组。 通过takeSample对数据采样设置为采样一份数据返回结果为V1。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731221057966-726438556.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　图12 &nbsp;　　takeSample算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　13&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">cache</span></strong></span><br> &nbsp; &nbsp; &nbsp;cache&nbsp;<span style="color:rgb(255,0,0);">将 RDD 元素从磁盘缓存到内存</span>。 相当于 persist(MEMORY_ONLY) 函数的功能。<br> &nbsp; &nbsp; &nbsp;图13 中每个方框代表一个 RDD 分区左侧相当于数据分区都存储在磁盘通过 cache 算子将数据缓存在内存。<br> &nbsp; &nbsp; &nbsp;&nbsp;<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731204305763-699299476.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图 13 Cache 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　14&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">persist</span></strong></span><br> &nbsp; &nbsp; &nbsp; persist 函数对&nbsp;<span style="color:rgb(255,0,0);">RDD 进行缓存操作</span>。数据缓存在哪里依据 StorageLevel 这个枚举类型进行确定。 有以下几种类型的组合见10 DISK 代表磁盘MEMORY 代表内存 SER 代表数据是否进行序列化存储。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　下面为函数定义 StorageLevel 是枚举类型代表存储模式用户可以通过图 14-1 按需进行选择。<br> persist(newLevel:StorageLevel)<br> 图 14-1 中列出persist 函数可以进行缓存的模式。例如MEMORY_AND_DISK_SER 代表数据可以存储在内存和磁盘并且以序列化的方式存储其他同理。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731204605997-1519520389.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　　　图 14-1 &nbsp;persist 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　图 14-2 中方框代表 RDD 分区。 disk 代表存储在磁盘 mem 代表存储在内存。数据最初全部存储在磁盘通过 persist(MEMORY_AND_DISK) 将数据缓存到内存但是有的分区无法容纳在内存将含有 V1、 V2、 V3 的RDD存储到磁盘将含有U1U2的RDD仍旧存储在内存。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731204807497-598725714.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; &nbsp; 图 14-2 &nbsp; Persist 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　15&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">mapValues</span></strong></span><br> &nbsp; &nbsp; &nbsp; mapValues 针对Key Value型数据中的 Value 进行 Map 操作而不对 Key 进行处理。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp; 图 15 中的方框代表 RDD 分区。 a=&gt;a+2 代表对 (V1,1) 这样的 Key Value 数据对数据只对 Value 中的 1 进行加 2 操作返回结果为 3。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; &nbsp;&nbsp;<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731204844169-405099284.png" alt="" style="border:0px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图 15 &nbsp; mapValues 算子 RDD 对转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　16&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">combineByKey</span></strong></span><br> 下面代码为 combineByKey 函数的定义<br> combineByKey[C](createCombiner:(V) C,<br> mergeValue:(C, V) C,<br> mergeCombiners:(C, C) C,<br> partitioner:Partitioner,<br> mapSideCombine:Boolean=true,<br> serializer:Serializer=null):RDD[(K,C)]</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">说明<br> 　　createCombiner V =&gt; C C 不存在的情况下比如通过 V 创建 seq C。<br> 　　 mergeValue (C V) =&gt; C当 C 已经存在的情况下需要 merge比如把 item V<br> 加到 seq C 中或者叠加。<br> &nbsp;mergeCombiners (C C) =&gt; C合并两个 C。<br> 　　partitioner Partitioner, Shuff le 时需要的 Partitioner。<br> 　　mapSideCombine Boolean = true为了减小传输量很多 combine 可以在 map<br> 端先做比如叠加可以先在一个 partition 中把所有相同的 key 的 value 叠加<br> 再 shuff le。<br> 　　serializerClass String = null传输需要序列化用户可以自定义序列化类</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　例如<span style="color:rgb(255,0,0);">相当于将元素为 (Int Int) 的 RDD 转变为了 (Int Seq[Int]) 类型元素的 RDD</span>。图 16中的方框代表 RDD 分区。如图通过 combineByKey 将 (V1,2) (V1,1)数据合并为 V1,Seq(2,1)。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731204940731-2073970167.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图 16&nbsp; comBineByKey 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　17&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">reduceByKey</span></strong></span><br> &nbsp; &nbsp; &nbsp;reduceByKey 是比 combineByKey 更简单的一种情况只是两个值合并成一个值 Int Int Vto Int Int C比如叠加。所以 createCombiner reduceBykey 很简单就是直接返回 v而 mergeValue和 mergeCombiners 逻辑是相同的没有区别。<br> &nbsp; &nbsp; 函数实现<br> &nbsp; &nbsp; def reduceByKey(partitioner: Partitioner, func: (V, V) =&gt; V): RDD[(K, V)]<br> = {<br> combineByKey[V]((v: V) =&gt; v, func, func, partitioner)<br> }<br> 图17中的方框代表 RDD 分区。通过用户自定义函数 (A,B) =&gt; (A + B) 函数将相同 key 的数据 (V1,2) 和 (V1,1) 的 value 相加运算结果为 V1,3。<br> &nbsp; &nbsp; &nbsp;<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731205135778-1447703222.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　图 17&nbsp;reduceByKey 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　18<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">partitionBy</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　partitionBy函数对RDD进行分区操作。<br> 函数定义如下。<br> partitionBypartitionerPartitioner<br><span style="color:rgb(255,0,0);">如果原有RDD的分区器和现有分区器partitioner一致则不重分区</span>如果不一致则相当于根据分区器生成一个新的ShuffledRDD。<br> 图18中的方框代表RDD分区。 通过新的分区策略将原来在不同分区的V1、 V2数据都合并到了一个分区。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731221629966-1096458926.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　图18　　partitionBy算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;19<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">Cogroup</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　cogroup函数<span style="color:rgb(255,0,0);">将两个RDD进行协同划分</span>cogroup函数的定义如下。<br> cogroup[W]other RDD[K W] numPartitions Int RDD[K Iterable[V] Iterable[W]]<br> 对在两个RDD中的Key-Value类型的元素每个RDD相同Key的元素分别聚合为一个集合并且返回两个RDD中对应Key的元素集合的迭代器。<br> K Iterable[V] Iterable[W]<br> 其中Key和ValueValue是两个RDD下相同Key的两个数据集合的迭代器所构成的元组。<br> 图19中的大方框代表RDD大方框内的小方框代表RDD中的分区。 将RDD1中的数据U11、 U12和RDD2中的数据U12合并为U1122。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731221840606-1498363270.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　图19 &nbsp;Cogroup算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　20&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">join</span></strong></span><br> &nbsp; &nbsp; &nbsp; &nbsp;join 对两个需要连接的 RDD 进行 cogroup函数操作将相同 key 的数据能够放到一个分区在 cogroup 操作之后形成的新 RDD 对每个key 下的元素进行笛卡尔积的操作返回的结果再展平对应 key 下的所有元组形成一个集合。最后返回 RDD[(K (V W))]。<br> 下 面 代 码 为 join 的 函 数 实 现 本 质 是通 过 cogroup 算 子 先 进 行 协 同 划 分 再 通 过flatMapValues 将合并的数据打散。<br> &nbsp; &nbsp; &nbsp; &nbsp;this.cogroup(other,partitioner).f latMapValues{case(vs,ws) =&gt;&nbsp;for(v&lt;-vs;w&lt;-ws)yield(v,w) }<br> 图 20是对两个 RDD 的 join 操作示意图。大方框代表 RDD小方框代表 RDD 中的分区。函数对相同 key 的元素如 V1 为 key 做连接后结果为 (V1,(1,1)) 和 (V1,(1,2))。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731205235169-1186414997.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　　　　　　　　　　　图 20 &nbsp; join 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　21<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">eftOutJoin</span></strong></span>和<strong><span style="color:rgb(255,0,0);font-size:18pt;">rightOutJoin</span></strong></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　LeftOutJoin左外连接和RightOutJoin右外连接相当于在join的基础上先判断一侧的RDD元素是否为空如果为空则填充为空。 如果不为空则将数据进行连接运算并<br> 返回结果。<br> 下面代码是leftOutJoin的实现。<br> if ws.isEmpty {<br> vs.mapv =&gt; v None<br> } else {<br> for v &lt;- vs w &lt;- ws yield v Somew<br> }</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">2. Actions 算子</span></strong></span><br> 本质上在 Action 算子中通过 SparkContext 进行了提交作业的 runJob 操作触发了RDD DAG 的执行。<br> 例如 Action 算子 collect 函数的代码如下感兴趣的读者可以顺着这个入口进行源码剖析<br><br> /**<br> * Return an array that contains all of the elements in this RDD.<br> */<br> def collect(): Array[T] = {<br> /* 提交 Job*/<br> val results = sc.runJob(this, (iter: Iterator[T]) =&gt; iter.toArray)<br> Array.concat(results: _*)<br> }</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br> 22&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">foreach</span></strong></span><br> foreach 对 RDD 中的每个元素都应用 f 函数操作不返回 RDD 和 Array 而是返回Uint。图22表示 foreach 算子通过用户自定义函数对每个数据项进行操作。本例中自定义函数为 println()控制台打印所有数据项。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731205454481-1346514184.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图 22 foreach 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　23&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">saveAsTextFile</span></strong></span><br> 函数将数据输出存储到 HDFS 的指定目录。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">下面为 saveAsTextFile 函数的内部实现其内部<br> 通过调用 saveAsHadoopFile 进行实现<br> this.map(x =&gt; (NullWritable.get(), new Text(x.toString))).saveAsHadoopFile[TextOutputFormat[NullWritable, Text]](path)<br> 将 RDD 中的每个元素映射转变为 (null x.toString)然后再将其写入 HDFS。<br> 图 23中左侧方框代表 RDD 分区右侧方框代表 HDFS 的 Block。通过函数将RDD 的每个分区存储为 HDFS 中的一个 Block。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　<img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731205548903-1055637433.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　　　图 23 &nbsp; saveAsHadoopFile 算子对 RDD 转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp; 24<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">saveAsObjectFile</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　saveAsObjectFile将分区中的每10个元素组成一个Array然后将这个Array序列化映射为NullBytesWritableY的元素写入HDFS为SequenceFile的格式。<br> 下面代码为函数内部实现。<br> mapx=&gt;NullWritable.getnew BytesWritableUtils.serializex<br> 图24中的左侧方框代表RDD分区右侧方框代表HDFS的Block。 通过函数将RDD的每个分区存储为HDFS上的一个Block。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731222523559-44457287.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　　　图24 saveAsObjectFile算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;25&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">collect</span></strong></span><br> collect 相当于 toArray toArray 已经过时不推荐使用 collect 将分布式的 RDD 返回为一个单机的 scala Array 数组。在这个数组上运用 scala 的函数式操作。<br> 图 25中左侧方框代表 RDD 分区右侧方框代表单机内存中的数组。通过函数操作将结果返回到 Driver 程序所在的节点以数组形式存储。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731222728044-198671492.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　图 25 &nbsp; Collect 算子对 RDD 转换　</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　26<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">collectAsMap</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　collectAsMap对KV型的RDD数据返回一个单机HashMap。 对于重复K的RDD元素后面的元素覆盖前面的元素。<br> 图26中的左侧方框代表RDD分区右侧方框代表单机数组。 数据通过collectAsMap函数返回给Driver程序计算结果结果以HashMap形式存储。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201608/855959-20160801101339887-1595343690.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　图26 CollectAsMap算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　27<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">reduceByKeyLocally</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　实现的是先reduce再collectAsMap的功能先对RDD的整体进行reduce操作然后再收集所有结果返回为一个HashMap。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　28<span style="color:rgb(255,0,0);font-size:18pt;">lookup</span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">下面代码为lookup的声明。<br> lookupkeyKSeq[V]<br> Lookup函数对KeyValue型的RDD操作返回指定Key对应的元素形成的Seq。 这个函数处理优化的部分在于如果这个RDD包含分区器则只会对应处理K所在的分区然后返回由KV形成的Seq。 如果RDD不包含分区器则需要对全RDD元素进行暴力扫描处理搜索指定K对应的元素。<br> 图28中的左侧方框代表RDD分区右侧方框代表Seq最后结果返回到Driver所在节点的应用中。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731222922013-1736160031.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　图28 &nbsp;lookup对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　29&nbsp;<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">count</span></strong></span><br> count 返回整个 RDD 的元素个数。<br> 内部函数实现为<br> defcount():Long=sc.runJob(this,Utils.getIteratorSize_).sum<br> 图 29中返回数据的个数为 5。一个方块代表一个 RDD 分区。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731205729356-1443529657.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　&nbsp;图29 count 对 RDD 算子转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　30<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">top</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">top可返回最大的k个元素。 函数定义如下。<br> topnumIntimplicit ordOrdering[T]Array[T]</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">相近函数说明如下。<br> ·top返回最大的k个元素。<br> ·take返回最小的k个元素。<br> ·takeOrdered返回最小的k个元素并且在返回的数组中保持元素的顺序。<br> ·first相当于top1返回整个RDD中的前k个元素可以定义排序的方式Ordering[T]。<br> 返回的是一个含前k个元素的数组。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　31<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">reduce</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　reduce函数相当于对RDD中的元素进行reduceLeft函数的操作。 函数实现如下。<br> Someiter.reduceLeftcleanF<br> reduceLeft先对两个元素&lt;KV&gt;进行reduce函数操作然后将结果和迭代器取出的下一个元素&lt;kV&gt;进行reduce函数操作直到迭代器遍历完所有元素得到最后结果。在RDD中先对每个分区中的所有元素&lt;KV&gt;的集合分别进行reduceLeft。 每个分区形成的结果相当于一个元素&lt;KV&gt;再对这个结果集合进行reduceleft操作。<br> 例如用户自定义函数如下。<br> fAB=&gt;A._1+"@"+B._1A._2+B._2<br> 图31中的方框代表一个RDD分区通过用户自定函数f将数据进行reduce运算。 示例<br> 最后的返回结果为V1@[1]V2U@U2@U3@U412。</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731223121044-290410786.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">图31 reduce算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　32<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">fold</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　fold和reduce的原理相同但是与reduce不同相当于每个reduce时迭代器取的第一个元素是zeroValue。<br> 图32中通过下面的用户自定义函数进行fold运算图中的一个方框代表一个RDD分区。 读者可以参照reduce函数理解。<br> fold"V0@"2 AB=&gt;A._1+"@"+B._1A._2+B._2<br><br></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731223130341-1176380072.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　　　图32 &nbsp;fold算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　33<span style="font-size:18pt;"><strong><span style="color:rgb(255,0,0);">aggregate</span></strong></span></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;　　aggregate先对每个分区的所有元素进行aggregate操作再对分区的结果进行fold操作。<br> aggreagate与fold和reduce的不同之处在于aggregate相当于采用归并的方式进行数据聚集这种聚集是并行化的。 而在fold和reduce函数的运算过程中每个分区中需要进行串行处理每个分区串行计算完结果结果再按之前的方式进行聚集并返回最终聚集结果。<br> 函数的定义如下。<br> aggregate[B]z Bseqop BA =&gt; Bcombop BB =&gt; B B<br> 图33通过用户自定义函数对RDD 进行aggregate的聚集操作图中的每个方框代表一个RDD分区。<br> rdd.aggregate"V0@"2AB=&gt;A._1+"@"+B._1A._2+B._2AB=&gt;A._1+"@"+B_1A._@+B_.2<br> 最后介绍两个计算模型中的两个特殊变量。<br> 广播broadcast变量其广泛用于广播Map Side Join中的小表以及广播大变量等场景。 这些数据集合在单节点内存能够容纳不需要像RDD那样在节点之间打散存储。<br> Spark运行时把广播变量数据发到各个节点并保存下来后续计算可以复用。 相比Hadoo的distributed cache广播的内容可以跨作业共享。 Broadcast的底层实现采用了BT机制。<br><img src="http://images2015.cnblogs.com/blog/855959/201607/855959-20160731223232856-272527583.png" alt="" style="border:0px;"></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　　　　　　　图33 &nbsp;aggregate算子对RDD转换</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">　　②代表V。<br> ③代表U。<br> accumulator变量允许做全局累加操作如accumulator变量广泛使用在应用中记录当前的运行指标的情景。<br><br></p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;</p> 
   <p style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></p> 
   <p><font><span style="font-size:14px;">本文转自大数据躺过的坑博客园博客原文链接http://www.cnblogs.com/zlslch/p/5723857.html如需转载请自行联系原作者</span></font><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
