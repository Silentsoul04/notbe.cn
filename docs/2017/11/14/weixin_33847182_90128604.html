<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>文本比较算法Ⅵ——用线性空间计算最大公共子序列（翻译贴） « NotBeCN</title>
  <meta name="description" content="             研究文本比较算法有一段时间了。近日研读了《A Linear Space Algorithm for Computing Maximal Common Subsequences》（D.S.Hirschberg著）。文章写于1975年。很多其他的论文都会引用这篇论文，可见这篇论文的质量。同时...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/14/weixin_33847182_90128604.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">文本比较算法Ⅵ——用线性空间计算最大公共子序列（翻译贴）</h1>
    <p class="post-meta">Nov 14, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">研究文本比较算法有一段时间了。近日研读了《A Linear Space Algorithm for Computing Maximal Common Subsequences》（D.S.Hirschberg著）。文章写于1975年。很多其他的论文都会引用这篇论文，可见这篇论文的质量。同时，该文作者D.S.Hirschberg也写了很多有关LCS的文章，也都是经典中的经典。</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">　　在研读这篇文章之后，我将它翻译成中文。由于本人的英语与文法都还不行，故翻译的质量也就一般了，也欢迎广大网友指正。</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong></strong>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong>Introduction</strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong>导论</strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">　　The problem of finding a longest common subsequence of two strings has been solved in quadratic time and space. For stings of length 1000 (assuming coefficients of 1 microsecond and 1 byte) the solution would require 10<sup>6</sup>&nbsp;microseconds (one second) and 10<sup>6&nbsp;</sup>bytes (1000K bytes). The former is easily accommodated, the latter is not so easily obtainable. If the strings were of length of 10000, the problem might not to be solvable in main memory for lack of space.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">过去求解两个字符串的最长公共子序列的问题，需要花费二次的时间和空间。在求解两个长</span><span style="line-height:1.5;font-family:Verdana;">1000</span><span style="line-height:1.5;font-family:'宋体';">的字符串（假定时间系数为</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">微秒，空间系数是</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">字节）过程中需要</span><span style="line-height:1.5;font-family:Verdana;">10<sup>6</sup></span><span style="line-height:1.5;font-family:'宋体';">微秒（</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">秒）和</span><span style="line-height:1.5;font-family:Verdana;">10<sup>6</sup></span><span style="line-height:1.5;font-family:'宋体';">字节（</span><span style="line-height:1.5;font-family:Verdana;">1000K</span><span style="line-height:1.5;font-family:'宋体';">字节）。前者很容易解决，而后者不是很容易满足的。如果两个字符串的长度为</span><span style="line-height:1.5;font-family:Verdana;">10000</span><span style="line-height:1.5;font-family:'宋体';">，则可能没有足够的主内存空间来求解这个问题。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;color:#FF0000;font-family:Verdana;">注：文章写于1975年，以当时的计算机的能力来看，1000K是个天量了。不过，就算是现在的计算机，如果没有良好的算法，在大容量的文本比较时就会出问题。比方说，文本是1M的，在O</span><span style="line-height:1.5;color:#FF0000;font-family:Verdana;">（MN）的情况下，需要1T的容量。这个可是够惊人的。&nbsp;</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">　　We present an algorithm which will solve this problem in quadratic time and in linear space. For Example, assuming coefficients of 2 microseconds and 10 bytes , for strings of length 1000 we would require 2 seconds and 10K bytes; for strings of length 10000 we would require a little over 3 minutes and 100K bytes.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">我们提出一个解决该问题算法，该算法花费二次的时间和线性空间。举例来说，假定时间系数是</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">微秒，空间系数为</span><span style="line-height:1.5;font-family:Verdana;">10</span><span style="line-height:1.5;font-family:'宋体';">字节。求解两个长</span><span style="line-height:1.5;font-family:Verdana;">1000</span><span style="line-height:1.5;font-family:'宋体';">的字符串，我们要花费</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">秒和</span><span style="line-height:1.5;font-family:Verdana;">10K</span><span style="line-height:1.5;font-family:'宋体';">字节；求解两个长</span><span style="line-height:1.5;font-family:Verdana;">10000</span><span style="line-height:1.5;font-family:'宋体';">的字符串，我们花费仅仅增加到</span><span style="line-height:1.5;font-family:Verdana;">3</span><span style="line-height:1.5;font-family:'宋体';">分钟和</span><span style="line-height:1.5;font-family:Verdana;">100K</span><span style="line-height:1.5;font-family:'宋体';">字节。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">String&nbsp;<em>C=c<sub>1</sub>c<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub></em>&nbsp;is a subsequence of string&nbsp;<em>A=a<sub>1</sub>a<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>a<sub>m</sub></em>&nbsp;if and only if there is a mapping&nbsp;<em>F:</em></span><em><span style="line-height:1.5;font-family:'宋体';">｛</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">，……，</span><span style="line-height:1.5;font-family:Verdana;">p</span><span style="line-height:1.5;font-family:'宋体';">｝→｛</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">，……，</span><span style="line-height:1.5;font-family:Verdana;">m</span><span style="line-height:1.5;font-family:'宋体';">｝</span></em><span style="line-height:1.5;font-family:Verdana;">&nbsp;such that&nbsp;<em>f(i)=k</em>&nbsp;only if&nbsp;<em>c<sub>i</sub></em>&nbsp;is&nbsp;<em>a<sub>k</sub></em>&nbsp;and&nbsp;<em>F</em>&nbsp;is a monotone strictly increasing function(i.e.&nbsp;<em>F(i)=u,F(j)=v</em>,and&nbsp;<em>i&lt;j</em>&nbsp;imply that&nbsp;<em>u&lt;v</em>)</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">字符串</span><em><span style="line-height:1.5;font-family:Verdana;">C=c<sub>1</sub>c<sub>2</sub></span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">c<sub>p</sub></span></em><span style="line-height:1.5;font-family:'宋体';">是字符串</span><em><span style="line-height:1.5;font-family:Verdana;">A=a<sub>1</sub>a<sub>2</sub></span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">a<sub>m</sub></span></em><span style="line-height:1.5;font-family:'宋体';">的子序列，指的是存在一个映射</span><em><span style="line-height:1.5;font-family:Verdana;">F:</span><span style="line-height:1.5;font-family:'宋体';">｛</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">，……，</span><span style="line-height:1.5;font-family:Verdana;">p</span><span style="line-height:1.5;font-family:'宋体';">｝→｛</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">，……，</span><span style="line-height:1.5;font-family:Verdana;">m</span></em><span style="line-height:1.5;font-family:'宋体';"><em>｝</em>，当</span><span style="line-height:1.5;font-family:Verdana;"><em>f(i)=k</em></span><span style="line-height:1.5;font-family:'宋体';">，则</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>i</sub>=a</em><sub>k</sub></span><span style="line-height:1.5;font-family:'宋体';">，并且</span><span style="line-height:1.5;font-family:Verdana;">F</span><span style="line-height:1.5;font-family:'宋体';">是一个严格单调递增函数（举例说明：若</span><span style="line-height:1.5;font-family:Verdana;"><em>F(i)=u,F(j)=v</em>,</span><span style="line-height:1.5;font-family:'宋体';">当</span><span style="line-height:1.5;font-family:Verdana;"><em>i&lt;j</em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">则</span><span style="line-height:1.5;font-family:Verdana;"><em>u&lt;v</em></span><span style="line-height:1.5;font-family:'宋体';">）</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">String&nbsp;<em>C</em>&nbsp;is a common subsequence of strings&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;if and only if&nbsp;<em>C</em>&nbsp;is a subsequence of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>C</em>&nbsp;is a subsequence of&nbsp;<em>B</em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">字符串</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">是字符串</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的公共子序列，当且仅当</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">既是</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">的子序列，同时</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">又是</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的子序列</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">The problem can be stated as follows : Given strings&nbsp;<em>A=a<sub>1</sub>a<sub>2</sub>……a<sub>m</sub></em>&nbsp;and&nbsp;<em>B=b<sub>1</sub>b<sub>2</sub>……b<sub>n</sub></em>&nbsp;(over alphabet Σ), find a string&nbsp;<em>C= c<sub>1</sub>c<sub>2</sub>……c<sub>p</sub></em>&nbsp;such that&nbsp;<em>C</em>&nbsp;is a common subsequence of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;and&nbsp;<em>p</em>&nbsp;is maximized</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">求解最长公共子序列问题定义如下：给定字符串</span><em>A=a<sub>1</sub>a<sub>2</sub><span style="line-height:1.5;font-family:'宋体';">……</span>a<sub>m</sub></em><span style="line-height:1.5;font-family:'宋体';">和</span><em>B=b<sub>1</sub>b<sub>2</sub><span style="line-height:1.5;font-family:'宋体';">……</span>b<sub>n</sub></em><span style="line-height:1.5;font-family:'宋体';">（覆盖字符集</span><span style="line-height:1.5;font-family:'宋体';">Σ</span><span style="line-height:1.5;font-family:'宋体';">），找到一个字符串</span><em>C=c<sub>1</sub>c<sub>2</sub><span style="line-height:1.5;font-family:'宋体';">……</span>c<sub>p</sub></em><span style="line-height:1.5;font-family:'宋体';">，</span><em>C</em><span style="line-height:1.5;font-family:'宋体';">是</span><em>A</em><span style="line-height:1.5;font-family:'宋体';">和</span><em>B</em><span style="line-height:1.5;font-family:'宋体';">的公共子序列之中</span><em>p</em><span style="line-height:1.5;font-family:'宋体';">最大的那个</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">We call&nbsp;<em>C</em>&nbsp;an example of a maximal common subsequence.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">我们又把</span><em>C</em><span style="line-height:1.5;font-family:'宋体';">称作最大公共子序列</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>Notation</em>. For string&nbsp;<em>D=d<sub>1</sub>d<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>r</sub></em>&nbsp;,&nbsp;<em>D<sub>kt</sub></em>&nbsp;is&nbsp;<em>d<sub>k</sub>d<sub>k+1</sub></em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>t</sub></em>&nbsp;if&nbsp;<em>k≤t</em>;&nbsp;<em>d<sub>k</sub>d<sub>k-1</sub>……d<sub>t</sub></em>&nbsp;if&nbsp;<em>k≥1</em>. When&nbsp;<em>k&gt;t</em>&nbsp;, we shall write&nbsp;<em>~D<sub>kt</sub></em>&nbsp;so as to make clear that we are referring to a “reverse substring” of&nbsp;<em>D</em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">标记。对于字符串</span><em><span style="line-height:1.5;font-family:Verdana;">D=d<sub>1</sub>d<sub>2</sub></span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">d<sub>r</sub></span></em><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;"><em>D<sub>kt</sub></em></span><span style="line-height:1.5;font-family:'宋体';">表示为</span><em><span style="line-height:1.5;font-family:Verdana;">d<sub>k</sub>d<sub>k+1</sub></span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">d<sub>t</sub>&nbsp;(k≤t)</span></em><span style="line-height:1.5;font-family:'宋体';">；</span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>k</sub>d<sub>k-1</sub>……d<sub>t</sub>(k≥1)</em>,</span><span style="line-height:1.5;font-family:'宋体';">当</span><span style="line-height:1.5;font-family:Verdana;"><em>k&gt;t</em></span><span style="line-height:1.5;font-family:'宋体';">时，我们标记为</span><span style="line-height:1.5;font-family:Verdana;"><em>~D<sub>kt</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，称为</span><span style="line-height:1.5;font-family:Verdana;">D</span><span style="line-height:1.5;font-family:'宋体';">的“反转子串”</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em>&nbsp;is the maximum length possible of any common subsequence of&nbsp;<em>A<sub>1i</sub></em>&nbsp;and&nbsp;<em>B<sub>1j</sub></em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">表示为</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的所有可能的公共子序列的长度中最大值。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>x||y</em>&nbsp;is the concatenation of strings<em>&nbsp;x</em>&nbsp;and&nbsp;<em>y</em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>x||y</em></span><span style="line-height:1.5;font-family:'宋体';">表示为字符串</span><span style="line-height:1.5;font-family:Verdana;"><em>x</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>y</em></span><span style="line-height:1.5;font-family:'宋体';">的连接。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">We present the algorithm described in [3], which takes quadratic time and space</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">我们提到的算法出自</span><span style="line-height:1.5;font-family:Verdana;">[3]</span><span style="line-height:1.5;font-family:'宋体';">，它花费二次时间和空间</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong></strong></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Algorithm A</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"></span><strong><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">A</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Algorithm A accepts as input strings&nbsp;<em>A<sub>1m</sub></em>&nbsp;and&nbsp;<em>B<sub>1n</sub></em>&nbsp;and produces as output the matrix&nbsp;<em>L</em>&nbsp;(where the element&nbsp;<em>L(i,j)</em>&nbsp;corresponds to our notation of maximum length possible of any common subsequence of&nbsp;<em>A<sub>1i</sub></em>&nbsp;and&nbsp;<em>B<sub>1j</sub></em>)</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">接受输入字符串</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1m</sub></em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，并且计算输出矩阵</span><span style="line-height:1.5;font-family:Verdana;"><em>L</em></span><span style="line-height:1.5;font-family:'宋体';">（矩阵元素</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">如标记中所称，表示为</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的所有可能的公共子序列的长度中最大值。）</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>ALG A(m,n,A,B,L)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">1.&nbsp;<strong>Initialization</strong>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>L(i,0)</em></span><span style="line-height:1.5;font-family:'宋体';"><em>←</em></span><span style="line-height:1.5;font-family:Verdana;"><em>0&nbsp;[i=0……m]</em>;</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>L(0,j)←0&nbsp;[j=0……n]</em>;</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">2.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;</strong></span></span><span style="line-height:1.5;font-family:Verdana;"><strong>for</strong>&nbsp;<em>i←1</em>&nbsp;<strong>to</strong>&nbsp;<em>m</em>&nbsp;<strong>do</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>begin</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">3.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;</strong></span></span><span style="line-height:1.5;font-family:Verdana;"><strong>for</strong>&nbsp;<em>j←1</em>&nbsp;<strong>to</strong>&nbsp;<em>n</em>&nbsp;<strong>do</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>if</strong>&nbsp;<em>A(i)=B(j)</em>&nbsp;<strong>then</strong>&nbsp;<em>L(i,j)←L(i-1,j-1)+1</em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>else</strong>&nbsp;<em>L(i,j)←max{L(i,j-1),L(i-1,j)}</em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>end</strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Proof of correctness of Algorithm A</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">论证算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">的正确性</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To find&nbsp;<em>L(i,j)</em>&nbsp;,let a common subsequence of that length be denoted by&nbsp;<em>S(i,j)=c<sub>1</sub>c<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub></em>&nbsp;, If&nbsp;<em>a<sub>i</sub>=b<sub>j</sub></em>, we can do no better than by taking&nbsp;<em>c<sub>p</sub>=a<sub>i</sub></em>&nbsp;and looking for&nbsp;<em>c<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p-1</sub></em>&nbsp;as a common subsequence of length&nbsp;<em>L(i,j)-1</em>&nbsp;of string&nbsp;<em>A<sub>1,i-1</sub></em>&nbsp;and&nbsp;<em>B<sub>1,j-1</sub></em>. Thus , in this case ,<em>L(i,j)=L(i-1,j-1)+1</em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">为了计算</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">，把长度和其相等的公共子序列定义为</span><em><span style="line-height:1.5;font-family:Verdana;">S(i,j)=c<sub>1</sub>c<sub>2</sub></span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">c<sub>p</sub></span></em><span style="line-height:1.5;font-family:'宋体';">，如果</span><span style="line-height:1.5;font-family:Verdana;"><em>a<sub>i</sub>=b<sub>j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，则</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub>=a<sub>i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，并且</span><em><span style="line-height:1.5;font-family:Verdana;">c<sub>1</sub></span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">c<sub>p-1</sub></span></em><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1,i-1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1,j-1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的最长公共子序列，长度为</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)-1</em></span><span style="line-height:1.5;font-family:'宋体';">。因此，在这种情况下，</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)=L(i-1,j-1)+1</em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If&nbsp;<em>a<sub>i</sub>≠b<sub>j</sub></em>&nbsp;,then&nbsp;<em>c<sub>p</sub></em>&nbsp;is&nbsp;<em>a<sub>i</sub></em>,<em>b<sub>j</sub></em>, or neither (but not both). If&nbsp;<em>c<sub>p</sub></em>&nbsp;is&nbsp;<em>a<sub>i</sub></em>&nbsp;, then a solution&nbsp;<em>C</em>&nbsp;to problem(<em>A<sub>1i</sub>,B<sub>1j</sub></em>) [written&nbsp;<em>P(i,j)</em>] will be a solution to&nbsp;<em>P(i,j-1)</em>&nbsp;since&nbsp;<em>b<sub>j</sub></em>&nbsp;is not used. Similarly , if&nbsp;<em>c<sub>p</sub></em>&nbsp;is&nbsp;<em>b</em><sub><em>j</em>&nbsp;</sub>, then we can get a solution to&nbsp;<em>P(i,j)</em>&nbsp;by solving&nbsp;<em>P(i-1,j)</em>. If&nbsp;<em>c<sub>p</sub></em>&nbsp;is neither, then a solution to either&nbsp;<em>P(i-1,j)</em>&nbsp;or&nbsp;<em>P(i,j-1)</em>&nbsp;will suffice . In determining the length of the solution, it is seen that&nbsp;<em>L(i,j)</em>&nbsp;[corresponding to&nbsp;<em>P(i,j)</em>] will be the maximum of&nbsp;<em>L(i-1,j)</em>&nbsp;and&nbsp;<em>L(i,j-1)</em>.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">如果</span><span style="line-height:1.5;font-family:Verdana;"><em>a<sub>i</sub>≠b<sub>j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，则</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub></em></span><span style="line-height:1.5;font-family:'宋体';">要么是</span><span style="line-height:1.5;font-family:Verdana;"><em>a<sub>i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，要么是</span><span style="line-height:1.5;font-family:Verdana;"><em>b<sub>j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，要么两者都不是（肯定不会都是）。如果</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub>=a<sub>i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，因为</span><span style="line-height:1.5;font-family:Verdana;"><em>b<sub>j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">不是</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">的元素，则求解</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">的问题</span><span style="line-height:1.5;font-family:Verdana;">(<em>A<sub>1i</sub>,B<sub>1j</sub></em>)[</span><span style="line-height:1.5;font-family:'宋体';">写作</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i,j)</em>]</span><span style="line-height:1.5;font-family:'宋体';">等同于求解</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i,j-1)</em></span><span style="line-height:1.5;font-family:'宋体';">。同样的，如果</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub>=b<sub>j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，求解</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">等同于求解</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i-1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">。如果，</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>p</sub></em></span><span style="line-height:1.5;font-family:'宋体';">两者都不是，则必是</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i-1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i,j-1)</em></span><span style="line-height:1.5;font-family:'宋体';">中的一个。求解的长度称为</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em>[</span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>P(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">相一致</span><span style="line-height:1.5;font-family:Verdana;">]</span><span style="line-height:1.5;font-family:'宋体';">将会是</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i-1,j)</em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j-1)</em></span><span style="line-height:1.5;font-family:'宋体';">中的最大值。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Time and Space Analysis of Algorithm A</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;">A</span><span style="line-height:1.5;font-family:'宋体';">的时间和空间分析</span></strong></span></p> 
   <strong style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"></strong>
   <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"></span> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The if statement in Algorithm A will be executed exactly mn times. Input and output arrays require&nbsp;<em>m+n+(m+1)(n+1)</em>&nbsp;locations. Thus Algorithm A requires&nbsp;<em>O(mn)</em>&nbsp;time and&nbsp;<em>O(mn)</em>&nbsp;space.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">中的判断语句将会精确的执行</span><span style="line-height:1.5;font-family:Verdana;">mn</span><span style="line-height:1.5;font-family:'宋体';">次。输入和输出占用的空间需要</span><span style="line-height:1.5;font-family:Verdana;"><em>m+n+(m+1)(n+1)</em></span><span style="line-height:1.5;font-family:'宋体';">位置。因此，算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">需要</span><span style="line-height:1.5;font-family:Verdana;"><em>O(mn)</em></span><span style="line-height:1.5;font-family:'宋体';">时间和</span><span style="line-height:1.5;font-family:Verdana;"><em>O(mn)</em></span><span style="line-height:1.5;font-family:'宋体';">空间。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>　　Algorithm B</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">　　算法</span><span style="line-height:1.5;font-family:Verdana;">B</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">　　In Algorithm A, the derivation of row&nbsp;<em>i</em>&nbsp;of matrix&nbsp;<em>L(L(i,1), L(i,2),</em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>&nbsp;,L(i,n))</em>&nbsp;requires only row&nbsp;<em>i-1</em>&nbsp;of matrix&nbsp;<em>L</em>. Thus , a slight modification yields Algorithm B, which accepts as input strings&nbsp;<em>A<sub>1m</sub></em>&nbsp;and&nbsp;<em>B<sub>1n</sub></em>&nbsp;and produces as output vector&nbsp;<em>LL</em>&nbsp;where&nbsp;<em>LL(j)</em>&nbsp;will have the value&nbsp;<em>L(m,j)</em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">在算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">中，推导出</span><span style="line-height:1.5;font-family:Verdana;"><em>L</em></span><span style="line-height:1.5;font-family:'宋体';">矩阵中的第</span><span style="line-height:1.5;font-family:Verdana;"><em>i</em></span><span style="line-height:1.5;font-family:'宋体';">行<em>（</em></span><em><span style="line-height:1.5;font-family:Verdana;">L(i,1), L(i,2),&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">,L(i,n)</span></em><span style="line-height:1.5;font-family:'宋体';"><em>）</em>只需要矩阵</span><span style="line-height:1.5;font-family:Verdana;"><em>L</em></span><span style="line-height:1.5;font-family:'宋体';">的第</span><span style="line-height:1.5;font-family:Verdana;"><em>i-1</em></span><span style="line-height:1.5;font-family:'宋体';">行。一个细小的改观生成了算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">，该算法接受输入字符串</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1m</sub></em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，输出向量</span><span style="line-height:1.5;font-family:Verdana;"><em>LL</em></span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;"><em>LL(j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值就是矩阵</span><span style="line-height:1.5;font-family:Verdana;">L</span><span style="line-height:1.5;font-family:'宋体';">中的</span><span style="line-height:1.5;font-family:Verdana;"><em>L(m,j)</em></span><span style="line-height:1.5;font-family:'宋体';">。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ALG B(m,n,A,B,LL)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">1.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;"><strong>Initialization</strong>:<em>K(1,j)</em></span><em><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">0&nbsp;[j=0</span><span style="line-height:1.5;font-family:'宋体';">……</span></em><span style="line-height:1.5;font-family:Verdana;"><em>n]</em>;</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">2.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;</strong></span></span><span style="line-height:1.5;font-family:Verdana;"><strong>for</strong>&nbsp;<em>i</em></span><span style="line-height:1.5;font-family:'宋体';"><em>←</em></span><span style="line-height:1.5;font-family:Verdana;"><em>1</em>&nbsp;<strong>to</strong>&nbsp;<em>n</em>&nbsp;<strong>do</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>begin</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">3.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp;</em></span></span><em><span style="line-height:1.5;font-family:Verdana;">K(0,j)&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">K(1,j) [j=0</span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">n]</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">4.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;</strong></span></span><span style="line-height:1.5;font-family:Verdana;"><strong>for</strong>&nbsp;<em>j</em></span><span style="line-height:1.5;font-family:'宋体';"><em>←</em></span><span style="line-height:1.5;font-family:Verdana;"><em>1</em>&nbsp;<strong>to</strong>&nbsp;<em>n</em>&nbsp;<strong>do</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>if</strong>&nbsp;<em>A(i)=B(j)</em>&nbsp;<strong>then</strong>&nbsp;<em>K(1,j)&nbsp;</em></span><em><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">K(0,j-1)+1</span></em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>else</strong>&nbsp;<em>K(1,j)&nbsp;</em></span><em><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">max{K(1,j-1),K(0,j)}</span></em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>end</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">5.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><em><span style="line-height:1.5;font-family:Verdana;">LL(j)&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">K(1,j)&nbsp;[j=0</span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">n]</span></em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Proof of Correctness of Algorithm B</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">论证算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">的正确性</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Algorithm B is Algorithm A with&nbsp;<em>K(0,j)</em>&nbsp;in statement 4 of&nbsp;<strong>ALG B</strong>&nbsp;having the same value as&nbsp;<em>L(i-1,j)</em>&nbsp;in statement 3 of&nbsp;<strong>ALG A</strong>&nbsp;and&nbsp;<em>K(1,j)</em>&nbsp;receiving the same value as&nbsp;<em>L(i,j)</em>. We show this by induction on&nbsp;<em>i</em>.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">和算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">等价，就像</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">中的第四步计算</span><span style="line-height:1.5;font-family:Verdana;"><em>K(0,j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值和</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG A</strong></span><span style="line-height:1.5;font-family:'宋体';">中的第三步计算</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i-1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值是一样的。同理，</span><span style="line-height:1.5;font-family:Verdana;"><em>K(1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值和</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值一样。下面我们将根据</span><span style="line-height:1.5;font-family:Verdana;"><em>i</em></span><span style="line-height:1.5;font-family:'宋体';">的值进行归纳说明。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For&nbsp;<em>i=1</em>&nbsp;,&nbsp;<em>L(i-1,j)</em>&nbsp;is zero (initialized in statement 1 of&nbsp;<strong>ALG A</strong>). In&nbsp;<strong>ALG B</strong>,&nbsp;<em>K(0,j)</em>&nbsp;received in statement 3 the value of&nbsp;<em>K(1,j)</em>&nbsp;, which was just initialized to zero in statement 1.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">当</span><span style="line-height:1.5;font-family:Verdana;">i=1</span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i-1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">为</span><span style="line-height:1.5;font-family:Verdana;">0</span><span style="line-height:1.5;font-family:'宋体';">（在</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG A</strong></span><span style="line-height:1.5;font-family:'宋体';">中的第一步初始化数据后）。在</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">中的第</span><span style="line-height:1.5;font-family:Verdana;">3</span><span style="line-height:1.5;font-family:'宋体';">步中，</span><span style="line-height:1.5;font-family:Verdana;"><em>K(0,j)</em></span><span style="line-height:1.5;font-family:'宋体';">从</span><span style="line-height:1.5;font-family:Verdana;"><em>K(1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">获得</span><span style="line-height:1.5;font-family:Verdana;">0</span><span style="line-height:1.5;font-family:'宋体';">值，因为</span><span style="line-height:1.5;font-family:Verdana;"><em>K(1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">在第一步中就已经初始化为</span><span style="line-height:1.5;font-family:Verdana;">0</span><span style="line-height:1.5;font-family:'宋体';">了。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assuming&nbsp;<em>K(0,j)</em>&nbsp;has the same value as does&nbsp;<em>L(i-1,j)</em>. Then&nbsp;<em>K(1,j)</em>&nbsp;receives the same value as&nbsp;<em>L(i,j)</em>&nbsp;since the assignment statement within the inner loops of&nbsp;<strong>ALG A</strong>&nbsp;and&nbsp;<strong>ALG B</strong>&nbsp;are equivalent . For the next iteration,&nbsp;<em>K(0,j)</em>&nbsp;receives (in statement 3 of&nbsp;<strong>ALG B</strong>) the value of&nbsp;<em>K(1,j)</em>&nbsp;which has the value of&nbsp;<em>L(i,j)</em>&nbsp;as shown above.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">假定</span><span style="line-height:1.5;font-family:Verdana;"><em>K(0,j)</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i-1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">值一样。那么</span><span style="line-height:1.5;font-family:Verdana;"><em>K(1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">像</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">一样获取同样的值，因为在</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG A</strong></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">中指定的循环步骤是一致的。在下一个循环之前，</span><span style="line-height:1.5;font-family:Verdana;"><em>K(0,j)</em></span><span style="line-height:1.5;font-family:'宋体';">获取</span><span style="line-height:1.5;font-family:Verdana;"><em>K(1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值（在</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">中的第</span><span style="line-height:1.5;font-family:Verdana;">3</span><span style="line-height:1.5;font-family:'宋体';">步），就像上面所示，</span><span style="line-height:1.5;font-family:Verdana;"><em>K(1,j)</em></span><span style="line-height:1.5;font-family:'宋体';">的值就是</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Time and Space Analysis of Algorithm B</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">的时间和空间分析</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">　　As in Algorithm A , the if statement in Algorithm B is executed exactly&nbsp;<em>mn</em>&nbsp;times. Input and output arrays require&nbsp;<em>m+n+(n+1)</em>&nbsp;locations. Local storage requires&nbsp;<em>2(n+1)</em>&nbsp;locations. Thus Algorithm B requires&nbsp;<em>O(mn)</em>&nbsp;time and&nbsp;<em>O(m+n)</em>&nbsp;space.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">和算法</span><span style="line-height:1.5;font-family:Verdana;">A</span><span style="line-height:1.5;font-family:'宋体';">一样，算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">的判断语句也会精确的执行</span><span style="line-height:1.5;font-family:Verdana;"><em>mn</em></span><span style="line-height:1.5;font-family:'宋体';">次。输入和输出占用</span><span style="line-height:1.5;font-family:Verdana;"><em>m+n+(n+1)</em></span><span style="line-height:1.5;font-family:'宋体';">位置，算法内部占用</span><span style="line-height:1.5;font-family:Verdana;"><em>2(n+1)</em></span><span style="line-height:1.5;font-family:'宋体';">位置。因此算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">需要</span><span style="line-height:1.5;font-family:Verdana;"><em>O(mn)</em></span><span style="line-height:1.5;font-family:'宋体';">时间和</span><span style="line-height:1.5;font-family:Verdana;"><em>O(m+n)</em></span><span style="line-height:1.5;font-family:'宋体';">空间。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';"></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">　　</span><span style="line-height:1.5;color:#FF0000;font-family:'宋体';">注：该算法还可以优化，使得LL()只占用n个位置，而不是2n个位置</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We shall show that using Algorithm B for appropriate substrings of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;will enable us to recover a maximal common subsequence of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;in linear space.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">接下来，我们要用算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">在线性空间中利用</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的合适子串来找回</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的最大公共子序列。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define&nbsp;<em>L*(i,j)</em>&nbsp;to be the maximum length of common subsequence of<em>&nbsp;A<sub>i+1,m</sub></em>&nbsp;and&nbsp;<em>B<sub>j+1,n</sub></em>.</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">定义</span><span style="line-height:1.5;font-family:Verdana;"><em>L*(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>i+1,m</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>j+1,n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的最大公共子序列</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">We note that&nbsp;<em>L(i,j) j=0</em></span><span style="line-height:1.5;font-family:'宋体';"><em>……</em></span><span style="line-height:1.5;font-family:Verdana;"><em>n</em>&nbsp;are the maximum lengths of common subsequence of&nbsp;<em>A<sub>1i</sub></em>&nbsp;and various prefixes of&nbsp;<em>B<sub>1n</sub></em>. We also note that&nbsp;<em>L*(i,j) j=0<span style="line-height:1.5;font-family:'宋体';"><em>……</em></span>n</em>&nbsp;are the maximum lengths of common subsequence of&nbsp;<em>~A<sub>m,i+1</sub></em>&nbsp;and various prefixes of&nbsp;<em>~B<sub>n,1</sub></em>.Choosing&nbsp;<em>i</em>&nbsp;to be&nbsp;<em>m/2</em>&nbsp;and using the theorem below , we shall be able to determine a prefix&nbsp;<em>B<sub>1</sub></em>&nbsp;of&nbsp;<em>B</em>&nbsp;which can be matched with the first half&nbsp;<em>A<sub>1</sub></em>&nbsp;of&nbsp;<em>A</em>&nbsp;(and the corresponding suffix&nbsp;<em>B<sub>2</sub></em>&nbsp;of&nbsp;<em>B</em>&nbsp;matched with the last half&nbsp;<em>A<sub>2</sub></em>&nbsp;of&nbsp;<em>A</em>) such that a maximal common subsequence (mcs) of&nbsp;<em>A<sub>1</sub></em>&nbsp;and&nbsp;<em>B<sub>1</sub></em>&nbsp;concatenated with an mcs of&nbsp;<em>A<sub>2</sub></em>&nbsp;and&nbsp;<em>B<sub>2</sub></em>&nbsp;will be an mcs of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">　　我们注意到</span><em><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">L(i,j) j=0</span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">……</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">n</span></em><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">表示</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">A<sub>1i</sub></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">B<sub>1n</sub></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的一些前缀的公共子序列的长度最大值。我们同时注意到</span><em><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">L*(i,j) j=0</span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">……</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">n</span></em><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">表示</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>~A<sub>m,i+1</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>~B<sub>n,1</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的一些前缀的公共子序列的长度最大值。在下面的定理中，令</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>i</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">为</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>m/2</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">，我们能确定</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的一个前缀</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>B<sub>1</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">能和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的前半部分</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A<sub>1</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">匹配（同时相对应的</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的后缀</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>B<sub>2</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的后半部分</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A<sub>2</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">匹配）。如此，</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A<sub>1</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;">B<sub>1</sub></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的最大公共子序列和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A<sub>2</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>B<sub>2</sub></em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的最大公共子序列连接起来就是</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">和</span><span style="line-height:1.5;font-size:10.5pt;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-size:10.5pt;font-family:'宋体';">的最大公共子序列。</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">　　<strong>Define</strong>&nbsp;　　<em>M(i)=max{L(i,j)+L*(i,j)}　　0≤i≤n</em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">　　<strong>THEOREM</strong>　<em>For</em>&nbsp;　<em>0≤i≤m</em>,<em>&nbsp;M(i)=L(m,n)</em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">PROOF . Let&nbsp;<em>M(i)=L(i,j)+L*(i,j)</em>&nbsp;for some&nbsp;<em>j</em>. Let&nbsp;<em>S(i,j)</em>&nbsp;be any maximal common subsequence of&nbsp;<em>A<sub>1i</sub></em>&nbsp;and&nbsp;<em>B<sub>1j</sub></em>; let&nbsp;<em>S*(i,j)</em>&nbsp;be any maximal common subsequence of&nbsp;<em>A<sub>i+1,m</sub></em>&nbsp;and&nbsp;<em>B<sub>j+1,n</sub></em>&nbsp;. Then&nbsp;<em>C=S(i,j) || S*(i,j)</em>&nbsp;is a common subsequence of&nbsp;<em>A<sub>1m</sub></em>&nbsp;and&nbsp;<em>B<sub>1n</sub></em>of length&nbsp;<em>M(i)</em>. Thus&nbsp;<em>L(m,n</em></span><em><span style="line-height:1.5;font-family:'宋体';">)</span><span style="line-height:1.5;font-family:'宋体';">≥</span><span style="line-height:1.5;font-family:Verdana;">M(i)</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">证明。当</span><span style="line-height:1.5;font-family:Verdana;"><em>j</em></span><span style="line-height:1.5;font-family:'宋体';">取某些值的时候，</span><span style="line-height:1.5;font-family:Verdana;"><em>M(i)=L(i,j)+L*(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">。让</span><span style="line-height:1.5;font-family:Verdana;"><em>S(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">是某个</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的最大公共子序列；让</span><span style="line-height:1.5;font-family:Verdana;"><em>S*(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">是某个</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>i+1,m</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>j+1,n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的最大公共子序列。那么</span><span style="line-height:1.5;font-family:Verdana;"><em>C=S(i,j) || S*(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">就是</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1m</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的一个公共子序列，且长度为</span><span style="line-height:1.5;font-family:Verdana;"><em>M(i)</em></span><span style="line-height:1.5;font-family:'宋体';">。因此</span><em><span style="line-height:1.5;font-family:Verdana;">L(m,n</span><span style="line-height:1.5;font-family:'宋体';">)</span><span style="line-height:1.5;font-family:'宋体';">≥</span><span style="line-height:1.5;font-family:Verdana;">M(i)</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;">Let&nbsp;<em>S(m,n)</em>&nbsp;be any maximal common subsequence of&nbsp;<em>A<sub>1m</sub></em>&nbsp;and&nbsp;<em>B<sub>1n</sub></em>.&nbsp;<em>S(m,n)</em>&nbsp;is a subsequence of&nbsp;<em>B</em>&nbsp;that is&nbsp;<em>S<sub>1</sub></em>&nbsp;(a subsequence of&nbsp;<em>A<sub>1i</sub></em>) ||&nbsp;<em>S<sub>2</sub></em>&nbsp;( a subsequence of&nbsp;<em>A<sub>i+1,m</sub></em>). Then there exists&nbsp;<em>j</em>&nbsp;such that&nbsp;<em>S<sub>1</sub></em>&nbsp;is a subsequence of&nbsp;<em>B<sub>1j</sub></em>&nbsp;and&nbsp;<em>S<sub>2</sub></em>&nbsp;is a subsequence of&nbsp;<em>B<sub>j+1,n</sub></em>&nbsp;. By definition of&nbsp;<em>L</em>&nbsp;and&nbsp;<em>L*</em>,&nbsp;<em>|S<sub>1</sub>|</em></span><span style="line-height:1.5;"><em>≤L(i,j)</em>&nbsp;and&nbsp;<em>|S<sub>2</sub>|</em></span><span style="line-height:1.5;font-family:'宋体';"><em>≤</em></span><span style="line-height:1.5;font-family:Verdana;"><em>L*(i,j)</em>. Thus&nbsp;<em>L(m,n)=|S(m,n)|=|S<sub>1</sub>|+|S<sub>2</sub>|</em></span><em><span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">L(i,j)+L*(i,j)</span>&nbsp;<span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">M(i)</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">让</span><span style="line-height:1.5;font-family:Verdana;"><em>S(m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">是某个</span><span style="line-height:1.5;font-family:Verdana;"><em>A<sub>1m</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的最大公共子序列。</span><span style="line-height:1.5;font-family:Verdana;"><em>S(m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的一个子序列，且就是</span><span style="line-height:1.5;font-family:Verdana;"><em>S<sub>1</sub></em>&nbsp;(<em>A<sub>1i</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的一个子序列</span><span style="line-height:1.5;font-family:Verdana;">) ||&nbsp;<em>S<sub>2</sub>&nbsp;</em>(<em>A<sub>i+1,m</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的一个子序列</span><span style="line-height:1.5;font-family:Verdana;">)</span><span style="line-height:1.5;font-family:'宋体';">。那么，必存在</span><span style="line-height:1.5;font-family:Verdana;"><em>j</em></span><span style="line-height:1.5;font-family:'宋体';">，使得</span><span style="line-height:1.5;font-family:Verdana;"><em>S<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>1j</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的子序列，同时</span><span style="line-height:1.5;font-family:Verdana;"><em>S<sub>2</sub></em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;font-family:Verdana;"><em>B<sub>j+1,n</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的子序列。根据</span><span style="line-height:1.5;font-family:Verdana;"><em>L</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>L*</em></span><span style="line-height:1.5;">的定义，<em>|S<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">|</span><span style="line-height:1.5;"><em>≤L(i,j)</em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">同时</span><em><span style="line-height:1.5;font-family:Verdana;">|S<sub>2</sub>|</span><span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">L*(i,j)</span></em><span style="line-height:1.5;font-family:'宋体';">。因此，</span><em><span style="line-height:1.5;font-family:Verdana;">L(m,n)=|S(m,n)|=|S<sub>1</sub>|+|S<sub>2</sub>|</span><span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">L(i,j)+L*(i,j)</span>&nbsp;<span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">M(i)</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;color:#FF0000;">注：典型的数学证明法。要证明A=B。先证明A≥B，再证明A≤B。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Algorithm C</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">C</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">We now apply the above theorem recursively to divide a given problem into two smaller problems until we obtain a trivial subproblem.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">现在，我们根据上面的定理递归的将一个给定的问题分成两个小问题直到能获得一个不成问题的子问题。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Algorithm C accepts as input stings&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;(of length&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>) and produces as output a common subsequence&nbsp;<em>C</em>&nbsp;of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;that is of Maximum length&nbsp;<em>p</em>.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">获得输入字符串</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">（长度分别为</span><span style="line-height:1.5;font-family:Verdana;"><em>m</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>n</em></span><span style="line-height:1.5;font-family:'宋体';">），然后计算输出</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的一个公共子序列</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">，且</span><span style="line-height:1.5;font-family:Verdana;"><em>C</em></span><span style="line-height:1.5;font-family:'宋体';">是最长的，长度为</span><span style="line-height:1.5;font-family:Verdana;"><em>p</em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C(m,n,A,B,C)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">1.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;</strong></span></span><span style="line-height:1.5;font-family:Verdana;"><strong>If problem is trivial , solve it:</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>If</strong>&nbsp;<em>n=0</em>&nbsp;<strong>then</strong>&nbsp;<em>C</em></span><span style="line-height:1.5;font-family:'宋体';"><em>←</em></span><span style="line-height:1.5;font-family:Verdana;"><em>e</em>&nbsp;(<em>e is empty string</em>)</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Else if</strong>&nbsp;<em>m=1</em>&nbsp;<strong>then if</strong>&nbsp;&nbsp;<strong>存在</strong><em>j≤n such that A(1)=B(j)　　</em></span><span style="line-height:1.5;color:#FF0000;font-family:Verdana;">注：存在的标记没法打出来，故用了中文</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Then</strong>&nbsp;<em>C</em></span><em><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">A(1)</span></em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Else</strong>&nbsp;<em>C</em></span><em><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">e</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">2.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;"><strong>Otherwise, split problem:</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Else begin</strong><em>&nbsp;i</em></span><em><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">[m/2]</span></em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">3.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;"><strong>Evaluate</strong>&nbsp;<em>L(i,j)</em>&nbsp;<strong>and</strong>&nbsp;<em>L*(i,j)</em>&nbsp;[j=0</span><span style="line-height:1.5;font-family:'宋体';">……</span><span style="line-height:1.5;font-family:Verdana;">n]:</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B(<em>i,n,A<sub>1i</sub>,B<sub>1n</sub>,L1</em>)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B(<em>m-i,n,~A<sub>n,i+1</sub>,~B<sub>n1</sub>,L2</em>)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">4.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;"><strong>Find</strong>&nbsp;<em>j such that L(i,j)+L*(i,j)=L(m,n) using theorem:</em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong><em>M</em></strong></span><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;"><em>max{L1(j)+L2(n-j)};<em>0≤i≤n</em></em></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em><strong>k</strong></em></span><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;"><em>min j such that L1(j)+L2(n-j)=<strong>M</strong></em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">5.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;"><strong>Solve simpler problems:</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C (<em>i,k,A<sub>1i</sub>,B<sub>1k</sub>,C1</em>)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C (<em>m-i,n-k,A<sub>i+1m</sub>,B<sub>k+1,n</sub>,C2</em>)</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">6.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;</strong></span></span><span style="line-height:1.5;font-family:Verdana;"><strong>Give output</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><em><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">←</span><span style="line-height:1.5;font-family:Verdana;">C1 || C2</span></em></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>end</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong></strong></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Proof of Correctness of Algorithm C</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">论证算法</span><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">的正确性</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>L1(j)</em>&nbsp;produced by the first call to&nbsp;<strong>ALG B</strong>&nbsp;in line 3 is equal to&nbsp;<em>L(i,j)</em>. This was shown in the proof of correctness of Algorithm B. Similarly ,&nbsp;<em>L2(j)</em>&nbsp;is equal to the maximum length of common subsequence (max lcs) of&nbsp;<em>~A<sub>m,i+1</sub></em>&nbsp;and&nbsp;<em>~B<sub>n,n-j+1</sub></em>&nbsp;by the proof of correctness of Algorithm B .</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">在第</span><span style="line-height:1.5;font-family:Verdana;">3</span><span style="line-height:1.5;font-family:'宋体';">行第一次调用</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">计算出的</span><span style="line-height:1.5;font-family:Verdana;"><em>L1(j)</em></span><span style="line-height:1.5;font-family:'宋体';">等价于</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">，这个在“论证算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">的正确性”中就说明了。同样的，</span><span style="line-height:1.5;font-family:Verdana;"><em>L2(j)</em></span><span style="line-height:1.5;font-family:'宋体';">等同于</span><span style="line-height:1.5;font-family:Verdana;"><em>~A<sub>m,i+1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>~B<sub>n,n-j+1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的公共子序列中的长度最大值也在“论证算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">的正确性”中说明了。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';"></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><em>L2(n-j)=max lcs of ~A<sub>m,i+1</sub>&nbsp;and ~B<sub>n,j+1</sub>=max lcs of A<sub>i+1,m</sub>&nbsp;and B<sub>j+1,n</sub>=L*(i,j)</em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';"></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">By our theorem , we can find&nbsp;<em>k</em>&nbsp;(as in line 4) such that&nbsp;<em>L(i,k)+L*(i,k)=L(m,n)</em>. So there must exist solutions&nbsp;<em>C1</em>&nbsp;and&nbsp;<em>C2</em>&nbsp;to the subproblems (<em>A<sub>1i</sub></em>,&nbsp;<em>B<sub>1k</sub></em>) and (<em>A<sub>i+1,m</sub></em>,<em>B<sub>k+1,n</sub></em>) such that&nbsp;<em>C1 || C2</em>&nbsp;will be a common subsequence of&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;of length&nbsp;<em>L(m,n)</em>. The solutions to the subproblems are obtained in line 5 and are added together in line 6 to obtain the final output .</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">根据我们的定理，我们能找到</span><span style="line-height:1.5;font-family:Verdana;"><em>k</em></span><span style="line-height:1.5;font-family:'宋体';">（在第</span><span style="line-height:1.5;font-family:Verdana;">4</span><span style="line-height:1.5;font-family:'宋体';">步），使得</span><span style="line-height:1.5;font-family:Verdana;"><em>L(i,k)+L*(i,k)=L(m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">。那么就一定存在</span><span style="line-height:1.5;font-family:Verdana;"><em>C1</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>C2</em></span><span style="line-height:1.5;font-family:'宋体';">，分别是子问题</span><span style="line-height:1.5;font-family:Verdana;">(<em>A<sub>1i</sub></em>,&nbsp;<em>B<sub>1k</sub></em>)</span><span style="line-height:1.5;font-family:'宋体';">和子问题</span><span style="line-height:1.5;font-family:Verdana;">(<em>A<sub>i+1,m</sub></em>,<em>B<sub>k+1,n</sub></em>)</span><span style="line-height:1.5;font-family:'宋体';">的解，而</span><span style="line-height:1.5;font-family:Verdana;"><em>C1 || C2</em></span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">的长度为</span><span style="line-height:1.5;font-family:Verdana;"><em>L(m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">的公共子序列。求解过程在第</span><span style="line-height:1.5;font-family:Verdana;">5</span><span style="line-height:1.5;font-family:'宋体';">步获得子问题的解，并在第</span><span style="line-height:1.5;font-family:Verdana;">6</span><span style="line-height:1.5;font-family:'宋体';">步将两个子问题的解连接起来并最终输出。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Time Analysis of Algorithm C</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">的时间分析</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">For&nbsp;<em>P(1,n)</em>&nbsp;we look for a single match . For some constants&nbsp;<em>c<sub>1</sub></em>&nbsp;and&nbsp;<em>c<sub>2</sub></em>&nbsp;this is time-bounded by&nbsp;<em>c<sub>1</sub>n+c<sub>2</sub></em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">针对</span><span style="line-height:1.5;font-family:Verdana;"><em>P(1,n)</em></span><span style="line-height:1.5;font-family:'宋体';">，我们找到一个单独的匹配。给定常量</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">，时间临界点为</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>1</sub>n+c<sub>2</sub></em></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">For&nbsp;<em>P(2m,n)</em>&nbsp;, let operations on vectors that are linear in&nbsp;<em>m</em>&nbsp;or<em>&nbsp;n</em>&nbsp;be time-bounded by&nbsp;<em>c<sub>3</sub>m+c<sub>4</sub>n+c<sub>5</sub></em>. That leaves two calls to&nbsp;<strong>ALG B</strong>&nbsp;and two calls to&nbsp;<strong>ALG C</strong>. the calls to&nbsp;<strong>ALG B</strong>&nbsp;are bounded by&nbsp;<em>c<sub>6</sub>mn</em>&nbsp;by time analysis of&nbsp;<strong>ALG B</strong>&nbsp;. Assume&nbsp;<em>P(m,n)</em>&nbsp;is time-bounded by&nbsp;<em>d<sub>1</sub>mn+d<sub>2</sub></em>(<em>d</em></span><em><sub><span style="line-height:1.5;font-family:'宋体';">1</span></sub><span style="line-height:1.5;font-family:'宋体';">≥</span><span style="line-height:1.5;font-family:Verdana;">c<sub>1</sub>,d<sub>2</sub></span><span style="line-height:1.5;font-family:'宋体';">≥</span></em><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>2</sub></em>). Then the calls to&nbsp;<strong>ALG C</strong>&nbsp;will be time-bounded by&nbsp;<em>d<sub>1</sub>mk+d<sub>2</sub></em>&nbsp;and&nbsp;<em>d<sub>1</sub>m(n-k)+d<sub>2</sub></em>. Thus a total time-bound T for&nbsp;<em>P(2m,n)</em>&nbsp;will be&nbsp;<em>T=(d<sub>1</sub>+c<sub>6</sub>)mn+c<sub>3</sub>m+c<sub>4</sub>n+c<sub>5</sub>+2d<sub>2</sub></em>. For&nbsp;<em>n</em></span><em><span style="line-height:1.5;font-family:'宋体';">≥</span><span style="line-height:1.5;font-family:Verdana;">1,</span><span style="line-height:1.5;font-family:'宋体';">T</span><span style="line-height:1.5;font-family:'宋体';">≤</span></em><span style="line-height:1.5;font-family:Verdana;"><em>(d<sub>1</sub>+c<sub>6</sub>+c<sub>3</sub>+c<sub>4</sub>+c<sub>5</sub>+d<sub>2</sub>)mn+d<sub>2</sub></em>. For&nbsp;<em>n=0 , let T</em></span><span style="line-height:1.5;font-family:'宋体';"><em>≤</em></span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>2</sub></em>&nbsp;. Then to be consistent with our assumption on the time-bound of&nbsp;<em>P(m,n)</em>&nbsp;, we must have&nbsp;<em>d<sub>1</sub>+c<sub>6</sub>+c<sub>3</sub>+c<sub>4</sub>+c<sub>5</sub>+d<sub>2</sub>≤2d<sub>1</sub></em>&nbsp;, which is realizable by letting&nbsp;<em>d<sub>1</sub>=c<sub>6</sub>+c<sub>3</sub>+c<sub>4</sub>+c<sub>5</sub>+d<sub>2</sub></em>.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">针对</span><span style="line-height:1.5;font-family:Verdana;"><em>P(2m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">，在向量的操作上，时间是关于</span><span style="line-height:1.5;font-family:Verdana;"><em>m</em></span><span style="line-height:1.5;font-family:'宋体';">或者</span><span style="line-height:1.5;font-family:Verdana;"><em>n</em></span><span style="line-height:1.5;font-family:'宋体';">线性的，时间临界点是</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>3</sub>m+c<sub>4</sub>n+c<sub>5</sub></em></span><span style="line-height:1.5;font-family:'宋体';">。还要执行两次</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">和两次</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">。根据</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">的时间分析，执行</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">的时间临界点为</span><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>6</sub>mn</em></span><span style="line-height:1.5;font-family:'宋体';">。假定</span><span style="line-height:1.5;font-family:Verdana;"><em>P(m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">的时间临界点为</span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>1</sub>mn+d<sub>2</sub></em>(<em>d</em></span><em><sub><span style="line-height:1.5;font-family:'宋体';">1</span></sub><span style="line-height:1.5;font-family:'宋体';">≥</span><span style="line-height:1.5;font-family:Verdana;">c<sub>1</sub>,d<sub>2</sub></span><span style="line-height:1.5;font-family:'宋体';">≥</span></em><span style="line-height:1.5;font-family:Verdana;"><em>c<sub>2</sub></em>)</span><span style="line-height:1.5;font-family:'宋体';">。那么执行两次</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">的时间临界点分别为</span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>1</sub>mk+d<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>1</sub>m(n-k)+d<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">。因此，</span><span style="line-height:1.5;font-family:Verdana;"><em>P(2m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">的总共时间临界点</span><span style="line-height:1.5;font-family:Verdana;"><em>T</em></span><span style="line-height:1.5;font-family:'宋体';">，将会是</span><span style="line-height:1.5;font-family:Verdana;"><em>T=(d<sub>1</sub>+c<sub>6</sub>)mn+c<sub>3</sub>m+c<sub>4</sub>n+c<sub>5</sub>+2d<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">。当</span><em><span style="line-height:1.5;font-family:Verdana;">n</span><span style="line-height:1.5;font-family:'宋体';">≥</span><span style="line-height:1.5;font-family:Verdana;">1</span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:'宋体';">T</span><span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">(d<sub>1</sub>+c<sub>6</sub>+c<sub>3</sub>+c<sub>4</sub>+c<sub>5</sub>+d<sub>2</sub>)mn+d<sub>2</sub></span></em><span style="line-height:1.5;font-family:'宋体';">。当</span><span style="line-height:1.5;font-family:Verdana;"><em>n=0</em></span><span style="line-height:1.5;font-family:'宋体';">时，</span><em><span style="line-height:1.5;font-family:Verdana;">T</span><span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">d<sub>2</sub></span></em><span style="line-height:1.5;font-family:'宋体';">。那么就象我们始终如一的假定</span><span style="line-height:1.5;font-family:Verdana;"><em>P(m,n)</em></span><span style="line-height:1.5;font-family:'宋体';">的时间临界点，我们一定会得到</span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>1</sub>+c<sub>6</sub>+c<sub>3</sub>+c<sub>4</sub>+c<sub>5</sub>+d<sub>2</sub>≤2d<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">。不妨写成</span><span style="line-height:1.5;font-family:Verdana;"><em>d<sub>1</sub>=c<sub>6</sub>+c<sub>3</sub>+c<sub>4</sub>+c<sub>5</sub>+d<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Thus Algorithm C has an&nbsp;<em>O(mn)</em>&nbsp;time bound.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">因此算法</span><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">需要时间</span><span style="line-height:1.5;font-family:Verdana;"><em>O(mn)</em></span><span style="line-height:1.5;font-family:'宋体';">。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;color:#FF0000;">注：由于英文水平有限，这一段翻的很干涩。其实当看到</span><span style="line-height:1.5;color:#FF0000;font-family:Verdana;"><em>T=(d<sub>1</sub>+c<sub>6</sub>)mn+c<sub>3</sub>m+c<sub>4</sub>n+c<sub>5</sub>+2d<sub>2</sub></em></span><span style="line-height:1.5;color:#FF0000;">时，就知道算法C的时间为</span><span style="line-height:1.5;color:#FF0000;font-family:Verdana;"><em>O(mn)</em></span><span style="line-height:1.5;color:#FF0000;">。因为式子的最高次是</span><em style="color:#FF0000;">mn</em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Space Analysis of Algorithm C</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>算法C的空间分析</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">We assume that vectors&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>&nbsp;are in common storage and substrings can be transferred as arguments by giving initial and final locations.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">我们假设向量</span><span style="line-height:1.5;font-family:Verdana;"><em>A</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>B</em></span><span style="line-height:1.5;font-family:'宋体';">存储在公共空间并且他们的子串能作为传递参数在初始化过程和确定的位置。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Then ,during execution, the calls to&nbsp;<strong>ALG B</strong>&nbsp;use temporary storage which is linear in&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>&nbsp;(see space analysis of Algorithm B) . It is seen that ,exclusive of recursive calls to&nbsp;<strong>ALG C</strong>&nbsp;,&nbsp;<strong>ALG C</strong>&nbsp;uses a constant amount of memory space. There are&nbsp;<em>2m-1</em>&nbsp;calls to&nbsp;<strong>ALG C</strong>&nbsp;(proven below) , and so&nbsp;<strong>ALG C</strong>&nbsp;requires memory space proportional to&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>&nbsp;, i.e.&nbsp;<em>O(m+n)</em>&nbsp;space.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">那么在整个计算过程中，调用</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG B</strong></span><span style="line-height:1.5;font-family:'宋体';">临时存储空间是和</span><span style="line-height:1.5;font-family:Verdana;"><em>m</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>n</em></span><span style="line-height:1.5;font-family:'宋体';">的线性相关的（在算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">的空间分析里说明）。这就像是，独享的递归调用</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">，</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">占用一块总量固定的内存空间。一共要调用</span><em><span style="line-height:1.5;font-family:Verdana;">2m</span><span style="line-height:1.5;font-family:Verdana;">-1</span></em><span style="line-height:1.5;font-family:'宋体';">次</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">（在后面证明），那么所以</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">需要的内存空间为和</span><span style="line-height:1.5;font-family:Verdana;"><em>m</em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>n</em></span><span style="line-height:1.5;font-family:'宋体';">成比例，也就是</span><span style="line-height:1.5;font-family:Verdana;"><em>O(m+n)</em></span><span style="line-height:1.5;font-family:'宋体';">空间</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><strong>Proof That There Are&nbsp;<em>2m-1</em>&nbsp;Calls to ALG C</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><strong><span style="line-height:1.5;font-family:'宋体';">证明，一共调用</span><em><span style="line-height:1.5;font-family:Verdana;">2m</span><span style="line-height:1.5;font-family:Verdana;">-1</span></em><span style="line-height:1.5;font-family:'宋体';">次</span><span style="line-height:1.5;font-family:Verdana;">ALG C</span></strong></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Let&nbsp;<em>m≤2<sup>r</sup></em>. If<em>&nbsp;r</em>&nbsp;is zero , then&nbsp;<em>m</em>&nbsp;is one , and there are&nbsp;<em>2<sup>1</sup>-1=1</em>&nbsp;call to&nbsp;<strong>ALG C</strong></span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"><span style="line-height:1.5;font-family:'宋体';">设</span><span style="line-height:1.5;"><em>m&lt;=2<sup>r</sup></em></span><span style="line-height:1.5;font-family:'宋体';">。如果</span><span style="line-height:1.5;"><em>r</em></span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;"><em>0</em></span><span style="line-height:1.5;font-family:'宋体';">，那么</span><span style="line-height:1.5;"><em>m</em></span><span style="line-height:1.5;font-family:'宋体';">是</span><span style="line-height:1.5;"><em>1</em></span><span style="line-height:1.5;font-family:'宋体';">，那么一共有</span><span style="line-height:1.5;"><em>2<sup>1</sup>-1=1</em></span><span style="line-height:1.5;font-family:'宋体';">次调用</span><span style="line-height:1.5;"><strong>ALG C</strong></span></span></p> 
   <strong style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"></strong>
   <span style="font-family:Verdana, Arial, Helvetica, sans-serif;font-size:15px;"></span> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;"></span>&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Assume that for&nbsp;<em>m</em></span><span style="line-height:1.5;font-family:'宋体';"><em>≤</em></span><span style="line-height:1.5;font-family:Verdana;"><em>2<sup>r</sup>=M</em>&nbsp;there are&nbsp;<em>2m-1</em>&nbsp;to calls to&nbsp;<strong>ALG C</strong>. For&nbsp;<em>m’</em></span><em>&nbsp;<span style="line-height:1.5;font-family:'宋体';">≤</span></em><span style="line-height:1.5;font-family:Verdana;"><em>2<sup>r+1</sup>=2M</em>,&nbsp;<em>i</em>&nbsp;will be set equal to at most&nbsp;<em>M&nbsp;</em>in line 2. There will be two calls to&nbsp;<strong>ALG C</strong>&nbsp;with first parameters&nbsp;<em>m<sub>1</sub></em>&nbsp;and&nbsp;<em>m<sub>2</sub></em>&nbsp;such that&nbsp;<em>m<sub>1</sub>+m<sub>2</sub>=m’</em>&nbsp;and both&nbsp;<em>m<sub>1</sub></em>&nbsp;and&nbsp;<em>m<sub>2</sub></em>&nbsp;are at most&nbsp;<em>M</em>&nbsp;. By assumption , each for these calls will generate a total of&nbsp;<em>2m<sub>i</sub>-1</em>&nbsp;calls to&nbsp;<strong>ALG C</strong>&nbsp;. Adding in the initial call results in a total of&nbsp;<em>:(2m<sub>1</sub>-1)+2(m<sub>2</sub>-1)+1=2(m<sub>1</sub>+m<sub>2</sub>)-1=2m’-1</em>&nbsp;calls.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">假设</span><em><span style="line-height:1.5;font-family:Verdana;">m</span><span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">2<sup>r</sup>=M</span></em><span style="line-height:1.5;font-family:'宋体';">成立，那么一共有</span><em><span style="line-height:1.5;font-family:Verdana;">2m</span><span style="line-height:1.5;font-family:Verdana;">-1</span></em><span style="line-height:1.5;font-family:'宋体';">次调用</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">。当</span><em><span style="line-height:1.5;font-family:Verdana;">m’</span>&nbsp;<span style="line-height:1.5;font-family:'宋体';">≤</span><span style="line-height:1.5;font-family:Verdana;">2<sup>r+1</sup>=2M</span></em><span style="line-height:1.5;font-family:'宋体';">时，那么在第</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">步，</span><span style="line-height:1.5;font-family:Verdana;">i</span><span style="line-height:1.5;font-family:'宋体';">将会等于接近</span><span style="line-height:1.5;font-family:Verdana;">M</span><span style="line-height:1.5;font-family:'宋体';">的值。一共调用</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">次第一个参数分别是</span><span style="line-height:1.5;font-family:Verdana;"><em>m<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>m<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">的</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">，且</span><span style="line-height:1.5;font-family:Verdana;"><em>m<sub>1</sub>+m<sub>2</sub>=m’</em></span><span style="line-height:1.5;font-family:'宋体';">且</span><span style="line-height:1.5;font-family:Verdana;"><em>m<sub>1</sub></em></span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>m<sub>2</sub></em></span><span style="line-height:1.5;font-family:'宋体';">都接近</span><span style="line-height:1.5;font-family:Verdana;"><em>M</em></span><span style="line-height:1.5;font-family:'宋体';">，根据假设，调用这</span><span style="line-height:1.5;font-family:Verdana;">2</span><span style="line-height:1.5;font-family:'宋体';">次</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">则一共需要调用</span><em><span style="line-height:1.5;font-family:Verdana;">2m<sub>i</sub></span><span style="line-height:1.5;font-family:Verdana;">-1</span></em><span style="line-height:1.5;font-family:'宋体';">次</span><span style="line-height:1.5;font-family:Verdana;"><strong>ALG C</strong></span><span style="line-height:1.5;font-family:'宋体';">。加上第一次的调用，总计为</span><span style="line-height:1.5;font-family:Verdana;"><em>(2m<sub>1</sub>-1)+2(m<sub>2</sub>-1)+1=2(m<sub>1</sub>+m<sub>2</sub>)-1=2m’-1</em></span><span style="line-height:1.5;font-family:'宋体';">次调用。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;color:#FF0000;">注：典型的数学归纳法证明。先证明r=0成立，再假设</span><span style="line-height:1.5;color:#FF0000;font-family:Verdana;"><em>2<sup>r</sup>=M</em></span><span style="line-height:1.5;color:#FF0000;">时成立，再证明</span><span style="line-height:1.5;color:#FF0000;font-family:Verdana;"><em>2<sup>r+1</sup>=2M</em>时成立</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Algorithm C can be modified to find the edit distance between two strings (as defined in [3]). In this case we would seek to minimize D(m,n), the cost of our theorem would be : for all I,</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">算法</span><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">能修改成找寻两个字符串的编辑距离（在</span><span style="line-height:1.5;font-family:Verdana;">[3]</span><span style="line-height:1.5;font-family:'宋体';">中的定义）。在这种情况下，我们设定最小的</span><span style="line-height:1.5;font-family:Verdana;">D(m,n)</span><span style="line-height:1.5;font-family:'宋体';">。在算法的定理中将会是</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><em>D(m,n)=min{D(i,j)+D*(i,j)}　　0≤i≤n</em></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">The modified Algorithm C would split problems in half by the above theorem, using a modified Algorithm B to evaluate&nbsp;<em>D(i,j)</em>&nbsp;and&nbsp;<em>D*(i,j)</em>, and call itself recursively.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:'宋体';">在上面的定理中，修改过的算法</span><span style="line-height:1.5;font-family:Verdana;">C</span><span style="line-height:1.5;font-family:'宋体';">将会对半分割问题，用修改过的算法</span><span style="line-height:1.5;font-family:Verdana;">B</span><span style="line-height:1.5;font-family:'宋体';">计算</span><span style="line-height:1.5;font-family:Verdana;"><em>D(i,j)</em>&nbsp;</span><span style="line-height:1.5;font-family:'宋体';">和</span><span style="line-height:1.5;font-family:Verdana;"><em>D*(i,j)</em></span><span style="line-height:1.5;font-family:'宋体';">，然后再自身递归调用。</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">Received May 1974;revised November 1974</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">References</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">参考文章&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:21pt;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-39.75pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">1.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;">Chvatal, V.,Klarner, D.A., and Knuth, D.E. Selected combinatorial research problems. STAN-CS-72-292, Stanford U., (June 1972),26</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-39.75pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">2.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;">Private communication from D.Knuth to J.D. Ullman.</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-39.75pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">3.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;">Wagner, R.A., and Fischer, M.J. The string-to-string correction problem. J. ACM 21 , 1 (Jan ,1974) 168-173</span></p> 
   <p style="line-height:1.5;font-size:15px;text-indent:-39.75pt;font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.5;font-family:Verdana;">4.<span style="line-height:normal;font-size:7pt;font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="line-height:1.5;font-family:Verdana;">Aho, A. V., Hirschberg, D.S., and Ullman, J.D. Bounds on the complexity of the longest common subsequence problem. Proc . 15th Ann. Symp. on Swiching and Automata Theory, 1974,pp.104-109</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">&nbsp;</p> 
   <p style="line-height:1.5;"><font><span style="font-size:15px;">&nbsp; &nbsp; 本文转自万仓一黍博客园博客，原文链接：http://www.cnblogs.com/grenet/archive/2011/02/27/1959223.html</span></font><span style="font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;">，如需转载请自行联系原作者</span></p> 
   <p style="line-height:1.5;font-size:15px;font-family:Verdana, Arial, Helvetica, sans-serif;"><br></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
