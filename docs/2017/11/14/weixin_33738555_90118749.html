<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>APUE学习总结 « NotBeCN</title>
  <meta name="description" content="             简介    本文总结了个人，一个数字，对应称号《APUE》第一版的每一章，但是，独立的二级标题和书，人需求进行编写。     3.文件I/O     本章所说明的函数常常被称之为不带缓存的I/O（与第5章中说明的标准I/O函数相对比）     3.1文件I/O函数    大多数UNIX文...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/11/14/weixin_33738555_90118749.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">APUE学习总结</h1>
    <p class="post-meta">Nov 14, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">简介</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">本文总结了个人，一个数字，对应称号《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》第一版的每一章，但是，独立的二级标题和书，人需求进行编写。</span><br><strong></strong></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">3.</span>文件<span style="line-height:1.8;font-family:Calibri;">I/O</span> </h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">本章所说明的函数常常被称之为不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>（与第<span style="line-height:1.8;font-family:Calibri;">5</span>章中说明的标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>函数相对比）</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">3.1</span>文件<span style="line-height:1.8;font-family:Cambria;">I/O</span>函数</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">大多数<span style="line-height:1.8;font-family:Calibri;">UNIX</span>文件<span style="line-height:1.8;font-family:Calibri;">I/O</span>仅仅需用到<span style="line-height:1.8;font-family:Calibri;">5</span>个函数：<span style="line-height:1.8;font-family:Calibri;">open</span>、<span style="line-height:1.8;font-family:Calibri;">read</span>、<span style="line-height:1.8;font-family:Calibri;">write</span>、<span style="line-height:1.8;font-family:Calibri;">lseek</span>、<span style="line-height:1.8;font-family:Calibri;">close</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">需注意的是<span style="line-height:1.8;font-family:Calibri;">write</span>后如须要<span style="line-height:1.8;font-family:Calibri;">read</span>，则须要在<span style="line-height:1.8;font-family:Calibri;">read</span>前加入<span style="line-height:1.8;font-family:Calibri;">lseek</span>。由于<span style="line-height:1.8;font-family:Calibri;">write</span>后文件的偏移量在<span style="line-height:1.8;font-family:Calibri;">write</span>的最后一个位置（而该位置可能在文件尾）。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">3.2&nbsp;</span>不同缓存长度对<span style="line-height:1.8;font-family:Cambria;">read</span>和<span style="line-height:1.8;font-family:Cambria;">write</span>函数的影响</h2> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">3.3&nbsp;</span>怎样在进程间共享文件</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">下图截自《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》，这节的总结都和该图有关。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">上图说明了进程的三张表之间的关系。也说明了<span style="line-height:1.8;font-family:Calibri;">I/O</span>的数据结构。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">内核使用了三种数据结构，它们之间的关系决定了在文件共享方面一个进程对还有一个进程可能产生的影响。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">每一个进程在进程表中有一个记录项，每一个记录项中有一张打开文件描写叙述附表（见上图中的“进程表项”），在每张文件描写叙述符表中每一个描写叙述符占用一项。与每一个文件描写叙述符相关联的是：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">a,&nbsp;</span>文件描写叙述符标志（上图进程表项中的<span style="line-height:1.8;font-family:Calibri;">fd 0, fd 1</span>）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">b,&nbsp;</span>指向一个文件表项的指针（上图进程表项指向外面的指针）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">内核为全部打开文件维持一张文件表。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">每一个文件表项包括：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">a,&nbsp;</span>文件状态标志（读、写、增写、同步、非堵塞等）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">b,&nbsp;</span>当前文件位移量。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">c,&nbsp;</span>指向该文件<span style="line-height:1.8;font-family:Calibri;">v</span>节点表项的指针。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">每一个打开的文件（或设备）都有一个<span style="line-height:1.8;font-family:Calibri;">v</span>节点结构。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">好。在此基础上參考下图来说明<span style="line-height:1.8;font-family:Calibri;">UNIX</span>怎样实现文件共享。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">如果有<span style="line-height:1.8;font-family:Calibri;">2</span>个进程打开同一个文件，那么这<span style="line-height:1.8;font-family:Calibri;">2</span>个进程都得到一个文件表项，只是<span style="line-height:1.8;font-family:Calibri;">v</span>节点表项仅仅有一个。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">“这<span style="line-height:1.8;font-family:Calibri;">2</span>个进程都得到一个文件表项”的原因是：每一个进程都有它自己对该文件的当前位移量。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">3.4&nbsp;</span>文件<span style="line-height:1.8;font-family:Cambria;">I/O</span>的原子操作</h2> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">3.4.1&nbsp;</span>向一个文件尾端处写</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在早期的<span style="line-height:1.8;font-family:Calibri;">UNIX</span>版本号不支持<span style="line-height:1.8;font-family:Calibri;">open</span>的<span style="line-height:1.8;font-family:Calibri;">O_APPEND</span>选择项，所以。若需在文件的尾端写数据则须要写例如以下代码：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If( lseek( fd, 0L, 2) &lt; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //position to EOF</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err_sys(“lseek&nbsp; error”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If( write(fd, buff, 100) != 100)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //write</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err_sys(“write&nbsp; error”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>对单个进程来说没问题，只是如果是以下这样的情况：<span style="line-height:1.8;font-family:Calibri;">2</span>个进程打开同一个文件，并都将文件的位移量移到了文件的尾端（如果是第<span style="line-height:1.8;font-family:Calibri;">1500</span>字节处），由文件共享可知。这两个进程都有自己的文件表项（即都有它自己对该文件的当前位移量），这时第一个进程调用<span style="line-height:1.8;font-family:Calibri;">write</span>，然后，内核切换到还有一个进程调用<span style="line-height:1.8;font-family:Calibri;">write</span>。可是<span style="line-height:1.8;font-family:Calibri;">2</span>个进程都是从<span style="line-height:1.8;font-family:Calibri;">1500</span>字节处写。所以第一个进程所写的内容就被破坏了。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>解决方法就是让“位移到文件尾端，然后写数据”这两步变成一个原子操作。而这就须要用到<span style="line-height:1.8;font-family:Calibri;">open</span>函数的<span style="line-height:1.8;font-family:Calibri;">O_APPEND</span>选项。该选项的作用是：每次写之前都将进程的当前位移量设置到文件的尾端处。</p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">3.4.2&nbsp;</span>创建一个文件</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们知道，对<span style="line-height:1.8;font-family:Calibri;">open</span>函数，假设同一时候制定了<span style="line-height:1.8;font-family:Calibri;">O_CREAT</span>和<span style="line-height:1.8;font-family:Calibri;">O_EXCL</span>时。假设文件已经存在。则<span style="line-height:1.8;font-family:Calibri;">open</span>失败。这是一个原子操作。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">假设没有这样一个原子操作的话，我们可能须要编写下列程序段：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If(( fd = open(pathname, O_WRONLY))&lt; 0)</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If( errno == ENOENT){</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If(( fd =creat(pathname, mode)) &lt; 0)</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err_sys(“creat&nbsp; error”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err_sys(“open&nbsp; error”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">道理同上，单个进程没问题，但如果在打开和创建之间。还有一个进程创建了该文件的话。那么该进程在运行<span style="line-height:1.8;font-family:Calibri;">creat</span>时就会将还有一个进程写进去的数据擦去（如果还有一个进程在创建文件后又向该文件里写数据的话）。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">3.4.3&nbsp;</span>复制一现存的文件描写叙述符</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">复制一现存的文件描写叙述符能够有以下两类方法：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>第一类：让系统来指定新的文件描写叙述符。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这类返回当前可用文件描写叙述符的最小值。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>调用：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Dup( filedes);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>等同于：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fcntl(filedes, F_DUPFD, 0);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>第二类：手段指定新的文件描写叙述符。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>假设指定的文件描写叙述符已经打开，则先将其关闭。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>调用：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dup2(filedes_old, filedes_new);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>等同于：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Close(filedes_new);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fcntl(filedes_old,F_DUPFD, filedes_new);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>关于第一类<span style="line-height:1.8;font-family:Calibri;">2</span>种方法都能够，但第二类最好仅仅用<span style="line-height:1.8;font-family:Calibri;">dup2()</span>，由于<span style="line-height:1.8;font-family:Calibri;">dup2()</span>是一个原子操作，而后者不是。当然并非说<span style="line-height:1.8;font-family:Calibri;">fcntl</span>不能使用，毕竟<span style="line-height:1.8;font-family:Calibri;">fcntl</span>能够做很多<span style="line-height:1.8;font-family:Calibri;">dup/dup2</span>所不能做的事情。</p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">4.</span>文件和文件夹</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">文件系统的其它特征和文件的性质。<span style="line-height:1.8;font-family:Calibri;">UNIX</span>文件系统的结构以及符号连接。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">5.</span>标准<span style="line-height:1.8;font-family:Calibri;">I/O</span> </h1> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">5.1.</span>缓存</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">谈到标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>就的谈到流缓存。而这也是标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>库中的一个重点。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>库提供了三种类型的缓存：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;</span>全缓存。<span style="line-height:1.8;font-family:Calibri;">b&nbsp;</span>行缓存；<span style="line-height:1.8;font-family:Calibri;">&nbsp;c&nbsp;</span>不带缓存</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">具体解释例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>对于全缓存：填满<span style="line-height:1.8;font-family:Calibri;">I/O</span>缓存后才进行实际<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作。一般来说，在一个流上运行第一次<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作时，相关标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>函数用<span style="line-height:1.8;font-family:Calibri;">malloc</span>获取需使用的缓存。（驻在磁盘上的文件一般是全缓存的）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>对于行缓存：在输入和输出中遇到新行符时，进行<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作。只是对于行缓存有<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">2</span></span><span style="line-height:1.8;color:#FF0000;">个限制</span>：<span style="line-height:1.8;font-family:Calibri;">1</span>，由于每一行的缓存长度是固定的。所以仅仅要填满了缓存，那么即使没有遇到换行符。也会进行<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作。<span style="line-height:1.8;font-family:Calibri;">2</span>，仅仅要通过标准输入输出库要求从一个不带缓存的流或者一个行缓存的流得到数据，那么就会刷新全部的行缓存输出流。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>对于不带缓存：就是直接调用文件<span style="line-height:1.8;font-family:Calibri;">I/O</span>，即第三章的内容。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在<span style="line-height:1.8;font-family:Calibri;">ANSI C&nbsp;</span>中：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当且仅当标准输入和标准输出不涉及交互作用设备时，它们才是全缓存的。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>标准出错绝不会是全缓存的。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">须要注意的是：假设在一个函数中分配了一个自己主动变量类的标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>缓存，则从该函数返回之前必须关闭该流。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">一般而言，应由系统选择缓存的长度。并自己主动分配缓存。这种话，标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>库在关闭此流时将自己主动释放此缓存。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">最后提一点：在好些系统中，默认的是当标准输入、输出连至终端时。它们是行缓存的。当将流又一次定向到普通文件时，它们就变成是全缓存的。其缓存长度是该文件系统优先选用的<span style="line-height:1.8;font-family:Calibri;">I/O</span>长度<span style="line-height:1.8;font-family:Calibri;">(</span>从<span style="line-height:1.8;font-family:Calibri;">stat</span>结构中得到的<span style="line-height:1.8;font-family:Calibri;">st_blksize)</span>。标准出错为非缓存，而普通文件按系统默认是全缓存的。（看程序<span style="line-height:1.8;font-family:Calibri;">5-3</span>）</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">5.2.&nbsp;</span>流的读写</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">注意，以读和写类型打开一文件时（<span style="line-height:1.8;font-family:Calibri;">type</span>中含<span style="line-height:1.8;font-family:Calibri;">+</span>号），具有下列限制：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>假设中间没有<span style="line-height:1.8;font-family:Calibri;">fflush</span>、<span style="line-height:1.8;font-family:Calibri;">fseek</span>、<span style="line-height:1.8;font-family:Calibri;">fsetpos</span>和<span style="line-height:1.8;font-family:Calibri;">rewind</span>。则在输出后面不能直接尾随输入。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>假设中间没有<span style="line-height:1.8;font-family:Calibri;">fseek</span>、<span style="line-height:1.8;font-family:Calibri;">fsetpos</span>或<span style="line-height:1.8;font-family:Calibri;">rewind</span>，或者一个输出操作没有到达文件尾端，则在输入操作之后不能直接尾随输出。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">5.3.&nbsp;</span>输入函数</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">有<span style="line-height:1.8;font-family:Calibri;">getc</span>、<span style="line-height:1.8;font-family:Calibri;">fgetc</span>、<span style="line-height:1.8;font-family:Calibri;">getchar</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">getchar</span>等用于<span style="line-height:1.8;font-family:Calibri;">getc(stdin)</span>。前两者的差别是：<span style="line-height:1.8;font-family:Calibri;">getc</span>可被实现为宏。而<span style="line-height:1.8;font-family:Calibri;">fgetc</span>则不能。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">5.4.&nbsp;</span>关于<span style="line-height:1.8;font-family:Cambria;">int ungetc(int c, FILE* fp);</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在一个流读之后调用它。可将字符在送回流中。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">当然送回到流中的字符以后可从流中读出，但读出字符的顺序与送回的顺序相反。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>注意：送回的字符不一定必须是上一次读到的字符。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">EOF</span>不能回送。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">5.5.&nbsp;</span>关于<span style="line-height:1.8;font-family:Cambria;">gets</span>，<span style="line-height:1.8;font-family:Cambria;">puts</span>，<span style="line-height:1.8;font-family:Cambria;">fgets</span>和<span style="line-height:1.8;font-family:Cambria;">fputs</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">gets</span>和<span style="line-height:1.8;font-family:Calibri;">puts</span>就忘掉他们吧。仅仅用<span style="line-height:1.8;font-family:Calibri;">fgets</span>和<span style="line-height:1.8;font-family:Calibri;">fputs</span>就可以，当然是用<span style="line-height:1.8;font-family:Calibri;">fgets</span>和<span style="line-height:1.8;font-family:Calibri;">fputs</span>时要在每行终止处自己加一个新行符。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这点须要注意。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">5.6.&nbsp;</span>关于暂时文件</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">char* tmpnam(char*ptr);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">若<span style="line-height:1.8;font-family:Calibri;">ptr</span>是<span style="line-height:1.8;font-family:Calibri;">NULL</span>，所产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回。下一次在调用<span style="line-height:1.8;font-family:Calibri;">tmpnam</span>时，会重写该静态区。这意味着：假设我们调用该函数多次，并且像保存路径名，则我们应当保存该路径名的副本。而不是指针的副本。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">若<span style="line-height:1.8;font-family:Calibri;">ptr</span>不是<span style="line-height:1.8;font-family:Calibri;">NULL</span>。则觉得它指向长度至少是<span style="line-height:1.8;font-family:Calibri;">L_tmpnam</span>个字符的数组。（常数<span style="line-height:1.8;font-family:Calibri;">L_tmpnam</span>定义在头文件<span style="line-height:1.8;font-family:Calibri;">&lt;stdio.h&gt;</span>中。）所产生的路径名存放在该数组中，<span style="line-height:1.8;font-family:Calibri;">ptr</span>也作为函数值返回。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">FILE*tmpfile(void);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">tmpfile</span>函数常常使用的标准<span style="line-height:1.8;font-family:Calibri;">UNIX</span>技术是先调用<span style="line-height:1.8;font-family:Calibri;">tmpnam</span>产生一个唯一的路径名。然后立马<span style="line-height:1.8;font-family:Calibri;">unlink</span>它。</p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></strong></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">7.UNIX</span>进程的环境</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">关于<span style="line-height:1.8;font-family:Calibri;">exit</span>和<span style="line-height:1.8;font-family:Calibri;">_exit</span>请看“附<span style="line-height:1.8;font-family:Calibri;">5</span>”。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">7.1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Cambria;font-size:24px;">C</span>程序的存储空间布局</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">因为历史原因<span style="line-height:1.8;font-family:Calibri;">--</span>！，<span style="line-height:1.8;font-family:Calibri;">C</span>程序一直由下列几部分组成：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>正文段、初始化数据段、非初始化数据等、栈、堆。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这是一种典型的安排方式。但并不要求一定以这样的方式安排其存储空间。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">以下对上面<span style="line-height:1.8;font-family:Calibri;">5</span>部分进行解释。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>正文段</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">CPU</span>运行的机器指令部分。一般该段是可共享的。但经常是仅仅读的。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2</span>初始化数据段</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">包括了程序中需赋初值的变量。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如：函数外说明<span style="line-height:1.8;font-family:Calibri;">int i=0;</span>就放在这里。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3</span>非初始化数据段</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">即<span style="line-height:1.8;font-family:Calibri;">BBS</span>段。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在程序開始运行之前，内核将该段初始化为<span style="line-height:1.8;font-family:Calibri;">0.</span>如：函数外说明：<span style="line-height:1.8;font-family:Calibri;">long sum[1000];</span>此变量就放在这里。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;</span>栈</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>自己主动变量以及每次函数调用时所需保存的信息存放在此处。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;</span>堆</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>在堆中通常进行动态存储分配。一般来说，堆位于非初始化数据段顶和栈底之间。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">7.2</span>存储器分配</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; ANSI C</span>说明了三个用于存储器空间分配的函数</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">Malloc. &nbsp;&nbsp;&nbsp;&nbsp;</span>存储器中初始值不确定</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Void* malloc(size_t size);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">Calloc. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>分配的空间中每一位都初始化为<span style="line-height:1.8;font-family:Calibri;">0</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Void* calloc(</span><span style="line-height:1.8;color:#000000;">unsigned n,unsigned size);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">Realloc.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>更改曾经分配区的长度。当添加时，可能需将曾经分配区的内容一道还有一个足够大的区域，而新增区域内的初始值则不确定。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Void* realloc(void* ptr, size_t newsize);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Void free(void* ptr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>释放<span style="line-height:1.8;font-family:Calibri;">ptr</span>指向的存储空间。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">注意：</span></h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">大多数实现所分配的存储空间比所要求的稍大一些，由于须要额外的空间来记录管理信息（如：分配块的长度、指向下一个分配块的指针等等）。这意味着假设写过一个已分配区的尾端，则会改写那些管理信息。这样的类型的错误时灾难性的，但由于这样的错误不会非常快暴露出来，所以非常难发现。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">而将指向分配块的指针向后移动亦可能会改写本块的管理信息。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">其它可能产生的致命错误是：释放了一个已经释放的块。调用<span style="line-height:1.8;font-family:Calibri;">free</span>时所用的指针不是<span style="line-height:1.8;font-family:Calibri;">3</span>个<span style="line-height:1.8;font-family:Calibri;">alloc</span>函数的返回值等。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">4.</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">Alloca</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">和<span style="line-height:1.8;font-family:Calibri;">malloc</span>同样，仅仅只是它在当前函数的栈上分配空间。而不是在堆中。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">长处是：当函数返回时，自己主动释放它所使用的栈。缺点是：某些系统在函数已被调用后不能添加栈长度，于是也就不支持<span style="line-height:1.8;font-family:Calibri;">alloca</span>函数。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">7.3setjmp</span>和<span style="line-height:1.8;font-family:Cambria;">longjmp</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在<span style="line-height:1.8;font-family:Calibri;">C</span>中，不同意使用<span style="line-height:1.8;font-family:Calibri;">goto</span>。而运行这样的跳转功能的函数是<span style="line-height:1.8;font-family:Calibri;">setjmp</span>和<span style="line-height:1.8;font-family:Calibri;">longjmp</span>。这两个函数对于处理发生在非常深的嵌套函数调用中的出错情况非常实用。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Int setjmp(jmp_buf env);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Void longjmp(jmp_buf env, int val);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当检查到一个错误时，则用<span style="line-height:1.8;font-family:Calibri;">2</span>个參数调用<span style="line-height:1.8;font-family:Calibri;">longjmp</span>函数。第一个为<span style="line-height:1.8;font-family:Calibri;">setjmp</span>时所用的<span style="line-height:1.8;font-family:Calibri;">env</span>。第二个<span style="line-height:1.8;font-family:Calibri;">val</span>为非<span style="line-height:1.8;font-family:Calibri;">0</span>值（由于<span style="line-height:1.8;font-family:Calibri;">setjmp</span>默认返回<span style="line-height:1.8;font-family:Calibri;">0</span>）。使用第二个參数的原因是对于一个<span style="line-height:1.8;font-family:Calibri;">setjmp</span>能够有多个<span style="line-height:1.8;font-family:Calibri;">longjmp</span>。比如在方法<span style="line-height:1.8;font-family:Calibri;">1</span>中<span style="line-height:1.8;font-family:Calibri;">longjmp</span>的<span style="line-height:1.8;font-family:Calibri;">val</span>为<span style="line-height:1.8;font-family:Calibri;">1</span>。在方法<span style="line-height:1.8;font-family:Calibri;">2</span>中<span style="line-height:1.8;font-family:Calibri;">longjmp</span>的<span style="line-height:1.8;font-family:Calibri;">val</span>为<span style="line-height:1.8;font-family:Calibri;">2</span>，这样通过測试返回值就可推断是从方法<span style="line-height:1.8;font-family:Calibri;">1</span>还是从方法<span style="line-height:1.8;font-family:Calibri;">2</span>来的<span style="line-height:1.8;font-family:Calibri;">longjmp</span>了。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">7.4 volatile</span>和自己主动、寄存器、亦失变量</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这牵扯到一个问题：当<span style="line-height:1.8;font-family:Calibri;">longjmp</span>返回后，之前的变量是否能恢复到曾经调用<span style="line-height:1.8;font-family:Calibri;">setjmp</span>时的值（即回滚原先的值）。或者这些变量保持为调用<span style="line-height:1.8;font-family:Calibri;">do_line</span>时的值。答案是：看情况。大多数情况不会滚这些自己主动变量和寄存器变量的值。但也仅仅是大多数情况下。所以假设有个一想不回滚的变量，可将其定义为<span style="line-height:1.8;font-family:Calibri;">volatile</span>属性。即将其说明为全局和静态变量。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">7.5&nbsp;</span>自己主动变量的潜在问题</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">如上例，<span style="line-height:1.8;font-family:Calibri;">open_data</span>打开了一个<span style="line-height:1.8;font-family:Calibri;">I/O</span>流，然后为该流设置了缓存。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">可是当其返回后。它在栈上所使用的空间将由下一个调用函数的栈使用。只是标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>库函数仍将使用原先为<span style="line-height:1.8;font-family:Calibri;">databuf</span>在栈上分配的空间作为该流的缓存，这就造成了冲突和混乱。所以应在全局存储空间静态的（<span style="line-height:1.8;font-family:Calibri;">static</span>或<span style="line-height:1.8;font-family:Calibri;">extern</span>）。或者动态的（使用<span style="line-height:1.8;font-family:Calibri;">alloc</span>函数）为数组<span style="line-height:1.8;font-family:Calibri;">databuf</span>分配空间。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">8.</span>进程控制</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">创建新进程、运行程序、进程终止。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">实际、有效合保存的用户和组<span style="line-height:1.8;font-family:Calibri;">ID</span>，他们怎样受到进程控制原语的影响。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">解释器文件合<span style="line-height:1.8;font-family:Calibri;">system</span>函数</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">8.1</span>几个精灵进程</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">ID</span>为<span style="line-height:1.8;font-family:Calibri;">0</span>的进程：经常被称为交换进程或者系统进程，该进程不运行不论什么磁盘上的程序<span style="line-height:1.8;font-family:Calibri;">—</span>他是内核的一部分。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">ID</span>为<span style="line-height:1.8;font-family:Calibri;">1</span>的进程：就是<span style="line-height:1.8;font-family:Calibri;">init</span>啦，这个进程绝不会终止。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">并且他是全部孤儿进程的父进程。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">ID</span>为<span style="line-height:1.8;font-family:Calibri;">2</span>的进程：页精灵进程。负责支持虚存系统的请页操作。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">与交换进程一样，该进程也是内核进程。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">顺便一提，这三个都是精灵进程。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-family:Cambria;font-size:24px;">8.2fork</span></h2> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.2.1</span>关于<span style="line-height:1.8;font-family:Calibri;">fork</span>和<span style="line-height:1.8;font-family:Calibri;">I/O</span>的关系</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在程序<span style="line-height:1.8;font-family:Calibri;">8-1</span>上面有这么一段关于程序<span style="line-height:1.8;font-family:Calibri;">8-1</span>的话，额。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">。。。先看程序<span style="line-height:1.8;font-family:Calibri;">8-1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">还记得<span style="line-height:1.8;font-family:Calibri;">I/O</span>分为带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>和不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>吗？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在这个样例中<span style="line-height:1.8;font-family:Calibri;">write</span>仅仅写到标准输出一次，这个好理解，由于<span style="line-height:1.8;font-family:Calibri;">write</span>是不带缓存的。可是针对以下的<span style="line-height:1.8;font-family:Calibri;">printf(“before fork\n”);</span>它会在终端输出一行<span style="line-height:1.8;font-family:Calibri;">before fork</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">但，假设将其定位到一个文件，那么在文件里就会出现<span style="line-height:1.8;font-family:Calibri;">2</span>行<span style="line-height:1.8;font-family:Calibri;">before fork</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">即：改动代码为：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">FILE* fp;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Charfile[256] = “8-1”;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Fp = fopen(“file”,“w”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Fprintf(fp, “beforefork\n”, NULL);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">的话。那么在文件<span style="line-height:1.8;font-family:Calibri;">8-1</span>中的结果是</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">before fork</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">before fork</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">为什么呢？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;color:#FF0000;">由于其为带缓存的</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">I/O</span></span><span style="line-height:1.8;color:#FF0000;">，而其缓存类型假设是连到终端设备。则事实上行缓存的。反之是全缓存。</span>所以，对于<span style="line-height:1.8;font-family:Calibri;">printf</span>，它连到终端设备。而须要输出的内容是<span style="line-height:1.8;font-family:Calibri;">before fork\n</span>，含有换行符，所以在<span style="line-height:1.8;font-family:Calibri;">fork</span>之前就将内容从缓存输出到了终端中，因而仅仅有一行输出。（我们知道<span style="line-height:1.8;font-family:Calibri;">fork</span>是复制父进程的数据空间到子进程中，而这数据空间就包括缓存数据，这里缓存中的数据被输出到了终端，所以子进程得到的缓存中不再包括<span style="line-height:1.8;font-family:Calibri;">before fork\n</span>）。这里我们做个试验，将<span style="line-height:1.8;font-family:Calibri;">before fork\n</span>改成<span style="line-height:1.8;font-family:Calibri;">befork fork</span>。就会发现终端输出了两遍<span style="line-height:1.8;font-family:Calibri;">before fork</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（由于是行缓存，又由于这里没有了换行符。又又由于在<span style="line-height:1.8;font-family:Calibri;">fork</span>之前一没有换行符二没有什么能让缓冲区满的语句，所以缓存中的数据在<span style="line-height:1.8;font-family:Calibri;">fork</span>之前不会输出到终端，所以复制给子进程的缓存中就包括了<span style="line-height:1.8;font-family:Calibri;">before fork</span>）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于输出到文件的，由上面那句红色的话可知，他是全缓存，缓存不满不输出，所以子进程也从父进程的缓存中拷贝到了该数据。从而文件里出现了<span style="line-height:1.8;font-family:Calibri;">2</span>遍<span style="line-height:1.8;font-family:Calibri;">before fork</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.2.2&nbsp;</span>关于<span style="line-height:1.8;font-family:Calibri;">fork</span>和文件共享的关系</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">假设父进程打开了一个文件，在关闭该文件前<span style="line-height:1.8;font-family:Calibri;">fork</span>了一个子进程的话会发生什么？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">没错。子进程通过复制得到父进程打开该文件的文件描写叙述符，这也就相当于子进程打开了该文件。因此，就不得不说说文件共享了。首先看下图。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">由图可知。父子进程均有自己对文件的文件描写叙述符（所以子进程在结束前也要将自己的文件描写叙述符<span style="line-height:1.8;font-family:Calibri;">close</span>掉），只是父子进程的文件描写叙述符均指向同一个“文件表”，这意味着父子进程共享该文件的位移量。所以，父子进程对该文件的写不会互相影响。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.2.3 fork</span>失败的主要原因</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>，系统中有了太多的进程（这通常意味着某个方面出了问题）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2</span>，该用户<span style="line-height:1.8;font-family:Calibri;">ID</span>的进程总数超过了系统限制。（在<span style="line-height:1.8;font-family:Calibri;">APUE</span>的表<span style="line-height:1.8;font-family:Calibri;">2-7</span>中说明<span style="line-height:1.8;font-family:Calibri;">CHILD_MAX</span>规定了每一个用户<span style="line-height:1.8;font-family:Calibri;">ID</span>在任一时刻可具有的最大进程数）</p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.2.4 fork</span>的两种使用方法</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>，一个父进程希望复制自己，使父子进程同一时候运行不同的代码段。（如：在网络服务进程中，父进程等待托付者的服务请求。当这样的请求到达时，父进程调用<span style="line-height:1.8;font-family:Calibri;">fork</span>，使子进程处理此请求。父进程则等待下一个服务请求。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2</span>，一个进程要运行一个不同的程序。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（这对<span style="line-height:1.8;font-family:Calibri;">shell</span>是常见的情况。在这样的情况下。子进程在从<span style="line-height:1.8;font-family:Calibri;">fork</span>返回后马上调用<span style="line-height:1.8;font-family:Calibri;">exec----</span>顺便一提。这样的情况能够说是使用<span style="line-height:1.8;font-family:Calibri;">vfork</span>的唯一情况。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）</p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.2.5 fork</span>和<span style="line-height:1.8;font-family:Calibri;">vfork</span> </h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">差别：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">fork</span>复制父进程的数据给子进程，这是子进程在还有一片地址中；</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">vfrok</span>则不复制，它的结果是子进程直接在父进程的地址中运行（这意味着子进程的操作会改动父进程内存中的数据）；</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">vfork</span>保证子进程先运行。</p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.2.6 vfork</span>和<span style="line-height:1.8;font-family:Calibri;">exec</span> </h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">为什么说“<span style="line-height:1.8;font-family:Calibri;">vfork</span>和<span style="line-height:1.8;font-family:Calibri;">exec</span>”而不说“<span style="line-height:1.8;font-family:Calibri;">fork</span>和<span style="line-height:1.8;font-family:Calibri;">exec</span>”啊。这是由于使用<span style="line-height:1.8;font-family:Calibri;">vfork</span>的情况一般来说也就是<span style="line-height:1.8;font-family:Calibri;">vfork</span>后接<span style="line-height:1.8;font-family:Calibri;">exec</span>。所以<span style="line-height:1.8;font-family:Calibri;">fork</span>就不要和<span style="line-height:1.8;font-family:Calibri;">vfork</span>抢了<span style="line-height:1.8;font-family:Calibri;">~O(</span>∩<span style="line-height:1.8;font-family:Calibri;">_</span>∩<span style="line-height:1.8;font-family:Calibri;">)O~</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">啊，开个玩笑开个玩笑。只是实际情况也就是这样，由于调用<span style="line-height:1.8;font-family:Calibri;">exec</span>（或<span style="line-height:1.8;font-family:Calibri;">exit</span>）后就会跳转到和<span style="line-height:1.8;font-family:Calibri;">exec</span>语句中的内容相相应的地址空间中（这点请学习<span style="line-height:1.8;font-family:Calibri;">exec</span>函数），所以用<span style="line-height:1.8;font-family:Calibri;">fork</span>先复制一片内存给子进程然后再跳转到其它地址就显得多此一举并且浪费空间了。因此<span style="line-height:1.8;font-family:Calibri;">vfork</span>就非常不错<span style="line-height:1.8;font-family:Calibri;">~</span>。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">8.3&nbsp;</span>进程终止的情况</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">感觉了解即可。但为了以后能够在别人面前卖弄。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">。。。<span style="line-height:1.8;font-family:Calibri;">(</span>我说我是开玩笑的你信吗？<span style="line-height:1.8;font-family:Calibri;">)</span>还是总结下吧。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">言归正传，进程终止的情况例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">正常终止</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">a)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">在<span style="line-height:1.8;font-family:Calibri;">main</span>函数内运行<span style="line-height:1.8;font-family:Calibri;">return</span>语句。（等效于调用<span style="line-height:1.8;font-family:Calibri;">exit</span>）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">b)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;">调用<span style="line-height:1.8;font-family:Calibri;">exit</span>函数。（终止处理程序，然后关闭全部标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>流等<span style="line-height:1.8;font-family:Calibri;">----</span>也因此，假设<span style="line-height:1.8;font-family:Calibri;">vfork</span>出的子进程中用了<span style="line-height:1.8;font-family:Calibri;">exit</span>。那么父进程中还没有<span style="line-height:1.8;font-family:Calibri;">I/O</span>的内容（如。子进程语句后面的<span style="line-height:1.8;font-family:Calibri;">printf</span>）就不会执行了。）<span style="line-height:1.8;color:#FF0000;">只是由于</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">ANSI C</span></span><span style="line-height:1.8;color:#FF0000;">不处理文件描写叙述符、多进程（父子进程）以及作业控制。所以这一定义对</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">UNIX</span></span><span style="line-height:1.8;color:#FF0000;">系统而言是不完整的。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">c)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;">调用<span style="line-height:1.8;font-family:Calibri;">_exit</span>函数。此函数由<span style="line-height:1.8;font-family:Calibri;">exit</span>调用，它处理<span style="line-height:1.8;font-family:Calibri;">UNIX</span>的特定细节。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">异常终止</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">a)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">调用<span style="line-height:1.8;font-family:Calibri;">abort</span>。它产生<span style="line-height:1.8;font-family:Calibri;">SIGABRT</span>信号，因此是下一种异常终止的特例。（你就理解为下一种是长方形。这样的是正方形，而正方形是长方形的特例）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">b)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">当进程接收到某个信号时。（进程越出其地址空间訪问存储单元。或者除以<span style="line-height:1.8;font-family:Calibri;">0</span>，内核就会为该进程产生对应的信号。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">还记得上面的红字吗？尽管<span style="line-height:1.8;font-family:Calibri;">exit</span>不处理文件描写叙述符，可是在进程终止的最后都会运行内核中的一段代码。这段代码为对应的进程关闭全部打开的描写叙述符，释放它所使用的存储器等。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当然，我们的希望是终止进程可以通知其父进程它是怎样终止的。在此须要注意的是，对于<span style="line-height:1.8;font-family:Calibri;">exit</span>和<span style="line-height:1.8;font-family:Calibri;">_exit(</span>正常终止<span style="line-height:1.8;font-family:Calibri;">)</span>。是依靠传递它们的<span style="line-height:1.8;color:#FF0000;">退出状态</span>參数来实现的。可是在异常终止的情况。内核（注意不是进程本身）产生一个指示其异常终止原因的<span style="line-height:1.8;color:#FF0000;">终止状态</span>。（对于上面的情况，该终止进程的父进程均能通过调用<span style="line-height:1.8;font-family:Calibri;">wait</span>和<span style="line-height:1.8;font-family:Calibri;">waitpid</span>函数取得其终止状态。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">注意这里的“退出状态”和“终止状态”，在最后调用<span style="line-height:1.8;font-family:Calibri;">_exit</span>时内核将其推出状态转换成终止状态。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">总之，假设子进程正常终止，那么父进程才干获得子进程的退出状态。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">8.4 wait</span>和<span style="line-height:1.8;font-family:Cambria;">waitpid</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Pid_t wait(intstat);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Pid_twaitpid(pid_t pid, int stat, int options);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">使用的<span style="line-height:1.8;font-family:Calibri;">wait</span>和<span style="line-height:1.8;font-family:Calibri;">waitpid</span>是预防僵死进程的重要方法之中的一个。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.4.1</span>&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-size:24px;">调用<span style="line-height:1.8;font-family:Calibri;">wait</span>或<span style="line-height:1.8;font-family:Calibri;">waitpid</span>的进程可能出现的<span style="line-height:1.8;font-family:Calibri;">3</span>种情况：</span> </h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>、堵塞（假设其全部子进程都还在执行）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2</span>、带子进程的终止状态马上返回（假设一个子进程已经终止，正等待父进程存取其终止状态）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3</span>、出错马上返回（假设它没有不论什么子进程）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当进程正常<span style="line-height:1.8;font-family:Calibri;">/</span>异常终止时，内核就向其父进程发送<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>信号，假设进程是由于接收到<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>信号而调用<span style="line-height:1.8;font-family:Calibri;">wait</span>，则可期望<span style="line-height:1.8;font-family:Calibri;">wait</span>会马上返回。可是在一个任一时刻调用<span style="line-height:1.8;font-family:Calibri;">wait</span>，则进程可能会堵塞。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">8.4.2 wait</span>和<span style="line-height:1.8;font-family:Calibri;">waitpid</span>的差别</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>、在一个子进程终止前，<span style="line-height:1.8;font-family:Calibri;">wait</span>使其调用者堵塞。而<span style="line-height:1.8;font-family:Calibri;">waitpid</span>有一个选择项，可使调用者不堵塞。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2</span>、<span style="line-height:1.8;font-family:Calibri;">waitpid</span>不等待第一个终止的子进程（它有若干个选择项，能够控制它所等待的进程）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3</span>、对于<span style="line-height:1.8;font-family:Calibri;">wait</span>，其唯一出错的调用时没有子进程。可是对于<span style="line-height:1.8;font-family:Calibri;">waitpid</span>，假设指定的进程或进程组不存在，或者调用进程没有子进程都能出错。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">wait</span>，我们能够这么用：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pid_t pid;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int stat;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If((pid = fork()) &lt;0) err_sys(“fork error”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else if(pid == 0)exit(7);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If(wait(&amp;stat) !=pid) err_sys(“wait error”);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Printf(“%d\n”, stat);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">（假设不关心进程是怎样结束的，可将<span style="line-height:1.8;font-family:Calibri;">wait</span>的參数设置为<span style="line-height:1.8;font-family:Calibri;">NULL</span>）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">可是这样有缺点：除了父进程可能会一直等待这点外，我们若想等待特定的进程也非常麻烦。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这时我们就用到了<span style="line-height:1.8;font-family:Calibri;">waitpid</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Waitpid</span>函数提供了<span style="line-height:1.8;font-family:Calibri;">wait</span>函数没有提供的三个功能：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">waitpid</span>能够等待一个特定的进程（<span style="line-height:1.8;font-family:Calibri;">wait</span>返回任一终止子进程的状态）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">waitpid</span>提供了<span style="line-height:1.8;font-family:Calibri;">wait</span>的非堵塞版本号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（有时希望取得一个子进程的状态。但不想堵塞）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3、</span>&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">waitpid</span>支持作业控制。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">waitpid</span>的<span style="line-height:1.8;font-family:Calibri;">pid</span>參数的解释与其值有关：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pid==-1&nbsp;</span>等待任一子进程（这方面<span style="line-height:1.8;font-family:Calibri;">waitpid</span>和<span style="line-height:1.8;font-family:Calibri;">wait</span>等效）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pid &gt; 0&nbsp;</span>等待其进程<span style="line-height:1.8;font-family:Calibri;">ID</span>与<span style="line-height:1.8;font-family:Calibri;">pid</span>相等的子进程</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pid == 0&nbsp;</span>等待其组<span style="line-height:1.8;font-family:Calibri;">ID</span>等于调用进程的组<span style="line-height:1.8;font-family:Calibri;">ID</span>的任一子进程</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pid &lt; -1&nbsp;</span>等待其组<span style="line-height:1.8;font-family:Calibri;">ID</span>等译<span style="line-height:1.8;font-family:Calibri;">pid</span>的绝对值的任一子进程</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-family:Cambria;font-size:24px;">8.5 exec</span></h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在<span style="line-height:1.8;font-family:Calibri;">linux</span>中，并不存在<span style="line-height:1.8;font-family:Calibri;">exec()</span>这样一个函数形式。实际上它是一组函数，一共同拥有<span style="line-height:1.8;font-family:Calibri;">6</span>个，例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">#include &lt;unistd.h&gt;</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int execl(const char *path, constchar *arg, ...);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int execlp(const char *file, constchar *arg, ...);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int execle(const char *path, constchar *arg, ..., char *const envp[]);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int execv(const char *path, char*const argv[]);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int execvp(const char *file, char*const argv[]);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">int execve(const char *path, char *const argv[], char *const envp[]);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这<span style="line-height:1.8;font-family:Calibri;">6</span>个函数的记忆方式例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>前面均以<span style="line-height:1.8;font-family:Calibri;">exec</span>开头，<span style="line-height:1.8;font-family:Calibri;">l</span>：取一个參数表。<span style="line-height:1.8;font-family:Calibri;">v</span>：取一个<span style="line-height:1.8;font-family:Calibri;">argv[]</span>。<span style="line-height:1.8;font-family:Calibri;">e</span>：取<span style="line-height:1.8;font-family:Calibri;">envp[]</span>数组，而不是使用当前环境变量。<span style="line-height:1.8;font-family:Calibri;">P</span>取<span style="line-height:1.8;font-family:Calibri;">filename</span>做为參数。并在<span style="line-height:1.8;font-family:Calibri;">PATH</span>中寻找可运行文件。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;color:#FF0000;">注意：无论是取一个參数表还是取一个</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">argv[]</span></span><span style="line-height:1.8;color:#FF0000;">，都要在末尾写一个</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">NULL</span></span><span style="line-height:1.8;color:#FF0000;">，告诉它參数结束。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">请看以下的样例：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">char *envp[]={"PATH=/tmp",</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>"USER=lei",</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>"STATUS=testing",</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>NULL};</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>char*argv_execv[]={"echo", "excuted by execv", NULL};</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>char*argv_execvp[]={"echo", "executed by execvp", NULL};</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>char*argv_execve[]={"env", NULL};</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">if(fork()==0)</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(execl("/bin/echo","echo", "executed by execl", NULL)&lt;0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>perror("Erron execl");</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(fork()==0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(execlp("echo","echo", "executed by execlp", NULL)&lt;0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>perror("Erron execlp");</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(fork()==0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(execle("/usr/bin/env","env", NULL, envp)&lt;0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>perror("Erron execle");</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(fork()==0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(execv("/bin/echo",argv_execv)&lt;0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>perror("Erron execv");</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(fork()==0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(execvp("echo",argv_execvp)&lt;0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>perror("Erron execvp");</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(fork()==0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>if(execve("/usr/bin/env",argv_execve, envp)&lt;0)</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>perror("Erron execve");</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-family:Cambria;font-size:24px;">8.6 system</span></h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">#include&lt;stdlib.h&gt;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Int system(constchar cmdstring);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">假设<span style="line-height:1.8;font-family:Calibri;">cmdstrinf</span>为一个空指针，则仅当命令处理程序可用时。<span style="line-height:1.8;font-family:Calibri;">system</span>返回非<span style="line-height:1.8;font-family:Calibri;">0</span>值，这一特征能够决定在一个给定的操作系统上是否支持<span style="line-height:1.8;font-family:Calibri;">system</span>函数。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">使用<span style="line-height:1.8;font-family:Calibri;">system</span>而不使用<span style="line-height:1.8;font-family:Calibri;">fork</span>和<span style="line-height:1.8;font-family:Calibri;">exec</span>的长处是：<span style="line-height:1.8;font-family:Calibri;">system</span>进行了所需的各种出错处理，以及各种信号处理。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">9.</span>进程关系</h1> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">9.1shell</span>运行程序</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">ps –xj | cat1 |cat2</span>看下图</span></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">能够看到，对于每一个<span style="line-height:1.8;font-family:Calibri;">SHELL</span>命令，<span style="line-height:1.8;font-family:Calibri;">shell</span>都对<span style="line-height:1.8;font-family:Calibri;">fork</span>一个<span style="line-height:1.8;font-family:Calibri;">sh</span>来运行它，为了让<span style="line-height:1.8;font-family:Calibri;">SHELL</span>知道何时结束，<span style="line-height:1.8;font-family:Calibri;">LINUX</span>中让管道的最后一个命令为登陆<span style="line-height:1.8;font-family:Calibri;">SHELL</span>的子进程，这样当最后一个命令结束后父进程（登陆<span style="line-height:1.8;font-family:Calibri;">SHELL</span>）就会知道运行完成了。</span></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>只是对于仅仅有一个管道的命令。如：<span style="line-height:1.8;font-family:Calibri;">ps –xj | cat1</span>，看下图</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这<span style="line-height:1.8;font-family:Calibri;">2</span>个的父进程都是登陆<span style="line-height:1.8;font-family:Calibri;">SHELL</span>。</p> 
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></strong></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">10.&nbsp;</span>信号</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">信号是软件中断。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">信号提供一种处理异步事件的方法：终端用户键入中断键，则会通过信号机构停止一个程序。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">10.1&nbsp;</span>信号的三种操作</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">尽管有些废话。只是还是不得不说一下信号的三种操作</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">忽略此信号。大多数信号都能够使用该处理方式。可是有两种信号不能被忽略。它们是：<span style="line-height:1.8;font-family:Calibri;">SIGKILL</span>和<span style="line-height:1.8;font-family:Calibri;">SIGSTOP</span>。（之所以不能被忽略是由于：它们向超级用户提供一种是进程终止或停止的可靠方法。另外，假设忽略某些有硬件异常产生的信号（如非法存储訪问或除以<span style="line-height:1.8;font-family:Calibri;">0</span>），则进程的行为时没有定义的）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">捕捉信号。实现此处理方式的方式是为该信号写信号处理函数。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3、</span>&nbsp;&nbsp;<span style="line-height:1.8;">运行系统默认动作。信号的默认动作看下图。可是注意：大多数的信号的系统默认动作是终止该进程。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在上图中的“终止<span style="line-height:1.8;font-family:Calibri;">w/core</span>”表示在进程的当前工作文件夹下的<span style="line-height:1.8;font-family:Calibri;">core</span>文件里复制了该<span style="line-height:1.8;background:#FFFF00;">进程的存储图像</span>，（大多数<span style="line-height:1.8;font-family:Calibri;">UNIX</span>调试程序都是用<span style="line-height:1.8;font-family:Calibri;">core</span>文件以检查进程在终止时的状态）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">只是在下列条件下不产生<span style="line-height:1.8;font-family:Calibri;">core</span>文件：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">进程是“设置<span style="line-height:1.8;font-family:Calibri;">-</span>用户<span style="line-height:1.8;font-family:Calibri;">-ID</span>”。并且当前用户并不是程序文件的全部者。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">进程是“设置<span style="line-height:1.8;font-family:Calibri;">-</span>组<span style="line-height:1.8;font-family:Calibri;">-ID</span>”，并且当前用户并不是该程序文件的全部者。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3、</span>&nbsp;&nbsp;<span style="line-height:1.8;">用户没有写当前工作文件夹的许可权；</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">4、</span>&nbsp;&nbsp;<span style="line-height:1.8;">文件太大。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Core</span>文件的许可权（假定该文件在此之前并不存在）一般是用户读<span style="line-height:1.8;font-family:Calibri;">/</span>写。组读和其它读。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">10.2</span>各个信号的具体说明</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGABRT</span>：调用<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">abort</span></span><span style="line-height:1.8;color:#FF0000;">函数</span>时产生。进程异常终止。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGALRM</span>：超过用<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">alarm</span></span><span style="line-height:1.8;color:#FF0000;">函数</span>设置的时间时产生此信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（若由<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">settitimer(2)</span></span><span style="line-height:1.8;color:#FF0000;">函数</span>设置的间隔时间已经过时，也产生此信号）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGBUS</span>：指示一个实现定义的<span style="line-height:1.8;color:#FF0000;">硬件故障</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGEMT</span>：指示一个实现定义的<span style="line-height:1.8;color:#FF0000;">硬件故障</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGIOT</span>：指示一个实现定义的<span style="line-height:1.8;color:#FF0000;">硬件故障</span><a name="%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%9B%BE%E5%83%8F" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"></a><a name="SIGBUS%E3%80%81SIGEMT%E3%80%81SIGIOT%E7%9A%84%E5%B7%AE%E5%88%AB" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"></a>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGTRAP</span>：指示一个实现定义的<span style="line-height:1.8;color:#FF0000;">硬件故障</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>：在一个<span style="line-height:1.8;color:#FF0000;">进程终止或停止时</span>，<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>信号被送给其父进程。<span style="line-height:1.8;color:#FF0000;">按系统默认：忽略此信号</span>。假设父进程希望了解其子进程的这样的状态改变，则应捕捉此信号。信号捕捉函数中通常要调用<span style="line-height:1.8;font-family:Calibri;">wait</span>函数取得子进程的<span style="line-height:1.8;font-family:Calibri;">ID</span>和其终止状态。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">（系统<span style="line-height:1.8;font-family:Calibri;">V</span>的早期版本号有一个名为<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>的类似信号。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这一信号具有非标准的语义，<span style="line-height:1.8;font-family:Calibri;">SVR2</span>的手冊页警告在心的程序中尽量不要使用这样的信号。而应当使用标准的<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGCONT</span>：须要继续执行的处于停止状态的进程受到该信号后<span style="line-height:1.8;color:#FF0000;">继续执行</span>。否则默认动作时忽略此信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGHUP</span>：<span style="line-height:1.8;color:#FF0000;">算术运算异常</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如：除以<span style="line-height:1.8;font-family:Calibri;">0</span>，浮点溢出等。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGHUP</span>：假设<span style="line-height:1.8;color:#FF0000;">终端界面检測到一个连接断开</span>。则将此<span style="line-height:1.8;color:#FF0000;">信号送给与该终端相关的控制进程（对话期首进程）</span>。（假设<span style="line-height:1.8;color:#FF0000;">对话期前进程终止</span>，也产生此信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在此情况下，此<span style="line-height:1.8;color:#FF0000;">信号送给前台的每个进程</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）通常此信号通知精灵进程已再度它们的配置文件。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">选用<span style="line-height:1.8;font-family:Calibri;">SIGHUP</span>的理由是：由于一个精灵进程不会有一个控制终端，并且通常绝不会接收到这样的信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGILL</span>：进程运行一条<span style="line-height:1.8;color:#FF0000;">非法硬件指令</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGINFO</span>：这是一种<span style="line-height:1.8;font-family:Calibri;">4.3+BSD</span>信号。当用户<span style="line-height:1.8;color:#FF0000;">按状态键（一般为</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">CTRL+T</span></span><span style="line-height:1.8;color:#FF0000;">）时</span>，终端驱动程序产生此信号并<span style="line-height:1.8;color:#FF0000;">送至前台进程组中的每个进程</span>。此信号通常造成在终端上显示进程组中个进程的状态信息。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGINT</span>：按<span style="line-height:1.8;color:#FF0000;">中断键（</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">DELETE/CTRL+C</span></span><span style="line-height:1.8;color:#FF0000;">）时</span>，终端驱动程序产生此信号并<span style="line-height:1.8;color:#FF0000;">送至前台进程组中的每个进程</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGIO</span>：指示一个<span style="line-height:1.8;color:#FF0000;">异步</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">I/O</span></span><span style="line-height:1.8;color:#FF0000;">事件</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGKILL</span>：这是两个<span style="line-height:1.8;color:#FF0000;">不能被捕捉或忽略</span>的信号中的一个。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">它向系统管理员提供了一种能够<span style="line-height:1.8;color:#FF0000;">杀死随意进程</span>的可靠方法。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGPIPE</span>：在<span style="line-height:1.8;color:#FF0000;">读进程已经终止时写管道</span>，则产生此信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（若<span style="line-height:1.8;color:#FF0000;">进程写一个已经终止的套接口</span>也产生此信号。）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGPOLL</span>：在一个<a name="SIGPOLL" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"><span style="line-height:1.8;color:#FF0000;">可轮回设备上发生一特定事件</span></a>时产生此信号。（<span style="line-height:1.8;font-family:Calibri;">SVR4</span>信号）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGPROF</span>：当<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">setitimer(2)</span></span><span style="line-height:1.8;color:#FF0000;">函数设置的更改统计时间超过时</span>产生。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGPWR</span>：该信号解释起来有些长。详细例如以下：这是一种<span style="line-height:1.8;font-family:Calibri;">SVR4</span>信号，它依赖于系统。它主要用于具有不间断电源（<span style="line-height:1.8;font-family:Calibri;">UPS</span>）的系统上。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设电源失效，则<span style="line-height:1.8;font-family:Calibri;">UPS</span>起作用，并且通常软件会收到通知。在这样的情况下，系统依靠蓄电池电源继续执行，所以无需不论什么处理。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">可是假设蓄电池也将不支持工作免责软件一般会再次接收到通知，此时，它在<span style="line-height:1.8;font-family:Calibri;">15~30</span>秒内使系统各部分都停止执行。此时应当传递<span style="line-height:1.8;font-family:Calibri;">SIGPWR</span>信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">在大多数系统中使接到蓄电池电压过低的进程将信号<span style="line-height:1.8;font-family:Calibri;">SIGPWR</span>发送给<span style="line-height:1.8;font-family:Calibri;">init</span>进程，然后由<span style="line-height:1.8;font-family:Calibri;">init</span>处理停机操作。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGQUIT</span>：当用户在终端上<span style="line-height:1.8;color:#FF0000;">按退出键（</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">CTRL+\</span></span><span style="line-height:1.8;color:#FF0000;">）</span>时产生并<span style="line-height:1.8;color:#FF0000;">送至前台进程组中的全部进程</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（此进程不仅终止前台进程组（如<span style="line-height:1.8;font-family:Calibri;">SIGINT</span>所做的那样），同一时候产生一个<span style="line-height:1.8;font-family:Calibri;">core</span>文件）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGSEGV</span>：指示进程<span style="line-height:1.8;color:#FF0000;">进行了一次无效的存储訪问</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGSTOP</span>：一个作业控制信号。<span style="line-height:1.8;color:#FF0000;">它停止一个进程</span>。（它类似交互停止信号（<span style="line-height:1.8;font-family:Calibri;">SIGTSTP</span>），可是<span style="line-height:1.8;font-family:Calibri;">SIGSTOP</span>不能被捕捉或忽略）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGSYS</span>：指示<span style="line-height:1.8;color:#FF0000;">一个无效的系统调用</span>。（因为某种未知原因，进程运行了一条系统调用指令。但其指示系统调用类型的參数却是无效的）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGTERM</span>：由<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">kill</span></span><span style="line-height:1.8;color:#FF0000;">命令发送的</span>系统默认终止信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGTSTP</span>：交互停止信号。当用户在终端上<span style="line-height:1.8;color:#FF0000;">按挂起键（</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">CTRL+Z</span></span><span style="line-height:1.8;color:#FF0000;">）</span>时产生。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGTTIN</span>：当一个<span style="line-height:1.8;color:#FF0000;">后台进程组试图读其控制终端时</span>。终端驱动程序产生此信号。（下列情况不产生此信号<span style="line-height:1.8;font-family:Calibri;">----</span>此时读操作返回出错，<span style="line-height:1.8;font-family:Calibri;">errno</span>设置为<span style="line-height:1.8;font-family:Calibri;">EIO</span>：<span style="line-height:1.8;font-family:Calibri;">1</span>、读进程忽略或堵塞此信号；<span style="line-height:1.8;font-family:Calibri;">2</span>、读进程所属的进程组是孤儿进程）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGTTOU</span>：当<span style="line-height:1.8;color:#FF0000;">一个后台进程组试图写其控制终端时产生</span>此信号。（与上述<span style="line-height:1.8;font-family:Calibri;">SIGTTIN</span>信号不同。一个进程能够选择为同意后台进程写控制终端。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如不同意后台进程写，则以下<span style="line-height:1.8;font-family:Calibri;">2</span>中情况不会产生该信号<span style="line-height:1.8;font-family:Calibri;">----</span>此时写操作返回出错，<span style="line-height:1.8;font-family:Calibri;">errno</span>设置为<span style="line-height:1.8;font-family:Calibri;">EIO</span>：<span style="line-height:1.8;font-family:Calibri;">1</span>、写进程忽略或堵塞此信号；<span style="line-height:1.8;font-family:Calibri;">2</span>、写进程所属进程组是孤儿进程组）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><a name="SIGURG" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"><span style="line-height:1.8;font-family:Calibri;">SIGURG</span></a><span style="line-height:1.8;">：此信号通知进程已经<span style="line-height:1.8;color:#FF0000;">发生一个紧急情况</span>。（在网络连接上，接到非规定波特率的数据时。此信号可选择的产生）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGUSR1</span>：一个用户定义的信号，可用于应用程序。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGUSR2</span>：一个用户定义的信号。可用于应用程序。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGVTALRM</span>：当一个<span style="line-height:1.8;color:#FF0000;">由</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">setitimer(2)</span></span><span style="line-height:1.8;color:#FF0000;">函数设置的虚拟间隔时间已经超过时产生</span>此信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGWINCH</span>：假设一个进程<span style="line-height:1.8;color:#FF0000;">用</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">ioctl</span></span><span style="line-height:1.8;color:#FF0000;">的“设置窗体大小”命令更改了窗体大小</span>，则内核将<span style="line-height:1.8;font-family:Calibri;">SIGWINCH</span>信号送至前台进程组。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGXCPU</span>：进程<span style="line-height:1.8;color:#FF0000;">超过了其软</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">CPU</span></span><span style="line-height:1.8;color:#FF0000;">时间限制</span>时产生。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGXFSZ</span>：进程<a name="%E8%BD%AF%E6%96%87%E4%BB%B6%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"></a><a name="%E8%BD%AFCPU%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6" style="color:rgb(0,0,0);border-bottom:1px dotted rgb(51,51,51);"><span style="line-height:1.8;color:#FF0000;">超过了其软文件长度限制</span></a>时<span style="line-height:1.8;font-family:Calibri;">SVR4</span>和<span style="line-height:1.8;font-family:Calibri;">4.3+BSD</span>产生此信号。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">10.3</span>程序启动</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">运行一个程序时。全部信号的状态时系统默认<span style="line-height:1.8;font-family:Calibri;">/</span>忽略。通常全部信号都被设置为系统默认动作，除非调用<span style="line-height:1.8;font-family:Calibri;">exec</span>的进程忽略该信号。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">须要注意的是，<span style="line-height:1.8;font-family:Calibri;">exec</span>函数将原先设置为要捕捉的信号都更改为默认动作，其它信号的状态则不变（一个进程原先要捕捉的信号。在运行一个新程序后就自然地不能再捕捉了，由于信号捕捉函数的地址非常可能在所运行的新程序文件里已无意义）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SHELL</span>自己主动将后台进程中对中断和退出信号的处理方式设置为忽略。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（由于假设不这样设置的话当按下中断键时。它不但终止前台进程，也终止全部后台进程）</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">10.4&nbsp;</span>不可靠信号</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在早期的<span style="line-height:1.8;font-family:Calibri;">UNIX</span>版本号中，信号是不可靠的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这里不可靠指的是：一个信号发生后可能会被丢失，可是进程却不知道这一点。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">那时。进程对信号的控制能力非常低。它能捕捉信号或者忽略它，可是有些非常须要的功能它却不具备。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如：有时用户希望通知内核堵塞某一信号。只是该堵塞有例如以下要求<span style="line-height:1.8;font-family:Calibri;">----</span>不要忽略该信号，在其发生时记住它，直到进程满足一定条件后在通知它。这样的能力当时就不具备。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">追其原因是由于：在早期版本号中，信号一旦发生。内核就随机将信号动作复位为默认值（尽管能够通过捕捉每种信号各一次而避免这点）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">以下是早期版本号处理中断信号的经典实例代码：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int sig_int();</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signal(SIGINT,sig_int);&nbsp;&nbsp;&nbsp; //</span>建立处理程序</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sig_int(){</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signal(SIGINT,sig_int);&nbsp;&nbsp;&nbsp; //</span>为下次信号的发生重建处理程序</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……&nbsp;&nbsp; //</span>信号处理代码</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">可是有一个问题：<span style="line-height:1.8;color:#FF0000;">在信号发生后</span>到<span style="line-height:1.8;color:#FF0000;">信号调用</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">signal</span></span><span style="line-height:1.8;color:#FF0000;">函数</span>之间有一段时间，若在这段这段时间中发生还有一次该信号，那么这次对该信号的处理会运行默认动作（对于中断信号就会终止该进程）。对于这样的类型的程序段在大多数时间都能正常工作，可是结果却可能不是我们想要的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">另一个问题：在进程不希望某种信号发生时。它不能关闭该信号，仅仅能做到忽略该信号。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">如：以下的关于“阻止下列信号发生，假设它们确实产生了，请记住它们”的经典实力代码：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int sig_int_flag;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Main(){</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Intsig_int();</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signal(SIGINT,sig_int);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; While(sig_int_flag== 0)</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pause();</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sig_int(){</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signal(SIGINT,sig_int);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sig_int_flag= 1;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当中。进程调用<span style="line-height:1.8;font-family:Calibri;">pause</span>函数使自己睡眠，直到捕捉到一个信号后内核将进程唤醒。嗯。。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">。这是正常情况。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">为什么这么说？由于在“<span style="line-height:1.8;font-family:Calibri;">While(sig_int_flag == 0)</span>”和“<span style="line-height:1.8;font-family:Calibri;">Pause();</span>”之间发生信号的话（并且该信号不会再次发生）。那么此进程就会一直睡眠下去了。于是这次发生的信号就丢失了。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-family:Cambria;font-size:24px;">10.5 SIGCLD</span></h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在上面的基础上，我们来看看<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>信号，为什么要单独把它拿出来呢？这是由于由于历史原因，系统<span style="line-height:1.8;font-family:Calibri;">V</span>出了<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>信号的方式和其它的不同。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">以下详解下：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>的语义为：子进程状态改变后产生此信号。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">该信号的默认动作是<span style="line-height:1.8;font-family:Calibri;">SIG_DFL</span>（忽略）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这有一个缺点：该动作的作用是不理会该信号，可是也不舍弃子进程的状态。因此假设不用<span style="line-height:1.8;font-family:Calibri;">wait</span>和<span style="line-height:1.8;font-family:Calibri;">waitpid</span>对其子进程进行状态信息回收的话，就会产生僵尸进程。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">假设将其动作指定为<span style="line-height:1.8;font-family:Calibri;">SIG_IGN</span>，那么在忽略<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>信号的基础上子进程的状态也会被丢弃（也就是自己主动回收），因此不会产生僵尸进程。只是问题是：<span style="line-height:1.8;font-family:Calibri;">wait</span>和<span style="line-height:1.8;font-family:Calibri;">waitpid</span>无法捕捉到子进程的状态信息了（这时假设你随后调用了<span style="line-height:1.8;font-family:Calibri;">wait</span>。那么会堵塞到全部的子进程结束。然后<span style="line-height:1.8;font-family:Calibri;">wait</span>返回<span style="line-height:1.8;font-family:Calibri;">-1</span>，<span style="line-height:1.8;font-family:Calibri;">errno</span>设置为<span style="line-height:1.8;font-family:Calibri;">ECHILD</span>，即无进程等待）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">既然如此。那么假设我们自己定义其处理函数的话又会是怎么样呢？请看以下的处理函数的经典实例代码：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sig_xxx(){</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signal(SIGXXX,sig_xxx);&nbsp; //</span>重建处理函数</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>会马上检查是否有子进程准备好被等待，而这就是<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>的<span style="line-height:1.8;color:#FF0000;">最大漏洞</span>。还记得<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>的默认动作吗？对，是忽略可是不释放子进程的状态。因此，假设在重建信号处理函数前没有事先<span style="line-height:1.8;font-family:Calibri;">wait</span>处理掉信号信息的话。就会出现例如以下情况：每次设置<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>处理方式时，都回去检查是否有信号到来，假设此时信号的确到来了，就会调用自己定义的信号处理函数。然后调用重建处理函数的代码，在重建的时候仍会检查信号是否到来，此时信号未被处理。会再次出发自己定义的信号处理函数，一直循环（只是在<span style="line-height:1.8;font-family:Calibri;">RH7.2</span>上上述问题不存在。由于现今的<span style="line-height:1.8;font-family:Calibri;">UNIX</span>系统均提供可靠的信号机制，并且现今的很多<span style="line-height:1.8;font-family:Calibri;">UNIX</span>系统对<span style="line-height:1.8;font-family:Calibri;">SIGCLD</span>的定义是：<span style="line-height:1.8;font-family:Calibri;">#define SIGCLD SIGCHLD</span>）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">只是如今有一个新的信号：<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>。该信号就解决的上面的问题<span style="line-height:1.8;font-family:Calibri;">----</span>该信号的语义为：子进程状态改变后产生此信号。父进程须要调用一个<span style="line-height:1.8;font-family:Calibri;">wait</span>函数以确定发生了什么。</span></p> 
   <strong style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><br></strong>
   <span style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></span> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-family:'宋体';font-size:14px;">&nbsp;</span></h1> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">12.&nbsp;</span>高级<span style="line-height:1.8;font-family:Calibri;">I/O</span> </h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">非堵塞<span style="line-height:1.8;font-family:Calibri;">I/O</span>、记录锁、系统<span style="line-height:1.8;font-family:Calibri;">V</span>流机制、<span style="line-height:1.8;font-family:Calibri;">I/O</span>多路转接<span style="line-height:1.8;font-family:Calibri;">(select</span>和<span style="line-height:1.8;font-family:Calibri;">poll</span>函数<span style="line-height:1.8;font-family:Calibri;">)</span>、<span style="line-height:1.8;font-family:Calibri;">readv</span>和<span style="line-height:1.8;font-family:Calibri;">writev</span>函数，存储映照<span style="line-height:1.8;font-family:Calibri;">I/O(mmap)</span></span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">12.1&nbsp;</span>非堵塞<span style="line-height:1.8;font-family:Cambria;">I/O</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》的<span style="line-height:1.8;font-family:Calibri;">10.5</span>节中曾将系统调用分为两类：低速系统调用和其它。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">可是须要注意：尽管读、写磁盘会使调用在短临时间内堵塞。但并不能将他们视为“低速”。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于一个给定描写叙述符有两种方法对其指定非堵塞<span style="line-height:1.8;font-family:Calibri;">I/O</span>：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1。</span>&nbsp;&nbsp;<span style="line-height:1.8;">假设是调用<span style="line-height:1.8;font-family:Calibri;">open</span>以获得该描写叙述符。则可指定<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>标识。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2，</span>&nbsp;&nbsp;<span style="line-height:1.8;">对已已经打开的一个描写叙述符，则可调用<span style="line-height:1.8;font-family:Calibri;">fcntl</span>打开<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>文件状态标识。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">12.2&nbsp;</span>记录锁</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">其功能是：一个进程正在读或者改动文件的某个部分时，能够组织其它进程改动同一个<u>文件区</u>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">12.2.1&nbsp;</span>锁的隐含继承和释放</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">关于记录锁的自己主动继承和释放有三条规则：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">1)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="line-height:1.8;">锁与进程、文件双方面有关。这有两重含义：第一重为当一个进程终止时，它所建立的锁所有释放。<span style="line-height:1.8;color:#FF0000;">第二重为不论什么时候关闭一个描写叙述符，则该进程通过这一描写叙述符能够存放的文件上的不论什么一把锁都将释放（这些锁都是该进程设置的）。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这就意味着假设运行下列四步：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd1 = open(pathname,….);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock_reg(fd,F_SETLK, F_RDLCK, offset, whence, len);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fd2 = dup(fd1); //</span>或者<span style="line-height:1.8;font-family:Calibri;">fd2 =open(pathname, ….);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close(fd2);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">则在<span style="line-height:1.8;font-family:Calibri;">close(fd2)</span>后，在<span style="line-height:1.8;font-family:Calibri;">fd1</span>上设置的锁被释放。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int lock_reg(int fd,int cmd, int type, off_t offset, int whence, off_t len){</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structflock lock;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock.l_type= type;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock.l_start= offset;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock.l_whence= whence;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock.l_len= len;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(fcntl(fd, cmd, &amp;lock));</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">}</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">由<span style="line-height:1.8;font-family:Calibri;">fork</span>产生的子程序不继承父进程所设置的锁。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">在运行<span style="line-height:1.8;font-family:Calibri;">exec</span>后。新程序能够继承原程序的锁。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">12.3&nbsp; I/O</span>多路转接</h2> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">12.3.1&nbsp;</span>为什么须要<span style="line-height:1.8;font-family:Calibri;">I/O</span>多路转接？</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">假设我们仅仅从一个描写叙述符读，那么一个<span style="line-height:1.8;font-family:Calibri;">read/fread</span>完事。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">可是假设从多个描写叙述符读呢？试想一下以下的情况：<span style="line-height:1.8;font-family:Calibri;">1</span>、正在读的那个描写叙述符正在被写，而还有一个描写叙述符早准备好了，难道我们须要在这个描写叙述符上一直等下去？<span style="line-height:1.8;font-family:Calibri;">2</span>、假设某个描写叙述符相应的文件一直没有内容，难道我们要“不停地<span style="line-height:1.8;font-family:Calibri;">read</span>然后发现是空返回，之后等待若干秒后在<span style="line-height:1.8;font-family:Calibri;">read</span>”（此为轮询）这样浪费资源？当然不能，那么我们就想了，能不能是描写叙述符有内容了而且准备好了后通知我们让我们去读呢？当然能，而眼下来说。一种比較好的技术就是<span style="line-height:1.8;font-family:Calibri;">I/O</span>多路转接。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">12.3.2&nbsp; I/O</span>多路转接的思想是什么？</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">先构造一张有关描写叙述符的表，然后调用一个函数，它要到这些描写叙述符中的一个已准备好进行<span style="line-height:1.8;font-family:Calibri;">I/O</span>时才返回。在返回时。它告诉进程哪一个描写叙述符已准备好能够进行<span style="line-height:1.8;font-family:Calibri;">I/O</span>。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">12.3.3&nbsp;</span>怎样实现<span style="line-height:1.8;font-family:Calibri;">I/O</span>多路转接？</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">有两个函数：<span style="line-height:1.8;font-family:Calibri;">select</span>和<span style="line-height:1.8;font-family:Calibri;">poll</span>。（当然某些内核可能提供了更高级的实现，比方<span style="line-height:1.8;font-family:Calibri;">pselect</span>等等）</span></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;">12.3.3.1&nbsp; select</span>函数</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select</span>的參数告诉内核：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">我们所关心的描写叙述符。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">对于每一个描写叙述符我们所关心的条件（如：是否读一个给定的描写叙述符？是否想写一个给定的描写叙述符？是否关心一个描写叙述符的异常条件？）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3、</span>&nbsp;&nbsp;<span style="line-height:1.8;">希望等待多长时间（永远等待<span style="line-height:1.8;font-family:Calibri;">/</span>等待一固定时间<span style="line-height:1.8;font-family:Calibri;">/</span>不等待）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Select</span>返回时，内核告诉我们：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">已准备好的描写叙述符的数量</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">哪一个描写叙述符已准备好读、写或异常条件。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int select(intmaxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *tvptr);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">对于timaval：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvptr == NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 永远等待</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvptr-&gt;tv_sec==0 &amp;&amp;tvptr-&gt;tv_usec==0;&nbsp;&nbsp; 全然不等待</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tvptr-&gt;tv_sec=x &amp;&amp;tvptr-&gt;tv_usec!=y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等待x秒y微秒</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">readfds</span>：说明了文件是否可读<span style="line-height:1.8;font-family:Calibri;">;</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">writefds</span>：说明了文件是否可写<span style="line-height:1.8;font-family:Calibri;">;</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">errorfds</span>：说明了文件是否可被河蟹啦！</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">额。。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">。。是文件是否处于异常条件<span style="line-height:1.8;font-family:Calibri;">;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Fd_set&nbsp; reset;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">Int&nbsp; fd;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">FD_ZERO(&amp;rset);&nbsp;&nbsp;&nbsp;&nbsp; //</span>清除全部位</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">FD_SET(fd,&amp;reset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>设置关心的位</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">If(FD_ISSET(fd,&amp;rset)){….}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>从<span style="line-height:1.8;font-family:Calibri;">select</span>返回时，用<span style="line-height:1.8;font-family:Calibri;">FD_ISSET</span>測试该集中的某个给定位是否仍旧设置。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">顺便一提，假设在一个描写叙述符上碰到了文件结束，那么<span style="line-height:1.8;font-family:Calibri;">select</span>觉得该描写叙述符是可读的。然后调用<span style="line-height:1.8;font-family:Calibri;">read</span>的话。它返回<span style="line-height:1.8;font-family:Calibri;">0</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（非常多人错误的觉得。当到达文件结尾处时，<span style="line-height:1.8;font-family:Calibri;">select</span>会指示一个异常条件。）</p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;">12.3.3.2&nbsp; poll</span>函数</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">与<span style="line-height:1.8;font-family:Calibri;">select</span>不同，<span style="line-height:1.8;font-family:Calibri;">poll</span>不是为每一个条件构造一个描写叙述符集，而是构造一个<span style="line-height:1.8;font-family:Calibri;">pollfd</span>结构数组，每一个数组元素制定一个描写叙述符编号以及对其所关心的条件。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">int poll ( structpollfd * fds, unsigned int nfds, int timeout);</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">structpollfd {</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">intfd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 文件描写叙述符*/<br> short events;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 等待的事件*/<br> short revents;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 实际发生了的事件*/</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">} ;&nbsp;</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">关于<span style="line-height:1.8;font-family:Calibri;">pollfd</span>的<span style="line-height:1.8;font-family:Calibri;">events</span>和<span style="line-height:1.8;font-family:Calibri;">revents</span>标志看下图：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>值得一提的是最后三个：即使在<span style="line-height:1.8;font-family:Calibri;">events</span>字段中没有指定这三个值，假设对应条件发生，则在<span style="line-height:1.8;font-family:Calibri;">revents</span>中也返回它们。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">关于timeout：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Timeout == 0&nbsp; ：&nbsp;&nbsp;&nbsp; 不等待；</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Timeout == INFTIM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：&nbsp;&nbsp;&nbsp; 永远等待；</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Timeout &gt; 0&nbsp;&nbsp;&nbsp; ：&nbsp;&nbsp;&nbsp; 等待timeout毫秒。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;">12.3.3.3 select</span>和<span style="line-height:1.8;font-family:Cambria;">poll</span>的对照</h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设须要操作的描写叙述符(如文件描写叙述符)少的话select和poll在性能上差点儿没有差异，并且由于select实现起来相对简单而成为了首选，只是若描写叙述符非常多的话那poll就快于select了，由于select须要遍历全部的描写叙述符而poll就跳过了这一步。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">12.3.4&nbsp;</span>多线程和<span style="line-height:1.8;font-family:Calibri;">I/O</span>多路转接</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">若线程数少的话多线程（每一个线程会申请8M的空间----当然不同的内核会有不同。因此假设线程过多那么内存是不够的）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">须要操作的文件太大（上百M）的话也多线程。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">反正就I/O多路转接了。</p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;">14.&nbsp;</span>进程间通信</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">下表为不同实现所支持的不同形式的<span style="line-height:1.8;font-family:Calibri;">IPC</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>上表中的前<span style="line-height:1.8;font-family:Calibri;">7</span>种<span style="line-height:1.8;font-family:Calibri;">IPC</span>通常限于同一台主机的各个进程间的<span style="line-height:1.8;font-family:Calibri;">IPC</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">最后两种：套接口和流支持不同主机上各个进程间的<span style="line-height:1.8;font-family:Calibri;">IPC</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">14.1&nbsp;</span>管道</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">管道有两种限制：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">它们是半双工的。数据仅仅能在一个方向上流动。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">它们仅仅能在具有公共祖先的进程之间使用。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">通常，一个管道由一个进程创建，然后该进程调用<span style="line-height:1.8;font-family:Calibri;">fork</span>，此后父、子进程之间就可应用该管道。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">只是流管道没有第一种限制<span style="line-height:1.8;font-family:Calibri;">(</span>即它是全双工的<span style="line-height:1.8;font-family:Calibri;">)</span>，<span style="line-height:1.8;font-family:Calibri;">FIFO</span>和命名流管道则没有另外一种限制。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">创建管道的函数：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int pipe(int filedes[2]);&nbsp;&nbsp;&nbsp;&nbsp; //filedes[0]:</span>为读而打开<span style="line-height:1.8;font-family:Calibri;">, filedes[1]:</span>为写而打开。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">能够使用<span style="line-height:1.8;font-family:Calibri;">fstat</span>以及<span style="line-height:1.8;font-family:Calibri;">S_ISFIFO</span>宏来測试管道。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">单个进程中的管道差点儿没有不论什么用处。通常，调用<span style="line-height:1.8;font-family:Calibri;">pipe</span>的进程接着调用<span style="line-height:1.8;font-family:Calibri;">fork</span>，这样就创建了从父进程到子进程或反之的<span style="line-height:1.8;font-family:Calibri;">IPC</span>通道。如图所看到的：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">图中的红蓝两条线是我加入的，毕竟是父子进程互相联系，而原图（没有这两条线）给人感觉是父进程内部和子进程内部通信（那样的话还要<span style="line-height:1.8;font-family:Calibri;">IPC</span>干吗？）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当管道的一端被关闭后。下列规则起作用：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">当读一个写端已被关闭的管道时。在全部数据都被读取后。<span style="line-height:1.8;font-family:Calibri;">read</span>返回<span style="line-height:1.8;font-family:Calibri;">0</span>，以指示达到了文件结束处。（若管道的写端还有进程时，就不会产生文件结束。）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">如写一个读端被关闭的管道。则产生信号<span style="line-height:1.8;font-family:Calibri;">SIGPIPE</span>。假设忽略该信号或者捕捉该信号并从其处理程序返回，则<span style="line-height:1.8;font-family:Calibri;">write</span>出错返回，<span style="line-height:1.8;font-family:Calibri;">errno</span>设置为<span style="line-height:1.8;font-family:Calibri;">EPIPE</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在<span style="line-height:1.8;font-family:Calibri;">limits.h</span>中定义了常数<span style="line-height:1.8;font-family:Calibri;">PIPE_BUF(</span>一般值为<span style="line-height:1.8;font-family:Calibri;">4096)</span>。该值规定了内核中管道缓存器的大小。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设对管道进行<span style="line-height:1.8;font-family:Calibri;">write</span>调用，并且要求写的字数小于等于<span style="line-height:1.8;font-family:Calibri;">PIPE_BUF</span>，则此操作不会与其它进程对同一管道（或<span style="line-height:1.8;font-family:Calibri;">FIFO</span>）的<span style="line-height:1.8;font-family:Calibri;">write</span>操作穿插进行。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">但，若有多个进程同一时候写一个管道（或<span style="line-height:1.8;font-family:Calibri;">FIFO</span>）。并且某个或某些进程要求写的字节数超过<span style="line-height:1.8;font-family:Calibri;">PIPE_BUF</span>。则数据可能会与其它写操作的数据相穿插。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">14.2 popen</span>和<span style="line-height:1.8;font-family:Cambria;">pclose</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">由于例如以下情况非经常见：创建一个连接到还有一个进程的管道，然后读其输出或向其发送输入。所以有了这两个函数。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这两个函数实现的操作是：创建一个管道。<span style="line-height:1.8;font-family:Calibri;">fork</span>一个子进程，关闭管道的不适用端。<span style="line-height:1.8;font-family:Calibri;">exec</span>一个<span style="line-height:1.8;font-family:Calibri;">shell</span>以运行命令。等待命令终止。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">函数例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE* popen(const char* cmdstring,const char type);&nbsp;&nbsp; //type : ”r”, “w”</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int pclose(FILE* fp);</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">14.3&nbsp;</span>管道，命名管道，协同进程之间的差别（转）</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">管道：仅仅能有一个进程创建，并写入值。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">命名管道：能够支持不相关的进程之间使用这个管道。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">协同进程：同意一个进程将其<span style="line-height:1.8;font-family:Calibri;">stdin</span>及<span style="line-height:1.8;font-family:Calibri;">stdout</span>这两个标准<span style="line-height:1.8;font-family:Calibri;">IO</span>绑定到相应的进程。能够向同一个进程写入数据。并从里面读取数据。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">14.4 FIFO(</span>命名管道<span style="line-height:1.8;font-family:Cambria;">)</span> </h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">创建命名管道的函数：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;sys/types.h&gt;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;sys/stst.h&gt;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Int mkfifo(const char pathname, mode_tmode);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>成功返回<span style="line-height:1.8;font-family:Calibri;">0</span>。出错返回<span style="line-height:1.8;font-family:Calibri;">-1</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">创建了一个<span style="line-height:1.8;font-family:Calibri;">FIFO</span>后，能够用<span style="line-height:1.8;font-family:Calibri;">open</span>打开它。（一般的文件<span style="line-height:1.8;font-family:Calibri;">I/O</span>函数<span style="line-height:1.8;font-family:Calibri;">—close,read, write, unlink</span>等均适用于<span style="line-height:1.8;font-family:Calibri;">FIFO</span>）。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">14.4.1&nbsp;</span>打开<span style="line-height:1.8;font-family:Calibri;">FIFO</span>和<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span> </h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">注意：当打开一个<span style="line-height:1.8;font-family:Calibri;">FIFO</span>时，非堵塞标志（<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>）产生下列影响：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">在普通情况中（没有说明<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>），一进程为读打开了某<span style="line-height:1.8;font-family:Calibri;">FIFO</span>。可是没有进程为写而打开它。那该<span style="line-height:1.8;font-family:Calibri;">FIFO</span>一直堵塞到某个其它进程为写打开此<span style="line-height:1.8;font-family:Calibri;">FIFO</span>。类似，为写而打开一个<span style="line-height:1.8;font-family:Calibri;">FIFO</span>要堵塞到某个其它进程为读而打开它。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">假设指定了<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>。则假设没有进程已经为写而打开该<span style="line-height:1.8;font-family:Calibri;">FIFO</span>，那么用仅仅读打开该<span style="line-height:1.8;font-family:Calibri;">FIFO</span>的进程会马上返回。可是，假设没有进程已经为读而打开此<span style="line-height:1.8;font-family:Calibri;">FIFO</span>，那么仅仅写打开将出错返回。其<span style="line-height:1.8;font-family:Calibri;">errno</span>是<span style="line-height:1.8;font-family:Calibri;">ENXIO</span>。（因此假设两个进程均用<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>打开此<span style="line-height:1.8;font-family:Calibri;">FIFO</span>的话，那就会出问题了<span style="line-height:1.8;font-family:Calibri;">—</span>由于不可能同一时候为读为写打开<span style="line-height:1.8;font-family:Calibri;">FIFO</span>。所以全会马上返回。所以依据须要某个进程用<span style="line-height:1.8;font-family:Calibri;">O_NONBLOCK</span>打开，另外一个不用该方式打开）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">类似于管道。若写一个尚无进程为读而打开<span style="line-height:1.8;font-family:Calibri;">FIFO</span>，则产生信号<span style="line-height:1.8;font-family:Calibri;">SIGPIPE</span>。若某个<span style="line-height:1.8;font-family:Calibri;">FIFO</span>的最有一个写进程关闭了该<span style="line-height:1.8;font-family:Calibri;">FIFO</span>，则将为该<span style="line-height:1.8;font-family:Calibri;">FIFO</span>的读进程产生一个文件结束标志。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;color:#FF0000;">一个给定的</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">FIFO</span></span><span style="line-height:1.8;color:#FF0000;">有多个写进程是常见的。这就意味着假设不希望多个进程缩写的数据互相穿插，则需考虑原子写操作。</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">正如对于管道一样。常数<span style="line-height:1.8;font-family:Calibri;">PIPE_BUF</span>说明了可被原子写到<span style="line-height:1.8;font-family:Calibri;">FIFO</span>的最大数据量。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">14.4.2 FIFO</span>的两种用途</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>、<span style="line-height:1.8;font-family:Calibri;">FIFO</span>由<span style="line-height:1.8;font-family:Calibri;">shell</span>命令使用一遍将数据从一条管道线传送到还有一条，为此无需创建中间暂时文件。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2</span>、<span style="line-height:1.8;font-family:Calibri;">FIFO</span>用于客户机<span style="line-height:1.8;font-family:Calibri;">-</span>server应用程序中，以在客户机和server之间传递数据。</p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">14.5&nbsp;</span>消息队列、信号量以及共享存储器</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">三种系统<span style="line-height:1.8;font-family:Calibri;">V IPC</span>：消息队列、信号量以及共享存储器它们各自的功能以及特征。</span></p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">14.5.1&nbsp;</span>标识符和keyword</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">都用一个非负整数的标识符加以引用。（如：为了对一个消息队列发送<span style="line-height:1.8;font-family:Calibri;">/</span>或取消息，仅仅需知道其队列标识符。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）<span style="line-height:1.8;font-family:Calibri;"></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">于文件描写叙述符不同，<span style="line-height:1.8;font-family:Calibri;">IPC</span>标识符不是小的整数。当一个<span style="line-height:1.8;font-family:Calibri;">IPC</span>被创建，以后又被删除时。与这结构相关的标志连续加<span style="line-height:1.8;font-family:Calibri;">1</span>。直至达到一个整数的最大正直，然后又转回到<span style="line-height:1.8;font-family:Calibri;">0</span>。（即使在<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构被删除后也记住该值，每次使用此结构时则增<span style="line-height:1.8;font-family:Calibri;">1</span>，该值被称为“槽使用顺序号”）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当创建<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构时，一定要制定一个keyword（<span style="line-height:1.8;font-family:Calibri;">key</span>），其数据类型是<span style="line-height:1.8;font-family:Calibri;">key_t</span>。内核会将keyword变换成标识符。</span></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;">使客户机和server在同一<span style="line-height:1.8;font-family:Cambria;">IPC</span>结构上会合的方法：</span></h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">server使用keyword<span style="line-height:1.8;font-family:Calibri;">IPC_PRIVATE</span>创建<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构，然后将返回的标识符放在某处（如一个文件）以便客户机取用。<span style="line-height:1.8;color:#FF0000;">这样的技术有个缺点：</span>server要将整形标识符写到文件里。然后客户机在此后又要读文件取得此标识符。（keyword<span style="line-height:1.8;font-family:Calibri;">IPC_PRIVATE</span>保证server创建一个新<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构，该keyword也可用于父、子关系进程。父进程制定<span style="line-height:1.8;font-family:Calibri;">IPC_PRIVATE</span>创建一个新<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构。所返回的标识符在<span style="line-height:1.8;font-family:Calibri;">fork</span>后可有子进程使用。子进程可将此标识符作为<span style="line-height:1.8;font-family:Calibri;">exec</span>函数的一个參数传给一个新程序。）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">在一个公用头文件里定义一个客户机和server都认可的keyword。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">然后server制定此keyword创建一个新的<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构。<span style="line-height:1.8;color:#FF0000;">缺点是：</span>假设该keyword已经和一个<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构相结合。那么运行<span style="line-height:1.8;font-family:Calibri;">get</span>函数（<span style="line-height:1.8;font-family:Calibri;">msgget</span>、<span style="line-height:1.8;font-family:Calibri;">semget</span>、<span style="line-height:1.8;font-family:Calibri;">shmget</span>）时会出错返回。所以server需注意处理这一错误：删除已经存在的<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构。然后试着再创建它。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3、</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">客户机和server认同一个路径名和课题<span style="line-height:1.8;font-family:Calibri;">ID</span>（<span style="line-height:1.8;font-family:Calibri;">0~255</span>之间的字符值），然后调用<span style="line-height:1.8;font-family:Calibri;">ftok</span>将这两个值变换为一个keyword，然后再方法<span style="line-height:1.8;font-family:Calibri;">2</span>中使用次keyword。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;color:#FF0000;">缺点是：</span><span style="line-height:1.8;font-family:Calibri;">ftok</span>尽管能够生成一个特殊的keyword，可是该keyword生成什么样我们不知道，所以一般避免使用<span style="line-height:1.8;font-family:Calibri;">ftok</span>，改为在头文件里存放一个大家都知道的keyword。</p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;">三个能够创建<span style="line-height:1.8;font-family:Cambria;">IPC</span>的<span style="line-height:1.8;font-family:Cambria;">get</span>函数</span></h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这三个函数式<span style="line-height:1.8;font-family:Calibri;">msgget</span>、<span style="line-height:1.8;font-family:Calibri;">semget</span>和<span style="line-height:1.8;font-family:Calibri;">shmget</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这三个<span style="line-height:1.8;font-family:Calibri;">get</span>函数都有两个类似的參数<span style="line-height:1.8;font-family:Calibri;">key</span>和一个整形的<span style="line-height:1.8;font-family:Calibri;">flag</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">若满足下列条件。则创建一个新的<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构（通常由server创建）：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">key</span>是<span style="line-height:1.8;font-family:Calibri;">IPC_PRIVATE</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">key</span>未和特定类型的<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构相结合，<span style="line-height:1.8;font-family:Calibri;">flag</span>中制定了<span style="line-height:1.8;font-family:Calibri;">IPC_CREAT</span>位。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（为訪问现存的队列<span style="line-height:1.8;font-family:Calibri;">—</span>通常由客户机进行，<span style="line-height:1.8;font-family:Calibri;">key</span>必须等于创建该队列时所指定的keyword。而且不应制定<span style="line-height:1.8;font-family:Calibri;">IPC_CREAT</span>）</p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;">注意：</span></h4> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>假设目的是訪问一个现存队列。那么决不能指定<span style="line-height:1.8;font-family:Calibri;">IPC_PRIVATE</span>作为keyword。由于该keyword总是用于创建一个新队列。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（为了訪问一个用于<span style="line-height:1.8;font-family:Calibri;">IPC_PRIVATE</span>作为keyword创建的现存队列，一定要知道与该队列相结合的标识符，然后再其它<span style="line-height:1.8;font-family:Calibri;">IPC</span>调用中<span style="line-height:1.8;font-family:Calibri;">(</span>如<span style="line-height:1.8;font-family:Calibri;">msgsnd</span>、<span style="line-height:1.8;font-family:Calibri;">msgrcv)</span>中使用该标识符）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>假设希望创建一个新<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构，保证不是引用具有同一标识符的一个现行<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构。那么必须在<span style="line-height:1.8;font-family:Calibri;">flag</span>中同一时候指定<span style="line-height:1.8;font-family:Calibri;">IPC_CREAT</span>和<span style="line-height:1.8;font-family:Calibri;">IPC_EXCL</span>位。这样假设<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构已经存在就会造成出错。返回<span style="line-height:1.8;font-family:Calibri;">EEXIST</span>（这与指定了<span style="line-height:1.8;font-family:Calibri;">O_CREAT</span>和<span style="line-height:1.8;font-family:Calibri;">O_EXCL</span>标志的<span style="line-height:1.8;font-family:Calibri;">open</span>相类似）。</p> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">14.5.2 ipc_perm</span>结构（许可权结构）</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">struct ipc_perm{</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid_t uid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>拥有者有效的用户<span style="line-height:1.8;font-family:Calibri;">id</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid_t gid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>拥有者有效的组<span style="line-height:1.8;font-family:Calibri;">id</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uid_t cuid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>创造者有效的用户<span style="line-height:1.8;font-family:Calibri;">id</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gid_t cgid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>创造者有效的组<span style="line-height:1.8;font-family:Calibri;">id</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode_t mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>使用模式</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ulong seq;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>槽使用序列号</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_t key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //key</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">}</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在创建<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构时。除<span style="line-height:1.8;font-family:Calibri;">seq</span>以外的全部字段都赋初值。以后能够调用<span style="line-height:1.8;font-family:Calibri;">msgctl</span>、<span style="line-height:1.8;font-family:Calibri;">semctl</span>或<span style="line-height:1.8;font-family:Calibri;">shmctl</span>改动<span style="line-height:1.8;font-family:Calibri;">uid</span>、<span style="line-height:1.8;font-family:Calibri;">gid</span>和<span style="line-height:1.8;font-family:Calibri;">mode</span>字段。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h4 style="font-size:14px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;">表<span style="line-height:1.8;font-family:Cambria;">14-2&nbsp;</span>？？？？</span></h4> 
   <h3 style="font-size:16px;line-height:1.5;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Calibri;font-size:24px;">14.5.3&nbsp;</span>长处和缺点</h3> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">缺点：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1</span>，<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构在系统范围内起作用，没有訪问技术。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">如：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于消息队列：假设创建了一个消息队列，在该队列中放入了几则消息，然后终止，可是该消息队列及其内容并不被删除。它们余留在系统直至：由某个进程调用<span style="line-height:1.8;font-family:Calibri;">magrcv</span>和<span style="line-height:1.8;font-family:Calibri;">msgctl</span>读消息或删除消息队列，或某个进程运行<span style="line-height:1.8;font-family:Calibri;">ipcrm</span>命令删除消息队列；或由正在启动的系统删除消息队列。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于管道<span style="line-height:1.8;font-family:Calibri;">pipe</span>，当最后一个訪问管道终止时。管道就被全然删除了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">对于<span style="line-height:1.8;font-family:Calibri;">FIFO</span>而言尽管当最后一个引用<span style="line-height:1.8;font-family:Calibri;">FIFO</span>的进程终止时其名字仍保留在系统中，直至显示的删除它，可是留在<span style="line-height:1.8;font-family:Calibri;">FIFO</span>中的数据却在此时所有删除。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; 2</span>，<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构并不按名字为文件系统所知。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们不能用<span style="line-height:1.8;font-family:Calibri;">open</span>、<span style="line-height:1.8;font-family:Calibri;">write</span>、<span style="line-height:1.8;font-family:Calibri;">close</span>这类函数来存取他们或改动它们的特征。为了支持它们不能不添加多个全新的调用（<span style="line-height:1.8;font-family:Calibri;">msgget</span>、<span style="line-height:1.8;font-family:Calibri;">semop</span>、<span style="line-height:1.8;font-family:Calibri;">shmat</span>等）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>我们不能用<span style="line-height:1.8;font-family:Calibri;">ls</span>看到它们，不能用<span style="line-height:1.8;font-family:Calibri;">rm</span>删除它们。不能用<span style="line-height:1.8;font-family:Calibri;">chmod</span>命令更改它们的存取全。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">于是，也不得不添加了全新的命令<span style="line-height:1.8;font-family:Calibri;">ipcs</span>和<span style="line-height:1.8;font-family:Calibri;">ipcrm</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>由于这些<span style="line-height:1.8;font-family:Calibri;">IPC</span>不适用文件描写叙述符。所以不能对它们使用多路转接<span style="line-height:1.8;font-family:Calibri;">I/O</span>函数：<span style="line-height:1.8;font-family:Calibri;">select</span>和<span style="line-height:1.8;font-family:Calibri;">poll</span>。这就使得一次使用多个<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构。以及用文件或设备<span style="line-height:1.8;font-family:Calibri;">I/O</span>来使用<span style="line-height:1.8;font-family:Calibri;">IPC</span>结构非常难做到。（比如：没有某种形式的忙<span style="line-height:1.8;font-family:Calibri;">-</span>等待循环。就不能使一个server等待一个消息放在两个消息队列的任一一个中）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">长处：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; 1</span>。可靠；<span style="line-height:1.8;font-family:Calibri;">2</span>，受控制的；<span style="line-height:1.8;font-family:Calibri;">3</span>。面向记录；<span style="line-height:1.8;font-family:Calibri;">4</span>，能够用非先进先出方式处理。（流也具有这些长处）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"> <span style="line-height:1.8;font-family:Cambria;font-size:24px;">14.6&nbsp;</span>消息队列</h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">消息队列是消息的连接表。存放在内核中并由消息队列标识符标识。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">以下介绍下和消息队列有关的函数：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; msgget</span>：用于创建一个新队列<span style="line-height:1.8;font-family:Calibri;">/</span>打开一个现存的队列。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; msgsnd</span>：用于将新消息加入到队列尾端。（每一个消息包括一个正长整形类型字段，一个非负长度以及实际数据字节（相应于长度），全部这些都在将消息加入到队列时，传送给<span style="line-height:1.8;font-family:Calibri;">msgsnd</span>）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp; msgcrv</span>：用于从队列中取消息（我们并不一定要以先进先出次序取消息，也能够按消息的类型字段取消息）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>每一个队列都有一个<span style="line-height:1.8;font-family:Calibri;">msqid_ds</span>结构与其相关。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">此结构例如以下：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>以下具体说明：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span>、新建<span style="line-height:1.8;font-family:Calibri;">/</span>打开一个消息队列：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msgget(key_tkey, int flag);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>成功返回消息队列的<span style="line-height:1.8;font-family:Calibri;">ID</span>，失败为<span style="line-height:1.8;font-family:Calibri;">-1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>当创建一个新队列时。初始化<span style="line-height:1.8;font-family:Calibri;">msqid_ds</span>结构的下列成员：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg_qnum</span>、<span style="line-height:1.8;font-family:Calibri;">msg_lspid</span>、<span style="line-height:1.8;font-family:Calibri;">msg_lrpid</span>、<span style="line-height:1.8;font-family:Calibri;">msg_stime</span>和<span style="line-height:1.8;font-family:Calibri;">msg_rtime</span>均设置为<span style="line-height:1.8;font-family:Calibri;">0</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg_ctime</span>设置为当前时间。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg_qbytes</span>设置为系统限制值。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span>、对队列运行多种操作：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msgctl(intmsqid, int cmd, struct msqid_ds* buf);&nbsp;&nbsp;&nbsp; //</span>成功返回<span style="line-height:1.8;font-family:Calibri;">0</span>，出错为<span style="line-height:1.8;font-family:Calibri;">-1</span>；</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd</span>參数例如以下（以下三个參数也可用于信号量和共享存储）：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPC_STAT</span>：取此队列的<span style="line-height:1.8;font-family:Calibri;">msqid_ds</span>结构。并将其存放在<span style="line-height:1.8;font-family:Calibri;">buf</span>指向的结构中。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPC_SET</span>：按由<span style="line-height:1.8;font-family:Calibri;">buf</span>指向的结构中的值，设置于此队列相关的结构中的下列四个字段：<span style="line-height:1.8;font-family:Calibri;">msg_perm.uid</span>、<span style="line-height:1.8;font-family:Calibri;">msg_perm.gid</span>、<span style="line-height:1.8;font-family:Calibri;">msg_perm.mode</span>和<span style="line-height:1.8;font-family:Calibri;">msg_perm.qbytes</span>。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（<span style="line-height:1.8;color:#FF0000;">此命令仅仅能有下列两种进程运行：</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">1</span></span><span style="line-height:1.8;color:#FF0000;">、其有效用户</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">ID</span></span><span style="line-height:1.8;color:#FF0000;">等于</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">msg_perm.cuid</span></span><span style="line-height:1.8;color:#FF0000;">或</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">msg_perm.uid</span></span><span style="line-height:1.8;color:#FF0000;">；</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">2</span></span><span style="line-height:1.8;color:#FF0000;">、具有超级用户特权的进程。仅仅有超级用户才干添加</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">msg_qbytes</span></span><span style="line-height:1.8;color:#FF0000;">的值</span>）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPC_RMID</span>：从系统中删除该消息队列以及仍在该队列上的全部数据。（<span style="line-height:1.8;color:#FF0000;">该删除马上生效。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">仍在使用这一消息队列的其它进程在他们下一次试图对此队列进行操作时。将出错返回<span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">EIDRM</span></span><span style="line-height:1.8;color:#FF0000;">。此命令仅仅能由下列两种进程运行：</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">1</span></span><span style="line-height:1.8;color:#FF0000;">、其有效用户</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">ID=msg_perm.cuid</span></span><span style="line-height:1.8;color:#FF0000;">或</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">msg_perm.uid</span></span><span style="line-height:1.8;color:#FF0000;">；</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">2</span></span><span style="line-height:1.8;color:#FF0000;">、具有超级用户特权和进程</span>）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</span>、将数据放到消息队列上：</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int magsnd(intmsqid, const void* ptr, size_t&nbsp; nbytes,int flag);&nbsp;&nbsp; //</span>成功返回<span style="line-height:1.8;font-family:Calibri;">0</span>。反之<span style="line-height:1.8;font-family:Calibri;">-1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span>、从队列中取消息</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int msgrcv(intmsqid, void* ptr, size_t nbytes, long type, int flag);</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><strong><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></strong></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">1</span>：带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>和不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>的差别</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》的第三章为“不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”，第五章为“带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>首先，我们须要明白一点，上面两个是“术语”，不是“述语”（描写叙述性质的语言）。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">事实上“不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”实际上也是带缓存的。仅仅只是此缓存非比缓存。这里的“不带缓存”指的是“不带流缓存”，而这也就是和“带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”的差别了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">以下让我详解下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》上对“不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”的定义是：每一个<span style="line-height:1.8;font-family:Calibri;">read</span>和<span style="line-height:1.8;font-family:Calibri;">write</span>都调用内核中的一个系统调用。什么意思？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">是这种：当我们调用<span style="line-height:1.8;font-family:Calibri;">write</span>函数时。直接调用系统调用，将数据写入到<span style="line-height:1.8;color:#FF0000;">块缓存</span>进行排队，当块缓存达到一定量时，才会把数据写入磁盘。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">而带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>对其进行了改进，它提供了一个流缓存，当用<span style="line-height:1.8;font-family:Calibri;">fwrite</span>函数时，先把数据写入到流缓存中。当达到一定条件，如：流缓存区满了、刷新流缓存时。才会把数据一次性送往内核提供的块缓存中。再经块缓存写入磁盘。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这样说假设还有些不清楚的话请看以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>的操作（以写为例）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;</span>将数据写入内核提供的块缓存</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;</span>经块缓存写入磁盘</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>的操作（以写为例）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;</span>将数据写入流缓存直至达到条件</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;</span>将数据一次性写入内核提供的块缓存</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;</span>经块缓存写入磁盘</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">怎么样？这样就清楚些了吧。“带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”比“不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”多了一步。而另外两步一样。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">事实上，标准库中的“带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”就是调用系统提供的“不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”实现的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">最后，总结一下：“不带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”是相对于“带缓存的<span style="line-height:1.8;font-family:Calibri;">I/O</span>”等流函数来说明的，由于后者的会先将数据在流缓存中进行操作，前者则无此步骤而直接和内核提供的块缓存进行交互，所以称前者是“不带缓存”的。事实上对于内核来说，它还是进行了缓存的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">2</span>：流</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">先总结下关于流的一些翻译：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,</span>流是与磁盘或其它外围设备关联的数据的源或目的地。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,</span>流是（表达）读写数据的一种可移植的方法，它为一般的<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作提供了灵活有效的手段。一个流是一个由指针操作的文件或者是一个物理设备。而这个指针正是指向了这个流。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3,&nbsp;</span>无论是交互与诸如终端盒磁带驱动器之类的物理设备，还是存取与由结构化存储设备支撑的文件。输入和输出（信息）都被映射为逻辑数据流，而流的属性却远不是诸多输入输出属性的统一。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4, ANSI C</span>进一步对<span style="line-height:1.8;font-family:Calibri;">I/O</span>的概念进行了抽象。就<span style="line-height:1.8;font-family:Calibri;">C</span>程序而言，全部的<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作知识简单地从程序移进或移出字节的事情。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">因此毫不惊奇的是，这样的字节流便被称为流。程序仅仅须要关心创建正确的输出字节数据，以及正确的解释从输入数据的字节数据。特定<span style="line-height:1.8;font-family:Calibri;">I/O</span>设备的细节对程序猿是隐藏的。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">定义大致如上。以下总结一下。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1。</span>&nbsp;&nbsp;<span style="line-height:1.8;">流是一个抽象的概念，并非一个物理设备的概念。假设用某个看得见摸得着的物理设备做參考来理解流的话那就大错特错了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2，</span>&nbsp;&nbsp;<span style="line-height:1.8;">流是对<span style="line-height:1.8;font-family:Calibri;">I/O</span>系统中的一种<span style="line-height:1.8;font-family:Calibri;">I/O</span>机制和功能的抽象。就像运输工具是对一切运动载体的抽象一样。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3，</span>&nbsp;&nbsp;<span style="line-height:1.8;">流是一种“动”的概念，精巧存储在介质上的信息仅仅有当他按一定的序列准备“运动”时才成为流。（精巧的信息具有流的潜力，但不一定是流，就像没有汽油的汽车一样，它具有成为运输工具的潜力。但还不是运输工具）。流有源头也有目的地（而且他将源头和目的地相关联）。而且一定带有某种信息（好像说了句废话）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">3</span>：原子操作</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">何为<span style="line-height:1.8;font-family:Calibri;">“</span>原子操作<span style="line-height:1.8;font-family:Calibri;">”</span>呢？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">事实上说白了，就是一个由多步操作组成。这些步骤要不运行就一个都不运行。假设运行的话，那么从第一步開始到最后一步结束绝对不会被信号等线程调度机制打断。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》上说的<span style="line-height:1.8;font-family:Calibri;">“</span>原子的运行<span style="line-height:1.8;font-family:Calibri;">”</span>也就是这个意思了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">其重要性在哪呢？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">我们知道，<span style="line-height:1.8;font-family:Calibri;">CPU</span>在用极快的速度不停地切换执行程序，这种优点是能够<span style="line-height:1.8;font-family:Calibri;">“</span>同一时候<span style="line-height:1.8;font-family:Calibri;">”</span>执行好多程序，但坏处就是可能会造成一些让我们头痛不已的问题。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">举个样例：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">我们想完毕例如以下的操作：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1.&nbsp;</span>打开一个文件（如果该文件已创建并且里面有我们须要的内容）<span style="line-height:1.8;font-family:Calibri;">;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2.&nbsp;</span>给该文件<span style="line-height:1.8;font-family:Calibri;">+</span>读锁<span style="line-height:1.8;font-family:Calibri;">;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3.&nbsp;</span>读取文件的内容<span style="line-height:1.8;font-family:Calibri;">;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">4.&nbsp;</span>解锁<span style="line-height:1.8;font-family:Calibri;">;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">5.&nbsp;</span>关闭文件。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这个操作看起来挺安全的。可是假设出现这样的情况呢：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在上述的步骤<span style="line-height:1.8;font-family:Calibri;">1</span>和<span style="line-height:1.8;font-family:Calibri;">2</span>之间<span style="line-height:1.8;font-family:Calibri;">(</span>即<span style="line-height:1.8;font-family:Calibri;">“</span>打开文件<span style="line-height:1.8;font-family:Calibri;">”</span>和<span style="line-height:1.8;font-family:Calibri;">“</span>加读锁<span style="line-height:1.8;font-family:Calibri;">”</span>之间<span style="line-height:1.8;font-family:Calibri;">)</span>突然有一个进程打开了这个文件<span style="line-height:1.8;font-family:Calibri;">(</span>这是<span style="line-height:1.8;font-family:Calibri;">CPU</span>切换到了这个进程。而原来的进程则被临时搁置了，也就是原来的进程被打断了<span style="line-height:1.8;font-family:Calibri;">)</span>，并往里面写入了一些内容后退出了。那么我们读到的内容可能就不是我们希望的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">之所以会出现上面的问题，就是由于上面<span style="line-height:1.8;font-family:Calibri;">5</span>步不是<span style="line-height:1.8;font-family:Calibri;">“</span>原子操作<span style="line-height:1.8;font-family:Calibri;">”</span>，假设是<span style="line-height:1.8;font-family:Calibri;">“</span>原子操作<span style="line-height:1.8;font-family:Calibri;">”</span>的话。那么从第<span style="line-height:1.8;font-family:Calibri;">1</span>步開始到最后一步结束为止，不会出现被打断的情况了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">由此。<span style="line-height:1.8;font-family:Calibri;">“</span>原子操作<span style="line-height:1.8;font-family:Calibri;">”</span>的重要性不言而喻。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">关于<span style="line-height:1.8;font-family:Calibri;">“</span>原子操作<span style="line-height:1.8;font-family:Calibri;">”</span>的误区：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">以下这句代码是不是原子操作呢？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">temp += 1;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">是？不是？是不是？</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">事实上不是。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">由于这句代码在翻译成汇编的话例如以下：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">mov ax,[temp] //</span>将<span style="line-height:1.8;font-family:Calibri;">temp</span>的值传到寄存器<span style="line-height:1.8;font-family:Calibri;">ax</span>中<span style="line-height:1.8;font-family:Calibri;">(</span>也就是将其值传到一个内存地址中<span style="line-height:1.8;font-family:Calibri;">)</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">inc ax //</span>对寄存器<span style="line-height:1.8;font-family:Calibri;">ax</span>中的值<span style="line-height:1.8;font-family:Calibri;">+1</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">mov [temp],ax //</span>将寄存器<span style="line-height:1.8;font-family:Calibri;">ax</span>中的值传回<span style="line-height:1.8;font-family:Calibri;">temp</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">可见，仅仅有一行的代码不见得就是<span style="line-height:1.8;font-family:Calibri;">“</span>原子操作<span style="line-height:1.8;font-family:Calibri;">”</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">4</span>：延迟写</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">传统的<span style="line-height:1.8;font-family:Calibri;">UNIX</span>实如今内核中没有缓冲存储器。大多数磁盘<span style="line-height:1.8;font-family:Calibri;">I/O</span>都通过缓存进行。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">当将数据写到文件上时，通常该数据先由内核拷贝到缓存中。假设该该缓存尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核须要重用该缓存以便存放其它磁盘块数据时，再将该缓存排入输出队列。然后待其达到对首时。才进行实际的<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这样的输出方式就是延迟写。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">延迟写降低了磁盘读写次数，只是降低了文件内容的更新速度，是的欲写到文件里的数据在一段时间内并没有写到磁盘上。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">因此当系统发生问题时，这样的延迟可能造成文件更新内容的丢失。而对了防止这样的丢失，保证磁盘上实际文件系统与缓存中内容的一致性，<span style="line-height:1.8;font-family:Calibri;">UNIX</span>系统提供了<span style="line-height:1.8;font-family:Calibri;">sync</span>和<span style="line-height:1.8;font-family:Calibri;">fsync</span>两个系统调用函数。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">5</span>：<span style="line-height:1.8;font-family:Calibri;">exit()</span>和<span style="line-height:1.8;font-family:Calibri;">_exit()</span> </h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">_exit()</span>函数<span style="line-height:1.8;font-family:Calibri;">:</span>直接使进程停止执行<span style="line-height:1.8;font-family:Calibri;">,</span>清除其使用的内存空间<span style="line-height:1.8;font-family:Calibri;">,</span>并销毁其在内核中的各种数据结构<span style="line-height:1.8;font-family:Calibri;">;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">exit()</span>函数则在这些基础上作了一些包装<span style="line-height:1.8;font-family:Calibri;">,</span>在运行退出之前加了若干道工序。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">exit()</span>函数与<span style="line-height:1.8;font-family:Calibri;">_exit()</span>函数最大的差别就在于<span style="line-height:1.8;font-family:Calibri;">exit()</span>函数在调用<span style="line-height:1.8;font-family:Calibri;">&nbsp;exit&nbsp;</span>系统调用之前要检查文件的打开情况<span style="line-height:1.8;font-family:Calibri;">,</span>把文件缓冲区中的内容写回文件。在<span style="line-height:1.8;font-family:Calibri;">Linux</span>的标准函数库中。有一套称作<span style="line-height:1.8;font-family:Calibri;">“</span>高级<span style="line-height:1.8;font-family:Calibri;">I/O”</span>的函数，我们熟知<span style="line-height:1.8;font-family:Calibri;">&nbsp;printf()</span>、<span style="line-height:1.8;font-family:Calibri;">fopen()</span>、<span style="line-height:1.8;font-family:Calibri;">fread()</span>、<span style="line-height:1.8;font-family:Calibri;">fwrite()</span>都在此列，它们也被称作<span style="line-height:1.8;font-family:Calibri;">“</span>缓冲<span style="line-height:1.8;font-family:Calibri;">I/O</span>（<span style="line-height:1.8;font-family:Calibri;">bufferedI/O</span>）<span style="line-height:1.8;font-family:Calibri;">”</span>，其特征是相应每个打开的文件，在内存中都有一片缓冲区，每次读文件时，会多读出若干条记录，这样下次读文件时就能够直接从内存的缓冲区中读取。每次写文件的时候。也不过写入内存中的缓冲区，等满足了一定的条件（达到一定数量，或遇到特定字符，如换行符<span style="line-height:1.8;font-family:Calibri;">\n</span>和文件结束<span style="line-height:1.8;font-family:Calibri;">&nbsp;EOF</span>），再将缓冲区中的内容一次性写入文件，这样就大大添加了文件读写的速度，但也为我们编程带来了一点点麻烦。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">假设有一些数据。我们觉得已经写入了文件。实际上由于没有满足特定的条件，它们还仅仅是保存在缓冲区内，这时我们用<span style="line-height:1.8;font-family:Calibri;">_exit()</span>函数直接将进程关闭，缓冲区中的数据就会丢失。反之，假设想保证数据的完整性，就一定要使用<span style="line-height:1.8;font-family:Calibri;">exit()</span>函数。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在一个进程调用了<span style="line-height:1.8;font-family:Calibri;">exit</span>之后，该进程并不是立即就消失掉，而是留下一个称为僵尸进程（<span style="line-height:1.8;font-family:Calibri;">Zombie</span>）的数据结构。</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">6</span>：孤儿进程和僵死进程<span style="line-height:1.8;font-family:Calibri;">(</span>原<span style="line-height:1.8;font-family:Calibri;">+</span>摘<span style="line-height:1.8;font-family:Calibri;">)</span> </h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">孤儿进程：一个进程结束时，内核对全部的活动进程逐个检查，假设某个进程是该进程的子进程，则将其父进程的<span style="line-height:1.8;font-family:Calibri;">ID</span>更改为<span style="line-height:1.8;font-family:Calibri;">1.</span>这时这个进程就成为了孤儿进程。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">僵死进程：一个已经终止，可是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程成为僵死进程。（僵死进程差点儿放弃了全部的内存空间。没有不论什么可运行代码。不能被调用。只在进程列表中保留一个位置，记载该进程的退出状态等信息供其它进程收集，它须要其父进程为其收尸。）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">僵死进程的产生：我们知道，在每一个进程退出的时候，内核会释放进程的资源（如：打开的文件，占用的内存等）。可是仍会为其保留一些信息（进程<span style="line-height:1.8;font-family:Calibri;">ID</span>，退出状态，执行时间等），知道父进程通过<span style="line-height:1.8;font-family:Calibri;">wait/waitpid</span>获取后才释放。在此之前，该进程就一直处于僵死状态，该进程也就是僵死进程了。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">僵死进程的避免：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1、</span>&nbsp;&nbsp;<span style="line-height:1.8;">父进程通过<span style="line-height:1.8;font-family:Calibri;">wait</span>和<span style="line-height:1.8;font-family:Calibri;">waitpid</span>等函数等待子进程结束（但这会导致父进程挂起）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2、</span>&nbsp;&nbsp;<span style="line-height:1.8;">假设父进程没时间等待子进程结束。那么能够用<span style="line-height:1.8;font-family:Calibri;">signal</span>函数为<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>安装信号处理函数。这样子进程结束后。父进程会收到该信号，能够在信号处理函数中调用<span style="line-height:1.8;font-family:Calibri;">wait</span>回收。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3、</span>&nbsp;&nbsp;<span style="line-height:1.8;">假设父进程对于子进程什么时候结束根本不关心。那么能够用<span style="line-height:1.8;font-family:Calibri;">signal(SIGCHLD, SIG_IGN)</span>通知内核。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">这时。子进程结束后内核会对其进行回收。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">或者用<span style="line-height:1.8;font-family:Calibri;">sigaction</span>函数为<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>设置<span style="line-height:1.8;font-family:Calibri;">SA_NOCLDWAIT</span>，这样子进程结束后。就不会进入僵死状态。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;"><span style="line-height:1.8;font-family:Calibri;">struct sigaction sa;&nbsp;<br> &nbsp;sa.sa_handler = SIG_IGN;&nbsp;<br> &nbsp;sa.sa_flags = SA_NOCLDWAIT;&nbsp;<br> &nbsp;sigemptyset(&amp;sa.sa_mask);&nbsp;<br> &nbsp;sigaction(SIGCHLD, &amp;sa, NULL);</span></span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">4、</span>&nbsp;&nbsp;<span style="line-height:1.8;font-family:Calibri;">fork</span>两次：父进程<span style="line-height:1.8;font-family:Calibri;">fork</span>一个子进程，然后继续工作。子进程<span style="line-height:1.8;font-family:Calibri;">fork</span>一个孙进程后退出。那么孙进程被<span style="line-height:1.8;font-family:Calibri;">init</span>接管（这时孙进程就是孤儿进程）。孙进程结束后，<span style="line-height:1.8;font-family:Calibri;">init</span>会回收。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">只是注意子进程的回收还要父进程来做。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">注：一个进程假设被<span style="line-height:1.8;font-family:Calibri;">init</span>领养，那么它就不会再变成僵死进程，由于<span style="line-height:1.8;font-family:Calibri;">init</span>被编写为仅仅要有一个子进程终止，<span style="line-height:1.8;font-family:Calibri;">init</span>就会调用一个<span style="line-height:1.8;font-family:Calibri;">wait</span>函数取得其终止状态。这样就防止了系统中有非常多僵死进程。</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">7</span>：（不）可重入函数</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">首先我们先看看两者的定义。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">可重入函数：能够由多于一个任务并发使用，而不必操心数据错误。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">不可重入函数：不能由超过一个任务所共享。除非能确保函数的相互排斥（或者使用信号量，或者在代码的关键部分禁用中断）。对于不可重入函数。事实上现不保证函数在多线程环境下死正确的。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">看完定义来让我们看一个样例：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *get_buffer(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>定义一个缓冲区</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static char buf[100];</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">return buf;</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">}</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">void *thread1(void *params) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span>向上面定义的缓冲区中写数据</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf =get_buffer();</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">strcpy(buf, "string1");</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">}</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">void *thread2(void *params){ //</span>同楼上</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf = get_buffer();</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(buf,"string2");</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">}</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">上面的函数就是不可重入的。由于当<span style="line-height:1.8;font-family:Calibri;">2</span>个以上的线程都使用<span style="line-height:1.8;font-family:Calibri;">get_buffer</span>的返回值去訪问<span style="line-height:1.8;font-family:Calibri;">buf</span>缓冲区的时候，先向<span style="line-height:1.8;font-family:Calibri;">buf</span>写入的数据就可能被后写入的数据覆盖。<span style="line-height:1.8;font-family:Calibri;">Thread1</span>不能保证<span style="line-height:1.8;font-family:Calibri;">buf</span>的内容是“<span style="line-height:1.8;font-family:Calibri;">string1</span>”。而<span style="line-height:1.8;font-family:Calibri;">thread2</span>不能保证<span style="line-height:1.8;font-family:Calibri;">buf</span>的内容是“<span style="line-height:1.8;font-family:Calibri;">string2</span>”。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">附<span style="line-height:1.8;font-family:Cambria;">7.1&nbsp;</span>有哪些（不）可重入函数</span></h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">假设理解了什么是可重入和不可重入函数的话。那么都有哪些函数时可重入的呢？请看下图。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">没有在上表中的大多数函数是不可再入的，其原由于：它们<span style="line-height:1.8;color:#FF0000;">使用静态数据结构</span>。或它们<span style="line-height:1.8;color:#FF0000;">调用</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">malloc</span></span><span style="line-height:1.8;color:#FF0000;">或</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">free</span></span>。或它们<span style="line-height:1.8;color:#FF0000;">是标准</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">I/O</span></span><span style="line-height:1.8;color:#FF0000;">函数</span>（标准<span style="line-height:1.8;font-family:Calibri;">I/O</span>库的非常多实现都以不可再入方式使用全局数据结构）。</span></p> 
   <h2 style="line-height:1.5;font-size:21px;font-family:verdana, Arial, Helvetica, sans-serif;"><span style="line-height:1.8;font-size:24px;">附<span style="line-height:1.8;font-family:Cambria;">7.2&nbsp;</span>关于不可重入函数须要注意的地方</span></h2> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">我们须要知道：每一个进程仅仅有一个<span style="line-height:1.8;font-family:Calibri;">errno</span>变量。而这就伴随着一个问题，信号处理程序中即使调用上述列表的值，但最后的<span style="line-height:1.8;font-family:Calibri;">errno</span>却不一定是我们想要的。考虑下么的情况：有一个信号处理程序。它恰好在<span style="line-height:1.8;font-family:Calibri;">main</span>刚设置<span style="line-height:1.8;font-family:Calibri;">errno</span>之后调用。假设该信号处理程序调用<span style="line-height:1.8;font-family:Calibri;">read</span>，则它可能更改<span style="line-height:1.8;font-family:Calibri;">errno</span>的值从而代替了刚由<span style="line-height:1.8;font-family:Calibri;">main</span>设置的值（就拿<span style="line-height:1.8;font-family:Calibri;">SIGCHLD</span>信号来说，由于其信号处理程序要调用一种<span style="line-height:1.8;font-family:Calibri;">wait</span>函数，而各种<span style="line-height:1.8;font-family:Calibri;">wait</span>函数都能改变<span style="line-height:1.8;font-family:Calibri;">errno</span>）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">因此。作为一个通用规则，<span style="line-height:1.8;color:#FF0000;">当在信号处理程序中调用上表中列出的函数时，应当在其前保存</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">errno</span></span><span style="line-height:1.8;color:#FF0000;">。在其后恢复</span><span style="line-height:1.8;color:#FF0000;"><span style="line-height:1.8;font-family:Calibri;">errno</span></span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">那么在信号处理程序中调用一个不可重入函数会出现什么情况呢？</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">8</span>：信号未决和信号堵塞</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">当产生信号时，内核通常在进程表中设置某种形式的一个标志。当对信号做了这样的动作时，我们说向一个进程递送了一个信号。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">（即信号被处理）</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">而<span style="line-height:1.8;color:#FF0000;">信号未决就是在信号产生到递送之间的这段时间间隔</span>。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">关于信号堵塞：这里要注意一点，这里的堵塞不是堵塞其产生，而是说在信号产生后堵塞其发生作用（假设一个信号被堵塞了。那么在其被堵塞的这段时间也是信号未决）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这里顺便在说一点：假设在进程解除对某个信号的堵塞之前。这样的信号发生了多次。那么会怎样？<span style="line-height:1.8;font-family:Calibri;">POSIX.1</span>同意系统递送该信号一次或多次。假设递送该信号多次，则称这些信号排了队。可是大多数的<span style="line-height:1.8;font-family:Calibri;">UNIX</span>并不正确信号排队。代之以。<span style="line-height:1.8;font-family:Calibri;">UNIX</span>内核仅仅递送这样的信号一次。</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">9</span>：低俗系统调用和其它</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》的<span style="line-height:1.8;font-family:Calibri;">10.5</span>节<span style="line-height:1.8;font-family:Calibri;">(</span>中断的系统调用<span style="line-height:1.8;font-family:Calibri;">)</span>中将系统调用分为两类：低速系统调用和其它。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">关于“低速系统调用”我没有查找到其定义，在《<span style="line-height:1.8;font-family:Calibri;">APUE</span>》中对其的解释是：低速系统调用是可能会使进程永远堵塞的一类系统调用。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">以下是其情况：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">1，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">假设数据并不存在。则读文件可能会使调用者永远堵塞（比如堵管道。终端设备和网络设备）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">2，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">假设数据不能马上被接受，则写这些相同的文件也会使调用者永远堵塞。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">3，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">在某些条件发生之前，打开文件会被堵塞（比如打开一个终端设备可能需等到与之连接的调制解调器应答；又比如若仅仅以写方式打开<span style="line-height:1.8;font-family:Calibri;">FIFO</span>，那么在没有其它进程以用读方式打开<span style="line-height:1.8;font-family:Calibri;">FIFO</span>时也要等待）。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">4，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">对已经加上强制性记录锁的文件进行读、写。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">5。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">某些<span style="line-height:1.8;font-family:Calibri;">ioctl</span>操作。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">6，</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height:1.8;">某些进程间通信函数。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">有一点须要注意：非堵塞<span style="line-height:1.8;font-family:Calibri;">I/O</span>使我们能够调用不会永远堵塞的<span style="line-height:1.8;font-family:Calibri;">I/O</span>操作。比如<span style="line-height:1.8;font-family:Calibri;">open</span>、<span style="line-height:1.8;font-family:Calibri;">read</span>和<span style="line-height:1.8;font-family:Calibri;">write</span>。假设这样的操作不能完毕，则立马出错返回。表示该操作假设继续运行将继续堵塞下去。</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">10</span>：同步、异步<span style="line-height:1.8;font-family:Calibri;">;&nbsp;</span>堵塞、非堵塞</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这两组概念均涉及到<span style="line-height:1.8;font-family:Calibri;">IO</span>处理。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">首先我们先说同步、异步：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这两个概念均与<strong>消息的通知机制</strong>有关。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>首先我们说说我们的大学生活，大学中最让人印象深刻的事情之中的一个应该是吃饭，为什么这么说呢？应为在吃饭时我们会为自己去吃还是让别人带而苦恼。假设选择自己去吃，那么我们就得去食堂排队买饭。假设让别人带饭的话，那么我们就不用去排队。直到别人把饭带过来。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这时吃饭就相当于程序中消息触发后我们要做的动作，前者（排队买饭。买到饭了在開始吃<span style="line-height:1.8;font-family:Calibri;">----</span><strong>即排队等候</strong>）就是同步，后者（该干什么干什么。等别人带饭过来了在開始吃<span style="line-height:1.8;font-family:Calibri;">----</span><strong>即等待通知</strong>）就是异步。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">然后我们再说堵塞、非堵塞：</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>这两个概念均与<strong>程序等待消息时的状态</strong>有关（无所谓同步或异步）。<em></em></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>无论我们是排队买饭还是等别人带饭。假设在这个过程中除了等待外不能做其它事情，那么就是堵塞。反之，假设在等待的时候，我们做些其它事情，那么就是非堵塞。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">11</span>：强制性锁和建议性锁</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">这两个都和<span style="line-height:1.8;font-family:Calibri;">12.2</span>记录锁有关系。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">在说这个之前要说一个概念，合作进程。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">所谓合作进程是指：假设该库中的全部函数都以一致的方法处理记录锁。则称使用这些函数存取数据库的不论什么进程集为合作进程。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">什么叫一致的方法处理记录锁？举个样例：我有几个进程（不一定有亲缘关系）都通过<span style="line-height:1.8;font-family:Calibri;">fcntl</span>机制来操作文件。这就叫一致的方法。假设有一个进程，不使用<span style="line-height:1.8;font-family:Calibri;">fcntl</span>机制而是直接<span style="line-height:1.8;font-family:Calibri;">open</span>。<span style="line-height:1.8;font-family:Calibri;">write</span>文件，那这个进程和之前的进程就不是一致的方法。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">好了，回归正题。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">建议性锁的规定：每一个使用上锁文件的进程都要检查是否有锁存在，当然还得尊重已有的锁。和系统整体上都坚持不使用建议性锁，它们依靠程序猿遵守这个规定（<span style="line-height:1.8;font-family:Calibri;">Linux</span>默认是採用建议性锁）</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">强制性锁：由内核运行。</span></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">当文件被上锁来进行写入操作时，在锁定文件的进程释放该锁之前，内核会阻止不论什么对该文件的读或写訪问。每次读或写訪问都得检查锁是否存在。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">lock()</span>用于对文件施加建议性锁</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">fcntl()</span>用于对文件施加建议性锁和强制性锁都行。同一时候还能够对文件某一记录进行上锁。即记录锁。</p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p align="left" style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">附<span style="line-height:1.8;font-family:Calibri;">12</span>：协同进程（属于<span style="line-height:1.8;font-family:Calibri;">IPC</span>的知识）</h1> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:Calibri;">UNIX</span>过滤程序从标准输入读取数据，对其进行适当处理后写到标准输出。这几个过滤进程通常在<span style="line-height:1.8;font-family:Calibri;">shell</span>管道中线性的连接。</p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"></p> 
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;">而协同进程就是：假设一程序产生某个过滤程序的输入。同一时候又读取该过滤程序的输出时。那该过滤程序就成为协同进程。</span></p> 
   <br style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;">
   <p style="color:rgb(51,51,51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;"><span style="line-height:1.8;font-family:'宋体';">&nbsp;</span></p> 
   <h1 style="line-height:1.5;font-size:28px;font-family:verdana, Arial, Helvetica, sans-serif;">（<span style="line-height:1.8;font-family:Calibri;">FIFO</span>、<span style="line-height:1.8;font-family:Calibri;">SOCKET</span>的对照）</h1> 
   <div>
    <br>
   </div> 
   <div>
    <br>
   </div> 
   <div>
    <br>
   </div> 
   <div>
    <br>
   </div> 
   <div>
    <br>
   </div> 
   <div>
    本文转自mfrbuaa博客园博客，原文链接：http://www.cnblogs.com/mfrbuaa/p/4906882.html，如需转载请自行联系原作者
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
