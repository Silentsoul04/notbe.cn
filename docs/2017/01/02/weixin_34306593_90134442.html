<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[XMOVE自主设计的体感方案] XMove Studio管理系统（二）应用开发API简要介绍 « NotBeCN</title>
  <meta name="description" content="                  一. XMove的开放式应用开发框架简介     　　XMove4.0以开放式的结构满足扩展性的要求。所有无线协议，底层算法和控制逻辑全部上移到PC端。节点只根据接受的控制逻辑返回传感器数据。新的架构使得开发新应用非常方便。     　　本节将主要介绍XMove应用开发API及...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/01/02/weixin_34306593_90134442.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">[XMOVE自主设计的体感方案] XMove Studio管理系统（二）应用开发API简要介绍</h1>
    <p class="post-meta">Jan 2, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body"> 
    <h3>一. XMove的开放式应用开发框架简介</h3> 
    <p>　　XMove4.0以开放式的结构满足扩展性的要求。所有无线协议，底层算法和控制逻辑全部上移到PC端。节点只根据接受的控制逻辑返回传感器数据。新的架构使得开发新应用非常方便。</p> 
    <p>　　本节将主要介绍XMove应用开发API及其使用。</p> 
    <h2>二. 注册新应用　　</h2> 
    <p>　　我们将以开发“空中鼠标”应用为例，介绍开发应用的方法。</p> 
    <p>　　空中鼠标是通过陀螺仪传感器采集的旋转数据，传递给PC机，在空中旋转节点即可控制PC鼠标的功能。由于需要鼠标左右键，因此最低节点需求是含键盘的节点。</p> 
    <h3>　　1.环境搭建</h3> 
    <p>　　在VS中新建C#类库工程，引用XFrmWork.XMove.Interface 基类库的dll文件。该文件包含了XMove的核心基类和抽象逻辑。若您曾经做过这步，可以跳过。添加功能时仅需在该工程中添加新的类即可。</p> 
    <p>　　注意，需将该工程的dll输出路径修改为XMove应用插件文件夹XMovePlugin。这样就可以不用手动拷贝了。</p> 
    <h3>　　2. 继承基类</h3> 
    <p>　　XMove应用基类是AbstractApp，它提供基础的服务和接口。新应用从AbstractApp继承。</p> 
    <div class="cnblogs_Highlighter"> 
     <div class="syntaxhighlighter nogutter csharp"> 
      <div class="toolbar">
       <a class="toolbar_item command_help help" href="http://www.cnblogs.com/buptzym/archive/2012/07/14/2591097.html#" rel="nofollow">?</a>
      </div> 
      <table border="0">
       <tbody>
        <tr>
         <td class="code"> 
          <div> 
           <div class="line number1 index0 alt2"> 
            <code class="csharp plain">[XFrmWorkAttribute(</code>
            <code class="csharp string">"空中鼠标"</code>
            <code class="csharp plain">, </code>
            <code class="csharp string">"IProgramWPF"</code>
            <code class="csharp plain">, </code>
            <code class="csharp string">"利用陀螺仪实现的空中鼠标系统"</code>
            <code class="csharp plain">, </code>
            <code class="csharp string">"/XFrmWork.XMove.Program;component/Images/空中鼠标.jpg"</code>
            <code class="csharp plain">)]</code> 
           </div> 
           <div class="line number2 index1 alt1"> 
            <code class="csharp keyword">public</code> 
            <code class="csharp keyword">class</code> 
            <code class="csharp plain">SkyMouse : AbstractApp</code> 
           </div> 
           <div class="line number3 index2 alt2">
            <code class="csharp plain">{</code>
           </div> 
           <div class="line number4 index3 alt1"> 
            <code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>
            <code class="csharp comments">//在此处添加代码逻辑</code> 
           </div> 
           <div class="line number5 index4 alt2">
            <code class="csharp plain">}</code>
           </div> 
          </div> </td>
        </tr>
       </tbody>
      </table>
     </div> 
    </div> 
    <p>　　为了能被XFrmWork插件搜索器搜索到，需要添加XFrmWorkAttribute插件标记。四个参数分别是： APP名称，接口约束（应用固定为IProgramWPF）， 说明介绍，和图片资源地址（方便主框架显示应用Logo）、</p> 
    <h3>　　3. 查看效果</h3> 
    <p>　　生成工程，运行XMove主程序，如下图所示，XFrmWork已经成功加载该应用。</p> 
    <p><img style="margin-left:auto;" alt="" src="https://pic002.cnblogs.com/images/2012/287060/2012071408482395.jpg"></p> 
    <p>　</p> 
    <h2>三.节点映射和配置节点工作状态</h2> 
    <h3>　1. 节点映射配置</h3> 
    <p>　　　要想获取节点传递来的信息，首先要配置应用程序节点映射。节点映射一般在默认情况下给出映射到哪个节点组的哪个节点，并给出其名称和最低节点功能需求。</p> 
    <p>　　在应用程序启动时，首先尝试读取硬盘中存储的节点映射表，否则尝试重建默认映射表。因此必须重写重建函数：</p> 
    <p>　　</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre>   <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">void</span> RebuildNodeRelation()
        {
            myProgramRoutedNode = <span style="color:#0000ff;">new</span> NodeRoutedCollection();
            myProgramRoutedNode.Add(<span style="color:#0000ff;">new</span> ProgramNodeRegeistration()
            {
                Name = <span style="color:#800000;">"</span><span style="color:#800000;">手持设备</span><span style="color:#800000;">"</span>,
                GroupID = <span style="color:#800080;">0</span>,
                SelectedID = NodeID.LeftHandNode,
                MinRequiredNodeType= XMoveStaticsHelper.QueryAbstractNodeString(<span style="color:#0000ff;">typeof</span>(XNodeHID))});
        }</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>　　如上案例所示，只增加一个节点，名称是手持设备，默认组别为0，组内ID是左手节点。最低要求是XNodeHID(包含键盘的MEMS节点)</p> 
    <p>　　若您允许用户在应用中修改映射表的表项数量，需要重写以下属性：</p> 
    <p>　　由于空中鼠标只需一个节点，因此不需要改变节点映射项数量,return false. 默认是return false的。此时，用户在运行时修改数量的按钮将不可用。</p> 
    <div class="cnblogs_code">
     <pre>        <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> isMountChangedeable
        {
            <span style="color:#0000ff;">get</span> { <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">false</span>; }
        }</pre>
    </div> 
    <p>&nbsp;</p> 
    <p>　　　基类已经将从外部读取映射表，和结束程序时存储映射表的功能实现，作为开发者的您可以不关心这些问题。您只需关心重建函数和isMountChangedeable属性。</p> 
    <h3>　　2. 配置节点工作状态</h3> 
    <p>　　为了尽可能降低节点工作功耗，应该给出应用程序所需的节点刷新速率，是否需要陀螺仪等属性。节点工作状态的描述类为：</p> 
    <p><img style="margin-left:auto;" alt="" src="https://pic002.cnblogs.com/images/2012/287060/2012071412494848.jpg"></p> 
    <p>　　其中NodeWorkMode类描述了节点当前的工作状态，而NodeControlledWorkMode类从NodeWorkMode继承，描述当前对该节点所有工作状态需求的汇总。</p> 
    <p>　　NodeControlledWorkMode类会自动汇总所有应用对该节点需求，求出能满足所有应用的最低需求。从而在应用发生改变时，控制节点切换到相应模式。</p> 
    <div class="cnblogs_code">
     <pre>  <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">void</span> ConfigNodeWorkMode()
        {
            LeftHandXNodeHID.neededWorkMode.SetWorkMode(<span style="color:#0000ff;">this</span>,<span style="color:#0000ff;">true</span>, NodeFreshSpeed.一秒32次);
        }</pre>
    </div> 
    <p>&nbsp;</p> 
    <p>　　其中函数的定义为：</p> 
    <div class="cnblogs_code">
     <pre>   <span style="color:#0000ff;">public</span>  <span style="color:#0000ff;">void</span> SetWorkMode(IProgramWPF program,<span style="color:#0000ff;">bool</span> gyroEnable, NodeFreshSpeed speed)
        {
            myNeededList.Add(program, <span style="color:#0000ff;">new</span> Tuple&lt;<span style="color:#0000ff;">bool</span>, NodeFreshSpeed&gt;(gyroEnable, speed));
            RefreshData();
        }</pre>
    </div> 
    <p>&nbsp;</p> 
    <p>　　参数分别为该程序的引用，是否能开启陀螺仪和刷新速度。 &nbsp;由于陀螺仪是传感器中的耗电大户，因此应该在不需要的情形下尽可能关闭之。</p> 
    <h2>四.获取传感器数据</h2> 
    <p>　　应用一般有两种类型:</p> 
    <ul>
     <li>　　隔一段时间获取传感器数据，实现刷新，但并不关心数据是否是最新的</li> 
     <li>只有当新数据到来时才会触发应用事件。</li> 
    </ul>
    <p>　　　我们分别将将它们称作定时器型应用和事件型应用。对于空中鼠标而言，应属于事件型应用。</p> 
    <p>　　首先必须获得映射表定义的节点的引用：</p> 
    <div class="cnblogs_code">
     <pre>     LeftHandXNodeHID = XNodeGroupManager.Instance[myProgramRoutedNode[<span style="color:#800080;">0</span>]] <span style="color:#0000ff;">as</span> XNodeHID;</pre>
    </div> 
    <p>　　XNodeGroupManager是节点管理器类，通过单例模式提供方便的访问权限，索引器中，可以按上述格式，获取节点引用。</p> 
    <h3>　1. 定时器型应用</h3> 
    <p>　　定时器型应用不关心数据是否是最新的，但需要稳定的定时实现刷新。要想实现定时刷新，需要重写以下字段：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre>   <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">int</span> ProcessPerSecond
        {
            <span style="color:#0000ff;">get</span>
            {
                <span style="color:#0000ff;">return</span> <span style="color:#800080;">25</span>;
            }
        }
      </pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
    <p>　　应用程序管理器会为重写该字段的每个应用提供定时器支持，在点击开启按钮后，会自动启动定时器，按下停止后关闭。应用程序可不关心其具体实现。</p> 
    <p>　　至于在定时到来时要处理的逻辑，可以通过重写DataProcess()函数：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre> <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> DataProcess()
        {
    
                VirtualKey.VKMouse(<span style="color:#800080;">1</span>, (<span style="color:#0000ff;">int</span>)(-LeftHandXNodeHID.GyroZ / <span style="color:#800080;">20</span>), (<span style="color:#0000ff;">int</span>)(LeftHandXNodeHID.GyroY / <span style="color:#800080;">20</span>), <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>);
            <span style="color:#0000ff;">switch</span> (LeftHandXNodeHID.thisKeyChanged)
            {
                <span style="color:#0000ff;">case</span> KeyBoardChanged.KEYUP_DOWN:  <span style="color:#008000;">//</span><span style="color:#008000;">左键</span>

                    VirtualKey.VKMouse(<span style="color:#800080;">0x0002</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>);  <span style="color:#008000;">//</span><span style="color:#008000;">按下</span>

                    <span style="color:#0000ff;">break</span>;
                <span style="color:#0000ff;">case</span> KeyBoardChanged.KEYUP_UP:
                    VirtualKey.VKMouse(<span style="color:#800080;">0x0004</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>);  <span style="color:#008000;">//</span><span style="color:#008000;">弹起</span>
                    <span style="color:#0000ff;">break</span>;

                <span style="color:#0000ff;">case</span> KeyBoardChanged.KEYDOWN_DOWN:  <span style="color:#008000;">//</span><span style="color:#008000;">右键</span>

                    VirtualKey.VKMouse(<span style="color:#800080;">0x0008</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>);  <span style="color:#008000;">//</span><span style="color:#008000;">按下</span>

                    <span style="color:#0000ff;">break</span>;
                <span style="color:#0000ff;">case</span> KeyBoardChanged.KEYDOWN_UP:  <span style="color:#008000;">//</span><span style="color:#008000;">右键</span>
                    VirtualKey.VKMouse(<span style="color:#800080;">0x0010</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>);  <span style="color:#008000;">//</span><span style="color:#008000;">弹起</span>
                    <span style="color:#0000ff;">break</span>;
                <span style="color:#0000ff;">case</span> KeyBoardChanged.KEYLEFT_DOWN:  <span style="color:#008000;">//</span><span style="color:#008000;">滚轮移动</span>
                    VirtualKey.VKMouse(<span style="color:#800080;">0x0800</span>, <span style="color:#800080;">0</span>, <span style="color:#800080;">0</span>, -(<span style="color:#0000ff;">int</span>)(LeftHandXNodeHID.GyroX), <span style="color:#800080;">0</span>);  <span style="color:#008000;">//
</span>                    <span style="color:#0000ff;">break</span>;
　　　　}
                <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">true</span>;
             
        }</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
    <p>&nbsp; &nbsp; 值得注意的是，LeftHandXNodeHID是该类的节点引用持有者。这样，系统会在每隔1/25秒执行该函数。</p> 
    <h3>　2. 事件型应用</h3> 
    <p>　　 另外一种类型是事件型应用，它对处理性能的要求更低，也更灵活。应用应该通过事件的方式订阅节点管理器发出的通知：如节点获取新数据，建立新连接或断开连接等。</p> 
    <p>　　要想配置成事件型应用，您需要将ProcessPerSecond属性中返回值改为0，这样系统就不会提供定时器了。</p> 
    <p>　　对于空中鼠标应用，可以只关心节点传递来的新数据通知。在开启时，需要将处理方法挂接在该事件上，如下程序所示：</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre>   <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> InitProcess()
        {

          
            LeftHandXNodeHID = XNodeGroupManager.Instance[myProgramRoutedNode[<span style="color:#800080;">0</span>]] <span style="color:#0000ff;">as</span> XNodeHID;
            LeftHandXNodeHID.OnXNodeEvent += LeftHandXNodeHID_OnProgramEvent;
            //除此之外，您可以添加其他初始化的函数
            <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">true</span>;
        }</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
    <p>　　关闭应用时，将该事件取消挂接：　　</p> 
    <div class="cnblogs_code">
     <pre>  <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> CloseProcess()
        {
            LeftHandXNodeHID.OnXNodeEvent -= LeftHandXNodeHID_OnProgramEvent;
            <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">true</span>;
        }</pre>
    </div> 
    <p>　　LeftHandXNodeHID_OnProgramEvent是处理事件，其功能与上述DataProcess()描述完全一致，此处从略。</p> 
    <h3>　　3. 混合型应用</h3> 
    <p>　　若您同时需要定时器和事件，可以将ProcessPerSecond设置成需要的值，同时挂载事件，与1,2描述一致，此处从略。</p> 
    <h2>五. 开发有UI控件的应用</h2> 
    <p>　　在很多情形下，您可能需要开发带UI控件的应用。此时的开发要比一般情形复杂。具体实现方法和您的具体设计有关。目前仅提供WPF内置的UserControl控件的支持。</p> 
    <h3>　　1. 使用MVVM结构开发</h3> 
    <p>　　若您对MVVM结构很熟悉，则推荐采用这种开发方式，此时，需要让您开发的类实现IView接口：</p> 
    <p>　　我们假设您对MVVM模式已经很熟悉，需要另外设计ViewModel，该类中是DynIdentityTrainnerUI， 在构造函数中，实现数据上下文绑定。</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre>   <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> DynIdentityTrainner : AbstractApp, IView
    {
      DynIdentityTrainner()
{
 myDynIdentityTrainnerUI.DataContext = <span style="color:#0000ff;">this</span>;   <span style="color:#008000;">//</span><span style="color:#008000;">实现绑定</span>
}

  DynIdentityTrainnerUI myDynIdentityTrainnerUI = <span style="color:#0000ff;">new</span> DynIdentityTrainnerUI();
        <span style="color:#0000ff;">public</span> UserControl thisUserControl  //IView接口成员：返回要显示的UI控件
        {
            <span style="color:#0000ff;">get</span> { <span style="color:#0000ff;">return</span> myDynIdentityTrainnerUI; }
        }

        <span style="color:#0000ff;">public</span> FrmState thisFrmState  //IView接口成员：返回要放置的位置
        {
            <span style="color:#0000ff;">get</span> { <span style="color:#0000ff;">return</span> FrmState.Large; }  
        }
}</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>&nbsp;</p> 
    <h3>　　2. 不使用MVVM开发</h3> 
    <p>　　若您对MVVM不熟悉，通常的解决办法是从UserControl类继承。但是C#只支持单继承，通常的办法是实现XMove基本应用的所有接口，这对于开发者是不合适的，因此我提供了一个UI类，解决了这一问题：　　</p> 
    <div class="cnblogs_code">
     <pre> <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">class</span> AbstractUIApp : UserControl, IProgramWPF, IProgramNodeChangeable, IView, IRelationComputeable
    {
     <span style="color:#008000;">//</span><span style="color:#008000;">实现代码</span>
    }</pre>
    </div> 
    <p>&nbsp;</p> 
    <p>　　在开发时，您需要从AbstractUIApp类继承，此时可获得界面设计器的支持，其他的开发方式和上述一致，此处不赘述。</p> 
    <h2>六. 其他注意点</h2> 
    <h3>　　1.可能要重写的其他函数</h3> 
    <p>　　除了以上可能要修改的属性和重写函数外，还有两个函数可能需要重写：</p> 
    <p>　 &nbsp; &nbsp;LoadMainResource函数在用户将其拖到应用列表时执行，若加载大型资源时必须重写该函数，而不是定义在InitProcess函数中，因为用户随时都可能开启或关闭程序，不应该在此函数中过分耗时。</p> 
    <p>　　例如空中鼠标，它需要在第一次初始化时加载SVM识别模型。用于手势识别。</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre> <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> LoadMainResource()
        {
             mySVMMethod = <span style="color:#0000ff;">new</span> SVMMethod();
            mySVMMethod.LoadSVMModel(PublicName);

            <span style="color:#0000ff;">return</span> <span style="color:#0000ff;">true</span>;
        }</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>&nbsp; &nbsp;除此之外，还有对应的释放函数。和初始化需要的注意点一致：</p> 
    <p>　　</p> 
    <div class="cnblogs_code">
     <pre> <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">override</span> <span style="color:#0000ff;">bool</span> ReleaseMainResource()
        {
            <span style="color:#008000;">//</span><span style="color:#008000;">释放所需的非托管资源</span>
        }</pre>
    </div> 
    <h3>&nbsp; &nbsp;2. 两个辅助外部管理器</h3> 
    <p>　　一些管理型应用，不仅需要获取节点的数据，还需要知悉整个系统的工作状态，此时就需要获得一些扩展功能。</p> 
    <p>　　系统提供在基类中提供了两个服务者，解决了以上问题：　　</p> 
    <div class="cnblogs_code">
     <pre>    <span style="color:#0000ff;">public</span> AbstractCommManager thisCommManager { <span style="color:#0000ff;">get</span>; <span style="color:#0000ff;">set</span>; }
        
     <span style="color:#0000ff;">public</span> IProgramManager thisProgramManager { <span style="color:#0000ff;">get</span>; <span style="color:#0000ff;">set</span>; }</pre>
    </div> 
    <p>&nbsp; &nbsp; &nbsp; 分别是通信管理器接口和程序管理器接口，它封装了和限制了应用对管理器的控制权限，提供了可读的一些有用信息。</p> 
    <p>　　例如，在thisProgramManager的帮助下，应用可以开启或关闭另外一个应用，可以在界面上添加或删除新的UI组件，</p> 
    <div class="cnblogs_code"> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
     <pre>  <span style="color:#808080;">///</span> <span style="color:#808080;">&lt;summary&gt;</span>
   <span style="color:#808080;">///</span><span style="color:#008000;"> 应用程序管理器
   </span><span style="color:#808080;">///</span> <span style="color:#808080;">&lt;/summary&gt;</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">interface</span> IProgramManager
    {
        <span style="color:#0000ff;">bool</span> BeginOneProcess(IProgramWPF rc);
        <span style="color:#0000ff;">bool</span> StopOneProcess(IProgramWPF rc);
        <span style="color:#0000ff;">void</span> AddUserControl(UserControl value, FrmState thisState, <span style="color:#0000ff;">string</span> title);
        <span style="color:#0000ff;">void</span> RemoveUserControl(UserControl value);
        IEnumerable&lt;NodeEnumKeyPair&gt; GetAllEnumerable { <span style="color:#0000ff;">get</span>; }
        IEnumerable&lt;IProgramWPF&gt; GetActivePrograms { <span style="color:#0000ff;">get</span>; }
    }</pre> 
     <div class="cnblogs_code_toolbar">
      <span class="cnblogs_code_copy"><img alt="复制代码" src="http://common.cnblogs.com/images/copycode.gif"></span>
     </div> 
    </div> 
    <p>&nbsp; &nbsp; &nbsp;与其类似的是，可以开启或关闭通信方法，或获取已开启通信方法的枚举等。</p> 
    <h3>　　3. 安全性</h3> 
    <p>　　由于系统使用和开发环境都是基于专业用户的，因此以开放的精神，API提供的接口的权限都达到甚至超过了实际应用的最大需求。在开发应用时，您应该考虑只读取数据，而不非法写入或修改核心状态数据，这可能会导致系统崩溃或出现不可预见的问题。</p> 
    <h3>　　4. 其他API</h3> 
    <p>　　XMove开发环境内置了XFrmWork的全部功能集合，同时有.NET FrameWork作为支持，您所需的大部分函数和功能类都可以在其中找到，这包括网络通信，数据库，图形UI等。您可以参考详细开发文档，此处不进行详细描述。</p> 
    <h3>　　5.发布</h3> 
    <p>　　您可以将您的工程编译为dll，提供给用户。在目前框架下，无法实现自动升级，因此需要手动拷贝。未来框架会加入自动升级功能。</p> 
    <h2>七. 总结</h2> 
    <p>　　本文较详细的介绍了在XMove框架下开发新应用的方法和注意事项。目前XMove框架已经支持多达20多种应用，涉及节点管理，人机交互，虚拟现实等应用，我会在后续文章中继续介绍。　　</p> 
    <p>　　若您感兴趣，欢迎联系我 &nbsp;<a href="mailto:buptzym@bupt.edu.cn" rel="nofollow">buptzym@bupt.edu.cn</a></p> 
    <p>　　</p> 
    <p>&nbsp;</p> 
   </div> 
   <div> 
    <div> 
     <p style="border-top:#e0e0e0 1px dashed;border-right:#e0e0e0 1px dashed;border-bottom:#e0e0e0 1px dashed;border-left:#e0e0e0 1px dashed;background:#e5f1f4 url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) no-repeat 1% 50%;font-family:'微软雅黑';font-size:11px;"><br> 作者：<a href="http://www.cnblogs.com/buptzym/" rel="nofollow">热情的沙漠</a> <br> 出处：<a href="http://www.cnblogs.com/buptzym/" rel="nofollow">http://www.cnblogs.com/buptzym/</a> <br> 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 <br></p> 
    </div> 
   </div> 
   <div class="clear"></div> 
   <div> 
    <div></div> 
    <div>
     标签: 
     <a href="http://www.cnblogs.com/buptzym/tag/XMove/" rel="nofollow">XMove</a>, 
     <a href="http://www.cnblogs.com/buptzym/tag/.NET/" rel="nofollow">.NET</a> 
    </div> 
    <div>
     <br>
    </div> 
    <div>
     本文转自FerventDesert博客园博客，原文链接：http://www.cnblogs.com/buptzym/archive/2012/07/14/2591097.html，如需转载请自行联系原作者
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
