<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>排序算法小结 « NotBeCN</title>
  <meta name="description" content="                  排序算法是一种基本并且常用的算法。由于实际工作中处理的数量巨大，所以排序算法对算法本身的速度要求很高。 &nbsp;&nbsp;&nbsp; 而一般我们所谓的算法的性能主要是指算法的复杂度，一般用O方法来表示。在后面我将给出详细的说明。&nbsp; &nbsp;&nbsp;&n...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2017/02/27/weixin_33895016_90118781.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">排序算法小结</h1>
    <p class="post-meta">Feb 27, 2017</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body" style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;"> 
    <p>排序算法是一种基本并且常用的算法。由于实际工作中处理的数量巨大，所以排序算法对算法本身的速度要求很高。<br> &nbsp;&nbsp;&nbsp; 而一般我们所谓的算法的性能主要是指算法的复杂度，一般用O方法来表示。在后面我将给出详细的说明。&nbsp;<br> &nbsp;&nbsp;&nbsp; 对于排序的算法我想先做一点简单的介绍，也是给这篇文章理一个提纲。<br> &nbsp;&nbsp;&nbsp; 我将按照算法的复杂度，从简单到难来分析算法。<br> &nbsp;&nbsp;&nbsp; 第一部分是简单排序算法，后面你将看到他们的共同点是算法复杂度为O(N*N)（因为没有使用word,所以无法打出上标和下标）。<br> &nbsp;&nbsp;&nbsp; 第二部分是高级排序算法，复杂度为O(Log2(N))。这里我们只介绍一种算法。另外还有几种算法因为涉及树与堆的概念，所以这里不于讨论。<br> &nbsp;&nbsp;&nbsp; 第三部分类似动脑筋。这里的两种算法并不是最好的（甚至有最慢的），但是算法本身比较奇特，值得参考（编程的角度）。同时也可以让我们从另外的角度来认识这个问题。<br> &nbsp;&nbsp;&nbsp; 第四部分是我送给大家的一个餐后的甜点——一个基于模板的通用快速排序。由于是模板函数可以对任何数据类型排序（抱歉，里面使用了一些论坛专家的呢称）。<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; 现在，让我们开始吧：<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> 一、简单排序算法<br> 由于程序比较简单，所以没有加什么注释。所有的程序都给出了完整的运行代码，并在我的VC环境<br> 下运行通过。因为没有涉及MFC和WINDOWS的内容，所以在BORLAND C++的平台上应该也不会有什么<br> 问题的。在代码的后面给出了运行过程示意，希望对理解有帮助。<br> 1.冒泡法：<br> 这是最原始，也是众所周知的最慢的算法了。他的名字的由来因为它的工作看来象是冒泡：<br> #include &lt;iostream.h&gt;<br> void BubbleSort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; int iTemp;<br> &nbsp;&nbsp;&nbsp; for(int i=1;i&lt;Count;i++)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=Count-1;j&gt;=i;j--)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pData[j]&lt;pData[j-1])<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[j-1];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[j-1] = pData[j];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[j] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4};<br> &nbsp;&nbsp;&nbsp; BubbleSort(data,7);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;7;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 倒序(最糟情况)<br> 第一轮：10,9,8,7-&gt;10,9,7,8-&gt;10,7,9,8-&gt;7,10,9,8(交换3次)<br> 第二轮：7,10,9,8-&gt;7,10,8,9-&gt;7,8,10,9(交换2次)<br> 第一轮：7,8,10,9-&gt;7,8,9,10(交换1次)<br> 循环次数：6次<br> 交换次数：6次<br> 其他：<br> 第一轮：8,10,7,9-&gt;8,10,7,9-&gt;8,7,10,9-&gt;7,8,10,9(交换2次)<br> 第二轮：7,8,10,9-&gt;7,8,10,9-&gt;7,8,10,9(交换0次)<br> 第一轮：7,8,10,9-&gt;7,8,9,10(交换1次)<br> 循环次数：6次<br> 交换次数：3次<br> 上面我们给出了程序段，现在我们分析它：这里，影响我们算法性能的主要部分是循环和交换，<br> 显然，次数越多，性能就越差。从上面的程序我们可以看出循环的次数是固定的，为1+2+...+n-1。<br> 写成公式就是1/2*(n-1)*n。<br> 现在注意，我们给出O方法的定义：<br> &nbsp;&nbsp;&nbsp; 若存在一常量K和起点n0，使当n&gt;=n0时，有f(n)&lt;=K*g(n),则f(n) = O(g(n))。（呵呵，不要说没<br> 学好数学呀，对于编程数学是非常重要的！！！）<br> 现在我们来看1/2*(n-1)*n，当K=1/2，n0=1，g(n)=n*n时，1/2*(n-1)*n&lt;=1/2*n*n=K*g(n)。所以f(n)<br> =O(g(n))=O(n*n)。所以我们程序循环的复杂度为O(n*n)。<br> &nbsp;&nbsp;&nbsp; 再看交换。从程序后面所跟的表可以看到，两种情况的循环相同，交换不同。其实交换本身同数据源的有序程度有极大的关系，当数据处于倒序的情况时，交换次数同循环一样（每次循环判断都会交换），复杂度为O(n*n)。当数据为正序，将不会有交换。复杂度为O(0)。乱序时处于中间状态。正是由于这样的原因，我们通常都是通过循环次数来对比算法。</p> 
    <p>2.交换法：<br> 交换法的程序最清晰简单，每次用当前的元素一一的同其后的元素比较并交换。<br> #include &lt;iostream.h&gt;<br> void ExchangeSort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; int iTemp;<br> &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;Count-1;i++)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=i+1;j&lt;Count;j++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pData[j]&lt;pData[i])<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i] = pData[j];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[j] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4};<br> &nbsp;&nbsp;&nbsp; ExchangeSort(data,7);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;7;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 倒序(最糟情况)<br> 第一轮：10,9,8,7-&gt;9,10,8,7-&gt;8,10,9,7-&gt;7,10,9,8(交换3次)<br> 第二轮：7,10,9,8-&gt;7,9,10,8-&gt;7,8,10,9(交换2次)<br> 第一轮：7,8,10,9-&gt;7,8,9,10(交换1次)<br> 循环次数：6次<br> 交换次数：6次<br> 其他：<br> 第一轮：8,10,7,9-&gt;8,10,7,9-&gt;7,10,8,9-&gt;7,10,8,9(交换1次)<br> 第二轮：7,10,8,9-&gt;7,8,10,9-&gt;7,8,10,9(交换1次)<br> 第一轮：7,8,10,9-&gt;7,8,9,10(交换1次)<br> 循环次数：6次<br> 交换次数：3次<br> 从运行的表格来看，交换几乎和冒泡一样糟。事实确实如此。循环次数和冒泡一样也是1/2*(n-1)*n，所以算法的复杂度仍然是O(n*n)。由于我们无法给出所有的情况，所以只能直接告诉大家他们在交换上面也是一样的糟糕（在某些情况下稍好，在某些情况下稍差）。<br> 3.选择法：<br> 现在我们终于可以看到一点希望：选择法，这种方法提高了一点性能（某些情况下）这种方法类似我们人为的排序习惯：从数据中选择最小的同第一个值交换，在从省下的部分中选择最小的与第二个交换，这样往复下去。<br> #include &lt;iostream.h&gt;<br> void SelectSort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; int iTemp;<br> &nbsp;&nbsp;&nbsp; int iPos;<br> &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;Count-1;i++)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPos = i;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=i+1;j&lt;Count;j++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pData[j]&lt;iTemp)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[j];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPos = j;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[iPos] = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i] = iTemp;<br> &nbsp;&nbsp;&nbsp; }<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4};<br> &nbsp;&nbsp;&nbsp; SelectSort(data,7);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;7;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 倒序(最糟情况)<br> 第一轮：10,9,8,7-&gt;(iTemp=9)10,9,8,7-&gt;(iTemp=8)10,9,8,7-&gt;(iTemp=7)7,9,8,10(交换1次)<br> 第二轮：7,9,8,10-&gt;7,9,8,10(iTemp=8)-&gt;(iTemp=8)7,8,9,10(交换1次)<br> 第一轮：7,8,9,10-&gt;(iTemp=9)7,8,9,10(交换0次)<br> 循环次数：6次<br> 交换次数：2次<br> 其他：<br> 第一轮：8,10,7,9-&gt;(iTemp=8)8,10,7,9-&gt;(iTemp=7)8,10,7,9-&gt;(iTemp=7)7,10,8,9(交换1次)<br> 第二轮：7,10,8,9-&gt;(iTemp=8)7,10,8,9-&gt;(iTemp=8)7,8,10,9(交换1次)<br> 第一轮：7,8,10,9-&gt;(iTemp=9)7,8,9,10(交换1次)<br> 循环次数：6次<br> 交换次数：3次<br> 遗憾的是算法需要的循环次数依然是1/2*(n-1)*n。所以算法复杂度为O(n*n)。<br> 我们来看他的交换。由于每次外层循环只产生一次交换（只有一个最小值）。所以f(n)&lt;=n<br> 所以我们有f(n)=O(n)。所以，在数据较乱的时候，可以减少一定的交换次数。</p> 
    <p>4.插入法：<br> 插入法较为复杂，它的基本工作原理是抽出牌，在前面的牌中寻找相应的位置插入，然后继续下一张<br> #include &lt;iostream.h&gt;<br> void InsertSort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; int iTemp;<br> &nbsp;&nbsp;&nbsp; int iPos;<br> &nbsp;&nbsp;&nbsp; for(int i=1;i&lt;Count;i++)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPos = i-1;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((iPos&gt;=0) &amp;&amp; (iTemp&lt;pData[iPos]))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[iPos+1] = pData[iPos];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iPos--;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[iPos+1] = iTemp;<br> &nbsp;&nbsp;&nbsp; }<br> }</p> 
    <p>void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4};<br> &nbsp;&nbsp;&nbsp; InsertSort(data,7);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;7;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 倒序(最糟情况)<br> 第一轮：10,9,8,7-&gt;9,10,8,7(交换1次)(循环1次)<br> 第二轮：9,10,8,7-&gt;8,9,10,7(交换1次)(循环2次)<br> 第一轮：8,9,10,7-&gt;7,8,9,10(交换1次)(循环3次)<br> 循环次数：6次<br> 交换次数：3次<br> 其他：<br> 第一轮：8,10,7,9-&gt;8,10,7,9(交换0次)(循环1次)<br> 第二轮：8,10,7,9-&gt;7,8,10,9(交换1次)(循环2次)<br> 第一轮：7,8,10,9-&gt;7,8,9,10(交换1次)(循环1次)<br> 循环次数：4次<br> 交换次数：2次<br> 上面结尾的行为分析事实上造成了一种假象，让我们认为这种算法是简单算法中最好的，其实不是，<br> 因为其循环次数虽然并不固定，我们仍可以使用O方法。从上面的结果可以看出，循环的次数f(n)&lt;=<br> 1/2*n*(n-1)&lt;=1/2*n*n。所以其复杂度仍为O(n*n)（这里说明一下，其实如果不是为了展示这些简单<br> 排序的不同，交换次数仍然可以这样推导）。现在看交换，从外观上看，交换次数是O(n)（推导类似<br> 选择法），但我们每次要进行与内层循环相同次数的‘=’操作。正常的一次交换我们需要三次‘=’<br> 而这里显然多了一些，所以我们浪费了时间。<br> 最终，我个人认为，在简单排序算法中，选择法是最好的。</p> 
    <p>二、高级排序算法：<br> 高级排序算法中我们将只介绍这一种，同时也是目前我所知道（我看过的资料中）的最快的。<br> 它的工作看起来仍然象一个二叉树。首先我们选择一个中间值middle程序中我们使用数组中间值，然后<br> 把比它小的放在左边，大的放在右边（具体的实现是从两边找，找到一对后交换）。然后对两边分别使<br> 用这个过程（最容易的方法——递归）。<br> 1.快速排序：<br> #include &lt;iostream.h&gt;<br> void run(int* pData,int left,int right)<br> {<br> &nbsp;&nbsp;&nbsp; int i,j;<br> &nbsp;&nbsp;&nbsp; int middle,iTemp;<br> &nbsp;&nbsp;&nbsp; i = left;<br> &nbsp;&nbsp;&nbsp; j = right;<br> &nbsp;&nbsp;&nbsp; middle = pData[(left+right)/2];&nbsp; //求中间值<br> &nbsp;&nbsp;&nbsp; do{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((pData[i]&lt;middle) &amp;&amp; (i&lt;right))//从左扫描大于中值的数<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((pData[j]&gt;middle) &amp;&amp; (j&gt;left))//从右扫描大于中值的数<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j--;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(i&lt;=j)//找到了一对值<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //交换<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i] = pData[j];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[j] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j--;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }while(i&lt;=j);//如果两边扫描的下标交错，就停止（完成一次）<br> &nbsp;&nbsp;&nbsp; //当左边部分有值(left&lt;j)，递归左半边<br> &nbsp;&nbsp;&nbsp; if(left&lt;j)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; run(pData,left,j);<br> &nbsp;&nbsp;&nbsp; //当右边部分有值(right&gt;i)，递归右半边<br> &nbsp;&nbsp;&nbsp; if(right&gt;i)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; run(pData,i,right);<br> }<br> void QuickSort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; run(pData,0,Count-1);<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4};<br> &nbsp;&nbsp;&nbsp; QuickSort(data,7);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;7;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 这里我没有给出行为的分析，因为这个很简单，我们直接来分析算法：首先我们考虑最理想的情况<br> 1.数组的大小是2的幂，这样分下去始终可以被2整除。假设为2的k次方，即k=log2(n)。<br> 2.每次我们选择的值刚好是中间值，这样，数组才可以被等分。<br> 第一层递归，循环n次，第二层循环2*(n/2)......<br> 所以共有n+2(n/2)+4(n/4)+...+n*(n/n) = n+n+n+...+n=k*n=log2(n)*n<br> 所以算法复杂度为O(log2(n)*n)<br> 其他的情况只会比这种情况差，最差的情况是每次选择到的middle都是最小值或最大值，那么他将变<br> 成交换法（由于使用了递归，情况更糟）。但是你认为这种情况发生的几率有多大？？呵呵，你完全<br> 不必担心这个问题。实践证明，大多数的情况，快速排序总是最好的。<br> 如果你担心这个问题，你可以使用堆排序，这是一种稳定的O(log2(n)*n)算法，但是通常情况下速度要慢于快速排序（因为要重组堆）。<br> 三、其他排序<br> 1.双向冒泡：<br> 通常的冒泡是单向的，而这里是双向的，也就是说还要进行反向的工作。<br> 代码看起来复杂，仔细理一下就明白了，是一个来回震荡的方式。<br> 写这段代码的作者认为这样可以在冒泡的基础上减少一些交换（我不这么认为，也许我错了）。<br> 反正我认为这是一段有趣的代码，值得一看。<br> #include &lt;iostream.h&gt;<br> void Bubble2Sort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; int iTemp;<br> &nbsp;&nbsp;&nbsp; int left = 1;<br> &nbsp;&nbsp;&nbsp; int right =Count -1;<br> &nbsp;&nbsp;&nbsp; int t;<br> &nbsp;&nbsp;&nbsp; do<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //正向的部分<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i=right;i&gt;=left;i--)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pData[i]&lt;pData[i-1])<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i] = pData[i-1];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i-1] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = i;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left = t+1;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //反向的部分<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=left;i&lt;right+1;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pData[i]&lt;pData[i-1])<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i] = pData[i-1];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i-1] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = i;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; right = t-1;<br> &nbsp;&nbsp;&nbsp; }while(left&lt;=right);<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4};<br> &nbsp;&nbsp;&nbsp; Bubble2Sort(data,7);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;7;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 2.SHELL排序<br> 这个排序非常复杂，看了程序就知道了。<br> 首先需要一个递减的步长，这里我们使用的是9、5、3、1（最后的步长必须是1）。<br> 工作原理是首先对相隔9-1个元素的所有内容排序，然后再使用同样的方法对相隔5-1个元素的排序<br> 以次类推。<br> #include &lt;iostream.h&gt;<br> void ShellSort(int* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; int step[4];<br> &nbsp;&nbsp;&nbsp; step[0] = 9;<br> &nbsp;&nbsp;&nbsp; step[1] = 5;<br> &nbsp;&nbsp;&nbsp; step[2] = 3;<br> &nbsp;&nbsp;&nbsp; step[3] = 1;<br> &nbsp;&nbsp;&nbsp; int iTemp;<br> &nbsp;&nbsp;&nbsp; int k,s,w;<br> &nbsp;&nbsp;&nbsp; for(int i=0;i&lt;4;i++)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = step[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s = -k;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int j=k;j&lt;Count;j++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[j];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w = j-k;//求上step个元素的下标<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(s ==0)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s = -k;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s++;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[s] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((iTemp&lt;pData[w]) &amp;&amp; (w&gt;=0) &amp;&amp; (w&lt;=Count))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[w+k] = pData[w];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w = w-k;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[w+k] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; int data[] = {10,9,8,7,6,5,4,3,2,1,-10,-1};<br> &nbsp;&nbsp;&nbsp; ShellSort(data,12);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;12;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i]&lt;&lt;" ";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br> 呵呵，程序看起来有些头疼。不过也不是很难，把s==0的块去掉就轻松多了，这里是避免使用0<br> 步长造成程序异常而写的代码。这个代码我认为很值得一看。<br> 这个算法的得名是因为其发明者的名字D.L.SHELL。依照参考资料上的说法：“由于复杂的数学原因<br> 避免使用2的幂次步长，它能降低算法效率。”另外算法的复杂度为n的1.2次幂。同样因为非常复杂并<br> “超出本书讨论范围”的原因（我也不知道过程），我们只有结果了。</p> 
    <p>四、基于模板的通用排序：<br> 这个程序我想就没有分析的必要了，大家看一下就可以了。不明白可以在论坛上问。<br> MyData.h文件<br> ///////////////////////////////////////////////////////<br> class CMyData&nbsp;&nbsp;<br> {<br> public:<br> &nbsp;&nbsp;&nbsp; CMyData(int Index,char* strData);<br> &nbsp;&nbsp;&nbsp; CMyData();<br> &nbsp;&nbsp;&nbsp; virtual ~CMyData();<br> &nbsp;&nbsp;&nbsp; int m_iIndex;<br> &nbsp;&nbsp;&nbsp; int GetDataSize(){ return m_iDataSize; };<br> &nbsp;&nbsp;&nbsp; const char* GetData(){ return m_strDatamember; };<br> &nbsp;&nbsp;&nbsp; //这里重载了操作符：<br> &nbsp;&nbsp;&nbsp; CMyData&amp; operator =(CMyData &amp;SrcData);<br> &nbsp;&nbsp;&nbsp; bool operator &lt;(CMyData&amp; data );<br> &nbsp;&nbsp;&nbsp; bool operator &gt;(CMyData&amp; data );<br> private:<br> &nbsp;&nbsp;&nbsp; char* m_strDatamember;<br> &nbsp;&nbsp;&nbsp; int m_iDataSize;<br> };<br> ////////////////////////////////////////////////////////<br> MyData.cpp文件<br> ////////////////////////////////////////////////////////<br> CMyData::CMyData():<br> m_iIndex(0),<br> m_iDataSize(0),<br> m_strDatamember(NULL)<br> {<br> }<br> CMyData::~CMyData()<br> {<br> &nbsp;&nbsp;&nbsp; if(m_strDatamember != NULL)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete[] m_strDatamember;<br> &nbsp;&nbsp;&nbsp; m_strDatamember = NULL;<br> }<br> CMyData::CMyData(int Index,char* strData):<br> m_iIndex(Index),<br> m_iDataSize(0),<br> m_strDatamember(NULL)<br> {<br> &nbsp;&nbsp;&nbsp; m_iDataSize = strlen(strData);<br> &nbsp;&nbsp;&nbsp; m_strDatamember = new char[m_iDataSize+1];<br> &nbsp;&nbsp;&nbsp; strcpy(m_strDatamember,strData);<br> }<br> CMyData&amp; CMyData::operator =(CMyData &amp;SrcData)<br> {<br> &nbsp;&nbsp;&nbsp; m_iIndex = SrcData.m_iIndex;<br> &nbsp;&nbsp;&nbsp; m_iDataSize = SrcData.GetDataSize();<br> &nbsp;&nbsp;&nbsp; m_strDatamember = new char[m_iDataSize+1];<br> &nbsp;&nbsp;&nbsp; strcpy(m_strDatamember,SrcData.GetData());<br> &nbsp;&nbsp;&nbsp; return *this;<br> }<br> bool CMyData::operator &lt;(CMyData&amp; data )<br> {<br> &nbsp;&nbsp;&nbsp; return m_iIndex&lt;data.m_iIndex;<br> }<br> bool CMyData::operator &gt;(CMyData&amp; data )<br> {<br> &nbsp;&nbsp;&nbsp; return m_iIndex&gt;data.m_iIndex;<br> }<br> ///////////////////////////////////////////////////////////<br> //////////////////////////////////////////////////////////<br> //主程序部分<br> #include &lt;iostream.h&gt;<br> #include "MyData.h"<br> template &lt;class T&gt;<br> void run(T* pData,int left,int right)<br> {<br> &nbsp;&nbsp;&nbsp; int i,j;<br> &nbsp;&nbsp;&nbsp; T middle,iTemp;<br> &nbsp;&nbsp;&nbsp; i = left;<br> &nbsp;&nbsp;&nbsp; j = right;<br> &nbsp;&nbsp;&nbsp; //下面的比较都调用我们重载的操作符函数<br> &nbsp;&nbsp;&nbsp; middle = pData[(left+right)/2];&nbsp; //求中间值<br> &nbsp;&nbsp;&nbsp; do{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((pData[i]&lt;middle) &amp;&amp; (i&lt;right))//从左扫描大于中值的数<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((pData[j]&gt;middle) &amp;&amp; (j&gt;left))//从右扫描大于中值的数<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j--;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(i&lt;=j)//找到了一对值<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //交换<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iTemp = pData[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[i] = pData[j];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pData[j] = iTemp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i++;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j--;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }while(i&lt;=j);//如果两边扫描的下标交错，就停止（完成一次）<br> &nbsp;&nbsp;&nbsp; //当左边部分有值(left&lt;j)，递归左半边<br> &nbsp;&nbsp;&nbsp; if(left&lt;j)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; run(pData,left,j);<br> &nbsp;&nbsp;&nbsp; //当右边部分有值(right&gt;i)，递归右半边<br> &nbsp;&nbsp;&nbsp; if(right&gt;i)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; run(pData,i,right);<br> }<br> template &lt;class T&gt;<br> void QuickSort(T* pData,int Count)<br> {<br> &nbsp;&nbsp;&nbsp; run(pData,0,Count-1);<br> }<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp; CMyData data[] = {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(8,"xulion"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(7,"sanzoo"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(6,"wangjun"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(5,"VCKBASE"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(4,"jacky2000"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(3,"cwally"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(2,"VCUSER"),<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMyData(1,"isdong")<br> &nbsp;&nbsp;&nbsp; };<br> &nbsp;&nbsp;&nbsp; QuickSort(data,8);<br> &nbsp;&nbsp;&nbsp; for (int i=0;i&lt;8;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;data[i].m_iIndex&lt;&lt;"&nbsp; "&lt;&lt;data[i].GetData()&lt;&lt;"\n";<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"\n";<br> }<br></p> 
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">
    专注于企业信息化，最近对股票数据分析较为感兴趣，可免费分享股票个股主力资金实时变化趋势分析工具，股票交流QQ群：457394862
   </div> 
   <div style="color:rgb(75,75,75);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:13px;">
    <br>
   </div> 
   <div> 
    <font color="#4b4b4b"><span style="font-size:13px;">本文转自沧海-重庆博客园博客，原文链接：http://www.cnblogs.com/omygod/archive/2007/05/11/742548.html，如需转载请自行联系原作者</span></font>
    <br>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
