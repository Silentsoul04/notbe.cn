<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>重磅开源:TN文本分析语言 « NotBeCN</title>
  <meta name="description" content="                  tn是desert(沙漠之鹰)和tan共同开发的一种用于匹配，转写和抽取文本的语言（DSL）。并为其开发和优化了专用的编译器。基于递归下降方法和正则表达式，能解析自然文本并转换为树和字典，识别时间，地址，数量等复杂序列模式。 github地址：https://github.co...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/09/26/weixin_33762321_90126497.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">重磅开源:TN文本分析语言</h1>
    <p class="post-meta">Sep 26, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body cnblogs-markdown"> 
    <p>tn是desert(沙漠之鹰)和tan共同开发的一种用于匹配，转写和抽取文本的语言（DSL）。并为其开发和优化了专用的编译器。基于递归下降方法和正则表达式，能解析自然文本并转换为树和字典，识别时间，地址，数量等复杂序列模式。<br> github地址：<a class="uri" href="https://github.com/ferventdesert/tnpy" rel="nofollow">https://github.com/ferventdesert/tnpy</a></p> 
    <h2>0.设计理由</h2> 
    <p>字符串分析和处理几乎是每个员程序必备的工作，简单到分割类似"1,2,3,4"这样的字符串，稍微复杂一些如字符串匹配，再复杂如编译和分析SQL语法。字符串几乎具有无穷的表达能力，解决字符串问题，就解决了计算机90%的问题。</p> 
    <p>虽然字符串处理如此深入人心，但当分割字符时，本来都是按照逗号分割的，突然出现分号，程序就可能出错。再如日期处理，每个程序员肯定都对各种奇怪诡异的时间表达方式感到头疼，处理起来非常费时。这些功能，几乎只能以硬编码实现。它们是与外界交互的最底层模块，然而却如此脆弱。</p> 
    <blockquote> 
     <ul>
      <li>如何将”一百二十三“转换为数字？</li> 
      <li>如何将”2013年12月14日“识别为时间并转换为时间类型？</li> 
      <li>如何分析一个XML或JSON文件？</li> 
     </ul>
    </blockquote> 
    <p>正则表达式虽提供了强大的匹配功能，成为必备的工具，但它有不少局限，我们扩展了正则表达式引擎，使之能力大大增强。<br> 在线演示：<a class="uri" href="http://www.desertlambda.com:81/extracttext.html" rel="nofollow">http://www.desertlambda.com:81/extracttext.html</a></p> 
    <h2>1. 如何学习?</h2> 
    <p>基本上程序员都读过“30分钟学会正则表达式”这篇文章吧？最后没几个人能在30分钟内就读完它。不过相信我，TN引擎只需要15分钟就可以学会。<br> 详细的语法说明在这里：<br><a href="http://www.cnblogs.com/buptzym/p/5355827.html" rel="nofollow">tn基本语法</a><br><a href="http://www.cnblogs.com/buptzym/p/5361121.html" rel="nofollow">使用tn构造自然语言计算器</a><br><a href="http://www.cnblogs.com/buptzym/p/5355920.html" rel="nofollow">tn实现的xml解析器</a></p> 
    <p>TN可以实现文本的匹配，转写和信息抽取，可以理解为模板引擎的逆运算。简单的操作用正则表达式更方便，但不少问题是正则无法解决的。这时就需要使用TN了。</p> 
    <p>TN的解释器有Python,C#和C三种版本。C#版本已经不再维护。使用C#或Java等语言的，建议使用IronPython或Jython进行跨语言编译。<br> tnpy是tn的Python解释器，Python良好的可读性让代码写起来非常方便，代码不超过1000行，单文件，无第三方库依赖。推荐使用Python3。<br> tn是解释型语言，需要编写规则文件，并使用tnpy加载，再对文本进行处理。</p> 
    <h2>1. 基础的匹配和替换：</h2> 
    <p>首先我们先编写一个最简单的规则文件learn，内容如下：</p> 
    <pre><code class="hljs ini"><span class="hljs-comment">#%Order% 1</span>
<span class="hljs-attr">hello</span>= (<span class="hljs-string">"你好"</span>);</code></pre> 
    <p>接着，执行下面的python代码：</p> 
    <pre><code class="hljs python"><span class="hljs-keyword">from</span> src.tnpy <span class="hljs-keyword">import</span> RegexCore
core = RegexCore(<span class="hljs-string">'../rules/learn'</span>)
matchs=core.Match(<span class="hljs-string">'领导你好！老婆你好'</span>);
<span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> matchs:
    print(<span class="hljs-string">'match'</span>,m.mstr, <span class="hljs-string">'pos:'</span>,m.pos)</code></pre> 
    <p>引入tnpy命名空间，之后从learn规则文件初始化引擎，匹配该文本:</p> 
    <pre><code class="hljs sql">success <span class="hljs-keyword">load</span> tn <span class="hljs-keyword">rules</span>:../<span class="hljs-keyword">rules</span>/learn
<span class="hljs-keyword">match</span> 你好 pos: <span class="hljs-number">2</span>
<span class="hljs-keyword">match</span> 你好 pos: <span class="hljs-number">7</span></code></pre> 
    <p>上面输出了文本的匹配结果和位置。当然这一点正则也能做到。<br> 如果我们匹配的是<code>领导你好，老婆您好</code>，并想把所有的<code>你好</code>和<code>您好</code>，都转写为<code>hello</code>。<br> 为此我们添加hello2和hello3两个子规则：</p> 
    <pre><code class="hljs ruby">hello2= $(hello)| (<span class="hljs-string">"您好"</span>);
<span class="hljs-comment">#%Order% 1</span>
hello3= $(hello2) <span class="hljs-symbol">:</span> (<span class="hljs-regexp">//</span><span class="hljs-symbol">:/hello/</span>);</code></pre> 
    <p><code>hello2</code>引用了刚才的<code>hello</code>规则，同时添加了<code>“您好”</code>。<br> hello3是主规则，负责将将<code>hello2</code>匹配的内容都转写为<code>hello</code><br><code>（$代表引用一条规则，|表示将几个规则并列排列，匹配最长的那个规则，:代表转写。）</code></p> 
    <p>执行下面的代码：`</p> 
    <pre><code class="hljs lisp">print(<span class="hljs-name">core</span>.Rewrite('领导你好！老婆您好'))<span class="hljs-comment">;</span></code></pre> 
    <p>结果为：</p> 
    <pre><code class="hljs">领导hello！老婆hello</code></pre> 
    <p>如果我们想替换顺序，把“你好”放在前面呢？可以这样写：</p> 
    <pre><code class="hljs ini"><span class="hljs-attr">people</span>= (<span class="hljs-string">"老婆"</span>) | (<span class="hljs-string">"领导"</span>);
<span class="hljs-comment">#%Order% 1</span>
<span class="hljs-attr">reorder</span>= $(people) $(hello3) : <span class="hljs-variable">$2</span> <span class="hljs-variable">$1</span>;</code></pre> 
    <p>先用<code>people</code>定义如何描述<code>老婆，领导</code>，然后用reorder来修改顺序， 注意reorder是个<strong>顺序结构</strong>，people匹配老婆和领导，hello3匹配您好/你好，并将其转换为<code>hello</code>。 <code>$2和$1</code>修改了转写顺序，执行Rewrite后输出:</p> 
    <pre><code class="hljs">hello领导！hello老婆</code></pre> 
    <p>我们把类似<code>$(name1) $(name2)</code>的结构，称为顺序表达式，把<code>$(name1) | $(name2)</code>称为或表达式。<br> 如果将刚才所有的规则绘制成图，则是下面的样子：<br><img alt="foo.png-34.5kB" src="http://static.zybuluo.com/buptzym/ksl5ggrfcn1psmdf2f81i8wg/foo.png"></p> 
    <h2>2. 正则表达式</h2> 
    <p>仅仅使用文本，表现力太差了。我们引入正则表达式来完成，正则表达式需要放在(//)中，注意和文本("")的区别。<br> 如果要进行转写，则标注为<code>(/match/:/rewrite/)</code>;<br> 下面的表达式将所有的长空白符转换为一个空白符:</p> 
    <pre><code class="hljs ruby">byte_det_space = (<span class="hljs-regexp">/ */</span><span class="hljs-symbol">://</span>);</code></pre> 
    <p>下面将所有字母转换为空白：</p> 
    <pre><code class="hljs ini"><span class="hljs-attr">low_letter_to_null</span> = (/[a-z]/ ://);
<span class="hljs-comment">#或者下面:</span>
<span class="hljs-attr">low_letter</span>= (/[a-z]/);
<span class="hljs-attr">translate</span>= $(low_letter) : (<span class="hljs-string">""</span>);</code></pre> 
    <p>觉得没有挑战？我们接着看下面的。</p> 
    <h3>3. 复杂组合：中文数字转阿拉伯数字</h3> 
    <p>二十三如何转换为23？这种用普通的编程会比较困难。我们尝试用TN解决，会发现一点都不难。<br> 先定义汉字的一二三到九转换为1-9，你肯定会写出这样的规则：</p> 
    <pre><code class="hljs ini"><span class="hljs-comment">#定义0-9</span>
<span class="hljs-attr">int_1</span> = (<span class="hljs-string">"一"</span> : <span class="hljs-string">"1"</span>);
<span class="hljs-attr">int_0</span> =(<span class="hljs-string">"零"</span> : <span class="hljs-string">"0"</span>);
<span class="hljs-attr">int_2</span>  = (<span class="hljs-string">"二"</span> : <span class="hljs-string">"2"</span>) | (<span class="hljs-string">"两"</span> : <span class="hljs-string">"2"</span>);
<span class="hljs-attr">int_3_9</span> = (<span class="hljs-string">"三"</span> : <span class="hljs-string">"3"</span>) | (<span class="hljs-string">"四"</span> : <span class="hljs-string">"4"</span>) | (<span class="hljs-string">"五"</span> : <span class="hljs-string">"5"</span>) | (<span class="hljs-string">"六"</span> : <span class="hljs-string">"6"</span>) | (<span class="hljs-string">"七"</span> : <span class="hljs-string">"7"</span>) | (<span class="hljs-string">"八"</span> : <span class="hljs-string">"8"</span>) | (<span class="hljs-string">"九"</span> : <span class="hljs-string">"9"</span>);
<span class="hljs-attr">int_1_9</span> = $(int_1) | $(int_2) | $(int_<span class="hljs-number">3_9</span>) | (/\d/);
<span class="hljs-attr">int_0_9</span> = $(int_0) | $(int_<span class="hljs-number">1_9</span>);
<span class="hljs-attr">int_del_0</span> = (/零/ : /<span class="hljs-number">0</span>/) |  (// : /<span class="hljs-number">0</span>/);
<span class="hljs-attr">int_0_9_null</span> = $(int_del_0) |  $(int_<span class="hljs-number">0_9</span>);</code></pre> 
    <p>之所以要把0,1,2分开写，是因为这些数有特殊情况，如两和二都代表2，需要在后面特殊处理。<br> 上面的<code>int_0_9_null</code>规则，就可以把<code>五七零二</code>转写为<code>5702</code>。但没法处理<code>二十三</code>这样的情况。</p> 
    <p>再定义下面的规则，这样<code>一十三</code>可以转写为<code>13</code></p> 
    <pre><code class="hljs typescript">int_del_0 = (<span class="hljs-regexp">/零/</span> : <span class="hljs-regexp">/0/</span>) |  (<span class="hljs-comment">// : /0/);</span>
int_0_9_null = $(int_del_0) |  $(int_0_9);
#定义<span class="hljs-number">10</span>，十
int_1_decades = (<span class="hljs-regexp">/十/</span> : <span class="hljs-regexp">/1/</span>) | (<span class="hljs-regexp">/一十/</span> : <span class="hljs-regexp">/1/</span>);</code></pre> 
    <p>再加上下面的规则，int_1_9_decades定义了十位数如何转写，而int_10_99定义了从十到九十九的转写规则。</p> 
    <pre><code class="hljs ini"><span class="hljs-attr">int_10_99</span> = $(int_<span class="hljs-number">1_9_</span>decades) $(int_<span class="hljs-number">0_9_</span>null)  | (/[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]/) ;
<span class="hljs-attr">int_1_99</span> = $(int_<span class="hljs-number">1_9</span>) | $(int_<span class="hljs-number">10_99</span>) ;
<span class="hljs-attr">int_01_99</span> =  $(int_<span class="hljs-number">1_9</span>) | $(int_<span class="hljs-number">10_99</span>) | (/\d{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}/);

<span class="hljs-comment">#%Order% 3</span>
<span class="hljs-attr">int_0_99</span> =  $(int_0) | $(int_<span class="hljs-number">1_9</span>) | $(int_<span class="hljs-number">10_99</span>);</code></pre> 
    <p>看看下面的例子：<br><code>print({r:core.Rewrite(r) for r in ['十','三十七','一十三','68']});</code><br> 运行结果:<br><code>{'一十三': '13', '68': '68', '十': '10', '三十七': '37'}</code><br> 是不是感到很神奇？三十七是如何被转写为37的？</p> 
    <p>仔细看规则，规则自底向上构造成了一棵规则树，in_0_99是整棵树的根节点。结构如下图：<br><img alt="foo.png-132.1kB" src="http://static.zybuluo.com/buptzym/itwhlmz8ua2h3jgbqdq5z48g/foo.png"><br> 下面的log文件给出了匹配过程:</p> 
    <pre><code class="hljs delphi">int_0_99,Table,Raw  =三十七
  int_0,<span class="hljs-keyword">String</span>,Raw  =三十七
  int_0,<span class="hljs-keyword">String</span>,NG
  int_1_9,Table,Raw  =三十七
    int_1,<span class="hljs-keyword">String</span>,Raw  =三十七
    int_1,<span class="hljs-keyword">String</span>,NG
    int_2,Table,Raw  =三十七
      int_2_merge,Regex,Raw  =三十七
      int_2_merge,Regex,NG
    int_2,Table,NG
    int_3_9,Table,Raw  =三十七
      int_3_9_merge,Regex,Raw  =三十七
      int_3_9_merge,Regex,Match=三
    int_3_9,Table,Match=三
    int_1_9_3,Regex,Raw  =三十七
    int_1_9_3,Regex,NG
  int_1_9,Table,Match=三
  int_10_99,Table,Raw  =三十七
    int_10_99_0,Sequence,Raw  =三十七
      int_1_9_decades,Table,Raw  =三十七
        int_1_decades,Table,Raw  =三十七
          int_1_decades_0,Regex,Raw  =三十七
          int_1_decades_0,Regex,Match=十
          int_1_decades_1,Regex,Raw  =三十七
          int_1_decades_1,Regex,NG
        int_1_decades,Table,Match=十
        int_1_9_decades_1,Sequence,Raw  =三十七
          int_1_9,Table,Raw  =三十七
          int_1_9,Table,Buff =三
          unknown,Regex,Raw  =十七
          unknown,Regex,Match=十
        int_1_9_decades_1,Sequence,Match=三十
      int_1_9_decades,Table,Match=三十
      int_0_9_null,Table,Raw  =七
        int_del_0,Table,Raw  =七
          int_del_0_0,Regex,Raw  =七
          int_del_0_0,Regex,NG
          int_del_0_1,Regex,Raw  =七
          int_del_0_1,Regex,Match=
        int_del_0,Table,Match=
        int_0_9,Table,Raw  =七
          int_0,<span class="hljs-keyword">String</span>,Raw  =七
          int_0,<span class="hljs-keyword">String</span>,NG
          int_1_9,Table,Raw  =七
            int_1,<span class="hljs-keyword">String</span>,Raw  =七
            int_1,<span class="hljs-keyword">String</span>,NG
            int_2,Table,Raw  =七
              int_2_merge,Regex,Raw  =七
              int_2_merge,Regex,NG
            int_2,Table,NG
            int_3_9,Table,Raw  =七
              int_3_9_merge,Regex,Raw  =七
              int_3_9_merge,Regex,Match=七
            int_3_9,Table,Match=七
            int_1_9_3,Regex,Raw  =七
            int_1_9_3,Regex,NG
          int_1_9,Table,Match=七
        int_0_9,Table,Match=七
      int_0_9_null,Table,Match=七
    int_10_99_0,Sequence,Match=三十七
    int_10_99_1,Regex,Raw  =三十七
    int_10_99_1,Regex,NG
  int_10_99,Table,Match=三十七
int_0_99,Table,Match=三十七</code></pre> 
    <p>引擎从文本的左向右，沿着规则树寻找最长的文本，如果在一个顺序表达式上的任何一步失败，那么整个顺序表达式被抛弃。或表达式会遍历每个子表达式，直到发现最长的那个，返回结果。具体的匹配原理，以及优化，会在专门的文章中介绍。</p> 
    <h2>4. 由规则构造更复杂的规则</h2> 
    <p>自然而然的，知道怎么定义三十七，就可以定义五百三十七，那不过是<code>int_1_9_hundreds+int_0_99</code>（这个已经定义过了）。</p> 
    <pre><code class="hljs ini"><span class="hljs-attr">int_1_9_hundreds</span> = $(int_<span class="hljs-number">1_9</span>) (<span class="hljs-string">"百"</span> : <span class="hljs-string">""</span>);
<span class="hljs-attr">int_100_999</span> =   $(int_<span class="hljs-number">1_9_</span>hundreds) (<span class="hljs-string">""</span> : <span class="hljs-string">"00"</span>) |  $(int_<span class="hljs-number">1_9_</span>hundreds) $(int_<span class="hljs-number">10_99</span>);
<span class="hljs-attr">int_1_999</span> = $(int_<span class="hljs-number">1_99</span>) | $(int_<span class="hljs-number">100_999</span>);</code></pre> 
    <p><code>int_1_999</code>可以处理类似五百三十七这样的问题！</p> 
    <p>进而，我们可以处理几千，几万，这个延伸到万以后，就可以自然而然地衍生出亿，万亿的表达。</p> 
    <p>如何处理负数？这还不简单！</p> 
    <pre><code class="hljs ini"><span class="hljs-attr">signed_symbol0</span> = (<span class="hljs-string">"正"</span> : <span class="hljs-string">""</span>) | (<span class="hljs-string">"负"</span> : <span class="hljs-string">"-"</span>) | (<span class="hljs-string">"正负"</span> : <span class="hljs-string">"±"</span>) | (<span class="hljs-string">"\+"</span> : <span class="hljs-string">"+"</span>) | (<span class="hljs-string">"\-"</span> : <span class="hljs-string">"-"</span>) | (<span class="hljs-string">"±"</span> : <span class="hljs-string">"±"</span>) ; 
<span class="hljs-attr">signed_symbol</span> = $(signed_symbol0) | $(null_2_null);</code></pre> 
    <p>接下来，我们默认正整数为<code>integer_int</code>，那么，整数（包含正负）就是：<br><code>integer_signed = $(signed_symbol) $(integer_int)</code></p> 
    <h2>5. 属性提取</h2> 
    <p>沿着刚才的路，我们自然而然地能定义分数，但仅仅是转写还不够，遇到三分之一，我们不仅要将其处理为1/3，还要计算出它的值，这就涉及到属性抽取。也就是把信息从文本中提取为字典。</p> 
    <p>分数，不过是<code>整数+分之+整数</code>，可以定义成下面的形式：</p> 
    <pre><code class="hljs ruby">fraction_cnv_slash = (<span class="hljs-string">"分之"</span> <span class="hljs-symbol">:</span> <span class="hljs-string">"/"</span>);
fraction2 = (<span class="hljs-string">"/"</span> <span class="hljs-symbol">:</span> <span class="hljs-string">"/"</span>);
percent_transform= (<span class="hljs-string">"%"</span> <span class="hljs-symbol">:</span> <span class="hljs-string">"100"</span>) | (<span class="hljs-string">"‰"</span> <span class="hljs-symbol">:</span> <span class="hljs-string">"1000"</span>);
<span class="hljs-comment">#%Type% DOUBLE</span>
<span class="hljs-comment">#%Property% Denominator,,Numerator| Numerator ,, Denominator | Denominator ,, Numerator </span>
<span class="hljs-comment">#%Order% 101</span>
fraction = $(integer_int_extend) $(fraction_cnv_slash) $(integer_int) <span class="hljs-symbol">:</span> $3 $2 $1
    | $(integer_int) $(fraction2) $(integer_int)
    | $(pure_decimal) (<span class="hljs-string">""</span> <span class="hljs-symbol">:</span> <span class="hljs-string">"/"</span>) $(percent_transform);</code></pre> 
    <p>这个有点复杂，但容我慢慢讲解。分数有三种情况，如刚才的<code>三分之一</code>，或是<code>1/3</code>，或是<code>30%</code>。分别对应上面<code>fraction</code>规则的三个子规则。仔细地看上面的规则，不难理解。</p> 
    <p>值得注意的是Property这个标签，该标签定义了如何抽取信息。也是用竖线分隔，每个名称对应下面的一个子规则，为空的直接跳过。那么”十三分之二十四“中，“十三”就对应Numerator， 而“二十四”对应Denominator。来测试一下：</p> 
    <p><code>print(core.Extract('十三分之二十四',entities=[core.Entities['fraction']]))</code><br> 我们用Extract函数来抽取文本，返回的是一个字典，entites是可选参数，我们限制只用fraction规则来匹配，获得输出：<br><code>[{'Numerator': '24', '#rewrite': '24/13', '#type': 'fraction', '#match': '十三分之二十四', 'Denominator': '13', '#pos': 3}]</code><br> 是不是很赞？</p> 
    <h3>6.嵌入Python脚本</h3> 
    <p>有一种需求还没谈到，将所有的大写字母转换为小写字母，你可能会想定义26个字符串规则，并用或表达式来拼接起来吧？这样太费事了。我们可以直接这样：<br><code>low_to_up_letter = (/[A-Z]/) : "str.lower(mt)";</code><br><code>[A-Z]</code>匹配了所有的大写字母，将匹配结果送到后半段的转写，内置的解释器会执行那段python代码，将其转换为小写，mt代表前面表达式的匹配串，rt代表转写串。好在<code>[A-Z]</code>不执行转写，可以认为<code>mt==rt</code>.<br> 这是在转写过程中嵌入python的例子，还能在匹配时嵌入转写：<br><code>foo = "findsecret" : "print(mt)"</code>;<br> 前面的findsecret函数负责在字符串中找到“神秘文本”，后面的转写代码打印出来，并将原始的字符返回…</p> 
    <h2>6. 你在15分钟内读完了么？</h2> 
    <p>我相信你没有，因为读懂那个匹配规则的日志文件，就需要最少五分钟，但如果你有编译原理和正则基础的话，还是能很快理解的。而从零开发这个引擎，到反复优化和完善，花了一年之久。</p> 
    <p>定义了各种数字之后，我们就能很快地定义时间，日期，电话号码，地址…而你看到的只是TN语言的冰山一角。</p> 
    <ul>
     <li> <p>它能够分析文本的模式，解析诸如ABCABC这样的序列，从而发现这是一个重复模式。</p> </li> 
     <li> <p>不仅能够顺序匹配，还能逆向，甚至乱序匹配，这就能够抽取类似“学校的校训”这样的问题。</p> </li> 
     <li> <p>规则可以调用自身，配合脚本，因此能够实现递归下降解析。例如30行代码实现xml解析，或20行规则实现自然语言计算器。</p> </li> 
     <li> <p>规则可以嵌入脚本，甚至动态生成代码，因此，甚至在理论上，TN能够自己编译自己。</p> </li> 
     <li> <p>TN还能做一个简单的SQL解释器，或是中文英文的简单互相翻译的工具。</p> </li> 
    </ul>
    <p>是不是已经激动地颤抖了？唯一限制你能力的就是你的想象力。本博客将会进一步发布一系列有关tn的内容，包括高级语法，tn优化等。<br> 感兴趣的可以联系作者：<a href="mailto:buptzym@qq.com" rel="nofollow">buptzym@qq.com</a>，或在本文下面留言。</p> 
   </div> 
   <div> 
    <div> 
     <p style="border-top:#e0e0e0 1px dashed;border-right:#e0e0e0 1px dashed;border-bottom:#e0e0e0 1px dashed;border-left:#e0e0e0 1px dashed;background:#e5f1f4 url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) no-repeat 1% 50%;font-family:'微软雅黑';font-size:11px;"><br> 作者：<a href="http://www.cnblogs.com/buptzym/" rel="nofollow">热情的沙漠</a> <br> 出处：<a href="http://www.cnblogs.com/buptzym/" rel="nofollow">http://www.cnblogs.com/buptzym/</a> <br> 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 <br></p> 
    </div> 
   </div> 
   <div class="clear"></div> 
   <div> 
    <div>
     分类: 
     <a href="http://www.cnblogs.com/buptzym/category/810798.html" rel="nofollow">tn文本分析引擎</a> 
    </div> 
    <div>
     <br>
    </div> 
    <div>
     本文转自FerventDesert博客园博客，原文链接：http://www.cnblogs.com/buptzym/p/5361105.html，如需转载请自行联系原作者
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
