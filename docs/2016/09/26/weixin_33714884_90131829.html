<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>浅谈神经网络算法 « NotBeCN</title>
  <meta name="description" content="                  我们在设计机器学习系统时，特别希望能够建立类似人脑的一种机制。神经网络就是其中一种。但是考虑到实际情况，一般的神经网络（BP网络）不需要设计的那么复杂，不需要包含反馈和递归。 人工智能的一大重要应用，是分类问题。本文通过分类的例子，来介绍神经网络。     1.最简单的线性分类...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/09/26/weixin_33714884_90131829.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">浅谈神经网络算法</h1>
    <p class="post-meta">Sep 26, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body cnblogs-markdown"> 
    <p>我们在设计机器学习系统时，特别希望能够建立类似人脑的一种机制。神经网络就是其中一种。但是考虑到实际情况，一般的神经网络（BP网络）不需要设计的那么复杂，不需要包含反馈和递归。<br> 人工智能的一大重要应用，是分类问题。本文通过分类的例子，来介绍神经网络。</p> 
    <h2>1.最简单的线性分类</h2> 
    <p>一个最简单的分类，是在平面上画一条直线，左边为类0，右边为类1，直线表示为<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">z<span></span></span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">a</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span class="mo" style="font-family:'MathJax_Main';">+</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">b</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">y<span></span></span><span class="mo" style="font-family:'MathJax_Main';">+</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">c</span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.33em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">z=ax+by+c</span></span> </span><br> 这是一个分类器，输入(x,y)，那么，要求的参数有三个:a,b,c。另外注意c的作用，如果没有c，这条直线一定会过原点。<br><img alt="最简单的神经网络" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image004.jpg"><br> 因此，我们可以设计一个简单的神经网络，包含两层，输入层有三个节点，代表x,y,1，三条线分别代表a,b,cg(z)对传入的值x进行判别，并输出结果。<br><span class="math display"><span class="MathJax_Preview" style="color:inherit;"></span></span></p> 
    <div class="MathJax_Display" style="text-align:center;">
     <span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">z<span></span></span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="msubsup"><span><span><span class="texatom"><span class="mrow"><span class="mo" style="font-family:'MathJax_Math';font-style:italic;">θ</span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">0</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">+</span><span class="msubsup"><span><span><span class="texatom"><span class="mrow"><span class="mo" style="font-family:'MathJax_Math';font-style:italic;">θ</span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">+</span><span class="msubsup"><span><span><span class="texatom"><span class="mrow"><span class="mo" style="font-family:'MathJax_Math';font-style:italic;">θ</span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.28em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">z=θ0+θ1X1+θ2X2</span></span>
    </div> 
    <br> 但是，由于z的值可能为[
    <span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mo" style="font-family:'MathJax_Main';">−</span><span class="mi" style="font-family:'MathJax_Main';">∞</span><span class="mo" style="font-family:'MathJax_Main';">,</span><span class="mo" style="font-family:'MathJax_Main';">+</span><span class="mi" style="font-family:'MathJax_Main';">∞</span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.31em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">−∞,+∞</span></span> </span>],为了方便处理，需要将其压缩到一个合理的范围，还需sigmoid函数:
    <br>
    <span class="math display"><span class="MathJax_Preview" style="color:inherit;"></span> </span>
    <div class="MathJax_Display" style="text-align:center;">
     <span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">a</span><span class="mo" style="font-family:'MathJax_Main';">(</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">z<span></span></span><span class="mo" style="font-family:'MathJax_Main';">)</span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="mfrac"><span style="margin-left:.12em;"><span style="margin-left:-.25em;"><span class="mn" style="font-family:'MathJax_Main';">1</span><span style="width:0px;"></span></span><span style="margin-left:-1.57em;"><span class="mrow"><span class="mn" style="font-family:'MathJax_Main';">1</span><span class="mo" style="font-family:'MathJax_Main';">−</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span style="width:0px;"></span></span><span><span class="texatom"><span class="mrow"><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">−</span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">z<span></span></span></span></span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span><span><span style="vertical-align:0em;border-top-width:1.3px;border-top-style:solid;"></span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-1.04em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">a(z)=11−e−z</span></span>
    </div> 
    <br> 这样的激励函数，能够将刚才的区间，压缩到
    <span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mo" style="font-family:'MathJax_Main';">[</span><span class="mn" style="font-family:'MathJax_Main';">0</span><span class="mo" style="font-family:'MathJax_Main';">,</span><span class="mn" style="font-family:'MathJax_Main';">1</span><span class="mo" style="font-family:'MathJax_Main';">]</span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.38em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">[0,1]</span></span> </span>。
    <br> 至于如何训练，会在之后的章节中讲解。 
    <p></p> 
    <h2>2.多层级神经网络</h2> 
    <p>刚才展示了最简单的二分类，如果有四个分类，那一条线就无法满足要求了。想象两条直线，就会将平面划分为四个区域，一个三角区域相当于两个子平面求交集。<br> 因此直觉告诉我们，如果有多个神经元，那么这样的问题能表现为问题的“逻辑与”操作。将第一节中介绍的神经网络的输出，再做一个判断层，即多层网络。<br><img alt="单层感知器" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image009.jpg"><br> 但是，如何实现逻辑与呢？用下面的图一目了然：<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image020.jpg"><br> 仔细看下，这相当于创建一条线，除非<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.26em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">x1</span></span> </span>和<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.26em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">x2</span></span> </span>都等于1，否则<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">h</span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">θ</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">(</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span class="mo" style="font-family:'MathJax_Main';">)</span><span class="mo" style="font-family:'MathJax_Main';">&lt;</span><span class="mn" style="font-family:'MathJax_Main';">0</span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.38em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">hθ(x)&lt;0</span></span> </span>。<br> 进一步地，如果我们能够对区域求并集，那么总可以对不同的子区域求并。而实现并操作和与操作是类似的：<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image022.jpg"><br> 此处就能看到sigmoid函数的作用了，如果没有它对数值的放缩，并和与的操作就无法实现了。<br> 输出还能作为下一级的输入，从而增加了一个隐层，产生了单隐层神经网络，再复杂一些，如果网络层数特别多，则叫做深度学习网络，简称深度学习。<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image010.jpg"><br> 之前针对一个线性不可分的区域，需要将其变换到更高维度的空间去处理。但如果用神经网络，你总可以通过n条直线，将整个区间围起来。只要直线数量够多，总能绘制出任意复杂的区域。每一个子区域都是凸域：<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image018.jpg"><br> 简直不能更酷！下面这张图总结了不同类型的神经网络具备的功能：<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_2015-11-28_235750.jpg"><br> 数学家证明了，双隐层神经网络能够解决任意复杂的分类问题。但我们的问题到此为止了吗？不见得！<br> 这里还有几个问题：</p> 
    <ul>
     <li>异或如何实现？异或肯定是不能通过一条直线区分的，因此单层网络无法实现异或，但两层（包含一个隐层）就可以了。</li> 
     <li>过拟合问题：过多的隐层节点，可能会将训练集里的点全部围进去，这样系统就没有扩展性了。如何防止过拟合？</li> 
     <li>如何训练：如何计算出合理的神经网络参数？（隐层节点数）</li> 
    </ul>
    <h2>3.如何训练神经网络</h2> 
    <p>如果一个平面，有6个点，分成三类。如何设计呢？<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image026.jpg"><br> 一种最狂暴的方法，是对每一个点都用四条线围起来，之后，再对六个区域两两取并集。形成下面这张超复杂的图：<br><img alt="此处输入图片的描述" src="http://7xnkcs.com1.z0.glb.clouddn.com/longxinchen_1128_image028.jpg"><br> 解释一下为什么要有这么多个节点：<br> 第一层：x,y再加bias,三个<br> 第二层：每个点需要四条线围起来，加上bias，总共4*6+1=25个<br> 第三层：一个节点处于该类的条件是在四条线的中间（交集），因此每四个点汇成一个点，24/4+1=7个<br> 第四层：三分类问题，需要对每两个区域求并集，因此需要6/2+1=4个</p> 
    <p>但这样的解法，使用了3+25+7+4=39个节点，需要111个参数。这样的系统非常复杂，对未知节点几乎没有任何扩展性。<br> 仔细思考这个问题， 我们能够通过更少的节点和层数，来简化这个问题嘛？只要三条直线就可以！节点数量大大减少。不仅训练效率更高，而且可扩展能力很强。对更复杂的例子，我们又不是神仙，怎么知道设计几个隐层和多少个节点呢？<br> 所谓超参数，就是模型之外的参数，在这个例子中，就是隐层的数量和节点的数量。通常来说，线性分类器（回归）只需要两层即可，对于一般的分类问题，三层足够。<br> 一个三层的神经网络，输入和输出节点的数量已经确定，那如何确定中间层（隐层）的节点数量呢？一般有几个经验：</p> 
    <ul>
     <li>隐层节点数量一定要小于N-1(N为样本数)</li> 
     <li>训练样本数应当是连接权（输入到第一隐层的权值数目+第一隐层到第二隐层的权值数目+...第N隐层到输出层的权值数目，不就是边的数量么）的2-10倍（也有讲5-10倍的），另外，最好将样本进行分组，对模型训练多次，也比一次性全部送入训练强很多。</li> 
     <li>节点数量尽可能少，简单的网络泛化能力往往更强</li> 
     <li>确定隐层节点的下限和上限，依次遍历，找到收敛速度较快，且性能较高的节点数</li> 
    </ul>
    <p>如何表示一个神经网络？网络有m层，每层的节点分别为<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">n</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">o</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">d<span></span></span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">0</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">,</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">n</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">o</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">d<span></span></span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">.</span><span class="mo" style="font-family:'MathJax_Main';">.</span><span class="mo" style="font-family:'MathJax_Main';">.</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">n</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">o</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">d<span></span></span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">m</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.31em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">node0,node1...nodem</span></span> </span>，节点最多的层，有m个节点，那么我们可以将其表达为一个矩阵W,规模为<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">m</span><span class="mo" style="font-family:'MathJax_Main';">∗</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">n</span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.08em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">m∗n</span></span> </span>，内部有些值是没有定义的。</p> 
    <h2>4.训练算法</h2> 
    <h3>线性可分</h3> 
    <p>如果输入和输出是线性关系（或者是正相关），那么想象我们在调节一个参数时，当输出过大，那就把输入调小一些，反之调大一些，最后当输出和我们想要的非常接近时，训练结束。这个就好比，在平面上，如果一个点被分配到了错误的输出，就应该对直线平移和扭转，减少该直线到这个点的距离，从而实现重新分区。<br> 进一步地，如果向量的多个分量<strong>互相独立</strong>，那么方法也和上面的类似<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">=&gt;</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">y<span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">,</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">=&gt;</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">y<span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.33em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">x1=&gt;y1,x2=&gt;y2</span></span> </span>，分别调节<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.26em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">x1</span></span> </span>和<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.26em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">x2</span></span> </span>的参数，最终让结果接近，训练结束。<br><img alt="此处输入图片的描述" src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht11.gif"><br> 而一个感知器结构可表示如下：<br><img alt="感知器结构" src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht13.gif"><br> 反思上面的过程，我们实际上是在衡量误差，根据误差来修改权重。</p> 
    <h3>线性不可分</h3> 
    <p>如果输入和输出的关系比较复杂，如二次函数<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">y<span></span></span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">x</span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.33em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">y=x2</span></span> </span>，那当超过x=0的位置之后，反而成了递增了，此时一个线性的判断函数就不起作用了。因此，上面的方法，不能推广到所有的前馈网络中。<br> 怎么办？那就只能使用梯度(LMS)法了。<br> 梯度法，是对于样本集<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">,</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">.</span><span class="mo" style="font-family:'MathJax_Main';">.</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">n</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.31em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">X1,X2..Xn</span></span> </span>，找到一个<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">W<span></span></span><span style="width:0px;"></span></span><span><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">∗</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.09em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">W∗</span></span> </span>,使得<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">f<span></span></span><span class="mo" style="font-family:'MathJax_Main';">(</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">W<span></span></span><span style="width:0px;"></span></span><span><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">∗</span><span style="width:0px;"></span></span></span></span><span class="msubsup"><span><span><span class="texatom"><span class="mrow"><span class="munderover"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mo" style="font-family:'MathJax_Main';">˙</span><span style="width:0px;"></span></span></span></span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">i</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">)</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">i</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.38em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">f(W∗X˙i)Xi</span></span> </span>与输出<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">Y<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">i</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.27em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">Yi</span></span> </span>尽可能接近，其中<span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">f<span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.33em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">f</span></span> </span>是激励函数。误差表示为：<br><span class="math display"><span class="MathJax_Preview" style="color:inherit;"></span></span></p> 
    <div class="MathJax_Display" style="text-align:center;">
     <span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="mfrac"><span style="margin-left:.12em;"><span style="margin-left:-.25em;"><span class="mn" style="font-family:'MathJax_Main';">1</span><span style="width:0px;"></span></span><span style="margin-left:-.25em;"><span class="mn" style="font-family:'MathJax_Main';">2</span><span style="width:0px;"></span></span><span><span style="vertical-align:0em;border-top-width:1.3px;border-top-style:solid;"></span><span style="width:0px;"></span></span></span></span><span class="munderover"><span><span><span class="mo" style="font-family:'MathJax_Size2';vertical-align:0em;">∑</span><span style="width:0px;"></span></span><span><span class="texatom"><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">i</span><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">=</span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span></span></span><span style="width:0px;"></span></span><span><span class="texatom"><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">n</span></span></span><span style="width:0px;"></span></span></span></span><span class="msubsup"><span><span><span class="texatom"><span class="mrow"><span class="mo" style="font-family:'MathJax_Main';">(</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">Y<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">i</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">−</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">Y<span></span></span><span style="width:0px;"></span></span><span><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">∗</span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">i</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">)</span></span></span><span style="width:0px;"></span></span><span><span class="texatom"><span class="mrow"><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span></span></span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-1.59em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">e=12∑i=1n(Yi−Yi∗)2</span></span>
    </div> 
    <br> 为了能够调节误差e,使之尽可能小，则需要求其导数，发现其下降的方向：
    <br>
    <span class="math display"><span class="MathJax_Preview" style="color:inherit;"></span> </span>
    <div class="MathJax_Display" style="text-align:center;">
     <span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">g<span></span></span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">r</span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">a</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">d<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">w</span><span style="width:0px;"></span></span></span></span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="mfrac"><span style="margin-left:.12em;"><span style="margin-left:-.51em;"><span class="mrow"><span class="mi" style="font-family:'MathJax_Main';">∂<span></span></span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span></span><span style="width:0px;"></span></span><span style="margin-left:-.8em;"><span class="mrow"><span class="mi" style="font-family:'MathJax_Main';">∂<span></span></span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">W<span></span></span></span><span style="width:0px;"></span></span><span><span style="vertical-align:0em;border-top-width:1.3px;border-top-style:solid;"></span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="munderover"><span><span><span class="mo" style="font-family:'MathJax_Size2';vertical-align:0em;">∑</span><span style="width:0px;"></span></span><span><span class="texatom"><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">k</span><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">=</span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">1</span></span></span><span style="width:0px;"></span></span><span><span class="texatom"><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">n</span></span></span><span style="width:0px;"></span></span></span></span><span class="mfrac"><span style="margin-left:.12em;"><span style="margin-left:-.73em;"><span class="mrow"><span class="mi" style="font-family:'MathJax_Main';">∂<span></span></span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">k</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span><span style="margin-left:-.8em;"><span class="mrow"><span class="mi" style="font-family:'MathJax_Main';">∂<span></span></span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">W<span></span></span></span><span style="width:0px;"></span></span><span><span style="vertical-align:0em;border-top-width:1.3px;border-top-style:solid;"></span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-1.61em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">gradwe=∂e∂W=∑k=1n∂ek∂W</span></span>
    </div> 
    <br> 其中:
    <br>
    <span class="math display"><span class="MathJax_Preview" style="color:inherit;"></span> </span>
    <div class="MathJax_Display" style="text-align:center;">
     <span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">e</span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">k</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">=</span><span class="mfrac"><span style="margin-left:.12em;"><span style="margin-left:-.25em;"><span class="mn" style="font-family:'MathJax_Main';">1</span><span style="width:0px;"></span></span><span style="margin-left:-.25em;"><span class="mn" style="font-family:'MathJax_Main';">2</span><span style="width:0px;"></span></span><span><span style="vertical-align:0em;border-top-width:1.3px;border-top-style:solid;"></span><span style="width:0px;"></span></span></span></span><span class="msubsup"><span><span><span class="texatom"><span class="mrow"><span class="mo" style="font-family:'MathJax_Main';">(</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">Y<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">k</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">−</span><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">Y<span></span></span><span style="width:0px;"></span></span><span><span class="mo" style="font-family:'MathJax_Main';font-size:70.7%;">−</span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">k</span><span style="width:0px;"></span></span></span></span><span class="mo" style="font-family:'MathJax_Main';">)</span></span></span><span style="width:0px;"></span></span><span><span class="mn" style="font-family:'MathJax_Main';font-size:70.7%;">2</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.94em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">ek=12(Yk−Yk−)2</span></span>
    </div> 
    <br> 对偏导进行求解：
    <br>
    <img alt="此处输入图片的描述" src="http://dataunion.org/wp-content/uploads/2015/03/03233317-775d2307dc7c46b8a5dfba716c2a4bd5.png">
    <br> 每次迭代的计算公式为：
    <br>
    <img alt="此处输入图片的描述" src="http://dataunion.org/wp-content/uploads/2015/03/03233327-4fce87a4944d41748e22ccd713cb0f3a.png">
    <br> 最终：
    <br>
    <img alt="此处输入图片的描述" src="http://www.funnyai.com/AI/Book/DigtalNN/images/4.2.ht21.gif">
    <br> 其几何意义就是，误差的偏导，等于在
    <span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="msubsup"><span><span><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">X<span></span></span><span style="width:0px;"></span></span><span><span class="mi" style="font-family:'MathJax_Math';font-size:70.7%;font-style:italic;">k</span><span style="width:0px;"></span></span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.27em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">Xk</span></span> </span>位置上的值，乘以误差，再乘以激励函数的偏导。
    <br> 所以，每次的权重矩阵
    <span class="math inline"><span class="MathJax_Preview" style="color:inherit;"></span><span class="MathJax"><span class="math"><span style="font-size:127%;"><span><span class="mrow"><span class="mi" style="font-family:'MathJax_Math';font-style:italic;">W<span></span></span></span><span style="width:0px;"></span></span></span><span style="width:0px;vertical-align:-.09em;border-left-width:0px;border-left-style:solid;"></span></span><span class="MJX_Assistive_MathML">W</span></span> </span>的修改，应当通过求误差的偏导（梯度）来实现。比之前的直接通过误差来调整，具备更好的适应性。
    <br> 但是，这样的梯度法，对于实际学习来说，效率还是太慢，我们需要更快的收敛方法。 
    <p></p> 
    <h3>BP算法</h3> 
    <p>BP算法就是所谓的反向传播算法，它将误差进行反向传播，从而获取更高的学习效率。这很像烽火台，如果前线战败了，那么消息就通过烽火台传递回指挥部，指挥部去反思问题，最终改变策略。<br> 但这带来一个问题，中间层的误差怎么计算？我们能简单地将权重和残差的乘积，返回给上一层节点（这种想法真暴力，从左到右和从右到左是一样的）。<br><img alt="此处输入图片的描述" src="http://dataunion.org/wp-content/uploads/2015/03/20f9979d6a46e7bca83f217bdfead4f0.png"></p> 
    <p>这相当于三次传播：</p> 
    <pre><code class="hljs ruby">-第一步：从前向后传播FP
-第二步：得到值z，误差为y,将误差反向传播，获得每个节点的偏差$\sigma$
-第三步：再次正向传播，通过上一步的$\sigma$，再乘以步长，修改每一个神经元突触的权重。</code></pre> 
    <p>下面一张图展示了完整的BP算法的过程，我看了不下20遍：<br><img alt="此处输入图片的描述" src="http://dataunion.org/wp-content/uploads/2015/03/08135834-8e9b8ff2212545c0aeb1d68103ef3d64.gif"><br> 更有趣的是，sigmoid求导之后，特别像高斯（正态）分布，而且sigmoid求导非常容易。</p> 
    <h2>5.总结</h2> 
    <p>这样的一篇文章真是够长了，原本还想再介绍一个神经网络的Python实现，可是考虑到篇幅的限制，最终作罢。在下一期继续介绍如何实现BP神经网络和RNN（递归神经网络）。</p> 
   </div> 
   <div> 
    <div> 
     <p style="border-top:#e0e0e0 1px dashed;border-right:#e0e0e0 1px dashed;border-bottom:#e0e0e0 1px dashed;border-left:#e0e0e0 1px dashed;background:#e5f1f4 url(&quot;https://images.cnblogs.com/cnblogs_com/lloydsheng/239039/o_copyright.gif&quot;) no-repeat 1% 50%;font-family:'微软雅黑';font-size:11px;"><br> 作者：<a href="http://www.cnblogs.com/buptzym/" rel="nofollow">热情的沙漠</a> <br> 出处：<a href="http://www.cnblogs.com/buptzym/" rel="nofollow">http://www.cnblogs.com/buptzym/</a> <br> 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 <br></p> 
    </div> 
   </div> 
   <div class="clear"></div> 
   <div> 
    <div>
     分类: 
     <a href="http://www.cnblogs.com/buptzym/category/809618.html" rel="nofollow">算法</a> 
    </div> 
    <div>
     <br>
    </div> 
    <div>
     本文转自FerventDesert博客园博客，原文链接：http://www.cnblogs.com/buptzym/p/5437973.html，如需转载请自行联系原作者
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
