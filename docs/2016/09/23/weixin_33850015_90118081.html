<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ARM、Intel、MIPS处理器啥区别？看完全懂了【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://news.mydrivers.com/1/472/472317.htm    安卓支持三类处理器(CPU)：ARM、Intel和MIPS。ARM无疑被使用得最为广泛。Intel因为普及于台式机和服务器而被人们所熟知，然而对移动行业影响力相对较小。MIPS在32位和64...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/09/23/weixin_33850015_90118081.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">ARM、Intel、MIPS处理器啥区别？看完全懂了【转】</h1>
    <p class="post-meta">Sep 23, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://news.mydrivers.com/1/472/472317.htm" rel="nofollow">http://news.mydrivers.com/1/472/472317.htm</a></p> 
   <p>安卓支持三类处理器(CPU)：ARM、Intel和MIPS。ARM无疑被使用得最为广泛。Intel因为普及于台式机和服务器而被人们所熟知，然而对移动行业影响力相对较小。MIPS在32位和64位嵌入式领域中历史悠久，获得了不少的成功，可目前Android的采用率在三者中最低。</p> 
   <p>总之，ARM现在是赢家而Intel是ARM的最强对手。那么ARM处理器和Intel处理器到底有何区别？为什么ARM如此受欢迎？你的智能手机或平板电脑用的是什么处理器到底重要不重要？&nbsp;</p> 
   <p align="center"><a href="http://img1.mydrivers.com/img/20160302/dd8a03d88fbb43b0bdcb84466be79ba2.jpg" rel="nofollow"><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></a></p> 
   <p><strong>处理器（CPU）</strong></p> 
   <p>中央处理器（CPU）是你智能设备的大脑。它的任务是通过执行一系列指令来驱动你的设备，包括显示屏、触摸屏、调制解调器等，让一坨塑料金属混合物变成闪亮的智能手机或者平板电脑。</p> 
   <p>移动设备非常复杂，其中的处理器需要执行数百万行指令才能完成人们希望这些设备去做的事。速度和功耗对处理器来说至关重要。速度影响用户体验，功耗影响电池寿命。完美的移动设备必须有好性能以及低功耗。</p> 
   <p>这就是为什么选择什么样的处理器很重要。一个超级耗电、反应迟钝的处理器会很快吸干你的电池，而一个考究的、高效的处理器给你带来高性能和长久的电池寿命。</p> 
   <p>总体而言，<strong>ARM和Intel处理器的第一个区别是，前者使用精简指令集（RISC），而后者使用复杂指令集（CISC)。</strong></p> 
   <p>通俗而言，精简指令集规模较小，更接近原子操作，而复杂指令集规模较大，更加复杂。所谓原子操作，是指每条指令的工作大都可以由处理器在一个操作内完成，例如对两个寄存器做加法。</p> 
   <p>复杂指令集的指令描述某个意图，但是处理器必须执行3或4个更简单的指令来实现这个意图。例如，可以命令一个复杂指令集处理器对2个数求和，并把结果存入主内存中。为了完成这个命令，处理器首先从地址1中取得第一个数（操作1），然后从地址2中取得另一个数（操作2），然后求和（操作3），等等。</p> 
   <p align="center"><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></p> 
   <p>所有的现代处理器都使用一种所谓<strong>微指</strong>令的概念，这是一个处理器内部的指令集合，用来描述处理器可以做的原子操作。</p> 
   <p>复杂指令集处理器实际上执行了3条微指令。对精简指令集处理器而言，其指令跟其微指令十分接近，而复杂指令集处理器的指令需要先被转换成一些更精简的微指令（就像前面的复杂指令集处理器做加法的例子中那样）。</p> 
   <p>也就是说，<strong>精简指令集处理器中的解码器（负责告诉处理器到底要干些什么的东东）要简单得多，而简洁意味着高效和低功耗。</strong></p> 
   <p><strong>制造工艺</strong></p> 
   <p>ARM和Intel处理器的另外一个主要区别是<strong>ARM从来只是设计低功耗处理器。</strong>其宗旨是设计低功耗处理器，这是他们的强项。Intel的强项是设计超高性能的台式机和服务器处理器，并且的确做的不错。</p> 
   <p>Intel是台式机的服务器行业的老大。过去的20年里我所有的PC，笔记本和服务器（除了一个外）用的都是Intel的处理器。然而进入移动行业时，Intel依然使用和台式机同样的复杂指令集架构，试图将其硬塞入给移动设备使用的体积较小的处理器中。</p> 
   <p>Intel i7处理器平均发热率为45瓦。基于ARM的片上系统（其中包括图形处理器）的发热率最大瞬间峰值大约是3瓦，约为Intel i7处理器的1/15。Intel现如今是个巨头，雇佣了大量的聪明人。</p> 
   <p>其最新的Atom系列处理器采用了跟ARM处理器类似的温度控制设计，为此Intel必须使用最新的22纳米制造工艺。一般而言，制造工艺的纳米数越小，能量的使用效率越高。ARM处理器使用更低的制造工艺，拥有类似的温控效果。比如，高通晓龙805处理器使用28纳米制造工艺。</p> 
   <p align="center"><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></p> 
   <p><strong>64位</strong></p> 
   <p>对于64位计算，ARM和Intel也有一些显著区别。你知不知道，Intel并没有开发64位版本的x86指令集。这个64位的指令集，名为x86-64（有时简称为x64），实际上是AMD设计开发的。</p> 
   <p>故事是这样的：Intel想搞64位计算，它知道如果从自己的32位x86架构进化出的64位架构的话，新架构效率会很低，于是它搞了一个新64位处理器项目名为IA64。由此制造出了Itanium系列处理器。</p> 
   <p>同时AMD知道自己造不出能与IA64兼容的处理器，于是它把x86扩展一下，加入了64位寻址和64位寄存器。最终出来的架构，人称AMD64，成为了64位版本的x86处理器的标准。</p> 
   <p align="center"><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></p> 
   <p>IA64项目并不算得上成功，现如今基本被放弃了。Intel最终采用了AMD64。Intel当前给出的移动方案，是采用了AMD开发的64位指令集（有些许差别）的64位处理器。</p> 
   <p>ARM的故事很不一样：看到移动设备对64位计算的需求后，ARM于2011年发布了ARMv8 64位架构，这是为了下一代ARM指令集架构工作若干年后的结晶。为了基于原有的原则和指令集，开发一个简明的64位架构，ARMv8使用了两种执行模式，AArch32和AArch64。</p> 
   <p align="center"><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></p> 
   <p>顾名思义，一个运行32位代码，一个运行64位代码。ARM设计的巧妙之处，是处理器在运行中可以无缝地在两种模式间切换。这意味着64位指令的解码器是全新设计的，不用兼顾32位指令，而处理器依然可以向后兼容。</p> 
   <p><strong>异构计算</strong></p> 
   <p align="center"><strong><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></strong></p> 
   <p><strong>ARM的big.LITTLE架构是一项Intel一时无法复制的创新。</strong>在big.LITTLE架构里，处理器可以是不同类型的。传统的双核或者四核处理器中包含同样的2个核或者4个核。一个双核Atom处理器中有两个一模一样的核，提供一样的性能，拥有相同的功耗。</p> 
   <p>ARM通过big.LITTLE向移动设备推出了异构计算。这意味着处理器中的核可以有不同的性能和功耗。当设备正常运行时，使用低功耗核，而当你运行一款复杂的游戏是，使用的是高性能的核。</p> 
   <p>这是什么做到的呢？设计处理器的时候，要考虑大量的技术设计的采用与否，这些技术设计决定了处理器的性能以及功耗。</p> 
   <p><strong>在一条指令被解码并准备执行时，Intel和ARM的处理器都使用流水线。就是说解码的过程是并行的。</strong></p> 
   <p>第一步从内存中读取指令，第二步检查和解码指令，第三步执行指令，周而复始。流水线的好处在于，当前指令在第二步的时候，下一条指令已经处于第一步。当前指令在第三步中执行的时候，下一条指令正处于第二步，而下下条指令处于第一步中，如此循环。</p> 
   <p>为了更快地执行指令，这些流水线可以被设计成允许指令们不按照程序的顺序被执行（乱序执行）。一些巧妙的逻辑结构可以判断下一条指令是否依赖于当前的指令执行的结果。Intel和ARM都提供乱序执行逻辑结构，可想而知，这种结构十分的复杂。复杂意味着更多的功耗。</p> 
   <p><strong>Intel处理器由设计者们选择是否加入乱序逻辑结构。异构计算则没有这方便的问题。</strong>ARM Cortex-A53采用顺序执行，因此功耗低一些。而ARM Cortex-A57使用乱序执行，所以更快但更耗电。采用big.LITTLE架构的处理器可以同时拥有Cortex-A53和Cortex-A57核，根据具体的需要决定如何使用这些核。在后台同步邮件的时候，不需要高速的乱序执行，仅在玩复杂游戏的时候需要。在合适的时间使用合适的核。</p> 
   <p align="center"><img src="https://yqfile.alicdn.com/img_638b1aec013975a08049b45b7bdbc21d.jpg" alt="ARM、Intel、MIPS处理器啥区别？看完全懂了"></p> 
   <p>原则上，处理器中复杂逻辑结构越多性能越高，越少则效率越高，指令流水线只是其中之一，包括浮点运算单元，单指令多数据逻辑（SIMD）（比如ARM的NEON和Intel的SSE/MMX），以及一级缓存二级缓存。</p> 
   <p>每种Atom片上系统，Intel仅提供一种方案，而ARM以及芯片合作伙伴提供的芯片则有多种方案可以配置。</p> 
   <p><strong>兼容性</strong></p> 
   <p>ARM目前是移动处理器的老大。ARM的合作伙伴们基于ARM的设计向移动和嵌入式市场的出货量已经达500亿片。<strong>对于安卓，ARM已然成为标准，这对Intel和MIPS而言是个问题。</strong></p> 
   <p>尽管安卓的主要编程语言是Java，开发者也可以使用现有的代码（比如C或者C++）去开发应用。这些固定平台的应用通常都编译成ARM处理器的程序，不全都会编译成Intel或者MIPS处理器的程序。</p> 
   <p><strong>为了解决这个问题，Intel和MIPS要使用特殊的转换软件把ARM的指令转换成他们处理器使用的指令。这当然是会降低性能的。</strong></p> 
   <p>目前MIPS和Intel声称兼容Play Store里大约90%的应用。对于最受欢迎的150个应用，兼容率是100%。一方面兼容率很高，另一方面表明ARM的主导地位，使得其他的处理器设计者需要提供一个兼容层。</p> 
   <p><strong>总结</strong></p> 
   <p>制造处理器是一项复杂的业务。ARM，Intel和MIPS都在不懈努力地向移动设备提供最好的技术，而很明显ARM是老大。拥有着低功耗，简明的64位设计，异构计算，以及作为移动计算的标准，看来ARM必能保持其老大的地位。</p> 
   <p><a id="jiucuo_n" href="http://blog.mydrivers.com/jiucuo-472317.htm" rel="nofollow">文章纠错</a></p> 
   <div class="weixin">
    微信公众号搜索"驱动之家"加关注，每日最新的手机、电脑、汽车、智能硬件信息可以让你一手全掌握。推荐关注！【
    <span style="color:#FF0000;">微信扫描下图可直接关注</span>】 
    <p align="center"><img src="https://yqfile.alicdn.com/img_a8ea4fe627fdef6b82c22a39b1aa4715.jpg" alt="" width="237" height="237"></p> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
