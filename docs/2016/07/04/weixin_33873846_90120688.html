<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>非常好！！！Linux源代码阅读——内核引导【转】 « NotBeCN</title>
  <meta name="description" content="             Linux源代码阅读——内核引导    转自：http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html    目录        Linux 引导过程综述     BIOS            POST       自举...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/07/04/weixin_33873846_90120688.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">非常好！！！Linux源代码阅读——内核引导【转】</h1>
    <p class="post-meta">Jul 4, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h1>Linux源代码阅读——内核引导</h1> 
   <p>转自：<a href="http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html" rel="nofollow">http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html</a></p> 
   <h3>目录</h3> 
   <ol>
    <li>Linux 引导过程综述</li> 
    <li>BIOS 
     <ul>
      <li>POST</li> 
      <li>自举过程</li> 
     </ul></li> 
    <li>Boot loader 
     <ul>
      <li>主引导扇区结构</li> 
      <li>GRUB stage1</li> 
      <li>GRUB stage2</li> 
     </ul></li> 
    <li>内核初始化：体系结构相关部分 
     <ul>
      <li>内核映像结构</li> 
      <li>header.S</li> 
      <li>初始化与保护模式</li> 
      <li>自解压内核</li> 
      <li>startup_32</li> 
     </ul></li> 
    <li>内核初始化：体系结构无关部分 
     <ul>
      <li>核心数据结构初始化</li> 
      <li>设备初始化</li> 
     </ul></li> 
   </ol>
   <h2>1 Linux引导过程综述</h2> 
   <ol>
    <li>BIOS&nbsp;<br>在 i386 平台中，由 BIOS 作最初的引导工作，执行加电自检、初始化，读取引导设备的主引导扇区并执行。</li> 
    <li>Boot loader（以 GRUB 为例）&nbsp;<br>MBR 中的、紧随 MBR 后的 phase 1/1.5 boot loader 载入文件系统中的 phase 2 及其配置，显示操作系统选择菜单，执行用户命令，载入选定的操作系统内核与 initrd。</li> 
    <li>内核初始化：体系结构相关部分&nbsp;<br>从 header.S 开始，到 main.c 初始化参数，再到 pm.c 进入保护模式，然后载入 vmlinuz 并自解压，在 startup_32.S 中开启分页机制、初始化中断向量表、检测 CPU 类型等，完成 x86 体系结构的保护模式初始化。这是本文重点。</li> 
    <li>内核初始化：体系结构无关部分&nbsp;<br>分为核心数据结构初始化（start_kernel）和设备初始化两个阶段。</li> 
    <li>用户态初始化&nbsp;<br>以下内容超出了本文范围。用户态的 init 程序: 
     <ul>
      <li>获取运行信息</li> 
      <li>执行 /etc/rc[runlevel].d 中的启动脚本</li> 
      <li>加载内核模块（/etc/modprobe.conf）</li> 
      <li>执行 /etc/init.d 中的脚本</li> 
      <li>执行 /bin/login，等待用户登录</li> 
      <li>接受 shell 中的用户控制</li> 
     </ul></li> 
   </ol>
   <h2>2 BIOS</h2> 
   <p>BIOS的主要功能概括来说包括如下几部分：</p> 
   <ul>
    <li>POST <p>加电自检，检测 CPU 各寄存器、计时芯片、中断芯片、DMA 控制器等</p> </li> 
    <li>Initial <p>枚举设备，初始化寄存器，分配中断、IO 端口、DMA 资源等</p> </li> 
    <li>Setup <p>进行系统设置，存于 CMOS 中。</p> </li> 
    <li>常驻程序 <p>INT 10h、INT 13h、INT 15h 等，提供给操作系统或应用程序调用。</p> </li> 
    <li>启动自举程序 <p>在POST过程结束后，将调用 INT 19h，启动自举程序，自举程序将读取引导记录，装载操作系统。</p> </li> 
   </ul>
   <p>BIOS 的启动主要由 POST 过程与自举过程构成。</p> 
   <h3>2.1 POST</h3> 
   <p>当 PC 加电后，CPU 的寄存器被设为某些特定值。其中，指令指针寄存器（program counter）被设为 0xfffffff0。</p> 
   <p>CR1，一个32位控制寄存器，在刚启动时值被设为0。CR1 的 PE (Protected Enabled，保护模式使能) 位指示处理器是处于保护模式还是实模式。由于启动时该位为0，处理器在实模式中引导。在实模式中，线性地址与物理地址是等同的。</p> 
   <p>在实模式下，0xfffffff0 不是一个有效的内存地址，计算机硬件将这个地址指向 BIOS 存储块。这个位置包含一条跳转指令，指向 BIOS 的 POST 例程。</p> 
   <p>POST（Power On Self Test，加电自检）过程包括内存检查、系统总线检查等。如果发现问题，主板会蜂鸣报警。在 POST 过程中，允许用户选择引导设备。</p> 
   <p>POST 的最后一步是执行 INT 0x19 指令，开始自举过程。</p> 
   <p>POST 过程在 AWARD BIOS 的源码中在 BOOTROM.ASM 文件中 BootBlock_POST 函数过程中实现，主要步骤如下：</p> 
   <ol>
    <li>初始化各种主板芯片组</li> 
    <li>初始化键盘控制器</li> 
    <li>初始化中断向量、中断服务例程</li> 
    <li>初始化 VGA BIOS 控制器</li> 
    <li>显示 BIOS 的版本和公司名称</li> 
    <li>扫描各种介质容量并显示</li> 
    <li>读取 CMOS 的启动顺序配置</li> 
    <li>调用 INT 0x19 启动自举程序</li> 
   </ol>
   <h3>2.2 自举过程</h3> 
   <p>自举过程即为执行中断 INT 0x19 的中断服务例程 INT19_VECT 的过程 (Bootrom.asm)</p> 
   <p>主要功能为读取引导设备第一个扇区的前 512 字节（MBR），将其读入到内存 0x0000:7C00，并跳转至此处执行。</p> 
   <h2>3 Boot loader</h2> 
   <h3>3.1 主引导扇区结构</h3> 
   <p>硬盘第一个扇区的前 512 个字节是主引导扇区，由 446 字节的 MBR、64 字节的分区表和 2 字节的结束标志组成。</p> 
   <ul>
    <li>MBR（Master Boot Record）是 446 字节的引导代码，被 BIOS 加载到 0x00007C00 并执行。</li> 
    <li> <p>硬盘分区表占据主引导扇区的 64 个字节（0x01BE -- 0x01FD)，可以对四个分区的信息进行描述，其中每个分区的信息占据 16 个字节。</p> <p><img src="https://yqfile.alicdn.com/img_119923f51e53fc1eacbf2adc90f70a0c.png" alt=""></p> <p>一个分区记录有如下域：</p> 
     <ul>
      <li>1字节 文件系统类型</li> 
      <li>1字节 可引导标志</li> 
      <li>6字节 CHS格式描述符</li> 
      <li>8字节 LBA格式描述符</li> 
     </ul><p>LBA和CHS两种描述符指示相同的信息，但是指示方式有所不同：LBA (逻辑块寻址，Logical Block Addressing)指示分区的起始扇区和分区长度， 而CHS(柱面 磁头 扇区)指示首扇区和末扇区。</p> </li> 
    <li>结束标志字 55，AA（0x1FEH -- 0x1FFH）是主引导扇区的最后两个字节，是检验主引导记录是否有效的标志。</li> 
   </ul>
   <h3>3.2 GRUB stage1</h3> 
   <p>Linux 的启动方式包括 LILO、GRUB 等。这里结合 GRUB 源代码分析其引导过程。</p> 
   <p>GRUB 的引导过程分为 stage1、stage 1.5 和 stage 2。其中 stage1 和可能存在的 stage1.5 是为 stage2 做准备，stage2 像一个微型操作系统。</p> 
   <ol>
    <li> <p>BIOS 加载 GRUB stage1（如果安装到 MBR）到 0x00007C00.</p> </li> 
    <li> <p>stage1 位于 stage1/stage1.S，汇编后形成 512 字节的二进制文件，写入硬盘的0面0道第1扇区。</p> <p>stage1 将0面0道第2扇区上的 512 字节读到内存中的0x00007000处，然后调用 COPY_BUFFER 将其拷贝到 0x00008000 的位置上，然后跳至 0x00008000 执行。这 512 字节代码来自 stage2/start.S，作用是 stage1_5 或者 stage2（编译时决定加载哪个）的加载器。</p> <pre>/* start.S */
blocklist_default_start:
.long 2	 /* 从第3扇区开始*/
blocklist_default_len:
/* 需要读取多少个扇区 */
#ifdef STAGE1_5
.word 0	 /* 如果是 STAGE1_5，则不读入 */
#else
.word (STAGE2_SIZE + 511) &gt;&gt; 9 /* 读入 Stage2 所占的所有扇区 */
#endif
blocklist_default_seg:
#ifdef STAGE1_5
.word 0x220 /* 将 stage1.5 加载到 0x2200 */
#else
.word 0x820	/* 将 stage2 加载到 0x8200 */
#endif
</pre> </li> 
    <li>由于 stage1 和 start 不具备文件系统识别功能，stage 1.5 只能被存放在固定的扇区中。例如 e2fs_stage1_5 就被存放在0面0道第3扇区开始的一段连续空间里。（第一个主分区是从1面0道第1扇区开始的，stage 1.5 不会覆盖主分区内容） <p>stage 1.5 能够读取文件系统，负责从文件系统中载入并执行 stage 2，即 GRUB 的核心映像。由于系统引导过程中不需要修改文件系统，因此只实现了文件系统的读取。</p> <p>可以说，stage 1.5 是 stage 1 与 stage 2 之间的桥梁，解决了文件系统这个“先有鸡还是先有蛋”的问题。</p> </li> 
   </ol>
   <h3>3.3 GRUB stage2</h3> 
   <p>stage2 将系统切换到保护模式，设置 C 运行环境，寻找 config 文件，执行 shell 接受用户命令，载入选定的操作系统内核。</p> 
   <ol>
    <li>stage2 的入口点是 asm.s <pre>#ifdef STAGE1_5
# define	ABS(x)	((x) - EXT_C(main) + 0x2200)
#else
# define	ABS(x)	((x) - EXT_C(main) + 0x8200)
#endif
</pre> 
     <ol>
      <li>初始化一些变量</li> 
      <li>跳转到 code_start</li> 
      <li>关中断，设置段寄存器和堆栈起始地址</li> 
      <li>从实模式切换到保护模式</li> 
      <li>清空 bss 段</li> 
      <li>init_bios_info()</li> 
     </ol></li> 
    <li> <p>随后进入 stage2.c，执行 GRUB 的主要功能。</p> 
     <ul>
      <li> <p>cmain(): 主函数，载入配置文件 menu.lst（GRUB 1）或 grub.cfg（GRUB 2），如果成功载入就进入 run_menu()，显示菜单，进入循环倒计时，如果超时就进入第一个，如果用户按了键就停止倒计时。用户作出选择后，跳转到 boot_entry()，清空屏幕、获取入口，通过 find_command 找到的函数指针调用相应的命令。</p> </li> 
      <li> <p>如果没有成功载入配置文件，就 enter_cmdline()，也是通过 find_command 调用相应的命令。</p> </li> 
     </ul></li> 
    <li>每个 GRUB 命令都要在 stage2/builtin.c 的 builtin_table 数组中登记： <pre>struct builtin
{
    char *name;			/* 命令名称 */
    int (*func) (char *, int);	/* 命令执行时调用的函数指针 */
    int flags;			/* 标志，似乎未用到 */
    char *short_doc;		/* 短帮助 */
    char *long_doc;		/* 详细帮助 */
};
struct builtin *builtin_table[];
</pre> </li> 
    <li>常用 GRUB 命令： 
     <ul>
      <li>root：挂载分区并设为根分区。 <pre>root_func (char *arg, int flags)</pre> </li> 
      <li>kernel：对传进来的参数逐个解析，获得 linux 内核映像路径，通过 load_image() 载入内核。 <pre>kernel_func (char *arg, int flags)</pre> </li> 
      <li>boot：根据操作系统类型调用不同的启动函数，将控制权转交给操作系统。支持 BSD、linux、chain loader、multi boot 等方式。 <pre>boot_func (char *arg, int flags)</pre> </li> 
     </ul></li> 
    <li>stage2 中的文件系统驱动： <p>每种文件系统都要按照 stage2/filesys.h 的定义在 stage2/disk_io.c 的 fsys_table 数组中登记：</p> <pre>/* stage2/filesys.h */
struct fsys_entry
{
    char *name;                                         //文件系统名称
    int (*mount_func) (void);                           //挂载
    int (*read_func) (char *buf, int len);              //读文件
    int (*dir_func) (char *dirname);                    //打开文件
    void (*close_func) (void);                          //关闭文件
    int (*embed_func) (int *start_sector, int needed_sectors);  //不清楚
};
</pre> <p>GRUB 调用 grub_open() 打开文件。grub_open 在 fsys_table 数组中逐个调用 fsys_entry::mount_func()，找到当前已挂载的文件系统，再用 fsys_entry::dir_func() 方法打开文件。</p> </li> 
   </ol>
   <h2>4 内核初始化：体系结构相关部分</h2> 
   <h3>4.1 内核映像结构</h3> 
   <p>根据 Linux/I386 启动协议（Documentation/i386/boot.txt），x86 体系结构大内核内存使用如下：</p> 
   <pre>For a modern bzImage kernel with boot protocol version &gt;= 2.02, a
memory layout like the following is suggested:

        ~                        ~   
        |  Protected-mode kernel |
100000  +------------------------+
        |  I/O memory hole       |   
0A0000  +------------------------+
        |  Reserved for BIOS     |      Leave as much as possible unused
        ~                        ~   
        |  Command line          |      (Can also be below the X+10000 mark)
X+10000 +------------------------+
        |  Stack/heap            |      For use by the kernel real-mode code.
X+08000 +------------------------+    
        |  Kernel setup          |      The kernel real-mode code.
        |  Kernel boot sector    |      The kernel legacy boot sector.
X       +------------------------+
        |  Boot loader           |      &lt;- Boot sector entry point 0000:7C00
001000  +------------------------+
        |  Reserved for MBR/BIOS |
000800  +------------------------+
        |  Typically used by MBR |
000600  +------------------------+ 
        |  BIOS use only         |   
000000  +------------------------+

</pre> 
   <p>根据 arch/x86/boot/Makefile，bzImage 大内核映像由 setup.elf 和 vmlinux 组成，而 vmlinux 又由 setup.bin 和 vmlinux.bin 组成。vmlinux.bin 会进行压缩存储，变成 vmlinux.bin.gz。因此 bzImage 由 setup.elf、setup.bin、vmlinux.bin.gz 三部分组成。</p> 
   <pre>Line 28: targets         := vmlinux.bin setup.bin setup.elf zImage bzImage
Line 29: subdir-         := compressed
Line 30: 
Line 31: setup-y         += a20.o cmdline.o copy.o cpu.o cpucheck.o edd.o
Line 32: setup-y         += header.o main.o mca.o memory.o pm.o pmjump.o
Line 33: setup-y         += printf.o string.o tty.o video.o video-mode.o version.o
</pre> 
   <p>其中 setup-y 就是 setup.elf，其中引用的 header.o 是从 header.S 汇编而来的。</p> 
   <pre>Line 77: $(obj)/bzImage: IMAGE_OFFSET := 0x100000</pre> 
   <pre>Line 86: $(obj)/zImage $(obj)/bzImage: $(obj)/setup.bin \
Line 87:                               $(obj)/vmlinux.bin $(obj)/tools/build FORCE
Line 88:         $(call if_changed,image)
Line 89:         @echo 'Kernel: $@ is ready' ' (#'`cat .version`')'
Line 90:
Line 91: OBJCOPYFLAGS_vmlinux.bin := -O binary -R .note -R .comment -S
</pre> 
   <p>大内核情况下的内存分布图：</p> 
   <pre>        |  vmlinux               |   
100000  +------------------------+
        |  setup.elf的setup部分   |
090200  +------------------------+
        |  setup.elf的启动扇区     |
090000  +------------------------+
        |  BootLoader            |
007c00  +------------------------+
        |                        |
000000  +------------------------+
</pre> 
   <p>在进入源代码的世界之前，我们先看看用于控制 arch/x86/boot 下代码进行链接的 setup.ld。</p> 
   <p>ld 文件用于控制 ld 的链接过程：</p> 
   <ul>
    <li>描述输入文件的各节如何对应到输出文件的各节</li> 
    <li>控制输入文件各节及符号的内存布局</li> 
   </ul>
   <p>每个对象文件有一个节（section）列表、一个符号列表，一个符号可以是已定义或未定义的。每个已定义的符号有地址。未定义的符号则要在链接时从其他文件中寻找其定义。</p> 
   <ol>
    <li>指定输出文件格式 <pre>OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")</pre> </li> 
    <li>指定目标体系结构 <pre>OUTPUT_ARCH(i386)</pre> </li> 
    <li>设置入口点 <pre>ENTRY(_start)</pre> </li> 
    <li>输入文件各节到输出文件的映射 <pre>SECTIONS
{
. = 0				// 从 0 开始
.bstext : { *(.bstext) }	// 所有输入文件的 .bstext 节组合成输出文件的 .bstext 节
.bsdata : { *(.badata) }	// 所有输入文件的 .bsdata 节...
. = 497				// 填充 512 字节的 bootloader（见4.2节 header.S）
.header : { *(.header) }
</pre> <p>在每一部分（header、rodata、data、bss、end）之间，对齐 16 字节内存边界：</p> <pre>. = ALIGN(16);</pre> <p>最后用断言保证链接后的目标文件不太大，且偏移量正确。</p> </li> 
   </ol>
   <h3>4.2 header.S</h3> 
   <pre>start2:
	movw	%cs, %ax        # CS = 0x7c00
	movw	%ax, %ds	# 初始化段寄存器
	movw	%ax, %es
	movw	%ax, %ss
	xorw	%sp, %sp
	sti			# 开中断
	cld			# di++, si++
................................
msg_loop:			# 打印字符例程
................................
bs_die:				# 错误处理例程
        .ascii  "Direct booting from floppy is no longer supported.\r\n"
        .ascii  "Please use a boot loader program instead.\r\n"
        .ascii  "\n"
        .ascii  "Remove disk and press any key to reboot . . .\r\n"
        .byte   0
</pre> 
   <p>这段代码编译链接后，会生成 512 字节的 bootsector，其中 .section ".header", "a" 中的变量共 15 字节。注意到 setup.ld (Linker script for the i386 setup code) 中加入了 497 字节的空白，事实上恰好凑够 512 字节。</p> 
   <p>事实上，上一节我们提到，MBR 是由 GRUB 写入的，因此这里的 bootsector 对于硬盘启动是用不到的。GRUB 等 boot loader 将 setup.elf 读到 0x90000 处，将 vmlinux 读到 0x100000 处，然后跳转到 0x90200 开始执行，恰好跳过了 512 字节的 bootsector。</p> 
   <p>有意思的是，从软盘启动时，header.S 生成的 bootsector 做的惟一一件事就是打印错误信息（bs_die），不支持从软盘启动。</p> 
   <p>下面就是 0x90200（_start）了，目的就是跳到 start_of_setup。</p> 
   <pre>         # Part 2 of the header, from the old setup.S
................................
# End of setup header #####################################################
</pre> 
   <p>上面这两行之间的代码是一个庞大的数据结构，与 include/asm/bootparam.h 中的 struct setup_header 一一对应。这个数据结构定义了启动时所需的默认参数，其中一些参数可以通过命令选项 overwrite。下表列出了一些参数的意义。</p> 
   <table>
    <tbody>
     <tr>
      <th>名称</th> 
      <th>偏移</th> 
      <th>大小(字节)</th> 
      <th>意义</th> 
     </tr>
     <tr>
      <td>root_flags</td> 
      <td>0x1f2</td> 
      <td>2</td> 
      <td>根目录是否只读，可用 ro 或 rw 选项指定</td> 
     </tr>
     <tr>
      <td>root_dev</td> 
      <td>0x1fc</td> 
      <td>2</td> 
      <td>默认的 root 设备，即 /boot 所在目录，可用 root= 选项指定</td> 
     </tr>
     <tr>
      <td>boot_flag</td> 
      <td>0x1fe</td> 
      <td>2</td> 
      <td>0xAA55，即主引导扇区结束标志</td> 
     </tr>
     <tr>
      <td>header</td> 
      <td>0x202</td> 
      <td>4</td> 
      <td>HdrS (0x53726448)，内核标志</td> 
     </tr>
     <tr>
      <td>version</td> 
      <td>0x206</td> 
      <td>2</td> 
      <td>启动协议版本号: major * 64 + minor</td> 
     </tr>
     <tr>
      <td>kernel_version</td> 
      <td>0x20e</td> 
      <td>2</td> 
      <td>内核版本号</td> 
     </tr>
     <tr>
      <td>type_of_loader</td> 
      <td>0x210</td> 
      <td>1</td> 
      <td>Boot loader ID: Boot loader ID * 64 + Version No. <pre>Boot loader IDs:
0 LILO
1 Loadlin
2 bootsect-loader
3 SYSLINUX
4 EtherBoot
5 ELILO
7 GRuB
8 U-BOOT
9 Xen
A Gujin
B Qemu</pre> </td> 
     </tr>
     <tr>
      <td>loadflags</td> 
      <td>0x211</td> 
      <td>1</td> 
      <td>启动选项的掩码。 
       <ul>
        <li>Bit 0: LOADED_HIGH (1表示保护模式代码加载到 0x100000)</li> 
        <li>Bit 7: CAN_USE_HEAP (为1表示 heap_end_ptr 有效)</li> 
       </ul></td> 
     </tr>
     <tr>
      <td>code32_start</td> 
      <td>0x214</td> 
      <td>4</td> 
      <td>内核解压缩前立即跳转到的 32 位 flat-mode 入口</td> 
     </tr>
     <tr>
      <td>ramdisk_image</td> 
      <td>0x218</td> 
      <td>4</td> 
      <td>initramfs 的 32 位线性地址</td> 
     </tr>
     <tr>
      <td>cmd_line_ptr</td> 
      <td>0x228</td> 
      <td>4</td> 
      <td>内核命令行的 32 位线性地址</td> 
     </tr>
    </tbody>
   </table>
   <p>下面我们迎来了真正的起点（start_of_setup），主要流程为：</p> 
   <ol>
    <li>复位硬盘控制器</li> 
    <li>如果 %ss 无效，重新计算栈指针</li> 
    <li>初始化栈，开中断</li> 
    <li>将 cs 设置为 ds，与 setup.elf 的入口地址一致</li> 
    <li>检查主引导扇区末尾标志，如果不正确则跳到 setup_bad</li> 
    <li>清空 bss 段</li> 
    <li>跳到 main（定义在 boot/main.c）</li> 
   </ol>
   <h3>4.3 初始化与保护模式</h3> 
   <p>我们终于暂时离开了汇编代码，走进 “主要” 的启动部分。这一部分在 arch/x86/boot/main.c 中。</p> 
   <p>main() 中的几个函数调用都有比较详细的注释，主要作用是初始化 boot_params，将来会经常被用到。</p> 
   <p>include/asm/bootparam.h 中定义的 boot_params 结构体 (即 zeropage) 在此完成初始化：</p> 
   <ul>
    <li>copy_boot_params() 初始化 boot_params.hdr (将 hdr 复制过来)</li> 
    <li>detect_memory() 初始化 boot_params.e820_map 和 boot_params.e820_entries</li> 
    <li>query_apm_bios() 初始化 apm_bios_info、screen_info</li> 
   </ul>
   <p>go_to_protected_mode() 进入保护模式，代码在 boot/pm.c。</p> 
   <ol>
    <li>realmode_switch_hook()：boot_params.hdr 中有 realmode_swtch，记录了 hook 函数地址，如果有的话就执行之</li> 
    <li>reset_coprecessor(): 重启协处理器</li> 
    <li>make_all_interrupts(): 关闭所有旧 PIC 上的中断。其中的 io_delay 等待 I/O 操作完成。</li> 
    <li>setup_idt(): 初始化中断描述符表 (空的)</li> 
    <li>setup_gdt(): 初始化 GDT: 
     <ul>
      <li>GDT_ENTRY_BOOT_CS</li> 
      <li>GDT_ENTRY_BOOT_DS</li> 
      <li>GDT_ENTRY_BOOT_TSS</li> 
     </ul><p>其中 GDT_ENTRY_BOOT_CS 和 GDT_ENTRY_BOOT_DS 基地址都为零，段限长都是 4G。</p> <p>下面是 GDT 数据结构示意：</p> <p><img src="https://yqfile.alicdn.com/img_efcc20d732407ac73255069fa70219aa.png" alt=""></p> </li> 
    <li>protected_mode_jump(): 汇编代码，下面分析。传参说明：进入保护模式后将采用段访问内存地址，因此要将传入的参数转换为线性地址。</li> 
   </ol>
   <p>下面进入 boot/pmjump.S 中的 protected_mode_jump。</p> 
   <pre> 29 protected_mode_jump:
 30         movl    %edx, %esi              # Pointer to boot_params table
 31 
 32         xorl    %ebx, %ebx
 33         movw    %cs, %bx                # 将实模式的代码段放入 bx
 34         shll    $4, %ebx                # 转换为线性地址
 35         addl    %ebx, 2f                # 将 in_pm32 的实模式地址转换为线性地址
 36 
 37         movw    $__BOOT_DS, %cx         # ds 段选择子
 38         movw    $__BOOT_TSS, %di        # tss 段选择子
 39 
 40         movl    %cr0, %edx
 41         orb     $X86_CR0_PE, %dl        # Protected mode
 42         movl    %edx, %cr0              # 将 cr0 的0位置0是进入保护模式的标志
 43         jmp     1f                      # Short jump to serialize on 386/486
 44 1:
 45         # 下面这段作用是跳转到 in_pm32，由于已经在保护模式，所以需要考虑段的问题
 46         # Transition to 32-bit mode
 47         .byte   0x66, 0xea              # ljmpl opcode
 48 2:      .long   in_pm32                 # offset
 49         .word   __BOOT_CS               # segment
 50 
 51         .size   protected_mode_jump, .-protected_mode_jump
 52 
 53         .code32
 54         .type   in_pm32, @function
 55 in_pm32:        # 下面的注释挺清楚，就不翻译了
 56         # Set up data segments for flat 32-bit mode
 57         movl    %ecx, %ds
 58         movl    %ecx, %es
 59         movl    %ecx, %fs
 60         movl    %ecx, %gs
 61         movl    %ecx, %ss
 62         # The 32-bit code sets up its own stack, but this way we do have
 63         # a valid stack if some debugging hack wants to use it.
 64         addl    %ebx, %esp
 65 
 66         # Set up TR to make Intel VT happy
 67         ltr     %di                     # 这个比较有意思
 68 
 69         # Clear registers to allow for future extensions to the
 70         # 32-bit boot protocol
 71         xorl    %ecx, %ecx
 72         xorl    %edx, %edx
 73         xorl    %ebx, %ebx
 74         xorl    %ebp, %ebp
 75         xorl    %edi, %edi
 76 
 77         # Set up LDTR to make Intel VT happy
 78         lldt    %cx                     # 又是一个骗 CPU 的东西

 79         # eax 是 protected_mode_jump 的第一个参数，即 header.S 中定义的 boot_params.hdr.code32_start，即 vmlinux 的入口地址
 80         jmpl    *%eax                   # Jump to the 32-bit entrypoint
 81 
 82         .size   in_pm32, .-in_pm32
</pre> 
   <h3>4.4 自解压内核</h3> 
   <p>上节末尾的 jmpl 指令把我们带入了 vmlinux 的世界。注意到，vmlinux 是压缩存储的，因此内核首先的工作就是把真正的内核解压出来。</p> 
   <p>根据 Makefile，linux 内核文件有以下几种：</p> 
   <ul>
    <li>vmlinux: 原始的 linux 内核</li> 
    <li>zImage: 经过 gzip 压缩后的 vmlinux，解压到 640KB 内存位置</li> 
    <li>bzImage: 大内核版的 zImage，解压到 1MB 内存位置，现在我们一般都用这个</li> 
    <li>vmlinuz: 指向 zImage 或 bzImage 的链接</li> 
    <li>initrd: init ram disk，用于引导 vmlinuz</li> 
   </ul>
   <p>循着 Makefile 的踪迹，我们找到了 arch/x86/boot/compressed/head_32.S，这就是大内核模式下 0x100000 开始的内存内容。</p> 
   <ol>
    <li>找到 vmlinux 的入口地址，并将其存入 ebp。</li> 
    <li>如果设置了可重入内核，就将 ebp 按照 kernel_alignment 对齐，放入 ebx。</li> 
    <li>确定解压内核的内存地址</li> 
    <li>设置栈</li> 
    <li>将 vmlinux 复制到安全地区（ebx 指定的地方）：保存 esi 到栈中，首先计算出需要复制的字节数目，然后4个字节为一组地复制过去，再从栈中恢复 esi。</li> 
    <li>进入 relocated，清空 BSS，初始化解压函数所用的栈</li> 
    <li>将 decompress_kernel 所用的参数入栈：内核加载地址、内核长度、压缩内核安全地址、堆地址、启动参数结构体指针。</li> 
    <li>调用 decompress_kernel 解压内核</li> 
    <li>如果设置了可重入内核，进行一些 relocate</li> 
    <li>跳转到解压后的内核。</li> 
   </ol>
   <p>至此，arch/x86/boot 下的流程基本分析完毕。</p> 
   <h3>4.5 startup_32</h3> 
   <p>vmlinux 是从哪里来的呢？不知道是否是 Linus 有意为我们增加难度 (其实是我对 make 不熟悉)，生成 vmlinux 的命令在源码根目录的隐藏文件 .vmlinux.cmd 中。</p> 
   <pre>md_vmlinux := ld -m elf_i386 --build-id -o vmlinux -T arch/x86/kernel/vmlinux.lds arch/x86/kernel/head_32.o arch/x86/kern
el/head32.o arch/x86/kernel/init_task.o  init/built-in.o --start-group  usr/built-in.o  arch/x86/mach-generic/built-in.o
arch/x86/kernel/built-in.o  arch/x86/mm/built-in.o  arch/x86/mach-default/built-in.o  arch/x86/crypto/built-in.o  arch/x86
/vdso/built-in.o  kernel/built-in.o  mm/built-in.o  fs/built-in.o  ipc/built-in.o  security/built-in.o  crypto/built-in.o 
block/built-in.o  lib/lib.a  arch/x86/lib/lib.a  lib/built-in.o  arch/x86/lib/built-in.o  drivers/built-in.o  sound/built 
-in.o  arch/x86/pci/built-in.o  arch/x86/oprofile/built-in.o  arch/x86/power/built-in.o  net/built-in.o --end-group .tmp_k
allsyms2.o</pre> 
   <p>真正的内核入口是 arch/x86/kernel/head_32.S (为什么也叫 head_32.S？)</p> 
   <p>汇编函数 startup_32 依次完成以下动作：</p> 
   <ol>
    <li> <p><strong>初始化参数</strong></p> 
     <ul>
      <li>初始化 GDT。boot_gdt_descr 在数据区中记载了 GDT 表首地址。 <pre>lgdt pa(boot_gdt_descr)</pre> </li> 
      <li>清空 BSS 段</li> 
      <li>复制实模式中的 boot_params 结构体</li> 
      <li>复制命令行参数到 boot_command_line (供 init/main.c 使用)</li> 
      <li>有关虚拟环境的一些配置</li> 
     </ul></li> 
    <li> <p><strong>开启分页机制</strong></p> <p>尽管我们已经在保护模式中，但只有段机制而没有启用页机制。这里设置全局页目录与页表项，并开启分页机制。</p> <p>下图示意了 Linux 的分页机制（From ULK）。</p> <p><img src="https://yqfile.alicdn.com/img_3b2f04b3b4a3dc6e23f8532586a23f38.png" alt=""></p> 
     <ul>
      <li> <p>如果启用了 PAE，即物理地址扩展到 64G 的机制，不作分析。</p> </li> 
      <li> <p>不然，就是通常的 4G 线性地址空间。__PAGE_OFFSET 是内核编译时配置的内核地址空间偏移，默认为 3G。默认配置下，进程的用户态地址空间为 0~3G，高 1G 是内核地址空间。</p> <p>全局页目录大小为 4KB，每项大小为 4B，可以表示 4MB 的线性范围，因此页目录的大小是 __PAGE_OFFSET &gt;&gt; 20。</p> <pre>page_pde_offset = (__PAGE_OFFSET &gt;&gt; 20);</pre> </li> 
      <li> <p>初始化页表首地址 %edi、全局页目录地址 %edx、PTE 属性（页目录和页表的每项 4 Byte 中后 12 位是属性，这里预先填充 0x67）</p> <pre>230         movl $pa(pg0), %edi
231         movl $pa(swapper_pg_dir), %edx
232         movl $PTE_ATTR, %eax
</pre> </li> 
      <li> <p>下面是一个双层循环，外层循环填充页目录，内层循环填充页表。</p> <pre>233 10:
		# %edi: 页表首地址
234         leal PDE_ATTR(%edi),%ecx                /* Create PDE entry */
		# 将页目录项填充到页目录中，%edx 为页目录地址
235         movl %ecx,(%edx)                        /* Store identity PDE entry */
236         movl %ecx,page_pde_offset(%edx)         /* Store kernel PDE entry */
		# 填充下一个页目录项
237         addl $4,%edx
238         movl $1024, %ecx
239 11:		# 内层循环，填充 4KB 的 PTD
240         stosl				# es:edi= eax,edi++
		# 表面上看是将 0x1000 加到属性上，事实上是 %eax 的后 12 位属性不变，前面的 20 位页地址加 1。
241         addl $0x1000,%eax
		# 继续内层循环
242         loop 11b
243         /*
244          * End condition: we must map up to and including INIT_MAP_BEYOND_END
245          * bytes beyond the end of our own page tables; the +0x007 is
246          * the attribute bits
247          */
		# 计算何时应停止
248         leal (INIT_MAP_BEYOND_END+PTE_ATTR)(%edi),%ebp
		# 如果 %eax &lt; %ebp，继续外层循环
249         cmpl %ebp,%eax
250         jb 10b
</pre> </li> 
      <li> <p>添加页目录项的最后一项，页表地址为 swapper_pg_fixmap，用于 fixmap area</p> <pre>251         movl %edi,pa(init_pg_tables_end)
252 
253         /* Do early initialization of the fixmap area */
254         movl $pa(swapper_pg_fixmap)+PDE_ATTR,%eax
255         movl %eax,pa(swapper_pg_dir+0xffc)
</pre> </li> 
      <li> <p>有关对称多处理器（SMP）的处理</p> </li> 
      <li> <p>一些 CPU 参数相关的判断和处理</p> </li> 
      <li> <p>开启分页机制</p> <pre>		# 将页表首地址（swapper_pg_dir）放入 cr3
331         movl $pa(swapper_pg_dir),%eax
332         movl %eax,%cr3          /* set the page table pointer.. */
		# 设置 cr0 的 paging 位，打开 cr0 的分页机制
333         movl %cr0,%eax
334         orl  $X86_CR0_PG,%eax
335         movl %eax,%cr0          /* ..and set paging (PG) bit */
		# 目前已经开启分页机制，完全进入保护模式。
336         ljmp $__BOOT_CS,$1f     /* Clear prefetch and normalize %eip */
</pre> </li> 
     </ul></li> 
    <li> <p><strong>初始化 Eflags</strong></p> </li> 
    <li> <p><strong>初始化中断向量表</strong></p> <p>在实模式中，已经初始化了 IDT，不过现在我们要对保护模式再做一次这样的工作。由于这段代码比较长，放在了单独的函数里。</p> <pre>485 setup_idt:
		# 默认中断处理例程，后面有定义，做一件事情：如果开启了 CONFIG_PRINTK，就通过 printk 输出内核信息。
486         lea ignore_int,%edx
		# 这里是内核代码段，注意已经是保护模式了，所以要用代码段选择子
487         movl $(__KERNEL_CS &lt;&lt; 16),%eax
488         movw %dx,%ax            /* selector = 0x0010 = cs */
489         movw $0x8E00,%dx        /* interrupt gate - dpl=0, present */
490 
        # 载入 IDT 表的首地址
491         lea idt_table,%edi
        # 共有 256 个中断向量
492         mov $256,%ecx
493 rp_sidt:
        # 这是一个循环，用默认中断处理例程初始化 256 个中断向量
494         movl %eax,(%edi)
495         movl %edx,4(%edi)
496         addl $8,%edi
497         dec %ecx
498         jne rp_sidt
499 
		# 设置几个已定义的中断向量
		# 宏定义
500 .macro  set_early_handler handler,trapno
501         lea \handler,%edx
502         movl $(__KERNEL_CS &lt;&lt; 16),%eax
503         movw %dx,%ax
504         movw $0x8E00,%dx        /* interrupt gate - dpl=0, present */
505         lea idt_table,%edi
506         movl %eax,8*\trapno(%edi)
507         movl %edx,8*\trapno+4(%edi)
508 .endm
509 		# 预先设置的中断向量
510         set_early_handler handler=early_divide_err,trapno=0			# 被零除
511         set_early_handler handler=early_illegal_opcode,trapno=6		# 操作码异常
512         set_early_handler handler=early_protection_fault,trapno=13		# 保护错误
513         set_early_handler handler=early_page_fault,trapno=14		# 缺页异常
514		# 后面一段代码定义了这四个中断向量的中断处理例程。
		# 它们都调用了 early_fault，即将当前状态、中断向量号等信息通过 early_printk 或 printk 输出。
515         ret
</pre> </li> 
    <li> <p><strong>检查处理器类型</strong></p> 
     <ul>
      <li>检查是 486 还是 386</li> 
      <li>get vendor info</li> 
      <li>如果是 486，就 set AM, WP, NE, MP；如果是 386，就 set MP</li> 
      <li>save PG, PE, ET</li> 
      <li>check ET for 287/387</li> 
     </ul></li> 
    <li> <p><strong>载入 GDT、IDT</strong></p> 
     <ul>
      <li>重新载入修改 GDT 后的段寄存器</li> 
      <li>DS/ES 包含着默认用户段</li> 
      <li>清除 GS、LDT</li> 
     </ul></li> 
    <li> <p><strong>i386_start_kernel</strong></p> <p>如果是 SMP 架构，则由第一个 CPU 调用 start_kernel，其余 CPUs 调用 initialize_secondary</p> <p>跳转到 i386_start_kernel（在 arch/x86/kernel/head32.c）</p> </li> 
   </ol>
   <p>head_32.S 中的其余代码是 BSS 段、数据段。</p> 
   <p>其中，下面这段数据描述了发生未知异常时内核输出的调试信息。</p> 
   <pre>655 int_msg:
656         .asciz "Unknown interrupt or fault at EIP %p %p %p\n"
657 
658 fault_msg:
659 /* fault info: */
660         .ascii "BUG: Int %d: CR2 %p\n"
661 /* pusha regs: */
662         .ascii "     EDI %p  ESI %p  EBP %p  ESP %p\n"
663         .ascii "     EBX %p  EDX %p  ECX %p  EAX %p\n"
664 /* fault frame: */
665         .ascii "     err %p  EIP %p   CS %p  flg %p\n"
666         .ascii "Stack: %p %p %p %p %p %p %p %p\n"
667         .ascii "       %p %p %p %p %p %p %p %p\n"
668         .asciz "       %p %p %p %p %p %p %p %p\n"
</pre> 
   <p>下图为 x86 体系结构下的段描述符格式（From ULK）。</p> 
   <p><img src="https://yqfile.alicdn.com/img_3b2f04b3b4a3dc6e23f8532586a23f38.png" alt=""></p> 
   <p>arch/x86/kernel/head32.c 中的 i386_start_kernel 只有一条语句 start_kernel()，将跳转到体系结构无关部分的 init/main.c line 534，执行核心数据结构初始化。</p> 
   <h2>5 内核初始化：体系结构无关部分</h2> 
   <h3>5.1 核心数据结构初始化</h3> 
   <p>start_kernel 为什么值得开启新的一章呢？因为我们已经跳出了体系结构相关部分，离开了复杂的汇编代码，可以在 C 语言的世界里自由翱翔了。</p> 
   <pre>本节摘抄自参考文献：Linux启动过程综述</pre> 
   <p>start_kernel()中调用了一系列初始化函数，以完成kernel本身的设置。这些动作有的是公共的，有的则是需要配置的才会执行的。</p> 
   <ul>
    <li>输出Linux版本信息（printk(linux_banner)）</li> 
    <li>设置与体系结构相关的环境（setup_arch()）</li> 
    <li>页表结构初始化（paging_init()）</li> 
    <li>使用"arch/alpha/kernel/entry.S"中的入口点设置系统自陷入口（trap_init()）</li> 
    <li>使用alpha_mv结构和entry.S入口初始化系统IRQ（init_IRQ()）</li> 
    <li>核心进程调度器初始化（包括初始化几个缺省的Bottom-half，sched_init()）</li> 
    <li>时间、定时器初始化（包括读取CMOS时钟、估测主频、初始化定时器中断等，time_init()）</li> 
    <li>提取并分析核心启动参数（从环境变量中读取参数，设置相应标志位等待处理，（parse_options()）</li> 
    <li>控制台初始化（为输出信息而先于PCI初始化，console_init()）</li> 
    <li>剖析器数据结构初始化（prof_buffer和prof_len变量）</li> 
    <li>核心Cache初始化（描述Cache信息的Cache，kmem_cache_init()）</li> 
    <li>延迟校准（获得时钟jiffies与CPU主频ticks的延迟，calibrate_delay()）</li> 
    <li>内存初始化（设置内存上下界和页表项初始值，mem_init()）</li> 
    <li>创建和设置内部及通用cache（"slab_cache"，kmem_cache_sizes_init()）</li> 
    <li>创建uid taskcount SLAB cache（"uid_cache"，uidcache_init()）</li> 
    <li>创建文件cache（"files_cache"，filescache_init()）</li> 
    <li>创建目录cache（"dentry_cache"，dcache_init()）</li> 
    <li>创建与虚存相关的cache（"vm_area_struct"，"mm_struct"，vma_init()）</li> 
    <li>块设备读写缓冲区初始化（同时创建"buffer_head"cache用户加速访问，buffer_init()）</li> 
    <li>创建页cache（内存页hash表初始化，page_cache_init()）</li> 
    <li>创建信号队列cache（"signal_queue"，signals_init()）</li> 
    <li>初始化内存inode表（inode_init()）</li> 
    <li>创建内存文件描述符表（"filp_cache"，file_table_init()）</li> 
    <li>检查体系结构漏洞（对于alpha，此函数为空，check_bugs()）</li> 
    <li>SMP机器其余CPU（除当前引导CPU）初始化（对于没有配置SMP的内核，此函数为空，smp_init()）</li> 
    <li>启动init过程（创建第一个核心线程，调用init()函数，原执行序列调用cpu_idle() 等待调度，init()）</li> 
   </ul>
   <p>至此，基本的核心环境已经建立起来了。</p> 
   <h3>5.2 设备初始化</h3> 
   <pre>本节摘抄自参考文献：Linux启动过程综述</pre> 
   <p>init()函数作为核心线程，首先锁定内核（仅对SMP机器有效），然后调用 do_basic_setup()完成外设及其驱动程序的加载和初始化。过程如下：</p> 
   <ul>
    <li>总线初始化（比如pci_init()）</li> 
    <li>网络初始化（初始化网络数据结构，包括sk_init()、skb_init()和proto_init()三部分，在proto_init()中，将调用protocols结构中包含的所有协议的初始化过程，sock_init()）</li> 
    <li>创建bdflush核心线程（bdflush()过程常驻核心空间，由核心唤醒来清理被写过的内存缓冲区，当bdflush()由kernel_thread()启动后，它将自己命名为kflushd）</li> 
    <li>创建kupdate核心线程（kupdate()过程常驻核心空间，由核心按时调度执行，将内存缓冲区中的信息更新到磁盘中，更新的内容包括超级块和inode表）</li> 
    <li>设置并启动核心调页线程kswapd（为了防止kswapd启动时将版本信息输出到其他信息中间，核心线调用kswapd_setup()设置kswapd运行所要求的环境，然后再创建 kswapd核心线程）</li> 
    <li>创建事件管理核心线程（start_context_thread()函数启动context_thread()过程，并重命名为keventd）</li> 
    <li>设备初始化（包括并口parport_init()、字符设备chr_dev_init()、块设备 blk_dev_init()、SCSI设备scsi_dev_init()、网络设备net_dev_init()、磁盘初始化及分区检查等等，device_setup()）</li> 
    <li>执行文件格式设置（binfmt_setup()）</li> 
    <li>启动任何使用__initcall标识的函数（方便核心开发者添加启动函数，do_initcalls()）</li> 
    <li>文件系统初始化（filesystem_setup()）</li> 
    <li>安装root文件系统（mount_root()）</li> 
   </ul>
   <p>至此do_basic_setup()函数返回init()，在释放启动内存段（free_initmem()）并给内核解锁以后，init()打开/dev/console设备，重定向stdin、stdout和stderr到控制台，最后，搜索文件系统中的init程序（或者由init=命令行参数指定的程序），并使用 execve()系统调用加载执行init程序。</p> 
   <p>init()函数到此结束，内核的引导部分也到此结束了，这个由start_kernel()创建的第一个线程已经成为一个用户模式下的进程了。此时系统中存在着六个运行实体：</p> 
   <ul>
    <li>start_kernel()本身所在的执行体，这其实是一个"手工"创建的线程，它在创建了init()线程以后就进入cpu_idle()循环了，它不会在进程（线程）列表中出现</li> 
    <li>init线程，由start_kernel()创建，当前处于用户态，加载了init程序</li> 
    <li>kflushd核心线程，由init线程创建，在核心态运行bdflush()函数</li> 
    <li>kupdate核心线程，由init线程创建，在核心态运行kupdate()函数</li> 
    <li>kswapd核心线程，由init线程创建，在核心态运行kswapd()函数</li> 
    <li>keventd核心线程，由init线程创建，在核心态运行context_thread()函数</li> 
   </ul>
   <h2>参考文献</h2> 
   <ul>
    <li><a href="http://staff.ustc.edu.cn/~xlanchen/2011FallULK/ULK2011Fall.html" rel="nofollow">陈香兰老师《Linux内核源代码导读》讲义</a></li> 
    <li>Linux Kernel Documentation</li> 
    <li>Understanding the Linux Kernel, Third Edition</li> 
    <li>Wikipedia</li> 
    <li>CSDN blog:&nbsp;<a href="http://blog.csdn.net/alais/article/details/5129005" rel="nofollow">BIOS 启动过程分析</a> </li> 
    <li>Windows Internals, Fifth Edition</li> 
    <li>IBM developerWorks:&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/kernel/startup/index.html" rel="nofollow">Linux 启动过程综述</a> </li> 
    <li><a href="http://cnsnap.cn.freebsd.org/doc/zh_CN.GB2312/books/arch-handbook/index.html" rel="nofollow">FreeBSD 系统结构手册</a></li> 
   </ul>
   <p>涉及的代码：</p> 
   <ul>
    <li>Linux 2.6.26 Kernel Source</li> 
    <li>GRUB source code</li> 
    <li>AWARD BIOS source code</li> 
   </ul>
   <hr>
   <p>Copyright © 2012 李博杰 PB10000603</p> 
   <p>This document is available from&nbsp;<a href="http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html" rel="nofollow">http://home.ustc.edu.cn/~boj/courses/linux_kernel/1_boot.html</a></p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
