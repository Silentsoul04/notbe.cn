<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux查看CPU和内存使用情况【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html    在系统维护的过程中，随时可能有需要查看 CPU 使用率，并根据相应信息分析系统状况的需要。在 CentOS 中，可以通过 top 命令来查看 CPU...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/07/25/weixin_34368949_90128672.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux查看CPU和内存使用情况【转】</h1>
    <p class="post-meta">Jul 25, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>转自：<a href="http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html" rel="nofollow">http://www.cnblogs.com/xd502djj/archive/2011/03/01/1968041.html</a></p> 
   <p>在系统维护的过程中，随时可能有需要查看 CPU 使用率，并根据相应信息分析系统状况的需要。在 CentOS 中，可以通过 top 命令来查看 CPU 使用状况。运行 top 命令后，CPU 使用状态会以全屏的方式显示，并且会处在对话的模式 -- 用基于 top 的命令，可以控制显示方式等等。退出 top 的命令为 q （在 top 运行中敲 q 键一次）。</p> 
   <p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器</p> 
   <p>　　可以直接使用top命令后，查看%MEM的内容。可以选择按进程查看或者按用户查看，如想查看oracle用户的进程内存使用情况的话可以使用如下的命令：<br>　　$ top -u oracle</p> 
   <p>内容解释：</p> 
   <blockquote> 
    <p>　　PID：进程的ID<br>　　USER：进程所有者<br>　　PR：进程的优先级别，越小越优先被执行<br>　　NInice：值<br>　　VIRT：进程占用的虚拟内存<br>　　RES：进程占用的物理内存<br>　　SHR：进程使用的共享内存<br>　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数<br>　　%CPU：进程占用CPU的使用率<br>　　%MEM：进程使用的物理内存和总内存的百分比<br>　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。<br>　　COMMAND：进程启动命令名称</p> 
   </blockquote> 
   <p>　　操作实例:</p> 
   <p>　　在命令行中输入 “top”</p> 
   <p>　　即可启动 top</p> 
   <p>　　top 的全屏对话模式可分为3部分：系统信息栏、命令输入栏、进程列表栏。</p> 
   <p>　　第一部分 -- 最上部的 系统信息栏 ：</p> 
   <p>　　第一行（top）：</p> 
   <p>　　　　“00:11:04”为系统当前时刻；</p> 
   <p>　　　　“3:35”为系统启动后到现在的运作时间；</p> 
   <p>　　　　“2 users”为当前登录到系统的用户，更确切的说是登录到用户的终端数 -- 同一个用户同一时间对系统多个终端的连接将被视为多个用户连接到系统，这里的用户数也将表现为终端的数目；</p> 
   <p>　　　　“load average”为当前系统负载的平均值，后面的三个值分别为1分钟前、5分钟前、15分钟前进程的平均数，一般的可以认为这个数值超过 CPU 数目时，CPU 将比较吃力的负载当前系统所包含的进程；</p> 
   <p>　　第二行（Tasks）：</p> 
   <p>　　　　“59 total”为当前系统进程总数；</p> 
   <p>　　　　“1 running”为当前运行中的进程数；</p> 
   <p>　　　　“58 sleeping”为当前处于等待状态中的进程数；</p> 
   <p>　　　　“0 stoped”为被停止的系统进程数；</p> 
   <p>　　　　“0 zombie”为被复原的进程数；</p> 
   <p>　　第三行（Cpus）：</p> 
   <p>　　　　分别表示了 CPU 当前的使用率；</p> 
   <p>　　第四行（Mem）：</p> 
   <p>　　　　分别表示了内存总量、当前使用量、空闲内存量、以及缓冲使用中的内存量；</p> 
   <p>　　第五行（Swap）：</p> 
   <p>　　　　表示类别同第四行（Mem），但此处反映着交换分区（Swap）的使用情况。通常，交换分区（Swap）被频繁使用的情况，将被视作物理内存不足而造成的。</p> 
   <p>　　第二部分 -- 中间部分的内部命令提示栏：</p> 
   <p>　　top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下表：</p> 
   <p>　　s</p> 
   <p>　　- 改变画面更新频率</p> 
   <p>　　l - 关闭或开启第一部分第一行 top 信息的表示</p> 
   <p>　　t - 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示</p> 
   <p>　　m - 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示</p> 
   <p>　　N - 以 PID 的大小的顺序排列表示进程列表（第三部分后述）</p> 
   <p>　　P - 以 CPU 占用率大小的顺序排列进程列表 （第三部分后述）</p> 
   <p>　　M - 以内存占用率大小的顺序排列进程列表 （第三部分后述）</p> 
   <p>　　h - 显示帮助</p> 
   <p>　　n - 设置在进程列表所显示进程的数量</p> 
   <p>　　q - 退出 top</p> 
   <p>　　s -</p> 
   <p>　　改变画面更新周期</p> 
   <p>　　第三部分 -- 最下部分的进程列表栏：</p> 
   <p>　　以 PID 区分的进程列表将根据所设定的画面更新时间定期的更新。通过 top 内部命令可以控制此处的显示方式</p> 
   <p><strong>pmap</strong></p> 
   <p>可以根据进程查看进程相关信息占用的内存情况，(进程号可以通过ps查看)如下所示：<br>　　$ pmap -d 5647</p> 
   <p>&nbsp;</p> 
   <p><strong>ps</strong></p> 
   <p>　　如下例所示：<br>　　$ ps -e -o 'pid,comm,args,pcpu,rsz,vsz,stime,user,uid'&nbsp; 其中rsz是是实际内存<br>　　$ ps -e -o 'pid,comm,args,pcpu,rsz,vsz,stime,user,uid' | grep oracle |&nbsp; sort -nrk</p> 
   <p>　　其中rsz为实际内存，上例实现按内存排序，由大到小</p> 
   <p>在Linux下查看内存我们一般用free命令：<br>[root@scs-2 tmp]# free<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free&nbsp;&nbsp;&nbsp;&nbsp; shared&nbsp;&nbsp;&nbsp; buffers&nbsp;&nbsp;&nbsp;&nbsp; cached<br>Mem:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3266180&nbsp;&nbsp;&nbsp; 3250004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16176&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 110652&nbsp;&nbsp;&nbsp; 2668236<br>-/+ buffers/cache:&nbsp;&nbsp;&nbsp;&nbsp; 471116&nbsp;&nbsp;&nbsp; 2795064<br>Swap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048276&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80160&nbsp;&nbsp;&nbsp; 1968116</p> 
   <p>下面是对这些数值的解释：<br>total:总计物理内存的大小。<br>used:已使用多大。<br>free:可用有多少。<br>Shared:多个进程共享的内存总额。<br>Buffers/cached:磁盘缓存的大小。<br>第三行(-/+ buffers/cached):<br>used:已使用多大。<br>free:可用有多少。<br>第四行就不多解释了。<br>区别：第二行(mem)的used/free与第三行(-/+ buffers/cache) used/free的区别。 这两个的区别在于使用的角度来看，第一行是从OS的角度来看，因为对于OS，buffers/cached 都是属于被使用，所以他的可用内存是16176KB,已用内存是3250004KB,其中包括，内核（OS）使用+Application(X, oracle,etc)使用的+buffers+cached.<br>第三行所指的是从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached会很快地被回收。<br>所以从应用程序的角度来说，可用内存=系统free memory+buffers+cached。<br>如上例：<br>2795064=16176+110652+2668236</p> 
   <p>接下来解释什么时候内存会被交换，以及按什么方交换。 当可用内存少于额定值的时候，就会开会进行交换。<br>如何看额定值：<br>cat /proc/meminfo</p> 
   <p>[root@scs-2 tmp]# cat /proc/meminfo<br>MemTotal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3266180 kB<br>MemFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17456 kB<br>Buffers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 111328 kB<br>Cached:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2664024 kB<br>SwapCached:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 kB<br>Active:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 467236 kB<br>Inactive:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2644928 kB<br>HighTotal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 kB<br>HighFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 kB<br>LowTotal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3266180 kB<br>LowFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17456 kB<br>SwapTotal:&nbsp;&nbsp;&nbsp;&nbsp; 2048276 kB<br>SwapFree:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1968116 kB<br>Dirty:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 kB<br>Writeback:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 kB<br>Mapped:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 345360 kB<br>Slab:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 112344 kB<br>Committed_AS:&nbsp;&nbsp; 535292 kB<br>PageTables:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2340 kB<br>VmallocTotal: 536870911 kB<br>VmallocUsed:&nbsp;&nbsp;&nbsp; 272696 kB<br>VmallocChunk: 536598175 kB<br>HugePages_Total:&nbsp;&nbsp;&nbsp;&nbsp; 0<br>HugePages_Free:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>Hugepagesize:&nbsp;&nbsp;&nbsp;&nbsp; 2048 kB</p> 
   <p>用free -m查看的结果：<br>[root@scs-2 tmp]# free -m&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free&nbsp;&nbsp;&nbsp;&nbsp; shared&nbsp;&nbsp;&nbsp; buffers&nbsp;&nbsp;&nbsp;&nbsp; cached<br>Mem:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3189&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3173&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2605<br>-/+ buffers/cache:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 460&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2729<br>Swap:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1921</p> 
   <p><br>查看/proc/kcore文件的大小（内存镜像）：<br>[root@scs-2 tmp]# ll -h /proc/kcore&nbsp;<br>-r-------- 1 root root 4.1G Jun 12 12:04 /proc/kcore</p> 
   <p>备注：</p> 
   <p>占用内存的测量</p> 
   <p>测量一个进程占用了多少内存，linux为我们提供了一个很方便的方法，/proc目录为我们提供了所有的信息，实际上top等工具也通过这里来获取相应的信息。</p> 
   <p>/proc/meminfo 机器的内存使用信息</p> 
   <p>/proc/pid/maps pid为进程号，显示当前进程所占用的虚拟地址。</p> 
   <p>/proc/pid/statm 进程所占用的内存</p> 
   <p>[root@localhost ~]# cat /proc/self/statm</p> 
   <p>654 57 44 0 0 334 0</p> 
   <p>输出解释</p> 
   <p>CPU 以及CPU0。。。的每行的每个参数意思（以第一行为例）为：</p> 
   <p>参数 解释 /proc//status</p> 
   <p>Size (pages) 任务虚拟地址空间的大小 VmSize/4</p> 
   <p>Resident(pages) 应用程序正在使用的物理内存的大小 VmRSS/4</p> 
   <p>Shared(pages) 共享页数 0</p> 
   <p>Trs(pages) 程序所拥有的可执行虚拟内存的大小 VmExe/4</p> 
   <p>Lrs(pages) 被映像到任务的虚拟内存空间的库的大小 VmLib/4</p> 
   <p>Drs(pages) 程序数据段和用户态的栈的大小 （VmData+ VmStk ）4</p> 
   <p>dt(pages) 04</p> 
   <p>查看机器可用内存</p> 
   <p>/proc/28248/&gt;free</p> 
   <p>total used free shared buffers cached</p> 
   <p>Mem: 1023788 926400 97388 0 134668 503688</p> 
   <p>-/+ buffers/cache: 288044 735744</p> 
   <p>Swap: 1959920 89608 1870312</p> 
   <p>我们通过free命令查看机器空闲内存时，会发现free的值很小。这主要是因为，在linux中有这么一种思想，内存不用白不用，因此它尽可能的cache和buffer一些数据，以方便下次使用。但实际上这些内存也是可以立刻拿来使用的。</p> 
   <p>所以 空闲内存=free+buffers+cached=total-used</p> 
   <p>top命令 是Linux下常用的性能 分析工具 ，能够实时显示系统 中各个进程的资源占用状况，类似于Windows的任务管理 器。下面详细介绍它的使用方法。</p> 
   <p>top - 02:53:32 up 16 days,&nbsp; 6:34, 17 users,&nbsp; load average: 0.24, 0.21, 0.24<br>Tasks: 481 total,&nbsp;&nbsp; 3 running, 474 sleeping,&nbsp;&nbsp; 0 stopped,&nbsp;&nbsp; 4 zombie<br>Cpu(s): 10.3%us,&nbsp; 1.8%sy,&nbsp; 0.0%ni, 86.6%id,&nbsp; 0.5%wa,&nbsp; 0.2%hi,&nbsp; 0.6%si,&nbsp; 0.0%st<br>Mem:&nbsp;&nbsp; 4042764k total,&nbsp; 4001096k used,&nbsp;&nbsp;&nbsp; 41668k free,&nbsp;&nbsp; 383536k buffers<br>Swap:&nbsp; 2104472k total,&nbsp;&nbsp;&nbsp;&nbsp; 7900k used,&nbsp; 2096572k free,&nbsp; 1557040k cached</p> 
   <p>&nbsp; PID USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PR&nbsp; NI&nbsp; VIRT&nbsp; RES&nbsp; SHR S %CPU %MEM&nbsp;&nbsp;&nbsp; TIME+&nbsp; COMMAND<br>32497 jacky&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp; 0&nbsp; 669m 222m&nbsp; 31m R&nbsp;&nbsp; 10&nbsp; 5.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 29:27.62 firefox<br>&nbsp;4788 yiuwing&nbsp;&nbsp; 20&nbsp;&nbsp; 0&nbsp; 257m&nbsp; 18m&nbsp; 13m S&nbsp;&nbsp;&nbsp; 5&nbsp; 0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5:42.44 konsole<br>&nbsp;5657 Liuxiaof&nbsp; 20&nbsp;&nbsp; 0&nbsp; 585m 159m&nbsp; 30m S&nbsp;&nbsp;&nbsp; 4&nbsp; 4.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5:25.06 firefox<br>&nbsp;4455 xiefc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp; 0&nbsp; 542m&nbsp; 124m&nbsp; 30m R&nbsp;&nbsp;&nbsp; 4&nbsp; 3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7:23.03 firefox<br>&nbsp;6188 Liuxiaof&nbsp; 20&nbsp;&nbsp; 0&nbsp; 191m&nbsp;&nbsp; 17m&nbsp; 13m S&nbsp;&nbsp;&nbsp; 4&nbsp; 0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:01.16 konsole<br>&nbsp;</p> 
   <p><br>统计信息区前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime&nbsp; 命令的执行结果。其内容如下：</p> 
   <p>01:06:48&nbsp; 当前时间&nbsp;&nbsp;<br>up 1:22&nbsp; 系统运行 时间，格式为时:分&nbsp;&nbsp;<br>1 user&nbsp; 当前登录用户 数&nbsp;&nbsp;<br>load average: 0.06, 0.60, 0.48&nbsp; 系统负载 ，即任务队列的平均长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 三个数值分别为&nbsp; 1分钟、5分钟、15分钟前到现在的平均值。&nbsp;</p> 
   <p><br>第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下：</p> 
   <p>Tasks: 29 total&nbsp; 进程总数&nbsp;&nbsp;<br>1 running&nbsp; 正在运行的进程数&nbsp;&nbsp;<br>28 sleeping&nbsp; 睡眠的进程数&nbsp;&nbsp;<br>0 stopped&nbsp; 停止的进程数&nbsp;&nbsp;<br>0 zombie&nbsp; 僵尸进程数&nbsp;&nbsp;<br>Cpu(s): 0.3% us&nbsp; 用户空间占用CPU百分比&nbsp;&nbsp;<br>1.0% sy&nbsp; 内核 空间占用CPU百分比&nbsp;&nbsp;<br>0.0% ni&nbsp; 用户进程空间内改变过优先级的进程占用CPU百分比&nbsp;&nbsp;<br>98.7% id&nbsp; 空闲CPU百分比&nbsp;&nbsp;<br>0.0% wa&nbsp; 等待输入输出的CPU时间百分比&nbsp;&nbsp;<br>0.0% hi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>0.0% si&nbsp;&nbsp;&nbsp;&nbsp;</p> 
   <p><br>最后两行为内存 信息。内容如下：</p> 
   <p>Mem: 191272k total&nbsp; 物理内存总量&nbsp;&nbsp;<br>173656k used&nbsp; 使用的物理内存总量&nbsp;&nbsp;<br>17616k free&nbsp; 空闲内存总量&nbsp;&nbsp;<br>22052k buffers&nbsp; 用作内核缓存 的内存量&nbsp;&nbsp;<br>Swap: 192772k total&nbsp; 交换区总量&nbsp;&nbsp;<br>0k used&nbsp; 使用的交换区总量&nbsp;&nbsp;<br>192772k free&nbsp; 空闲交换区总量&nbsp;&nbsp;<br>123988k cached&nbsp; 缓冲的交换区总量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该数值即为这些内容已存在于内存中 的交换区的大小。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 相应的内存再次被换出时可不必再对交换区写入。&nbsp;</p> 
   <p><br>进程信息区统计信息区域的下方显示了各个进程的详细信息。首先来认识一下各列的含义。</p> 
   <p>序号&nbsp; 列名&nbsp; 含义&nbsp;&nbsp;<br>a&nbsp; PID&nbsp; 进程id&nbsp;&nbsp;<br>b&nbsp; PPID&nbsp; 父进程id&nbsp;&nbsp;<br>c&nbsp; RUSER&nbsp; Real user name&nbsp;&nbsp;<br>d&nbsp; UID&nbsp; 进程所有者的用户id&nbsp;&nbsp;<br>e&nbsp; USER&nbsp; 进程所有者的用户名&nbsp;&nbsp;<br>f&nbsp; GROUP&nbsp; 进程所有者的组名&nbsp;&nbsp;<br>g&nbsp; TTY&nbsp; 启动进程的终端名。不是从终端启动的进程则显示为 ?&nbsp;&nbsp;<br>h&nbsp; PR&nbsp; 优先级&nbsp;&nbsp;<br>i&nbsp; NI&nbsp; nice值。负值表示高优先级，正值表示低优先级&nbsp;&nbsp;<br>j&nbsp; P&nbsp; 最后使用的CPU，仅在多CPU环境 下有意义&nbsp;&nbsp;<br>k&nbsp; %CPU&nbsp; 上次更新到现在的CPU时间占用百分比&nbsp;&nbsp;<br>l&nbsp; TIME&nbsp; 进程使用的CPU时间总计，单位秒&nbsp;&nbsp;<br>m&nbsp; TIME+&nbsp; 进程使用的CPU时间总计，单位1/100秒&nbsp;&nbsp;<br>n&nbsp; %MEM&nbsp; 进程使用的物理内存 百分比&nbsp;&nbsp;<br>o&nbsp; VIRT&nbsp; 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES&nbsp;&nbsp;<br>p&nbsp; SWAP&nbsp; 进程使用的虚拟内存中，被换出的大小，单位kb。&nbsp;&nbsp;<br>q&nbsp; RES&nbsp; 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA&nbsp;&nbsp;<br>r&nbsp; CODE&nbsp; 可执行代码占用的物理 内存大小，单位kb&nbsp;&nbsp;<br>s&nbsp; DATA&nbsp; 可执行代码以外的部分(数据 段+栈)占用的物理 内存大小，单位kb&nbsp;&nbsp;<br>t&nbsp; SHR&nbsp; 共享内存大小，单位kb&nbsp;&nbsp;<br>u&nbsp; nFLT&nbsp; 页面错误次数&nbsp;&nbsp;<br>v&nbsp; nDRT&nbsp; 最后一次写入到现在，被修改过的页面数。&nbsp;&nbsp;<br>w&nbsp; S&nbsp; 进程状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D =不可中断的睡眠状态<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R =运行<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S =睡眠<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T =跟踪/停止<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z =僵尸进程&nbsp;&nbsp;<br>x&nbsp; COMMAND&nbsp; 命令名/命令行&nbsp;&nbsp;<br>y&nbsp; WCHAN&nbsp; 若该进程在睡眠，则显示睡眠中的系统函数名&nbsp;&nbsp;<br>z&nbsp; Flags&nbsp; 任务标志，参考 sched.h&nbsp;</p> 
   <p><br>默认情况下仅显示比较重要的&nbsp; PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND&nbsp; 列。可以通过下面的快捷键来更改显示内容。<br>更改显示内容通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z&nbsp; 即可显示或隐藏对应的列，最后按回车键确定。<br>按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z&nbsp; 可以将相应的列向左移动。最后按回车键确定。<br>按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的&nbsp; R 键可以将当前的排序倒转。</p> 
   <p>&nbsp;</p> 
   <p>==============================</p> 
   <p>top命令使用过程中，还可以使用一些交互的命令来完成其它参数的功能。这些命令是通过快捷键启动的。<br>＜空格＞：立刻刷新。<br>P：根据CPU使用大小进行排序。<br>T：根据时间、累计时间排序。<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>M：根据使用内存大小进行排序。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p> 
   <p>可以看到，top命令是一个功能十分强大的监控系统的工具，对于系统管理员而言尤其重要。但是，它的缺点是会消耗很多系统资源。</p> 
   <p>&nbsp;应用实例&nbsp;<br>使用top命令可以监视指定用户，缺省情况是监视所有用户的进程。如果想查看指定用户的情况，在终端中按“U”键，然后输入用户名，系统就会切换为指定用户的进程运行界面。<br>ａ.作用<br>free命令用来显示内存的使用情况，使用权限是所有用户。<br>ｂ.格式<br>free [－b　－k　－m] [－o] [－s delay] [－t] [－V]<br>ｃ.主要参数<br>－b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。<br>－s delay：显示每隔多少秒数来显示一次内存使用情况。<br>－t：显示内存总和列。<br>－o：不显示缓冲区调节列。<br>ｄ.应用实例<br>free命令是用来查看内存使用情况的主要命令。和top命令相比，它的优点是使用简单，并且只占用很少的系统资源。通过－S参数可以使用free命令不间断地监视有多少内存在使用，这样可以把它当作一个方便实时监控器。<br>＃free －b －s5<br>使用这个命令后终端会连续不断地报告内存使用情况（以字节为单位），每5秒更新一次。</p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
