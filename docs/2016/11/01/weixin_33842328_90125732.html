<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>比较好的C++面试题 « NotBeCN</title>
  <meta name="description" content="                 1.是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?     virtual修饰符会被隐形继承的。     private 也被集成，只事派生类没有访问权限而已     virtual可加可不加     子类的空间里有父类的所有...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/11/01/weixin_33842328_90125732.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">比较好的C++面试题</h1>
    <p class="post-meta">Nov 1, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body">
    1.是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态? 
    <p>virtual修饰符会被隐形继承的。</p> 
    <p>private 也被集成，只事派生类没有访问权限而已</p> 
    <p>virtual可加可不加</p> 
    <p>子类的空间里有父类的所有变量(static除外)</p> 
    <p>同一个函数只存在一个实体(inline除外)</p> 
    <p>子类覆盖它的函数不加virtual ,也能实现多态。</p> 
    <p>在子类的空间里，有父类的私有变量。私有变量不能直接访问。</p> 
    <p><br> --------------------------------------------------------------------------<br> 2.输入一个字符串，将其逆序后输出。（使用C++，不建议用伪码）</p> 
    <p>#include &lt;iostream&gt;<br> using namespace std;</p> 
    <p><br> void main()<br> {<br> &nbsp; char a[50];memset(a,0,sizeof(a));<br> &nbsp; int i=0,j;<br> &nbsp; char t;<br> &nbsp; cin.getline(a,50,'\n');<br> &nbsp; for(i=0,j=strlen(a)-1;i&lt;strlen(a)/2;i++,j--)<br> &nbsp; {<br> &nbsp;&nbsp; t=a[i];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[i]=a[j];<br> &nbsp;&nbsp; a[j]=t;<br> &nbsp; }<br> &nbsp; cout&lt;&lt;a&lt;&lt;endl;&nbsp; <br> }</p> 
    <p>//第二种</p> 
    <p>string str;<br> cin&gt;&gt;str;<br> str.replace;<br> cout&lt;&lt;str;</p> 
    <p><br> --------------------------------------------------------------------------<br> 3.请简单描述Windows内存管理的方法。</p> 
    <p>内存管理是操作系统中的重要部分，两三句话恐怕谁也说不清楚吧～～<br> 我先说个大概，希望能够抛砖引玉吧</p> 
    <p>当程序运行时需要从内存中读出这段程序的代码。代码的位置必须在物理内存中才能被运行，由于现在的操作系统中有非常多的程序运行着，内存中不能够完全放下，所以引出了虚拟内存的概念。把哪些不常用的程序片断就放入虚拟内存，当需要用到它的时候在load入主存（物理内存）中。这个就是内存管理所要做的事。内存管理还有另外一件事需要做：计算程序片段在主存中的物理位置，以便CPU调度。</p> 
    <p>内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理</p> 
    <p>块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程 序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但时易于管理。</p> 
    <p>页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。</p> 
    <p>段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上（计算机最耗时间的大家都知道是I/O吧）。</p> 
    <p>段页式管理：结合了段式管理和页式管理的优点。把主存分为若干页，每一页又分为若干段。好处就很明显，不用我多说了吧。</p> 
    <p>各种内存管理都有它自己的方法来计算出程序片断在主存中的物理地址，其实都很相似。</p> 
    <p>这只是一个大概而已，不足以说明内存管理的皮毛。无论哪一本操作系统书上都有详细的讲解</p> 
    <p><br> --------------------------------------------------------------------------<br> 4.<br> #include "stdafx.h"<br> #define SQR(X) X*X</p> 
    <p>int main(int argc, char* argv[])<br> {<br> &nbsp;int a = 10;<br> &nbsp;int k = 2;<br> &nbsp;int m = 1;</p> 
    <p>&nbsp;a /= SQR(k+m)/SQR(k+m); <br> &nbsp;printf("%d\n",a); </p> 
    <p>&nbsp;return 0;<br> }<br> 这道题目的结果是什么啊?</p> 
    <p>define 只是定义而已，在编择时只是简单代换X*X而已，并不经过算术法则的</p> 
    <p>a /= (k+m)*(k+m)/(k+m)*(k+m);<br> =&gt;a /= (k+m)*1*(k+m);<br> =&gt;a = a/9;<br> =&gt;a = 1;</p> 
    <p>--------------------------------------------------------------------------<br> 5.<br> const 符号常量；<br> (1)const char *p<br> (2)char const *p<br> (3)char * const p<br> 说明上面三种描述的区别；</p> 
    <p><br> 如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；<br> 如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。</p> 
    <p>(1)const char *p</p> 
    <p>一个指向char类型的const对象指针，p不是常量,我们可以修改p的值，使其指向不同的char，但是不能改变它指向非char对象，如：<br> const char *p;<br> char c1='a';<br> char c2='b';<br> p=&amp;c1;//ok<br> p=&amp;c2;//ok<br> *p=c1;//error</p> 
    <p>(2)char const *p<br> (3)char * const p</p> 
    <p>这两个好象是一样的，此时*p可以修改，而p不能修改。</p> 
    <p>(4)const char * const p<br> 这种是地址及指向对象都不能修改。</p> 
    <p>--------------------------------------------------------------------------<br> 6.下面是C语言中两种if语句判断方式。请问哪种写法更好？为什么？<br> &nbsp;int n;<br> &nbsp;if (n == 10) // 第一种判断方式<br> &nbsp;if (10 == n) // 第二种判断方式</p> 
    <p>如果少了个=号,编译时就会报错,减少了出错的可能行,可以检测出是否少了=</p> 
    <p>--------------------------------------------------------------------------<br> 7.下面的代码有什么问题？<br> void DoSomeThing(...)<br> {<br> &nbsp;char* p;<br> &nbsp;...<br> &nbsp;p = malloc(1024);&nbsp; // 分配1K的空间<br> &nbsp;if (NULL == p)<br> &nbsp; return;<br> &nbsp;...<br> &nbsp;p = realloc(p, 2048); // 空间不够，重新分配到2K<br> &nbsp;if (NULL == p)<br> &nbsp; return;<br> &nbsp;...<br> }</p> 
    <p>A:<br> p = malloc(1024);&nbsp;&nbsp;&nbsp;&nbsp; 应该写成： p = (char *) malloc(1024); <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有释放p的空间，造成内存泄漏。</p> 
    <p><br> --------------------------------------------------------------------------<br> 8.下面的代码有什么问题？并请给出正确的写法。<br> void DoSomeThing(char* p)<br> {<br> &nbsp;char str[16];<br> &nbsp;int n;<br> &nbsp;assert(NULL != p);<br> &nbsp;sscanf(p, "%s%d", str, n);<br> &nbsp;if (0 == strcmp(str, "something"))<br> &nbsp;{<br> &nbsp; ...<br> &nbsp;}<br> }</p> 
    <p>A:<br> sscanf(p, "%s%d", str, n);&nbsp;&nbsp; 这句该写成： sscanf(p, "%s%d", str, &amp;n);</p> 
    <p>--------------------------------------------------------------------------<br> 9.下面代码有什么错误?<br> Void test1() <br> { <br> &nbsp;char string[10]; <br> &nbsp;char *str1="0123456789";<br> &nbsp;strcpy(string, str1); <br> } </p> 
    <p>数组越界</p> 
    <p>--------------------------------------------------------------------------<br> 10.下面代码有什么问题?<br> Void test2() <br> { <br> &nbsp; char string[10], str1[10]; <br> &nbsp; for(i=0; i&lt;10;i++) <br> &nbsp; { <br> &nbsp;&nbsp;&nbsp;&nbsp; str1[i] ='a'; <br> &nbsp; } <br> &nbsp; strcpy(string, str1); <br> } </p> 
    <p>数组越界</p> 
    <p>--------------------------------------------------------------------------<br> 11.下面代码有什么问题?<br> Void test3(char* str1) <br> { <br> &nbsp; char string[10]; <br> &nbsp; if(strlen(str1)&lt;=10) <br> &nbsp; { <br> &nbsp;&nbsp;&nbsp; strcpy(string, str1); <br> &nbsp; } <br> } </p> 
    <p>==数组越界<br> ==strcpy拷贝的结束标志是查找字符串中的\0 因此如果字符串中没有遇到\0的话 会一直复制，直到遇到\0,上面的123都因此产生越界的情况<br> &nbsp;<br> 建议使用 strncpy 和 memcpy</p> 
    <p>--------------------------------------------------------------------------<br> 12.下面代码有什么问题?</p> 
    <p>#define MAX_SRM 256 </p> 
    <p>DSN get_SRM_no() <br> { <br> &nbsp; static int SRM_no; //是不是这里没赋初值？<br> &nbsp; int I; <br> &nbsp; for(I=0;I&lt;MAX_SRM;I++,SRM_no++) <br> &nbsp; { <br> &nbsp;&nbsp;&nbsp; SRM_no %= MAX_SRM; <br> &nbsp;&nbsp;&nbsp; if(MY_SRM.state==IDLE) <br> &nbsp;&nbsp;&nbsp; { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <br> &nbsp;&nbsp;&nbsp; } <br> &nbsp; } <br> &nbsp; if(I&gt;=MAX_SRM) <br> &nbsp;&nbsp;&nbsp; return (NULL_SRM); <br> &nbsp; else <br> &nbsp;&nbsp;&nbsp; return SRM_no; <br> } </p> 
    <p>系统会初始化static int变量为0,但该值会一直保存,所谓的不可重入...</p> 
    <p>--------------------------------------------------------------------------<br> 13.写出运行结果:<br> {// test1<br> &nbsp;&nbsp;&nbsp; char str[] = "world"; cout &lt;&lt; sizeof(str) &lt;&lt; ": ";<br> &nbsp;&nbsp;&nbsp; char *p&nbsp;&nbsp;&nbsp; = str;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; sizeof(p) &lt;&lt; ": ";<br> &nbsp;&nbsp;&nbsp; char i&nbsp;&nbsp;&nbsp;&nbsp; = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; sizeof(i) &lt;&lt; ": ";<br> &nbsp;&nbsp;&nbsp; void *pp&nbsp;&nbsp; = malloc(10);&nbsp; cout &lt;&lt; sizeof(p) &lt;&lt; endl;<br> }</p> 
    <p>6：4：1：4</p> 
    <p>--------------------------------------------------------------------------<br> 14.写出运行结果:<br> {// test2<br> &nbsp;&nbsp;&nbsp; union V {<br> &nbsp;struct X {<br> &nbsp;&nbsp;unsigned char s1:2;<br> &nbsp;&nbsp;unsigned char s2:3;<br> &nbsp;&nbsp;unsigned char s3:3;<br> &nbsp;} x;</p> 
    <p>&nbsp;unsigned char c;<br> &nbsp;&nbsp;&nbsp; } v;</p> 
    <p>&nbsp;&nbsp;&nbsp; v.c = 100;<br> &nbsp;&nbsp;&nbsp; printf("%d", v.x.s3); </p> 
    <p>}</p> 
    <p>3</p> 
    <p>--------------------------------------------------------------------------<br> 15.用C++写个程序，如何判断一个操作系统是16位还是32位的？不能用sizeof()函数</p> 
    <p>A1:<br> 16位的系统下，<br> int i = 65536;<br> cout &lt;&lt; i; // 输出0；<br> int i = 65535;<br> cout &lt;&lt; i; // 输出-1；</p> 
    <p>32位的系统下，<br> int i = 65536;<br> cout &lt;&lt; i; // 输出65536；<br> int i = 65535;<br> cout &lt;&lt; i; // 输出65535；</p> 
    <p>A2:</p> 
    <p>int a = ~0;<br> if( a&gt;65536 ) <br> {<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"32 bit"&lt;&lt;endl;<br> }<br> else<br> {<br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"16 bit"&lt;&lt;endl;<br> }</p> 
    <p><br> --------------------------------------------------------------------------<br> 16.C和C++有什么不同?</p> 
    <p>从机制上：c是面向过程的（但c也可以编写面向对象的程序）；c++是面向对象的，提供了类。但是，<br> c++编写面向对象的程序比c容易</p> 
    <p>从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的；&nbsp; llinux核心大部分是c写的，因为它是系统软件，效率要求极高。</p> 
    <p>从名称上也可以看出，c++比c多了+，说明c++是c的超集；那为什么不叫c+而叫c++呢，是因为c++比<br> c来说扩充的东西太多了，所以就在c后面放上两个+；于是就成了c++</p> 
    <p>C语言是结构化编程语言，C++是面向对象编程语言。<br> C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。</p> 
    <p>--------------------------------------------------------------------------<br> 17.在不用第三方参数的情况下，交换两个参数的值<br> #include &lt;stdio.h&gt;</p> 
    <p>void main()<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i=60;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j=50;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=i+j;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=i-j;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=i-j;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("i=%d\n",i);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("j=%d\n",j);<br> }</p> 
    <p>方法二：<br> i^=j;<br> j^=i;<br> i^=j;</p> 
    <p>方法三：<br> // 用加减实现，而且不会溢出<br> a = a+b-(b=a)</p> 
    <p>--------------------------------------------------------------------------<br> 18.有关位域的面试题（为什么输出的是一个奇怪的字符）</p> 
    <p>a.t = 'b';效果相当于 a.t= 'b' &amp; 0xf;</p> 
    <p>'b' --&gt; 01100010<br> 'b' &amp; 0xf --&gt;&gt;00000010<br> 所以输出Ascii码为2的特殊字符</p> 
    <p><br> char t:4;就是4bit的字符变量，同样<br> unsigned short i:8;就是8bit的无符号短整形变量</p> 
    <p>--------------------------------------------------------------------------<br> 19.int i=10, j=10, k=3; k*=i+j; k最后的值是?</p> 
    <p>60</p> 
    <p>--------------------------------------------------------------------------<br> 20.进程间通信的方式有?</p> 
    <p>进程间通信的方式有 共享内存， 管道 ，Socket ，消息队列 , DDE等</p> 
    <p>--------------------------------------------------------------------------<br> 21.<br> struct A <br> { <br> char t:4; <br> char k:4; <br> unsigned short i:8; <br> unsigned long m; <br> } <br> sizeof(A)=?（不考虑边界对齐）</p> 
    <p>7</p> 
    <p>struct CELL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Declare CELL bit field<br> {<br> &nbsp;&nbsp; unsigned character&nbsp; : 8;&nbsp; // 00000000 ????????<br> &nbsp;&nbsp; unsigned foreground : 3;&nbsp; // 00000??? 00000000<br> &nbsp;&nbsp; unsigned intensity&nbsp; : 1;&nbsp; // 0000?000 00000000<br> &nbsp;&nbsp; unsigned background : 3;&nbsp; // 0???0000 00000000<br> &nbsp;&nbsp; unsigned blink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 1;&nbsp; // ?0000000 00000000<br> } screen[25][80];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Array of bit fields<br> 二、位结构 <br> &nbsp;&nbsp;&nbsp; 位结构是一种特殊的结构, 在需按位访问一个字节或字的多个位时, 位结构 <br> 比按位运算符更加方便。 <br> &nbsp;&nbsp;&nbsp; 位结构定义的一般形式为: <br> &nbsp;&nbsp;&nbsp;&nbsp; struct位结构名{ <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数据类型 变量名: 整型常数; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 数据类型 变量名: 整型常数; <br> &nbsp;&nbsp;&nbsp;&nbsp; } 位结构变量; <br> &nbsp;&nbsp;&nbsp; 其中: 数据类型必须是int(unsigned或signed)。 整型常数必须是非负的整 <br> 数, 范围是0~15, 表示二进制位的个数, 即表示有多少位。 <br> &nbsp;&nbsp;&nbsp; 变量名是选择项, 可以不命名, 这样规定是为了排列需要。 <br> &nbsp;&nbsp;&nbsp; 例如: 下面定义了一个位结构。 <br> &nbsp;&nbsp;&nbsp;&nbsp; struct{ <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned incon: 8;&nbsp; /*incon占用低字节的0~7共8位*/ <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned txcolor: 4;/*txcolor占用高字节的0~3位共4位*/ <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned bgcolor: 3;/*bgcolor占用高字节的4~6位共3位*/ <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned blink: 1;&nbsp; /*blink占用高字节的第7位*/ <br> &nbsp;&nbsp;&nbsp;&nbsp; }ch; <br> &nbsp;&nbsp;&nbsp; 位结构成员的访问与结构成员的访问相同。 <br> &nbsp;&nbsp;&nbsp; 例如: 访问上例位结构中的bgcolor成员可写成: <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch.bgcolor <br> &nbsp; <br> &nbsp;&nbsp;&nbsp; 注意: <br> &nbsp;&nbsp;&nbsp; 1. 位结构中的成员可以定义为unsigned, 也可定义为signed,&nbsp; 但当成员长 <br> 度为1时, 会被认为是unsigned类型。因为单个位不可能具有符号。 <br> &nbsp;&nbsp;&nbsp; 2. 位结构中的成员不能使用数组和指针, 但位结构变量可以是数组和指针, <br> 如果是指针, 其成员访问方式同结构指针。 <br> &nbsp;&nbsp;&nbsp; 3. 位结构总长度(位数), 是各个位成员定义的位数之和,&nbsp; 可以超过两个字 <br> 节。 <br> &nbsp;&nbsp;&nbsp; 4. 位结构成员可以与其它结构成员一起使用。 <br> &nbsp;&nbsp;&nbsp; 例如: <br> &nbsp;&nbsp;&nbsp;&nbsp; struct info{ <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char name[8]; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int age; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct addr address; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float pay; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned state: 1; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned pay: 1; <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }workers;<br> &nbsp;&nbsp;&nbsp; 上例的结构定义了关于一个工人的信息。其中有两个位结构成员, 每个位结 <br> 构成员只有一位, 因此只占一个字节但保存了两个信息, 该字节中第一位表示工 <br> 人的状态, 第二位表示工资是否已发放。由此可见使用位结构可以节省存贮空间。</p> 
    <p><br> --------------------------------------------------------------------------<br> 22.下面的函数实现在一个固定的数上加上一个数，有什么错误，改正 <br> int add_n(int n) <br> { <br> &nbsp; static int i=100; <br> &nbsp; i+=n; <br> &nbsp; return i; <br> } </p> 
    <p>答:<br> 因为static使得i的值会保留上次的值。<br> 去掉static就可了</p> 
    <p>--------------------------------------------------------------------------<br> 23.下面的代码有什么问题?<br> class A <br> { <br> public: <br> &nbsp; A() { p=this; } <br> &nbsp; ~A() { if(p!=NULL) { delete p; p=NULL; } } </p> 
    <p>&nbsp; A* p; <br> };</p> 
    <p>答:<br> 会引起无限递归</p> 
    <p>--------------------------------------------------------------------------<br> 24.<br> union a {<br> &nbsp;int a_int1;<br> &nbsp;double a_double;<br> &nbsp;int a_int2;<br> };</p> 
    <p>typedef struct<br> {<br> &nbsp;a a1;<br> &nbsp;char y;<br> } b;</p> 
    <p>class c<br> {<br> &nbsp;double c_double;<br> &nbsp;b b1;<br> &nbsp;a a2;</p> 
    <p>};</p> 
    <p>输出cout&lt;&lt;sizeof(c)&lt;&lt;endl;的结果?</p> 
    <p>答:<br> VC6环境下得出的结果是32</p> 
    <p>另:<br> 我(sun)在VC6.0+win2k下做过试验:<br> short - 2<br> int-4<br> float-4<br> double-8<br> 指针-4</p> 
    <p>sizeof(union)，以结构里面size最大的为union的size</p> 
    <p>解析C语言中的sizeof</p> 
    <p>一、sizeof的概念　 <br> sizeof是C语言的一种单目操作符，如C语言的其他操作符++、--等。它并不是函数。sizeof操作符以字节形式给出了其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数的存储大小由操作数的类型决定。　 </p> 
    <p>二、sizeof的使用方法　 <br> 1、用于数据类型　 </p> 
    <p>　　sizeof使用形式：sizeof（type）　 </p> 
    <p>　　数据类型必须用括号括住。如sizeof（int）。　 </p> 
    <p>　　2、用于变量　 </p> 
    <p>　　sizeof使用形式：sizeof（var_name）或sizeof　var_name　 </p> 
    <p>　　变量名可以不用括号括住。如sizeof　(var_name)，sizeof　var_name等都是正确形式。带括号的用法更普遍，大多数程序员采用这种形式。　 </p> 
    <p>　　注意：sizeof操作符不能用于函数类型，不完全类型或位字段。不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。　 </p> 
    <p>　　如sizeof(max)若此时变量max定义为int　max(),sizeof(char_v)　若此时char_v定义为char　char_v　[MAX]且MAX未知，sizeof(void)都不是正确形式。　 </p> 
    <p>三、sizeof的结果　 <br> sizeof操作符的结果类型是size_t，它在头文件</p> 
    <p>中typedef为unsigned　int类型。该类型保证能容纳实现所建立的最大对象的字节大小。　 </p> 
    <p>　　1、若操作数具有类型char、unsigned　char或signed　char，其结果等于1。　 </p> 
    <p>　　ANSI　C正式规定字符类型为1字节。　 </p> 
    <p>　　2、int、unsigned　int　、short　int、unsigned　short　、long　int　、unsigned　long　、float、double、long　double类型的sizeof　在ANSI　C中没有具体规定，大小依赖于实现，一般可能分别为2、2、2、2、4、4、4、8、10。　 </p> 
    <p>　　3、当操作数是指针时，sizeof依赖于编译器。例如Microsoft　C/C++7.0中，near类指针字节数为2，far、huge类指针字节数为4。一般Unix的指针字节数为4。　 </p> 
    <p>　　4、当操作数具有数组类型时，其结果是数组的总字节数。　 </p> 
    <p>　　5、联合类型操作数的sizeof是其最大字节成员的字节数。结构类型操作数的sizeof是这种类型对象的总字节数，包括任何垫补在内。　 </p> 
    <p>　　让我们看如下结构：　 </p> 
    <p>　　struct　{char　b;　double　x;}　a;　 </p> 
    <p>　　在某些机器上sizeof（a）=12，而一般sizeof（char）+　sizeof（double）=9。　 </p> 
    <p>　　这是因为编译器在考虑对齐问题时，在结构中插入空位以控制各成员对象的地址对齐。如double类型的结构成员x要放在被4整除的地址。　 </p> 
    <p>　　6、如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小。　 </p> 
    <p>四、sizeof与其他操作符的关系　 <br> sizeof的优先级为2级，比/、%等3级运算符优先级高。它可以与其他操作符一起组成表达式。如i*sizeof（int）；其中i为int类型变量。　 </p> 
    <p>五、sizeof的主要用途　 <br> 1、sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。例如：　 </p> 
    <p>　　void　*malloc（size_t　size）,　 </p> 
    <p>　　size_t　fread(void　*　ptr,size_t　size,size_t　nmemb,FILE　*　stream)。　 </p> 
    <p>　　2、sizeof的另一个的主要用途是计算数组中元素的个数。例如：　 </p> 
    <p>　　void　*　memset（void　*　s,int　c,sizeof(s)）。　 </p> 
    <p>六、建议　 <br> 由于操作数的字节数在实现时可能出现变化，建议在涉及到操作数字节大小时用sizeof来代替常量计算。</p> 
    <p><br> =============================================================<br> 本文主要包括二个部分，第一部分重点介绍在VC中，怎么样采用sizeof来求结构的大小，以及容易出现的问题，并给出解决问题的方法，第二部分总结出VC中sizeof的主要用法。 </p> 
    <p>1、 sizeof应用在结构上的情况 </p> 
    <p>请看下面的结构： </p> 
    <p>struct MyStruct </p> 
    <p>{ </p> 
    <p>double dda1; </p> 
    <p>char dda; </p> 
    <p>int type </p> 
    <p>}; </p> 
    <p>对结构MyStruct采用sizeof会出现什么结果呢？sizeof(MyStruct)为多少呢？也许你会这样求： </p> 
    <p>sizeof(MyStruct)=sizeof(double)+sizeof(char)+sizeof(int)=13 </p> 
    <p>但是当在VC中测试上面结构的大小时，你会发现sizeof(MyStruct)为16。你知道为什么在VC中会得出这样一个结果吗？ </p> 
    <p>其实，这是VC对变量存储的一个特殊处理。为了提高CPU的存储速度，VC对一些变量的起始地址做了"对齐"处理。在默认情况下，VC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。下面列出常用类型的对齐方式(vc6.0,32位系统)。 </p> 
    <p>类型 <br> 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） </p> 
    <p>Char <br> 偏移量必须为sizeof(char)即1的倍数 </p> 
    <p>int <br> 偏移量必须为sizeof(int)即4的倍数 </p> 
    <p>float <br> 偏移量必须为sizeof(float)即4的倍数 </p> 
    <p>double <br> 偏移量必须为sizeof(double)即8的倍数 </p> 
    <p>Short <br> 偏移量必须为sizeof(short)即2的倍数 </p> 
    <p>&nbsp;</p> 
    <p>各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节VC会自动填充。同时VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 </p> 
    <p>下面用前面的例子来说明VC到底怎么样来存放结构的。 </p> 
    <p>struct MyStruct </p> 
    <p>{ </p> 
    <p>double dda1; </p> 
    <p>char dda; </p> 
    <p>int type </p> 
    <p>}； </p> 
    <p>为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式，先为第一个成员dda1分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(double)的倍数），该成员变量占用sizeof(double)=8个字节；接下来为第二个成员dda分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，所以把dda存放在偏移量为8的地方满足对齐方式，该成员变量占用sizeof(char)=1个字节；接下来为第三个成员type分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是sizeof(int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把type存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。所以整个结构的大小为：sizeof(MyStruct)=8+1+3+4=16，其中有3个字节是VC自动填充的，没有放任何有意义的东西。 </p> 
    <p>下面再举个例子，交换一下上面的MyStruct的成员变量的位置，使它变成下面的情况： </p> 
    <p>struct MyStruct </p> 
    <p>{ </p> 
    <p>char dda; </p> 
    <p>double dda1;&nbsp;&nbsp; </p> 
    <p>int type </p> 
    <p>}； </p> 
    <p>这个结构占用的空间为多大呢？在VC6.0环境下，可以得到sizeof(MyStruc)为24。结合上面提到的分配空间的一些原则，分析下VC怎么样为上面的结构分配空间的。（简单说明） </p> 
    <p>struct MyStruct </p> 
    <p>{ </p> 
    <p>&nbsp; char dda;//偏移量为0，满足对齐方式，dda占用1个字节； </p> 
    <p>double dda1;//下一个可用的地址的偏移量为1，不是sizeof(double)=8 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //的倍数，需要补足7个字节才能使偏移量变为8（满足对齐 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //方式），因此VC自动填充7个字节，dda1存放在偏移量为8 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //的地址上，它占用8个字节。 </p> 
    <p>int type；//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //数，满足int的对齐方式，所以不需要VC自动填充，type存 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //放在偏移量为16的地址上，它占用4个字节。 </p> 
    <p>}；//所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构 </p> 
    <p>&nbsp;&nbsp; //的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof </p> 
    <p>&nbsp;&nbsp; //(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为 </p> 
    <p>&nbsp;&nbsp; //sizeof(double)=8的倍数。 </p> 
    <p>&nbsp;</p> 
    <p>所以该结构总的大小为：sizeof(MyStruc)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。 </p> 
    <p>&nbsp;</p> 
    <p>VC对结构的存储的特殊处理确实提高CPU存储变量的速度，但是有时候也带来了一些麻烦，我们也屏蔽掉变量默认的对齐方式，自己可以设定变量的对齐方式。 </p> 
    <p>VC中提供了#pragma pack(n)来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的偏移量有两种情况：第一、如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，第二、如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。结构的总大小也有个约束条件，分下面两种情况：如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数； </p> 
    <p>否则必须为n的倍数。下面举例说明其用法。 </p> 
    <p>#pragma pack(push) //保存对齐状态 </p> 
    <p>#pragma pack(4)//设定为4字节对齐 </p> 
    <p>struct test </p> 
    <p>{ </p> 
    <p>&nbsp; char m1; </p> 
    <p>&nbsp; double m4; </p> 
    <p>&nbsp; int&nbsp; m3; </p> 
    <p>}; </p> 
    <p>#pragma pack(pop)//恢复对齐状态 </p> 
    <p>以上结构的大小为16，下面分析其存储情况，首先为m1分配空间，其偏移量为0，满足我们自己设定的对齐方式（4字节对齐），m1占用1个字节。接着开始为m4分配空间，这时其偏移量为1，需要补足3个字节，这样使偏移量满足为n=4的倍数（因为sizeof(double)大于n）,m4占用8个字节。接着为m3分配空间，这时其偏移量为12，满足为4的倍数，m3占用4个字节。这时已经为所有成员变量分配了空间，共分配了16个字节，满足为n的倍数。如果把上面的#pragma pack(4)改为#pragma pack(16)，那么我们可以得到结构的大小为24。（请读者自己分析） </p> 
    <p>2、 sizeof用法总结 </p> 
    <p>在VC中，sizeof有着许多的用法，而且很容易引起一些错误。下面根据sizeof后面的参数对sizeof的用法做个总结。 </p> 
    <p>A．&nbsp; 参数为数据类型或者为一般变量。例如sizeof(int),sizeof(long)等等。这种情况要注意的是不同系统系统或者不同编译器得到的结果可能是不同的。例如int类型在16位系统中占2个字节，在32位系统中占4个字节。 </p> 
    <p>B．&nbsp; 参数为数组或指针。下面举例说明. </p> 
    <p>int a[50];&nbsp; //sizeof(a)=4*50=200; 求数组所占的空间大小 </p> 
    <p>int *a=new int[50];// sizeof(a)=4; a为一个指针，sizeof(a)是求指针 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //的大小,在32位系统中，当然是占4个字节。 </p> 
    <p>C．&nbsp; 参数为结构或类。Sizeof应用在类和结构的处理情况是相同的。但有两点需要注意，第一、结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。 </p> 
    <p>第二、没有成员变量的结构或类的大小为1，因为必须保证结构或类的每一 </p> 
    <p>个实例在内存中都有唯一的地址。 </p> 
    <p>下面举例说明， </p> 
    <p>Class Test{int a;static double c};//sizeof(Test)=4. </p> 
    <p>Test *s;//sizeof(s)=4,s为一个指针。 </p> 
    <p>Class test1{ };//sizeof(test1)=1; </p> 
    <p>D．&nbsp; 参数为其他。下面举例说明。 </p> 
    <p>&nbsp;&nbsp; int func(char s[5]); </p> 
    <p>&nbsp;&nbsp; { </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;sizeof(s);//这里将输出4，本来s为一个数组，但由于做为函 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //数的参数在传递的时候系统处理为一个指针，所 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //以sizeof(s)实际上为求指针的大小。 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp; return 1; </p> 
    <p>} </p> 
    <p>sizeof(func("1234"))=4//因为func的返回类型为int，所以相当于 </p> 
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //求sizeof(int). </p> 
    <p>&nbsp;</p> 
    <p>以上为sizeof的基本用法，在实际的使用中要注意分析VC的分配变量的分配策略，这样的话可以避免一些错误。 </p> 
    <p><br> --------------------------------------------------------------------------<br> 25.i最后等于多少?<br> int i = 1;<br> int j = i++;<br> if((i&gt;j++) &amp;&amp; (i++ == j)) i+=j;</p> 
    <p>答:<br> i = 5</p> 
    <p>--------------------------------------------------------------------------<br> 26.<br> unsigned short array[]={1,2,3,4,5,6,7};<br> int i = 3;<br> *(array + i) = ?</p> 
    <p>答:<br> 4</p> 
    <p>--------------------------------------------------------------------------<br> 27.<br> class A<br> {<br> &nbsp; virtual void func1()；<br> &nbsp; void func2();<br> }<br> Class B: class A<br> {<br> &nbsp; void func1(){cout &lt;&lt; "fun1 in class B" &lt;&lt; endl;}<br> &nbsp; virtual void func2(){cout &lt;&lt; "fun2 in class B" &lt;&lt; endl;}<br> } <br> A, A中的func1和B中的func2都是虚函数.<br> B, A中的func1和B中的func2都不是虚函数.<br> C, A中的func2是虚函数.，B中的func1不是虚函数.<br> D, A中的func2不是虚函数，B中的func1是虚函数.</p> 
    <p>答:<br> A</p> 
    <p>--------------------------------------------------------------------------<br> 28.<br> 数据库：抽出部门，平均工资，要求按部门的字符串顺序排序，不能含有"human resource"部门，</p> 
    <p>employee结构如下：employee_id, employee_name, depart_id,depart_name,wage</p> 
    <p>答:<br> select depart_name, avg(wage)<br> from employee<br> where depart_name &lt;&gt; 'human resource'<br> group by depart_name<br> order by depart_name</p> 
    <p>--------------------------------------------------------------------------<br> 29.<br> 给定如下SQL数据库：Test(num INT(4)) 请用一条SQL语句返回num的最小值，但不许使用统计功能，如MIN，MAX等</p> 
    <p>答:<br> select top 1 num<br> from Test<br> order by num desc</p> 
    <p>--------------------------------------------------------------------------<br> 30.<br> 输出下面程序结果。 </p> 
    <p>#include &lt;iostream.h&gt; </p> 
    <p>class A <br> { <br> public:<br> &nbsp;virtual void print(void) <br> &nbsp;{ <br> &nbsp;&nbsp;&nbsp; cout&lt;&lt;"A::print()"&lt;&lt;endl; <br> &nbsp;} <br> };<br> class B:public A <br> { <br> public:<br> &nbsp;virtual void print(void) <br> &nbsp;{ <br> &nbsp;&nbsp; cout&lt;&lt;"B::print()"&lt;&lt;endl;<br> &nbsp;}; <br> }; <br> class C:public B<br> {<br> public:<br> &nbsp;virtual void print(void)<br> &nbsp;{<br> &nbsp;&nbsp;cout&lt;&lt;"C::print()"&lt;&lt;endl;<br> &nbsp;}<br> };<br> void print(A a) <br> { <br> &nbsp;&nbsp; a.print(); <br> } <br> void main(void) <br> { <br> &nbsp;&nbsp; A a, *pa,*pb,*pc; <br> &nbsp;&nbsp; B b; <br> &nbsp;&nbsp; C c; <br> &nbsp;&nbsp; <br> &nbsp;&nbsp; pa=&amp;a; <br> &nbsp;&nbsp; pb=&amp;b; <br> &nbsp;&nbsp; pc=&amp;c; <br> &nbsp;&nbsp; <br> &nbsp;&nbsp; a.print(); <br> &nbsp;&nbsp; b.print(); <br> &nbsp;&nbsp; c.print(); <br> &nbsp;&nbsp; <br> &nbsp;&nbsp; pa-&gt;print(); <br> &nbsp;&nbsp; pb-&gt;print(); <br> &nbsp;&nbsp; pc-&gt;print(); <br> &nbsp;&nbsp; <br> &nbsp;&nbsp; print(a); <br> &nbsp;&nbsp; print(b); <br> &nbsp;&nbsp; print(c); <br> }</p> 
    <p>A:<br> A::print()<br> B::print()<br> C::print()<br> A::print()<br> B::print()<br> C::print()<br> A::print()<br> A::print()<br> A::print()</p> 
    <p>--------------------------------------------------------------------------<br> 31.<br> 试编写函数判断计算机的字节存储顺序是开序(little endian)还是降序(bigendian)</p> 
    <p>答:<br> bool IsBigendian()<br> {<br> &nbsp;unsigned short usData = 0x1122;<br> &nbsp;unsigned char&nbsp; *pucData = (unsigned char*)&amp;usData;</p> 
    <p>&nbsp;return (*pucData == 0x22);<br> }</p> 
    <p>--------------------------------------------------------------------------<br> 32.简述Critical Section和Mutex的不同点</p> 
    <p>答:<br> 对几种同步对象的总结<br> 1.Critical Section<br> A.速度快<br> B.不能用于不同进程<br> C.不能进行资源统计(每次只可以有一个线程对共享资源进行存取)</p> 
    <p>2.Mutex<br> A.速度慢<br> B.可用于不同进程<br> C.不能进行资源统计</p> 
    <p>3.Semaphore<br> A.速度慢<br> B.可用于不同进程<br> C.可进行资源统计(可以让一个或超过一个线程对共享资源进行存取)</p> 
    <p>4.Event<br> A.速度慢<br> B.可用于不同进程<br> C.可进行资源统计</p> 
    <p>&nbsp;</p> 
    <p>--------------------------------------------------------------------------<br> 33.一个数据库中有两个表:<br> 一张表为Customer，含字段ID,Name;<br> 一张表为Order，含字段ID,CustomerID（连向Customer中ID的外键）,Revenue；<br> 写出求每个Customer的Revenue总和的SQL语句。</p> 
    <p>建表<br> create table customer<br> (<br> ID int primary key,Name char(10)<br> )</p> 
    <p>go</p> 
    <p>create table [order]<br> (<br> ID int primary key,CustomerID&nbsp; int foreign key references customer(id) , Revenue float<br> )</p> 
    <p>go</p> 
    <p>--查询<br> select Customer.ID, sum( isnull([Order].Revenue,0) )<br> from customer full join [order] <br> on( [order].customerid=customer.id )<br> group by customer.id</p> 
    <p>--------------------------------------------------------------------------<br> 34.请指出下列程序中的错误并且修改<br> void GetMemory(char *p){<br> &nbsp; p=(char *)malloc(100);<br> }<br> void Test(void){<br> &nbsp; char *str=NULL;<br> &nbsp; GetMemory=(str);<br> &nbsp; strcpy(str,"hello world");<br> &nbsp; printf(str);<br> }</p> 
    <p>A:错误--参数的值改变后，不会传回<br> GetMemory并不能传递动态内存，Test函数中的 str一直都是 NULL。<br> strcpy(str, "hello world");将使程序崩溃。</p> 
    <p>修改如下:<br> char *GetMemory(){<br> &nbsp; char *p=(char *)malloc(100);<br> &nbsp; return p;<br> }<br> void Test(void){<br> &nbsp; char *str=NULL;<br> &nbsp; str=GetMemory(){<br> &nbsp; strcpy(str,"hello world");<br> &nbsp; printf(str);<br> }</p> 
    <p>方法二:void GetMemory2(char **p)变为二级指针.<br> void GetMemory2(char **p, int num)<br> {<br> &nbsp;*p = (char *)malloc(sizeof(char) * num);<br> }</p> 
    <p>--------------------------------------------------------------------------<br> 35.程序改错<br> class mml<br> {<br> &nbsp; private:<br> &nbsp;&nbsp;&nbsp; static unsigned int x;<br> &nbsp; public:<br> &nbsp;&nbsp;&nbsp; mml(){ x++; }<br> &nbsp;&nbsp;&nbsp; mml(static unsigned int &amp;) {x++;}<br> &nbsp;&nbsp;&nbsp; ~mml{x--;}<br> &nbsp; pulic:<br> &nbsp;&nbsp;&nbsp; virtual mon() {} = 0;<br> &nbsp;&nbsp;&nbsp; static unsigned int mmc(){return x;}<br> &nbsp;&nbsp;&nbsp; ......&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br> &nbsp;<br> };<br> class nnl:public mml<br> {<br> &nbsp; private:<br> &nbsp;&nbsp;&nbsp; static unsigned int y;<br> &nbsp; public:<br> &nbsp;&nbsp;&nbsp; nnl(){ x++; }<br> &nbsp;&nbsp;&nbsp; nnl(static unsigned int &amp;) {x++;}<br> &nbsp;&nbsp;&nbsp; ~nnl{x--;}<br> &nbsp; public:<br> &nbsp;&nbsp;&nbsp; virtual mon() {};<br> &nbsp;&nbsp;&nbsp;&nbsp; static unsigned int nnc(){return y;}<br> &nbsp;&nbsp;&nbsp; ......&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br> };</p> 
    <p>代码片断:<br> mml* pp = new nnl;<br> ..........<br> delete pp;</p> 
    <p><br> A:<br> 基类的析构函数应该为虚函数<br> virtual ~mml{x--;}</p> 
    <p>--------------------------------------------------------------------------<br> 36.101个硬币100真、1假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论。</p> 
    <p>答:<br> 101个先取出2堆,<br> 33,33<br> 第一次称,如果不相等,说明有一堆重或轻<br> 那么把重的那堆拿下来,再放另外35个中的33<br> 如果相等,说明假的重,如果不相等,新放上去的还是重的话,说明假的轻(不可能新放上去的轻)</p> 
    <p>第一次称,如果相等的话，这66个肯定都是真的,从这66个中取出35个来,与剩下的没称过的35个比<br> 下面就不用说了</p> 
    <p>方法二:<br> 第3题也可以拿A(50),B(50)比一下，一样的话拿剩下的一个和真的比一下。<br> 如果不一样，就拿其中的一堆。比如A(50)再分成两堆25比一下，一样的话就在<br> B(50)中，不一样就在A(50)中，结合第一次的结果就知道了。</p> 
    <p>--------------------------------------------------------------------------<br> 37.static变量和static 函数各有什么特点？</p> 
    <p>答:<br> static变量：在程序运行期内一直有效，如果定义在函数外，则在编译单元内可见，如果在函数内，在在定义的block内可见；<br> static函数：在编译单元内可见；</p> 
    <p>--------------------------------------------------------------------------<br> 38.用C 写一个输入的整数,倒着输出整数的函数,要求用递归方法 ;</p> 
    <p>答:<br> void fun( int a )<br> {<br> &nbsp;printf( "%d", a%10 );<br> &nbsp;a /= 10;<br> &nbsp;if( a &lt;=0 )return;</p> 
    <p>&nbsp;fun( a );<br> }</p> 
    <p>--------------------------------------------------------------------------<br> 39.写出程序结果:<br> void Func(char str[100])<br> {<br> &nbsp; printf("%d\n", sizeof(str));<br> }</p> 
    <p>答:<br> 4<br> 分析:<br> 指针长度</p> 
    <p>--------------------------------------------------------------------------<br> 40.int id[sizeof(unsigned long)];<br> &nbsp;&nbsp;&nbsp; 这个对吗？为什么??</p> 
    <p>答:<br> 对<br> 这个 sizeof是编译时运算符，编译时就确定了<br> 可以看成和机器有关的常量。</p> 
    <p><br> 本文主要包括二个部分，第一部分重点介绍在VC中，怎么样采用sizeof来求结构的大小，以及容易出现的问题，并给出解决问题的方法，第二部分总结出VC中sizeof的主要用法。 </p> 
    <p>1、 sizeof应用在结构上的情况 </p> 
    <p>请看下面的结构： </p> 
    <p>struct MyStruct </p> 
    <p>{ </p> 
    <p>double dda1; </p> 
    <p>char dda; </p> 
    <p>int type </p> 
    <p>}; </p> 
    <p>对结构MyStruct采用sizeof会出现什么结果呢？sizeof(MyStruct)为多少呢？也许你会这样求： </p> 
    <p>sizeof(MyStruct)=sizeof(double)+sizeof(char)+sizeof(int)=13 </p> 
    <p>但是当在VC中测试上面结构的大小时，你会发现sizeof(MyStruct)为16。你知道为什么在VC中会得出这样一个结果吗？ </p> 
    <p>其实，这是VC对变量存储的一个特殊处理。为了提高CPU的存储速度，VC对一些变量的起始地址做了"对齐"处理。在默认情况下，VC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。下面列出常用类型的对齐方式(vc6.0,32位系统)。 </p> 
    <p>类型 <br> 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） </p> 
    <p>Char <br> 偏移量必须为sizeof(char)即1的倍数 </p> 
    <p>int <br> 偏移量必须为sizeof(int)即4的倍数 </p> 
    <p>float <br> 偏移量必须为sizeof(float)即4的倍数 </p> 
    <p>double <br> 偏移量必须为sizeof(double)即8的倍数 </p> 
    <p>Short <br> 偏移量必须为sizeof(short)即2的倍数 </p> 
    <p>&nbsp;</p> 
    <p>各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节VC会自动填充。同时VC为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍?/textarea&gt;</p> 
   </div> 
   <div>
    专注于企业信息化，最近对股票数据分析较为感兴趣，可免费分享股票个股主力资金实时变化趋势分析工具，股票交流QQ群：457394862
   </div> 
   <div class="clear"></div> 
   <div> 
    <div>
     分类: 
     <a href="http://www.cnblogs.com/omygod/category/72753.html" rel="nofollow">C/C++</a> 
    </div> 
    <div>
     <br>
    </div> 
    <div>
     本文转自沧海-重庆博客园博客，原文链接：http://www.cnblogs.com/omygod/archive/2006/11/15/560786.html，如需转载请自行联系原作者
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
