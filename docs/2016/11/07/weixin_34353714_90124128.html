<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C#的多线程（2）之二 « NotBeCN</title>
  <meta name="description" content="                  三.线程的同步和通讯——生产者和消费者         　　假设这样一种情况，两个线程同时维护一个队列，如果一个线程对队列中添加元素，而另外一个线程从队列中取用元素，那么我们称添加元素的线程为生产者，称取用 元素的线程为消费者。生产者与消费者问题看起来很简单，但是却是多线程应用...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/11/07/weixin_34353714_90124128.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C#的多线程（2）之二</h1>
    <p class="post-meta">Nov 7, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="blogpost-body"> 
    <strong>三<span>.</span>线程的同步和通讯<span>——</span>生产者和消费者</strong> 
    <span><br><br></span>
    <span>　　</span>假设这样一种情况，两个线程同时维护一个队列，如果一个线程对队列中添加元素，而另外一个线程从队列中取用元素，那么我们称添加元素的线程为生产者，称取用 元素的线程为消费者。生产者与消费者问题看起来很简单，但是却是多线程应用中一个必须解决的问题，它涉及到线程之间的同步和通讯问题。 
    <br>
    <span><br></span>
    <span>　　</span>前面说过，每个线程都有自己的资源，但是代码区是共享的，即每个线程都可以执行相同的函数。但是多线程环境下，可能带来的问题就是几个线程同时执行一个函数，导致数据的混乱，产生不可预料的结果，因此我们必须避免这种情况的发生。
    <span>C#</span>提供了一个关键字
    <span>lock</span>，它可以把一段代码定义为互斥段（
    <span>critical section</span>），互斥段在一个时刻内只允许一个线程进入执行，而其他线程必须等待。在
    <span>C#</span>中，关键字
    <span>lock</span>定义如下： 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span><br><br> lock(expression) statement_block </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span>expression</span>代表你希望跟踪的对象，通常是对象引用。一般地，如果你想保护一个类的实例，你可以使用<span>this</span>；如果你希望保护一个静态变量（如互斥代码段在一个静态方法内部），一般使用类名就可以了。而<span>statement_block</span>就是互斥段的代码，这段代码在一个时刻内只可能被一个线程执行。 <span><br><br></span>　　下面是一个使用<span>lock</span>关键字的典型例子，我将在注释里向大家说明<span>lock</span>关键字的用法和用途：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　//lock.cs</span><span><br></span><span>　　using System;<br> using System.Threading; </span><span><br><br></span><span>　　internal class Account </span><span><br></span><span>　　{</span><span><br></span>　　<span>int balance;<br></span>　　<span>Random r = new Random();<br></span>　　<span>internal Account(int initial) <br></span>　　<span>{<br></span>　　<span>　　balance = initial;</span><span><br></span>　　<span>} <br><br></span>　　<span>internal int Withdraw(int amount) <br></span>　　<span>{<br></span>　　<span>　　if (balance &lt; 0) </span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span><em>file:</em>//</span>如果<span>balance</span>小于<span>0</span>则抛出异常<span><br></span>　　　　<span>throw new Exception("Negative Balance");<br></span>　　<span>　　}</span><span><br></span>　　<span>　　//</span>下面的代码保证在当前线程修改<span>balance</span>的值完成之前<span><br></span>　　<span>　　//</span>不会有其他线程也执行这段代码来修改<span>balance</span>的值<span><br></span>　　<span>　　//</span>因此，<span>balance</span>的值是不可能小于<span>0</span>的<span><br></span>　　<span>　　lock (this)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>Console.WriteLine("Current Thread:"+Thread.CurrentThread.Name);<br></span>　　　　<span><em>file:</em>//</span>如果没有<span>lock</span>关键字的保护，那么可能在执行完<span>if</span>的条件判断之后<span><br></span>　　　　<span><em>file:</em>//</span>另外一个线程却执行了<span>balance=balance-amount</span>修改了<span>balance</span>的值<span><br></span>　　　　<span><em>file:</em>//</span>而这个修改对这个线程是不可见的，所以可能导致这时<span>if</span>的条件已经不成立了<span><br></span>　　　　<span><em>file:</em>//</span>但是，这个线程却继续执行<span>balance=balance-amount</span>，所以导致<span>balance</span>可能小于<span>0<br></span>　　　　<span>if (balance &gt;= amount) <br></span>　　　　<span>{<br></span>　　　　<span>　　Thread.Sleep(5);<br></span>　　　　<span>　　balance = balance - amount;</span><span><br></span>　　　　<span>　　return amount;</span><span><br></span>　　　　<span>} <br></span>　　　　<span>else <br></span>　　　　<span>{<br></span>　　　　<span>　　return 0; // transaction rejected</span><span><br></span>　　　　<span>}<br></span>　　<span>　　}</span><span><br></span>　　<span>}<br></span>　　<span>internal void DoTransactions() <br></span>　　<span>{<br></span>　　<span>　　for (int i = 0; i &lt; 100; i++) </span><span><br></span>　　　　<span>Withdraw(r.Next(-50, 100));<br></span>　　<span>}<br> } </span><span><br><br></span><span>　　internal class Test </span><span><br></span><span>　　{</span><span><br></span>　　<span>static internal Thread[] threads = new Thread[10];<br></span>　　<span>public static void Main() <br></span>　　<span>{<br></span>　　<span>　　Account acc = new Account (0);</span><span><br></span>　　<span>　　for (int i = 0; i &lt; 10; i++) </span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>Thread t = new Thread(new ThreadStart(acc.DoTransactions));<br></span>　　　　<span>threads[i] = t;<br></span>　　<span>　　}</span><span><br></span>　　<span>　　for (int i = 0; i &lt; 10; i++) </span><span><br></span>　　　　<span>threads[i].Name=i.ToString();<br></span>　　<span>　　for (int i = 0; i &lt; 10; i++) </span><span><br></span>　　　　<span>threads[i].Start();<br></span>　　<span>　　Console.ReadLine();</span><span><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br><br></span><span>　　</span>而多线程公用一个对象时，也会出现和公用代码类似的问题，这种问题就不应该使用<span>lock</span>关键字了，这里需要用到<span>System.Threading</span>中的一个类<span>Monitor</span>，我们可以称之为监视器，<span>Monitor</span>提供了使线程共享资源的方案。 <span><br><br></span>　　<span>Monitor</span>类可以锁定一个对象，一个线程只有得到这把锁才可以对该对象进行操作。对象锁机制保证了在可能引起混乱的情况下一个时刻只有一个线程可以访问这个对象。<span>Monitor</span>必须和一个具体的对象相关联，但是由于它是一个静态的类，所以不能使用它来定义对象，而且它的所有方法都是静态的，不能使用对象来引用。下面代码说明了使用<span>Monitor</span>锁定一个对象的情形：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　......</span><span><br></span><span>　　Queue oQueue=new Queue();<br> ...... </span><span><br></span><span>　　Monitor.Enter(oQueue);</span><span><br></span><span>　　......//</span>现在<span>oQueue</span>对象只能被当前线程操纵了<span><br> Monitor.Exit(oQueue);// </span>释放锁<span> </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>如上所示，当一个线程调用<span>Monitor.Enter()</span>方法锁定一个对象时，这个对象就归它所有了，其它线程想要访问这个对象，只有等待它使用<span>Monitor.Exit()</span>方法释放锁。为了保证线程最终都能释放锁，你可以把<span>Monitor.Exit()</span>方法写在<span>try-catch-finally</span>结构中的<span>finally</span>代码块里。对于任何一个被<span>Monitor</span>锁定的对象，内存中都保存着与它相关的一些信息，其一是现在持有锁的线程的引用，其二是一个预备队列，队列中保存了已经准备好获取锁的线程，其三是一个等待队列，队列中保存着当前正在等待这个对象状态改变的队列的引用。当拥有对象锁的线程准备释放锁时，它使用<span>Monitor.Pulse()</span>方法通知等待队列中的第一个线程，于是该线程被转移到预备队列中，当对象锁被释放时，在预备队列中的线程可以立即获得对象锁。 <span><br><br></span><span>　　</span>下面是一个展示如何使用<span>lock</span>关键字和<span>Monitor</span>类来实现线程的同步和通讯的例子，也是一个典型的生产者与消费者问题。这个例程中，生产者线程和消费者线程是交替进行的，生产者写入一个数，消费者立即读取并且显示，我将在注释中介绍该程序的精要所在。用到的系统命名空间如下：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　using System;</span><span><br></span><span>　　using System.Threading; </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left">首先，我们定义一个被操作的对象的类<span>Cell</span>，在这个类里，有两个方法：<span>ReadFromCell()</span>和<span>WriteToCell</span>。消费者线程将调用<span>ReadFromCell()</span>读取<span>cellContents</span>的内容并且显示出来，生产者进程将调用<span>WriteToCell()</span>方法向<span>cellContents</span>写入数据。</p> 
    <table border="0">
     <tbody>
      <tr>
       <td valign="top"> <p align="left"><span>　　public class Cell</span><span><br></span><span>　　{</span><span><br></span>　　<span>int cellContents; // Cell</span>对象里边的内容<span><br></span>　　<span>bool readerFlag = false; // </span>状态标志，为<span>true</span>时可以读取，为<span>false</span>则正在写入<span><br></span>　　<span>public int ReadFromCell( )<br></span>　　<span>{<br></span>　　<span>　　lock(this) // Lock</span>关键字保证了什么，请大家看前面对<span>lock</span>的介绍<span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>if (!readerFlag)//</span>如果现在不可读取<span><br></span>　　　　<span>{ <br></span>　　　　<span>　　try</span><span><br></span>　　　　<span>　　{</span><span><br></span>　　　　　　<span><em>file:</em>//</span>等待<span>WriteToCell</span>方法中调用<span>Monitor.Pulse()</span>方法<span><br></span>　　　　　　<span>Monitor.Wait(this);<br></span>　　　　<span>　　}</span><span><br></span>　　　　<span>　　catch (SynchronizationLockException e)<br></span>　　　　<span>　　{</span><span><br></span>　　　　　　<span>Console.WriteLine(e);<br></span>　　　　<span>　　}</span><span><br></span>　　　　<span>　　catch (ThreadInterruptedException e)</span><span><br></span>　　　　<span>　　{</span><span><br></span>　　　　　　<span>Console.WriteLine(e);<br></span>　　　　<span>　　}</span><span><br></span>　　　　<span>}<br></span>　　　　<span>Console.WriteLine("Consume: {0}",cellContents);<br></span>　　　　<span>readerFlag = false; <em>file:</em>//</span>重置<span>readerFlag</span>标志，表示消费行为已经完成<span><br></span>　　　　<span>Monitor.Pulse(this); <em>file:</em>//</span>通知<span>WriteToCell()</span>方法（该方法在另外一个线程中执行，等待中）<span><br></span>　　<span>　　}</span><span><br></span>　　<span>　　return cellContents;</span><span><br></span>　　<span>}<br><br></span>　　<span>public void WriteToCell(int n)<br></span>　　<span>{<br></span>　　<span>　　lock(this)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>if (readerFlag)<br></span>　　　　<span>{<br></span>　　　　<span>　　try</span><span><br></span>　　　　<span>　　{</span><span><br></span>　　　　　　<span>Monitor.Wait(this);<br></span>　　　　<span>　　}</span><span><br></span>　　　　<span>　　catch (SynchronizationLockException e)</span><span><br></span>　　　　<span>　　{</span><span><br></span>　　　　　　<span><em>file:</em>//</span>当同步方法（指<span>Monitor</span>类除<span>Enter</span>之外的方法）在非同步的代码区被调用<span><br></span>　　　　　　<span>Console.WriteLine(e);<br></span>　　　　<span>　　}</span><span><br></span>　　　　<span>　　catch (ThreadInterruptedException e)</span><span><br></span>　　　　<span>　　{</span><span><br></span>　　　　　　<span><em>file:</em>//</span>当线程在等待状态的时候中止<span> <br></span>　　　　　　<span>Console.WriteLine(e);<br></span>　　　　<span>　　}</span><span><br></span>　　　　<span>}<br></span>　　　　<span>cellContents = n;<br></span>　　　　<span>Console.WriteLine("Produce: {0}",cellContents);<br></span>　　　　<span>readerFlag = true; <br></span>　　　　<span>Monitor.Pulse(this); <em>file:</em>//</span>通知另外一个线程中正在等待的<span>ReadFromCell()</span>方法<span><br></span>　　<span>　　}</span><span><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>下面定义生产者<span>CellProd</span>和消费者类<span>CellCons</span>，它们都只有一个方法<span>ThreadRun()</span>，以便在<span>Main()</span>函数中提供给线程的<span>ThreadStart</span>代理对象，作为线程的入口。</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　public class CellProd</span><span><br></span><span>　　{</span><span><br></span>　　<span>Cell cell; // </span>被操作的<span>Cell</span>对象<span><br></span>　　<span>int quantity = 1; // </span>生产者生产次数，初始化为<span>1 <br><br></span>　　<span>public CellProd(Cell box, int request)<br></span>　　<span>{<br></span>　　<span>　　//</span>构造函数<span><br></span>　　<span>　　cell = box; <br></span>　　<span>　　quantity = request; </span><span><br></span>　　<span>}<br></span>　　<span>public void ThreadRun( )<br></span>　　<span>{<br></span>　　<span>　　for(int looper=1; looper&lt;=quantity; looper++)</span><span><br></span>　　　　<span>cell.WriteToCell(looper); <em>file:</em>//</span>生产者向操作对象写入信息<span><br></span>　　<span>}<br> } </span><span><br><br></span><span>　　public class CellCons</span><span><br></span><span>　　{</span><span><br></span>　　<span>Cell cell; <br></span>　　<span>int quantity = 1; <br><br></span>　　<span>public CellCons(Cell box, int request)<br></span>　　<span>{<br></span>　　<span>　　cell = box; </span><span><br></span>　　<span>　　quantity = request; </span><span><br></span>　　<span>}<br></span>　　<span>public void ThreadRun( )<br></span>　　<span>{<br></span>　　<span>　　int valReturned;</span><span><br></span>　　<span>　　for(int looper=1; looper&lt;=quantity; looper++)</span><span><br></span>　　　　<span>valReturned=cell.ReadFromCell( );//</span>消费者从操作对象中读取信息<span><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left">然后在下面这个类<span>MonitorSample</span>的<span>Main()</span>函数中我们要做的就是创建两个线程分别作为生产者和消费者，使用<span>CellProd.ThreadRun()</span>方法和<span>CellCons.ThreadRun()</span>方法对同一个<span>Cell</span>对象进行操作。</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　public class MonitorSample</span><span><br></span><span>　　{</span><span><br></span>　　<span>public static void Main(String[] args)<br></span>　　<span>{<br></span>　　<span>　　int result = 0; <em>file:</em>//</span>一个标志位，如果是<span>0</span>表示程序没有出错，如果是<span>1</span>表明有错误发生<span><br></span>　　<span>　　Cell cell = new Cell( ); </span><span><br><br></span>　　<span>　　//</span>下面使用<span>cell</span>初始化<span>CellProd</span>和<span>CellCons</span>两个类，生产和消费次数均为<span>20</span>次<span><br></span>　　<span>　　CellProd prod = new CellProd(cell, 20); <br></span>　　<span>　　CellCons cons = new CellCons(cell, 20); </span><span><br><br></span>　　<span>　　Thread producer = new Thread(new ThreadStart(prod.ThreadRun));</span><span><br></span>　　<span>　　Thread consumer = new Thread(new ThreadStart(cons.ThreadRun));</span><span><br></span>　　<span>　　//</span>生产者线程和消费者线程都已经被创建，但是没有开始执行<span> <br><br></span>　　<span>　　try</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>producer.Start( );<br></span>　　　　<span>consumer.Start( ); <br><br></span>　　　　<span>producer.Join( ); <br></span>　　　　<span>consumer.Join( );<br></span>　　　　<span>Console.ReadLine();<br></span>　　<span>　　}</span><span><br></span>　　<span>　　catch (ThreadStateException e)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span><em>file:</em>//</span>当线程因为所处状态的原因而不能执行被请求的操作<span><br></span>　　　　<span>Console.WriteLine(e); <br></span>　　　　<span>result = 1; <br></span>　　<span>　　}</span><span><br></span>　　<span>　　catch (ThreadInterruptedException e)<br></span>　　<span>　　{</span><span><br></span>　　　　<span><em>file:</em>//</span>当线程在等待状态的时候中止<span><br></span>　　　　<span>Console.WriteLine(e); <br></span>　　　　<span>result = 1; <br></span>　　<span>　　}</span><span><br></span>　　<span>　　//</span>尽管<span>Main()</span>函数没有返回值，但下面这条语句可以向父进程返回执行结果<span><br></span>　　<span>　　Environment.ExitCode = result;</span><span><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left">大家可以看到，在上面的例程中，同步是通过等待<span>Monitor.Pulse()</span>来完成的。首先生产者生产了一个值，而同一时刻消费者处于等待状态，直到收到生产者的<span>“</span>脉冲<span>(Pulse)”</span>通知它生产已经完成，此后消费者进入消费状态，而生产者开始等待消费者完成操作后将调用<span>Monitor.Pulese()</span>发出的<span>“</span>脉冲<span>”</span>。它的执行结果很简单：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　Produce: 1</span><span><br></span><span>　　Consume: 1</span><span><br></span><span>　　Produce: 2</span><span><br></span><span>　　Consume: 2</span><span><br></span><span>　　Produce: 3</span><span><br></span><span>　　Consume: 3</span><span><br></span><span>　　...</span><span><br></span><span>　　...</span><span><br></span><span>　　Produce: 20</span><span><br></span><span>　　Consume: 20 </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p><span><br></span><span>　　</span>事实上，这个简单的例子已经帮助我们解决了多线程应用程序中可能出现的大问题，只要领悟了解决线程间冲突的基本方法，很容易把它应用到比较复杂的程序中去。 <span><br><br></span>　　<strong>四、线程池和定时器</strong><strong><span>——</span></strong><strong>多线程的自动管理</strong> <span><br></span><span>　　</span>在多线程的程序中，经常会出现两种情况。一种情况下，应用程序中的线程把大部分的时间花费在等待状态，等待某个事件发生，然后才能给予响应；而另外一种情况则是线程平常都处于休眠状态，只是周期性地被唤醒。在<span>.net framework</span>里边，我们使用<span>ThreadPool</span>来对付第一种情况，使用<span>Timer</span>来对付第二种情况。<span><br><br></span><span>　　ThreadPool</span>类提供一个由系统维护的线程池<span>——</span>可以看作一个线程的容器，该容器需要<span>Windows 2000</span>以上版本的系统支持，因为其中某些方法调用了只有高版本的<span>Windows</span>才有的<span>API</span>函数。你可以使用<span>ThreadPool.QueueUserWorkItem()</span>方法将线程安放在线程池里，该方法的原型如下：<span><br><br></span><span>　　//</span>将一个线程放进线程池，该线程的<span>Start()</span>方法将调用<span>WaitCallback</span>代理对象代表的函数<span><br></span><span>　　public static bool QueueUserWorkItem(WaitCallback);</span><span><br></span><span>　　//</span>重载的方法如下，参数<span>object</span>将传递给<span>WaitCallback</span>所代表的方法<span><br></span><span>　　public static bool QueueUserWorkItem(WaitCallback, object);</span><span><br><br><br></span><span>　　</span>要注意的是，<span>ThreadPool</span>类也是一个静态类，你不能也不必要生成它的对象，而且一旦使用该方法在线程池中添加了一个项目，那么该项目将是没有办法取消的。在这里你无需自己建立线程，只需把你要做的工作写成函数，然后作为参数传递给<span>ThreadPool.QueueUserWorkItem()</span>方法就行了，传递的方法就是依靠<span>WaitCallback</span>代理对象，而线程的建立、管理、运行等等工作都是由系统自动完成的，你无须考虑那些复杂的细节问题，线程池的优点也就在这里体现出来了，就好像你是公司老板<span>——</span>只需要安排工作，而不必亲自动手。</p> 
    <p align="left">下面的例程演示了<span>ThreadPool</span>的用法。首先程序创建了一个<span>ManualResetEvent</span>对象，该对象就像一个信号灯，可以利用它的信号来通知其它线程，本例中当线程池中所有线程工作都完成以后，<span>ManualResetEvent</span>的对象将被设置为有信号，从而通知主线程继续运行。它有几个重要的方法：<span>Reset()</span>，<span>Set()</span>，<span>WaitOne()</span>。初始化该对象时，用户可以指定其默认的状态（有信号<span>/</span>无信号），在初始化以后，该对象将保持原来的状态不变直到它的<span>Reset()</span>或者<span>Set()</span>方法被调用，<span>Reset()</span>方法将其设置为无信号状态，<span>Set()</span>方法将其设置为有信号状态。<span>WaitOne()</span>方法使当前线程挂起直到<span>ManualResetEvent</span>对象处于有信号状态，此时该线程将被激活。然后，程序将向线程池中添加工作项，这些以函数形式提供的工作项被系统用来初始化自动建立的线程。当所有的线程都运行完了以后，<span>ManualResetEvent.Set()</span>方法被调用，因为调用了<span>ManualResetEvent.WaitOne()</span>方法而处在等待状态的主线程将接收到这个信号，于是它接着往下执行，完成后边的工作。</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span><br> using System;<br> using System.Collections; </span><span><br></span><span>　　using System.Threading;</span><span><br><br></span><span>　　//</span>这是用来保存信息的数据结构，将作为参数被传递<span><br> public class SomeState </span><span><br></span><span>　　{</span><span><br></span>　　<span>public int Cookie;<br></span>　　<span>public SomeState(int iCookie)<br></span>　　<span>{<br></span>　　<span>　　Cookie = iCookie;</span><span><br></span>　　<span>}<br> } </span><span><br><br></span><span>　　public class Alpha</span><span><br></span><span>　　{</span><span><br></span>　　<span>public Hashtable HashCount;<br></span>　　<span>public ManualResetEvent eventX;<br></span>　　<span>public static int iCount = 0;<br></span>　　<span>public static int iMaxCount = 0;<br></span>　　<span>public Alpha(int MaxCount) <br></span>　　<span>{<br></span>　　<span>　　HashCount = new Hashtable(MaxCount);</span><span><br></span>　　<span>　　iMaxCount = MaxCount;</span><span><br></span>　　<span>}<br><br></span>　　<span><em>file:</em>//</span>线程池里的线程将调用<span>Beta()</span>方法<span><br></span>　　<span>public void Beta(Object state)<br></span>　　<span>{<br></span>　　<span>　　//</span>输出当前线程的<span>hash</span>编码值和<span>Cookie</span>的值<span><br></span>　　<span>　　Console.WriteLine(" {0} {1} :", Thread.CurrentThread.GetHashCode(),</span><span><br></span>　　<span>　　((SomeState)state).Cookie);</span><span><br></span>　　<span>　　Console.WriteLine("HashCount.Count=={0}, Thread.CurrentThread.GetHashCode()=={1}", HashCount.Count, Thread.CurrentThread.GetHashCode());<br></span>　　<span>　　lock (HashCount) </span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span><em>file:</em>//</span>如果当前的<span>Hash</span>表中没有当前线程的<span>Hash</span>值，则添加之<span><br></span>　　　　<span>if (!HashCount.ContainsKey(Thread.CurrentThread.GetHashCode()))<br></span>　　　　<span>　　HashCount.Add (Thread.CurrentThread.GetHashCode(), 0);</span><span><br></span>　　　　<span>HashCount[Thread.CurrentThread.GetHashCode()] = <br> ((int)HashCount[Thread.CurrentThread.GetHashCode()])+1;<br></span>　　<span>　　}</span><span><br><br></span>　　<span>　　int iX = 2000;</span><span><br></span>　　<span>　　Thread.Sleep(iX);</span><span><br></span>　　<span>　　//Interlocked.Increment()</span>操作是一个原子操作，具体请看下面说明<span><br></span>　　<span>　　Interlocked.Increment(ref iCount);</span><span><br></span>　　<span>　　if (iCount == iMaxCount)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>Console.WriteLine();<br></span>　　　　<span>Console.WriteLine("Setting eventX ");<br></span>　　　　<span>eventX.Set();<br></span>　　<span>　　}</span><span><br></span>　　<span>}<br> } </span><span><br><br></span><span>　　public class SimplePool</span><span><br></span><span>　　{</span><span><br></span>　　<span>public static int Main(string[] args)<br></span>　　<span>{<br></span>　　<span>　　Console.WriteLine("Thread Pool Sample:");</span><span><br></span>　　<span>　　bool W2K = false;</span><span><br></span>　　<span>　　int MaxCount = 10;//</span>允许线程池中运行最多<span>10</span>个线程<span><br></span>　　<span>　　//</span>新建<span>ManualResetEvent</span>对象并且初始化为无信号状态<span><br></span>　　<span>　　ManualResetEvent eventX = new ManualResetEvent(false);</span><span><br></span>　　<span>　　Console.WriteLine("Queuing {0} items to Thread Pool", MaxCount);</span><span><br></span>　　<span>　　Alpha oAlpha = new Alpha(MaxCount); <em>file:</em>//</span>创建工作项<span><br></span>　　<span>　　//</span>注意初始化<span>oAlpha</span>对象的<span>eventX</span>属性<span><br></span>　　<span>　　oAlpha.eventX = eventX;</span><span><br></span>　　<span>　　Console.WriteLine("Queue to Thread Pool 0");</span><span><br></span>　　<span>　　try</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span><em>file:</em>//</span>将工作项装入线程池<span> <br></span>　　　　<span><em>file:</em>//</span>这里要用到<span>Windows 2000</span>以上版本才有的<span>API</span>，所以可能出现<span>NotSupportException</span>异常<span><br></span>　　　　<span>ThreadPool.QueueUserWorkItem(new WaitCallback(oAlpha.Beta),<br></span>　　　　<span>new SomeState(0));<br></span>　　　　<span>W2K = true;<br></span>　　<span>　　}</span><span><br></span>　　<span>　　catch (NotSupportedException)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>Console.WriteLine("These API's may fail when called on a non-Windows 2000 system.");<br></span>　　　　<span>W2K = false;<br></span>　　<span>　　}</span><span><br></span>　　<span>　　if (W2K)//</span>如果当前系统支持<span>ThreadPool</span>的方法<span>.<br></span>　　<span>　　{</span><span><br></span>　　　　<span>for (int iItem=1;iItem &lt; MaxCount;iItem++)<br></span>　　　　<span>{<br></span>　　　　<span>　　//</span>插入队列元素<span><br></span>　　　　<span>　　Console.WriteLine("Queue to Thread Pool {0}", iItem);</span><span><br></span>　　　　<span>　　ThreadPool.QueueUserWorkItem(new WaitCallback(oAlpha.Beta),new SomeState(iItem));</span><span><br></span>　　　　<span>}<br></span>　　　　<span>Console.WriteLine("Waiting for Thread Pool to drain");<br></span>　　　　<span><em>file:</em>//</span>等待事件的完成，即线程调用<span>ManualResetEvent.Set()</span>方法<span><br></span>　　　　<span>eventX.WaitOne(Timeout.Infinite,true);<br></span>　　　　<span><em>file:</em>//WaitOne()</span>方法使调用它的线程等待直到<span>eventX.Set()</span>方法被调用<span><br></span>　　　　<span>Console.WriteLine("Thread Pool has been drained (Event fired)");<br></span>　　　　<span>Console.WriteLine();<br></span>　　　　<span>Console.WriteLine("Load across threads");<br></span>　　　　<span>foreach(object o in oAlpha.HashCount.Keys)<br></span>　　　　<span>Console.WriteLine("{0} {1}", o, oAlpha.HashCount[o]);<br></span>　　<span>　　}</span><span><br></span>　　<span>　　Console.ReadLine();</span><span><br></span>　　<span>　　return 0;</span><span><br><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>程序中有些小地方应该引起我们的注意。<span>SomeState</span>类是一个保存信息的数据结构，在上面的程序中，它作为参数被传递给每一个线程，你很容易就能理解这个，因为你需要把一些有用的信息封装起来提供给线程，而这种方式是非常有效的。程序出现的<span>InterLocked</span>类也是专为多线程程序而存在的，它提供了一些有用的原子操作，所谓原子操作就是在多线程程序中，如果这个线程调用这个操作修改一个变量，那么其他线程就不能修改这个变量了，这跟<span>lock</span>关键字在本质上是一样的。<span><br><br></span><span>　　</span>我们应该彻底地分析上面的程序，把握住线程池的本质，理解它存在的意义是什么，这样我们才能得心应手地使用它。下面是该程序的输出结果：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　Thread Pool Sample:</span><span><br></span><span>　　Queuing 10 items to Thread Pool</span><span><br></span><span>　　Queue to Thread Pool 0</span><span><br></span><span>　　Queue to Thread Pool 1</span><span><br></span><span>　　...</span><span><br></span><span>　　...</span><span><br></span><span>　　Queue to Thread Pool 9</span><span><br></span><span>　　Waiting for Thread Pool to drain</span><span><br></span><span>　　98 0 :</span><span><br></span><span>　　HashCount.Count==0, Thread.CurrentThread.GetHashCode()==98<br> 100 1 : </span><span><br></span><span>　　HashCount.Count==1, Thread.CurrentThread.GetHashCode()==100</span><span><br></span><span>　　98 2 :</span><span><br></span><span>　　...</span><span><br></span><span>　　...</span><span><br></span><span>　　Setting eventX</span><span><br></span><span>　　Thread Pool has been drained (Event fired) </span><span><br></span><span>　　Load across threads</span><span><br></span><span>　　101 2</span><span><br></span><span>　　100 3</span><span><br></span><span>　　98 4</span><span><br></span><span>　　102 1</span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>与<span>ThreadPool</span>类不同，<span>Timer</span>类的作用是设置一个定时器，定时执行用户指定的函数，而这个函数的传递是靠另外一个代理对象<span>TimerCallback</span>，它必须在创建<span>Timer</span>对象时就指定，并且不能更改。定时器启动后，系统将自动建立一个新的线程，并且在这个线程里执行用户指定的函数。下面的语句初始化了一个<span>Timer</span>对象：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　Timer timer = new Timer(timerDelegate, s,1000, 1000); </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span>　<span>　</span>第一个参数指定了<span>TimerCallback</span>代理对象；第二个参数的意义跟上面提到的<span>WaitCallback</span>代理对象的一样，作为一个传递数据的对象传递给要调用的方法；第三个参数是延迟时间<span>——</span>计时开始的时刻距现在的时间，单位是毫秒；第四个参数是定时器的时间间隔<span>——</span>计时开始以后，每隔这么长的一段时间，<span>TimerCallback</span>所代表的方法将被调用一次，单位也是毫秒。这句话的意思就是将定时器的延迟时间和时间间隔都设为<span>1</span>秒钟。<span><br><br></span><span>　　</span>定时器的设置是可以改变的，只要调用<span>Timer.Change()</span>方法，这是一个参数类型重载的方法，一般使用的原型如下：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　 public bool Change(long, long);</span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span>　　下面这段代码将前边设置的定时器修改了一下：</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span>　　 timer.Change(10000,2000); </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>很显然，定时器<span>timer</span>的时间间隔被重新设置为<span>2</span>秒，停止计时<span>10</span>秒后生效。<span><br><br></span><span>　　</span>下面这段程序演示了<span>Timer</span>类的用法。</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span><br> using System;</span><span><br></span><span>　　using System.Threading; </span><span><br></span><span>　　class TimerExampleState </span><span><br></span><span>　　{</span><span><br></span>　　<span>public int counter = 0;<br></span>　　<span>public Timer tmr;<br> } </span><span><br><br></span><span>　　class App </span><span><br></span><span>　　{</span><span><br></span>　　<span>public static void Main()<br></span>　　<span>{<br></span>　　<span>　　TimerExampleState s = new TimerExampleState();</span><span><br><br></span>　　<span>　　//</span>创建代理对象<span>TimerCallback</span>，该代理将被定时调用<span><br></span>　　<span>　　TimerCallback timerDelegate = new TimerCallback(CheckStatus);</span><span><br><br></span>　　<span>　　//</span>创建一个时间间隔为<span>1s</span>的定时器<span><br></span>　　<span>　　Timer timer = new Timer(timerDelegate, s,1000, 1000);</span><span><br></span>　　<span>　　s.tmr = timer;</span><span><br><br></span>　　<span>　　//</span>主线程停下来等待<span>Timer</span>对象的终止<span><br></span>　　<span>　　while(s.tmr != null)</span><span><br></span>　　　　<span>Thread.Sleep(0);<br></span>　　<span>　　Console.WriteLine("Timer example done.");</span><span><br></span>　　<span>　　Console.ReadLine();</span><span><br></span>　　<span>}<br></span>　　<span><em>file:</em>//</span>下面是被定时调用的方法<span><br><br></span>　　<span>static void CheckStatus(Object state)<br></span>　　<span>{<br></span>　　<span>　　TimerExampleState s =(TimerExampleState)state;</span><span><br></span>　　<span>　　s.counter++;</span><span><br></span>　　<span>　　Console.WriteLine("{0} Checking Status {1}.",DateTime.Now.TimeOfDay, s.counter);</span><span><br></span>　　<span>　　if(s.counter == 5)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span><em>file:</em>//</span>使用<span>Change</span>方法改变了时间间隔<span><br></span>　　　　<span>(s.tmr).Change(10000,2000);<br></span>　　　　<span>Console.WriteLine("changed...");<br></span>　　<span>　　}</span><span><br></span>　　<span>　　if(s.counter == 10)</span><span><br></span>　　<span>　　{</span><span><br></span>　　　　<span>Console.WriteLine("disposing of timer...");<br></span>　　　　<span>s.tmr.Dispose();<br></span>　　　　<span>s.tmr = null;<br></span>　　<span>　　}</span><span><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>程序首先创建了一个定时器，它将在创建<span>1</span>秒之后开始每隔<span>1</span>秒调用一次<span>CheckStatus()</span>方法，当调用<span>5</span>次以后，在<span>CheckStatus()</span>方法中修改了时间间隔为<span>2</span>秒，并且指定在<span>10</span>秒后重新开始。当计数达到<span>10</span>次，调用<span>Timer.Dispose()</span>方法删除了<span>timer</span>对象，主线程于是跳出循环，终止程序。程序执行的结果如下：<span><br><br></span></p> 
    <div> 
     <table border="0">
      <tbody>
       <tr>
        <td> <p align="left"><span><img width="667" height="309" alt="" src=""></span></p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p><span><br></span><span>　　</span>上面就是对<span>ThreadPool</span>和<span>Timer</span>两个类的简单介绍，充分利用系统提供的功能，可以为我们省去很多时间和精力<span>——</span>特别是对很容易出错的多线程程序。同时我们也可以看到<span>.net Framework</span>强大的内置对象，这些将对我们的编程带来莫大的方便。</p> 
    <p align="left"><strong>、互斥对象</strong><strong><span>——</span></strong><strong>更加灵活的同步方式</strong><span><br><br></span><span>　　</span>有 时候你会觉得上面介绍的方法好像不够用，对，我们解决了代码和资源的同步问题，解决了多线程自动化管理和定时触发的问题，但是如何控制多个线程相互之间的 联系呢？例如我要到餐厅吃饭，在吃饭之前我先得等待厨师把饭菜做好，之后我开始吃饭，吃完我还得付款，付款方式可以是现金，也可以是信用卡，付款之后我才 能离开。分析一下这个过程，我吃饭可以看作是主线程，厨师做饭又是一个线程，服务员用信用卡收款和收现金可以看作另外两个线程，大家可以很清楚地看到其中 的关系<span>——</span>我吃饭必须等待厨师做饭，然后等待两个收款线程之中任意一个的完成，然后我吃饭这个线程可以执行离开这个步骤，于是我吃饭才算结束了。事实上，现实中有着比这更复杂的联系，我们怎样才能很好地控制它们而不产生冲突和重复呢？<span><br><br></span><span>　　</span>这种情况下，我们需要用到互斥对象，即<span>System.Threading</span>命名空间中的<span>Mutex</span>类。大家一定坐过出租车吧，事实上我们可以把<span>Mutex</span>看作一个出租车，那么乘客就是线程了，乘客首先得等车，然后上车，最后下车，当一个乘客在车上时，其他乘客就只有等他下车以后才可以上车。而线程与<span>Mutex</span>对象的关系也正是如此，线程使用<span>Mutex.WaitOne()</span>方法等待<span>Mutex</span>对象被释放，如果它等待的<span>Mutex</span>对象被释放了，它就自动拥有这个对象，直到它调用<span>Mutex.ReleaseMutex()</span>方法释放这个对象，而在此期间，其他想要获取这个<span>Mutex</span>对象的线程都只有等待。<span><br><br></span><span>　　</span>下面这个例子使用了<span>Mutex</span>对象来同步四个线程，主线程等待四个线程的结束，而这四个线程的运行又是与两个<span>Mutex</span>对象相关联的。其中还用到<span>AutoResetEvent</span>类的对象，如同上面提到的<span>ManualResetEvent</span>对象一样，大家可以把它简单地理解为一个信号灯，使用<span>AutoResetEvent.Set()</span>方法可以设置它为有信号状态，而使用<span>AutoResetEvent.Reset()</span>方法把它设置为无信号状态。这里用它的有信号状态来表示一个线程的结束。</p> 
    <table border="0">
     <tbody>
      <tr>
       <td> <p align="left"><span><br> // Mutex.cs</span><span><br></span><span>　　using System;</span><span><br></span><span>　　using System.Threading;</span><span><br><br></span><span>　　public class MutexSample</span><span><br></span><span>　　{</span><span><br></span>　　<span>static Mutex gM1;<br></span>　　<span>static Mutex gM2;<br></span>　　<span>const int ITERS = 100;<br></span>　　<span>static AutoResetEvent Event1 = new AutoResetEvent(false);<br></span>　　<span>static AutoResetEvent Event2 = new AutoResetEvent(false);<br></span>　　<span>static AutoResetEvent Event3 = new AutoResetEvent(false);<br></span>　　<span>static AutoResetEvent Event4 = new AutoResetEvent(false);<br><br></span>　　<span>public static void Main(String[] args)<br></span>　　<span>{<br></span>　　<span>　　Console.WriteLine("Mutex Sample ...");</span><span><br></span>　　<span>　　//</span>创建一个<span>Mutex</span>对象，并且命名为<span>MyMutex<br></span>　　<span>　　gM1 = new Mutex(true,"MyMutex");</span><span><br></span>　　<span>　　//</span>创建一个未命名的<span>Mutex </span>对象<span>.<br></span>　　<span>　　gM2 = new Mutex(true);</span><span><br></span>　　<span>　　Console.WriteLine(" - Main Owns gM1 and gM2");</span><span><br><br></span>　　<span>　　AutoResetEvent[] evs = new AutoResetEvent[4];<br></span>　　<span>　　evs[0] = Event1; <em>file:</em>//</span>为后面的线程<span>t1,t2,t3,t4</span>定义<span>AutoResetEvent</span>对象<span><br></span>　　<span>　　evs[1] = Event2; </span><span><br></span>　　<span>　　evs[2] = Event3; </span><span><br></span>　　<span>　　evs[3] = Event4; </span><span><br><br></span>　　<span>　　MutexSample tm = new MutexSample( );</span><span><br></span>　　<span>　　Thread t1 = new Thread(new ThreadStart(tm.t1Start));<br></span>　　<span>　　Thread t2 = new Thread(new ThreadStart(tm.t2Start));</span><span><br></span>　　<span>　　Thread t3 = new Thread(new ThreadStart(tm.t3Start));</span><span><br></span>　　<span>　　Thread t4 = new Thread(new ThreadStart(tm.t4Start));</span><span><br></span>　　<span>　　t1.Start( );// </span>使用<span>Mutex.WaitAll()</span>方法等待一个<span>Mutex</span>数组中的对象全部被释放<span><br></span>　　<span>　　t2.Start( );// </span>使用<span>Mutex.WaitOne()</span>方法等待<span>gM1</span>的释放<span><br></span>　　<span>　　t3.Start( );// </span>使用<span>Mutex.WaitAny()</span>方法等待一个<span>Mutex</span>数组中任意一个对象被释放<span><br></span>　　<span>　　t4.Start( );// </span>使用<span>Mutex.WaitOne()</span>方法等待<span>gM2</span>的释放<span><br><br><br></span>　　<span>　　Thread.Sleep(2000);</span><span><br></span>　　<span>　　Console.WriteLine(" - Main releases gM1");</span><span><br></span>　　<span>　　gM1.ReleaseMutex( ); <em>file:</em>//</span>线程<span>t2,t3</span>结束条件满足<span><br><br></span>　　<span>　　Thread.Sleep(1000);<br></span>　　<span>　　Console.WriteLine(" - Main releases gM2");</span><span><br></span>　　<span>　　gM2.ReleaseMutex( ); <em>file:</em>//</span>线程<span>t1,t4</span>结束条件满足<span><br><br></span>　　<span>　　//</span>等待所有四个线程结束<span><br></span>　　<span>　　WaitHandle.WaitAll(evs); </span><span><br></span>　　<span>　　Console.WriteLine("... Mutex Sample");</span><span><br></span>　　<span>　　Console.ReadLine();</span><span><br></span>　　<span>}<br><br></span>　　<span>public void t1Start( )<br></span>　　<span>{<br></span>　　<span>　　Console.WriteLine("t1Start started, Mutex.WaitAll(Mutex[])");</span><span><br></span>　　<span>　　Mutex[] gMs = new Mutex[2];</span><span><br></span>　　<span>　　gMs[0] = gM1;//</span>创建一个<span>Mutex</span>数组作为<span>Mutex.WaitAll()</span>方法的参数<span><br></span>　　<span>　　gMs[1] = gM2;</span><span><br></span>　　<span>　　Mutex.WaitAll(gMs);//</span>等待<span>gM1</span>和<span>gM2</span>都被释放<span><br></span>　　<span>　　Thread.Sleep(2000);</span><span><br></span>　　<span>　　Console.WriteLine("t1Start finished, Mutex.WaitAll(Mutex[]) satisfied");<br></span>　　<span>　　Event1.Set( ); <em>file:</em>//</span>线程结束，将<span>Event1</span>设置为有信号状态<span><br></span>　　<span>}<br><br></span>　　<span>public void t2Start( )<br></span>　　<span>{<br></span>　　<span>　　Console.WriteLine("t2Start started, gM1.WaitOne( )");</span><span><br></span>　　<span>　　gM1.WaitOne( );//</span>等待<span>gM1</span>的释放<span><br></span>　　<span>　　Console.WriteLine("t2Start finished, gM1.WaitOne( ) satisfied");<br></span>　　<span>　　Event2.Set( );//</span>线程结束，将<span>Event2</span>设置为有信号状态<span><br></span>　　<span>}<br><br></span>　　<span>public void t3Start( )<br></span>　　<span>{<br></span>　　<span>　　Console.WriteLine("t3Start started, Mutex.WaitAny(Mutex[])");</span><span><br></span>　　<span>　　Mutex[] gMs = new Mutex[2];</span><span><br></span>　　<span>　　gMs[0] = gM1;//</span>创建一个<span>Mutex</span>数组作为<span>Mutex.WaitAny()</span>方法的参数<span><br></span>　　<span>　　gMs[1] = gM2;</span><span><br></span>　　<span>　　Mutex.WaitAny(gMs);//</span>等待数组中任意一个<span>Mutex</span>对象被释放<span><br></span>　　<span>　　Console.WriteLine("t3Start finished, Mutex.WaitAny(Mutex[])");</span><span><br></span>　　<span>　　Event3.Set( );//</span>线程结束，将<span>Event3</span>设置为有信号状态<span><br></span>　　<span>}<br><br></span>　　<span>public void t4Start( )<br></span>　　<span>{<br></span>　　<span>　　Console.WriteLine("t4Start started, gM2.WaitOne( )");<br></span>　　<span>　　gM2.WaitOne( );//</span>等待<span>gM2</span>被释放<span><br></span>　　<span>　　Console.WriteLine("t4Start finished, gM2.WaitOne( )");</span><span><br></span>　　<span>　　Event4.Set( );//</span>线程结束，将<span>Event4</span>设置为有信号状态<span><br></span>　　<span>}<br> } </span></p> </td>
      </tr>
     </tbody>
    </table>
    <p align="left"><span><br></span><span>　　</span>下面是该程序的执行结果：<span><br><br></span></p> 
    <div> 
     <table border="0">
      <tbody>
       <tr>
        <td> <p align="left"><span><img width="669" height="246" alt="" src=""></span></p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p><span><br></span><span>　　</span>从执行结果可以很清楚地看到，线程<span>t2,t3</span>的运行是以<span>gM1</span>的释放为条件的，而<span>t4</span>在<span>gM2</span>释放后开始执行，<span>t1</span>则在<span>gM1</span>和<span>gM2</span>都被释放了之后才执行。<span>Main()</span>函数最后，使用<span>WaitHandle</span>等待所有的<span>AutoResetEvent</span>对象的信号，这些对象的信号代表相应线程的结束。<span><br><br></span>　　<strong>六、小结</strong><span><br><br></span><span>　　</span>多线程程序设计是一个庞大的主题，而本文试图在<span>.net Framework</span>环境下，使用最新的<span>C#</span>语言来描述多线程程序的概貌。希望本文能有助于大家理解线程这种概念，理解多线程的用途，理解它的<span>C#</span>实现方法，理解线程将为我们带来的好处和麻烦。<span>C#</span>是一种新的语言，因此它的线程机制也有许多独特的地方，希望大家能通过本文清楚地看到这些，从而可以对线程进行更深入的理解和探索。</p> 
   </div> 
   <div>
    专注于企业信息化，最近对股票数据分析较为感兴趣，可免费分享股票个股主力资金实时变化趋势分析工具，股票交流QQ群：457394862
   </div> 
   <div>
    <br>
   </div> 
   <div>
    本文转自沧海-重庆博客园博客，原文链接：http://www.cnblogs.com/omygod/archive/2006/11/08/554546.html，如需转载请自行联系原作者
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
