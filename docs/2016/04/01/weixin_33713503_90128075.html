<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>学习 Linux，101: 自定义或编写简单脚本【转】 « NotBeCN</title>
  <meta name="description" content="                        转自：http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html      学习如何使用标准的 shell 语法、循环和控制结构，以及成功或失败测试来自定义现有脚本或编写简单的新 bash ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/04/01/weixin_33713503_90128075.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">学习 Linux，101: 自定义或编写简单脚本【转】</h1>
    <p class="post-meta">Apr 1, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <div class="dw-summary-columns"> 
    <div class="ibm-col-6-4"> 
     <p>转自：<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html" rel="nofollow">http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html</a></p> 
     <p>学习如何使用标准的 shell 语法、循环和控制结构，以及成功或失败测试来自定义现有脚本或编写简单的新 bash 脚本。您可以使用本教程中的资料学习针对 Linux 系统管理员认证的 LPI 102 考试内容，或者仅为兴趣而学习。</p> 
     <p><a class="ibm-forward-link" href="http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?search_by=%E5%AD%A6%E4%B9%A0+Linux%EF%BC%8C101" rel="nofollow">查看本系列更多内容</a>&nbsp;<span class="dw-summary-bar">|&nbsp;<span>0<img class="dw-cmts-arrow" src="https://yqfile.alicdn.com/img_431c075af271279e2eac08670205e10e.png" alt="" width="7" height="7">&nbsp;<a class="dw-cmt-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#icomments" rel="nofollow">评论</a></span></span></p> 
    </div> 
    <div class="ibm-col-6-2 dw-toc-margin"> 
     <p><a class="ibm-popup-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#authorN10029" rel="nofollow">Ian Shields</a>, Linux 作家, Freelance</p> 
     <p>2016 年 2 月 23 日</p> 
     <div class="ibm-container"> 
      <div class="ibm-container-body"> 
       <ul class="ibm-twisty">
        <li> <a class="ibm-twisty-trigger ibm-twisty-trigger-closed" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#toggle" rel="nofollow"><img src="https://yqfile.alicdn.com/img_fc94fb0c3ed8a8f909dbc7630a0987ff.gif" alt="expand"></a><span class="ibm-twisty-head">内容</span> </li> 
       </ul>
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div> 
     <div> 
      <div> 
       <div class="ibm-columns"> 
        <div class="ibm-col-1-1"> 
         <div class="dw-article-sidebar dw-bluemix"> 
          <img src="https://yqfile.alicdn.com/img_53bb432f53673e86d66faf52292e101e.png" alt="" width="64" height="64">
          <p>在 IBM Bluemix 云平台上开发并部署您的下一个应用。</p> 
          <p><a id="tutc-sbar-bmix-home-btn-ABa" class="dw-button-large" href="https://developer.ibm.com/sso/bmregistration?lang=zh_CN&amp;ca=dwchina-_-bluemix-_-l-lpic1-105-2-_-sidebar" rel="nofollow">开始您的试用</a></p> 
         </div> 
         <h2>概述</h2> 
         <p>在本教程中，学习自定义现有脚本或编写简单的新 bash 脚本。学习：</p> 
         <ul class="ibm-bullet-list">
          <li>使用标准的循环和控制结构</li> 
          <li>使用命令替换</li> 
          <li>测试来自命令的返回值来确定成功还是失败</li> 
          <li>有条件地向超级用户发送邮件</li> 
          <li>确保使用正确的 shell 解释您的脚本</li> 
          <li>管理脚本的位置、所有权、执行和 suid 权利</li> 
         </ul>
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>使用 Linux shell 编程</h2> 
         <p>在本教程中，我将通过&nbsp;<code>&amp;&amp;</code>和&nbsp;<code>||</code>来完善简单的命令执行和最小化测试。我将介绍如何使用 bash shell 控制结构为 shell 脚本增添强大的编程功能。首先将介绍如何执行您可赖以制定控制决策的各种测试。然后介绍如何使用&nbsp;<code>if</code>-<code>then</code>-<code>else</code>、<code>for</code>、<code>while</code>和&nbsp;<code>case</code>控制结构来利用这些测试结果。最后，我将介绍一些重要问题，关于谁有权利运行您的脚本，以及当您的脚本没有处于终端用户的直接控制下时，运行时如何通知超级用户（根用户）。</p> 
         <div class="dw-sidebar ibm-inset"> 
          <h2>关于本系列</h2> 
          <p>本教程系列将帮助学习 Linux 系统管理任务。您还可以使用这些教程中的资料对&nbsp;<a href="http://www.lpi.org/" rel="nofollow">Linux Professional Institute 的 LPIC-1：Linux 服务器专业认证考试</a>进行备考。</p> 
          <p>请参阅 “<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-map/" rel="nofollow"><em>学习 Linux，101</em>：LPIC-1 学习路线图</a>”，查看本系列中每部教程的描述和链接。这个路线图正在开发之中，它反映了 2015 年 4 月 15 日更新的 4.0 版 LPIC-1 考试目标。在完成这些教程中，会将它们添加到路线图中。</p> 
         </div> 
         <p>本教程帮助您对 Linux Server Professional (LPIC-1) 考试 102 的主题 105 中的目标 105.2 进行应考准备。该目标的权重为 4。</p> 
         <h3>前提条件</h3> 
         <p>要充分掌握本系列中的教程，您需要：</p> 
         <ul class="ibm-bullet-list">
          <li>掌握 Linux 的基本知识</li> 
          <li>熟悉 GNU 和 UNIX®命令</li> 
          <li>一个正常运行的 Linux 系统，您可以在该系统上练习本教程中介绍的命令</li> 
         </ul>
         <p>本教程以针对考试 101 的主题 103 的教程中介绍的材料为基础。此外，您还需要熟悉 “<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html" rel="nofollow"><em>学习 Linux，101</em>：自定义和使用 shell 环境</a>” 中介绍的材料。</p> 
         <p>有时程序的不同版本会得到不同的输出格式，所以您的结果可能并不总是与这里给出的清单和图完全相同。本教程中的示例大部分都与发行版独立。除非另行说明，本文中的示例使用了 Ubuntu 15.10 和 4.2.0 内核。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>变量赋值和算法</h2> 
         <p>在学习任何编程语言时，都会学习如何将值赋给变量。在本系列前面的教程中，您学习了如何将字符串值赋给变量。Bash 支持使用整数的 shell 算法。您可以将一个表达式计算为算术值，并使用&nbsp;<code>let</code>内建命令将它赋给一个变量。您可以明确将变量声明为整数变量，未来对它的赋值将会计算为整数表达式。 清单 1显示了两种方法的示例和一些细微区别。</p> 
         <h5>清单 1. 变量赋值和算法</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>x=3+4</strong>
 ian@attic-u15:~$ <strong>let y=5*10</strong>
 ian@attic-u15:~$ <strong>declare -i z=5*4/3</strong>
 ian@attic-u15:~$ <strong>echo $x $y $z</strong>
 3+4 50 6 
 ian@attic-u15:~$ <strong># Use declare -p to show more information</strong>
 ian@attic-u15:~$ <strong>declare -p x y z</strong>
 declare -- x="3+4"
 declare -- y="50"
 declare -i z="6"</pre> 
         </div> 
         <p>请注意，只有变量&nbsp;<code>z</code>被声明为整数。</p> 
         <p>您可以在 shell 算法中使用大部分 C 或 C++ 算术运算符，包括逐位和逻辑运算符。您可以使用前和后增量运算符，以及常用的 C 或 C++ 幅值运算符，比如&nbsp;<code>+=</code>、<code>&amp;&amp;=</code>和&nbsp;<code>|=</code>。如果需要将运算分组，可以使用圆括号。如果愿意的话，可以使用&nbsp;<code>let</code>和&nbsp;<code>declare</code>在一行中为多个变量赋值。如果希望在一个算术表达式中使用一个变量值，则不需要在变量名前使用&nbsp;<code>$</code>，但是，如果您愿意的话，也可以这么做。 清单 2给出了 bash 中的更多算法例子。</p> 
         <h5>清单 2. 更多算术赋值例子</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>declare -i p q r</strong>
 ian@attic-u15:~$ <strong>let p=" x + 7 " q=" (y * 2**4) / 100 "</strong>
 ian@attic-u15:~$ <strong>q=" 2**z - (50 /3 ) + 7%4 "</strong>
 ian@attic-u15:~$ <strong>r=4</strong>
 ian@attic-u15:~$ <strong>r+=" q + ( 17 &gt; 4) "</strong>
 ian@attic-u15:~$ <strong>echo $p $q $r</strong>
 14 51 56 
 ian@attic-u15:~$ <strong>declare -p p q r</strong>
 declare -i p="14"
 declare -i q="51"
 declare -i r="56"
 ian@attic-u15:~$ <strong>let t=3 u=p+q</strong>
 ian@attic-u15:~$ <strong>echo $t $u</strong>
 3 65 
 ian@attic-u15:~$ <strong>declare -p t u</strong>
 declare -- t="3"
 declare -- u="65"</pre> 
         </div> 
         <p>请注意，<code>=</code>符号左边不能有空格，而且它的右边任何包含空格的内容都必须放在单引号或双引号中。您可以使用&nbsp;<code>((&nbsp;))</code>结构来进行赋值，从而扩展这些规则。您不需要转义&nbsp;<code>((</code>和&nbsp;<code>))</code>之间的运算符。 清单 3显示了如果在错误的位置拥有空格会发生的情况，以及如何使用&nbsp;<code>((&nbsp;))</code>来缓解该问题。</p> 
         <h5>清单 3. 算法、空格和&nbsp;<code>((&nbsp;))</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>declare -i t</strong>
 ian@attic-u15:~$ <strong>t= 3**3 % 5</strong>
 3**3: command not found 
 ian@attic-u15:~$ <strong>t = 3**3 % 5</strong>
 t: command not found 
 ian@attic-u15:~$ <strong>(( t = 3**3 % 5 ))</strong>
 ian@attic-u15:~$ <strong>echo $t</strong>
 2 
 ian@attic-u15:~$ <strong># Logical expression using unescaped shell meta characters</strong>
 ian@attic-u15:~$ <strong>(( u = ( 3 &gt; 5 ) || ( 4 &lt; 6 ) ))</strong>
 ian@attic-u15:~$ <strong>echo $u</strong>
 1</pre> 
         </div> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>测试</h2> 
         <p>知道如何将值赋给变量和传递参数之后，您还需要知道如何测试这些值和参数。您已经知道&nbsp;<code>$?</code>包含来自一个 shell 命令的返回状态。还可以设置该值，将它用于变量声明和赋值，以及我稍后将展示的测试。<code>test</code>命令是一个内建命令，它执行各种测试，并将返回状态设置为&nbsp;<code>0</code>（成功或 true）或&nbsp;<code>1</code>（失败或 false）。在本教程后面，我将展示如何使用返回状态来制定决策，比如在&nbsp;<code>if-then-else</code>结构中。</p> 
         <h3> <code>test</code>和&nbsp;<code>[</code> </h3> 
         <p>在以前的教程（“<a href="https://www.ibm.com/developerworks/library/l-lpic1-105-1/" rel="nofollow">学习 Linux, 101：自定义和使用 shell 环境</a>” 中的简单&nbsp;<code>add2path</code>函数中，我介绍了&nbsp;<code>test</code>命令，展示了在您的变量&nbsp;<code>PATH</code>变量没有目录时如何添加它。参见 清单 4。</p> 
         <h5>清单 4.&nbsp;<code>add2path</code>函数</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type  add2path</strong>
 add2path is a function 
 add2path () 
 { 
    local augpath augdir; 
    augpath=":$PATH:"; 
    augdir=":$1:"; 
    test "$augpath" = "${augpath/$augdir}" &amp;&amp; PATH="$1:$PATH"
 }</pre> 
         </div> 
         <p>根据表达式&nbsp;<code><em>expr</em></code>的计算结果，<code>test</code>内建命令将会返回&nbsp;<code>0</code>(true) 或&nbsp;<code>1</code>(false)。您还可以使用方括号；<code>test&nbsp;<em>expr</em></code>和&nbsp;<code>[&nbsp;<em>expr</em>&nbsp;]</code>是等效的。您可以显示&nbsp;<code>$?</code>来检查返回值。然后可以像以前使用 &amp;&amp; 和 || 一样使用返回值。或者您可以使用我将在本教程后面介绍的各种条件结构来测试返回值。 清单 5显示了一些简单的测试例子。</p> 
         <h5>清单 5. 一些简单的测试</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>test 3 -gt 4 &amp;&amp; echo true || echo false</strong>
 false 
 ian@attic-u15:~$ <strong>[ "abc" != "def" ];echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[ "abc" = "def" ];echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>test -d "$HOME" ;echo $?</strong>
 0</pre> 
         </div> 
         <p><a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing5" rel="nofollow">清单 5</a>中的第一个示例使用&nbsp;<code>-gt</code>运算符在两个文字值之间执行算术比较。第二和第三个示例使用了替代语法&nbsp;<code>[&nbsp;]</code>来比较两个字符串相等还是不相等，然后在每种情况下回送&nbsp;<code>$?</code>的值。最后一个示例使用&nbsp;<code>-d</code>一元运算符来检查&nbsp;<code>HOME</code>变量是否是一个目录的名称。</p> 
         <p>可以使用&nbsp;<code>-eq</code>（相等）、<code>-ne</code>（不等）、<code>-lt</code>（小于）、<code>-le</code>（小于或等于）、<code>-gt</code>（大于）或&nbsp;<code>-ge</code>（大于或等于）中的一个运算符来比较算术值。</p> 
         <p>可以使用&nbsp;<code>=</code>来比较字符串是否相等，使用&nbsp;<code>!=</code>比较字符串是否不等，并使用&nbsp;<code>&lt;</code>和&nbsp;<code>&gt;</code>确定第一个字符串排在第二个字符串之前还是之后。一元运算符&nbsp;<code>-z</code>将会测试 null 字符串；如果一个字符串不是 null，<code>-n</code>或 no 运算符返回 true (<code>0</code>)。</p> 
         <p><code>&lt;</code>和&nbsp;<code>&gt;</code>运算符也被 shell 用来进行重定向，所以您必须使用&nbsp;<code>\&lt;</code>或&nbsp;<code>\&gt;</code>对它们进行转义。 清单 6显示了字符串测试的更多示例。</p> 
         <h5>清单 6. 更多字符串测试</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>test "abc" = "def" ;echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ "abc" != "def" ];echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[ "abc" \&lt; "def" ];echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[ "abc" \&gt; "def" ];echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ "abc" \&lt; "abc" ];echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ "abc" \&gt; "abc" ];echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ -z "abc" ]; echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ -n "abc" ]; echo $?</strong>
 0</pre> 
         </div> 
         <p>您可以在文件系统对象上使用许多测试。 表 1显示了一些常见的测试。如果测试的对象存在并具有指定的属性，则结果为 true (<code>0</code>)。</p> 
         <h5>表 1. 常见文件测试</h5> 
         <table class="ibm-data-table">
          <thead>
           <tr>
            <th>一元运算符</th> 
            <th>特征</th> 
           </tr>
          </thead>
          <tbody>
           <tr>
            <td><code>-d</code></td> 
            <td>目录</td> 
           </tr>
           <tr>
            <td> <code>-e</code>或&nbsp;<code>-a</code> </td> 
            <td>存在</td> 
           </tr>
           <tr>
            <td><code>-f</code></td> 
            <td>普通文件</td> 
           </tr>
           <tr>
            <td> <code>-h</code>或&nbsp;<code>-L</code> </td> 
            <td>符号链接</td> 
           </tr>
           <tr>
            <td><code>-p</code></td> 
            <td>命名管道</td> 
           </tr>
           <tr>
            <td><code>-r</code></td> 
            <td>可被您读取</td> 
           </tr>
           <tr>
            <td><code>-s</code></td> 
            <td>不是 null</td> 
           </tr>
           <tr>
            <td><code>-S</code></td> 
            <td>套接字</td> 
           </tr>
           <tr>
            <td><code>-w</code></td> 
            <td>可被您写入</td> 
           </tr>
           <tr>
            <td><code>-N</code></td> 
            <td>自上次读取以来已修改</td> 
           </tr>
          </tbody>
         </table>
         <p>您也可使用 表 2中所示的二元运算符来比较两个文件。</p> 
         <h5>表 2. 文件比较测试</h5> 
         <table class="ibm-data-table">
          <thead>
           <tr>
            <th>二元运算符</th> 
            <th>特征</th> 
           </tr>
          </thead>
          <tbody>
           <tr>
            <td><code>-nt</code></td> 
            <td>测试文件 1 是否比文件 2 更新。此比较会使用修改时间戳。</td> 
           </tr>
           <tr>
            <td><code>-ot</code></td> 
            <td>测试文件 1 是否比文件 2 更旧。此比较会使用修改时间戳。</td> 
           </tr>
           <tr>
            <td><code>-ef</code></td> 
            <td>测试文件 1 是否是文件 2 的硬链接。</td> 
           </tr>
          </tbody>
         </table>
         <p>可以使用其他测试来检查文件的权限设置等方面。请参阅 bash 手册页了解更多的细节，或者使用&nbsp;<code>help&nbsp;test</code>来查看&nbsp;<code>test</code>内建命令的简略信息。您可以将&nbsp;<code>help</code>命令用于其他内建命令。</p> 
         <p>您可以使用一元&nbsp;<code>-o</code>运算符来测试各种 shell 选项是否已设置。如 清单 7所示，如果 -o 选项已设置，<code>test&nbsp;-o&nbsp;<em>option</em></code>返回 true (<code>0</code>)；否则它返回 false (<code>1</code>)。</p> 
         <h5>清单 7. 测试 shell 选项</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong># Setting and testing the unset option</strong>
 ian@attic-u15:~$ <strong>set +o nounset</strong>
 ian@attic-u15:~$ <strong>echo $MYTESTVAR</strong>

 ian@attic-u15:~$ <strong>[ -o nounset ];echo $?</strong>
 1 
 ian@attic-u15:~$ <strong># You can also set/unset nounset using set -u or set +u</strong>
 ian@attic-u15:~$ <strong>set -u</strong>
 ian@attic-u15:~$ <strong>echo $MYTESTVAR</strong>
 bash: MYTESTVAR: unbound variable 
 ian@attic-u15:~$ <strong>test -o nounset; echo $?</strong>
 0</pre> 
         </div> 
         <p>可以使用&nbsp;<code>-a</code>二元选项来将表达式与逻辑与 (logical AND) 相组合，使用&nbsp;<code>-o</code>二元选项来将表达式与逻辑或 (logical OR) 相组合。一元&nbsp;<code>!</code>运算符对测试的含义求反。可使用圆括号来将表达式分组或覆盖默认优先级。请记住，shell 通常在一个子 shell 内运行括号之间的表达式，所以您必须使用&nbsp;<code>\(</code>和&nbsp;<code>\)</code>对圆括号进行转义，或者当您不想一个表达式在子 shell 内运行时，可以将这些运算符放在单引号或双引号中。 清单 8演示了&nbsp;<a href="http://mathworld.wolfram.com/deMorgansLaws.html" rel="nofollow">德·摩根定律</a>在表达式上的应用。</p> 
         <h5>清单 8. 组合和分组测试</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>test "a" != "$HOME" -a 3 -ge 4 ; echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ ! \( "a" = "$HOME" -o 3 -lt 4 \) ]; echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[ ! \( "a" = "$HOME" -o '(' 3 -lt 4 ')' ")" ]; echo $? 
 1</strong>
 ian@attic-u15:~$ <strong># Be careful. ! has higher priority that -a or -o</strong>
 ian@attic-u15:~$ <strong>[ ! \( "a" = "$HOME" \) -o '(' 3 -lt 4 ')'  ]; echo $?</strong>
 0</pre> 
         </div> 
         <p><code>test</code>命令很强大，但转义的需求和字符串与算术比较之间的区别可能让它变得不实用。幸运的是，bash 有其他两种方式来设置算术和逻辑表达式的返回代码，如果您熟悉 C、C++ 或 Java 语法，那么它们看起来应该更自然一些。</p> 
         <h3>来自&nbsp;<code>((&nbsp;))</code>和&nbsp;<code>[[&nbsp;]] 的返回状态</code> </h3> 
         <p>您在本教程开头看到的&nbsp;<code>((&nbsp;))</code>复合命令计算一个算术表达式，如果表达式计算为 0，则将退出状态设置为&nbsp;<code>1</code>，或者如果表达式计算为非 0 值，则设置为&nbsp;<code>0</code>。请注意，<code>let</code>命令基于最后一个参数计算为 0 还是非 0 值来设置返回状态。 清单 9显示了一些示例。</p> 
         <h5>清单 9. 来自&nbsp;<code>((&nbsp;)) 的返回状态</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>let x=2 y=2**3 z=y*3;echo $? $x $y $z</strong>
 0 2 8 24 
 ian@attic-u15:~$ <strong>(( w=(y/x) + ( (~ ++x) &amp; 0x0f ) )); echo $? $x $y $w</strong>
 0 3 8 16 
 ian@attic-u15:~$ <strong>(( w=(y/x) + ( (~ ++x) &amp; 0x0f ) )); echo $? $x $y $w</strong>
 0 4 8 13 
 ian@attic-u15:~$ <strong>(( w - w )) ;echo $?</strong>
 1</pre> 
         </div> 
         <p><code>[[&nbsp;]]</code>复合命令执行一个条件表达式，并将返回状态设置为&nbsp;<code>0</code>(true) 或&nbsp;<code>1</code>(false)。与&nbsp;<code>((&nbsp;))</code>一样，您可以为&nbsp;<code>[[&nbsp;]]</code>复合命令使用更自然的语法来执行文件名和字符串测试。通过使用圆括号和逻辑运算符，您可以将&nbsp;<code>test</code>命令可运行的测试组合在一起。参见 清单 10。</p> 
         <h5>清单 10. 来自&nbsp;<code>[[&nbsp;]] 的返回状态</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ [<strong>[ ( -d "$HOME" ) &amp;&amp; ( -w "$HOME" ) ]]; echo $?</strong>
 0 
 ian@attic-u15:~$ [[ ( -d "$HOME" ) &amp;&amp; ( -w "$HOME" ) ]] &amp;&amp; 
 &gt; <strong>echo "home is a writable directory"</strong>
 home is a writable directory</pre> 
         </div> 
         <p>当使用&nbsp;<code>==</code>或&nbsp;<code>!=</code>运算符时，您可以使用&nbsp;<code>[[&nbsp;]]</code>复合命令在字符串上执行模式匹配。该匹配行为与 shell 通配符语法相同，如 清单 11中所示。</p> 
         <h5>清单 11. 使用&nbsp;<code>[[&nbsp;]] 的通配符测试</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>[[ "abc def .d,x--" == a[abc]*\ ?d* ]]; echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[[ "abc def c" == a[abc]*\ ?d* ]]; echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* ]]; echo $?</strong>
 1</pre> 
         </div> 
         <p>在&nbsp;<code>[[&nbsp;]]</code>中，<code>==</code>和&nbsp;<code>=</code>拥有相同的含义，所以您可以使用任意一个。如果您希望模式是正则表达式而不是 shell 通配符语法，那么可以使用&nbsp;<code>=~</code>。参见 清单 12。</p> 
         <h5>清单 12. 使用&nbsp;<code>[[&nbsp;]] 的正则表达式模式匹配</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong># Wildcard globbing does not match this pattern</strong>
 ian@attic-u15:~$ <strong>[[ "abc def c" == a[abc]*\ ?d* ]]; echo $? 
 1</strong>
 ian@attic-u15:~$ <strong># But regular expression matching does</strong>
 ian@attic-u15:~$ <strong>[[ "abc def c" =~ a[abc]*\ ?d* ]]; echo $?</strong>
 0</pre> 
         </div> 
         <p>您甚至可以在&nbsp;<code>[[&nbsp;]]</code>复合命令内执行算术测试，但要小心。除非它们在一个嵌套的&nbsp;<code>((&nbsp;))</code>复合命令内，否则&nbsp;<code>&lt;</code>和&nbsp;<code>&gt;</code>运算符会将操作数当作字符串来比较，并测试它们在当前核对序列中的顺序。 清单 13通过一些示例演示了这种行为。</p> 
         <h5>清单 13.&nbsp;<code>[[&nbsp;]] 中的算法测试</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong># Set warning in case we use an unbound variable</strong>
 ian@attic-u15:~$ <strong># Otherwise names are interpreted as strings</strong>
 ian@attic-u15:~$ <strong>set -u</strong>
 ian@attic-u15:~$ <strong># First expression is false</strong>
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* ]]; echo $?</strong>
 1 
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* || (( 3 &gt; 2 )) ]]; echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* || 3 -gt 2 ]]; echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* || 3 &gt; 2 ]]; echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* || a &gt; 2 ]]; echo $?</strong>
 0 
 ian@attic-u15:~$ <strong>[[ "abc def d,x" == a[abc]*\ ?d* || a -gt 2 ]]; echo $?</strong>
 bash: a: unbound variable 
 ian@attic-u15:~$ <strong># Restore default</strong>
 ian@attic-u15:~$ <strong>set +u</strong></pre> 
         </div> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>条件</h2> 
         <p>您可以使用我目前展示的测试及&nbsp;<code>&amp;&amp;</code>和&nbsp;<code>||</code>控制运算符来完成大量编程。此外，bash 还包含更熟悉的&nbsp;<code>if</code>-<code>then</code>-<code>else</code>和&nbsp;<code>case</code>结构。在我展示这些结构和循环结构后，您的工具箱会变得充实得多。</p> 
         <h3>使用&nbsp;<code>if</code>-<code>then</code>-<code>else</code>语句</h3> 
         <div class="dw-sidebar ibm-inset"> 
          <p>尽管您目前看到的测试仅返回&nbsp;<code>0</code>或&nbsp;<code>1</code>值，但该命令可以返回其他值。本教程后面会介绍更多测试这些值的知识。</p> 
         </div> 
         <p>bash&nbsp;<code>if</code>命令是一个复合命令，它测试一次测试或命令的返回状态 (<code>$?</code>)，并基于返回状态为 true (<code>0</code>) 还是 false（非&nbsp;<code>0</code>）而进行分支。bash 中的&nbsp;<code>if</code>命令有一个&nbsp;<code>then</code>子句，其中包含在测试或命令返回&nbsp;<code>0</code>时要执行的命令列表。该命令还有一个或多个可选的&nbsp;<code>elif</code>子句。每个可选的<code>elif</code>子句都有一项额外的测试和一个拥有关联的命令列表的&nbsp;<code>then</code>子句。最后的一个&nbsp;<code>else</code>子句和关联的命令列表是可选的。如果最初的测试和&nbsp;<code>elif</code>子句中使用的任何测试的结果都不是 true，则运行最后的&nbsp;<code>else</code>子句。需要一个终止&nbsp;<code>fi</code>来标记结构的末尾处。</p> 
         <p>利用您目前在这些教程中学到的知识，现在可以构建一个简单的计算器来计算算术表达式，如 清单 14中所示。</p> 
         <h5>清单 14. 使用&nbsp;<code>if</code>-<code>then</code>-<code>else</code>计算表达式</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>function mycalc ()</strong>
 &gt; <strong>{</strong>
 &gt;   <strong>local x</strong>
 &gt;   <strong>if [ $# -lt 1 ]; then</strong>
 &gt;     <strong>echo "This function evaluates arithmetic for you if you give it some"</strong>
 &gt;   <strong>elif (( $* )); then</strong>
 &gt;   <strong>let x="$*"</strong>
 &gt;     <strong>echo "$* = $x"</strong>
 &gt;   <strong>else</strong>
 &gt;     <strong>echo "$* = 0 or is not an arithmetic expression"</strong>
 &gt;   <strong>fi</strong>
 &gt; } 
 ian@attic-u15:~$ <strong>mycalc 3 + 4</strong>
 3 + 4 = 7 
 ian@attic-u15:~$ <strong>mycalc 3 + 4**3</strong>
 3 + 4**3 = 67 
 ian@attic-u15:~$ <strong>mycalc 3 + (4**3 /2)</strong>
 bash: syntax error near unexpected token `('
 ian@attic-u15:~$ <strong>mycalc 3 + "(4**3 /2)"</strong>
 3 + (4**3 /2) = 35 
 ian@attic-u15:~$ <strong>mycalc xyz</strong>
 xyz = 0 or is not an arithmetic expression 
 ian@attic-u15:~$ <strong>mycalc xyz + 3 + "(4**3 /2)" + abc</strong>
 xyz + 3 + (4**3 /2) + abc = 35</pre> 
         </div> 
         <p>计算器使用&nbsp;<code>local</code>语句将&nbsp;<code>x</code>声明为只能在&nbsp;<code>mycalc</code>函数的范围内使用的局部变量。<code>let</code>内建命令有多个可能的选项，与和它密切相关的&nbsp;<code>declare</code>命令一样。请查阅 bash 的手册页或使用&nbsp;<code>help&nbsp;let</code>来了解更多的信息。</p> 
         <p>您已在&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing14" rel="nofollow">清单 14</a>中看到，如果您的表达式使用了 shell 元字符，比如&nbsp;<code>(</code>、<code>)</code>、<code>*</code>、<code>&gt;</code>和&nbsp;<code>&lt;</code>，那么这些表达式必须正确转义。但是，您现在有一个方便的小计算器来计算算术表达式，就像 shell 一样。</p> 
         <p>请注意 清单 14中的最后两个示例。将&nbsp;<code>xyz</code>传递给&nbsp;<code>mycalc</code>并没有错，但除非您之前已将一个值赋给变量&nbsp;<code>xyz</code>，否则它将计算为&nbsp;<code>0</code>。在最后的例子中，该函数不够聪明，无法识别字符值来提醒您，<code>xyz</code>和&nbsp;<code>abc</code>被静默地当作具有值&nbsp;<code>0</code>的变量来处理。您可以使用一种字符串模式匹配测试，比如<code>[[&nbsp;!&nbsp;("$*"&nbsp;==&nbsp;*[a-zA-Z]*&nbsp;]]</code>（或针对您的语言环境的合适形式），以消除任何包含字母字符的表达式，但这会阻止您将 shell 变量用作输入。它还会阻止您在输入中使用十六进制表示法，因为十六进制表示法（比如&nbsp;<code>0x0f</code>表示十进制树 15）可能包含字母。事实上，您可以在 shell 中（通过&nbsp;<code><em>base</em>#<em>值</em></code>表示法）使用最多 64 个 base 字符，所以您的输入可以合法地包含任何字母字符，以及&nbsp;<code>_</code>和&nbsp;<code>@</code>。对于八进制和十六进制的特殊情况，可以使用更常见的表示法，也就是说，在八进制数前面添加 0，在十六进制数前面添加 0x 或 0X。清单 15显示了一些示例。</p> 
         <h5>清单 15. 使用不同的 base 字符来计算</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>mycalc 015</strong>
 015 = 13 
 ian@attic-u15:~$ <strong>mycalc 0xff</strong>
 0xff = 255 
 ian@attic-u15:~$ <strong>mycalc 29#37</strong>
 29#37 = 94 
 ian@attic-u15:~$ <strong>mycalc 64#1az</strong>
 64#1az = 4771 
 ian@attic-u15:~$ <strong>mycalc 64#1azA</strong>
 64#1azA = 305380 
 ian@attic-u15:~$ <strong>mycalc 64#1azA_@</strong>
 64#1azA_@ = 1250840574 
 ian@attic-u15:~$ <strong>mycalc 64#1az*64**3 + 64#A_@</strong>
 64#1az*64**3 + 64#A_@ = 1250840574</pre> 
         </div> 
         <p>对输入的其他处理不属于本教程的讨论范围，所以请审慎地使用您计算器。</p> 
         <p><code>elif</code>语句很方便，可以帮助您简化脚本中的缩进。 清单 16展示了如何对&nbsp;<code>mycalc</code>函数使用&nbsp;<code>type</code>命令来显示&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing14" rel="nofollow">清单 14</a>的&nbsp;<code>elif</code>语句的等效形式。</p> 
         <h5>清单 16. 类型 mycalc</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type mycalc</strong>
 mycalc is a function 
 mycalc () 
 { 
    local x; 
    if [ $# -lt 1 ]; then 
        echo "This function evaluates arithmetic for you if you give it some"; 
    else 
        if (( $* )); then 
            let x="$*"; 
            echo "$* = $x"; 
        else 
            echo "$* = 0 or is not an arithmetic expression"; 
        fi; 
    fi 
 }</pre> 
         </div> 
         <h3>Case 语句</h3> 
         <p>在有多种可能性且希望基于某个值是否与某种特定可能性匹配来执行操作时，可以使用&nbsp;<code>case</code>复合命令来简化测试。<code>case</code>复合命令以<code>case&nbsp;<em>WORD</em>&nbsp;in</code>开始，以&nbsp;<code>esac</code>（的反向拼写）结尾。每个&nbsp;<code>case</code>包含一种模式或多个以&nbsp;<code>|</code>分隔的模式，后跟&nbsp;<code>)</code>、一个语句列表，最后是一对分号 (<code>;;</code>)。</p> 
         <p>例如，想象一个出售咖啡、无咖啡因咖啡 (decaf)、茶叶或苏打水的商店。 清单 17中的函数可用于确定对一个订单的响应。</p> 
         <h5>清单 17. 使用&nbsp;<code>case</code>命令</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type myorder</strong>
 myorder is a function 
 myorder () 
 { 
    case "$*" in 
        "coffee" | "decaf") 
            echo "Hot coffee coming right up"
        ;; 
        "tea") 
            echo "Hot tea on its way"
        ;; 
        "soda") 
            echo "Your ice-cold soda will be ready in a moment"
        ;; 
        *) 
            echo "Sorry, we don't serve that here"
        ;; 
    esac 
 } 
 ian@attic-u15:~$ <strong>myorder decaf</strong>
 Hot coffee coming right up 
 ian@attic-u15:~$ <strong>myorder tea</strong>
 Hot tea on its way 
 ian@attic-u15:~$ <strong>myorder milk</strong>
 Sorry, we don't serve that here</pre> 
         </div> 
         <p>请注意，我们使用了&nbsp;<code>*</code>来匹配任何还未被匹配的内容。</p> 
         <p>另一个与&nbsp;<code>case</code>类似的 bash 结构是&nbsp;<code>select</code>语句，这里没有介绍它。可以使用它将一个商品输出列表打印到终端，您的用户可以从该列表中进行选择。请参阅 bash 手册页或键入&nbsp;<code>help&nbsp;select</code>来了解&nbsp;<code>select</code>的更多信息。</p> 
         <p>当然，这样一个简单的饮品订购系统有许多问题；您不能一次订购两种饮品，而且该函数只能处理小写输入。您能否执行不区分大小写的匹配？答案是能，我将展示如何做。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>返回值</h2> 
         <p>Bash 有一个&nbsp;<code>shopt</code>内建命令可用来设置或取消设置许多 shell 选项。其中一个选项是&nbsp;<code>nocasematch</code>，如果设置了该选项，它会告诉 shell 在字符串匹配中忽略大小写。您的第一个想法可能是使用您在&nbsp;<code>test</code>命令中学到的&nbsp;<code>-o</code>操作数。不幸的是，<code>nocasematch</code>不是可以使用&nbsp;<code>-o</code>测试的选项，所以您必须采用不同的方法。</p> 
         <p>您之前学到的测试不是能返回值的唯一测试。举例而言，<code>if</code>语句可测试基础&nbsp;<code>test</code>命令的返回值是 true (<code>0</code>) 还是 false（非&nbsp;<code>0</code>）。即使您使用了 test 以外的命令，成功和失败也分别由返回值&nbsp;<code>0</code>和非零返回值表示。像大部分 UNIX 和 LInux 命令一样，<code>shopt</code>命令将会设置一个可以使用&nbsp;<code>$?</code>检查的返回值。</p> 
         <p>掌握这项知识后，您现在可以测试&nbsp;<code>nocasematch</code>选项，如果尚未设置它，请设置它，然后在您的函数终止时将该设置恢复为用户的首选项。<code>shopt</code>命令有 4 个方便的选项：<code>-pqsu</code>：打印当前值，不打印任何内容，设置该选项或取消设置该选项。<code>-p</code>和&nbsp;<code>-q</code>选项设置一个返回值&nbsp;<code>0</code>，用该值表示 shell 选项已设置，设置&nbsp;<code>1</code>来表示它未设置。<code>-p</code>选项打印出了将该选项设置为当前值需要使用的命令，而&nbsp;<code>-q</code>选项简单地将返回值设置为&nbsp;<code>0</code>或&nbsp;<code>1</code>。 清单 18显示了您修改&nbsp;<code>myorder</code>函数所需的基本用法示例，其中使用了您之前在&nbsp;<code>[[&nbsp;]]</code>中看到的模式匹配。</p> 
         <h5>清单 18. 使用&nbsp;<code>shopt</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong># nocasematch starts out unset</strong>
 ian@attic-u15:~$ <strong>shopt -p nocasematch ; echo $?</strong>
 shopt -u nocasematch 
 1 
 ian@attic-u15:~$ <strong># test it</strong>
 ian@attic-u15:~$ <strong>[[ "abc" = "ABC" ]] ;echo $?</strong>
 1 
 ian@attic-u15:~$ <strong># set nocasematch</strong>
 ian@attic-u15:~$ <strong>shopt -s nocasematch ; echo $?</strong>
 0 
 ian@attic-u15:~$ <strong># test the pattern again</strong>
 ian@attic-u15:~$ <strong>[[ "abc" = "ABC" ]] ;echo $?</strong>
 0 
 ian@attic-u15:~$ <strong># restore nocasematch</strong>
 ian@attic-u15:~$ <strong>shopt -u nocasematch ; echo $?</strong>
 0</pre> 
         </div> 
         <p>如 清单 19所示，修改后的&nbsp;<code>myorder</code>函数现在可以使用来自&nbsp;<code>shopt</code>的返回值来：</p> 
         <ol>
          <li>设置一个表示&nbsp;<code>nocasematch</code>选项的当前状态的局部变量。</li> 
          <li>设置该选项。</li> 
          <li>返回&nbsp;<code>case</code>命令。</li> 
          <li>将&nbsp;<code>nocasematch</code>选项重设为它的原始值。</li> 
         </ol>
         <h5>清单 19. 测试来自&nbsp;<code>shopt</code>命令的返回值</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type myorder</strong>
 myorder is a function 
 myorder () 
 { 
    local restorecase; 
    if shopt -q nocasematch; then 
        restorecase="-s"; 
    else 
        restorecase="-u"; 
        shopt -s nocasematch; 
    fi; 
    case "$*" in 
        "coffee" | "decaf") 
            echo "Hot coffee coming right up"
        ;; 
        "tea") 
            echo "Hot tea on its way"
        ;; 
        "soda") 
            echo "Your ice-cold soda will be ready in a moment"
        ;; 
        *) 
            echo "Sorry, we don't serve that here"
        ;; 
    esac; 
    shopt $restorecase nocasematch 
 } 
 ian@attic-u15:~$ <strong>shopt -p nocasematch</strong>
 shopt -u nocasematch 
 ian@attic-u15:~$ <strong># nocasematch is currently unset</strong>
 ian@attic-u15:~$ <strong>myorder DECAF</strong>
 Hot coffee coming right up 
 ian@attic-u15:~$ <strong>myorder Soda</strong>
 Your ice-cold soda will be ready in a moment 
 ian@attic-u15:~$ <strong>shopt -p nocasematch</strong>
 shopt -u nocasematch 
 ian@attic-u15:~$ <strong># nocasematch is unset again after running the myorder function</strong></pre> 
         </div> 
         <p>如果您想您的函数（脚本）返回其他函数或命令可以测试的值，那么可以在您的函数中使用 return 语句。 清单 20展示了如何为一种您可以销售的饮品返回&nbsp;<code>0</code>，如果客户请求其他商品，则返回&nbsp;<code>1</code>。</p> 
         <h5>清单 20. 设置您自己的函数返回值</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type myorder</strong>
 myorder is a function 
 myorder () 
 { 
    local restorecase; 
    rc=0; 
    if shopt -q nocasematch; then 
        restorecase="-s"; 
    else 
        restorecase="-u"; 
        shopt -s nocasematch; 
    fi; 
    case "$*" in 
        "coffee" | "decaf") 
            echo "Hot coffee coming right up"
        ;; 
        "tea") 
            echo "Hot tea on its way"
        ;; 
        "soda") 
            echo "Your ice-cold soda will be ready in a moment"
        ;; 
        *) 
            echo "Sorry, we don't serve that here"; 
            rc=1 
        ;; 
    esac; 
    shopt $restorecase nocasematch; 
    return $rc 
 } 
 ian@attic-u15:~$ <strong>myorder coffee;echo $?</strong>
 Hot coffee coming right up 
 0 
 ian@attic-u15:~$ <strong>myorder milk;echo $?</strong>
 Sorry, we don't serve that here 
 1</pre> 
         </div> 
         <p>如果没有指定您自己的返回值，返回值将是执行的上一个命令的返回值。函数和脚本有一种在您从未考虑到的情况下被重用的倾向，所以一种好的做法是设置您自己的值。</p> 
         <p>命令可以返回&nbsp;<code>0</code>和&nbsp;<code>1</code>以外的值，而且有时您需要额外的信息。例如，如果模式匹配，<code>grep</code>命令将会返回&nbsp;<code>0</code>；如果不匹配，则会返回&nbsp;<code>1</code>；但是，如果模式无效或文件规范与任何文件都不匹配，则会返回&nbsp;<code>2</code>。如果需要区分成功 (<code>0</code>) 或失败（非 0）以外的返回值，可以使用&nbsp;<code>case</code>命令或一个包含多个&nbsp;<code>elif</code>部分的&nbsp;<code>if</code>命令。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>命令替换</h2> 
         <p>如果将一个命令放在&nbsp;<code>$(</code>和&nbsp;<code>)</code>之间或一对重音符&nbsp;<code>`</code>之间，您可以将该命令的输出替换为另一个命令的输入。这种技术称为&nbsp;<em>命令替换</em>。在需要嵌套命令替换时，可以采用&nbsp;<code>$()</code>的形式。这种形式也使确定发生的情况变得更容易，因为圆括号有左右之分，但两个重音符是相同的。选择权在您手上，而且重音符仍然很常见。</p> 
         <p>我们常常将命令替换与循环结合使用（将在后面的 “<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#loops" rel="nofollow">循环</a>” 中介绍）。但是，您还可以使用它来稍微简化&nbsp;<code>myorder</code>函数。因为&nbsp;<code>shopt&nbsp;-p&nbsp;nocasematch</code>打印您需要将&nbsp;<code>nocasematch</code>选项设置为其当前值的命令，所以您只需保存该输出，然后在&nbsp;<code>case</code>语句的末尾执行它。通过这么做，您会恢复&nbsp;<code>nocasematch</code>选项，无论您是否更改了它。修改后的函数现在可能类似于 清单 21。请自行尝试它。</p> 
         <h5>清单 21. 使用命令替换而不是返回值测试</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type myorder</strong>
 myorder is a function 
 myorder () 
 { 
    local restorecase=$(shopt -p nocasematch) rc=0; 
    shopt -s nocasematch; 
    case "$*" in 
        "coffee" | "decaf") 
            echo "Hot coffee coming right up"
        ;; 
        "tea") 
            echo "Hot tea on its way"
        ;; 
        "soda") 
            echo "Your ice-cold soda will be ready in a moment"
        ;; 
        *) 
            echo "Sorry, we don't serve that here"; 
            rc=1 
        ;; 
    esac; 
    $restorecase; 
    return $rc 
 } 
 ian@attic-u15:~$ <strong>shopt -p nocasematch</strong>
 shopt -u nocasematch 
 ian@attic-u15:~$ <strong>myorder DECAF</strong>
 Hot coffee coming right up 
 ian@attic-u15:~$ <strong>myorder TeA</strong>
 Hot tea on its way 
 ian@attic-u15:~$ <strong>shopt -p nocasematch</strong>
 shopt -u nocasematch</pre> 
         </div> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>调试</h2> 
         <p>如果您输入了函数定义且出现了输入错误，您想知道哪里出错了，您可能还想知道如何调试函数。幸运的是，您可以设置&nbsp;<code>-x</code>选项在 shell 执行命令时跟踪它们和它们的参数。 清单 22展示了如何对来自&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing21" rel="nofollow">清单 21</a>的&nbsp;<code>myorder</code>函数使用此选项。</p> 
         <h5>清单 22. 跟踪执行</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>set -x</strong>
 ian@attic-u15:~$ <strong>myorder tea</strong>
 + myorder tea 
 ++ shopt -p nocasematch 
 + local 'restorecase=shopt -u nocasematch' rc=0 
 + shopt -s nocasematch 
 + case "$*" in 
 + echo 'Hot tea on its way'
 Hot tea on its way 
 + shopt -u nocasematch 
 + return 0 
 ian@attic-u15:~$ <strong>set +x</strong>
 + set +x</pre> 
         </div> 
         <p>您可以对您的别名、函数或脚本使用此技术。如果需要更多的信息，可以添加&nbsp;<code>-v</code>选项来获得详细的输出。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>循环</h2> 
         <p>Bash 和其他 shell 语言有 3 种循环结构与 C 语言中的循环结构比较相似。每种循环执行一个命令列表 0 次或更多次。命令列表放在单词&nbsp;<code>do</code>和<code>done</code>之间，每个命令前都有一个分号。</p> 
         <dl>
          <dt>
           <strong><code>for</code></strong>
          </dt> 
          <dd> 
           <code>for</code>循环有两种形式。shell 脚本中的最常用的形式是迭代一组值，对每个值执行命令列表一次。这组值可能是空的，在这种情况下，不会执行命令列表。另一种形式更加类似于传统的 C&nbsp;
           <code>for</code>循环，它使用 3 个算术表达式来控制开始条件、步进函数和结束条件。
          </dd> 
          <dt>
           <strong><code>while</code></strong>
          </dt> 
          <dd> 
           <code>while</code>循环该循环每次开始时计算一个条件，如果条件为 true，则执行命令列表。如果该条件最初不为 true，则从不执行这些命令。
          </dd> 
          <dt>
           <strong><code>until</code></strong>
          </dt> 
          <dd> 
           <code>until</code>循环执行命令列表并在每次循环结束时计算一个条件。如果条件为 true，则再执行该循环一次。即使条件最初不为 true，这些命令也会至少执行一次。
          </dd> 
         </dl>
         <p>测试的条件可以是一个命令列表。在这种情况下，将使用执行的&nbsp;<em>最后一个</em>命令的返回值。清单 23演示了这些循环命令。</p> 
         <h5>清单 23. 简单的&nbsp;<code>for</code>、<code>while</code>和&nbsp;<code>until</code>循环</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ for x in abd 2 "my stuff"; do echo $x; done 
 abd 
 2 
 my stuff 
 ian@attic-u15:~$ for (( x=2; x&lt;5; x++ )); do echo $x; done 
 2 
 3 
 4 
 ian@attic-u15:~$ let x=3; while [ $x -ge 0 ] ; do echo $x ;let x--;done 
 3 
 2 
 1 
 0 
 ian@attic-u15:~$ let x=3; until echo -e "x=\c"; (( x-- == 0 )) ; do echo $x ; done 
 x=2 
 x=1 
 x=0</pre> 
         </div> 
         <p>这些示例虽然不太自然，但它们演示了这些概念。您通常希望迭代一个函数或 shell 脚本的参数，或者命令替换所创建的一个列表。</p> 
         <p>在 “<a href="https://www.ibm.com/developerworks/library/l-lpic1-105-1/" rel="nofollow"><em>学习 Linux，101</em>：自定义和使用 shell 环境</a>” 中，您已经了解到 shell 可以&nbsp;<code>$*</code>或&nbsp;<code>$@</code>形式引用传递的参数列表，而且您是否引用这些表达式会影响对它们的解释方式。 表 3回顾了这些区别。</p> 
         <h5>表 3. Shell 函数参数</h5> 
         <table class="ibm-data-table">
          <thead>
           <tr>
            <th>参数</th> 
            <th>用途</th> 
           </tr>
          </thead>
          <tbody>
           <tr>
            <td><code>*</code></td> 
            <td>从参数 1 开始的位置参数。如果在双引号内进行扩展，那么扩展结果将是一个单词，使用字段间分隔符 (IFS) 特殊变量的第一个字符来分离参数，如果 IFS 是 null，则没有中间空格。默认的 IFS 值是一个空白、制表符和换行符。如果 IFS 未设置，则使用的分隔符为空白，与默认 IFS 一样。</td> 
           </tr>
           <tr>
            <td><code>@</code></td> 
            <td>从参数 1 开始的位置参数。如果在双引号内进行扩展，则每个参数变成一个单词，以便&nbsp;<code>"$@"</code>等于&nbsp;<code>"$1"</code>、<code>"$2"</code>……如果您的参数可能包含嵌入的空白，则使用此形式。</td> 
           </tr>
          </tbody>
         </table>
         <p>清单 24显示了一个函数，它打印出参数数量，然后依据 4 种替代选择来打印参数。</p> 
         <h5>清单 24. 一个打印参数信息的函数</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ type testfunc 
 testfunc is a function 
 testfunc () 
 { 
    echo "$# parameters"; 
    echo Using '$*'; 
    for p in $*; 
    do 
        echo "[$p]"; 
    done; 
    echo Using '"$*"'; 
    for p in "$*"; 
    do 
        echo "[$p]"; 
    done; 
    echo Using '$@'; 
    for p in $@; 
    do 
        echo "[$p]"; 
    done; 
    echo Using '"$@"'; 
    for p in "$@"; 
    do 
        echo "[$p]"; 
    done 
 }</pre> 
         </div> 
         <p>清单 25展示了该函数的实际应用，在&nbsp;<code>IFS</code>变量前面添加了一个额外的字符来方便函数执行。</p> 
         <h5>清单 25. 使用&nbsp;<code>testfunc</code>打印参数信息</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>IFS="|${IFS}" testfunc abc "a bc" "1 2</strong>
 &gt; <strong>3"</strong>
 3 parameters 
 Using $* 
 [abc] 
 [a] 
 [bc] 
 [1] 
 [2] 
 [3] 
 Using "$*"
 [abc|a bc|1 2 
 3] 
 Using $@ 
 [abc] 
 [a] 
 [bc] 
 [1] 
 [2] 
 [3] 
 Using "$@"
 [abc] 
 [a bc] 
 [1 2 
 3]</pre> 
         </div> 
         <p>请仔细分析区别，特别是引用形式和包含空格的参数，比如空白或换行字符。</p> 
         <h3> <code>break</code>和&nbsp;<code>continue</code>命令</h3> 
         <p>可以使用&nbsp;<code>break</code>命令立即退出循环。如果您拥有嵌套循环，可以指定要分成的级别数。例如，如果您在一个&nbsp;<code>for</code>内的另一个&nbsp;<code>for</code>循环内有一个<code>until</code>循环，而它们都在一个&nbsp;<code>while</code>循环内，则&nbsp;<code>break&nbsp;3</code>会立即终止&nbsp;<code>until</code>循环和两个&nbsp;<code>for</code>循环，并将控制权返回给&nbsp;<code>while</code>循环中的下一个指令。</p> 
         <p>可以使用&nbsp;<code>continue</code>语句绕过命令列表中的剩余语句，直接转到循环的下一次迭代。 清单 26演示了&nbsp;<code>break</code>和&nbsp;<code>continue</code>的使用。</p> 
         <h5>清单 26. 使用&nbsp;<code>break</code>和&nbsp;<code>continue</code> </h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>for word in red blue green yellow violet; do</strong>
 &gt; <strong>if [ "$word" = blue ]; then continue; fi</strong>
 &gt; <strong>if [ "$word" = yellow ]; then break; fi</strong>
 &gt; <strong>echo "$word"</strong>
 &gt; <strong>done</strong>
 red 
 green</pre> 
         </div> 
         <h3>再看一下&nbsp;<code>ldirs</code> </h3> 
         <p>是否还记得在 “<a href="https://www.ibm.com/developerworks/library/l-lpic1-105-1/" rel="nofollow"><em>学习 Linux，101</em>：自定义和使用 shell 环境</a>” 中，您是如何让&nbsp;<code>ldirs</code>函数从一个长列表中提取文件名并确定它是否是一个目录？您开发的最后一个函数不是太糟，但前提是您拥有现在拥有的所有信息。您是否创建了同一个函数？或许没有。您知道如何使用&nbsp;<code>[ -d $name ]</code>测试一个名称是否是一个目录，而且您知道&nbsp;<code>for</code>复合命令。 清单 27给出了您可以编写&nbsp;<code>ldirs</code>函数的另一种方法。</p> 
         <h5>清单 27. 编写&nbsp;<code>ldirs</code>的另一种方法</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type ldirs</strong>
 ldirs is a function 
 ldirs () 
 { 
    if [ $# -gt 0 ]; then 
        for file in "$@"; 
        do 
            [ -d "$file" ] &amp;&amp; echo "$file"; 
        done; 
    else 
        for file in *; 
        do 
            [ -d "$file" ] &amp;&amp; echo "$file"; 
        done; 
    fi; 
    return 0 
 } 
 ian@attic-u15:~$ <strong>cd developerworks/</strong>
 ian@attic-u15:~/developerworks$ <strong>ldirs</strong>
 my first article 
 readme 
 schema 
 templates 
 tools 
 web 
 xsl 
 ian@attic-u15:~/developerworks$ <strong>ldirs *s* tools/*</strong>
 my first article 
 schema 
 templates 
 tools 
 xsl 
 tools/java 
 ian@attic-u15:~/developerworks$ <strong>ldirs *www*</strong></pre> 
         </div> 
         <p>如果没有目录与您的条件匹配，新&nbsp;<code>ldirs</code>函数会静默地返回。这不一定是您想要的。至少您的工具箱中现在有了另一个工具。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>创建脚本</h2> 
         <p>回想一下，<code>myorder</code>函数一次只能处理一种饮品。您现在可以将这个单一饮品函数与一个&nbsp;<code>for</code>复合函数相结合，以迭代这些参数并处理多种饮品。这很简单，只需将您的函数放在一个文件中并添加&nbsp;<code>for</code>指令。 清单 28演示了新的 myorder.sh 脚本。</p> 
         <h5>清单 28. 使用 myorder.sh 订购多种饮品</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>cat myorder.sh</strong>
 function myorder () 
 { 
    local restorecase=$(shopt -p nocasematch) rc=0; 
    shopt -s nocasematch; 
    case "$*" in 
        "coffee" | "decaf") 
            echo "Hot coffee coming right up"
        ;; 
        "tea") 
            echo "Hot tea on its way"
        ;; 
        "soda") 
            echo "Your ice-cold soda will be ready in a moment"
        ;; 
        *) 
            echo "Sorry, we don't serve that here"; 
            rc=1 
        ;; 
    esac; 
    $restorecase; 
    return $rc 
 } 

 for file in "$@"; do myorder "$file"; done 

 ian@attic-u15:~$ <strong>. myorder.sh coffee tea "milk shake"</strong>
 Hot coffee coming right up 
 Hot tea on its way 
 Sorry, we don't serve that here</pre> 
         </div> 
         <p>您可以注意到，通过使用&nbsp;<code>.</code>命令，会获取该脚本，在当前 shell 环境中运行它，而不是在它自己的 shell 中运行它。要运行一个脚本，必须获取它，或者必须使用&nbsp;<code>chmod&nbsp;+x</code>命令将脚本文件标记为可执行，如 清单 29中所示。</p> 
         <h5>清单 29. 让脚本可执行</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>chmod +x myorder.sh</strong>
 ian@attic-u15:~$ <strong>./myorder.sh coffee tea "milk shake"</strong>
 Hot coffee coming right up 
 Hot tea on its way 
 Sorry, we don't serve that here</pre> 
         </div> 
         <p>您仍然必须提供脚本的完整或相对路径，除非将它放在位于&nbsp;<code>PATH</code>上的目录中。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2> <code>seq</code>、<code>read</code>和&nbsp;<code>exec</code>命令</h2> 
         <p>Bash 和其他 shell 中有 3 个有用的命令，在脚本中常常会看到它们：<code>seq</code>、<code>read</code>和&nbsp;<code>exec</code>。</p> 
         <h3> <code>seq</code>命令</h3> 
         <p><code>seq</code>命令生成一个具有指定的增量的数列。您指定至多 3 个参数：一个单独的结尾值；一个起点和一个重点；或者一个起点、增量和一个终点。如果未指定，增量和起点默认情况下为 1。增量可以为负值。可以使用&nbsp;<code>-s</code>选项指定默认&nbsp;<code>\n</code>以外的分隔符；如果需要的话，可以使用&nbsp;<code>-w</code>选项获得等差数列。还可以使用&nbsp;<code>-f</code>选项执行&nbsp;<code>printf</code>风格的格式化。请参阅&nbsp;<code>seq</code>手册页了解更多的细节。 清单 30显示了一些示例。</p> 
         <h5>清单 30. 使用&nbsp;<code>seq</code>生成数列</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>seq 3</strong>
 1 
 2 
 3 
 ian@attic-u15:~$ <strong>seq -s " - " 7 10</strong>
 7 - 8 - 9 - 10 
 ian@attic-u15:~$ <strong>seq -w 2 7 19</strong>
 02 
 09 
 16 
 ian@attic-u15:~$ <strong>seq -s ' ' 2 -3 -8</strong>
 2 -1 -4 -7 
 ian@attic-u15:~$ <strong>seq 3 2</strong></pre> 
         </div> 
         <p>现在看看一个使用了目前介绍的一些概念的更有趣示例。您可能已在学校学过素数，而且可能听说过生成它们的方式，包括爱拉托逊斯筛法和试除法。我将在这个示例中使用试除法。思路是您通过将一个数除以更小的数来测试它是否是素数。显然，您只需要检查它是否可被更小的素数除尽，您需要测试的这个素数最大不能大于您测试的数的平方根。</p> 
         <p>清单 31显示了我的 primes.sh 脚本。该脚本在测试中使用了&nbsp;<code>[&nbsp;]</code>，在算法中使用了&nbsp;<code>((&nbsp;))</code>，在决策中使用了&nbsp;<code>if</code>，还使用了&nbsp;<code>for</code>循环，并使用<code>break</code>命令来分解循环。我使用命令替换（使用重音符）来分配&nbsp;<code>seq</code>命令的输出，将它作为&nbsp;<code>for</code>命令要处理的值列表。</p> 
         <h5>清单 31. 使用&nbsp;<code>seq</code>和其他工具生成素数</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>cat primes.sh</strong>
 #!/bin/bash 
 # Find all the positive primes up to $1 
 declare -i lastnum=0 
 # primelist will contain all prime values up to 
 # the square root of $1 
 primelist="2"
 # Only try to do something if we have a parameter 
 if [ $# -gt 0 ]; then 
  (( lastnum+= $1 )) 
  echo "Positive primes up to $lastnum"
  if [ $lastnum -ge 2 ]; then 
      echo "2"
      # Now only look at odd numbers greater than 2 
      for n in `seq 3 2  $lastnum` 
      do 
	  # Flag this one as prime till proven otherwise 
	  p=0 
	  for t in $primelist 
	  do 
	      (( remainder = n%t )) 
	      if [ $remainder -eq 0 ]; then 
		  p=1 
		  # Skip to next now we know not a prime 
		  break 
	      fi 
	  done 
	  if [ $p -eq 0 ]; then 
	      # Found a prime 
	      echo $n 
	      if (( lastnum &gt; (n * n) )) ; then 
		  primelist="$primelist $n"
	      fi 
	   fi 
      done 
  fi 
 fi</pre> 
         </div> 
         <p>将该脚本的代码粘贴到您自己的 Linux 系统中并尝试运行。 清单 32显示了一些示例输出。想想您可以如何修改此脚本来查找两个不同的数之间的素数，比如 10,000 和 10,500 之间。您能否或是否应该添加额外的错误检查或输入清理？</p> 
         <h5>清单 32. 不超过 30 的素数</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>./primes.sh 30</strong>
 Positive primes up to 30 
 2 
 3 
 5 
 7 
 11 
 13 
 17 
 19 
 23 
 29</pre> 
         </div> 
         <h3> <code>read</code>命令</h3> 
         <p>如果您想迭代一组数，那么&nbsp;<code>seq</code>命令很有用，但是，如果您需要迭代来自终端或一个文件的输入，该怎么办？答案是使用&nbsp;<code>read</code>命令，它从 stdin 读取一行，将它分解为标记，并将这些标记分配给一个或多个变量。 清单 33展示了如何将一行读入到 3 个数组变量中，然后使用&nbsp;<code>for</code>和&nbsp;<code>seq</code>打印结果。在读取第二个变量后，将输入行的剩余部分放在第三个变量&nbsp;<code>v[3]</code>中。如果您希望将整行放在一个变量中，可以对&nbsp;<code>read</code>使用单个变量。</p> 
         <h5>清单 33. 使用&nbsp;<code>read</code>命令</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>read v[1] v[2] v[3]</strong><strong>The quick brown fox jumps over the lazy dog</strong>
 ian@attic-u15:~$ <strong>for n in `seq 1 3`; do echo ${v[n]} ;done</strong>
 The 
 quick 
 brown fox jumps over the lazy dog</pre> 
         </div> 
         <p><code>read</code>命令有多个选项可用来设置行分隔符，在读取输入之前写出一个提示，读取至多指定数量个字符，等等。使用&nbsp;<code>help&nbsp;read</code>查看简略摘要或使用&nbsp;<code>info&nbsp;bash&nbsp;read</code>。在一些系统上，比如 Ubuntu 或 Debian，可能需要安装&nbsp;<code>bash-doc</code>包才能获得&nbsp;<code>info</code>格式的 bash 手册。</p> 
         <p>现在您已经知道如何从 stdin 读取一行，您可以将此命令与一个循环结构相结合 —通常为&nbsp;<code>while</code>来迭代来自 stdin 的所有行。您可以尝试将此作为来自&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing27" rel="nofollow">清单 27</a>的&nbsp;<code>ldirs</code>函数的另一种方法。 清单 34给出了一次尝试的代码。</p> 
         <h5>清单 34. 编写&nbsp;<code>ldirs</code>的另一种方法</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>type ldirs</strong>
 ldirs is a function 
 ldirs () 
 { 
    if [ $# -gt 0 ]; then 
        /bin/ls "$@" | while read l; do 
            [ -d "$l" ] &amp;&amp; echo "$l"; 
        done; 
    else 
        /bin/ls | while read l; do 
            [ -d "$l" ] &amp;&amp; echo "$l"; 
        done; 
    fi; 
    return 0 
 } 
 ian@attic-u15:~$ <strong>cd developerworks/</strong>
 ian@attic-u15:~/developerworks$ <strong>ldirs</strong>
 my first article 
 readme 
 schema 
 templates 
 tools 
 web 
 xsl 
 ian@attic-u15:~/developerworks$ <strong>ldirs *s* tools/*</strong>
 ian@attic-u15:~/developerworks$ <strong># Oops! No output</strong></pre> 
         </div> 
         <p>分析来自&nbsp;<code>ls</code>命令的输出，您将发现它没有显示完整路径。所以修改后的函数在没有参数时能正常运行，但有参数时可能失败。如果您返回来，使用前面的教程 “<a href="https://www.ibm.com/developerworks/library/l-lpic1-105-1/" rel="nofollow"><em>学习 Linux，101</em>：自定义和使用 shell 环境</a>” 中的函数，就会发现它也会遇到同样的问题，我当时没有指出这一事实。&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing27" rel="nofollow">清单 27</a>中的&nbsp;<code>ldirs</code>函数在使用参数时能够更好地运行，因为输入直接来自 shell 通配符和通配符替换，而不是来自&nbsp;<code>ls</code>命令的格式化输出。</p> 
         <p>您现在已知道如何结合使用&nbsp;<code>read</code>和&nbsp;<code>while</code>循环，而且已经了解了编写&nbsp;<code>ldirs</code>函数的 3 种不同方法。</p> 
         <h3> <code>exec</code>命令</h3> 
         <p><code>exec</code>命令有两个用途。第一个是将控制权完全交给一个新程序，取代您当前运行的 shell，但不创建新进程。如果您想利用 bash shell 的强大功能来设置命令的复杂环境，那么可以这么做。使用&nbsp;<code>exec</code>将您的 shell 替换为想要的命令后，您的用户无法返回到 shell 提示符（即使命令失败）。您可以在希望用户拥有有限且受控的系统访问权的地方使用&nbsp;<code>exec</code>—例如在信息亭环境或图书馆目录终端上。</p> 
         <p>在&nbsp;<code>exec</code>的第二种用法中，您没有指定命令。使用&nbsp;<code>exec</code>从不同的文件句柄输入和输出到它们。为什么您想这么做？假设您想使用一个&nbsp;<code>while</code>循环来读取一个文件，并计算总行数和空白行数。在&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#read2" rel="nofollow">清单 34</a>中，该过程是使用一个管道来完成的，其中&nbsp;<code>ls</code>命令的输出传输到&nbsp;<code>while</code>循环中。当 bash 运行一个管道时，它在一个子 shell 中运行它，对环境的任何更改均对调用环境不可见。 清单 35演示了该问题。</p> 
         <h5>清单 35. 环境变量无法在管道中设置</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ x=3 
 ian@attic-u15:~$ echo "abc" | while read n; do echo $n;x=4;done 
 abc 
 ian@attic-u15:~$ echo $x 
 3</pre> 
         </div> 
         <p>如果您可以重定向来自指定文件的输入，而不使用 stdin，则不需要将&nbsp;<code>cat</code>的输出传经&nbsp;<code>while</code>循环。使用&nbsp;<code>exec</code>重定向文件描述符很有用。 清单 36给出了一段统计一个指定文件中的总行数和空白行数的简单脚本。想想您可以如何修改该脚本来处理多个文件。</p> 
         <h5>清单 36. 统计一个文件中的行数</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ cat ./countlines.sh  
 #!/bin/bash 
 # Simple script to count lines in a file and also blank lines 

 if [ $# -gt 0 ]; then 
  if [ -f "$1" -a -r "$1" ] ; then 
      lines=0 
      blanklines=0 
      exec 3&lt; "$1" # Redirect input to file descriptor 3 
      while read line &lt;&amp;3 # Read from fd 3 
      do { 
	  [ -z "$line" ] &amp;&amp;  (( blanklines ++  )) 
	  (( lines ++  )) 
      } 
      done 
      exec 3&gt;&amp;- # Restore input to stdin (fd 0) 
      echo "$1 has $lines lines of which $blanklines are blank"
  fi 
 fi 
 exit 0 
 ian@attic-u15:~$ ./countlines.sh  .bashrc 
 .bashrc has 120 lines of which 23 are blank</pre> 
         </div> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>指定一个 shell</h2> 
         <p>现在您有一些全新的 shell 脚本要处理，您可能会问它们能否在所有 shell 中运行。 清单 37显示了如果您在 Ubuntu 系统上首先使用 bash shell，然后使用 dash shell 来运行 myorder.sh shell 脚本，会发生什么情况。</p> 
         <h5>清单 37. Shell 的区别</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>./myorder.sh tea soda</strong>
 Hot tea on its way 
 Your ice-cold soda will be ready in a moment 
 ian@attic-u15:~$ <strong>dash</strong>
 $ <strong>./myorder.sh tea soda</strong>
 ./myorder.sh: 1: ./myorder.sh: Syntax error: "(" unexpected</pre> 
         </div> 
         <p>结果并不好！</p> 
         <p>回想一下 “<a href="https://www.ibm.com/developerworks/library/l-lpic1-105-1/" rel="nofollow"><em>学习 Linux，101</em>：自定义和使用 shell 环境</a>” 中的介绍，单词&nbsp;<code>function</code>在 bash 函数定义中是可选的，但未包含在 POSIX shell 规范中。dash 是一种比 bash 更小型、更轻量级的 shell，它不支持这个可选的特性。您无法保证您的潜在用户可能更喜欢哪个 shell，所以始终应确保您的脚本可移植到所有 shell 环境（这可能很困难），或者使用所谓的 shebang (<code>#!</code>) 来告诉 shell 在一个特定的 shell 中运行您的脚本。shebang 行必须是您的脚本的第一行，而且该行的剩余部分包含您的程序必须使用的 shell 的路径。所以您将对 myorder.sh 脚本使用<code>#!/bin/bash</code>，如 清单 38中所示。</p> 
         <h5>清单 38. 使用 shebang</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>head -n3 myorder.sh</strong>
 #!/bin/bash 
 function myorder () 
 { 
 ian@attic-u15:~$ <strong>dash</strong>
 $ <strong>./myorder.sh Tea Coffee</strong>
 Hot tea on its way 
 Hot coffee coming right up</pre> 
         </div> 
         <p>您可以使用&nbsp;<code>cat</code>命令来显示 /etc/shells，这是您系统上的 shell 列表。一些系统会列出未安装的 shell，而且一些列出的 shell（可能是 /dev/null）的存在可能只是为了确保 FTP 用户不会意外地离开他们的受限环境。如果您需要更改默认的 shell，可以使用&nbsp;<code>chsh</code>命令，它会更新 /etc/passwd 中您的 userid 的条目。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>Suid 权限和脚本位置</h2> 
         <p>在早先的教程 “<a href="http://www.ibm.com/developerworks/library/l-lpic1-v3-104-5/" rel="nofollow"><em>学习 Linux，101</em>：管理文件权限和所有权</a>” 中，您学习了如何更改文件的所有者和组，以及如何设置 suid 和 sgid 权限。一个包含这些权限集之一的可执行程序将在一个具有该文件的所有者 (suid) 或组 (suid) 的有效权限的 shell 中运行。因此根据设置的权限位，该程序将能够执行该所有者或组可以执行的任何操作。一些程序有合理的理由需要这么做。例如，<code>passwd</code>程序需要更新 /etc/shadow，<code>chsh</code>命令（您使用它更改默认 shell）需要更新 /etc/passwd。如果您为&nbsp;<code>ls</code>使用了一个别名，列出这些程序可能会得到一个红色的、突出显示的列表来警告您，如 图 1中所示。这两个程序都设置了一个或多个 suid 位，因此就像所有者（在本例中为根用户）在运行它们一样。</p> 
         <h5>图 1. 具有 suid 权限的程序</h5> 
         <img src="https://yqfile.alicdn.com/img_edff958ca5e51d68df89451cc268646d.jpg" alt="两个具有 suid 权限的程序的颜色输出" width="425">
         <p>清单 39表明普通用户可运行这些程序和更新根用户拥有的文件。</p> 
         <h5>清单 39. 使用 suid 程序</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> jenni@attic-u15:~$ <strong>passwd</strong>
 Changing password for jenni. 
 (current) UNIX password: 
 Enter new UNIX password: 
 Retype new UNIX password: 
 passwd: password updated successfully 
 jenni@attic-u15:~$ <strong>cat /etc/shells</strong>
 # /etc/shells: valid login shells 
 /bin/sh 
 /bin/dash 
 /bin/bash 
 /bin/rbash 
 jenni@attic-u15:~$ <strong>chsh</strong>
 Password: 
 Changing the login shell for jenni 
 Enter the new value, or press ENTER for the default 
 Login Shell [/bin/bash]: <strong>/bin/dash</strong>
 jenni@attic-u15:~$ <strong>find /etc -mmin -4 -ls 2&gt;/dev/null</strong>
 4325377   12 drwxr-xr-x 139 root     root        12288 Dec  1 22:47 /etc 
 4334839    4 -rw-r--r--   1 root     root         2304 Dec  1 22:47 /etc/passwd 
 jenni@attic-u15:~$ <strong>grep jenni /etc/passwd</strong>
 jenni:x:1001:1001:Jenni Aloi,,,:/home/jenni:/bin/dash</pre> 
         </div> 
         <p>您可以为所有 shell 脚本设置 suid 和 sgid 权限，但大多数现代 shell 都会忽略脚本的这些位。您可以看到，shell 拥有一种强大的脚本语言，具有比本教程中介绍的更多的特性 —比如解释和执行任意表达式的能力。这些特性使 shell 成为了一个允许使用如此广泛的权限的不安全环境。所以如果您为一个 shell 脚本设置 suid 或 sgid 权限，不要期望该权限会在脚本运行时得到遵守。</p> 
         <p>在之前（参阅&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#listing29" rel="nofollow">清单 29</a>），您更改了 myorder.sh 的权限，将它标记为可执行。但要运行该脚本，仍然需要通过添加&nbsp;<code>./</code>前缀来限定它的名称，除非您是在当前 shell 中获取它的。如果想要仅通过名称来运行一个 shell 脚本，该脚本必须在您的搜索路径上，该路径由&nbsp;<code>PATH</code>变量表示。通常您不希望当前目录在您的路径上，因为这会带来潜在的安全风险。测试您的脚本并对它感到满意后，将它放在您的主目录中，或者如果它是个人脚本，可以将它放在 ~/bin 目录中，如果它要供系统上的其他用户使用，则将它放在 /usr/local/bin 中。如果您只使用&nbsp;<code>chmod&nbsp;+x</code>来将它标记为可执行，那么它可以由每个人执行（所有者、组和所有用户），您通常希望这么做。如果您需要限制脚本，以便只有某个组的成员可以运行它，请参阅 “<a href="http://www.ibm.com/developerworks/library/l-lpic1-v3-104-5/" rel="nofollow"><em>学习 Linux，101</em>：管理文件权限和所有权</a>。”</p> 
         <p>您可能已注意到，shell 程序（比如 bash 和 dash）通常位于 /bin 中而不是 /usr/bin 中。依据文件系统分层结构标准，/usr/bin 可位于在系统间共享的文件系统中，因此它可能在初始化时不可用。因此，一些函数（比如 shell）应位于 /bin 中，以便即使 /usr/bin 还未挂载，也可以使用它们。用户创建的脚本通常不需要位于 /bin（或 /sbin）中，因为这些目录中的程序应该已经为您提供了足够的工具来正常运行系统，达到您可以挂载 /usr 文件系统的状态。</p> 
         <div class="ibm-alternate-rule">
          &nbsp;
         </div> 
         <p><a class="ibm-anchor-up-link" href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-105-2/index.html#ibm-pcon" rel="nofollow">回页首</a></p> 
         <h2>向根用户发送邮件通知</h2> 
         <p>假设在夜深人静您进入梦乡的时候，您的脚本正在运行您的系统上的一个管理任务。某个地方出错时会发生什么？幸运的是，将错误信息或日志文件通过邮件发送给自己、另一位管理员或根用户非常简单。只需将该消息传输到&nbsp;<code>mail</code>命令，使用&nbsp;<code>-s</code>选项添加一个主题行，如 清单 40中所示。</p> 
         <h5>清单 40. 通过邮件将错误消息发送给用户</h5> 
         <div class="codesection"> 
          <pre class="displaycode"> ian@attic-u15:~$ <strong>echo "Midnight error message" | mail -s "Admin error" ian</strong>
 ian@attic-u15:~$ <strong>mail</strong>
"/var/mail/ian": 1 message 1 new 
 &gt;N   1 Ian Shields        Tue Dec  1 23:08  13/423   Admin error 
 ? <strong>1</strong>
 Return-Path: &lt;ian@attic-u15&gt; 
 X-Original-To: ian@attic-u15 
 Delivered-To: ian@attic-u15 
 Received: by attic-u15 (Postfix, from userid 1000) 
 id 6755C42740; Tue,  1 Dec 2015 23:08:57 -0500 (EST) 
 Subject: Admin error 
 To: &lt;ian@attic-u15&gt; 
 X-Mailer: mail (GNU Mailutils 2.99.98) 
 Message-Id: &lt;20151202040857.6755C42740@attic-u15&gt; 
 Date: Tue,  1 Dec 2015 23:08:57 -0500 (EST) 
 From: ian@attic-u15 (Ian Shields) 

 Midnight error message 
 ? <strong>d</strong>
 ? <strong>q</strong>
 Held 0 messages in /var/mail/ian</pre> 
         </div> 
         <p>如果您需要通过邮件发送日志文件，可以使用&nbsp;<code>&lt;</code>重定向函数将它重定向为&nbsp;<code>mail</code>命令的输入。如果您需要发送多个文件，可以使用&nbsp;<code>cat</code>组合它们，然后将输出传输到&nbsp;<code>mail</code>。在 清单 40中，邮件发送给了用户 ian，儿他恰好也在运行该命令，但管理脚本很有可能通过邮件直接发送给根用户或另一位管理员。跟平常一样，请参阅&nbsp;<code>mail</code>的手册页，了解您可指定的其他选项。</p> 
         <p>对自定义和编写 bash 脚本的介绍到此就结束了。</p> 
        </div> 
       </div> 
       <div class="ibm-columns"> 
        <div class="ibm-col-6-4"> 
         <h2>参考资料</h2> 
         <h3>学习</h3> 
         <ul class="ibm-bullet-list">
          <li> <a href="https://www.ibm.com/developerworks/cn/premium" rel="nofollow">developerWorks Premium</a>提供了强大的工具、来自 Safari Books Online 的精心管理的技术图书馆、大会折扣和会议记录、SoftLayer 和 Bluemix 贷款等的一站式访问权。</li> 
          <li>使用&nbsp;<a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-map/" rel="nofollow">developerWorks LPIC-1 学习路线图</a>查找 developerWorks 教程，帮助您基于 2015 年 4 月的 LPI 4.0 版目标来进行 LPIC-1 认证学习。</li> 
          <li>在&nbsp;<a href="http://www.lpi.org/certification/get-certified-lpi/" rel="nofollow">Linux Professional Institute</a>网站上，查找这些认证的详细目标、任务列表和样例问题。具体地讲，请参阅： 
           <ul>
            <li> <a href="http://www.lpi.org/certification/get-certified-lpi/lpic-1-linux-server-professional/" rel="nofollow">LPIC-1：Linux 服务器专业认证</a>计划细节</li> 
            <li> <a href="http://www.lpi.org/study-resources/lpic-1-101-exam-objectives/" rel="nofollow">LPIC-1 考试 101</a>目标</li> 
            <li> <a href="http://www.lpi.org/study-resources/lpic-1-102-exam-objectives/" rel="nofollow">LPIC-1 考试 102</a>目标</li> 
           </ul> 随时访问 Linux Professional Institute 网站来了解最新的目标。</li> 
          <li>在 “<a href="http://www.ibm.com/developerworks/cn/linux/tutorials/l-basics/" rel="nofollow">新 Linux 用户的基本任务</a>” 中（developerWorks，2011 年 4 月），学习如何打开终端窗口或 shell 提示符等操作。</li> 
          <li> <a href="http://www.ibm.com/developerworks/cn/linux/" rel="nofollow">IBM developerWorks 中国 Linux 专区</a>：为使用 Linux 产品的开发人员准备的技术信息和资料。这里提供产品下载、how-to 信息、支持资源以及免费技术库，包含 2000 多份技术文章、教程、最佳实践、IBM Redbook 和在线产品手册。</li> 
         </ul>
         <h3>讨论</h3> 
         <ul class="ibm-bullet-list">
          <li>加入&nbsp;<a href="http://www.ibm.com/developerworks/cn/community/" rel="nofollow">developerWorks 中文社区</a>，developerWorks 社区是一个面向全球 IT 专业人员，可以提供博客书签、wiki、群组、联系、共享和协作等社区功能的专业社交网络社区。</li> 
         </ul>
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
