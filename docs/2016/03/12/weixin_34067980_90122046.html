<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>NandFlash详述【转】 « NotBeCN</title>
  <meta name="description" content="             NandFlash详述    转自：http://wenku.baidu.com/view/04d9330bb52acfc789ebc92f.html?re=view    1.&nbsp;硬件特性：    【Flash的硬件实现机制】    Flash全名叫做Flash Memory，...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/03/12/weixin_34067980_90122046.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">NandFlash详述【转】</h1>
    <p class="post-meta">Mar 12, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p align="center"><strong>NandFlash</strong><strong>详述</strong></p> 
   <p style="text-align:left;" align="center"><strong>转自：<a href="http://wenku.baidu.com/view/04d9330bb52acfc789ebc92f.html?re=view" rel="nofollow">http://wenku.baidu.com/view/04d9330bb52acfc789ebc92f.html?re=view</a></strong></p> 
   <p align="left"><strong>1.&nbsp;</strong><strong>硬件特性：</strong></p> 
   <p align="left"><strong>【</strong><strong>Flash</strong><strong>的硬件实现机制】</strong></p> 
   <p align="left">Flash全名叫做Flash Memory，属于非易失性存储设备(Non-volatile Memory Device)，与此相对应的是易失性存储设备(Volatile Memory Device)。这类设备，除了Flash，还有其他比较常见的如硬盘，ROM等，</p> 
   <p align="left">与此相对的，易失性就是断电了，数据就丢失了，比如大家常用的内存，不论是以前的SDRAM，DDR SDRAM，还是现在的DDR2，DDR3等，都是断电后，数据就没了。</p> 
   <p align="left">Flash的内部存储是<strong>MOSFET</strong>，里面有个悬浮门(Floating Gate)，是真正存储数据的单元。</p> 
   <p align="left">-------------------------------------------------------------------------------------------------------------------------</p> 
   <p align="left">金属-氧化层-半导体-场效<a href="http://baike.baidu.com/view/30363.htm" rel="nofollow">晶体管</a>，简称<strong>金氧半场效晶体管</strong>（Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET）是一种可以广泛使用在模拟<a href="http://baike.baidu.com/view/134362.htm" rel="nofollow">电路</a>与数字电路的场效晶体管（field-effect transistor）。MOSFET依照其“通道”的极性不同，可分为n-type与p-type的MOSFET，通常又称为NMOSFET与PMOSFET，其他简称尚包括NMOS FET、PMOS FET、nMOSFET、pMOSFET等。</p> 
   <p align="left">-------------------------------------------------------------------------------------------------------------------------</p> 
   <p align="left">在Flash之前，紫外线可擦除(uv-erasable)的EPROM，就已经采用用Floating Gate存储数据这一技术了。</p> 
   <p align="center">&nbsp;</p> 
   <p align="center"><strong>图</strong><strong>1.</strong><strong>典型的</strong><strong>Flash</strong><strong>内存单元的物理结构</strong></p> 
   <p align="left">数据在Flash内存单元中是的。</p> 
   <p align="left">存储电荷的多少，取决于图中的外部门（external gate）所被施加的电压，其控制了是向存储单元中冲入电荷还是使其释放电荷。</p> 
   <p align="left">数据的表示，以所存储的电荷的电压是否超过一个特定的阈值Vth来表示。</p> 
   <p align="left"><strong>【</strong><strong>SLC</strong><strong>和</strong><strong>MLC</strong><strong>的实现机制】</strong></p> 
   <p align="left">Nand Flash按照内部存储数据单元的电压的不同层次，也就是单个内存单元中，是存储1位数据，还是多位数据，可以分为<strong>SLC</strong>和<strong>MLC</strong>：</p> 
   <p align="left"><strong>1.&nbsp;SLC</strong><strong>，</strong><strong>Single Level Cell:</strong></p> 
   <p align="left">单个存储单元，只存储一位数据，表示成1或0.</p> 
   <p align="left">就是上面介绍的，对于数据的表示，单个存储单元中内部所存储电荷的电压，和某个特定的阈值电压Vth，相比，如果大于此Vth值，就是表示1，反之，小于Vth，就表示0.</p> 
   <p align="left">对于nand Flash的数据的写入1，就是控制External Gate去充电，使得存储的电荷够多，超过阈值Vth，就表示1了。而对于写入0，就是将其放电，电荷减少到小于Vth，就表示0了。</p> 
   <p align="left">关于为何Nand Flash不能从0变成1，我的理解是，物理上来说，是可以实现每一位的，从0变成1的，但是实际上，对于实际的物理实现，出于效率的考虑，如果对于，每一个存储单元都能单独控制，即，0变成1就是，对每一个存储单元单独去充电，所需要的硬件实现就很复杂和昂贵，同时，所进行对块擦除的操作，也就无法实现之前的，一闪而过的速度了，也就失去了Flash的众多特性了。</p> 
   <p align="left">// 也就是放电的思路还是容易些。1-&gt;0</p> 
   <p align="left"><strong>2.&nbsp;MLC</strong><strong>，</strong><strong>Multi Level Cell</strong><strong>：</strong></p> 
   <p align="left">与SLC相对应，就是单个存储单元，可以存储多个位，比如2位，4位等。其实现机制，说起来比较简单，就是，通过控制内部电荷的多少，分成多个阈值，通过控制里面的电荷多少，而达到我们所需要的存储成不同的数据。比如，假设输入电压是Vin＝4V（实际没有这样的电压，此处只是为了举例方便），那么，可以设计出2的2次方＝4个阈值，1/4的Vin＝1V，2/4的Vin＝2V，3/4的Vin＝3V，Vin＝4V，分别表示2位数据00，01，10，11，对于写入数据，就是充电，通过控制内部的电荷的多少，对应表示不同的数据。</p> 
   <p align="left">对于读取，则是通过对应的内部的电流（与Vth成反比），然后通过一系列解码电路完成读取，解析出所存储的数据。这些具体的物理实现，都是有足够精确的设备和技术，才能实现精确的数据写入和读出的。</p> 
   <p align="left">单个存储单元可以存储2位数据的，称作2的2次方＝4 Level Cell，而不是2 Level Cell；</p> 
   <p align="left">同理，对于新出的单个存储单元可以存储4位数据的，称作2的4次方＝16 Level Cell。</p> 
   <p align="left"><strong>【关于如何识别</strong><strong>SLC</strong><strong>还是</strong><strong>MLC</strong><strong>】</strong></p> 
   <p align="left">Nand Flash设计中，有个命令叫做Read ID，读取ID，意思是读取芯片的ID，就像大家的身份证一样，这里读取的ID中，是：</p> 
   <p align="left">读取好几个字节，一般最少是4个，新的芯片，支持5个甚至更多，从这些字节中，可以解析出很多相关的信息，比如：</p> 
   <p align="left">此Nand Flash内部是几个芯片（chip）所组成的，</p> 
   <p align="left">每个chip包含了几片（Plane），</p> 
   <p align="left">每一片中的页大小，块大小，等等。</p> 
   <p align="left">在这些信息中，其中有一个，就是识别此flash是SLC还是MLC。下面这个就是最常见的Nand Flash的datasheet中所规定的，第3个字节，3rd byte，所表示的信息，其中就有SLC/MLC的识别信息：</p> 
   <p align="left">&nbsp;</p> 
   <table border="1">
    <tbody>
     <tr>
      <td>&nbsp;</td> 
      <td> <p align="left"><strong>Description</strong></p> </td> 
      <td> <p align="left"><strong>I/O7</strong></p> </td> 
      <td> <p align="left"><strong>I/O6</strong></p> </td> 
      <td> <p align="left"><strong>I/O5 I/O4</strong></p> </td> 
      <td> <p align="left"><strong>I/O3 I/O2</strong></p> </td> 
      <td> <p align="left"><strong>I/O1 I/O0</strong></p> </td> 
     </tr>
     <tr>
      <td> <p align="left"><strong>Internal</strong></p> <p align="left"><strong>Chip Number</strong></p> </td> 
      <td> <p align="left"><strong>1</strong></p> <p align="left"><strong>2</strong></p> <p align="left"><strong>4</strong></p> <p align="left"><strong>8</strong></p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="left"><strong>0&nbsp;0</strong></p> <p align="left"><strong>0&nbsp;1</strong></p> <p align="left"><strong>1&nbsp;0</strong></p> <p align="left"><strong>1&nbsp;1</strong></p> </td> 
     </tr>
     <tr>
      <td> <p align="left"><strong>Cell Type</strong></p> </td> 
      <td> <p align="left"><strong>2 Level Cell</strong></p> <p align="left"><strong>4 Level Cell</strong></p> <p align="left"><strong>8 Level Cell</strong></p> <p align="left"><strong>16 Level Cell</strong></p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="left"><strong>0&nbsp;0</strong></p> <p align="left"><strong>0&nbsp;1</strong></p> <p align="left"><strong>1&nbsp;0</strong></p> <p align="left"><strong>1&nbsp;1</strong></p> </td> 
      <td>&nbsp;</td> 
     </tr>
     <tr>
      <td> <p align="left"><strong>Number of</strong></p> <p align="left"><strong>Simultaneously</strong></p> <p align="left"><strong>Programmed Pages</strong></p> </td> 
      <td> <p align="left"><strong>1</strong></p> <p align="left"><strong>2</strong></p> <p align="left"><strong>4</strong></p> <p align="left"><strong>8</strong></p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td> <p align="left"><strong>0&nbsp;0</strong></p> <p align="left"><strong>0&nbsp;1</strong></p> <p align="left"><strong>1&nbsp;0</strong></p> <p align="left"><strong>1&nbsp;1</strong></p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr>
     <tr>
      <td> <p align="left"><strong>Interleave Program</strong></p> <p align="left"><strong>Between multiple chips</strong></p> </td> 
      <td> <p align="left"><strong>Not Support</strong></p> <p align="left"><strong>Support</strong></p> </td> 
      <td>&nbsp;</td> 
      <td> <p align="left"><strong>0</strong></p> <p align="left"><strong>1</strong></p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr>
     <tr>
      <td> <p align="left"><strong>Cache Program</strong></p> </td> 
      <td> <p align="left"><strong>Not Support</strong></p> <p align="left"><strong>Support</strong></p> </td> 
      <td> <p align="left"><strong>0</strong></p> <p align="left"><strong>1</strong></p> </td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
      <td>&nbsp;</td> 
     </tr>
    </tbody>
   </table>
   <p align="left"><strong>表</strong><strong>1.Nand Flash</strong><strong>第</strong><strong>3</strong><strong>个</strong><strong>ID</strong><strong>的含义</strong></p> 
   <p align="left"><strong>【</strong><strong>Nand Flash</strong><strong>的物理存储单元的阵列组织结构】</strong></p> 
   <p align="left">Nand flash的内部组织结构，此处还是用图来解释，比较容易理解：</p> 
   <p align="left"><strong>图</strong><strong>2.Nand Flash</strong><strong>物理存储单元的阵列组织结构</strong></p> 
   <p align="left">&nbsp;</p> 
   <p align="left">上图是K9K8G08U0A的datasheet中的描述。</p> 
   <p align="left">简单解释就是:</p> 
   <p align="left"><strong>1.</strong>一个nand flash由很多个块（Block）组成，</p> 
   <p align="left">块的大小一般是</p> 
   <p align="left">-&gt;&nbsp;128KB，</p> 
   <p align="left">-&gt;&nbsp;256KB，</p> 
   <p align="left">-&gt;&nbsp;512KB</p> 
   <p align="left">此处是128KB。</p> 
   <p align="left"><strong>2.</strong>每个块里面又包含了很多页（page）。每个页的大小，</p> 
   <p align="left">老的nand flash，页大小是256B，512B，</p> 
   <p align="left">这类的nand flash被称作small block，。地址周期只有4个。</p> 
   <p align="left">对于现在常见的nand flash多数是2KB，</p> 
   <p align="left">被称作big block，对应的发读写命令地址，一共5个周期(cycle)，</p> 
   <p align="left">更新的nand flash是4KB，</p> 
   <p align="left"><strong>块</strong>，也是Nand Flash的擦除操作的基本/最小单位。</p> 
   <p align="left"><strong>3.</strong>每一个页，对应还有一块区域，叫做空闲区域（spare area）/冗余区域（redundant area），而Linux系统中，一般叫做<strong>OOB</strong>（Out Of Band），这个区域，是最初基于Nand Flash的硬件特性：数据在读写时候相对容易错误，所以为了保证数据的正确性，必须要有对应的检测和纠错机制，此机制被叫做EDC(Error Detection Code)/ECC（Error Code Correction,或者Error Checking and Correcting），所以设计了多余的区域，用于放置数据的校验值。</p> 
   <p align="left"><strong>页</strong>, 是Nand Flash的写入操作的基本/最小的单位。</p> 
   <p align="left">【Nand Flash数据存储单元的整体架构】</p> 
   <p align="left">简单说就是，常见的nand flash，内部只有一个chip，每个chip只有一个plane。</p> 
   <p align="left">而有些复杂的，容量更大的nand flash，内部有多个chip，每个chip有多个plane。这类的nand flash，往往也有更加高级的功能，比如下面要介绍的Multi Plane Program和Interleave Page Program等。</p> 
   <p align="left"><strong>比如</strong>，型号为<strong>K9K8G08U0A</strong>这个芯片（chip），</p> 
   <p align="left">内部有:</p> 
   <p align="left">K9F4G08U0A (256MB)&nbsp;<strong>:</strong>&nbsp;Plane (1Gb), Plane (1Gb)</p> 
   <p align="left">K9F4G08U0A (256MB)&nbsp;<strong>:</strong>&nbsp;Plane (1Gb), Plane (1Gb)</p> 
   <p align="left">K9WAG08U1A&nbsp;，内部包含了2个K9K8G08U0A</p> 
   <p align="left">K9NBG08U5A&nbsp;，内部包含了4个K9K8G08U0A</p> 
   <p align="left">【Flash名称的由来】</p> 
   <p align="left">Flash的擦除操作是以block块为单位的，与此相对应的是其他很多存储设备，是以bit位为最小读取/写入的单位，Flash是一次性地擦除整个块：在发送一个擦除命令后，一次性地将一个block，常见的块的大小是128KB/256KB。。，<strong>全部擦除为</strong><strong>1</strong><strong>，也就是里面的内容全部都是</strong><strong>0xFF</strong><strong>了</strong>，由于是一下子就擦除了，相对来说，擦除用的时间很短，可以用一闪而过来形容，所以，叫做Flash Memory。中文有的翻译为（快速）闪存。</p> 
   <p align="left">【Flash相对于普通设备的特殊性】</p> 
   <p align="left">1.&nbsp;上面提到过的，Flash最小操作单位，有些特殊。</p> 
   <p align="left">一般设备，比如硬盘/内存，读取和写入都是以bit位为单位，读取一个bit的值，将某个值写入对应的地址的位，都是可以按位操作的。</p> 
   <p align="left">但是Flash由于物理特性，使得内部存储的数据，只能从1变成0，这点，可以从前面的内部实现机制了解到，只是方便统一充电，不方便单独的存储单元去放电，所以才说，只能从1变成0，也就是释放电荷。</p> 
   <p align="left">所以，总结一下Flash的特殊性如下：</p> 
   <table style="width:595px;" border="1">
    <tbody>
     <tr>
      <td>&nbsp;</td> 
      <td> <p align="left">普通设备(硬盘/内存等)</p> </td> 
      <td> <p align="left">Flash</p> </td> 
     </tr>
     <tr>
      <td> <p align="left">读取/写入的叫法</p> </td> 
      <td> <p align="left">读取/写入</p> </td> 
      <td> <p align="left">读取/编程(Program)①</p> </td> 
     </tr>
     <tr>
      <td> <p align="left">读取/写入的最小单位</p> </td> 
      <td> <p align="left">Bit/位</p> </td> 
      <td> <p align="left">Page/页</p> </td> 
     </tr>
     <tr>
      <td> <p align="left">擦除(Erase)操作的最小单位</p> </td> 
      <td> <p align="left">Bit/位</p> </td> 
      <td> <p align="left">Block/块②</p> </td> 
     </tr>
     <tr>
      <td> <p align="left">擦除操作的含义</p> </td> 
      <td> <p align="left">将数据删除/全部写入0</p> </td> 
      <td> <p align="left">将整个块都擦除成全是1，也就是里面的数据都是0xFF③</p> </td> 
     </tr>
     <tr>
      <td> <p align="left">对于写操作</p> </td> 
      <td> <p align="left">直接写即可</p> </td> 
      <td> <p align="left">在写数据之前，要先擦除，然后再写</p> </td> 
     </tr>
    </tbody>
   </table>
   <p align="left">表2.Flash和普通设备相比所具有的特殊性</p> 
   <p align="left">注：</p> 
   <p align="left">①之所以将写操作叫做编程，是因为，flash和之前的EPROM，EEPROM继承发展而来，而之前的EEPROM(Electrically Erasable Programmable Read-Only Memory)，往里面写入数据，就叫做编程Program，之所以这么称呼，是因为其对数据的写入，是需要用电去擦除/写入的，就叫做编程。</p> 
   <p align="left">②对于目前常见的页大小是2K/4K的Nand Flash，其块的大小有128KB/256KB/512KB等。而对于Nor Flash，常见的块大小有64K/32K等。</p> 
   <p align="left">③在写数据之前，要先擦除，内部就都变成0xFF了，然后才能写入数据，也就是将对应位由1变成0。</p> 
   <p align="left"><strong>【</strong><strong>Nand Flash</strong><strong>引脚</strong><strong>(Pin)</strong><strong>的说明】</strong></p> 
   <p align="left">&nbsp;</p> 
   <p align="left"><strong>图</strong><strong>3.Nand Flash</strong><strong>引脚功能说明</strong></p> 
   <p align="left">上图是常见的Nand Flash所拥有的引脚（Pin）所对应的功能，简单翻译如下：</p> 
   <p align="left">1.&nbsp;I/O0 ~ I/O7：用于输入地址/数据/命令，输出数据</p> 
   <p align="left">2.&nbsp;CLE：Command Latch Enable，命令锁存使能，在输入命令之前，要先在模式寄存器中，设置CLE使能</p> 
   <p align="left">3.&nbsp;ALE：Address Latch Enable，地址锁存使能，在输入地址之前，要先在模式寄存器中，设置ALE使能</p> 
   <p align="left">4.&nbsp;CE#：Chip Enable，芯片使能，在操作Nand Flash之前，要先选中此芯片，才能操作</p> 
   <p align="left">5.&nbsp;RE#：Read Enable，读使能，在读取数据之前，要先使CE＃有效。</p> 
   <p align="left">6.&nbsp;WE#：Write Enable，写使能,在写取数据之前，要先使WE＃有效。</p> 
   <p align="left">7.&nbsp;WP#：Write Protect，写保护</p> 
   <p align="left">8.&nbsp;R/B#:Ready/Busy Output,就绪/忙,主要用于在发送完编程/擦除命令后,检测这些操作是否完成,忙,表示编程/擦除操作仍在进行中,就绪表示操作完成.</p> 
   <p align="left">9.&nbsp;Vcc：Power，电源</p> 
   <p align="left">10.&nbsp;Vss：Ground，接地</p> 
   <p align="left">11.&nbsp;N.C：Non-Connection,未定义，未连接。</p> 
   <p align="left"><strong>[</strong><strong>小常识</strong><strong>]</strong></p> 
   <p align="left">在数据手册中，你常会看到，对于一个引脚定义，有些字母上面带一横杠的，那是说明此引脚/信号是低电平有效，比如你上面看到的RE头上有个横线，就是说明，此RE是低电平有效，此外，为了书写方便，在字母后面加“＃”，也是表示低电平有效，比如我上面写的CE＃；如果字母头上啥都没有，就是默认的高电平有效，比如上面的CLE，就是高电平有效。</p> 
   <p align="left"><strong>【为何需要</strong><strong>ALE</strong><strong>和</strong><strong>CLE</strong><strong>】</strong></p> 
   <p align="left">突然想明白了，Nand Flash中,为何设计这么多的命令,把整个系统搞这么复杂的原因了:</p> 
   <p align="left">比如命令锁存使能(Command Latch Enable,CLE)和地址锁存使能(Address Latch Enable，ALE)，那是因为，Nand Flash就8个I/O，而且是复用的，也就是，可以传数据，也可以传地址，也可以传命令，为了区分你当前传入的到底是啥，所以，先要用发一个CLE（或ALE）命令，告诉nand Flash的控制器一声，我下面要传的是命令（或地址），这样，里面才能根据传入的内容，进行对应的动作。否则,nand flash内部,怎么知道你传入的是数据,还是地址,还是命令啊,也就无法实现正确的操作了.</p> 
   <p align="left"><strong>【</strong><strong>Nand Flash</strong><strong>只有</strong><strong>8</strong><strong>个</strong><strong>I/O</strong><strong>引脚的好处】</strong></p> 
   <p align="left">1.&nbsp;减少外围引脚：相对于并口(Parellel)的Nor Flash的48或52个引脚来说，的确是大大减小了引脚数目，这样封装后的芯片体积，就小很多。现在芯片在向体积更小，功能更强，功耗更低发展，减小芯片体积，就是很大的优势。同时，减少芯片接口，也意味着使用此芯片的相关的外围电路会更简化，避免了繁琐的硬件连线。</p> 
   <p align="left">2.&nbsp;提高系统的可扩展性，因为没有像其他设备一样用物理大小对应的完全数目的addr引脚，在芯片内部换了芯片的大小等的改动，对于用全部的地址addr的引脚，那么就会引起这些引脚数目的增加，比如容量扩大一倍，地址空间/寻址空间扩大一倍，所以，地址线数目/addr引脚数目，就要多加一个，而对于统一用8个I/O的引脚的Nand Flash，由于对外提供的都是统一的8个引脚，内部的芯片大小的变化或者其他的变化，对于外部使用者(比如编写nand flash驱动的人)来说，不需要关心，只是保证新的芯片，还是遵循同样的接口，同样的时序，同样的命令，就可以了。这样就提高了系统的扩展性。</p> 
   <p align="left"><strong>【Nand flash的一些典型(typical)特性】</strong></p> 
   <p align="left">1.页擦除时间是200us，有些慢的有800us。</p> 
   <p align="left">2.块擦除时间是1.5ms.</p> 
   <p align="left">3.页数据读取到数据寄存器的时间一般是20us。</p> 
   <p align="left">4.串行访问（Serial access）读取一个数据的时间是25ns，而一些旧的nand flash是30ns，甚至是50ns。</p> 
   <p align="left">5.输入输出端口是地址和数据以及命令一起multiplex复用的。</p> 
   <p align="left">以前老的Nand Flash，编程/擦除时间比较短，比如K9G8G08U0M，才5K次，而后来很多6.nand flash的编程/擦除的寿命，最多允许的次数，以前的nand flash多数是10K次，也就是1万次，而现在很多新的nand flash，技术提高了，比如，Micron的MT29F1GxxABB，Numonyx的NAND04G-B2D/NAND08G-BxC，都可以达到100K，也就是10万次的编程/擦除。和之前常见的Nor Flash达到同样的使用寿命了。</p> 
   <p align="left">7.48引脚的TSOP1封装或 52引脚的ULGA封装</p> 
   <p align="left"><strong>【Nand Flash中的特殊硬件结构】</strong></p> 
   <p align="left">由于nand flash相对其他常见设备来说，比较特殊，所以，特殊的设备，也有特殊的设计，所以，有些特殊的硬件特性，就有比较解释一下：</p> 
   <p align="left">1. 页寄存器（Page Register）：由于Nand Flash读取和编程操作来说，一般最小单位是页，所以，nand flash在硬件设计时候，就考虑到这一特性，对于每一片，都有一个对应的区域，专门用于存放，将要写入到物理存储单元中去的或者刚从存储单元中读取出来的，一页的数据，这个数据缓存区，本质上就是一个buffer，但是只是名字叫法不同，datasheet里面叫做Page Register，此处翻译为页寄存器，实际理解为页缓存，更为恰当些。</p> 
   <p align="left">注意：只有写到了这个页缓存中，只有等你发了对应的编程第二阶段的确认命令0x10之后，实际的编程动作才开始，才开始把页缓存中的数据，一点点写到物理存储单元中去。</p> 
   <p align="left">所以，简单总结一下就是，对于数据的流向，实际是经过了如下步骤：</p> 
   <p align="left">&nbsp;</p> 
   <p align="left">图4 Nand Flash读写时的数据流向</p> 
   <p align="left"><strong>【Nand Flash中的坏块(Bad Block)】</strong></p> 
   <p align="left">Nand Flash中，一个块中含有1个或多个位是坏的，就成为其为坏块。</p> 
   <p align="left">坏块的稳定性是无法保证的，也就是说，不能保证你写入的数据是对的，或者写入对了，读出来也不一定对的。而正常的块，肯定是写入读出都是正常的。</p> 
   <p align="left">坏块有两种：</p> 
   <p align="left">（1）一种是出厂的时候，也就是，你买到的新的，还没用过的Nand Flash，就可以包含了坏块。此类出厂时就有的坏块，被称作factory (masked)bad block或initial bad/invalid block，在出厂之前，就会做对应的标记，标为坏块。</p> 
   <p align="left">具体标记的地方是，对于现在常见的页大小为2K的Nand Flash，是块中第一个页的oob起始位置（关于什么是页和oob，下面会有详细解释）的第1个字节（旧的小页面，pagesize是512B甚至256B的nand flash，坏块标记是第6个字节），如果不是0xFF，就说明是坏块。相对应的是，所有正常的块，好的块，里面所有数据都是0xFF的。</p> 
   <p align="left">（2）第二类叫做在使用过程中产生的，由于使用过程时间长了，在擦块除的时候，出错了，说明此块坏了，也要在程序运行过程中，发现，并且标记成坏块的。具体标记的位置，和上面一样。这类块叫做worn-out bad block。</p> 
   <p align="left">对于坏块的管理，在Linux系统中，叫做坏块管理（BBM，Bad Block Managment），对应的会有一个表去记录好块，坏块的信息，以及坏块是出厂就有的，还是后来使用产生的，这个表叫做&nbsp;<strong>坏块表（BBT，Bad Block Table）</strong>。在Linux内核MTD架构下的Nand Flash驱动，和Uboot中Nand Flash驱动中，在加载完驱动之后，如果你没有加入参数主动要求跳过坏块扫描的话，那么都会去主动扫描坏块，建立必要的BBT的，以备后面坏块管理所使用。</p> 
   <p align="left">而关于好块和坏块，Nand Flash在出厂的时候，会做出保证：</p> 
   <p align="left">1.关于好的，可以使用的块的数目达到一定的数目，比如三星的K9G8G08U0M，整个flash一共有4096个块，出厂的时候，保证好的块至少大于3996个，也就是意思是，你新买到这个型号的nand flash，最坏的可能，有3096－3996＝100个坏块。不过，事实上，现在出厂时的坏块，比较少，绝大多数，都是使用时间长了，在使用过程中出现的。</p> 
   <p align="left">2.保证第一个块是好的，并且一般相对来说比较耐用。做此保证的主要原因是，很多Nand Flash坏块管理方法中，就是将第一个块，用来存储上面提到的BBT，否则，都是出错几率一样的块，那么也就不太好管理了，连放BBT的地方，都不好找了，^_^。</p> 
   <p align="left">一般来说，不同型号的Nand Flash的数据手册中，也会提到，自己的这个nand flash，最多允许多少个坏块。就比如上面提到的，三星的K9G8G08U0M，最多有100个坏块。</p> 
   <p align="left">对于坏块的标记，本质上，也只是对应的flash上的某些字节的数据是非0xFF而已，所以，只要是数据，就是可以读取和写入的。也就意味着，可以写入其他值，也就把这个坏块标记信息破坏了。对于出厂时的坏块，一般是不建议将标记好的信息擦除掉的。</p> 
   <p align="left">uboot中有个命令是“nand scrub”就可以将块中所有的内容都擦除了，包括坏块标记，不论是出厂时的，还是后来使用过程中出现而新标记的。一般来说，不建议用这个。不过，我倒是经常用，其实也没啥大碍，呵呵。</p> 
   <p align="left">最好用“nand erase”只擦除好的块，对于已经标记坏块的块，不擦除。</p> 
   <p align="left">【nand Flash中页的访问顺序】</p> 
   <p align="left">在一个块内，对每一个页进行编程的话，必须是顺序的，而不能是随机的。比如，一个块中有128个页，那么你只能先对page0编程，再对page1编程，。。。。，而不能随机的，比如先对page3，再page1，page2.，page0，page4，.。。。</p> 
   <p align="left"><strong>【片选无关(CE don’t-care)技术】</strong></p> 
   <p align="left">很多Nand flash支持一个叫做CE don’t-care的技术，字面意思就是，不关心是否片选，</p> 
   <p align="left">那有人会问了，如果不片选，那还能对其操作吗？答案就是，这个技术，主要用在当时是不需要选中芯片却还可以继续操作的这些情况：在某些应用，比如录音，音频播放等应用，中，外部使用的微秒（us）级的时钟周期，此处假设是比较少的2us，在进行读取一页或者对页编程时，是对Nand Flash操作，这样的串行（Serial Access）访问的周期都是20/30/50ns，都是纳秒（ns）级的，此处假设是50ns，当你已经发了对应的读或写的命令之后，接下来只是需要Nand Flash内部去自己操作，将数据读取除了或写入进去到内部的数据寄存器中而已，此处，如果可以把片选取消，CE#是低电平有效，取消片选就是拉高电平，这样会在下一个外部命令发送过来之前，即微秒量级的时间里面，即2us－50ns≈2us，这段时间的取消片选，可以降低很少的系统功耗，但是多次的操作，就可以在很大程度上降低整体的功耗了。</p> 
   <p align="left">总结起来简单解释就是：由于某些外部应用的频率比较低，而Nand Flash内部操作速度比较快，所以具体读写操作的大部分时间里面，都是在等待外部命令的输入，同时却选中芯片，产生了多余的功耗，此“不关心片选”技术，就是在Nand Flash的内部的相对快速的操作（读或写）完成之后，就取消片选，以节省系统功耗。待下次外部命令/数据/地址输入来的时候，再选中芯片，即可正常继续操作了。这样，整体上，就可以大大降低系统功耗了。</p> 
   <p align="left">注:Nand Flash的片选与否，功耗差别会有很大。如果数据没有记错的话，我之前遇到我们系统里面的nand flash的片选，大概有5个mA的电流输出呢，要知道，整个系统优化之后的待机功耗，也才10个mA左右的。</p> 
   <p align="left"><strong>【带EDC的拷回操作以及Sector的定义（Copy-Back Operation with EDC &amp; Sector Definition for EDC）】</strong></p> 
   <p align="left">Copy-Back功能，简单的说就是，将一个页的数据，拷贝到另一个页。</p> 
   <p align="left">如果没有Copy-Back功能，那么正常的做法就是，先要将那个页的数据拷贝出来放到内存的数据buffer中，读出来之后，再用写命令将这页的数据，写到新的页里面。</p> 
   <p align="left">而<strong>Copy-Back</strong><strong>功能</strong>的好处在于，不需要用到外部的存储空间，不需要读出来放到外部的buffer里面，而是可以直接读取数据到内部的页寄存器（page register）然后写到新的页里面去。而且，为了保证数据的正确，要硬件支持EDC（Error Detection Code）的，否则，在数据的拷贝过程中，可能会出现错误，并且拷贝次数多了，可能会累积更多错误。</p> 
   <p align="left">而对于错误检测来说，硬件一般支持的是512字节数据，对应有16字节用来存放校验产生的ECC数值，而这512字节一般叫做一个扇区。对于2K＋64字节大小的页来说，按照512字节分，分别叫做A，B，C，D区，而后面的64字节的oob区域，按照16字节一个区，分别叫做E，F，G，H区，对应存放A，B，C，D数据区的ECC的值。</p> 
   <p align="left">总结：</p> 
   <p align="left">512+16</p> 
   <p align="left">2K +64 ： A B C D - E F G H区</p> 
   <p align="left">Copy-Back编程的主要作用在于，去掉了数据串行读取出来，再串行写入进去的时间，所以，这部分操作，是比较耗时的，所以此技术可以提高编程效率，提高系统整体性能。</p> 
   <p align="left"><strong>【多片同时编程(Simultaneously Program Multi Plane)】</strong></p> 
   <p align="left">对于有些新出的Nand Flash，支持同时对多个片进行编程，比如上面提到的三星的K9K8G08U0A，内部包含4片(Plane)，分别叫做Plane0，Plane1，Plane2，Plane3。.由于硬件上，对于每一个Plane，都有对应的大小是2048+64=2112字节的页寄存器（Page Register），使得同时支持多个Plane编程成为可能。K9K8G08U0A支持同时对2个Plane进行编程。不过要注意的是，只能对Plane0和Plane1或者Plane2和Plane3，同时编程，而不支持Plane0和Plane2同时编程。</p> 
   <p align="left">【交错页编程（Interleave Page Program）】</p> 
   <p align="left">多片同时编程，是针对一个chip里面的多个Plane来说的，</p> 
   <p align="left">而此处的交错页编程，是指<strong>对多个chip而言</strong>的。</p> 
   <p align="left">可以先对一个chip，假设叫chip1，里面的一页进行编程，然后此时，chip1内部就开始将数据一点点写到页里面，就出于忙的状态了，而此时可以利用这个时间，对出于就绪状态的chip2，也进行页编程，发送对应的命令后，chip2内部也就开始慢慢的写数据到存储单元里面去了，也出于忙的状态了。此时，再去检查chip1，如果编程完成了，就可以开始下一页的编程了，然后发完命令后，就让其内部慢慢的编程吧，再去检查chip2，如果也是编程完了，也就可以进行接下来的其他页的编程了。如此，交互操作chip1和chip2，就可以有效地利用时间，使得整体编程效率提高近2倍，大大提高nand flash的编程/擦写速度了。</p> 
   <p align="left">【随机输出页内数据（Random Data Output In a Page）】</p> 
   <p align="left">在介绍此特性之前，先要说说，与Random Data Output In a Page相对应的是，普通的，正常的，sequential data output in a page。</p> 
   <p align="left">正常情况下，我们读取数据，都是先发读命令，然后等待数据从存储单元到内部的页数据寄存器中后，我们通过不断地将RE#(Read Enale，低电平有效)置低，然后从我们开始传入的列的起始地址，一点点读出我们要的数据，直到页的末尾，当然有可能还没到页地址的末尾，就不再读了。所谓的顺序（sequential）读取也就是，根据你之前发送的列地址的起始地址开始，每读一个字节的数据出来，内部的数据指针就加1，移到下个字节的地址，然后你再读下一个字节数据，就可以读出来你要的数据了，直到读取全部的数据出来为止。</p> 
   <p align="left">而此处的随机（random）读取，就是在你正常的顺序读取的过程中，</p> 
   <p align="left">先发一个随机读取的开始命令0x05命令，</p> 
   <p align="left">再传入你要将内部那个数据指针定位到具体什么地址，也就是2个cycle的列地址，</p> 
   <p align="left">然后再发随机读取结束命令0xE0，</p> 
   <p align="left">然后，内部那个数据地址指针，就会移动到你所制定的位置了，</p> 
   <p align="left">你接下来再读取的数据，就是从那个制定地址开始的数据了。</p> 
   <p align="left">而nand flash数据手册里面也说了，这样的随机读取，你可以多次操作，没限制的。</p> 
   <p align="left">请注意，上面你所传入的地址，都是列地址，也就是页内地址，也就是说，对于页大小为2K的nand flash来说，所传入的地址，应该是小于2048+64＝2112的。</p> 
   <p align="left">不过，实际在nand flash的使用中，好像这种用法很少的。绝大多数，都是顺序读取数据。</p> 
   <p align="left">【页编程（写操作）】</p> 
   <p align="left">Nand flash的写操作叫做编程Program，编程，一般情况下，是以页为单位的。</p> 
   <p align="left">有的Nand Flash，比如K9K8G08U0A，支持部分页编程，但是有一些限制：在同一个页内的，连续的部分页的编程，不能超过4次。一般情况下，很少使用到部分页编程，都是以页为单位进行编程操作的。</p> 
   <p align="left">一个操作，用两个命令去实现，看起来是多余，效率不高，但是实际上，有其特殊考虑，</p> 
   <p align="left">至少对于块擦除来说，开始的命令0x60是擦除设置命令(erase setup comman)，然后传入要擦除的块地址，然后再传入擦除确认命令（erase confirm command）0xD0，以开始擦除的操作。</p> 
   <p align="left">这种，分两步：开始设置，最后确认的命令方式，是为了避免由于外部由于无意的/未预料而产生的噪音，比如，，此时，即使被nand flash误认为是擦除操作，但是没有之后的确认操作0xD0，nand flash就不会去擦除数据，这样使得数据更安全，不会由于噪音而误操作。</p> 
   <p align="left">分类: Flash驱动</p> 
   <p align="left">【读（read）操作过程详解】</p> 
   <p align="left">以最简单的read操作为例，解释如何理解时序图，以及将时序图中的要求，转化为代码。</p> 
   <p align="left">解释时序图之前，让我们先要搞清楚，我们要做的事情：那就是，要从nand flash的某个页里面，读取我们要的数据。</p> 
   <p align="left">要实现此功能，会涉及到几部分的知识，至少很容易想到的就是：需要用到哪些命令，怎么发这些命令，怎么计算所需要的地址，怎么读取我们要的数据等等。</p> 
   <p align="left">下面，就一步步的解释，需要做什么，以及如何去做：</p> 
   <p align="left">1.需要使用何种命令</p> 
   <p align="left">首先，是要了解，对于读取数据，要用什么命令。</p> 
   <p align="left">下面是datasheet中的命令集合：</p> 
   <p align="left">&nbsp;</p> 
   <p align="left">图5.Nand Flash K9K8G08U0A的命令集合</p> 
   <p align="left">很容易看出，我们要读取数据，要用到Read命令，该命令需要2个周期，第一个周期发0x00，第二个周期发0x30。</p> 
   <p align="left">2.发送命令前的准备工作以及时序图各个信号的具体含义</p> 
   <p align="left">知道了用何命令后，再去了解如何发送这些命令。</p> 
   <p align="left">[小常识]</p> 
   <p align="left">在开始解释前，多罗嗦一下”使能”这个词，以便有些读者和我以前一样，在听这类虽然对于某些专业人士说是属于最基本的词汇了，但是对于初次接触，或者接触不多的人来说，听多了，容易被搞得一头雾水：使能（Enable），是指使其（某个信号）有效，使其生效的意思，“使其”“能够”怎么怎么样。。。。比如，上面图中的CLE线号，是高电平有效，如果此时将其设为高电平，我们就叫做，将CLE使能，也就是使其生效的意思。</p> 
   <p align="left">&nbsp;</p> 
   <p align="left">图6.Nand Flash数据读取操作的时序图</p> 
   <p align="left">注：此图来自三星的型号K9K8G08U0A的nand flash的数据手册(datasheet)。</p> 
   <p align="left">我们来一起看看，我在图6中的特意标注的①边上的黄色竖线。</p> 
   <p align="left">黄色竖线所处的时刻，是在发送读操作的第一个周期的命令0x00之前的那一刻。</p> 
   <p align="left">让我们看看，在那一刻，其所穿过好几行都对应什么值，以及进一步理解，为何要那个值。</p> 
   <p align="left"><strong>（1）</strong>黄色竖线穿过的第一行，是CLE。还记得前面介绍命令所存使能（CLE）那个引脚吧？CLE，将CLE置1，就说明你将要通过I/O复用端口发送进入Nand Flash的，是命令，而不是地址或者其他类型的数据。只有这样将CLE置1，使其有效，才能去通知了内部硬件逻辑，你接下来将收到的是命令，内部硬件逻辑，才会将受到的命令，放到命令寄存器中，才能实现后面正确的操作，否则，不去将CLE置1使其有效，硬件会无所适从，不知道你传入的到底是数据还是命令了。</p> 
   <p align="left"><strong>（2）</strong>而第二行，是CE#，那一刻的值是0。这个道理很简单，你既然要向Nand Flash发命令，那么先要选中它，所以，要保证CE#为低电平，使其有效，也就是片选有效。</p> 
   <p align="left"><strong>（3）</strong>第三行是WE#，意思是写使能。因为接下来是往nand Flash里面写命令，所以，要使得WE#有效，所以设为低电平。</p> 
   <p align="left"><strong>（4）</strong>第四行，是ALE是低电平，而ALE是高电平有效，此时意思就是使其无效。而对应地，前面介绍的，使CLE有效，因为将要数据的是命令，而不是地址。如果在其他某些场合，比如接下来的要输入地址的时候，就要使其有效，而使CLE无效了。</p> 
   <p align="left"><strong>（5）</strong>第五行，RE#，此时是高电平，无效。可以看到，知道后面低6阶段，才变成低电平，才有效，因为那时候，要发生读取命令，去读取数据。</p> 
   <p align="left"><strong>（6）</strong>第六行，就是我们重点要介绍的，复用的输入输出I/O端口了，此刻，还没有输入数据，接下来，在不同的阶段，会输入或输出不同的数据/地址。</p> 
   <p align="left"><strong>（7）</strong>第七行，R/B#,高电平，表示R（Ready）/就绪，因为到了后面的第5阶段，硬件内部，在第四阶段，接受了外界的读取命令后，把该页的数据一点点送到页寄存器中，这段时间，属于系统在忙着干活，属于忙的阶段，所以，R/B#才变成低，表示Busy忙的状态的。</p> 
   <p align="left">介绍了时刻①的各个信号的值，以及为何是这个值之后，相信，后面的各个时刻，对应的不同信号的各个值，大家就会自己慢慢分析了，也就容易理解具体的操作顺序和原理了。</p> 
   <p align="left">3.如何计算出，我们要传入的地址</p> 
   <p align="left">在介绍具体读取数据的详细流程之前，还要做一件事，那就是，先要搞懂我们要访问的地址，以及这些地址，如何分解后，一点点传入进去，使得硬件能识别才行。</p> 
   <p align="left">此处还是以K9K8G08U0A为例，此nand flash，一共有8192个块，每个块内有64页，每个页是2K+64 Bytes，假设，我们要访问其中的第7000个块中的第25页中的1208字节处的地址，此时，我们就要先把具体的地址算出来：</p> 
   <p align="left">物理地址=块大小×块号+页大小×页号+页内地址=7000×128K+64×2K+1208=0x36B204B8,接下来，我们就看看，怎么才能把这个实际的物理地址，转化为nand Flash所要求的格式。</p> 
   <p align="left">在解释地址组成之前，先要来看看其datasheet中关于地址周期的介绍：</p> 
   <p align="left">&nbsp;</p> 
   <p align="left">图7 Nand Flash的地址周期组成</p> 
   <p align="left">结合图7和图5中的2，3阶段，我们可以看出，此nand flash地址周期共有5个，2个列(Column)周期，3个行（Row）周期。</p> 
   <p align="left">而对于对应地，我们可以看出，实际上，</p> 
   <p align="left">列地址A0~A10，就是页内地址，地址范围是从0到2047，而对出的A11，理论上可以表示2048～4095，但是实际上，我们最多也只用到了2048～2112，用于表示页内的oob区域，其大小是64字节。</p> 
   <p align="left">A12～A30，称作页号，页的号码，可以定位到具体是哪一个页。</p> 
   <p align="left">而其中，A18～A30，表示对应的块号，即属于哪个块。</p> 
   <p align="left">// 可见：地址的传输顺序是是 页内地址，页号，块号。 从小到大。</p> 
   <p align="left">简单解释完了地址组成，那么就很容易分析上面例子中的地址了：</p> 
   <p align="left">0x36B204B8 =&nbsp;0011&nbsp;0110 1011&nbsp;0010 0000&nbsp;0100&nbsp;1011 1000，分别分配到5个地址周期就是：</p> 
   <p align="left">1st 周期，A7～A0 ：1011 1000&nbsp;= 0x B8</p> 
   <p align="left">2nd周期，A11～A8 ：0000&nbsp;0100&nbsp;= 0x04</p> 
   <p align="left">3rd周期，A19～A12 ：0010 0000&nbsp;= 0x20</p> 
   <p align="left">4th周期，A27～A20 ：0110 1011&nbsp;= 0x6B</p> 
   <p align="left">5th周期，A30～A28 ：0000&nbsp;0011&nbsp;= 0x03</p> 
   <p align="left">注意，与图7中对应的，*L，意思是低电平，由于未用到那些位，datasheet中强制要求设为0，所以，才有上面的2nd周期中的高4位是0000.其他的A30之后的位也是类似原理，都是0。</p> 
   <p align="left">因此，接下来要介绍的，我们要访问第7000个块中的第25页中的1208字节处的话，所要传入的地址就是分5个周期，分别传入两个列地址的：0xB8，0x04，然后再传3个行地址的：0x20，0x6B，0x03，这样硬件才能识别。</p> 
   <p align="left">4.读操作过程的解释</p> 
   <p align="left">准备工作终于完了，下面就可以开始解释说明，对于读操作的，上面图中标出来的，1-6个阶段，具体是什么含义。</p> 
   <p align="left">（1） 操作准备阶段：此处是读（Read）操作，所以，先发一个图5中读命令的第一个阶段的0x00,表示，让硬件先准备一下，接下来的操作是读。</p> 
   <p align="left">（2） 发送两个周期的列地址。也就是页内地址，表示，我要从一个页的什么位置开始读取数据。</p> 
   <p align="left">（3） 接下来再传入三个行地址。对应的也就是页号。</p> 
   <p align="left">（4） 然后再发一个读操作的第二个周期的命令0x30。接下来，就是硬件内部自己的事情了。</p> 
   <p align="left">（5） Nand Flash内部硬件逻辑，负责去按照你的要求，根据传入的地址，找到哪个块中的哪个页，然后把整个这一页的数据，都一点点搬运到页缓存中去。而在此期间，你所能做的事，也就只需要去读取状态寄存器，看看对应的位的值，也就是R/B#那一位，是1还是0，0的话，就表示，系统是busy，仍在”忙“（着读取数据），如果是1，就说系统活干完了，忙清了，已经把整个页的数据都搬运到页缓存里去了，你可以接下来读取你要的数据了。</p> 
   <p align="left">对于这里。估计有人会问了，这一个页一共2048+64字节，如果我传入的页内地址，就像上面给的1028一类的值，只是想读取1028到2011这部分数据，而不是页开始的0地址整个页的数据，那么内部硬件却读取整个页的数据出来，岂不是很浪费吗？答案是，的确很浪费，效率看起来不高，但是实际就是这么做的，而且本身读取整个页的数据，相对时间并不长，而且读出来之后，内部数据指针会定位到你刚才所制定的1208的那个位置。</p> 
   <p align="left">（6） 接下来，就是你“窃取“系统忙了半天之后的劳动成果的时候了，呵呵。通过先去Nand Flash的控制器中的数据寄存器中写入你要读取多少个字节(byte)/字(word)，然后就可以去Nand Flash的控制器的FIFO中，一点点读取你要的数据了。</p> 
   <p align="left">至此，整个Nand Flash的读操作就完成了。</p> 
   <p align="left">对于其他操作，可以根据我上面的分析，一点点自己去看datasheet，根据里面的时序图去分析具体的操作过程，然后对照代码，会更加清楚具体是如何实现的。</p> 
   <p align="left"><strong>【Flash的类型】</strong></p> 
   <p align="left">Flash的类型主要分两种，nand flash和nor flash。</p> 
   <p align="left">除了网上最流行的这个解释之外：</p> 
   <p align="left">NAND和NOR的比较</p> 
   <p align="left">再多说几句：</p> 
   <p align="left">1.nor的成本相对高，具体读写数据时候，不容易出错。总体上，比较适合应用于存储少量的代码。</p> 
   <p align="left">2.Nand flash相对成本低。使用中数据读写容易出错，所以一般都需要有对应的软件或者硬件的数据校验算法，统称为ECC。由于相对来说，容量大，价格便宜，因此适合用来存储大量的数据。其在嵌入式系统中的作用，相当于PC上的硬盘，用于存储大量数据。</p> 
   <p align="left">所以，一个常见的应用组合就是，用小容量的Nor Flash存储启动代码，比如uboot，系统启动后,初始化对应的硬件，包括SDRAM等，然后将Nand Flash上的Linux 内核读取到内存中，做好该做的事情后，就跳转到SDRAM中去执行内核了，然后内核解压（如果是压缩内核的话，否则就直接运行了）后，开始运行，在Linux内核启动最后，去Nand Flash上，挂载根文件，比如jffs2，yaffs2等，挂载完成，运行初始化脚本，启动consle交互，才运行你通过console和内核交互。至此完成整个系统启动过程。</p> 
   <p align="left">而Nor Flash存放的是Uboot，Nand Flash存放的是Linux的内核镜像和根文件系统，以及余下的空间分成一个数据区。</p> 
   <p align="left">Nor flash，有类似于dram之类的地址总线，因此可以直接和CPU相连，CPU可以直接通过地址总线对nor flash进行访问，而nand flash没有这类的总线，只有IO接口，只能通过IO接口发送命令和地址，对nand flash内部数据进行访问。相比之下，nor flash就像是并行访问，nand flash就是串行访问，所以相对来说，前者的速度更快些。</p> 
   <p align="left">但是由于物理制程/制造方面的原因，导致nor 和nand在一些具体操作方面的特性不同：</p> 
   <p align="left"><br></p> 
   <p align="left">表3 Nand Flash 和 Nor Flash的区别</p> 
   <p align="left">1. 理论上是可以的，而且也是有人验证过可以的，只不过由于nand flash的物理特性，不能完全保证所读取的数据/代码是正确的，实际上，很少这么用而已。因为，如果真是要用到nand flash做XIP，那么除了读出速度慢之外，还要保证有数据的校验，以保证读出来的，将要执行的代码/数据，是正确的。否则，系统很容易就跑飞了。。。</p> 
   <p align="left">2. 芯片内执行(XIP, eXecute In Place):</p> 
   <p align="left"><a href="http://hi.baidu.com/serial_story/blog/item/adb20a2a3f8ffe3c5243c1df.html" rel="nofollow">http://hi.baidu.com/serial_story/blog/item/adb20a2a3f8ffe3c5243c1df.html</a></p> 
   <p align="left">【Nand Flash的种类】</p> 
   <p align="left">具体再分，又可以分为</p> 
   <p align="left">1)Bare NAND chips：裸片，单独的nand 芯片</p> 
   <p align="left">2)SmartMediaCards： =裸片+一层薄塑料，常用于数码相机和MP3播放器中。之所以称smart，是由于其软件smart，而不是硬件本身有啥smart之处。^_^</p> 
   <p align="left">3)DiskOnChip：裸片+glue logic，glue logic=硬件ECC产生器+用于静态的nand 芯片控制的寄存器+直接访问一小片地址窗口，那块地址中包含了引导代码的stub桩，其可以从nand flash中拷贝真正的引导代码。</p> 
   <p align="left">【spare area/oob】</p> 
   <p align="left">Nand由于最初硬件设计时候考虑到，额外的错误校验等需要空间，专门对应每个页，额外设计了叫做spare area空区域，在其他地方，比如jffs2文件系统中，也叫做oob（out of band）数据。</p> 
   <p align="left">其具体用途，总结起来有：</p> 
   <p align="left">1. 标记是否是坏快</p> 
   <p align="left">2. 存储ECC数据</p> 
   <p align="left">3. 存储一些和文件系统相关的数据，如jffs2就会用到这些空间存储一些特定信息，yaffs2文件系统，会在oob中，存放很多和自己文件系统相关的信息。</p> 
   <p align="left"><strong>【内存技术设备，MTD（Memory Technology Device）】</strong></p> 
   <p align="left">MTD，是Linux的存储设备中的一个子系统。其设计此系统的目的是，对于内存类的设备，提供一个抽象层，一个接口，使得对于硬件驱动设计者来说，可以尽量少的去关心存储格式，比如FTL，FFS2等，而只需要去提供最简单的底层硬件设备的读/写/擦除函数就可以了。而对于数据对于上层使用者来说是如何表示的，硬件驱动设计者可以不关心，而MTD存储设备子系统都帮你做好了。</p> 
   <p align="left">对于MTD字系统的好处，简单解释就是，他帮助你实现了，很多对于以前或者其他系统来说，本来也是你驱动设计者要去实现的很多功能。换句话说，有了MTD，使得你设计Nand Flash的驱动，所要做的事情，要少很多很多，因为大部分工作，都由MTD帮你做好了。</p> 
   <p align="left">当然，这个好处的一个“副作用”就是，使得我们不了解的人去理解整个Linux驱动架构，以及MTD，变得更加复杂。但是，总的说，觉得是利远远大于弊，否则，就不仅需要你理解，而且还是做更多的工作，实现更多的功能了。</p> 
   <p align="left"><br> 此外，还有一个重要的原因，那就是，前面提到的nand flash和普通硬盘等设备的特殊性：</p> 
   <p align="left">有限的通过出复用来实现输入输出命令和地址/数据等的IO接口，最小单位是页而不是常见的bit，写前需擦除等，导致了这类设备，不能像平常对待硬盘等操作一样去操作，只能采取一些特殊方法，这就诞生了MTD设备的统一抽象层。</p> 
   <p align="left">MTD，将nand flash，nor flash和其他类型的flash等设备，统一抽象成MTD设备来管理，根据这些设备的特点，上层实现了常见的操作函数封装，底层具体的内部实现，就需要驱动设计者自己来实现了。具体的内部硬件设备的读/写/擦除函数，那就是你必须实现的了。</p> 
   <p align="left">&nbsp;</p> 
   <p align="left">表4.MTD设备和硬盘设备之间的区别</p> 
   <p align="left"><br> ==========<br> 多说一句，关于MTD更多的内容，感兴趣的，去附录中的MTD的主页去看。</p> 
   <p align="left">关于mtd设备驱动，感兴趣的可以去参考</p> 
   <p align="left"><a href="http://www.cnitblog.com/luofuchong/archive/2007/08/31/32682.html" rel="nofollow">MTD原始设备与FLASH硬件驱动的对话</a></p> 
   <p align="left"><a href="http://www.cnitblog.com/luofuchong/archive/2007/09/04/32939.html" rel="nofollow">MTD原始设备与FLASH硬件驱动的对话-续</a></p> 
   <p align="left">那里，算是比较详细地介绍了整个流程，方便大家理解整个mtd框架和nand flash驱动。</p> 
   <p align="left"><strong>【Nand flash驱动工作原理】</strong></p> 
   <p align="left">在介绍具体如何写Nand Flash驱动之前，我们先要了解，大概的，整个系统，和Nand Flash相关的部分的驱动工作流程，这样，对于后面的驱动实现，才能更加清楚机制，才更容易实现，否则就是，即使写完了代码，也还是没搞懂系统是如何工作的了。</p> 
   <p align="left">让我们以最常见的，Linux内核中已经有的三星的Nand Flash驱动，来解释Nand Flash驱动具体流程和原理。</p> 
   <p align="left">此处是参考2.6.29版本的Linux源码中的\drivers\mtd\nand\s3c2410.c，以2410为例。</p> 
   <p align="left">1. 在nand flash驱动加载后，第一步，调用对应的init函数 ---- s3c2410_nand_init: 去将nand flash驱动注册到Linux驱动框架中。</p> 
   <p align="left">2. 驱动本身真正的开始，是从probe函数： s3c2410_nand_probe-&gt;s3c24xx_nand_probe,<br> 在probe过程中：<br> clk_enable //打开nand flash控制器的clock时钟，<br> request_mem_region //去申请驱动所需要的一些内存等相关资源。<br> s3c2410_nand_inithw //去初始化硬件相关的部分，主要是关于时钟频率的计算，以及启用nand flash控制器，使得硬件初始化好了，后面才能正常工作。</p> 
   <p align="left">3. 需要多解释一下的，是这部分代码：</p> 
   <p align="left">for (setno = 0; setno &lt; nr_sets; setno++, nmtd++) {<br> pr_debug("initialising set %d (%p, info %p)\n", setno, nmtd, info);</p> 
   <p align="left">/*调用init chip去挂载你的nand驱动的底层函数到"nand flash的结构体"中，以及设置对应的"ecc mode"，挂载ecc相关的函数&nbsp;*/<br> s3c2410_nand_init_chip(info, nmtd, sets);</p> 
   <p align="left">/*&nbsp;scan_ident，扫描nand 设备，设置nand flash的默认函数，获得物理设备的具体型号以及对应各个特性参数，这部分算出来的一些值，对于nand flash来说，是最主要的参数，比如nand flash的芯片的大小，块大小，页大小等。&nbsp;*/<br> nmtd-&gt;scan_res = nand_scan_ident(&amp;nmtd-&gt;mtd, (sets) ? sets-&gt;nr_chips : 1);</p> 
   <p align="left">if (nmtd-&gt;scan_res == 0) {<br> s3c2410_nand_update_chip(info, nmtd);</p> 
   <p align="left">/*扫描的后一阶段，经过前面的scan_ident，我们已经获得对应nand flash的硬件的各个参数，<br> *然后就可以在scan tail中，根据这些参数，去设置其他一些重要参数，尤其是ecc的layout，即ecc是如何在oob中摆放的，<br> *最后，再去进行一些初始化操作，主要是根据你的驱动，如果没有实现一些函数的话，那么就用系统默认的。&nbsp;*/<br> nand_scan_tail(&amp;nmtd-&gt;mtd);</p> 
   <p align="left">/*add partion，根据你的nand flash的分区设置，去分区&nbsp;*/<br> s3c2410_nand_add_partition(info, nmtd, sets);<br> }<br> if (sets != NULL)<br> sets++;<br> }</p> 
   <p align="left">4. 等所有的参数都计算好了，函数都挂载完毕，系统就可以正常工作了。</p> 
   <p align="left">上层访问你的nand falsh中的数据的时候，通过MTD层，一层层调用，最后调用到你所实现的那些底层访问硬件数据/缓存的函数中。</p> 
   <p align="left"><br><strong>【Linux下nand flash驱动编写步骤简介】</strong></p> 
   <p align="left">关于上面提到的，在nand_scan_tail的时候，系统会根据你的驱动，如果没有实现一些函数的话，那么就用系统默认的。如果实现了自己的函数，就用你的。<br> "那么到底我要实现哪些函数呢，而又有哪些是可以不实现，用系统默认的就可以了呢。"<br> 此问题的，就是我们下面要介绍的，也就是，你要实现的，你的驱动最少要做哪些工作，才能使整个nand flash工作起来。</p> 
   <p align="left"><strong>1.&nbsp;</strong>对于驱动框架部分</p> 
   <p align="left">其实，要了解，关于驱动框架部分，你所要做的事情的话，只要看看三星的整个nand flash驱动中的这个结构体，就差不多了：</p> 
   <p align="left">static struct platform_driver s3c2410_nand_driver = {<br> .probe = s3c2410_nand_probe,<br> .remove = s3c2410_nand_remove,<br> .suspend = s3c24xx_nand_suspend,<br> .resume = s3c24xx_nand_resume,<br> .driver = {<br> .name = "s3c2410-nand",<br> .owner = THIS_MODULE,<br> },<br> };</p> 
   <p align="left">对于上面这个结构体，没多少要解释的。从名字，就能看出来：<br> （1）probe就是系统“探测”，就是前面解释的整个过程，这个过程中的多数步骤，都是和你自己的nand flash相关的，尤其是那些硬件初始化部分，是你必须要自己实现的。<br> （2）remove，就是和probe对应的，“反初始化”相关的动作。主要是释放系统相关资源和关闭硬件的时钟等常见操作了。<br> （3）suspend和resume，对于很多没用到电源管理的情况下，至少对于我们刚开始写基本的驱动的时候，可以不用关心，放个空函数即可。</p> 
   <p align="left"><br><strong>2.</strong>&nbsp;对于nand flash底层操作实现部分</p> 
   <p align="left">而对于底层硬件操作的有些函数，总体上说，都可以在上面提到的s3c2410_nand_init_chip中找到：</p> 
   <p align="left">static void&nbsp;<strong>s3c2410_nand_init_chip</strong>(struct s3c2410_nand_info *info,<br> struct s3c2410_nand_mtd *nmtd, //主要是完善该结构体<br> struct s3c2410_nand_set *set)<br> {</p> 
   <p align="left">struct nand_chip *chip = &amp;nmtd-&gt;chip;<br> void __iomem *regs = info-&gt;regs;</p> 
   <p align="left">chip-&gt;write_buf = s3c2410_nand_write_buf;<br> chip-&gt;read_buf = s3c2410_nand_read_buf;<br> chip-&gt;select_chip = s3c2410_nand_select_chip;<br> chip-&gt;chip_delay = 50;<br> chip-&gt;priv = nmtd;<br> chip-&gt;options = 0;<br> chip-&gt;controller = &amp;info-&gt;controller;</p> 
   <p align="left">switch (info-&gt;cpu_type) {<br> case TYPE_S3C2410:</p> 
   <p align="left">/* nand flash控制器中，一般都有对应的数据寄存器，用于给你往里面写数据，表示将要读取或写入多少个字节(byte,u8)/字(word,u32) ，所以，此处，你要给出地址，以便后面的操作所使用 */</p> 
   <p align="left">chip-&gt;IO_ADDR_W = regs + S3C2410_NFDATA;<br> info-&gt;sel_reg = regs + S3C2410_NFCONF;<br> info-&gt;sel_bit = S3C2410_NFCONF_nFCE;<br> chip-&gt;cmd_ctrl = s3c2410_nand_hwcontrol;<br> chip-&gt;dev_ready = s3c2410_nand_devready;</p> 
   <p align="left">break;</p> 
   <p align="left">。。。。。。</p> 
   <p align="left">}</p> 
   <p align="left">chip-&gt;IO_ADDR_R = chip-&gt;IO_ADDR_W;</p> 
   <p align="left">nmtd-&gt;info = info;<br> nmtd-&gt;mtd.priv = chip;<br> nmtd-&gt;mtd.owner = THIS_MODULE;<br> nmtd-&gt;set = set;</p> 
   <p align="left">if (hardware_ecc) {<br> chip-&gt;ecc.calculate = s3c2410_nand_calculate_ecc;<br> chip-&gt;ecc.correct = s3c2410_nand_correct_data;</p> 
   <p align="left">/* 此处，多数情况下，你所用的Nand Flash的控制器，都是支持硬件ECC的，所以，此处设置硬件ECC(HW_ECC) ，也是充分利用硬件的特性，<br> * 而如果此处不用硬件去做ECC话，那么下面也会去设置成NAND_ECC_SOFT，系统会用默认的软件去做ECC校验，相比之下，比硬件ECC的效率就低很多，而你的nand flash的读写，也会相应地要慢不少 */</p> 
   <p align="left">chip-&gt;ecc.mode = NAND_ECC_HW;&nbsp;//设置成了硬件方式校验ecc</p> 
   <p align="left">switch (info-&gt;cpu_type) {</p> 
   <p align="left">case TYPE_S3C2410:</p> 
   <p align="left">chip-&gt;ecc.hwctl = s3c2410_nand_enable_hwecc;<br> chip-&gt;ecc.calculate = s3c2410_nand_calculate_ecc;</p> 
   <p align="left">break;<br> 。。。。。<br> }</p> 
   <p align="left">} else {<br> chip-&gt;ecc.mode = NAND_ECC_SOFT;&nbsp;//也就是说，怎么搞也得校验了<br> }</p> 
   <p align="left">if (set-&gt;ecc_layout != NULL)<br> chip-&gt;ecc.layout = set-&gt;ecc_layout;</p> 
   <p align="left">if (set-&gt;disable_ecc)<br> chip-&gt;ecc.mode = NAND_ECC_NONE;<br> }</p> 
   <p align="left">而我们要实现的底层函数，也就是上面蓝色标出来的一些函数而已：</p> 
   <p align="left">（1）<strong>s3c2410_nand_write_buf</strong>和&nbsp;<strong>s3c2410_nand_read_buf</strong>：这是两个最基本的操作函数，其功能，就是往你的nand flash的控制器中的FIFO读写数据。一般情况下，是MTD上层的操作，比如要读取一页的数据，那么在发送完相关的读命令和等待时间之后，就会调用到你底层的read_buf，去nand Flash的FIFO中，一点点把我们要的数据，读取出来，放到我们制定的内存的缓存中去。写操作也是类似，将我们内存中的数据，写到Nand Flash的FIFO中去。<br> （2）<strong>s3c2410_nand_select_chip</strong>&nbsp;： 实现Nand Flash的片选。<br> （3）<strong>s3c2410_nand_hwcontrol</strong>： 给底层发送命令或地址，或者设置具体操作的模式，都是通过此函数。<br> （4）<strong>s3c2410_nand_devready</strong>： Nand Flash的一些操作，比如读一页数据，写入（编程）一页数据，擦除一个块，都是需要一定时间的，在命令发送完成后，就是硬件开始忙着工作的时候了，而硬件什么时候完成这些操作，什么时候不忙了，变就绪了，就是通过这个函数去检查状态的。一般具体实现都是去读硬件的一个状态寄存器，其中某一位是否是1，对应着是出于“就绪/不忙”还是“忙”的状态。这个寄存器，也就是我们前面分析时序图中的R/B#。<br> （5）<strong>s3c2410_nand_calculate_ecc</strong>：如果是上面提到的硬件ECC的话，就不用我们用软件去实现校验算法了，而是直接去读取硬件产生的ECC数值就可以了。<br> （6）<strong>s3c2410_nand_correct_data</strong>： 当实际操作过程中，读取出来的数据所对应的硬件或软件计算出来的ECC，和从oob中读出来的ECC不一样的时候，就是说明数据有误了，就需要调用此函数去纠正错误。对于现在SLC常见的ECC算法来说，可以发现2位，纠正1位。如果错误大于1位，那么就无法纠正回来了。一般情况下，出错超过1位的，好像几率不大。至少我看到的不是很大。更复杂的情况和更加注重数据安全的情况下，一般是需要另外实现更高效和检错和纠错能力更强的ECC算法的。<br> （7）<strong>s3c2410_nand_enable_hwecc</strong>： 在硬件支持的前提下，前面设置了硬件ECC的话，要实现这个函数，用于每次在读写操作前，通过设置对应的硬件寄存器的某些位，使得启用硬件ECC，这样在读写操作完成后，就可以去读取硬件校验产生出来的ECC数值了。</p> 
   <p align="left">当然，除了这些你必须实现的函数之外，在你更加熟悉整个框架之后，你可以根据你自己的nand flash的特点，去实现其他一些原先用系统默认但是效率不高的函数，而用自己的更高效率的函数替代他们，以提升你的nand flash的整体性能和效率。</p> 
   <p>&nbsp;</p> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
