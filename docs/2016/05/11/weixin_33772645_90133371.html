<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>linux下bus、devices和platform的基础模型 【转】 « NotBeCN</title>
  <meta name="description" content="             转自：http://blog.chinaunix.net/uid-20672257-id-3147337.html    一、kobject的定义:kobject是Linux2.6引入的设备管理机制,在内核中由struct kobject结构表示,这个结构使所有设备在底层都具有统一的接口...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2016/05/11/weixin_33772645_90133371.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">linux下bus、devices和platform的基础模型 【转】</h1>
    <p class="post-meta">May 11, 2016</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p><strong><span style="color:#0000ff;">转自：<a href="http://blog.chinaunix.net/uid-20672257-id-3147337.html" rel="nofollow">http://blog.chinaunix.net/uid-20672257-id-3147337.html</a></span></strong></p> 
   <p><strong><span style="color:#0000ff;">一、kobject的定义</span></strong>:<br>kobject是Linux2.6引入的设备管理机制,在内核中由struct kobject结构表示,这个结构使所有设备在底层都具有统一的接口.kobject提供了基本的对象管理能力,是构成Linux2.6设备模型的核心结构,它与sysfs文件系统紧密联系,每个在内核中注册kobject对象都对应与sysfs文件系统中的一个目录;kobject---&gt;sysfs.dir;其结构定义为:<br>struct kobject<br>{<br>&nbsp; const char*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向设备名称的指针<br>&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name[KOBJ_NAME_LEN]; //设备名称<br>&nbsp; struct kref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kref;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //内核对象的引用计数<br>&nbsp; struct list_head&nbsp;&nbsp; entry;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //挂接到当前内核对象所在kset中的单元<br>&nbsp; struct kobject*&nbsp;&nbsp;&nbsp; parent;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向父对象的指针<br>&nbsp; struct kset*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kset;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //内核对象所属kset的指针<br>&nbsp; struct kobj_type*&nbsp; ktype;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指向内核对象类型描述符的指针<br>&nbsp; struct dentry*&nbsp;&nbsp;&nbsp;&nbsp; dentry;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //sysfs文件系统中与该内核对象对应的文件节点路径的指针<br>&nbsp; wait_queue_head_t&nbsp; poll;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //IO等待队列;<br>};<br><strong><span style="color:#0000ff;">二、kobject相关函数</span></strong>:<br>1、void kobject_init(struct kobject* kobj);<br>&nbsp;&nbsp; 该函数用于初始化kobject对象,它设置kobject对象的引用计数为1,entry字段指向自身,其所属kset对象的引用计数加1;<br>2、void kobject_cleanup(struct kobject* kobj);<br>&nbsp;&nbsp; void kobject_release(struct kref* ref);<br>&nbsp;&nbsp; 这两个函数用于清除kobject对象,当其引用计数为0时,释放对象所占用的资源;<br>3、int kobject_set_name(struct kobject* kobj, const char* format, ...);<br>&nbsp;&nbsp; 该函数用于设置指定kobject对象的名称;<br>4、const char* kobject_name(const struct kobject* kobj);<br>&nbsp;&nbsp; 该函数用于返回指定kobject的名称;<br>5、int kobject_rename(struct kobject* kobj, const char* new_name);<br>&nbsp;&nbsp; 该函数用于为指定kobject对象重命名;<br>6、struct kobject* kobject_get(struct kobject* kobj);<br>&nbsp;&nbsp; 该函数用于将kobject对象的引用计数加1,相当于申请了一个kobject对象资源,同时返回该kobject对象的指针;<br>7、void kobject_put(struct kobject* kobj);<br>&nbsp;&nbsp; 该函数用于将kobject对象的引用计数减1,相当于释放了一个kobject对象资源;当引用计数为0时,则调用kobject_release()释放该kobject对象的资源;<br>8、int kobject_add(struct kobject* kobj);<br>&nbsp;&nbsp; 该函数用于注册kobject对象,即:加入到Linux的设备层次中,它会挂接该kobject对象到kset的list链中,增加父目录各级kobject对象的引用计数,在其parent字段指向的目录下创建对应的文件节点,并启动该类型kobject对象的hotplug()函数;<br>9、void kobject_del(struct kobject* kobj);<br>&nbsp;&nbsp; 该函数与kobject_add()相反,用于注销kobject对象,即:中止该kobject对象的hotplug()函数,从Linux的设备层次中删除该kobject对象,删除该kobject对象在sysfs文件系统中对应的文件节点;<br>10、int kobject_register(struct kobject* obj);<br>&nbsp;&nbsp;&nbsp; 该函数用于注册kobject对象,它首先会调用kobject_init()初始化kobj,然后再调用kobject_add()完成该内核对象的添加;<br>11、void kobject_unregister(struct kobject* kobj);<br>&nbsp;&nbsp;&nbsp; 该函数与kobject_register()相反,用于注销kobject对象,它首先调用kobject_del()从Linux的设备层次中删除kobject对象,再调用kobject_put()减少该kobject对象的引用计数,当引用计数为0时,则释放该kobject对象的资源;<br>12、struct kobject* kobject_add_dir(struct kobject*, const char* path);<br>&nbsp;&nbsp;&nbsp; 该函数用于在sysfs文件系统中为该kobject对象创建对应的目录;<br>13、char* kobject_get_path(struct kobject* kobj);<br>&nbsp;&nbsp;&nbsp; 该函数用于返回该kobject对象在sysfs文件系统中的对应目录路径;<br><strong><span style="color:#0000ff;">三、kobject的行为</span></strong>:<br>typedef int __bitwise kobject_action_t;<br>enum kobject_action<br>{<br>&nbsp; KOBJ_ADD&nbsp;&nbsp;&nbsp;&nbsp; = (__force kobject_action_t) 0x01, //exclusive to core<br>&nbsp; KOBJ_REMOVE&nbsp; = (__force kobject_action_t) 0x02, //exclusive to core<br>&nbsp; KOBJ_CHANGE&nbsp; = (__force kobject_action_t) 0x03, //device state change<br>&nbsp; KOBJ_MOUNT&nbsp;&nbsp; = (__force kobject_action_t) 0x04, //mount event for block devices (broken)<br>&nbsp; KOBJ_UMOUNT&nbsp; = (__force kobject_action_t) 0x05, //umount event for block devices (broken)<br>&nbsp; KOBJ_OFFLINE = (__force kobject_action_t) 0x06, //device offline<br>&nbsp; KOBJ_ONLINE&nbsp; = (__force kobject_action_t) 0x07, //device online<br>};<br>该枚举类型用于定义kobject对象的状态更新消息码,也就是热插拔事件码;<br><span style="color:#ff0000;">备注</span>:struct kobject结构定义于文件include/linux/kobject.h<br><br>下面转自：<a href="http://blog.chinaunix.net/u1/57901/showart_1803248.html" rel="nofollow">http://blog.chinaunix.net/u1/57901/showart_1803248.html</a></p> 
   <div>
    在LINUX中最让人不解的大概就是/sys下面的内容了
   </div> 
   <div>
    下面首先让我们来创建一个简单的platform设备,并从这个设备的视角进行深入,在此篇文章的深入过程中,我们只看kobeject的模型我所使用的内核版本号为2.6.26,操作系统的内核版本号为2.6.27-7,暂未发现2.6.27-7与2.6.26的重大不同
   </div> 
   <div>
    首先写一个简单的模块
   </div> 
   <div>
    #include
   </div> 
   <div>
    #include
   </div> 
   <div>
    #include
   </div> 
   <div>
    static int __init test_probe(struct platform_device *pdev)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; int err = 0;
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; return err;
   </div> 
   <div>
    }
   </div> 
   <div>
    static int test_remove(struct platform_device *pdev)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; return 0;
   </div> 
   <div>
    }
   </div> 
   <div>
    static struct platform_device test_device = {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; .name = "test_ts",
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; .id = -1,
   </div> 
   <div>
    };
   </div> 
   <div>
    static struct platform_driver test_driver = {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; .probe &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= test_probe,
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; .remove &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= test_remove,
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; .driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .name &nbsp; &nbsp; &nbsp; &nbsp;= "test_ts",
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .owner &nbsp; &nbsp; &nbsp; &nbsp;= THIS_MODULE,
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; },
   </div> 
   <div>
    };
   </div> 
   <div>
    static int __devinit test_init(void)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; platform_device_register(&amp;test_device); &nbsp; &nbsp; &nbsp; &nbsp;
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; return platform_driver_register(&amp;test_driver);
   </div> 
   <div>
    }
   </div> 
   <div>
    static void __exit test_exit(void)
   </div> 
   <div>
    {
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; platform_device_unregister(&amp;test_device);
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; platform_driver_unregister(&amp;test_driver);
   </div> 
   <div>
    }
   </div> 
   <div>
    module_init(test_init);
   </div> 
   <div>
    module_exit(test_exit);
   </div> 
   <div>
    MODULE_AUTHOR("zwolf");
   </div> 
   <div>
    MODULE_DESCRIPTION("Module test");
   </div> 
   <div>
    MODULE_LICENSE("GPL");
   </div> 
   <div>
    MODULE_ALIAS("test");
   </div> 
   <div>
    接下来是makefile
   </div> 
   <div>
    #Makefile
   </div> 
   <div>
    obj-m:=test.o
   </div> 
   <div>
    KDIR:=/lib/modules/2.6.27-7-generic/build
   </div> 
   <div>
    PWD:=$(shell pwd)
   </div> 
   <div>
    default:
   </div> 
   <div>
    &nbsp; &nbsp; &nbsp; &nbsp; $(MAKE) -C $(KDIR) M=$(PWD) modules
   </div> 
   <div>
    KDIR中的目录请改为各位实际运行中的内核目录make之后进行模块的加载 sudo insmod ./test.ko
   </div> 
   <div>
    现在到sys目录中查看我们的设备是否已经加载上了
   </div> 
   <div>
    首先是/sys/bus/platform/devices/在devices下,每一个连接文件都代表了一个设备ls可看见test_ts,进入test_ts,ls可发现driver这个链接文件,ls-l查看,发现这个文件是连到/sys/bus/platform/drivers/test_ts的
   </div> 
   <div>
    这里需要说明的是连接的含义,并不是driver驱动存在于test_ts这个设备中,而是test_ts使用的驱动为/sys/bus/platform/drivers/test_ts
   </div> 
   <div>
    现在换到/sys/bus/platform/drivers这个目录下
   </div> 
   <div>
    ls查看会发现这里的文件都为目录,而非连接文件,说明这是驱动真正放置的位置
   </div> 
   <div>
    现在进入test_ts目录,然后ls,发现有一个test_ts的连接文件,ls –l查看可发现该文件连接到/sys/devices/platform/test_ts下
   </div> 
   <div>
    回到/sys/bus/platform/devices/下ls –l也会发现test_ts连接到/sys/devices/platform/test_ts
   </div> 
   <div>
    为什么test_ts这个设备放置于/sys/devices/platform下,而不是/sys/bus/platform/devices下呢
   </div> 
   <div>
    我认为和直观性有关,在sys下有这么几个目录block &nbsp;bus &nbsp;class &nbsp;dev &nbsp;devices &nbsp;firmware &nbsp;kernel &nbsp;module &nbsp;fs power&nbsp;
   </div> 
   <div>
    devices很直观的说明了设备在这个目录下
    <br>再来看组成这个目录图的核心,kobject图,我也叫他层次图
    <br>
    <a href="https://yqfile.alicdn.com/img_fd4d31232db5be1741b32944cc7fc32e.png" rel="nofollow"><img src="https://yqfile.alicdn.com/img_fd4d31232db5be1741b32944cc7fc32e.png" alt="" width="596" height="708"></a>
    <br>
    <br>
    <div>
     不看大号绿色箭头右边的内容的话是不是发现两个架构相同?
    </div> 
    <div>
     对的,kobject的层次决定了目录的结构
    </div> 
    <div>
     kobeject图很大,但也不要担心,里面的内容其实不多,基础框架涉及3个主要结构kset kobject和ktype
    </div> 
    <div>
     在说明test_ts的注册之前,先让我们看一下sys下的两个基础目录bus,devices
    </div> 
    <div>
     首先是bus
    </div> 
    <div>
     bus的注册在/drivers/base/bus.c里
    </div> 
    <div>
     int __init buses_ini&nbsp;
    </div> 
    <div>
     &nbsp;
    </div> 
    <div>
     t(void)
    </div> 
    <div>
     {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; bus_kset = kset_create_and_add("bus", &amp;bus_uevent_ops, NULL);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (!bus_kset)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; return 0;
    </div> 
    <div>
     }
    </div> 
    <div>
     先看bus_uevent_ops,这是一个uevent的操作集(我也还没清楚uevent的用途,所以uevent的内容先放着)
    </div> 
    <div>
     然后到kset_create_and_add
    </div> 
    <div>
     struct kset *kset_create_and_add(const char *name,
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct kset_uevent_ops *uevent_ops,
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct kobject *parent_kobj)
    </div> 
    <div>
     //传递进来的参数为("bus", &amp;bus_uevent_ops, NULL)
    </div> 
    <div>
     {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; struct kset *kset;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; int error;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //创建一个kset容器
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset = kset_create(name, uevent_ops, parent_kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (!kset)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //注册创建的kset容器
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; error = kset_register(kset);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (error) {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree(kset);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; }
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; return kset;
    </div> 
    <div>
     }
    </div> 
    <div>
     首先需要创建一个kset容器
    </div> 
    <div>
     static struct kset *kset_create(const char *name,
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct kset_uevent_ops *uevent_ops,
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *parent_kobj)
    </div> 
    <div>
     //传递进来的参数为("bus", &amp;bus_uevent_ops, NULL)
    </div> 
    <div>
     {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; struct kset *kset;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //为kset分配内存
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset = kzalloc(sizeof(*kset), GFP_KERNEL);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (!kset)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //设置kset中kobject的名字,这里为bus
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kobject_set_name(&amp;kset-&gt;kobj, name);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //设置uevent操作集,这里为bus_uevent_ops
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset-&gt;uevent_ops = uevent_ops;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //设置父对象,这里为NULL
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset-&gt;kobj.parent = parent_kobj;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //设置容器操作集
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset-&gt;kobj.ktype = &amp;kset_ktype;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //设置父容器
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset-&gt;kobj.kset = NULL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; return kset;
    </div> 
    <div>
     }
    </div> 
    <div>
     这里的ktype,也就是kset_ktype是一个操作集,用于为sys下文件的实时反馈做服务,例如我们cat name的时候就要通过ktype提供的show函数,具体什么怎么运用,将在后面讲解
    </div> 
    <div>
     现在回到kset_create_and_add中的kset_register,将建立好的kset添加进sys里
    </div> 
    <div>
     int kset_register(struct kset *k)
    </div> 
    <div>
     {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; int err;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (!k)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //初始化
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kset_init(k);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //添加该容器
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; err = kobject_add_internal(&amp;k-&gt;kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (err)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return err;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; return 0;
    </div> 
    <div>
     }
    </div> 
    <div>
     kset_init进行一些固定的初始化操作,里面没有我们需要关心的内容
    </div> 
    <div>
     kobject_add_internal为重要的一个函数,他对kset里kobj的从属关系进行解析,搭建正确的架构
    </div> 
    <div>
     static int kobject_add_internal(struct kobject *kobj)
    </div> 
    <div>
     {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; int error = 0;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *parent;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //检测kobj是否为空
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (!kobj)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOENT;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //检测kobj名字是否为空
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (!kobj-&gt;name || !kobj-&gt;name[0]) {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("kobject: (%p): attempted to be registered with empty "
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"name!\n", kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WARN_ON(1);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; }
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //提取父对象
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; parent = kobject_get(kobj-&gt;parent);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; /* join kset if set, use it as parent if we do not already have one */
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //父容器存在则设置父对象
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (kobj-&gt;kset) {//在bus的kset中为空,所以不会进入到下面的代码
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //检测是否已经设置父对象
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!parent)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //无则使用父容器为父对象
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //添加该kobj到父容器的链表中
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobj_kset_join(kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //设置父对象
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobj-&gt;parent = parent;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; }
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n",
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kobject_name(kobj), kobj, __func__,
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;parent ? kobject_name(parent) : "",
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : "");
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; //建立相应的目录
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; error = create_dir(kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; if (error) {
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobj_kset_leave(kobj);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobject_put(parent);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobj-&gt;parent = NULL;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error == -EEXIST)
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s failed for %s with "
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"-EEXIST, don't try to register things with "
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"the same name in the same directory.\n",
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__func__, kobject_name(kobj));
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s failed for %s (%d)\n",
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;__func__, kobject_name(kobj), error);
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dump_stack();
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; } else
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobj-&gt;state_in_sysfs = 1;
    </div> 
    <div>
     &nbsp; &nbsp; &nbsp; &nbsp; return error;
    </div> 
    <div>
     }
    </div> 
    <div>
     至此bus的目录就建立起来了
    </div> 
    <div>
     模型如下
     <br>
     <a href="https://yqfile.alicdn.com/img_93b22861f281ab5a4ee963e609dfccc0.png" rel="nofollow"><img src="https://yqfile.alicdn.com/img_93b22861f281ab5a4ee963e609dfccc0.png" alt="" width="276" height="714"></a>
     <br>
     <br>
     <div>
      接下来是devices,在/drivers/base/core.c里
     </div> 
     <div>
      int __init devices_init(void)
     </div> 
     <div>
      {
     </div> 
     <div>
      &nbsp; &nbsp; &nbsp; &nbsp; devices_kset = kset_create_and_add("devices", &amp;device_uevent_ops, NULL);
     </div> 
     <div>
      &nbsp; &nbsp; &nbsp; &nbsp; if (!devices_kset)
     </div> 
     <div>
      &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;
     </div> 
     <div>
      &nbsp; &nbsp; &nbsp; &nbsp; return 0;
     </div> 
     <div>
      }
     </div> 
     <div>
      过程和bus的注册一致,我就不复述了~
     </div> 
     <div>
      模型如下
      <br>
      <a href="https://yqfile.alicdn.com/img_3c347435785263b8c229ef184c4c3cc4.jpg" rel="nofollow"><img src="https://yqfile.alicdn.com/img_3c347435785263b8c229ef184c4c3cc4.jpg" alt="" width="498" height="457"></a>
      <br>
      <div>
       然后是platform的注册
      </div> 
      <div>
       在platform的注册中,分为两个部分,一部分是注册到devices中,另一部分是注册到bus中,代码在/drivers/base/platform.c中
      </div> 
      <div>
       int __init platform_bus_init(void)
      </div> 
      <div>
       {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; int error;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //注册到devices目录中
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = device_register(&amp;platform_bus);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return error;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //注册到bus目录中
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = &nbsp;bus_register(&amp;platform_bus_type);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
      </div> 
      <div>
       if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; device_unregister(&amp;platform_bus);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; return error;
      </div> 
      <div>
       }
      </div> 
      <div>
       首先是device_register,注册的参数为platform_bus,如下所示
      </div> 
      <div>
       struct device platform_bus = {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; .bus_id &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= "platform",
      </div> 
      <div>
       };
      </div> 
      <div>
       很简单,只有一个参数,表明了目录名
      </div> 
      <div>
       int device_register(struct device *dev)
      </div> 
      <div>
       {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //初始化dev结构
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; device_initialize(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //添加dev至目录
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; return device_add(dev);
      </div> 
      <div>
       }
      </div> 
      <div>
       void device_initialize(struct device *dev)
      </div> 
      <div>
       {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //重要的一步,指明了父容器为devices_kset,而devices_kset的注册在前面已经介绍过了
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;kobj.kset = devices_kset;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //初始化kobj的ktype为device_ktype
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; klist_init(&amp;dev-&gt;klist_children, klist_children_get,
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;klist_children_put);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; INIT_LIST_HEAD(&amp;dev-&gt;node);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; init_MUTEX(&amp;dev-&gt;sem);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; spin_lock_init(&amp;dev-&gt;devres_lock);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; INIT_LIST_HEAD(&amp;dev-&gt;devres_head);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; device_init_wakeup(dev, 0);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; set_dev_node(dev, -1);
      </div> 
      <div>
       }
      </div> 
      <div>
       int device_add(struct device *dev)
      </div> 
      <div>
       {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; struct device *parent = NULL;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; struct class_interface *class_intf;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; int error;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; dev = get_device(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (!dev || !strlen(dev-&gt;bus_id)) {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = -EINVAL;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto Done;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; }
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("device: '%s': %s\n", dev-&gt;bus_id, __func__);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; parent = get_device(dev-&gt;parent);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; setup_parent(dev, parent);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_dev_node(dev, dev_to_node(parent));
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //设置dev-&gt;kobj的名字和父对象,并建立相应的目录
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, "%s", dev-&gt;bus_id);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto Error;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (platform_notify)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; platform_notify(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;bus)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BUS_NOTIFY_ADD_DEVICE, dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //建立uevent文件
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = device_create_file(dev, &amp;uevent_attr);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto attrError;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (MAJOR(dev-&gt;devt)) {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = device_create_file(dev, &amp;devt_attr);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto ueventattrError;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; }
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //建立subsystem连接文件连接到所属class,这里没有设置class对象所以不会建立
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = device_add_class_symlinks(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto SymlinkError;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //建立dev的描述文件,这里没有设置描述文件所以不会建立
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = device_add_attrs(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto AttrsError;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //建立链接文件至所属bus,这里没有设置所属bus所以不会建立
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = bus_add_device(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto BusError;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //添加power文件,因为platform不属于设备,所以不会建立power文件
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; error = device_pm_add(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (error)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto PMError;
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //检测驱动中有无适合的设备进行匹配,但没有设置bus,所以不会进行匹配
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; bus_attach_device(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; klist_add_tail(&amp;dev-&gt;knode_parent, &amp;parent-&gt;klist_children);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;class) {
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; down(&amp;dev-&gt;class-&gt;sem);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_add_tail(&amp;dev-&gt;node, &amp;dev-&gt;class-&gt;devices);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_for_each_entry(class_intf, &amp;dev-&gt;class-&gt;interfaces, node)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (class_intf-&gt;add_dev)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class_intf-&gt;add_dev(dev, class_intf);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up(&amp;dev-&gt;class-&gt;sem);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; }
      </div> 
      <div>
       Done:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; put_device(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; return error;
      </div> 
      <div>
       PMError:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; bus_remove_device(dev);
      </div> 
      <div>
       BusError:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;bus)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BUS_NOTIFY_DEL_DEVICE, dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; device_remove_attrs(dev);
      </div> 
      <div>
       AttrsError:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; device_remove_class_symlinks(dev);
      </div> 
      <div>
       SymlinkError:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (MAJOR(dev-&gt;devt))
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; device_remove_file(dev, &amp;devt_attr);
      </div> 
      <div>
       ueventattrError:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; device_remove_file(dev, &amp;uevent_attr);
      </div> 
      <div>
       attrError:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; kobject_del(&amp;dev-&gt;kobj);
      </div> 
      <div>
       Error:
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; cleanup_device_parent(dev);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put_device(parent);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; goto Done;
      </div> 
      <div>
       }
      </div> 
      <div>
       在kobject_add-&gt; kobject_add_varg-&gt; kobject_add_internal中
      </div> 
      <div>
       //提取父对象,因为没有设置,所以为空
      </div> 
      <div>
       parent = kobject_get(kobj-&gt;parent);
      </div> 
      <div>
       //父容器存在则设置父对象,在前面的dev-&gt;kobj.kset = devices_kset中设为了devices_kset
      </div> 
      <div>
       if (kobj-&gt;kset) {
      </div> 
      <div>
       //检测是否已经设置父对象
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; if (!parent)
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //无则使用父容器为父对象
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);
      </div> 
      <div>
       //添加该kobj到父容器的链表中
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; kobj_kset_join(kobj);
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; //设置父对象
      </div> 
      <div>
       &nbsp; &nbsp; &nbsp; &nbsp; kobj-&gt;parent = parent;
      </div> 
      <div>
       }
      </div> 
      <div>
       现在devices下的platform目录建立好了,模型如下,其中红线描绘了目录关系
       <br>
       <a href="https://yqfile.alicdn.com/img_504932534a30354befa02247b19c9f34.png" rel="nofollow"><img src="https://yqfile.alicdn.com/img_504932534a30354befa02247b19c9f34.png" alt="" width="601" height="1125"></a>
       <br>
       <div>
        现在到bus_register了
       </div> 
       <div>
        注册的参数platform_bus_type如下所示
       </div> 
       <div>
        struct bus_type platform_bus_type = {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= "platform",
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .dev_attrs &nbsp; &nbsp; &nbsp; &nbsp;= platform_dev_attrs,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .match &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= platform_match,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .uevent &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= platform_uevent,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .suspend &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= platform_suspend,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .suspend_late &nbsp; &nbsp; &nbsp; &nbsp;= platform_suspend_late,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .resume_early &nbsp; &nbsp; &nbsp; &nbsp;= platform_resume_early,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; .resume &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= platform_resume,
       </div> 
       <div>
        };
       </div> 
       <div>
        int bus_register(struct bus_type *bus)
       </div> 
       <div>
        {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; int retval;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //声明一个总线私有数据并分配空间
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; struct bus_type_private *priv;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv = kzalloc(sizeof(struct bus_type_private), GFP_KERNEL);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (!priv)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //互相关联
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;bus = bus;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; bus-&gt;p = priv;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //设置私有数据中kobj对象的名字
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, "%s", bus-&gt;name);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (retval)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //设置父容器为bus_kset,操作集为bus_ktype
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;subsys.kobj.kset = bus_kset;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;drivers_autoprobe = 1;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //注册bus容器
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; retval = kset_register(&amp;priv-&gt;subsys);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (retval)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //建立uevent属性文件
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; retval = bus_create_file(bus, &amp;bus_attr_uevent);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (retval)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto bus_uevent_fail;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //建立devices目录
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;devices_kset = kset_create_and_add("devices", NULL,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;priv-&gt;subsys.kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (!priv-&gt;devices_kset) {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = -ENOMEM;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto bus_devices_fail;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; }
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //建立drivers目录
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;drivers_kset = kset_create_and_add("drivers", NULL,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;priv-&gt;subsys.kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (!priv-&gt;drivers_kset) {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = -ENOMEM;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto bus_drivers_fail;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; }
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //初始化klist_devices和klist_drivers链表
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //增加probe属性文件
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; retval = add_probe_files(bus);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (retval)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto bus_probe_files_fail;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //增加总线的属性文件
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; retval = bus_add_attrs(bus);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (retval)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto bus_attrs_fail;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("bus: '%s': registered\n", bus-&gt;name);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; return 0;
       </div> 
       <div>
        bus_attrs_fail:
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; remove_probe_files(bus);
       </div> 
       <div>
        bus_probe_files_fail:
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kset_unregister(bus-&gt;p-&gt;drivers_kset);
       </div> 
       <div>
        bus_drivers_fail:
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kset_unregister(bus-&gt;p-&gt;devices_kset);
       </div> 
       <div>
        bus_devices_fail:
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; bus_remove_file(bus, &amp;bus_attr_uevent);
       </div> 
       <div>
        bus_uevent_fail:
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kset_unregister(&amp;bus-&gt;p-&gt;subsys);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kfree(bus-&gt;p);
       </div> 
       <div>
        out:
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; return retval;
       </div> 
       <div>
        }
       </div> 
       <div>
        在kset_register-&gt; kobject_add_internal中
       </div> 
       <div>
        //提取父对象,因为没有设置父对象,所以为空
       </div> 
       <div>
        parent = kobject_get(kobj-&gt;parent);
       </div> 
       <div>
        //父容器存在则设置父对象,在上文中设置了父容器priv-&gt;subsys.kobj.kset = bus_kset
       </div> 
       <div>
        if (kobj-&gt;kset) {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //检测是否已经设置父对象
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (!parent)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //无则使用父容器为父对象
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //添加该kobj到父容器的链表中
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kobj_kset_join(kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //设置父对象
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kobj-&gt;parent = parent;
       </div> 
       <div>
        }
       </div> 
       <div>
        在retval = kset_register(&amp;priv-&gt;subsys)完成之后platform在bus下的模型如下图
       </div> 
       <div>
        <a href="https://yqfile.alicdn.com/img_22d371be746dd47f7593dc5d189f5d4e.png" rel="nofollow"><img src="https://yqfile.alicdn.com/img_22d371be746dd47f7593dc5d189f5d4e.png" alt="" width="596" height="870"></a>
       </div> 
       <div>
        &nbsp;
       </div> 
       <div>
        &nbsp;
       </div> 
       <div>
        有印象的话大家还记得在platform下面有两个目录devices和drivers吧~
       </div> 
       <div>
        现在就到这两个目录的注册了
       </div> 
       <div>
        priv-&gt;devices_kset = kset_create_and_add("devices", NULL,&amp;priv-&gt;subsys.kobj);
       </div> 
       <div>
        priv-&gt;drivers_kset = kset_create_and_add("drivers", NULL, &amp;priv-&gt;subsys.kobj);
       </div> 
       <div>
        注意这两条语句的头部
       </div> 
       <div>
        priv-&gt;devices_kset = kset_create_and_add
       </div> 
       <div>
        priv-&gt;drivers_kset = kset_create_and_add
       </div> 
       <div>
        可以清楚的看到bus_type_private下的devices_kset, drivers_kset分别连接到了devices,drivers的kset上
       </div> 
       <div>
        现在来看kset_create_and_add("devices", NULL,&amp;priv-&gt;subsys.kobj);
       </div> 
       <div>
        struct kset *kset_create_and_add(const char *name,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct kset_uevent_ops *uevent_ops,
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct kobject *parent_kobj)
       </div> 
       <div>
        //参数为"devices", NULL,&amp;priv-&gt;subsys.kobj
       </div> 
       <div>
        {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; struct kset *kset;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; int error;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //创建一个kset容器
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kset = kset_create(name, uevent_ops, parent_kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (!kset)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //注册创建的kset容器
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; error = kset_register(kset);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (error) {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree(kset);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; }
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; return kset;
       </div> 
       <div>
        }
       </div> 
       <div>
        在kset_create 中比较重要的操作为
       </div> 
       <div>
        kset-&gt;kobj.ktype = &amp;kset_ktype //设置了ktype,为kset_ktype
       </div> 
       <div>
        kset-&gt;kobj.parent = parent_kobj; //设置了父对象,为priv-&gt;subsys.kobj,也就是platform_bus_type-&gt;p-&gt;subsys.kobj
       </div> 
       <div>
        kset-&gt;kobj.kset = NULL; &nbsp; &nbsp;//设置父容器为空
       </div> 
       <div>
        在kset_register中
       </div> 
       <div>
        //提取父对象
       </div> 
       <div>
        parent = kobject_get(kobj-&gt;parent); //在之前设置为了
       </div> 
       <div>
        //父容器存在则设置父对象,由于父容器为空,不执行以下代码
       </div> 
       <div>
        if (kobj-&gt;kset) {
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //检测是否已经设置父对象
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; if (!parent)
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //无则使用父容器为父对象
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //添加该kobj到父容器的链表中
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kobj_kset_join(kobj);
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; //设置父对象
       </div> 
       <div>
        &nbsp; &nbsp; &nbsp; &nbsp; kobj-&gt;parent = parent;
       </div> 
       <div>
        }
       </div> 
       <div>
        至此, devices的模型就建立好了,drivers模型的建立和devices是一致的,只是名字不同而已,我就不复述了,建立好的模型如下
       </div> 
       <div>
        <a href="https://yqfile.alicdn.com/img_8ab4d2a4e265e156f4c118b74fcda183.png" rel="nofollow"><img src="https://yqfile.alicdn.com/img_8ab4d2a4e265e156f4c118b74fcda183.png" alt="" width="597" height="903"></a>
       </div> 
       <div>
        &nbsp;
       </div> 
       <div>
        好了~ &nbsp;到了这里,bus,devices和platform的基础模型就就建立好了,就等设备来注册了
        <br>
        <br>
        <br>
        <div>
         在platform模型设备的建立中,需要2个部分的注册,驱动的注册和设备的注册
        </div> 
        <div>
         platform_device_register(&amp;test_device); &nbsp; &nbsp; &nbsp; &nbsp;
        </div> 
        <div>
         platform_driver_register(&amp;test_driver);
        </div> 
        <div>
         首先看platform_device_register
        </div> 
        <div>
         注册参数为test_device,结构如下
        </div> 
        <div>
         static struct platform_device test_device = {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; .name = "test_ts",
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; .id = -1,
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //. resource
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //.dev
        </div> 
        <div>
         };
        </div> 
        <div>
         这个结构主要描述了设备的名字,ID和资源和私有数据,其中资源和私有数据我们在这里不使用,将在别的文章中进行讲解
        </div> 
        <div>
         int platform_device_register(struct platform_device *pdev)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //设备属性的初始化
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; device_initialize(&amp;pdev-&gt;dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //将设备添加进platform里
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; return platform_device_add(pdev);
        </div> 
        <div>
         }
        </div> 
        <div>
         void device_initialize(struct device *dev)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;kobj.kset = devices_kset; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //设置kset为devices_kset,则将设备挂接上了devices目录
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//初始化kobeject,置ktype为device_ktype
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; klist_init(&amp;dev-&gt;klist_children, klist_children_get,
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;klist_children_put);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; INIT_LIST_HEAD(&amp;dev-&gt;node);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; init_MUTEX(&amp;dev-&gt;sem);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; spin_lock_init(&amp;dev-&gt;devres_lock);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; INIT_LIST_HEAD(&amp;dev-&gt;devres_head);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; device_init_wakeup(dev, 0);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; set_dev_node(dev, -1);
        </div> 
        <div>
         }
        </div> 
        <div>
         int platform_device_add(struct platform_device *pdev)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; int i, ret = 0;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (!pdev)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //检测是否设置了dev中的parent,无则赋为platform_bus
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (!pdev-&gt;dev.parent)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pdev-&gt;dev.parent = &amp;platform_bus;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //设置dev中的bus为platform_bus_type
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; pdev-&gt;dev.bus = &amp;platform_bus_type;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //检测id,id为-1表明该设备只有一个,用设备名为bus_id
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //不为1则表明该设备有数个,需要用序号标明bus_id
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (pdev-&gt;id != -1)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(pdev-&gt;dev.bus_id, BUS_ID_SIZE, "%s.%d", pdev-&gt;name,
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pdev-&gt;id);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; else
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlcpy(pdev-&gt;dev.bus_id, pdev-&gt;name, BUS_ID_SIZE);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //增加资源到资源树中
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; pdev-&gt;num_resources; i++) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct resource *p, *r = &amp;pdev-&gt;resource;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (r-&gt;name == NULL)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;name = pdev-&gt;dev.bus_id;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = r-&gt;parent;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!p) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (r-&gt;flags &amp; IORESOURCE_MEM)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = &amp;iomem_resource;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (r-&gt;flags &amp; IORESOURCE_IO)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = &amp;ioport_resource;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (p &amp;&amp; insert_resource(p, r)) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s: failed to claim resource %d\n",pdev-&gt;dev.bus_id, i);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = -EBUSY;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto failed;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("Registering platform device '%s'. Parent at %s\n",pdev-&gt;dev.bus_id, pdev-&gt;dev.parent-&gt;bus_id);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //添加设备到设备层次中
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; ret = device_add(&amp;pdev-&gt;dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (ret == 0)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ret;
        </div> 
        <div>
         failed:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; while (--i &gt;= 0)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (pdev-&gt;resource.flags &amp; (IORESOURCE_MEM|IORESOURCE_IO))
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; release_resource(&amp;pdev-&gt;resource);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; return ret;
        </div> 
        <div>
         }
        </div> 
        <div>
         int device_add(struct device *dev)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; struct device *parent = NULL;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; struct class_interface *class_intf;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; int error;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; dev = get_device(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (!dev || !strlen(dev-&gt;bus_id)) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = -EINVAL;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto Done;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("device: '%s': %s\n", dev-&gt;bus_id, __func__);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //取得上层device,而dev-&gt;parent的赋值是在platform_device_add中的pdev-&gt;dev.parent = &amp;platform_bus完成的
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; parent = get_device(dev-&gt;parent);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //以上层devices为准重设dev-&gt;kobj.parent
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; setup_parent(dev, parent);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_dev_node(dev, dev_to_node(parent));
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //设置dev-&gt;kobj的名字和父对象,并建立相应目录
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, "%s", dev-&gt;bus_id);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto Error;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (platform_notify)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; platform_notify(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //一种新型的通知机制,但是platform中没有设置相应的结构,所以在这里跳过
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; /* notify clients of device entry (new way) */
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;bus)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,BUS_NOTIFY_ADD_DEVICE, dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //建立uevent文件
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; error = device_create_file(dev, &amp;uevent_attr);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto attrError;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //设备有设备号则建立dev文件
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (MAJOR(dev-&gt;devt)) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = device_create_file(dev, &amp;devt_attr);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto ueventattrError;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //建立subsystem连接文件连接到所属class
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; error = device_add_class_symlinks(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto SymlinkError;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //添加dev的描述文件
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; error = device_add_attrs(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto AttrsError;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //添加链接文件至所属bus
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; error = bus_add_device(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto BusError;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //添加power文件
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; error = device_pm_add(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (error)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto PMError;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //检测驱动中有无适合的设备进行匹配,现在只添加了设备,还没有加载驱动,所以不会进行匹配
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; bus_attach_device(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; klist_add_tail(&amp;dev-&gt;knode_parent, &amp;parent-&gt;klist_children);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;class) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; down(&amp;dev-&gt;class-&gt;sem);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_add_tail(&amp;dev-&gt;node, &amp;dev-&gt;class-&gt;devices);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_for_each_entry(class_intf, &amp;dev-&gt;class-&gt;interfaces, node)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (class_intf-&gt;add_dev)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class_intf-&gt;add_dev(dev, class_intf);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up(&amp;dev-&gt;class-&gt;sem);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         Done:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; put_device(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; return error;
        </div> 
        <div>
         PMError:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; bus_remove_device(dev);
        </div> 
        <div>
         BusError:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;bus)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,BUS_NOTIFY_DEL_DEVICE, dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; device_remove_attrs(dev);
        </div> 
        <div>
         AttrsError:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; device_remove_class_symlinks(dev);
        </div> 
        <div>
         SymlinkError:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (MAJOR(dev-&gt;devt))
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; device_remove_file(dev, &amp;devt_attr);
        </div> 
        <div>
         ueventattrError:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; device_remove_file(dev, &amp;uevent_attr);
        </div> 
        <div>
         attrError:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; kobject_del(&amp;dev-&gt;kobj);
        </div> 
        <div>
         Error:
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; cleanup_device_parent(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put_device(parent);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; goto Done;
        </div> 
        <div>
         }
        </div> 
        <div>
         static void setup_parent(struct device *dev, struct device *parent)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *kobj;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //取得上层device的kobj
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; kobj = get_device_parent(dev, parent);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //kobj不为空则重设dev-&gt;kobj.parent
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (kobj)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dev-&gt;kobj.parent = kobj;
        </div> 
        <div>
         }
        </div> 
        <div>
         static struct kobject *get_device_parent(struct device *dev,
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;struct device *parent)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; int retval;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; //因为dev-&gt;class为空,所以跳过这段代码
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (dev-&gt;class) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *kobj = NULL;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *parent_kobj;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *k;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (parent == NULL)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_kobj = virtual_device_parent(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (parent-&gt;class)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &amp;parent-&gt;kobj;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_kobj = &amp;parent-&gt;kobj;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spin_lock(&amp;dev-&gt;class-&gt;class_dirs.list_lock);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_for_each_entry(k, &amp;dev-&gt;class-&gt;class_dirs.list, entry)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (k-&gt;parent == parent_kobj) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobj = kobject_get(k);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spin_unlock(&amp;dev-&gt;class-&gt;class_dirs.list_lock);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (kobj)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return kobj;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k = kobject_create();
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!k)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k-&gt;kset = &amp;dev-&gt;class-&gt;class_dirs;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = kobject_add(k, parent_kobj, "%s", dev-&gt;class-&gt;name);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (retval &lt; 0) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kobject_put(k);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return k;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (parent)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //返回上层device的kobj
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return &amp;parent-&gt;kobj;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
        </div> 
        <div>
         }
        </div> 
        <div>
         在bus_attach_device中虽然没有成功进行匹配,但是有很重要的一步为之后正确的匹配打下基础
        </div> 
        <div>
         void bus_attach_device(struct device *dev)
        </div> 
        <div>
         {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; struct bus_type *bus = dev-&gt;bus;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; int ret = 0;
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; if (bus) {
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (bus-&gt;p-&gt;drivers_autoprobe)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = device_attach(dev);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WARN_ON(ret &lt; 0);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ret &gt;= 0)
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; klist_add_tail(&amp;dev-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);
        </div> 
        <div>
         &nbsp; &nbsp; &nbsp; &nbsp; }
        </div> 
        <div>
         }
        </div> 
        <div>
         klist_add_tail(&amp;dev-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices)就是这一行
        </div> 
        <div>
         在这一行代码中将设备挂载到了bus下的devices链表下,这样,当驱动请求匹配的时候,platform总线就会历遍devices链表为驱动寻找合适的设备
        </div> 
        <div>
         现在来看一下test_device的模型
         <br>
         <a href="https://yqfile.alicdn.com/img_b41d3cfce42e9630377db3b23f4664dc.png" rel="nofollow"><img src="https://yqfile.alicdn.com/img_b41d3cfce42e9630377db3b23f4664dc.png" alt="" width="595" height="1167"></a>
         <br>
         <div>
          然后platform_driver_unregister,他的参数 test_driver的结构如下
         </div> 
         <div>
          static struct platform_driver test_driver = {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; .probe &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= test_probe,
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; .remove &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= test_remove,
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; .driver &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .name &nbsp; &nbsp; &nbsp; &nbsp;= "test_ts",
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .owner &nbsp; &nbsp; &nbsp; &nbsp;= THIS_MODULE,
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; },
         </div> 
         <div>
          };
         </div> 
         <div>
          int platform_driver_register(struct platform_driver *drv)
         </div> 
         <div>
          {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;driver.bus = &amp;platform_bus_type;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (drv-&gt;probe)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;driver.probe = platform_drv_probe;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (drv-&gt;remove)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;driver.remove = platform_drv_remove;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (drv-&gt;shutdown)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;driver.shutdown = platform_drv_shutdown;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (drv-&gt;suspend)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;driver.suspend = platform_drv_suspend;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (drv-&gt;resume)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;driver.resume = platform_drv_resume;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; return driver_register(&amp;drv-&gt;driver);
         </div> 
         <div>
          }
         </div> 
         <div>
          从上面代码可以看出,在platform_driver中设置了probe, remove, shutdown, suspend或resume函数的话
         </div> 
         <div>
          则drv-&gt;driver也会设置成platform对应的函数
         </div> 
         <div>
          int driver_register(struct device_driver *drv)
         </div> 
         <div>
          {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; int ret;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; struct device_driver *other;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //检测总线的操作函数和驱动的操作函数是否同时存在,同时存在则提示使用总线提供的操作函数
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_WARNING "Driver '%s' needs updating - please use ""bus_type methods\n", drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //检测是否已经注册过
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; other = driver_find(drv-&gt;name, drv-&gt;bus);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (other) {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put_driver(other);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "Error: Driver '%s' is already registered, “"aborting...\n", drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EEXIST;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; }
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //添加驱动到总线上
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; ret = bus_add_driver(drv);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (ret)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ret;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; ret = driver_add_groups(drv, drv-&gt;groups);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (ret)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bus_remove_driver(drv);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; return ret;
         </div> 
         <div>
          }
         </div> 
         <div>
          int bus_add_driver(struct device_driver *drv)
         </div> 
         <div>
          {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; struct bus_type *bus;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; struct driver_private *priv;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; int error = 0;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //取bus结构
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; bus = bus_get(drv-&gt;bus);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (!bus)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("bus: '%s': add driver %s\n", bus-&gt;name, drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //分配驱动私有数据
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; priv = kzalloc(sizeof(*priv), GFP_KERNEL);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (!priv) {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = -ENOMEM;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out_put_bus;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; }
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //初始化klist_devices链表
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; klist_init(&amp;priv-&gt;klist_devices, NULL, NULL);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //互相关联
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;driver = drv;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; drv-&gt;p = priv;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //设置私有数据的父容器,在这一步中,设置了kset为platform下的drivers_kset结构,也就是drivers呢个目录
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //初始化kobj对象,设置容器操作集并建立相应的目录,这里由于没有提供parent,所以会使用父容器中的kobj为父对象
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, NULL,
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"%s", drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (error)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out_unregister;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //检测所属总线的drivers_autoprobe属性是否为真
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //为真则进行与设备的匹配,到这里,就会与我们之前注册的test_device连接上了,至于如何连接,进行了什么操作,将在别的文章中详细描述
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = driver_attach(drv);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (error)
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out_unregister;
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; }
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //挂载到所属总线驱动链表上
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; module_add_driver(drv-&gt;owner, drv);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //建立uevent属性文件
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; error = driver_create_file(drv, &amp;driver_attr_uevent);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (error) {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s: uevent attr (%s) failed\n",
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __func__, drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; }
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; //建立设备属性文件
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; error = driver_add_attrs(bus, drv);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (error) {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s: driver_add_attrs(%s) failed\n",__func__, drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; }
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; error = add_bind_files(drv);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; if (error) {
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "%s: add_bind_files(%s) failed\n",__func__, drv-&gt;name);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; }
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; kobject_uevent(&amp;priv-&gt;kobj, KOBJ_ADD);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; return error;
         </div> 
         <div>
          out_unregister:
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; kobject_put(&amp;priv-&gt;kobj);
         </div> 
         <div>
          out_put_bus:
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; bus_put(bus);
         </div> 
         <div>
          &nbsp; &nbsp; &nbsp; &nbsp; return error;
         </div> 
         <div>
          }
         </div> 
         <div>
          到这里test_driver的模型就建立好了,图就是最上面的层次图,我就不再贴了
         </div> 
         <div>
          到这里一个基本的框架就建立起来了~
         </div> 
         <div>
          &nbsp;
         </div> 
         <div>
          下面,我开始对kobject kset和ktype做分析
         </div> 
         <div>
          先说说关系,ktype与kobject和kset这两者之前的关系较少,让我画一个图,是这样的
          <br>
          <a href="https://yqfile.alicdn.com/img_9e03b328b90ec9113c7ae4914746a696.jpg" rel="nofollow"><img src="https://yqfile.alicdn.com/img_9e03b328b90ec9113c7ae4914746a696.jpg" alt="" width="153" height="188"></a>
          <br>
          <div>
           ktype依赖于kobject,kset也依赖于kobject,而kobject有时需要kset(所以用了一个白箭头),不一定需要ktype(真可怜,连白箭头都没有)
          </div> 
          <div>
           首先先说一下这个可有可无的ktype
          </div> 
          <div>
           到/sys/bus/platform下面可以看见一个drivers_autoprobe的文件
          </div> 
          <div>
           cat drivers_autoprobe可以查看这个文件的值
          </div> 
          <div>
           echo 0 &gt; drivers_autoprobe则可以改变这个文件的值
          </div> 
          <div>
           drivers_autoprobe这个文件表示的是是否自动进行初始化
          </div> 
          <div>
           在
          </div> 
          <div>
           void bus_attach_device(struct device *dev)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct bus_type *bus = dev-&gt;bus;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; int ret = 0;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (bus) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (bus-&gt;p-&gt;drivers_autoprobe)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = device_attach(dev);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WARN_ON(ret &lt; 0);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ret &gt;= 0)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; klist_add_tail(&amp;dev-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           }
          </div> 
          <div>
           中可以看见这么一段代码
          </div> 
          <div>
           if (bus-&gt;p-&gt;drivers_autoprobe)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; ret = device_attach(dev);
          </div> 
          <div>
           bus-&gt;p-&gt;drivers_autoprobe的值为真则进行匹配
          </div> 
          <div>
           而drivers_autoprobe这个文件则可以动态的修改这个值选择是否进行匹配
          </div> 
          <div>
           使用外部文件修改内核参数,ktype就是提供了这么一种方法
          </div> 
          <div>
           现在让我们看看ktype是怎么通过kobject进行运作的
          </div> 
          <div>
           首先是ktype及通过ktype进行运作的drivers_autoprobe的注册
          </div> 
          <div>
           ktype的挂载十分简单,因为他是和kobject是一体的
          </div> 
          <div>
           只有这么下面一句 &nbsp; &nbsp; &nbsp; &nbsp;
          </div> 
          <div>
           priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;
          </div> 
          <div>
           这样就将bus_ktype挂载到了platform_bus_type的kobject上
          </div> 
          <div>
           drivers_autoprobe的注册如下
          </div> 
          <div>
           retval = bus_create_file(bus, &amp;bus_attr_drivers_autoprobe);
          </div> 
          <div>
           bus_attr_drivers_autoprobe这个结构由一系列的宏进行组装
          </div> 
          <div>
           static BUS_ATTR(drivers_autoprobe, S_IWUSR | S_IRUGO,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; show_drivers_autoprobe, store_drivers_autoprobe);
          </div> 
          <div>
           #define BUS_ATTR(_name, _mode, _show, _store) &nbsp; &nbsp; &nbsp; &nbsp;\
          </div> 
          <div>
           struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)
          </div> 
          <div>
           #define __ATTR(_name,_mode,_show,_store) { \
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .attr = {.name = __stringify(_name), .mode = _mode }, &nbsp; &nbsp; &nbsp; &nbsp;\
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .show &nbsp; &nbsp; &nbsp; &nbsp;= _show, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .store &nbsp; &nbsp; &nbsp; &nbsp;= _store, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\
          </div> 
          <div>
           }
          </div> 
          <div>
           最后bus_attr_drivers_autoprobe的模型如下
          </div> 
          <div>
           struct bus_attribute &nbsp;bus_attr_drivers_autoprobe&nbsp;
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .attr = {
          </div> 
          <div>
           .name = “drivers_autoprobe”,
          </div> 
          <div>
           .mode = S_IWUSR | S_IRUGO&nbsp;
          </div> 
          <div>
           }, &nbsp; &nbsp; &nbsp; &nbsp;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .show &nbsp; &nbsp; &nbsp; &nbsp;= show_drivers_autoprobe, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .store &nbsp; &nbsp; &nbsp; &nbsp;= store_drivers_autoprobe, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
          </div> 
          <div>
           }
          </div> 
          <div>
           进入到bus_create_file中
          </div> 
          <div>
           int bus_create_file(struct bus_type *bus, struct bus_attribute *attr)
          </div> 
          <div>
           //参数为(bus, &amp;bus_attr_drivers_autoprobe)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; int error;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (bus_get(bus)) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = sysfs_create_file(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bus_put(bus);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; } else
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error = -EINVAL;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return error;
          </div> 
          <div>
           }
          </div> 
          <div>
           int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)
          </div> 
          <div>
           //参数为(&amp;bus-&gt;p-&gt;subsys.kobj, &amp;attr-&gt;attr)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; BUG_ON(!kobj || !kobj-&gt;sd || !attr);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return sysfs_add_file(kobj-&gt;sd, attr, SYSFS_KOBJ_ATTR);
          </div> 
          <div>
           }
          </div> 
          <div>
           int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,int type)
          </div> 
          <div>
           //参数为(&amp;bus-&gt;p-&gt;subsys.kobj -&gt;sd, &amp;attr-&gt;attr, SYSFS_KOBJ_ATTR)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return sysfs_add_file_mode(dir_sd, attr, type, attr-&gt;mode);
          </div> 
          <div>
           }
          </div> 
          <div>
           int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const struct attribute *attr, int type, mode_t amode)
          </div> 
          <div>
           //整理一下参数,现在应该为
          </div> 
          <div>
           //(&amp;platform_bus_type-&gt;p-&gt;subsys.kobj -&gt;sd, &amp;bus_attr_drivers_autoprobe-&gt;attr, SYSFS_KOBJ_ATTR, &amp;bus_attr_drivers_autoprobe-&gt;attr-&gt;mode)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; umode_t mode = (amode &amp; S_IALLUGO) | S_IFREG;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_addrm_cxt acxt;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent *sd;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; int rc;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //在这一步中可以看出新建了一个节点
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sd = sysfs_new_dirent(attr-&gt;name, mode, type);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (!sd)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //这一步挂载了&amp;bus_attr_drivers_autoprobe-&gt;attr到节点中,为以后提取attr及上层结构做准备
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sd-&gt;s_attr.attr = (void *)attr;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; // dir_sd也就是上层目录,在这里为platform_bus_type-&gt;p-&gt;subsys.kobj -&gt;sd
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //也就是/sys/bus/platform这个目录
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sysfs_addrm_start(&amp;acxt, dir_sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; rc = sysfs_add_one(&amp;acxt, sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sysfs_addrm_finish(&amp;acxt);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (rc)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysfs_put(sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return rc;
          </div> 
          <div>
           }
          </div> 
          <div>
           struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; char *dup_name = NULL;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent *sd;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (type &amp; SYSFS_COPY_NAME) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = dup_name = kstrdup(name, GFP_KERNEL);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!name)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sd = kmem_cache_zalloc(sysfs_dir_cachep, GFP_KERNEL);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (!sd)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_out1;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (sysfs_alloc_ino(&amp;sd-&gt;s_ino))
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_out2;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; atomic_set(&amp;sd-&gt;s_count, 1);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; atomic_set(&amp;sd-&gt;s_active, 0);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sd-&gt;s_name = name; &nbsp; //节点的名字为&amp;bus_attr_drivers_autoprobe-&gt;attr-&gt;name &nbsp;也就是drivers_autoprobe
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sd-&gt;s_mode = mode;
          </div> 
          <div>
           sd-&gt;s_flags = type; &nbsp; //节点的type为SYSFS_KOBJ_ATTR
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return sd;
          </div> 
          <div>
           err_out2:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; kmem_cache_free(sysfs_dir_cachep, sd);
          </div> 
          <div>
           err_out1:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; kfree(dup_name);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return NULL;
          </div> 
          <div>
           }
          </div> 
          <div>
           现在一切准备就绪,来看看怎么读取吧
          </div> 
          <div>
           首先是open,大概流程可以看我的另一篇文章&lt;从文件到设备&gt;,一直看到ext3_lookup
          </div> 
          <div>
           这里和ext3_lookup不同的是,sys的文件系统是sysfs文件系统,所以应该使用的lookup函数为sysfs_lookup(/fs/sysfs/dir.c)
          </div> 
          <div>
           static struct dentry * sysfs_lookup(struct inode *dir, struct dentry *dentry,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct nameidata *nd)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct dentry *ret = NULL;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent *parent_sd = dentry-&gt;d_parent-&gt;d_fsdata;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent *sd;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct inode *inode;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; mutex_lock(&amp;sysfs_mutex);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sd = sysfs_find_dirent(parent_sd, dentry-&gt;d_name.name);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (!sd) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ERR_PTR(-ENOENT);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out_unlock;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //节点的初始化在这里
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode = sysfs_get_inode(sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (!inode) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ERR_PTR(-ENOMEM);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out_unlock;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; dentry-&gt;d_op = &amp;sysfs_dentry_ops;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; dentry-&gt;d_fsdata = sysfs_get(sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; d_instantiate(dentry, inode);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; d_rehash(dentry);
          </div> 
          <div>
           out_unlock:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; mutex_unlock(&amp;sysfs_mutex);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return ret;
          </div> 
          <div>
           }
          </div> 
          <div>
           struct inode * sysfs_get_inode(struct sysfs_dirent *sd)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct inode *inode;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode = iget_locked(sysfs_sb, sd-&gt;s_ino);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (inode &amp;&amp; (inode-&gt;i_state &amp; I_NEW))
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //为节点赋值
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sysfs_init_inode(sd, inode);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return inode;
          </div> 
          <div>
           }
          </div> 
          <div>
           static void sysfs_init_inode(struct sysfs_dirent *sd, struct inode *inode)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct bin_attribute *bin_attr;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_blocks = 0;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_mapping-&gt;a_ops = &amp;sysfs_aops;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_mapping-&gt;backing_dev_info = &amp;sysfs_backing_dev_info;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_op = &amp;sysfs_inode_operations;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_ino = sd-&gt;s_ino;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; lockdep_set_class(&amp;inode-&gt;i_mutex, &amp;sysfs_inode_imutex_key);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (sd-&gt;s_iattr) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_inode_attr(inode, sd-&gt;s_iattr);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; } else
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_default_inode_attr(inode, sd-&gt;s_mode);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //判断类型
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; switch (sysfs_type(sd)) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; case SYSFS_DIR:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_op = &amp;sysfs_dir_inode_operations;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_fop = &amp;sysfs_dir_operations;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_nlink = sysfs_count_nlink(sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //还记得在注册的时候有一个参数为SYSFS_KOBJ_ATTR赋到了sd-&gt;s_flags上面吧
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; case SYSFS_KOBJ_ATTR:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_size = PAGE_SIZE;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_fop = &amp;sysfs_file_operations;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; case SYSFS_KOBJ_BIN_ATTR:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bin_attr = sd-&gt;s_bin_attr.bin_attr;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_size = bin_attr-&gt;size;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_fop = &amp;bin_fops;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; case SYSFS_KOBJ_LINK:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inode-&gt;i_op = &amp;sysfs_symlink_inode_operations;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; default:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BUG();
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; unlock_new_inode(inode);
          </div> 
          <div>
           }
          </div> 
          <div>
           sysfs_file_operations的结构如下,之后open和read,write都明了了
          </div> 
          <div>
           const struct file_operations sysfs_file_operations = {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .read &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sysfs_read_file,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .write &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sysfs_write_file,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .llseek &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= generic_file_llseek,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .open &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sysfs_open_file,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .release &nbsp; &nbsp; &nbsp; &nbsp;= sysfs_release,
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; .poll &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= sysfs_poll,
          </div> 
          <div>
           };
          </div> 
          <div>
           有关在哪调用open还是请查阅我的另一篇文章&lt;从文件到设备&gt;中 nameidata_to_filp之后的操作
          </div> 
          <div>
           好的~ &nbsp;现在进入到了sysfs_open_file中
          </div> 
          <div>
           static int sysfs_open_file(struct inode *inode, struct file *file)
          </div> 
          <div>
           {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent *attr_sd = file-&gt;f_path.dentry-&gt;d_fsdata;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //要重的取值,在这里取得了drivers_autoprobe的目录platform的kproject
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_buffer *buffer;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_ops *ops;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; int error = -EACCES;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (!sysfs_get_active_two(attr_sd))
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENODEV;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (kobj-&gt;ktype &amp;&amp; kobj-&gt;ktype-&gt;sysfs_ops)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //这里可谓是ktype实现中的核心,在这里ops设置成了platform_bus_type中kobject-&gt;ktype的sysfs_ops
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ops = kobj-&gt;ktype-&gt;sysfs_ops;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; else {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printk(KERN_ERR "missing sysfs attribute operations for ""kobject: %s\n", kobject_name(kobj));
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WARN_ON(1);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_out;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (file-&gt;f_mode &amp; FMODE_WRITE) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(inode-&gt;i_mode &amp; S_IWUGO) || !ops-&gt;store)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_out;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (file-&gt;f_mode &amp; FMODE_READ) {
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(inode-&gt;i_mode &amp; S_IRUGO) || !ops-&gt;show)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_out;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; }
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; error = -ENOMEM;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (!buffer)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_out;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; mutex_init(&amp;buffer-&gt;mutex);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;needs_read_fill = 1;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //然后将设置好的ops挂载到buffer上
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;ops = ops;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; //再将buffer挂载到file-&gt;private_data中
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; file-&gt;private_data = buffer;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; error = sysfs_get_open_dirent(attr_sd, buffer);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; if (error)
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_free;
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sysfs_put_active_two(attr_sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return 0;
          </div> 
          <div>
           err_free:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; kfree(buffer);
          </div> 
          <div>
           err_out:
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; sysfs_put_active_two(attr_sd);
          </div> 
          <div>
           &nbsp; &nbsp; &nbsp; &nbsp; return error;
          </div> 
          <div>
           }
          </div> 
          <div>
           现在已经为read和write操作准备好了
          </div> 
          <div>
           马上进入到read操作中
           <br>
           <a href="https://yqfile.alicdn.com/img_1f8eb7cde69b24433a16afa06f20eca8.jpg" rel="nofollow"><img src="https://yqfile.alicdn.com/img_1f8eb7cde69b24433a16afa06f20eca8.jpg" alt="" width="184" height="409"></a>
           <br>整个流程如上图所示,如何进入到sysfs_read_file在上面open的操作中已经说明了 
           <div>
            我们就从sysfs_read_file开始分析(该文件在/fs/sysfs/file.c中)
           </div> 
           <div>
            sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
           </div> 
           <div>
            {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_buffer * buffer = file-&gt;private_data;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; ssize_t retval = 0;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; mutex_lock(&amp;buffer-&gt;mutex);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (buffer-&gt;needs_read_fill || *ppos == 0) {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //主要操作在fill_read_buffer中
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = fill_read_buffer(file-&gt;f_path.dentry,buffer);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (retval)
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto out;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; }
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",__func__, count, *ppos, buffer-&gt;page);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; retval = simple_read_from_buffer(buf, count, ppos, buffer-&gt;page,
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer-&gt;count);
           </div> 
           <div>
            out:
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; mutex_unlock(&amp;buffer-&gt;mutex);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; return retval;
           </div> 
           <div>
            }
           </div> 
           <div>
            static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)
           </div> 
           <div>
            {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent *attr_sd = dentry-&gt;d_fsdata;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; //取得父目录的kobject,也就是platform的kobject
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; //还记得这个buffer-&gt;ops在什么时候进行赋值的么?
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_ops * ops = buffer-&gt;ops;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; int ret = 0;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; ssize_t count;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (!buffer-&gt;page)
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;page = (char *) get_zeroed_page(GFP_KERNEL);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (!buffer-&gt;page)
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (!sysfs_get_active_two(attr_sd))
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENODEV;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;event = atomic_read(&amp;attr_sd-&gt;s_attr.open-&gt;event);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; //调用ops-&gt;show &nbsp;也就是bus_sysfs_ops-&gt;show &nbsp; &nbsp;具体就是bus_attr_show了
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; //参数为父目录的kobject, bus_attr_drivers_autoprobe-&gt;attr,和一段char信息
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; count = ops-&gt;show(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; sysfs_put_active_two(attr_sd);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (count &gt;= (ssize_t)PAGE_SIZE) {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print_symbol("fill_read_buffer: %s returned bad count\n",
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (unsigned long)ops-&gt;show);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Try to struggle along */
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = PAGE_SIZE - 1;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; }
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (count &gt;= 0) {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;needs_read_fill = 0;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer-&gt;count = count;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; } else {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = count;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; }
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; return ret;
           </div> 
           <div>
            }
           </div> 
           <div>
            现在进入bus_attr_show中
           </div> 
           <div>
            static ssize_t bus_attr_show(struct kobject *kobj, struct attribute *attr,char *buf)
           </div> 
           <div>
            {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; //提取attr的上层结构,也就是bus_attr_drivers_autoprobe
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct bus_attribute *bus_attr = to_bus_attr(attr);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; //提取kobj的上上层结构,也就是bus_type_private
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct bus_type_private *bus_priv = to_bus(kobj);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; ssize_t ret = 0;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (bus_attr-&gt;show)
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //终于到了这里,最后的调用,调用bus_attr_drivers_autoprobe.show ,也就是show_drivers_autoprobe
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //参数为bus_priv-&gt;bus,也就是platform_bus_type , 及一段char信息
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = bus_attr-&gt;show(bus_priv-&gt;bus, buf);
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; return ret;
           </div> 
           <div>
            }
           </div> 
           <div>
            static ssize_t show_drivers_autoprobe(struct bus_type *bus, char *buf)
           </div> 
           <div>
            {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; return sprintf(buf, "%d\n", bus-&gt;p-&gt;drivers_autoprobe);
           </div> 
           <div>
            }
           </div> 
           <div>
            没什么好介绍了就是打印 buf + bus-&gt;p-&gt;drivers_autoprobe &nbsp; 从结果来看~ buf是空的
           </div> 
           <div>
            到这里,终于把内核的信息给打印出来了,千辛万苦,层层调用,就是为了取得上层kobject结构,逆运算再取得kobject的上层结构
           </div> 
           <div>
            大家是否对kobject有所了解了呢?~ &nbsp;
           </div> 
           <div>
            在对kobject进行介绍之前 &nbsp;还是先把write操作讲完吧 哈哈~
           </div> 
           <div>
            write操作和read操作重要的步骤基本是一致的,只不过在最后的调用中
           </div> 
           <div>
            static ssize_t store_drivers_autoprobe(struct bus_type *bus,
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const char *buf, size_t count)
           </div> 
           <div>
            {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; if (buf[0] == '0')
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bus-&gt;p-&gt;drivers_autoprobe = 0;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; else
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bus-&gt;p-&gt;drivers_autoprobe = 1;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; return count;
           </div> 
           <div>
            }
           </div> 
           <div>
            不进行打印而对内核的参数进行了修改而已
           </div> 
           <div>
            好~ 现在让我们来看看kobject吧
           </div> 
           <div>
            kobject的结构如下
           </div> 
           <div>
            struct kobject {
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; const char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*name; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//kobject的名字
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct kref &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;kref; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//kobject的原子操作
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct list_head &nbsp; &nbsp; &nbsp; &nbsp;entry;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct kobject &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*parent; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//父对象
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct kset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*kset; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//父容器
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct kobj_type &nbsp; &nbsp; &nbsp; &nbsp;*ktype; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//ktype
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; struct sysfs_dirent &nbsp; &nbsp; &nbsp; &nbsp;*sd; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//文件节点
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; unsigned int state_initialized:1;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; unsigned int state_in_sysfs:1;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; unsigned int state_add_uevent_sent:1;
           </div> 
           <div>
            &nbsp; &nbsp; &nbsp; &nbsp; unsigned int state_remove_uevent_sent:1;
           </div> 
           <div>
            };
           </div> 
           <div>
            kobject描述的是较具体的对象,一个设备,一个驱动,一个总线,一类设备
           </div> 
           <div>
            在层次图上可以看出,每个存在于层次图中的设备,驱动,总线,类别都有自己的kobject
           </div> 
           <div>
            kobject与kobject之间的层次由kobject中的parent指针决定
           </div> 
           <div>
            而kset指针则表明了kobject的容器
           </div> 
           <div>
            像platform_bus 和test_device的kset都是devices_kset
           </div> 
           <div>
            呢parent和kset有什么不同呢
           </div> 
           <div>
            我认为是人工和默认的区别,看下面这张图 ,蓝框为kset,红框为kobject
            <br>
            <a href="https://yqfile.alicdn.com/img_e2e598314eb8e2e2d1c266fae5eb1cef.jpg" rel="nofollow"><img src="https://yqfile.alicdn.com/img_e2e598314eb8e2e2d1c266fae5eb1cef.jpg" alt="" width="499" height="248"></a>
            <br>
            <div>
             容器提供了一种默认的层次~ &nbsp;但也可以人工设置层次
            </div> 
            <div>
             对于kobject现在我只理解了这么多,欢迎大家指出有疑问的地方
            </div> 
            <div>
             最后是kset,kset比较简单,看下面的结构
            </div> 
            <div>
             struct kset {
            </div> 
            <div>
             &nbsp; &nbsp; &nbsp; &nbsp; struct list_head list;
            </div> 
            <div>
             &nbsp; &nbsp; &nbsp; &nbsp; spinlock_t list_lock;
            </div> 
            <div>
             &nbsp; &nbsp; &nbsp; &nbsp; struct kobject kobj;
            </div> 
            <div>
             &nbsp; &nbsp; &nbsp; &nbsp; struct kset_uevent_ops *uevent_ops;
            </div> 
            <div>
             };
            </div> 
            <div>
             对于kset的描述,文档里也有介绍
            </div> 
            <div>
             /**
            </div> 
            <div>
             * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.
            </div> 
            <div>
             *
            </div> 
            <div>
             * A kset defines a group of kobjects. &nbsp;They can be individually
            </div> 
            <div>
             * different "types" but overall these kobjects all want to be grouped
            </div> 
            <div>
             * together and operated on in the same manner. &nbsp;ksets are used to
            </div> 
            <div>
             * define the attribute callbacks and other common events that happen to
            </div> 
            <div>
             * a kobject.
            </div> 
            <div>
             翻译过来大概就是
            </div> 
            <div>
             结构kset,一个指定类型的kobject的集合,属于某一个指定的子系统
            </div> 
            <div>
             kset定义了一组kobject,它们可以是不同类型组成但却希望捆在一起有一个统一的操作
            </div> 
            <div>
             kset通常被定义为回调属性和其他通用的事件发生在kobject上
            </div> 
            <div>
             可能翻译的不是很好,望大家见谅
            </div> 
            <div>
             从结构中能看出kset比kobject多了3个属性
            </div> 
            <div>
             list_head &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//列表
            </div> 
            <div>
             spinlock_t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//共享锁
            </div> 
            <div>
             kset_uevent_ops &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//uevent操作集
            </div> 
            <div>
             list_head &nbsp; &nbsp; &nbsp; &nbsp;连接了所有kobject中kset属性指向自己的kobject
            </div> 
            <div>
             而kset_uevent_ops则用于通知机制,由于uevent的作用我也没接触过,所以暂不解析uevent的机制了
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div> 
    <div>
     【作者】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">张昺华</a> 
    </div> 
    <div>
     【出处】
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【博客园】 
     <a href="http://www.cnblogs.com/sky-heaven/" rel="nofollow">http://www.cnblogs.com/sky-heaven/</a> 
    </div> 
    <div>
     【新浪博客】 
     <a href="http://blog.sina.com.cn/u/2049150530" rel="nofollow">http://blog.sina.com.cn/u/2049150530</a> 
    </div> 
    <div>
     【知乎】 
     <a href="http://www.zhihu.com/people/zhang-bing-hua" rel="nofollow">http://www.zhihu.com/people/zhang-bing-hua</a> 
    </div> 
    <div>
     【我的作品---旋转倒立摆】 
     <a href="http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5NDAzNjQw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【我的作品---自平衡自动循迹车】 
     <a href="http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2" rel="nofollow">http://v.youku.com/v_show/id_XODM5MzYyNTIw.html?spm=a2hzp.8253869.0.0&amp;from=y1.7-2</a> 
    </div> 
    <div>
     【新浪微博】 张昺华--sky
    </div> 
    <div>
     【twitter】 @sky2030_
    </div> 
    <div>
     【facebook】 张昺华 zhangbinghua
    </div> 
    <div>
     本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利.
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
