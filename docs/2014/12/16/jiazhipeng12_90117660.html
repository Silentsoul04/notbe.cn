<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>java的几种设计模式 « NotBeCN</title>
  <meta name="description" content="                 设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。    &nbsp;    java中有23种设计模式：    单例设计模式：★★★★★    解决的问题...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2014/12/16/jiazhipeng12_90117660.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">java的几种设计模式</h1>
    <p class="post-meta">Dec 16, 2014</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="artical-content-bak main-content editor-side-new"> 
   <div class="con editor-preview-side" id="result">
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">设计模式</span></span><span style="font-family:'宋体';">：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">java</span><span style="font-family:'宋体';">中有<span>23</span>种设计模式：</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;font-size:14pt;">单例设计模式：★★★★★</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">解决的问题：<span style="font-weight:600;">保证一个类在内存中的对象唯一性。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">Runtime()</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">方法就是单例设计模式进行设计的。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">如何保证对象唯一性呢？</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">思想：</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">1</span><span style="font-family:'宋体';">，不让其他程序创建该类对象。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">2</span><span style="font-family:'宋体';">，在本类中创建一个本类对象。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">3</span><span style="font-family:'宋体';">，对外提供方法，让其他程序获取这个对象。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">步骤：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">，就在类中创建一个本类的对象；</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">3</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">代码体现：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">，私有化构造函数；</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">，创建私有并静态的本类对象；</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">3</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">，定义公有并静态的方法，返回该对象。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">---------------------------------------------</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">//</span><span style="font-family:'宋体';color:#FF0000;">饿汉式</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">class Single{</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>private Single(){} //</span><span style="font-weight:600;"><span style="font-family:'宋体';">私有化构造函数。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">private static Single s = new Single(); //</span><span style="font-weight:600;"><span style="font-family:'宋体';">创建私有并静态的本类对象。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>public static Single getInstance(){ //</span><span style="font-weight:600;"><span style="font-family:'宋体';">定义公有并静态的方法，返回该对象。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>return s;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">---------------------------------------------</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">//</span><span style="font-family:'宋体';color:#FF0000;">懒汉式</span><span style="font-family:'宋体';">:</span><span style="font-family:'宋体';">延迟加载方式。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">class Single2{</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>private Single2(){}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">private static Single2 s = null;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>public static Single2 getInstance(){</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>if(s==null)</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>s = new Single2();</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>return s;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">-------------------------------------------------------------------------------------------------</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;font-size:16pt;">继 承</span></span><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">（面向对象特征之一）</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">好处：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：提高了代码的复用性。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：让类与类之间产生了关系，提供了另一个特征多态的前提。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">父类的由来：其实是由多个类不断向上抽取共性内容而来的。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">java</span><span style="font-family:'宋体';">中对于继承，<span>java</span>只支持单继承。<span>java</span>虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">单继承：一个类只能有一个父类。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">多继承：一个类可以有多个父类。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">为什么不支持多继承呢？</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">但是<span>java</span>支持多重继承。<span>A</span>继承<span>B<span>&nbsp;&nbsp;</span>B</span>继承<span>C<span>&nbsp;&nbsp;</span>C</span>继承<span>D</span>。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">子父类出现后，类中的成员都有了哪些特点：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：成员变量。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;</span></span><span style="font-family:'宋体';">当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;</span></span><span style="font-family:'宋体';">如果想要调用父类中的属性值，需要使用一个关键字：<span style="font-weight:600;"><span style="color:#FF0000;">super</span></span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color:#FF0000;"><span>&nbsp;</span><span style="font-weight:600;">This</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">：</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">代表是本类类型的对象引用。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;</span><span style="color:#FF0000;">Super</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">：</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">代表是子类所属的父类中的内存空间引用。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;</span></span><span style="font-family:'宋体';">注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：成员函数。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：<span style="font-weight:600;"><span style="color:#FF0000;">覆盖</span><span>(</span>复写，重写<span>)</span></span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">3</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：构造函数。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">发现子类构造函数运行时，先运行了父类的构造函数。为什么呢<span>?</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">原因：<span style="color:#FF0000;">子类的<span style="font-weight:600;">所有构造函数中的第一行</span>，其实都有一条隐身的语句<span>super();</span></span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">super():&nbsp;</span></span><span style="font-family:'宋体';">表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而<span>super():</span>是在调用父类中空参数的构造函数。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">为什么子类对象初始化时，都需要调用父类中的函数？<span>(</span>为什么要在子类构造函数的第一行加入这个<span>super()?)</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是<span style="font-weight:600;">子类的实例化过程</span>。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">注意：</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句<span>super();</span></span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;"><span style="font-size:small;">如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过<span>super</span>语句指定要访问的父类中的构造函数。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;"><span style="font-size:small;">如果子类构造函数中用<span>this</span>来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">问题：<span>super()</span>和<span>this()</span>是否可以同时出现的构造函数中。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">两个语句只能有一个定义在第一行，所以只能出现其中一个。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">super()</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">或者<span>this():</span>为什么一定要定义在第一行？</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">因为<span>super()</span>或者<span>this()</span>都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">继承的细节：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">什么时候使用继承呢？</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">当类与类之间存在着所属关系时，才具备了继承的前提。<span>a</span>是<span>b</span>中的一种。<span>a</span>继承<span>b</span>。狼是犬科中的一种。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">英文书中，所属关系：<span>" is a "</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">注意：不要仅仅为了获取其他类中的已有成员进行继承。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">细节二：</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">在方法覆盖时，注意两点：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">1</span><span style="font-family:'宋体';">：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';">2</span><span style="font-family:'宋体';">：覆盖时，要么都静态，要么都不静态。<span>&nbsp;(</span>静态只能覆盖静态，或者被静态覆盖<span>)</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">这时如何解决问题呢？介绍一个关键字，<span style="font-weight:600;"><span>final</span></span><span>:</span>最终。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">final</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">特点：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：这个关键字是一个修饰符，可以修饰类，方法，变量。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：被<span>final</span>修饰的类是一个最终类，不可以被继承。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">3</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：被<span>final</span>修饰的方法是一个最终方法，不可以被覆盖。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">4</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：被<span>final</span>修饰的变量是一个常量，只能赋值一次。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">&nbsp;</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="font-family:'宋体';">其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span style="font-family:'宋体';">不加<span>final</span>修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了<span>final</span>，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用&nbsp;<span style="font-weight:600;"><span>_&nbsp;</span></span>连接。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">&nbsp;</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;font-size:14pt;">抽象类<span>:</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">&nbsp;</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;font-size:14pt;">abstract</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">抽象：不具体，看不明白。抽象类表象体现。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字<span>abstract</span>所标示，声明为抽象方法。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">抽象方法所在类一定要标示为抽象类，也就是说该类需要被<span>abstract</span>关键字所修饰。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">抽象类的特点：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由<span>abstract</span>关键字修饰（可以描述类和方法，不可以描述变量）。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：抽象方法只定义方法声明，并不定义方法实现。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">3</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：抽象类不可以被创建对象<span>(</span>实例化<span>)</span>。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">4</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">：只有通过子类继承抽象类并覆盖了抽象类中的</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">所有</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#0000FF;">抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">&nbsp;</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;"><span style="font-size:small;">抽象类的细节：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">1</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：抽象类中是否有构造函数？有，用于给子类对象进行初始化。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">2</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：抽象类中是否可以定义非抽象方法？</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-family:'宋体';">可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">3</span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">：抽象关键字<span>abstract</span>和哪些不可以共存？<span>final ,<span>&nbsp;</span>private , static</span></span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-weight:600;"><span style="font-family:'宋体';">4</span></span><span style="font-weight:600;"><span style="font-family:'宋体';">：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">-----------------------------------------------------------------------------------------------</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-weight:600;"><span style="font-family:'宋体';"><span style="font-size:small;">模板方法设计模式：</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">abstract class GetTime{</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>public&nbsp;<span style="font-weight:600;"><span style="color:#0000FF;">final</span></span>&nbsp;void getTime(){&nbsp;<span style="font-weight:600;"><span style="color:#FF0000;">//</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">此功能如果不需要复写，可加<span>final</span>限定</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>long start = System.currentTimeMillis();</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;"><span style="color:#FF0000;">code(); //</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">不确定的功能部分，提取出来，通过抽象方法实现</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>long end = System.currentTimeMillis();</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println("</span><span style="font-family:'宋体';">毫秒是：<span>"+(end-start));</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;"><span style="color:#FF0000;">public&nbsp;</span><span style="color:#0000FF;">abstract</span><span style="color:#FF0000;">&nbsp;void code(); //</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">抽象不确定的功能，让子类复写实现</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">class SubDemo extends GetTime{</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-size:small;"><span style="font-family:'宋体';"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-weight:600;">public void code()</span>{&nbsp;<span style="font-weight:600;"><span style="color:#FF0000;">//</span></span></span><span style="font-weight:600;"><span style="font-family:'宋体';color:#FF0000;">子类复写功能方法</span></span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>for(int y=0; y&lt;1000; y++){</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>System.out.println("y");</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>}</span></span></p>
    <p style="line-height:22.5px;letter-spacing:.5px;font-size:13px;color:rgb(51,51,51);font-family:'微软雅黑', Verdana, sans-serif, '宋体';"><span style="font-family:'宋体';"><span style="font-size:small;">}</span></span></p>
    <p><br></p>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
