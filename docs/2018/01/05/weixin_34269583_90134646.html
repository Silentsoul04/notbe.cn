<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>C++查缺补漏4，赶紧的 « NotBeCN</title>
  <meta name="description" content="             请说出const与#define 相比，有何优点？               答案：1）&nbsp;const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 &nbsp;&nb...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2018/01/05/weixin_34269583_90134646.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">C++查缺补漏4，赶紧的</h1>
    <p class="post-meta">Jan 5, 2018</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2 style="font-size:18px;letter-spacing:-1px;background-image:url(&quot;images/dotsH.gif&quot;);background-position:left bottom;background-repeat:repeat-x;font-weight:normal;line-height:21.6px;color:rgb(51,51,51);font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';">请说出const与#define 相比，有何优点？<br></h2> 
   <div class="entry" style="line-height:1.8;"> 
    <div class="blogpost-body" style="color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;">答案：</span><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;">1）&nbsp;<strong>const 常量有数据类型，而宏常量没有数据类型</strong>。编译器可以对前者进行类型<strong>安全检查</strong>。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2）&nbsp;<strong>有些集成化的调试工具可以对const 常量进行调试</strong>，但是不能对宏常量进行调试。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;">在8086 汇编下，逻辑地址和物理地址是怎样转换的？（Intel）</span><br><span style="line-height:1.8;">答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址*10H+通用寄存器内地址，就得到了真正要访问的地址。</span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;">当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）</span><br><span style="line-height:1.8;">答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。</span></span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;">&nbsp;描述内存分配方式以及它们的区别?</span><br><span style="line-height:1.8;">1）</span><strong>&nbsp;从静态存储区域分配</strong><span style="line-height:1.8;">。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如</span><strong>全局变量，static 变量</strong><span style="line-height:1.8;">。</span><br><span style="line-height:1.8;">2）&nbsp;</span><strong>在栈上创建</strong><span style="line-height:1.8;">。在执行函数时，</span><strong>函数内局部变量的存储单元都可以在栈上创建</strong><span style="line-height:1.8;">，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。</span><br><span style="line-height:1.8;">3）&nbsp;</span><strong>从堆上分配</strong><span style="line-height:1.8;">，</span><strong>亦称动态内存分配</strong><span style="line-height:1.8;">。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</span></span></span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;">&nbsp;main 函数执行以前，还会执行什么代码？</span><br><span style="line-height:1.8;">答案：全局对象的构造函数会在main 函数之前执行。</span></span></span></span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;">&nbsp;C++是不是类型安全的？</span><br><span style="line-height:1.8;">答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。</span></span></span></span></span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(51,0,255);font-family:'楷体_GB2312';font-size:medium;">有哪几种情况只能用intialization list 而不能用assignment?</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(51,0,255);font-family:'楷体_GB2312';font-size:medium;">答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(51,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;">define DOUBLE(x) x+x ，</span><span style="line-height:1.8;">i = 5*DOUBLE(5)； i 是多少？<br> 答案：i 为30</span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(51,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;">New delete 与malloc free 的联系与区别?</span><br><span style="line-height:1.8;">答案：都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor.</span></span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">1、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。<br> .#define Min(X, Y) ((X)&gt;(Y)?(Y):(X))//结尾没有;<br> 2、嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。<br> while(1){}或者for(;;)<br> 3、关键字static的作用是什么？<br> 定义静态变量<br> 4、关键字const有什么含意？<br> 表示常量不可以修改的变量。<br> 5、关键字volatile有什么含意？并举出三个不同的例子？<br> 提示编译器对象的值可能在编译器未监测到的情况下改变。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">int (*s[10])(int) 表示的是什么啊<br> int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">1.有以下表达式：<br> int a=248; b=4;int const c=21;const int *d=&amp;a;<br> int *const e=&amp;b;int const *f const =&amp;a;<br> 请问下列表达式哪些会被编译器禁止？为什么？<br> *c=32;d=&amp;b;*d=43;e=34;e=&amp;a;f=0x321f;<br> *c 这是个什么东东，禁止<br> *d 说了是const， 禁止<br> e = &amp;a 说了是const 禁止<br> const *f const =&amp;a; 禁止<br> 2.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;<br> 有两种解法, 一种用算术算法, 一种用^(异或)<br> a = a + b;<br> b = a - b;<br> a = a - b;&nbsp;<br> or<br> a = a^b;// 只能对int,char..<br> b = a^b;<br> a = a^b;<br> or<br> a ^= b ^= a;<br> 3.c和c++中的struct有什么不同？<br> c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private<br> 4.＃i nclude &lt;stdio.h&gt;<br> ＃i nclude &lt;stdlib.h&gt;<br> void getmemory(char *p)<br> {<br> &nbsp;&nbsp;&nbsp; p=(char *) malloc(100);<br> &nbsp;&nbsp;&nbsp; strcpy(p,"hello world");<br> }<br> int main( )<br> {<br> &nbsp;&nbsp;&nbsp; char *str=NULL;<br> &nbsp;&nbsp;&nbsp; getmemory(str);<br> &nbsp;&nbsp;&nbsp; printf("%s/n",str);<br> &nbsp;&nbsp;&nbsp; free(str);<br> &nbsp;&nbsp;&nbsp; return 0;<br> &nbsp;&nbsp; }<br> 程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险<br> 5.char szstr[10];<br> strcpy(szstr,"0123456789");<br> 产生什么结果？为什么？<br> 长度不一样，会造成非法的OS<br> 6.列举几种进程的同步机制，并比较其优缺点。<br> &nbsp;&nbsp; 原子操作&nbsp;<br> 信号量机制<br> &nbsp;&nbsp; 自旋锁<br> &nbsp;&nbsp; 管程，会合，分布式系统</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">7.进程之间通信的途径<br> 共享存储系统<br> 消息传递系统<br> 管道：以文件系统为基础<br> 11.进程死锁的原因<br> 资源竞争及进程推进顺序非法<br> 12.死锁的4个必要条件<br> 互斥、请求保持、不可剥夺、环路<br> 13.死锁的处理<br> 鸵鸟策略、预防策略、避免策略、检测与解除死锁<br> 15.&nbsp;&nbsp; 操作系统中进程调度策略有哪几种？<br> FCFS(先来先服务)，优先级，时间片轮转，多级反馈<br> 8.类的静态成员和非静态成员有何区别？<br> 类的静态成员每个类只有一个，非静态成员每个对象一个<br> 9.纯虚函数如何定义？使用时应注意什么？<br> virtual void f()=0;<br> 是接口，子类必须要实现<br> 10.数组和链表的区别<br> 数组：数据顺序存储，固定大小<br> 连表：数据可以随机存储，大小可动态改变</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">12.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？<br> 应用层<br> 表示层<br> 会话层<br> 运输层<br> 网络层<br> 物理链路层<br> 物理层<br> tcp /udp属于运输层<br> TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。<br> 与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。<br> tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好<br> udp: 不提供稳定的服务，包头小，开销小&nbsp;&nbsp;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">1：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针<br> .(void *)ptr 和 (*(void**))ptr值是相同的<br> 2：int main()<br> &nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp; int x=3;<br> &nbsp;&nbsp;&nbsp; printf("%d",x);<br> &nbsp;&nbsp;&nbsp; return 1;<br> &nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp; }<br> 问函数既然不会被其它函数调用，为什么要返回1？<br> mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">1，要对绝对地址0x100000赋值，我们可以用<br> (unsigned int*)0x100000 = 1234;<br> 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？<br> *((void (*)( ))0x100000 ) ( );<br> 首先要将0x100000强制转换成函数指针,即:<br> (void (*)())0x100000<br> 然后再调用它:<br> *((void (*)())0x100000)();<br> 用typedef可以看得更直观些:<br> typedef void(*)() voidFuncPtr;<br> *((voidFuncPtr)0x100000)();<br> 2，已知一个数组table，用一个宏定义，求出数据的元素个数<br> #define NTBL<br> #define NTBL (sizeof(table)/sizeof(table[0]))</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">面试题: 线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?<br> 进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">每个线程有自己的堆栈。<br> DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">unsigned short A = 10;<br> printf("~A = %u\n", ~A);</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">char c=128;&nbsp;<br> printf("c=%d\n",c);</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">输出多少？并分析过程<br> 第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285<br> 第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。<br> 这两道题都是在考察二进制向int或uint转换时的最高位处理。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">分析下面的程序：<br> void GetMemory(char **p,int num)<br> {<br> &nbsp;&nbsp;&nbsp; *p=(char *)malloc(num);<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> int main()<br> {<br> &nbsp;&nbsp;&nbsp; char *str=NULL;<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; GetMemory(&amp;str,100);<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; strcpy(str,"hello");<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; free(str);<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; if(str!=NULL)<br> &nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(str,"world");<br> &nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp; printf("\n str is %s",str);<br> &nbsp;&nbsp;&nbsp; getchar();<br> }&nbsp;&nbsp;&nbsp;&nbsp;<br> 问输出结果是什么？希望大家能说说原因，先谢谢了<br> 输出str is world。<br> free 只是释放的str指向的内存空间,它本身的值还是存在的.<br> 所以free之后，有一个好的习惯就是将str=NULL.<br> 此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,<br> 尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。<br> 这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。<br> 当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">char a[10],strlen(a)为什么等于15？运行的结果</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">＃i nclude "stdio.h"<br> ＃i nclude "string.h"</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">void main()<br> {</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">char aa[10];<br> printf("%d",strlen(aa));<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">sizeof()和初不初始化，没有关系；<br> strlen()和初始化有关。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/<br> char *str[20];/*str是一个指针数组，其元素为指针型数据．*/</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">long a=0x801010;<br> a+5=?<br> 0x801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，再加上5就是8392725罗</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">1)给定结构struct A&nbsp;<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char t:4;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char k:4;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short i:8;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long m;<br> };问sizeof(A) = ?<br> 给定结构struct A&nbsp;<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char t:4; 4位<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char k:4; 4位<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short i:8; 8位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long m; // 偏移2字节保证4字节对齐<br> }; // 共8字节<br> 2)下面的函数实现在一个数上加一个数，有什么错误？请改正。<br> int add_n ( int n )<br> {<br> &nbsp;&nbsp;&nbsp; static int i = 100;<br> &nbsp;&nbsp;&nbsp; i += n;<br> &nbsp;&nbsp;&nbsp; return i;<br> }<br> 当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 static上？</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">// 帮忙分析一下<br> ＃i nclude&lt;iostream.h&gt;<br> ＃i nclude &lt;string.h&gt;<br> ＃i nclude &lt;malloc.h&gt;<br> ＃i nclude &lt;stdio.h&gt;<br> ＃i nclude &lt;stdlib.h&gt;<br> ＃i nclude &lt;memory.h&gt;<br> typedef struct AA<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b1:5;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b2:2;<br> }AA;<br> void main()<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AA aa;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char cc[100];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz");<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy(&amp;aa,cc,sizeof(AA));<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; aa.b1 &lt;&lt;endl;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; aa.b2 &lt;&lt;endl;<br> }<br> 答案是 -16和１<br> 首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.<br> 经过strcpy和memcpy后,aa的4个字节所存放的值是:<br> 0,1,2,3的ASC码，即00110000,00110001,00110010,00110011<br> 所以，最后一步：显示的是这４个字节的前５位，和之后的２位<br> 分别为：10000,和01<br> 因为int是有正负之分　　所以：答案是-16和１</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">求函数返回值，输入x=9999;&nbsp;<br> int func （ x ）<br> {&nbsp;<br> &nbsp;&nbsp;&nbsp; int countx = 0;&nbsp;<br> &nbsp;&nbsp;&nbsp; while ( x )&nbsp;<br> &nbsp;&nbsp;&nbsp; {&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; countx ++;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = x&amp;(x-1);&nbsp;<br> &nbsp;&nbsp;&nbsp; }&nbsp;<br> &nbsp;&nbsp;&nbsp; return countx;&nbsp;<br> }&nbsp;<br> 结果呢？<br> 知道了这是统计9999的二进制数值中有多少个1的函数，且有<br> 9999＝9×1024＋512＋256＋15</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">9×1024中含有1的个数为2；<br> 512中含有1的个数为1；<br> 256中含有1的个数为1；<br> 15中含有1的个数为4；<br> 故共有1的个数为8，结果为8。<br> 1000 - 1 = 0111，正好是原数取反。这就是原理。<br> 用这种方法来求1的个数是很效率很高的。<br> 不必去一个一个地移位。循环次数最少。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题<br> bool add (int a, int b,int *c)<br> {<br> *c=a+b;<br> return (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp;(*c&lt;a || *c&lt;b) || (a&lt;0 &amp;&amp; b&lt;0 &amp;&amp;(*c&gt;a || *c&gt;b)));<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">分析：<br> struct bit&nbsp;<br> {&nbsp;&nbsp; int a:3;&nbsp;<br> &nbsp;&nbsp;&nbsp; int b:2;&nbsp;<br> &nbsp;&nbsp;&nbsp; int c:3;&nbsp;<br> };&nbsp;<br> int main()&nbsp;<br> {&nbsp;<br> bit s;&nbsp;<br> char *c=(char*)&amp;s;&nbsp;<br> &nbsp;&nbsp; cout&lt;&lt;sizeof(bit)&lt;&lt;endl;<br> *c=0x99;<br> &nbsp;&nbsp; cout &lt;&lt; s.a &lt;&lt;endl &lt;&lt;s.b&lt;&lt;endl&lt;&lt;s.c&lt;&lt;endl;&nbsp;<br> &nbsp;&nbsp;&nbsp;&nbsp; int a=-1;<br> &nbsp;&nbsp; printf("%x",a);<br> return 0;&nbsp;<br> }&nbsp;<br> 输出为什么是<br> 4<br> 1<br> -1<br> -4<br> ffffffff<br> 因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100<br> 当c为有符合数时, c = 100, 最高1为表示c为负数，负数在计算机用补码表示，所以c = -4;同理&nbsp;<br> b = -1;<br> 当c为有符合数时, c = 100,即 c = 4,同理 b = 3</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">位域 ：&nbsp;&nbsp;&nbsp;<br> 有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> struct 位域结构名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> { 位域列表 };&nbsp;&nbsp;&nbsp;&nbsp;<br> 其中位域列表的形式为： 类型说明符 位域名：位域长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> 例如：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> struct bs&nbsp;&nbsp;&nbsp;&nbsp;<br> {&nbsp;&nbsp;&nbsp;&nbsp;<br> int a:8;&nbsp;&nbsp;&nbsp;&nbsp;<br> int b:2;&nbsp;&nbsp;&nbsp;&nbsp;<br> int c:6;&nbsp;&nbsp;&nbsp;&nbsp;<br> };&nbsp;&nbsp;&nbsp;&nbsp;<br> 位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> struct bs&nbsp;&nbsp;&nbsp;&nbsp;<br> {&nbsp;&nbsp;&nbsp;&nbsp;<br> int a:8;&nbsp;&nbsp;&nbsp;&nbsp;<br> int b:2;&nbsp;&nbsp;&nbsp;&nbsp;<br> int c:6;&nbsp;&nbsp;&nbsp;&nbsp;<br> }data;&nbsp;&nbsp;&nbsp;&nbsp;<br> 说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：&nbsp;&nbsp;&nbsp;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> struct bs&nbsp;&nbsp;&nbsp;&nbsp;<br> {&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned a:4&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned :0 /*空域*/&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned b:4 /*从下一单元开始存放*/&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned c:4&nbsp;&nbsp;&nbsp;&nbsp;<br> }&nbsp;&nbsp;&nbsp;&nbsp;<br> 在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。&nbsp;&nbsp;&nbsp;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。&nbsp;&nbsp;&nbsp;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">3. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> struct k&nbsp;&nbsp;&nbsp;&nbsp;<br> {&nbsp;&nbsp;&nbsp;&nbsp;<br> int a:1&nbsp;&nbsp;&nbsp;&nbsp;<br> int :2 /*该2位不能使用*/&nbsp;&nbsp;&nbsp;&nbsp;<br> int b:3&nbsp;&nbsp;&nbsp;&nbsp;<br> int c:2&nbsp;&nbsp;&nbsp;&nbsp;<br> };&nbsp;&nbsp;&nbsp;&nbsp;<br> 从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。&nbsp;&nbsp;&nbsp;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名•位域名 位域允许用各种格式输出。&nbsp;&nbsp;&nbsp;&nbsp;<br> main(){&nbsp;&nbsp;&nbsp;&nbsp;<br> struct bs&nbsp;&nbsp;&nbsp;&nbsp;<br> {&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned a:1;&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned b:3;&nbsp;&nbsp;&nbsp;&nbsp;<br> unsigned c:4;&nbsp;&nbsp;&nbsp;&nbsp;<br> } bit,*pbit;&nbsp;&nbsp;&nbsp;&nbsp;<br> bit.a=1;&nbsp;&nbsp;&nbsp;&nbsp;<br> bit.b=7;&nbsp;&nbsp;&nbsp;&nbsp;<br> bit.c=15;&nbsp;&nbsp;&nbsp;&nbsp;<br> pri</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">改错：<br> ＃i nclude &lt;stdio.h&gt;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">int main(void) {</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">&nbsp;&nbsp;&nbsp; int **p;<br> &nbsp;&nbsp;&nbsp; int arr[100];</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">&nbsp;&nbsp;&nbsp; p = &amp;arr;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">&nbsp;&nbsp;&nbsp; return 0;<br> }<br> 解答：<br> 搞错了,是指针类型不同,<br> int **p; //二级指针<br> &amp;arr; //得到的是指向第一维为100的数组的指针<br> ＃i nclude &lt;stdio.h&gt;<br> int main(void) {<br> int **p, *q;<br> int arr[100];<br> q = arr;<br> p = &amp;q;<br> return 0;<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">下面这个程序执行后会有什么错误或者效果:<br> #define MAX 255<br> int main()<br> {<br> &nbsp;&nbsp; unsigned char A[MAX],i;//i被定义为unsigned char<br> &nbsp;&nbsp; for (i=0;i&lt;=MAX;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A[i]=i;<br> }<br> 解答：死循环加数组越界访问（C/C++不进行数组越界检查）<br> MAX=255&nbsp;<br> 数组A的下标范围为:0..MAX-1,这是其一..<br> 其二.当i循环到255时,循环内执行:<br> A[255]=255;<br> 这句本身没有问题..但是返回for (i=0;i&lt;=MAX;i++)语句时,<br> 由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">struct name1{<br> &nbsp;&nbsp; char str;<br> &nbsp;&nbsp; short x;<br> &nbsp;&nbsp; int&nbsp;&nbsp; num;<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">struct name2{<br> &nbsp;&nbsp; char str;<br> &nbsp;&nbsp; int num;<br> &nbsp;&nbsp; short x;<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">sizeof(struct name1)=8,sizeof(struct name2)=12<br> 在第二个结构中，为保证num按四个字节对齐，char后必须留出3字节的空间；同时为保证整个结构的自然对齐（这里是4字节对齐），在x后还要补齐2个字节，这样就是12字节。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">intel：<br> A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?<br> static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。<br> 他们都放在数据区，但是编译器对他们的命名是不同的。<br> 如果要使变量在其他模块也有意义的话，需要使用extern关键字。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">struct s1<br> {<br> int i: 8;<br> int j: 4;<br> int a: 3;<br> double b;<br> };</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">struct s2<br> {<br> int i: 8;<br> int j: 4;<br> double b;<br> int a:3;<br> };</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">printf("sizeof(s1)= %d\n", sizeof(s1));<br> printf("sizeof(s2)= %d\n", sizeof(s2));<br> result: 16, 24<br> 第一个struct s1<br> {<br> int i: 8;<br> int j: 4;<br> int a: 3;<br> double b;<br> };<br> 理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于double是8字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">上面是基本问题，接下来是编程问题：</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><br><span style="line-height:1.8;color:rgb(72,34,221);">本人很弱，这几个题也搞不定，特来求救：<br> 1）读文件file1.txt的内容（例如）：<br> 12<br> 34<br> 56<br> 输出到file2.txt：<br> 56<br> 34<br> 12<br> （逆序）<br> 2）输出和为一个给定整数的所有组合<br> 例如n=5<br> 5=1+4；5=2+3（相加的数不能重复）<br> 则输出<br> 1，4；2，3。<br> 望高手赐教！！</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">第一题,注意可增长数组的应用.<br> ＃i nclude &lt;stdio.h&gt;<br> ＃i nclude &lt;stdlib.h&gt;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">int main(void)<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int MAX = 10;<br> int *a = (int *)malloc(MAX * sizeof(int));<br> int *b;<br> &nbsp;&nbsp;&nbsp;&nbsp;<br> FILE *fp1;<br> FILE *fp2;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">fp1 = fopen("a.txt","r");<br> if(fp1 == NULL)<br> {printf("error1");<br> &nbsp;&nbsp;&nbsp; exit(-1);<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">&nbsp;&nbsp;&nbsp; fp2 = fopen("b.txt","w");<br> if(fp2 == NULL)<br> {printf("error2");<br> &nbsp;&nbsp;&nbsp; exit(-1);<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">int i = 0;<br> &nbsp;&nbsp;&nbsp; int j = 0;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">while(fscanf(fp1,"%d",&amp;a[i]) != EOF)<br> {<br> i++;<br> j++;<br> if(i &gt;= MAX)<br> {<br> MAX = 2 * MAX;<br> b = (int*)realloc(a,MAX * sizeof(int));<br> if(b == NULL)<br> {<br> printf("error3");<br> exit(-1);<br> }<br> a = b;<br> }<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">for(;--j &gt;= 0;)<br> &nbsp;&nbsp; fprintf(fp2,"%d\n",a[j]);</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">fclose(fp1);<br> fclose(fp2);</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">return 0;<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">第二题.<br> ＃i nclude &lt;stdio.h&gt;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">int main(void)<br> {<br> unsigned long int i,j,k;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">printf("please input the number\n");<br> scanf("%d",&amp;i);<br> &nbsp;&nbsp;&nbsp; if( i % 2 == 0)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = i / 2;<br> else<br> j = i / 2 + 1;</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">printf("The result is \n");<br> &nbsp;&nbsp;&nbsp; for(k = 0; k &lt; j; k++)<br> &nbsp;&nbsp;&nbsp;&nbsp; printf("%d = %d + %d\n",i,k,i - k);<br> return 0;<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">＃i nclude &lt;stdio.h&gt;<br> void main()<br> {<br> unsigned long int a,i=1;<br> scanf("%d",&amp;a);<br> if(a%2==0)<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp; for(i=1;i&lt;a/2;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp; printf("%d",a,a-i);<br> }<br> else<br> for(i=1;i&lt;=a/2;i++)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(" %d, %d",i,a-i);<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">兄弟,这样的题目若是做不出来实在是有些不应该, 给你一个递规反向输出字符串的例子,可谓是反序的经典例程.</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">void inverse(char *p)<br> {<br> &nbsp;&nbsp;&nbsp; if( *p = = '\0' )&nbsp;<br> return;<br> &nbsp;&nbsp;&nbsp; inverse( p+1 );<br> &nbsp;&nbsp;&nbsp; printf( "%c", *p );<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">int main(int argc, char *argv[])<br> {<br> &nbsp;&nbsp;&nbsp; inverse("abc\0");</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">&nbsp;&nbsp;&nbsp; return 0;<br> }</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;">&nbsp;</p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(72,34,221);">借签了楼上的“递规反向输出”<br> ＃i nclude &lt;stdio.h&gt;<br> void test(FILE *fread, FILE *fwrite)<br> {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buf[1024] = {0};<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!fgets(buf, sizeof(buf), fread))<br> &nbsp;&nbsp;&nbsp;&nbsp; &amp;nb</span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(51,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;"><br></span></span></span></p> 
     <p style="line-height:1.8;font-family:Merriweather, Georgia, '微软雅黑', '黑体', '宋体';font-size:15px;"><span style="line-height:1.8;color:rgb(0,0,255);font-family:'楷体_GB2312';font-size:medium;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;"><span style="line-height:1.8;"><br></span></span></span></span></span></span></p> 
    </div> 
    <div style="color:rgb(51,51,51);font-family:Georgia, 'Times New Roman', Times, sans-serif;font-size:14px;"> 
     <br> ==============================================================================
    </div> 
    <div> 
     <font color="#333333"><span style="font-size:14px;">本文转自被遗忘的博客园博客，原文链接：http://www.cnblogs.com/rollenholt/archive/2012/03/28/2422454.html，如需转载请自行联系原作者</span></font>
     <br>
    </div> 
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
