<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>java常见面试题及答案 1-10（JVM） « NotBeCN</title>
  <meta name="description" content="             java常见面试题及答案原文地址http://www.bieryun.com/549.html     1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？         Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 J...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2018/01/17/weixin_34146986_90132441.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">java常见面试题及答案 1-10（JVM）</h1>
    <p class="post-meta">Jan 17, 2018</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <h2>java常见面试题及答案原文地址<a href="http://www.bieryun.com/549.html" rel="nofollow" title="http://www.bieryun.com/549.html">http://www.bieryun.com/549.html</a> </h2> 
   <h3>1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3> 
   <blockquote> 
    <p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。<br> Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。<br> Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p> 
   </blockquote> 
   <p><img class="alignnone size-full wp-image-519" src="http://www.bieryun.com/wp-content/uploads/2018/01/java.jpg" alt="" width="591" height="275"></p> 
   <h3>2.JDK和JRE的区别是什么？</h3> 
   <blockquote> 
    <p><em>JDK:</em> java开发工具包,包含了JRE、编译器和其它工具（如：javaDOc、java调试器)<br><em>JRE:</em> java运行环境,包含java虚拟机和java程序所需的核心类库。<br> 如果只是想跑java程序，那么只需安装JRE，如果要写java程序并且运行，那就需要JDK了。</p> 
   </blockquote> 
   <h3>3.”static”关键字是什么意思？Java中是否可以覆盖一个private或者是static的方法？</h3> 
   <blockquote> 
    <p>如果一个类的变量或者方法前面有<strong>static</strong>修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用<br> 当父类的方法被<strong>private</strong>修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该“覆盖方法”，会产生编译错误</p> 
   </blockquote> 
   <pre class="prettyprint"><code class="has-numbering">class Parent {
    private fun() {
        ...
    }   
}
class Child extends Parent {
    private fun() {
        ...
    }
}
class Test {
    public static void main(String[] args) {
        Parent c = new Child();
        c.fun(); //编译出错
    }
}</code></pre> 
   <blockquote> 
    <p><strong>static</strong>方法时编译时静态绑定的，属于类，而覆盖是运行时动态绑定的(动态绑定的多态),因此不能覆盖.</p> 
   </blockquote> 
   <h3>4.Java支持的基本数据类型有哪些？什么是自动拆装箱？</h3> 
   <blockquote> 
    <p>java支持的基本数据类型有以下9种:byte,shot,int,long,float,double,char,boolean,void.<br> 自动拆装箱是java从jdk1.5引用，目的是将原始类型自动的装换为相对应的对象，也可以逆向进行，即拆箱。这也体现java中一切皆对象的宗旨。<br> 所谓自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。java中的自动拆装箱通常发生在变量赋值的过程中，如：</p> 
   </blockquote> 
   <pre class="prettyprint"><code class="has-numbering">    Integer object = 3; //自动装箱
    int o = object; //拆箱</code></pre> 
   <blockquote> 
    <p>在java中，应该注意自动拆装箱，因为有时可能因为java自动装箱机制，而导致创建了许多对象，对于内存小的平台会造成压力。</p> 
   </blockquote> 
   <h3>覆盖和重载是什么?</h3> 
   <blockquote> 
    <p><strong>覆盖</strong>也叫<strong>重写</strong>，发生在子类与父类之间，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。<br><strong>重载</strong>是指在一个类中，可以有多个相同名称的方法，但是他们的参数列表的个数或类型不同，当调用该方法时，根据传递的参数类型调用对应参数列表的方法。当参数列表相同但返回值不同时，将会出现编译错误，这并不是重载，因为jvm无法根据返回值类型来判断应该调用哪个方法。</p> 
   </blockquote> 
   <h3>5.Java支持多继承么？如果不支持，如何实现?</h3> 
   <blockquote> 
    <p>在java中是单继承的，也就是说一个类只能继承一个父类。<br> java中实现多继承有两种方式,一是接口，而是内部类.</p> 
   </blockquote> 
   <pre class="prettyprint"><code class="has-numbering">//实现多个接口 如果两个接口的变量相同 那么在调用该变量的时候 编译出错
interface interface1 {
    static String field = "dd"; 
    public void fun1();
    }
interface interface2 {
static String field = "dddd";
    public void fun2();
    }
class child implements interface1,interface2 {
    static String field = "dddd";
    @Override
    public void fun2() {
    }

    @Override
    public void fun1() {
    }   
}

//内部类 间接多继承
class Child {
class Father {
    private void strong() {
        System.out.println("父类");
    }
}
class Mother {
    public void getCute() {
        System.out.println("母亲");
    }
}
public void getStrong() {
    Father f = new Father();
    f.strong();
    }
public void getCute() {
    Mother m = new Mother();
    m.getCute();
    }
}</code></pre> 
   <h3>6.什么是值传递和引用传递？java中是值传递还是引用传递，还是都有?</h3> 
   <blockquote> 
    <p><strong>值传递</strong> 就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参，常见的例子就是刚开始学习c语言的时候那个交换方法的例子了。<br><strong>引用传递</strong> 是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。<br> 在java中只有一种传递方式，那就是<strong>值传递</strong>.可能比较让人迷惑的就是java中的对象传递时，对形参的改变依然会意向到该对象的内容。 <br> 下面这个例子来说明java中是值传递.</p> 
   </blockquote> 
   <pre class="prettyprint"><code class="has-numbering">    public class Test {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("hello ");
        getString(sb);
        System.out.println(sb);
    }
    public static void getString(StringBuffer s) {
        //s = new StringBuffer("ha");
        s.append("world");
    }
}</code></pre> 
   <blockquote> 
    <p>在上面这个例子中,当前输出结果为:hello world。这并没有什么问题，可能就是大家平常所理解的引用传递，那么当然会改变StringBuffer的内容。但是如果把上面的注释去掉，那么就会输出:hello.此时sb的值并没有变成ha hello. 假如说是引用传递的话，那么形参的s也就是sb的地址，此时在方法里new StringBuffer（），并将该对象赋给s，也就是说s现在指向了这个新创建的对象.按照引用传递的说法，此时对s的改变就是对sb的操作，也就是说sb应该也指向新创建的对象，那么输出的结果应该为ha world.但实际上输出的仅是hello.这说明sb指向的还是原来的对象，而形参s指向的才是创建的对象,这也就验证了java中的对象传递也是值传递。</p> 
   </blockquote> 
   <h3>7.接口和抽象类的区别是什么?</h3> 
   <blockquote> 
    <p>不同点在于：</p> 
    <ol>
     <li> <p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p> </li> 
     <li> <p>类可以实现很多个接口，但是只能继承一个抽象类</p> </li> 
     <li> <p>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p> </li> 
     <li> <p>抽象类可以在不提供接口方法实现的情况下实现接口。</p> </li> 
     <li> <p>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。</p> </li> 
     <li> <p>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。</p> </li> 
     <li> <p>接口是绝对抽象的，不可以被实例化(java 8已支持在接口中实现默认的方法)。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。</p> </li> 
    </ol>
   </blockquote> 
   <h3>8.构造器（constructor）是否可被重写（override）?</h3> 
   <blockquote> 
    <p>构造方法是不能被子类重写的，但是构造方法可以重载，也就是说一个类可以有多个构造方法。</p> 
   </blockquote> 
   <h3>9.Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?</h3> 
   <blockquote> 
    <p>Math.round(11.5)==12 Math.round(-11.5)==-11 round 方法返回与参数 最接近的长整数，参数加 1/2 后求其 floor.</p> 
   </blockquote> 
   <h3>10. String, StringBuffer StringBuilder的区别。</h3> 
   <blockquote> 
    <p>tring 的长度是不可变的；</p> 
    <p>StringBuffer的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer，如果最后需要 &gt;String，那么使用 StringBuffer 的 toString() 方法；线程安全；</p> 
    <p>StringBuilder 是从 JDK 5 开始，为StringBuffer该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因&gt;为它支持所有相同的操作，但由于它不执行同步，所以速度更快。 <br> 使用字符串的时候要特别小心，如果对一个字符串要经常改变的话，就一定不要用String,否则会创建许多无用的对象出来. <br> 来看一下比较</p> 
   </blockquote> 
   <pre class="prettyprint"><code class="has-numbering">String s = "hello"+"world"+"i love you";
StringBuffer Sb = new StringBuilder("hello").append("world").append("i love you");</code></pre> 
   <blockquote> 
    <p>这个时候s有多个字符串进行拼接，按理来说会有多个对象产生，但是jvm会对此进行一个优化，也就是说只创建了一个对象，此时它的执行速度要比StringBuffer拼接快.再看下面这个:</p> 
   </blockquote> 
   <pre class="prettyprint"><code class="has-numbering">String s2 = "hello";  
String s3 = "world";  
String s4 = "i love you";  
String s1 = s2 + s3 + s4;</code></pre> 
   <blockquote> 
    <p>上面这种情况，就会多创建出来三个对象，造成了内存空间的浪费.</p> 
   </blockquote> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
