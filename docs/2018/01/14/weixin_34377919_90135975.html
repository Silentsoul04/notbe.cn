<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>《逆向分析实战》数据的存储及表示形式 « NotBeCN</title>
  <meta name="description" content="             学习过计算机的读者都知道，计算机中的各种数据都是以二进制形式进行存储的，无论是文本文件、图片文件，还是音频文件、视频文件、可执行文件等，统统都是由二进制文件存储的。学习过计算机的读者在学习计算机基础的时候一定学习过进制转换，也一定学习过数据的表示方式等，大部分人在学习这部分知识时会觉得枯...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2018/01/14/weixin_34377919_90135975.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">《逆向分析实战》数据的存储及表示形式</h1>
    <p class="post-meta">Jan 14, 2018</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="content-detail markdown-body"> 
   <p>学习过计算机的读者都知道，计算机中的各种数据都是以二进制形式进行存储的，无论是文本文件、图片文件，还是音频文件、视频文件、可执行文件等，统统都是由二进制文件存储的。学习过计算机的读者在学习计算机基础的时候一定学习过进制转换，也一定学习过数据的表示方式等，大部分人在学习这部分知识时会觉得枯燥、无用，但是对于学习逆向知识和使用逆向工具，数据的存储及表示形式是必须要掌握的。<br>本文借助OllyDbg这款调试工具来一起讨论数据的存储及表示形式，让读者对于学习计算机的数据存储及表示可以更加的感性，从而脱离纯粹理论性的学习。</p> 
   <p>本文内容较为枯燥，但是着实是学习逆向的基础知识，对于从来没有接触过逆向或者是刚开始接触逆向的读者，本文内容还是有一定帮助的。</p> 
   <p>本文关键字：进制 数据表示 数据转换 数据存储</p> 
   <h1>1.1　进制及进制的转换</h1> 
   <p>了解进制的概念及进制的转换是学习逆向的基础，因为计算机使用的进制是二进制，它又不同于我们现实生活中使用的十进制，因此我们必须学习不同的进制及进制之间的转换。<br>1.1.1　现实生活中的进制与计算机的二进制<br>我们在现实生活中会接触到多种多样的进制，通常见到的有十进制、十二进制和二十四进制等。下面分别对这几种进制进行举例说明。</p> 
   <p>十进制是每个人从上学就开始接触和学习的进制表示方法。所谓的十进制，就是逢十进一，最简单的例子就是9+1=10。这个无需过多解释。</p> 
   <p>十二进制也是我们日常生活中常见的表示方法。所谓的十二进制，就是逢十二进一，例如12个月为1年，13个月就是1年1个月。</p> 
   <p>二十四进制也是我们日常生活中常见的表示方法。所谓的二十四进制，就是逢二十四进一，例如24小时为1天，25小时就是1天1小时。</p> 
   <p>介绍了以上现实生活中的例子后，我们再来说说计算机中的二进制。根据前面各种进制的解释，我们可以想到，二进制就是逢二进一。这里举个不太恰当的例子，例如2斤就是1公斤。</p> 
   <p>在计算机中为什么使用二进制呢？简单说就是计算机用高电平和低电平来表示1和0最为方便和稳定，高电平被认为是1，低电平被认为是0，这就是所谓的二进制的来源。</p> 
   <p>由于二进制在阅读上不方便，计算机又引入了十六进制来直观地表示二进制。所谓的十六进制，就是逢十六进一。</p> 
   <p>因此在计算机中，我们常见的数据表示方法有二进制、十进制和十六进制。</p> 
   <p><strong>1.1.2　进制的定义</strong><br>在学习小学数学的时候我们就学习了十进制，十进制一共有十个数字，从0一直到9，9再往后数一个的时候要产生进位，也就是逢十进一。总结十进制的定义则是，由0到9十个数字组成，并且逢十进一。</p> 
   <p>举一反一地来说，二进制的定义是，由0到1两个数字组成，逢二进一。十六进制的定义是由0到9十个数字和A到F六个字母组成，逢十六进一。</p> 
   <p>由此，我们衍生出N进制的定义是，由N个符号组成，逢N进一。</p> 
   <p>表1-1所列为这三种进制的数字表。<br>表1-1　　二进制、十进制和十六进制数字表<br><img src="https://yqfile.alicdn.com/7ab6a5fa52232937345f1a9082277606f7403966.png" alt="01" title="01"><br><strong>1.1.3　进制的转换</strong><br>在逆向当中，我们直接面对的通常是十六进制，而由于很多原因，我们需要将其当作十进制或二进制来查看，当然也有可能需要根据二进制转换成十六进制或十进制。所以，我们就需要掌握进制之间的转换。<br>**<br>1．二进制转十进制**<br>二进制整数的每个位都是2的幂次方，最低位是2的0次方，最高为是2的（N-1）次方，我们通过一个例子进行说明。我们把二进制数10010011转换成十进制数，计算方式如下：</p> 
   <p>10010011 = 1 × 27 + 0 × 26 + 0 × 25 + 1 × 24 + 0 × 23 + 0 × 22 + 1 × 21 + 1 × 20 = 128 + 0 + 0 +16 + 0 + 0 + 2 + 1 = 147</p> 
   <p>我们得出的结果是，把二进制10010011转换成十进制后是147。我们用计算机进行验算，如图1-1和图1-2所示。</p> 
   <p>从图1-1和图1-2中可以看出，我们的计算结果是正确的，由此读者在计算二进制时按照上面转换的例子进行转换即可。<br><img src="https://yqfile.alicdn.com/1424eae11e1e23a40b2363748044f8c9beb4806d.png" alt="02" title="02"><br>图1-1　验算二进制（一）<br><img src="https://yqfile.alicdn.com/beab177d4bdb86da74dbd19c944ed074a924afd2.png" alt="03" title="03"><br>图1-2　验算二进制（二）<br>2．十六进制与二进制的转换<br>由于一个简单的数值用二进制表示需要很长的位数，这样对于阅读很不方便，因此汇编和调试器常用十六进制表示二进制。十六进制的每个位可以代表4个二进制位，因为2的4次方刚好是16。这样，在二进制与十六进制之间就产生了一个很好的对应关系，如表1-2所列。</p> 
   <p>表1-2　　二进制对应的十六进制与十进制数<br><img src="https://yqfile.alicdn.com/0226ebcdffed852bb82a256ecacb29385dbcd526.png" alt="04" title="04"><br>根据此表，我们可以很快地把二进制和十六进制进行转换，把上例的二进制10010011转换成十六进制，转换过程如下：</p> 
   <p>第一步，把10010011从最低开始按每四位分为一组，不足四位前面补0，划分结果为1001 0011；</p> 
   <p>第二步，把划分好的组进行查表，1001对应十六进制是9，0011对应的十六进制是3。</p> 
   <p>那么，二进制10010011转换成十六进制后的值是93。读者可以通过计算器自行进行验算。</p> 
   <p>在逆向中常用的就是二进制与十进制的转换，或者是二进制与十六进制的转换，其他的转换方式读者可以自行查找资料进行学习。关于十六进制和二进制需要记住的重要一点就是，一位十六进制数可以表示四位二进制数。</p> 
   <h1>1.2　数据宽度、字节序和ASCII码</h1> 
   <p>前面介绍了计算机中常用的进制表示方法和转换，现在读者知道了计算机存储的都是二进制的数据，那么接下来要讨论的是在计算机中数据存储的单位以及数据是如何存储在存储空间的。<br>1.2.1　数据的宽度<br>数据的宽度是指数据在存储器中存储的尺寸。在计算机中，所有数据的基本存储单位都是字节（byte），每个字节占8个位（位是计算机存储的最小单位，而不是基本单位，因为在存储数据时几乎没有按位进行存储的）。其他的存储单位还有字（word）、双字（dword）和八字节（qword）。<br><img src="https://yqfile.alicdn.com/1cd853c303ad95baf94ea9cc49b163540b0d779b.png" alt="05" title="05"><br>图1-3 给出各个存储单位所包含的位数。</p> 
   <p>在计算机编程中，常用的几个重要数据存储单位分别就是byte、word和dword，这几个存储单位稍后我们会使用到。</p> 
   <p><strong>1.2.2　数值的表示范围</strong><br>在计算机中存储数值时，也是要依据前面介绍过的数据宽度进行存储的，那么在存储数据时由于存储数据的宽度限制，数值的表示也是有范围限制的。那么byte、word和dword能存储多少数据呢？我们先来计算一下，如果按位存储的话，能存储多少个数据，再分别来计算以上三种单位能够存储的数值的范围。</p> 
   <p>计算机使用二进制进行数据存储时，一位二进制最多能表示几个数呢？因为是二进制数，只存在0和1两个数，所以一位二进制数最多能表示两个数，分别是0和1。那么，两位二进制最多能表示几个数呢？因为一位二进制数能表示两个数，所以两位二进制数则能表示2的2次方个数，即4个数，分别是0、1、10、11。进一步地，三位二进制数能表示的就是2的3次方个数，即8个数，分别是0、1、10、11、100、101、110、111。</p> 
   <p>上面的过程可以整理成表1-3。</p> 
   <p>表1-3　　N位二进制位能够表示的数<br><img src="https://yqfile.alicdn.com/cd948d6e0d02e90e1ad2d659f624c221acad9253.png" alt="06" title="06"><br>根据表1-3计算的byte、word和dword三种数据存储宽度能表示的数据的范围如表1-4所列。<br>根据表1-3计算的byte、word和dword三种数据存储宽度能表示的数据的范围如表1-4所列。<br><img src="https://yqfile.alicdn.com/a27755eb650a41441c938d5b3332c8d78df7f66d.png" alt="07" title="07"><br>2的8次方是256，为什么数值只有0～255个呢？因为计算机计数是从0开始，从0到255同样是256个数，这里的2的8次方表示能够表示数值的个数，而不是能够表示数值的最大的数。</p> 
   <p><strong>1.2.3　字节序</strong><br>字节序也称为字节顺序，在计算机中对数值的存储有一定的标准，而该标准随着系统架构的不同而不同。了解字节存储顺序对于逆向工程是一项基础知识，在动态分析程序的时候，往往需要观察内存数据的变化情况，这就需要我们在掌握数据的存储宽度、范围之后，进一步了解字节顺序。</p> 
   <p>通常情况下，数值在内存中存储的方式有两种，一种是大尾方式，另一种是小尾方式。关于字节序的知识，通过一个简单的例子就可以掌握。</p> 
   <p>比如有0x01020304（C语言中对十六进制数的表示方式）这样一个数值，如果用大尾方式存储，其存储方式为01 02 03 04，而用小尾方式进行存储则是04 03 02 01，用更直观的方式展示其区别，如表1-5所列。</p> 
   <p>表1-5　　字节顺序对比表<br><img src="https://yqfile.alicdn.com/6f8557a13620cfb4ee02b648dc923d6e3d93cf8d.png" alt="08" title="08"><br>从两个地址列可以看出，地址的值都是一定的，没有变化，而数据的存储顺序却是不相同的。从表中可以得到如下结论。</p> 
   <p>大尾存储方式：内存高位地址存放数据低位字节数据，内存低位地址存放数据高位字节数据；</p> 
   <p>小尾存储方式：内存高位地址存放数据高位字节数据，内存低位地址存放数据低位字节数据。</p> 
   <p>通常情况下，Windows操作系统兼容的CPU为小尾存储方式，而Unix操作系统兼容的CPU多为大尾存储方式。在网络中传输的数据的字节顺序使用的是大尾存储方式。</p> 
   <p><strong>1.2.4　ASCII码</strong><br>计算机智能存储二进制数据，那么计算机是如何存储字符的呢？为了存储字符，计算机必须支持特定的字符集，字符集的作用是将字符映射为整数。早期字符集仅仅使用8个二进制数据位进行存储，即ASCII码。后来，由于全世界语言的种类繁多，又产生了新的字符集Unicode字符编码。</p> 
   <p>ASCII码是美国标准信息交换码的字母缩写，在ASCII字符集中，每个字符由唯一的7位整数表示。ASCII码仅使用了每个字节的低7位，最高位被不同计算机用来创建私有字符集。由于标准ASCII码仅使用7位，因此十进制表示范围是0～127共128个字符。</p> 
   <p>在编程与逆向中都会用到ASCII码，因此有必要记住常用的ASCII字符对应的十六进制和十进制数。常用的ASCII字符如表1-6所列。</p> 
   <p>表1-6　　常用ASCII码表<br><img src="https://yqfile.alicdn.com/1e86844fffaa73f730c71a3d97a783cdc114961a.png" alt="9" title="9"><br>表1-6是经常使用到的ASCII字符，这些字符是经常会见到和用到的，希望读者能将其保存，以便使用之时可以快速查阅。</p> 
   <p>Unicode编码是为了使字符编码更进一步符合国际化而进行的扩展，Unicode使用一个字（也就是两个字节，即16位）来表示一个字符。这里不做过多的介绍。</p> 
   <h1>1.3　在OD中查看数据</h1> 
   <p>在逆向分析中，调试工具可以说是非常重要的。调试器能够跟踪一个进程的运行时状态，在逆向分析中称为动态分析工具。动态调试会用在很多方面，比如漏洞的挖掘、游戏外挂的分析、软件加密解密等方面。本节介绍应用层下最流行的调试工具OllyDbg。<br>OllyDbg简称OD，是一款具有可视化界面的运行在应用层的32位的反汇编逆向调试分析工具。OD是所有进行逆向分析人员都离不开的工具。它的流行，主要原因是操作简单、参考文档丰富、支持插件功能等。</p> 
   <p>熟悉OD</p> 
   <p>OD的操作非常简单，但是由于逆向是一门实战性和综合性非常强的技术，因此要真正熟练掌握OD的使用却并不是容易的事，单凭操作而言看似没有太多的技术含量，但是其真正的精髓在于配合逆向的思路来达到逆向者的目的。</p> 
   <p><strong>1．OD的选型</strong><br>为什么先介绍OD的选型，而不直接开始介绍OD的使用呢？OD的主流版本是1.10和待崛起的2.0。虽然它的主流版本是1.10，但是它仍然存在很多修改版。所谓修改版，就是由用户自己对OD进行修改而产生的，类似于病毒的免杀。OD虽然是动态调试工具，但是由于其强大的功能经常被很多人用在软件破解等方面，导致很多作者的心血付诸东流。软件的作者为了防止软件被OD调试，加入了很多专门针对OD进行调试的反调试功能来保护自<br>己的软件不被调试，从而不被破解；而破解者为了能够继续使用OD来破解软件，则不得不对OD进行修改，从而达到反反调试的效果。</p> 
   <p>调试、反调试、反反调试，对于新接触调试的爱好者来说容易混淆。简单来说，反调试是阻止使用OD进行调试，而反反调试是突破反调试继续进行调试。OD的修改版本之所以很多，目的就是为了能够更好地突破软件的反调试功能。</p> 
   <p>因此，如果从学习的角度来讲，建议选择原版的OD进行使用。在使用的过程中，除了会掌握很多调试技巧外，还会学到很多反调试的技巧，从而掌握反反调试的技巧。如果在实际的应用中，则可以直接使用修改版的OD，避免OD被软件反调试，从而提高逆向调试分析的速度。</p> 
   <p><strong>2．熟悉OD主界面</strong></p> 
   <p>OD的发行是一个压缩包，解压即可运行使用，运行OD解压目录总的ollydbg.exe程序，就会出现一个分布恰当、有菜单有面板和能输入命令的看着很强大的软件窗口，如图1-4所示。</p> 
   <p>在图1-4的OD调试主窗口中的工作区大致可以分为6个部分，按照从左往右、从上往下，这6部分分别是反汇编窗口、信息提示窗口、数据窗口、寄存器窗口、栈窗口和命令窗口。下面分别介绍各个窗口的用法。</p> 
   <p>反汇编窗口：该窗口用于显示反汇编代码，调试分析程序主要在这个窗口中进行，这也是进行调试分析的主要工作窗口。</p> 
   <p>信息提示窗口：该窗口用于显示与反汇编窗口中上下文环境相关的内存、寄存器或跳转来源、调用来源等信息。</p> 
   <p>数据窗口：该窗口用于以多种格式显示内存中的内容，可使用的格式有Hex、文本、短型、长型、浮点、地址和反汇编等。</p> 
   <p>寄存器窗口：该窗口用于显示各个寄存器的内容，包括前面介绍的通用寄存器、段寄存器、标志寄存器、浮点寄存器。另外，还可以在寄存器窗口中的右键菜单选择显示MMX寄存器、3DNow!寄存器和调试寄存器等。</p> 
   <p>栈窗口：该窗口用于显示栈内容、栈帧，即ESP或EBP寄存器指向的地址部分。</p> 
   <p>命令窗口：该窗口用于输入命令来简化调试分析的工作，该窗口并非基本窗口，而是由OD的插件提供的功能，由于几乎所有的OD使用者都会使用该插件，因此有必要把它也列入主窗口中。<br><img src="https://yqfile.alicdn.com/10296a1157af288ac5fb623906ef0de8f39e4d0b.png" alt="10" title="10"><br>图1-4　OD调试主窗口</p> 
   <p><strong>3．在数据窗口中查看数据</strong><br>前面已经介绍，OD是一款应用层下的调试工具，它除了可以进行软件的调试以外，还可以帮助我们学习前面介绍的数据宽度、进制转换等知识，而且能够帮助我们学习汇编语言。本节主要介绍通过OD的数据窗口来观察数据宽度。</p> 
   <p>为了能够直观地观察内存中的数据，我们通过RadAsm创建一个没有资源的汇编工程，然后编写一段自己的汇编代码，代码如下：<br><img src="https://yqfile.alicdn.com/abd136fab7f751044e5773358f063ffbc8c477bd.png" alt="11" title="11"><br>在上面的代码中，定义了10个全局变量。首先，var1、var2和var3分别定义了dword类型的3个变量，其中var1的值是十六进制的12h，var2的值是十进制的12，var3的值是2进制的11b。b1到b4四个变量是字节类型的，w1和w2两个变量是字类型的，d变量是dword类型的。</p> 
   <p>这10个全局变量就是我们要考察的关键。在RadAsm中进行编译连接后，直接按下Ctrl + D这个快捷键，即可在RadAsm安装时自带的OD中打开。在OD调试器中打开该程序后，观察它的数据窗口（如图1-5所示）。<br><img src="https://yqfile.alicdn.com/814e5ca9d6f7bf0df74817c07bc61adab6f4de38.png" alt="12" title="12"><br>图1-5　数据窗口中查看变量</p> 
   <p>在图1-5中，数据窗口一共有3列，分别是地址列、HEX数据列和ASCII列。这3个列，可以通过单击鼠标右键来改变现实方式和显示的列数。在地址00403000处开始的4个字节12 00 00 00是十六进制的12，也就是在汇编代码中定义的var1；在地址00403004处的4个字节0C 00 00 00是十六进制0C，也就是在汇编代码中定义的var2，var2变量定义的值是十进制的12，也就是十六进制的0C；在地址00403008处的4个字节03 00 00 00是十六进制的03，也就是在汇编代码中定义的var3，var3变量定义的值是2进制的11，也就是十六进制的03。</p> 
   <p>这3个变量在我们定义的时候都是以dd进行的，都是dword类型的变量，分别各占用4字节，因此在内存中，前3个变量分别是12 00 00 00、0C 00 00 00和03 00 00 00。</p> 
   <p>在地址0040300C处的值是11 22 33 44，这4个值分别是我们定义b1、b2、b3和b4 4个字节型的变量，这4变量按照内存由低到高的顺序显示分别是11、22、33、44。</p> 
   <p>在地址00403010处显示的值是66 55 88 77，这4个值分别对应我们定义的w1和w2两个字型变量，但是我们定义的变量w1的值是5566h，w2的值是7788h，在内存中为何显示的是6655和8877呢？这就是我们提到过的字节顺序的问题。我们的主机采用的是小尾方式存储的数据，也就是数据的低位存放在内存的低地址中，数据的高位存放在内存的高地址中，因此在地址00403020中存放的是5566H的低位数据66，在地址00403021中存放的是5566H的高位数据55，在内存看时，顺序是相反的。</p> 
   <p>在地址00403014处存放的是78 56 34 12，这是我们定义的最后一个变量d，它也是按照小尾方式存储在内存中的。因此，在查看内存时顺序也是反的。</p> 
   <p>OD提供了多种查看内存数据的方式，通过在数据窗口中单击鼠标右键，会弹出如图1-6所示菜单。</p> 
   <p>当在数据窗口中选择数据时，右键的菜单提供编辑、赋值、查找、断点功能，如图1-7所示。<br><img src="https://yqfile.alicdn.com/c9b69b82372ac79253bf2c8b505f86cff72f9596.png" alt="13" title="13"><br>图1-6　查看数据方式的菜单选项<br><img src="https://yqfile.alicdn.com/7df1444fefbcd0e7b6da836a9631de2f297645b2.png" alt="14" title="14"><br>图1-7　OD中对数据操作的菜单</p> 
   <p><strong>4．通过命令窗口改变数据窗口显示方式</strong><br>在图1-4中的最下方可以看到有一个输入命令的编辑框，在此处可以输入OD的相关命令以提高调试的速度。本小节就介绍如果通过命令窗口来改变数据窗口的显示方式。</p> 
   <p>在上面代码中定义变量时，使用了db、dw和dd三种类型，在OD的命令窗口中也同样可以使用者3个命令，其格式分别如表1-7所列。</p> 
   <p>表1-7　　命令窗口改变数据显示命令格式<br><img src="https://yqfile.alicdn.com/779a018d58f99fcbc27dfea0c844398b08bccaad.png" alt="15" title="15"><br>将表1-7中的命令在命令窗口中进行输入，数据窗口的变化和数值显示的变化分别如图1-8、图1-9和图1-10所示。<br><img src="https://yqfile.alicdn.com/9f60e00d9b0fa25fa6de235dd53f0a054e00b315.png" alt="016" title="016"><br>图1-8　dd命令显示的数据窗口<br><img src="https://yqfile.alicdn.com/a79e387051f8db52a67bcaeca27f9457b6602967.png" alt="17" title="17"><br>图1-9　dw命令显示的数据窗口<br><img src="https://yqfile.alicdn.com/8101794096f5296b51c6ea0aa00f8d9f2d44dc37.png" alt="18" title="18"><br>图1-10　db命令显示的数据窗口</p> 
   <p>从图中可以看出不同方式下数据窗口显示的样式，但是无论使用哪种方式显示数据，地址列总是会显示在最前面的，只要我们知道数据的地址，就可以直接在命令窗口中输入显示数据的格式来查看指定内存中的数据。</p> 
   <h1>1.4　编程判断主机字符序</h1> 
   <p>编程判断主机字节序是更进一步掌握字节序的方式，本小节给出两种对主机的字节序进行判断的方式。<br>1.4.1　字节序相关函数<br>在TCP/IP网络编程中会涉及关于字节序的函数，TCP/IP协议中传递数据是以网络字节序进行传输的，网络字节序是指网络传输相关协议所规定的字节传输的顺序，TCP/IP协议所使用的网络字节序与大尾方式相同。而主机字节序包含大尾方式与小尾方式，因此在进行网络传输时会进行相应的判断，如果主机字节序是大尾方式则无需进行转换即可传输，如果主机字节序是小尾方式则需要转换成网络字节序（也就是转换成大尾方式）然后进行传输。</p> 
   <p>常用的字节序涉及的函数有如下几个：<br><img src="https://yqfile.alicdn.com/87bbd43cf6f841704a0d33f963b71a759ede573c.png" alt="20" title="20"><br>在这4个函数中，前两个是将主机字节序转换成网络字节序，后两个是将网络字节序转换为主机字节序。关于更多的字节序的函数可参考MSDN。</p> 
   <p>1.4.2　编程判断主机字节序<br>“编程判断主机字节序”是很多杀毒软件公司或者安全开发职位的一道面试题，因为这个题目比较基础。通过前面的知识，相信读者能够很容易地实现该程序。这里给出笔者自己对于该题目的实现方法。笔者认为，完成该题目有两种方法，第一种方法是“取值比较法”，第二种方法是“直接转换比较法”。</p> 
   <p>1．取值比较法<br>所谓取值比较法，是首先定义一个4字节的十六进制数。因为使用调试器查看内存最直观的就是十六进制，所以定义十六进制数是一个操作起来比较直观的方法。而后通过指针方式取出这个十六进制数在“内存”中的某一个字节，最后与实际数值中相对应的数进行比较。<br>由于字节序的原因，内存中的某字节与实际数值中对应的字节可能不相同，这样就可以确定字节序了。</p> 
   <p>代码如下：<br><img src="https://yqfile.alicdn.com/c5721581fe66c01e4a3a2a366c970c485c819060.png" alt="21" title="21"></p> 
   <p>以上代码中，定义了0x01020304这个十六进制数，其在小尾方式内存中的存储顺序为04 03 02 01。取(BYTE )&amp;dwSmallNum内存中的低地址位的值，如果是小尾方式的话，那么低地址存储的值为0x04；如果是大尾方式的话，则低地址存储的值为0x01。<br>2．直接转换比较法<br>所谓直接转换比较法，是利用字节序转换函数将所定义的值进行转换，然后用转换后的值与原值进行比较。如果原值与转换后的值相同，说明是大尾方式，否则为小尾方式。</p> 
   <p>代码如下：<br><img src="https://yqfile.alicdn.com/67171385df73f15822230f0af975b1c1e131fe7c.png" alt="_" title="_"><br>这种方式比较直接，其前提是网络字节序是固定的，就是大尾方式。因为是比较，所以就要有一个参照物。如果原值转换后的结果与原值相同，就说明该主机是大尾方式存储，反之则是小尾方式。</p> 
   <h1>1.5　总结</h1> 
   <p>本文对内存中存储基础数据的方式进行了阐述，并且在最后部分介绍了如何使用OD调试器来查看内存中的数据。在学习编程时，都会从数据类型开始介绍，不同的数据类型都是以二进制的方式存储在内存中的，只是它们存储的方式不同，或者是存储的宽度不同。在我们学习逆向时，也首先讲解了数据的基础及数据的存储方式。<br>本文摘自《逆向分析实战》<br><img src="https://yqfile.alicdn.com/27dbe6b25d6feee2cf1aecf758c6faf4662246fe.png" alt="_" title="_"><br>点击封面查看<br>也许你想知道什么是软件逆向，也许你已经听说过软件逆向，从而想要学习软件逆向。不管你抱着什么目的翻开本书，笔者还是在你阅读本书之前，先来说一些软件逆向的知识！</p> 
   <p>什么是“软件逆向工程”<br>术语“逆向工程”源自硬件领域，在软件领域目前还没有明确的定义。就笔者个人的理解简单来说，软件逆向是通过观察分析软件或程序的行为、数据和代码等，来还原其设计实现，或者推导出更高抽象层次的表示。</p> 
   <p>软件工程与软件逆向工程的区别<br>对于软件工程而言，软件的设计讲究封装，将各个模块进行封装，将具体的实现进行隐藏，只暴露一个接口给使用者。对于模块的使用者而言，封装好的模块相当于一个“黑盒子”，使用者使用“盒子”时，无需关心“盒子”的内部实现，只需要按照模块预留的接口进行使用即可。</p> 
   <p>软件逆向工程对于软件工程而言，却是正好相反的。对软件进行逆向工程时要查看软件的行为，即软件的输入与输出的情况；要查看软件的文件列表，即软件使用了哪些动态链接库（哪些动态连接库是作者编写的，哪些动态连接库是系统提供的），有哪些配置文件，甚至还要通过一系列的工具查看软件的文件结构、反汇编代码等。</p> 
   <p>对比软件工程与软件逆向工程可以发现，软件工程是在封装、实现一个具备某种功能的“黑盒子”，而软件逆向工程则是在分析“黑盒子”并尝试还原封装的实现与设计。后者对于前者而言是一个相反的过程，因此称为“软件逆向工程”。</p> 
   <p>学习软件逆向工程与软件工程的区别<br>对于软件逆向工程而言，学习逆向知识，除了要学习逆向知识本身外，还需要掌握各种不同的逆向工具，或者说逆向知识中重要的一个环节就是逆向工具的使用。对于软件开发而言，软件开发工具在软件开发中所占据的位置远远达不到逆向工具在逆向领域中的位置。因此，读者在学习编程时可能更注重的是编程语言本身而不是工具，但是在学习逆向时，逆向知识是不可能抛开逆向工具而独立进行学习的。</p> 
   <p>本书的主要内容<br>本书全面讲解了软件逆向工程的知识，即包括主流的技术，如加壳与脱壳、汇编、数据的存储等；也有实用的工具，如主流的调试工具OllyDbg、PE工具、加壳与脱壳工具、十六进制编辑与反编译工具、IDA与逆向、逆向工具实现等。</p> 
   <p>延伸推荐<br><img src="https://yqfile.alicdn.com/cbb0163f752cad51dacb3f9f10a7e4dd3439041f.png" alt="0_" title="0_"><br>点击关键词阅读更多新书：<br>Python|机器学习|Kotlin|Java|移动开发|机器人|有奖活动|Web前端|书单<br><img src="https://yqfile.alicdn.com/095d751c037a00e8c6698aee1f67bd6521b63208.png" alt="0_0" title="0_0"><br>在“异步图书”后台回复“关注”，即可免费获得2000门在线视频课程；推荐朋友关注根据提示获取赠书链接，免费得异步图书一本。赶紧来参加哦！<br>点击阅读原文，查看本书更多信息<br>扫一扫上方二维码，回复“关注”参与活动！<br><img src="https://yqfile.alicdn.com/7a4d8cba6b640aa2d88460af00506c5682e49d68.png" alt="0_3_0" title="0_3_0"></p> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
