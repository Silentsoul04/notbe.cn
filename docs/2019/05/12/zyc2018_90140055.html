<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>leetcode② « NotBeCN</title>
  <meta name="description" content="         跳跃游戏       给定一个非负整数数组，你最初位于数组的第一个位置。    数组中的每个元素代表你在该位置可以跳跃的最大长度。    判断你是否能够到达最后一个位置。    例一：输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/zyc2018_90140055.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">leetcode②</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h3>跳跃游戏</h3> 
  <blockquote> 
   <p>给定一个非负整数数组，你最初位于数组的第一个位置。</p> 
   <p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p> 
   <p>判断你是否能够到达最后一个位置。</p> 
   <p><strong>例一：输入:</strong> [2,3,1,1,4] <strong>输出:</strong> true <strong>解释:</strong> 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置</p> 
   <p><strong>例二：输入:</strong> [3,2,1,0,4] <strong>输出:</strong> false <strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p> 
  </blockquote> 
  <pre class="has">
<code class="language-cpp">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 1) {
            return true;
        }
        int n = -2; 
        for(int i=nums.size() - 2;i&gt;=0;i--) {
             // 从后往前找，把当前过不了的坑的位置记录起来
            if(nums[i] == 0 &amp;&amp; n&lt;=-1) {  
                // 如果遇到新的坑并且当前没有坑，则记录坑的位置
                n = i;
                continue;
            }
            if(n&gt;=0 &amp;&amp; nums[i] &gt; (n-i)) {   
            // 如果发现元素的值大于元素和坑的距离，说明可以跳过这个坑，将坑的下标置为-1，继续往前找坑
                n = -1;
            }
        }
        // 走到起点发现没有记录到坑，说明可以跳过去，否则返回false
        return n&lt;0;
    }
};</code></pre> 
  <h3>三角形的最大周长</h3> 
  <blockquote> 
   <p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p> 
   <p>如果不能形成任何面积不为零的三角形，返回&nbsp;<code>0</code>。</p> 
   <p><strong>输入：</strong>[2,1,2] <strong>输出：</strong>5</p> 
   <p><strong>输入：</strong>[1,2,1] <strong>输出：</strong>0</p> 
   <p><strong>输入：</strong>[3,2,3,4] <strong>输出：</strong>10</p> 
  </blockquote> 
  <pre class="has">
<code class="language-java">class Solution {
    public int largestPerimeter(int[] A) {
        Arrays.sort(A);
        if(A.length&lt;3)
            return 0;
        for(int i = A.length - 1; i &gt;= 2; i--) {
            int a = A[i];
            int b = A[i - 1];
            int c = A[i - 2];
            if(a &lt; b + c){
                return a + b + c;
            }
        }
        return 0;
    }
}</code></pre> 
  <h3>正则表达式匹配</h3> 
  <p>动态规划：<a href="https://www.cnblogs.com/raichen/p/5772056.html" rel="nofollow">https://www.cnblogs.com/raichen/p/5772056.html</a></p> 
  <blockquote> 
   <p>给定一个字符串&nbsp;(<code>s</code>) 和一个字符模式&nbsp;(<code>p</code>)。实现支持 <code>'.'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的正则表达式匹配。'.' 匹配任意单个字符。 '*' 匹配零个或多个前面的元素。匹配应该覆盖<strong>整个</strong>字符串&nbsp;(<code>s</code>) ，而不是部分字符串。说明：<code>s</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母；<code>p</code>&nbsp;可能为空，且只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</p> 
   <p><strong>输入:</strong> s = "aa" p = "a" <strong>输出:</strong> false <strong>解释:</strong> "a" 无法匹配 "aa" 整个字符串。</p> 
   <p><strong>输入:</strong> s = "aa" p = "a*" <strong>输出:</strong> true <strong>解释:</strong>&nbsp;'*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。</p> 
   <p><strong>输入:</strong> s = "ab" p = ".*" <strong>输出:</strong> true <strong>解释:</strong>&nbsp;".*" 表示可匹配零个或多个('*')任意字符('.')。</p> 
   <p><strong>输入:</strong> s = "aab" p = "c*a*b" <strong>输出:</strong> true <strong>解释:</strong>&nbsp;'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。</p> 
   <p><strong>输入:</strong> s = "mississippi" p = "mis*is*p*." <strong>输出:</strong> false</p> 
  </blockquote> 
  <pre class="has">
<code class="language-java">class Solution {
    public boolean isMatch(String s, String p) {
        int sLen = s.length(), pLen = p.length();
		boolean[][] memory = new boolean[sLen+1][pLen+1];
		memory[0][0] = true;
		for(int i = 0; i &lt;= sLen; i++) {
			for(int j = 1; j &lt;= pLen; j++) {
				if(p.charAt(j-1) == '*') {
					memory[i][j] = memory[i][j-2] || (i &gt; 0 &amp;&amp; (s.charAt(i-1) == p.charAt(j-2) || 
							p.charAt(j-2) == '.') &amp;&amp; memory[i-1][j]);
				}else {
					memory[i][j] = i &gt; 0 &amp;&amp; (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.')
									&amp;&amp; memory[i-1][j-1];
				}
			}
		}
		return memory[sLen][pLen];
    }
}</code></pre> 
  <h3>DI序列的有效排列</h3> 
  <blockquote> 
   <p>我们给出 <code>S</code>，一个源于&nbsp;<code>{'D', 'I'}</code>&nbsp;的长度为 <code>n</code>&nbsp;的字符串 。（这些字母代表 “减少” 和 “增加”。）<br><em>有效排列&nbsp;是对整数 <code>{0, 1, ..., n}</code>&nbsp;的一个排列&nbsp;<code>P[0], P[1], ..., P[n]</code>，使得对所有的&nbsp;<code>i</code>：</em></p> 
   <ul>
    <li>如果 <code>S[i] == 'D'</code>，那么&nbsp;<code>P[i] &gt; P[i+1]</code>，以及；</li> 
    <li>如果 <code>S[i] == 'I'</code>，那么 <code>P[i] &lt; P[i+1]</code>。</li> 
   </ul>
   <p>有多少个有效排列？因为答案可能很大，所以请<strong>返回你的答案模</strong><strong> <code>10^9 + 7</code></strong>.</p> 
   <p><strong>输入：</strong>"DID" <strong>输出：</strong>5 <strong>解释：</strong> (0, 1, 2, 3) 的五个有效排列是： (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0）</p> 
  </blockquote> 
  <pre class="has">
<code class="language-cpp">class Solution {
public:
    int numPermsDISequence(string S) {
        int M = pow(10, 9)+7;
        //第一维表示取到S的第几个字母，第二维表示取值，例如0，1，2，3,dp[i][3]结尾取3
        vector&lt;vector&lt;int&gt;&gt; dp(S.size()+1,vector&lt;int&gt;(S.size()+1,0));
        dp[0][0] = 1;
        for(int i = 0;i&lt;S.size();i++){
            if(S[i] == 'I'){
                for(int j = 1;j&lt;=i+1;j++){
                    dp[i+1][j] = (dp[i+1][j-1]+dp[i][j-1])%M;
                }
            }else{
                for(int j = i;j&gt;=0;j--){
                    dp[i+1][j] = (dp[i+1][j+1]+dp[i][j])%M;
                }
            }
        }
        int res = 0;
        for(int i = 0;i&lt;dp.size();i++){
            res=(res+dp[dp.size()-1][i])%M;
        }
        return res;
    }
};</code></pre> 
  <h3>最佳买卖股票时机含冷冻期</h3> 
  <blockquote> 
   <p>给定一个整数数组，其中第<em>&nbsp;i</em>&nbsp;个元素代表了第&nbsp;<em>i</em>&nbsp;天的股票价格 。​</p> 
   <p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p> 
   <ul>
    <li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li> 
    <li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li> 
   </ul>
   <p><strong>输入:</strong> [1,2,3,0,2] <strong>输出: </strong>3 <strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p> 
  </blockquote> 
  <pre class="has">
<code class="language-python">'''
sell[i]表示截至第i天，最后一个操作是卖时的最大收益；
buy[i]表示截至第i天，最后一个操作是买时的最大收益；
cool[i]表示截至第i天，最后一个操作是冷冻期时的最大收益；
递推公式：
sell[i] = max(buy[i-1]+prices[i], sell[i-1]) (第一项表示第i天卖出，第二项表示第i天冷冻)
buy[i] = max(cool[i-1]-prices[i], buy[i-1]) （第一项表示第i天买进，第二项表示第i天冷冻）
cool[i] = max(sell[i-1], buy[i-1], cool[i-1])
'''
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n == 0:
            return 0     
        sell = [0 for _ in range(n)]
        buy = [0 for _ in range(n)]
        cool = [0 for _ in range(n)]
        buy[0] = -prices[0]
        for i in range(1,n):
            sell[i] = max(buy[i-1] + prices[i], sell[i-1])
            buy[i] = max(cool[i-1] - prices[i], buy[i-1])
            cool[i] = max(sell[i-1], buy[i-1],cool[i-1])
        return sell[n-1]</code></pre> 
  <pre class="has">
<code class="language-java">   /**
     * buy[i]表示第i天买入时的最大利润（最后一个操作是买）
     * sell[i]表示第i天卖出时的最大利润（最后一个操作是卖）
     */
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0)
            return 0;
        int[] buy = new int[n];
        int[] sell = new int[n];
        buy[0] = -prices[0];
        sell[0] = 0;
        if (n &gt; 1) {
            buy[1] = Math.max(buy[0], 0 - prices[1]);//因为冷冻期，所以前一天只能为买，所以比较的是buy[0]=-prices[0],而大前天无买卖，所以利润为0，则得到0-prices[1]
            sell[1] = Math.max(sell[0], buy[0] + prices[1]);
        }
        for (int i = 2; i &lt; n; ++i) {
            buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);//因为冷冻期，所以前一天只能为买，所以比较的是buy[i - 1]
            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);//比较的是前一天卖出的最大利润和前一天买入的最大利润+今天卖出的价格
        }
        return sell[n - 1];
    }</code></pre> 
  <h3>连续数组</h3> 
  <blockquote> 
   <p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p> 
   <p><strong>输入:</strong> [0,1] <strong>输出:</strong> 2 <strong>说明:</strong> [0, 1] 是具有相同数量0和1的最长连续子数组。</p> 
   <p><strong>输入:</strong> [0,1,0] <strong>输出:</strong> 2 <strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</p> 
  </blockquote> 
  <pre class="has">
<code class="language-cpp">class Solution {
public:
    int findMaxLength(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt; m;
        int sum = 0;
        int res = 0;
        for(int i = 0;i&lt;nums.size();i++){
            sum+=(nums[i]==1?1:-1);
            if(sum == 0){
                res = i+1;
            }
            else{
                if(m[sum]==0){
                    m[sum] = i+1;
                }else{
                    res = max(res,i-m[sum]+1);
                }
            }
        }
        return res;
    }
};</code></pre> 
  <h3>汉明距离</h3> 
  <blockquote> 
   <p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" rel="nofollow">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p> 
   <p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p> 
   <p><strong>输入:</strong> x = 1, y = 4 <strong>输出:</strong> 2</p> 
   <p><strong>解释:</strong> 1 (0 0 0 1)</p> 
   <p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 4 (0 1 0 0)</p> 
   <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ↑ &nbsp;&nbsp; ↑ 上面的箭头指出了对应二进制位不同的位置。</p> 
  </blockquote> 
  <p>方法一：</p> 
  <pre class="has">
<code class="language-cpp">class Solution {
public:
    int hammingDistance(int x, int y) {
        return bitset&lt;32&gt;(x ^ y).count();
    }
};
//bitset&lt;32&gt; bv; 声明 bv 是 32位2进制 bitset class 的对象。</code></pre> 
  <p>方法二：</p> 
  <pre class="has">
<code class="language-java">class Solution {
    public int hammingDistance(int x, int y) {
        int sum = 0;
        x = x^y;
        while(x!=0) {
            sum+=x&amp;1;
            x&gt;&gt;=1;
        }
        return sum;
    }</code></pre> 
  <blockquote> 
   <p>两个整数的&nbsp;<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin" rel="nofollow">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p> 
   <p>计算一个数组中，任意两个数之间汉明距离的总和。</p> 
   <p><strong>输入:</strong> 4, 14, 2 <strong>输出:</strong> 6 <strong>解释:</strong> 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系） 所以答案为： HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p> 
  </blockquote> 
  <pre class="has">
<code class="language-cpp">class Solution {
public:
    int totalHammingDistance(vector&lt;int&gt;&amp; nums) {
        int dist = 0;
        for (int i = 0; i &lt; 8 * sizeof(int); i++) {
            int b1 = 0;
            for (int n : nums) {
                b1 += n &gt;&gt; i &amp; 1;
            }
            dist += b1 * (nums.size() - b1);
        }
        return dist;
    }
};</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
