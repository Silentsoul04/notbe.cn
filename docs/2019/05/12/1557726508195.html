<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Zookeeper 介绍-快速入门 « NotBeCN</title>
  <meta name="description" content="                  ZooKeeper 简介   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZooKeeper 是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。ZooKeeper通过其简单的架构和API解决...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726508195.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Zookeeper 介绍-快速入门</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h3><a id="ZooKeeper__0"></a>ZooKeeper 简介</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZooKeeper 是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。ZooKeeper通过其简单的架构和API解决了这个问题 ZooKeeper 允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZooKeeper 框架最初是在“Yahoo!"上构建的，Apache ZooKeeper成为 Hadoop，HBase 和其他分布式框架使用的有组织服务的标准。使用 ZooKeeper 跟踪分布式数据的状态。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式应用正在运行的一组系统称为集群，而在集群中运行的每台机器被称为节点。</p> 
  <h3><a id="_7"></a>分布式应用的优点</h3> 
  <ul> 
   <li><strong>可靠性</strong> - 单个或几个系统的故障不会使整个系统出现故障。</li> 
   <li><strong>可扩展性</strong> - 可以在需要时增加性能，通过添加更多机器，在应用程序配置中进行微小的更改，而不会有停机时间。</li> 
   <li><strong>透明性</strong> - 隐藏系统的复杂性，并将其显示为单个实体/应用程序。</li> 
  </ul> 
  <h3><a id="_12"></a>分布式应用的挑战</h3> 
  <ul> 
   <li><strong>竞争条件</strong> - 两个或多个机器尝试执行特定任务，实际上只需在任意给定时间由单个机器完成。例如，共享资源只能在任意给定时间由单个机器修改。</li> 
   <li><strong>死锁</strong> - 两个或多个操作等待彼此无限期完成。</li> 
   <li><strong>不一致</strong> - 数据的部分失败。</li> 
  </ul> 
  <h3><a id="ZooKeeper__17"></a>ZooKeeper 提供的服务</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZooKeeper 是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper 本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p> 
  <ul> 
   <li><strong>命名服务</strong> - 按名称标识集群中的节点。它类似于 DNS，但仅对于节点。</li> 
   <li><strong>配置管理</strong> - 加入节点的最近的和最新的系统配置信息。</li> 
   <li><strong>集群管理</strong> - 实时地在集群和节点状态中加入/离开节点。</li> 
   <li><strong>选举算法</strong> - 选举一个节点作为协调目的的leader。</li> 
   <li><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如 Apache HBase）时进行自动故障恢复。</li> 
   <li><strong>高度可靠的数据注册表</strong> - 即使在一个或几个节点关闭时也可以获得数据。</li> 
  </ul> 
  <h3><a id="ZooKeeper__26"></a>ZooKeeper 优点</h3> 
  <ul> 
   <li><strong>简单的分布式协调过程</strong></li> 
   <li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li> 
   <li><strong>有序的消息</strong></li> 
   <li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li> 
   <li><strong>可靠性</strong></li> 
   <li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li> 
  </ul> 
  <h3><a id="ZooKeeper__35"></a>ZooKeeper 架构</h3> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512153645323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY1MDI1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <ul> 
   <li>Client（客户端）<br> 客户端，我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。</li> 
   <li>Server（服务器）<br> 服务器，我们的 ZooKeeper 总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。</li> 
   <li>Ensemble<br> ZooKeeper 服务器组。形成 ensemble 所需的最小节点数为 3。</li> 
   <li>Leader<br> 服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader 在服务启动时被选举。</li> 
   <li>Follower<br> 跟随leader指令的服务器节点。</li> 
  </ul> 
  <h3><a id="ZooKeeper__48"></a>ZooKeeper 数据模型</h3> 
  <p>层次命名空间</p> 
  <p>ZooKeeper 文件系统的树结构</p> 
  <p>ZooKeeper 节点称为 znode，每个 znode 由一个名称标识，并用路径 (/) 序列分隔。</p> 
  <p>每个 znode下的根目录下，有两个逻辑命名空间 config 和 workers，config 命名空间用于集中式配置管理，workers 命名空间用于命名。在 config 命名空间下，每个 znode 最多可存储1MB的数据。</p> 
  <p>这种结构的主要目的是存储同步数据并描述 znode 的元数据。此结构称为 ZooKeeper 数据模型。</p> 
  <p>ZooKeeper 数据模型中的每个 znode 都维护着一个 stat 结构。一个 stat 仅提供一个 znode 的元数据。它由<strong>版本号</strong>，<strong>操作控制列表 (ACL)</strong>，<strong>时间戳</strong>和<strong>数据长度</strong>组成。</p> 
  <ul> 
   <li><strong>版本号</strong> - 每个 znode 都有版本号，这意味着每当与 znode 相关联的数据发生变化时，其对应的版本号也会增加。当多个 ZooKeeper 客户端尝试在同一 znode 上执行操作时，版本号的使用就很重要。</li> 
   <li><strong>操作控制列表(ACL)</strong> - ACL 基本上是访问 znode 的认证机制。它管理所有 znode 读取和写入操作。</li> 
   <li><strong>时间戳</strong> - 时间戳表示创建和修改 znode 所经过的时间。它通常以毫秒为单位。ZooKeeper 从“事务ID" (zxid) 标识 znode 的每个更改。zxid 是唯一的，并且为每个事务保留时间，以便你可以轻松地确定从一个请求到另一个请求所经过的时间。</li> 
   <li><strong>数据长度</strong> - 存储在 znode 中的数据总量是数据长度。你最多可以存储1MB的数据。</li> 
  </ul> 
  <h3><a id="ZooKeeper__66"></a>ZooKeeper 节点类型</h3> 
  <p>Znode 被分为<strong>持久（persistent）节点</strong>，<strong>顺序（sequential）节点</strong>和<strong>临时（ephemeral）节点</strong>。</p> 
  <ul> 
   <li><strong>持久节点</strong> - 即使在创建该特定 znode 的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode 都是持久的。</li> 
   <li><strong>临时节点</strong> - 客户端活跃时，临时节点就是有效的。当客户端与 ZooKeeper 集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在leader选举中起着重要作用。</li> 
   <li><strong>顺序节点</strong> - 顺序节点可以是持久的或临时的。当一个新的 znode 被创建为一个顺序节点时，ZooKeeper 通过将10位的序列号附加到原始名称来设置 znode 的路径。例如，如果将具有路径 /myapp 的 znode 创建为顺序节点，则 ZooKeeper 会将路径更改为 /myapp0000000001 ，并将下一个序列号设置为 0000000002。如果两个顺序节点是同时创建的，那么 ZooKeeper 不会对每个 znode 使用相同的数字。顺序节点在锁定和同步中起重要作用。</li> 
  </ul> 
  <h3><a id="ZooKeeper__73"></a>ZooKeeper 组件</h3> 
  <ul> 
   <li><strong>写入（write）</strong>- 写入过程由 leader 节点处理。leader 将写入请求转发到所有 znode，并等待 znode 的回复。如果一半的 znode 回复，则写入过程完成。</li> 
   <li><strong>读取（read）</strong>- 读取由特定连接的znode在内部执行，因此不需要与集群进行交互。</li> 
   <li><strong>复制数据库（replicated database）</strong>- 它用于在zookeeper中存储数据。每个 znode 都有自己的数据库，每个 znode 在一致性的帮助下每次都有相同的数据。</li> 
   <li><strong>Leader</strong> - Leader 是负责处理写入请求的 Znode。</li> 
   <li><strong>Follower</strong> - follower 从客户端接收写入请求，并将它们转发到 leader znode。</li> 
   <li><strong>请求处理器（request processor）</strong>- 只存在于 leader 节点。它管理来自 follower 节点的写入请求。</li> 
   <li><strong>原子广播（atomic broadcasts）</strong> - 负责广播从leader节点到follower节点的变化。</li> 
  </ul> 
  <h3><a id="ZooKeeper_API__83"></a>ZooKeeper API 介绍</h3> 
  <ul> 
   <li><strong>connect</strong> - 连接到ZooKeeper集合</li> 
   <li><strong>create</strong> - 创建znode</li> 
   <li><strong>exists</strong> - 检查znode是否存在及其信息</li> 
   <li><strong>getData</strong> - 从特定的znode获取数据</li> 
   <li><strong>setData</strong> - 在特定的znode中设置数据</li> 
   <li><strong>getChildren</strong> - 获取特定znode中的所有子节点</li> 
   <li><strong>delete</strong> - 删除特定的znode及其所有子项</li> 
   <li><strong>close</strong> - 关闭连接</li> 
  </ul> 
  <h3><a id="ZooKeeper__93"></a>ZooKeeper 选举机制</h3> 
  <p><strong>提供了三种</strong></p> 
  <ul> 
   <li>LeaderElection</li> 
   <li>AuthFastLeaderElection</li> 
   <li>FastLeaderElection（默认）</li> 
  </ul> 
  <p><strong>为何 ZooKeeper 要有 leader?</strong><br> Zookeeper 是以 Fast Paxos 算法为基础，paxos 算法存在活锁的问题，即当有多个 proposer 交错提交时，有可能互相排斥导致没有一个 proposer 能提交成功，而 Fase Paxos 作了一些优化，通过选举产生一个 leader。</p> 
  <ul> 
   <li>proposer：提议者</li> 
   <li>accepter：决策者</li> 
   <li>learners：最终决策学习者</li> 
  </ul> 
  <p><strong>选举状态:</strong></p> 
  <ul> 
   <li>looking：竞选状态</li> 
   <li>following：随从状态，参与投票</li> 
   <li>observing：观察状态，不参与投票</li> 
   <li>leading：领导中</li> 
  </ul> 
  <p><strong>选举机制发生的时间</strong></p> 
  <ul> 
   <li>集群启动时</li> 
   <li>leader 节点崩溃时</li> 
  </ul> 
  <p><strong>选举参与的参数</strong></p> 
  <ul> 
   <li><strong>ZXID：</strong> 事务 id，为了保证事务的顺序一致性，zk采用了递增的事务id号（zxid）来标识事务，所有的提议（proposal）都在被提出的时候加上了 zxid，实现中 zxid 是一个64位的数字，他高32位是 epoch，低32用于递增计数。值越大说明数据越新，在选举算法中数据约新权重越大</li> 
   <li><strong>myid：</strong> 服务器 id，服务器 id 越大，选举的权重越大。或者投票次数，同一轮投票过程中的逻辑时钟值是相同的，每一次投票完成 epoch 就会+1,然后与接受到的其他服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断</li> 
   <li><strong>epoch：</strong> 逻辑时钟</li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
