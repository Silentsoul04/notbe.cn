<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Java总结（1） « NotBeCN</title>
  <meta name="description" content="          Java总结   目录   Java总结   什么是jvm，其中jdk和jre有什么区别？什么是字节码？为什么要采用字节码？   Java和C++的区别   重载和重写的区别？构造器Constructor是否可以被override？   Java的三大特性   String str="abcd...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/qq_41203284_90118930.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Java总结（1）</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1 id="Java%E6%80%BB%E7%BB%93">Java总结</h1> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="Java%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#Java%E6%80%BB%E7%BB%93" rel="nofollow">Java总结</a></p> 
  <p id="%E4%BB%80%E4%B9%88%E6%98%AFjvm%EF%BC%8C%E5%85%B6%E4%B8%ADjdk%E5%92%8Cjre%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFjvm%EF%BC%8C%E5%85%B6%E4%B8%ADjdk%E5%92%8Cjre%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F" rel="nofollow">什么是jvm，其中jdk和jre有什么区别？什么是字节码？为什么要采用字节码？</a></p> 
  <p id="Java%E5%92%8CC%2B%2B%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#Java%E5%92%8CC%2B%2B%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">Java和C++的区别</a></p> 
  <p id="%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%ABoverride%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%ABoverride%EF%BC%9F" rel="nofollow">重载和重写的区别？构造器Constructor是否可以被override？</a></p> 
  <p id="Java%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#Java%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7" rel="nofollow">Java的三大特性</a></p> 
  <p id="String%20str%3D%22abcd%22%E4%B8%8E%C2%A0String%20str1%3Dnew%20String(%22acbd%22)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9Fstr%E5%92%8Cstr1%E7%9B%B8%E7%AD%89%E5%90%97%3F-toc" style="margin-left:40px;"><a href="#String%20str%3D%22abcd%22%E4%B8%8E%C2%A0String%20str1%3Dnew%20String(%22acbd%22)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9Fstr%E5%92%8Cstr1%E7%9B%B8%E7%AD%89%E5%90%97%3F" rel="nofollow">String str="abcd"与&nbsp;String str1=new String("acbd")一样吗？str和str1相等吗?</a></p> 
  <p id="String%EF%BC%8CStringBuffer%20%E5%92%8C%20StringBuilder%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3FString%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%3F-toc" style="margin-left:40px;"><a href="#String%EF%BC%8CStringBuffer%20%E5%92%8C%20StringBuilder%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3FString%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%3F" rel="nofollow">String，StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?</a></p> 
  <p id="%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E4%BD%BF%E7%94%A8%20final%20%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E4%BD%BF%E7%94%A8%20final%20%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F" rel="nofollow">接口和抽象类的区别是什么？抽象类必须要有抽象方法吗？抽象类能使用 final 修饰吗？</a></p> 
  <p id="%3D%3D%20%E4%B8%8E%20equals(%E9%87%8D%E8%A6%81)-toc" style="margin-left:40px;"><a href="#%3D%3D%20%E4%B8%8E%20equals(%E9%87%8D%E8%A6%81)" rel="nofollow">== 与 equals(重要)</a></p> 
  <p id="hashCode%20%E4%B8%8E%20equals%20(%E9%87%8D%E8%A6%81)-toc" style="margin-left:40px;"><a href="#hashCode%20%E4%B8%8E%20equals%20(%E9%87%8D%E8%A6%81)" rel="nofollow">hashCode 与 equals (重要)</a></p> 
  <p id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">什么是反射机制？反射机制的应用场景有哪些？</a></p> 
  <p id="%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D" rel="nofollow">反射机制介绍</a></p> 
  <p id="%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91-toc" style="margin-left:80px;"><a href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91" rel="nofollow">静态编译和动态编译</a></p> 
  <p id="%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">反射机制优缺点</a></p> 
  <p id="%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">反射的应用场景</a></p> 
  <p id="%E4%B8%BA%E4%BB%80%E4%B9%88%20Java%20%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%20Java%20%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F" rel="nofollow">为什么 Java 中只有值传递？</a></p> 
  <p id="Java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9FBIO%2CNIO%2CAIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#Java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9FBIO%2CNIO%2CAIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">Java 中 IO 流分为几种？BIO,NIO,AIO 有什么区别？</a></p> 
  <p id="java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F-toc" style="margin-left:80px;"><a href="#java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F" rel="nofollow">java 中 IO 流分为几种？</a></p> 
  <p id="BIO%2CNIO%2CAIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#BIO%2CNIO%2CAIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">BIO,NIO,AIO 有什么区别？</a></p> 
  <hr id="hr-toc">
  <h2 id="%E4%BB%80%E4%B9%88%E6%98%AFjvm%EF%BC%8C%E5%85%B6%E4%B8%ADjdk%E5%92%8Cjre%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F">什么是jvm，其中jdk和jre有什么区别？什么是字节码？为什么要采用字节码？</h2> 
  <ul>
   <li>JVM 
    <ul>
     <li>java虚拟机，是运行java字节码的虚拟机，可以针对不同的操作系统，执行相同的字节码，从而给出相同的结果。</li> 
     <li>实现了“一次编译，随处运行”关键特征。</li> 
    </ul></li> 
   <li>什么是字节码？ 
    <ul>
     <li>jvm理解的代码就是字节码，扩展面就是.class的文件，不面向任何处理体统，只面向jvm。解决了解释型语言的效率底问题，保留了解释型语言可移植的特性。</li> 
     <li><img alt="" class="has" height="149" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512001421744.png" width="643"></li> 
    </ul></li> 
   <li>JDK和JRE 
    <ul>
     <li> <p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p> </li> 
     <li> <p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p> </li> 
    </ul></li> 
  </ul>
  <h2 id="Java%E5%92%8CC%2B%2B%E7%9A%84%E5%8C%BA%E5%88%AB">Java和C++的区别</h2> 
  <ul>
   <li>Java和c++都支持面向对象编程，支持继承，封装，多态。</li> 
   <li>java不提供直接操作内存的方法，所以程序更加安全。</li> 
   <li>java的类是单继承的，c++支持多继承。java接口支持多继承。</li> 
   <li>java特有的内存管理机制，无需程序员手动释放内存。</li> 
  </ul>
  <h2 id="%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%ABoverride%EF%BC%9F">重载和重写的区别？构造器Constructor是否可以被override？</h2> 
  <ul>
   <li>重载：发生在同一个类中，方法名必须相同，参数类型、个数、顺序不同，返回值和修饰符可以不同。</li> 
   <li>重写：发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类的修饰符是private，则子类无法重写此方法。</li> 
   <li>父类的私有属性和构造方法并不能被继承，所以Constructor不能被重写，但是可以重载，所以一个类中常有多个构造函数的情况。</li> 
  </ul>
  <h2 id="Java%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">Java的三大特性</h2> 
  <ul>
   <li>封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li> 
   <li> <p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p> 
    <ul>
     <li> <p><strong>关于继承如下 3 点请记住：</strong></p> 
      <ul>
       <li> <p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p> </li> 
       <li> <p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p> </li> 
       <li> <p>子类可以用自己的方式实现父类的方法。（以后介绍）。</p> </li> 
      </ul></li> 
    </ul></li> 
   <li> <p>多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p> </li> 
  </ul>
  <h2 id="String%20str%3D%22abcd%22%E4%B8%8E%C2%A0String%20str1%3Dnew%20String(%22acbd%22)%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9Fstr%E5%92%8Cstr1%E7%9B%B8%E7%AD%89%E5%90%97%3F"><code>String str="abcd"</code>与&nbsp;<code>String str1=new String("acbd")</code>一样吗？str和str1相等吗?</h2> 
  <ul>
   <li>第一种方式先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后str指向字符串常量池中的对象，如果有，则直接将str指向字符串常量池中的"abcd""；</li> 
   <li> <p>第二种方式是直接在堆内存空间创建一个新的对象。推荐使用第一种方式创建字符串。str和str1不相等，因为一个是堆内存中的String对象一个是常量池中的String对象。</p> </li> 
  </ul>
  <h2 id="String%EF%BC%8CStringBuffer%20%E5%92%8C%20StringBuilder%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%3FString%20%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%3F">String，StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?</h2> 
  <ul>
   <li> <p><strong>可变性</strong>&nbsp;　</p> <p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code>&nbsp;但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p> <p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p> <p>AbstractStringBuilder.java</p> </li> 
  </ul>
  <pre class="has">
<code class="language-java">abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    int count;
    AbstractStringBuilder() {
    }
    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }</code></pre> 
  <ul>
   <li> <p><strong>线程安全性</strong></p> <p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p> </li> 
   <li> <p><strong>性能</strong></p> <p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p> </li> 
   <li> <p><strong>对于三者使用的总结：</strong></p> 
    <ul>
     <li> <p>操作少量的数据: 适用String</p> </li> 
     <li> <p>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</p> </li> 
     <li> <p>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</p> </li> 
    </ul></li> 
  </ul>
  <h2 id="%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E4%BD%BF%E7%94%A8%20final%20%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F">接口和抽象类的区别是什么？抽象类必须要有抽象方法吗？抽象类能使用 final 修饰吗？</h2> 
  <ul>
   <li><strong>接口和抽象类的区别是什么？</strong> 
    <ul>
     <li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li> 
     <li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定。</li> 
     <li>一个类可以实现多个接口，但最多只能实现一个抽象类。</li> 
     <li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定。</li> 
     <li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li> 
    </ul></li> 
  </ul>
  <p>备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</p> 
  <ul>
   <li><strong>抽象类必须要有抽象方法吗？</strong> 
    <ul>
     <li>抽象类中不一定包含抽象方法，但是包含抽象方法的类一定要被声明为抽象类。</li> 
    </ul></li> 
   <li><strong>抽象类能使用 final 修饰吗？</strong> 
    <ul>
     <li>抽象类不能用final来修饰。当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法，这明显违背了抽象类存在的意义了。</li> 
    </ul></li> 
  </ul>
  <h2 id="%3D%3D%20%E4%B8%8E%20equals(%E9%87%8D%E8%A6%81)">== 与 equals(重要)</h2> 
  <ul>
   <li><strong>==</strong>&nbsp;: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</li> 
   <li><strong>equals()</strong>&nbsp;: 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</li> 
   <li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li> 
   <li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li> 
  </ul>
  <p><strong>举个例子：</strong></p> 
  <pre class="has">
<code class="language-java">public class test1 {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}</code></pre> 
  <ul>
   <li><strong>说明：</strong> 
    <ul>
     <li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li> 
     <li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li> 
    </ul></li> 
  </ul>
  <h2 id="hashCode%20%E4%B8%8E%20equals%20(%E9%87%8D%E8%A6%81)">hashCode 与 equals (重要)</h2> 
  <ul>
   <li><strong>hashCode（）介绍</strong> 
    <ul>
     <li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</li> 
     <li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li> 
    </ul></li> 
   <li><strong>为什么要有 hashCode</strong> 
    <ul>
     <li>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：&nbsp;当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用&nbsp;<code>equals（）</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li> 
     <li>通过我们可以看出：<code>hashCode()</code>&nbsp;的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</li> 
    </ul></li> 
   <li> <p><strong>hashCode（）与equals（）的相关规定</strong></p> 
    <ul>
     <li>如果两个对象相等，则hashcode一定也是相同的;</li> 
     <li>两个对象相等,对两个对象分别调用equals方法都返回true;</li> 
     <li>两个对象有相同的hashcode值，它们也不一定是相等的（不同的对象也可能产生相同的hashcode，概率性问题）;</li> 
     <li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li> 
     <li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li> 
    </ul></li> 
  </ul>
  <h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">什么是反射机制？反射机制的应用场景有哪些？</h2> 
  <ul>
   <li> <h3 id="%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D">反射机制介绍</h3> 
    <ul>
     <li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li> 
    </ul></li> 
   <li> <h3 id="%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91">静态编译和动态编译</h3> 
    <ul>
     <li><strong>静态编译：</strong>在编译时确定类型，绑定对象•<strong>动态编译：</strong>运行时确定类型，绑定对象</li> 
    </ul></li> 
   <li> <h3 id="%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E7%BC%BA%E7%82%B9">反射机制优缺点</h3> 
    <ul>
     <li><strong>优点：</strong>&nbsp;运行期类型的判断，动态加载类，提高代码灵活度。</li> 
     <li><strong>缺点：</strong>&nbsp;性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li> 
    </ul></li> 
   <li> <h3 id="%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">反射的应用场景</h3> 
    <ul>
     <li>反射是框架设计的灵魂。</li> 
     <li>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li> 
     <li>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</li> 
    </ul></li> 
  </ul>
  <h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%20Java%20%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F">为什么 Java 中只有值传递？</h2> 
  <p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong>&nbsp;它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p> 
  <p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p> 
  <p><strong>下面通过 3 个例子来给大家说明</strong></p> 
  <ul>
   <li>example 1</li> 
   <li> <pre class="has">
<code class="language-java">public static void main(String[] args) {
    int num1 = 10;
    int num2 = 20;

    swap(num1, num2);

    System.out.println("num1 = " + num1);
    System.out.println("num2 = " + num2);
}

public static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;

    System.out.println("a = " + a);
    System.out.println("b = " + b);
}</code></pre> </li> 
   <li>·结果：<img alt="" class="has" height="98" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512013659368.png" width="96"></li> 
   <li>解析：<img alt="" class="has" height="255" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512013711338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAzMjg0,size_16,color_FFFFFF,t_70" width="449"><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p> <p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 </strong></p> </li> 
   <li><strong>example2</strong></li> 
  </ul>
  <pre class="has">
<code class="language-java">public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        System.out.println(arr[0]);
        change(arr);
        System.out.println(arr[0]);
    }

    public static void change(int[] array) {
        // 将数组的第一个元素变为0
        array[0] = 0;
    }</code></pre> 
  <ul>
   <li>结果：<img alt="" class="has" height="48" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512013802965.png" width="43"></li> 
   <li>解析：<img alt="" class="has" height="178" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051201381475.png" width="402">array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。 <p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p> <p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p> </li> 
   <li>example 3</li> 
  </ul>
  <pre class="has">
<code class="language-java">public class Test {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Student s1 = new Student("小张");
        Student s2 = new Student("小李");
        Test.swap(s1, s2);
        System.out.println("s1:" + s1.getName());
        System.out.println("s2:" + s2.getName());
    }

    public static void swap(Student x, Student y) {
        Student temp = x;
        x = y;
        y = temp;
        System.out.println("x:" + x.getName());
        System.out.println("y:" + y.getName());
    }
}</code></pre> 
  <ul>
   <li>结果：<img alt="" class="has" height="96" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512013905445.png" width="73"></li> 
   <li>解析：<img alt="" class="has" height="440" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512013918569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAzMjg0,size_16,color_FFFFFF,t_70" width="568">通过上面两张图可以很清晰的看出：<strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></li> 
   <li><strong>总结：</strong> 
    <ul>
     <li>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</li> 
     <li>下面再总结一下Java中方法参数的使用情况： 
      <ul>
       <li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li> 
       <li>一个方法可以改变一个对象参数的状态。</li> 
       <li>一个方法不能让对象参数引用一个新的对象。</li> 
      </ul></li> 
    </ul></li> 
  </ul>
  <h2 id="Java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9FBIO%2CNIO%2CAIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">Java 中 IO 流分为几种？BIO,NIO,AIO 有什么区别？</h2> 
  <h3 id="java%20%E4%B8%AD%20IO%20%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F">java 中 IO 流分为几种？</h3> 
  <ul>
   <li>按照流的流向分，可以分为输入流和输出流；</li> 
   <li>按照操作单元划分，可以划分为字节流和字符流；</li> 
   <li>按照流的角色划分为节点流和处理流。</li> 
   <li>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</li> 
   <li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li> 
   <li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li> 
   <li>按操作方式分类结构图（图源网络，原出处不明）：</li> 
   <li><img alt="" class="has" height="466" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512014103966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAzMjg0,size_16,color_FFFFFF,t_70" width="414"></li> 
   <li>按操作对象分类结构图</li> 
   <li><img alt="" class="has" height="308" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512014131156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAzMjg0,size_16,color_FFFFFF,t_70" width="538"></li> 
  </ul>
  <h3 id="BIO%2CNIO%2CAIO%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">BIO,NIO,AIO 有什么区别？</h3> 
  <ul>
   <li><strong>BIO (Blocking I/O):</strong>&nbsp;同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li> 
   <li><strong>NIO (New I/O):</strong>&nbsp;NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的&nbsp;<code>Socket</code>&nbsp;和&nbsp;<code>ServerSocket</code>&nbsp;相对应的&nbsp;<code>SocketChannel</code>&nbsp;和&nbsp;<code>ServerSocketChannel</code>&nbsp;两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li> 
   <li><strong>AIO (Asynchronous I/O):</strong>&nbsp;AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li> 
  </ul>
  <p>希望对你有所帮助，感谢浏览！</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
