<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Mel Frequency Cepstral Coefficient (MFCC) tutorial « NotBeCN</title>
  <meta name="description" content="         The first step in any automatic speech recognition system is to extract features i.e. identify the components of the audio signal that are good for ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/YoungLittleT_90137618.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Mel Frequency Cepstral Coefficient (MFCC) tutorial</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>The first step in any automatic speech recognition system is to extract features i.e. identify the components of the audio signal that are good for identifying the linguistic content and discarding all the other stuff which carries information like background noise, emotion etc.</p> 
  <p>The main point to understand about speech is that the sounds generated by a human are filtered by the shape of the vocal tract including tongue, teeth etc. This shape determines what sound comes out. If we can determine the shape accurately, this should give us an accurate representation of the&nbsp;<a href="http://en.wikipedia.org/wiki/Phoneme" rel="nofollow">phoneme</a>&nbsp;being produced. The shape of the vocal tract manifests itself in the envelope of the short time power spectrum, and the job of MFCCs is to accurately represent this envelope. This page will provide a short tutorial on MFCCs.</p> 
  <p>Mel Frequency Cepstral Coefficents (MFCCs) are a feature widely used in automatic speech and speaker recognition. They were introduced by Davis and Mermelstein in the 1980's, and have been state-of-the-art ever since. Prior to the introduction of MFCCs, Linear Prediction Coefficients (LPCs) and Linear Prediction Cepstral Coefficients (LPCCs) (click&nbsp;<a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/tutorial-cepstrum-and-lpccs/" rel="nofollow">here for a tutorial on cepstrum and LPCCs</a>) and were the main feature type for automatic speech recognition (ASR), especially with&nbsp;<a href="http://practicalcryptography.com/miscellaneous/machine-learning/hidden-markov-model-hmm-tutorial/" rel="nofollow">HMM</a>&nbsp;classifiers. This page will go over the main aspects of MFCCs, why they make a good feature for ASR, and how to implement them.</p> 
  <h2>Steps at a Glance&nbsp;</h2> 
  <p>We will give a high level intro to the implementation steps, then go in depth why we do the things we do. Towards the end we will go into a more detailed description of how to calculate MFCCs.</p> 
  <ol>
   <li>Frame the signal into short frames.</li> 
   <li>For each frame calculate the&nbsp;<a href="http://en.wikipedia.org/wiki/Periodogram" rel="nofollow">periodogram estimate</a>&nbsp;of the power spectrum.</li> 
   <li>Apply the mel filterbank to the power spectra, sum the energy in each filter.</li> 
   <li>Take the logarithm of all filterbank energies.</li> 
   <li>Take the DCT of the log filterbank energies.</li> 
   <li>Keep DCT coefficients 2-13, discard the rest.</li> 
  </ol>
  <p>There are a few more things commonly done, sometimes the frame energy is appended to each feature vector.&nbsp;<a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/#deltas-and-delta-deltas" rel="nofollow">Delta and Delta-Delta</a>&nbsp;features are usually also appended. Liftering is also commonly applied to the final features.</p> 
  <h2>Why do we do these things?&nbsp;</h2> 
  <p>We will now go a little more slowly through the steps and explain why each of the steps is necessary.</p> 
  <p>An audio signal is constantly changing, so to simplify things we assume that on short time scales the audio signal doesn't change much (when we say it doesn't change, we mean statistically i.e. statistically stationary, obviously the samples are constantly changing on even short time scales). This is why we frame the signal into 20-40ms frames. If the frame is much shorter we don't have enough samples to get a reliable spectral estimate, if it is longer the signal changes too much throughout the frame.</p> 
  <p>The next step is to calculate the power spectrum of each frame. This is motivated by the human cochlea (an organ in the ear) which vibrates at different spots depending on the frequency of the incoming sounds. Depending on the location in the cochlea that vibrates (which wobbles small hairs), different nerves fire informing the brain that certain frequencies are present. Our periodogram estimate performs a similar job for us, identifying which frequencies are present in the frame.</p> 
  <p>The periodogram spectral estimate still contains a lot of information not required for Automatic Speech Recognition (ASR). In particular the cochlea can not discern the difference between two closely spaced frequencies. This effect becomes more pronounced as the frequencies increase. For this reason we take clumps of periodogram bins and sum them up to get an idea of how much energy exists in various frequency regions. This is performed by our Mel filterbank: the first filter is very narrow and gives an indication of how much energy exists near 0 Hertz. As the frequencies get higher our filters get wider as we become less concerned about variations. We are only interested in roughly how much energy occurs at each spot. The Mel scale tells us exactly how to space our filterbanks and how wide to make them. See&nbsp;<a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/#computing-the-mel-filterbank" rel="nofollow">below</a>&nbsp;for how to calculate the spacing.</p> 
  <p>Once we have the filterbank energies, we take the logarithm of them. This is also motivated by human hearing: we don't hear loudness on a linear scale. Generally to double the percieved volume of a sound we need to put 8 times as much energy into it. This means that large variations in energy may not sound all that different if the sound is loud to begin with. This compression operation makes our features match more closely what humans actually hear. Why the logarithm and not a cube root? The logarithm allows us to use cepstral mean subtraction, which is a channel normalisation technique.</p> 
  <p>The final step is to compute the DCT of the log filterbank energies. There are 2 main reasons this is performed. Because our filterbanks are all overlapping, the filterbank energies are quite correlated with each other. The DCT decorrelates the energies which means diagonal covariance matrices can be used to model the features in e.g. a HMM classifier. But notice that only 12 of the 26 DCT coefficients are kept. This is because the higher DCT coefficients represent fast changes in the filterbank energies and it turns out that these fast changes actually degrade ASR performance, so we get a small improvement by dropping them.</p> 
  <h2>What is the Mel scale?&nbsp;</h2> 
  <p>The Mel scale relates perceived frequency, or pitch, of a pure tone to its actual measured frequency. Humans are much better at discerning small changes in pitch at low frequencies than they are at high frequencies. Incorporating this scale makes our features match more closely what humans hear.</p> 
  <p>The formula for converting from frequency to Mel scale is:</p> 
  <p><a name="eqn1"></a><img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/369d64804e572729863c874aaa092e582bf5eb56-11pt.png"></p> 
  <p>To go from Mels back to frequency:</p> 
  <p><a name="eqn2"></a><img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/05d74bc31f4c2a9c375dd9c95d4642d558f455a0-11pt.png"></p> 
  <h2>Implementation steps&nbsp;</h2> 
  <p>We start with a speech signal, we'll assume sampled at 16kHz.</p> 
  <p>1. Frame the signal into 20-40 ms frames. 25ms is standard. This means the frame length for a 16kHz signal is 0.025*16000 = 400 samples. Frame step is usually something like 10ms (160 samples), which allows some overlap to the frames. The first 400 sample frame starts at sample 0, the next 400 sample frame starts at sample 160 etc. until the end of the speech file is reached. If the speech file does not divide into an even number of frames, pad it with zeros so that it does.</p> 
  <p>The next steps are applied to every single frame, one set of 12 MFCC coefficients is extracted for each frame. A short aside on notation: we call our time domain signal&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/70d1b299ee52431700f44e5e87a9e7c17349a16f-11pt.png">. Once it is framed we have&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/9b3dc4b224cc0c356406dbbdacd54dc5ab3cae9a-11pt.png">where n ranges over 1-400 (if our frames are 400 samples) and&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/2166dcb5865f974c0c285d3bcb1464f65d895074-11pt.png">&nbsp;ranges over the number of frames. When we calculate the complex DFT, we get&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/59416aead1098181fc51ad81b9d8070401c7cf04-11pt.png">&nbsp;- where the&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/2166dcb5865f974c0c285d3bcb1464f65d895074-11pt.png">&nbsp;denotes the frame number corresponding to the time-domain frame.&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/4f6522a52e781c1d01ef30df3b8534d2b920758e-11pt.png">&nbsp;is then the power spectrum of frame&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/2166dcb5865f974c0c285d3bcb1464f65d895074-11pt.png">.</p> 
  <p>2. To take the Discrete Fourier Transform of the frame, perform the following:</p> 
  <p><img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/c970f070a776e4c900bd3e8a2082a2971236b013-11pt.png"></p> 
  <p>where&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/dc52f5afe0e59b4ed07b222ebcb7832bfa6579ad-11pt.png">&nbsp;is an&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/50ec1aff7eaddddda99094b6cc7c602dc3c98245-11pt.png">&nbsp;sample long analysis window (e.g. hamming window), and&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/6eee515a89159b28568cb0744e3a8d5a68ab8d26-11pt.png">&nbsp;is the length of the DFT. The periodogram-based power spectral estimate for the speech frame&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/9b3dc4b224cc0c356406dbbdacd54dc5ab3cae9a-11pt.png">&nbsp;is given by:</p> 
  <p><img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/c526edb9d52e631812798237ea3f2beea496d181-11pt.png"></p> 
  <p>This is called the Periodogram estimate of the power spectrum. We take the absolute value of the complex fourier transform, and square the result. We would generally perform a 512 point FFT and keep only the first 257 coefficents.</p> 
  <p>3. Compute the Mel-spaced filterbank. This is a set of 20-40 (26 is standard) triangular filters that we apply to the periodogram power spectral estimate from step 2. Our filterbank comes in the form of 26 vectors of length 257 (assuming the FFT settings fom step 2). Each vector is mostly zeros, but is non-zero for a certain section of the spectrum. To calculate filterbank energies we multiply each filterbank with the power spectrum, then add up the coefficents. Once this is performed we are left with 26 numbers that give us an indication of how much energy was in each filterbank. For a detailed explanation of how to calculate the filterbanks see&nbsp;<a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/#computing-the-mel-filterbank" rel="nofollow">below</a>. Here is a plot to hopefully clear things up:</p> 
  <p><img alt="Plot of Mel Filterbank and windowed power spectrum" class="has" src="http://www.practicalcryptography.com/media/miscellaneous/files/mel_filterbank_example.png"></p> 
  <p>Plot of Mel Filterbank and windowed power spectrum</p> 
  <p>4. Take the log of each of the 26 energies from step 3. This leaves us with 26 log filterbank energies.</p> 
  <p>5. Take the Discrete Cosine Transform (DCT) of the 26 log filterbank energies to give 26 cepstral coefficents. For ASR, only the lower 12-13 of the 26 coefficients are kept.</p> 
  <p>The resulting features (12 numbers for each frame) are called Mel Frequency Cepstral Coefficients.</p> 
  <h2>Computing the Mel filterbank&nbsp;</h2> 
  <p>In this section the example will use 10 filterbanks because it is easier to display, in reality you would use 26-40 filterbanks.</p> 
  <p>To get the filterbanks shown in figure 1(a) we first have to choose a lower and upper frequency. Good values are 300Hz for the lower and 8000Hz for the upper frequency. Of course if the speech is sampled at 8000Hz our upper frequency is limited to 4000Hz. Then follow these steps:</p> 
  <ol>
   <li>Using&nbsp;<a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/#eqn1" rel="nofollow">equation 1</a>, convert the upper and lower frequencies to Mels. In our case 300Hz is 401.25 Mels and 8000Hz is 2834.99 Mels.</li> 
   <li>For this example we will do 10 filterbanks, for which we need 12 points. This means we need 10 additional points spaced linearly between 401.25 and 2834.99. This comes out to: <pre>
m(i) = 401.25, 622.50, 843.75, 1065.00, 1286.25, 1507.50, 1728.74, 
       1949.99, 2171.24, 2392.49, 2613.74, 2834.99</pre> </li> 
   <li>Now use&nbsp;<a href="http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/#eqn2" rel="nofollow">equation 2</a>&nbsp;to convert these back to Hertz: <pre>
h(i) = 300, 517.33, 781.90, 1103.97, 1496.04, 1973.32, 2554.33, 
       3261.62, 4122.63, 5170.76, 6446.70, 8000</pre> Notice that our start- and end-points are at the frequencies we wanted.</li> 
   <li>We don't have the frequency resolution required to put filters at the exact points calculated above, so we need to round those frequencies to the nearest FFT bin. This process does not affect the accuracy of the features. To convert the frequncies to fft bin numbers we need to know the FFT size and the sample rate, <pre>
f(i) = floor((nfft+1)*h(i)/samplerate)</pre> This results in the following sequence: <pre>
f(i) =  9, 16,  25,   35,   47,   63,   81,  104,  132, 165,  206,  256</pre> We can see that the final filterbank finishes at bin 256, which corresponds to 8kHz with a 512 point FFT size.</li> 
   <li>Now we create our filterbanks. The first filterbank will start at the first point, reach its peak at the second point, then return to zero at the 3rd point. The second filterbank will start at the 2nd point, reach its max at the 3rd, then be zero at the 4th etc. A formula for calculating these is as follows:<br><img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/9dbdba8524bc6c95d056048f37b0a4ea4194de45-11pt.png"><br> where&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/1697b5c24713e54de1923d78f7dddf294f238490-11pt.png">&nbsp;is the number of filters we want, and&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/3846541a4d8c54b4f92280b77f7bddeeebf0a4ae-11pt.png">&nbsp;is the list of M+2 Mel-spaced frequencies.</li> 
  </ol>
  <p>The final plot of all 10 filters overlayed on each other is:</p> 
  <p><img alt="Plot of 10 filter Mel Filterbank" class="has" src="http://www.practicalcryptography.com/media/miscellaneous/files/10_filt_melfb.png"></p> 
  <p>A Mel-filterbank containing 10 filters. This filterbank starts at 0Hz and ends at 8000Hz. This is a guide only, the worked example above starts at 300Hz.</p> 
  <h2>Deltas and Delta-Deltas&nbsp;</h2> 
  <p>Also known as differential and acceleration coefficients. The MFCC feature vector describes only the power spectral envelope of a single frame, but it seems like speech would also have information in the dynamics i.e. what are the trajectories of the MFCC coefficients over time. It turns out that calculating the MFCC trajectories and appending them to the original feature vector increases ASR performance by quite a bit (if we have 12 MFCC coefficients, we would also get 12 delta coefficients, which would combine to give a feature vector of length 24).</p> 
  <p>To calculate the delta coefficients, the following formula is used:</p> 
  <p><img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/542b8743573ec3ff3ddbfd965512d484bc1a1818-11pt.png"></p> 
  <p>where&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/0ebc849fb6b661203c93346c162b470565acd724-11pt.png">&nbsp;is a delta coefficient, from frame&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/dee6308e7a1c17e1311800c9912280deb4d0c2cf-11pt.png">&nbsp;computed in terms of the static coefficients&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/0f102270d35423bfa3612c54b1f872703a5f9266-11pt.png">&nbsp;to&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/2e8c1c5ca3f3ed9fe2aa30ab706375631430fb4c-11pt.png">. A typical value for&nbsp;<img alt="" class="has" src="http://www.practicalcryptography.com/media/latex/50ec1aff7eaddddda99094b6cc7c602dc3c98245-11pt.png">&nbsp;is 2. Delta-Delta (Acceleration) coefficients are calculated in the same way, but they are calculated from the deltas, not the static coefficients.</p> 
  <h2>Implementations&nbsp;</h2> 
  <p>I have implemented MFCCs in python, available&nbsp;<a href="https://github.com/jameslyons/python_speech_features" rel="nofollow">here</a>. Use the 'Download ZIP' button on the right hand side of the page to get the code. Documentation can be found at&nbsp;<a href="http://python-speech-features.readthedocs.org/en/latest/" rel="nofollow">readthedocs</a>. If you have any troubles or queries about the code, you can leave a comment at the bottom of this page.</p> 
  <p>There is a good MATLAB implementation of MFCCs&nbsp;<a href="http://labrosa.ee.columbia.edu/matlab/rastamat/" rel="nofollow">over here</a>.</p> 
  <h2>References&nbsp;</h2> 
  <p>Davis, S. Mermelstein, P. (1980)&nbsp;<em>Comparison of Parametric Representations for Monosyllabic Word Recognition in Continuously Spoken Sentences</em>. In IEEE Transactions on Acoustics, Speech, and Signal Processing, Vol. 28 No. 4, pp. 357-366</p> 
  <p>X. Huang, A. Acero, and H. Hon.&nbsp;<em>Spoken Language Processing: A guide to theory, algorithm, and system development</em>. Prentice Hall, 2001.</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
