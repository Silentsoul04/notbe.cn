<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>shell 用法 « NotBeCN</title>
  <meta name="description" content="                  本文为粘贴,来源找不到了,如果有侵权请联系   kldn 1. Linux 脚本编写基础1.1 语法基本介绍1.1.1 开头       程序必须以下面的行开始（必须放在文件的第一行）：       #!/bin/sh　   符号#!用来告诉系统它后面的参数是用来执行该文件的程...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/late_tender_90137607.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">shell 用法</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="_0"></a>本文为粘贴,来源找不到了,如果有侵权请联系</h1> 
  <pre><code class="prism language-shell">kldn 1. Linux 脚本编写基础
1.1 语法基本介绍
1.1.1 开头
       程序必须以下面的行开始（必须放在文件的第一行）：
       <span class="token comment">#!/bin/sh</span>
　   符号<span class="token comment">#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。 当编辑好脚本时，如果要执行该脚本，还必须使其可执行。</span>
　   要使脚本可执行：   编译 <span class="token function">chmod</span> +x filename 这样才能用./filename 来运行
1.1.2 注释
　　在进行shell编程时，以<span class="token comment">#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。</span>
1.1.3 变量
　　在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：
        <span class="token comment">#!/bin/sh</span>
        <span class="token comment">#对变量赋值：</span>
        a<span class="token operator">=</span><span class="token string">"hello world"</span>
        <span class="token comment"># 现在打印变量a的内容：</span>
        <span class="token keyword">echo</span> <span class="token string">"A is:"</span>
        <span class="token keyword">echo</span> ＄a
       有时候变量名很容易与其他文字混淆，比如：
        num<span class="token operator">=</span>2
        <span class="token keyword">echo</span> <span class="token string">"this is the ＄numnd"</span>
       这并不会打印出<span class="token string">"this is the 2nd"</span>，而仅仅打印<span class="token string">"this is the "</span>，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：
        num<span class="token operator">=</span>2
        <span class="token keyword">echo</span> <span class="token string">"this is the ＄{num}nd"</span>
　　      这将打印： this is the 2nd
1.1.4 环境变量
       由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录
脚本中使用环境变量。
1.1.5 Shell命令和流程控制
       在shell脚本中可以使用三类命令：
       1<span class="token punctuation">)</span>Unix 命令:
　　    虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。
        常用命令语法及功能
　　<span class="token keyword">echo</span> <span class="token string">"some text"</span><span class="token keyword">:</span> 将文字内容打印在屏幕上
　　ls: 文件列表
　　<span class="token function">wc</span> –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数
　　<span class="token function">cp</span> sourcefile destfile: 文件拷贝
　　<span class="token function">mv</span> oldname newname <span class="token keyword">:</span> 重命名文件或移动文件
　　<span class="token function">rm</span> file: 删除文件
　　<span class="token function">grep</span> <span class="token string">'pattern'</span> file: 在文件内搜索字符串比如：grep <span class="token string">'searchstring'</span> file.txt
　　<span class="token function">cut</span> -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令
　　<span class="token function">cat</span> file.txt: 输出文件内容到标准输出设备（屏幕）上
　　<span class="token function">file</span> somefile: 得到文件类型
　　<span class="token function">read</span> var: 提示用户输入，并将输入赋值给变量
　　<span class="token function">sort</span> file.txt: 对file.txt文件中的行进行排序
　　uniq: 删除文本文件中出现的行列比如： <span class="token function">sort</span> file.txt <span class="token operator">|</span> <span class="token function">uniq</span>
　　expr: 进行数学运算Example: add 2 and 3expr 2 <span class="token string">"+"</span> 3
　　find: 搜索文件比如：根据文件名搜索find <span class="token keyword">.</span> -name filename -print
　　tee: 将数据输出到标准输出设备<span class="token punctuation">(</span>屏幕<span class="token punctuation">)</span> 和文件比如：somecommand <span class="token operator">|</span> <span class="token function">tee</span> outfile
　　<span class="token function">basename</span> file: 返回不包含路径的文件名比如： <span class="token function">basename</span> /bin/tux将返回 tux
　　<span class="token function">dirname</span> file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin
　　<span class="token function">head</span> file: 打印文本文件开头几行
　　<span class="token function">tail</span> <span class="token function">file</span> <span class="token keyword">:</span> 打印文本文件末尾几行
　　sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为LinuxFocus ：cat text.file <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/linuxfocus/LinuxFocus/'</span> <span class="token operator">&gt;</span> newtext.file
　　awk: <span class="token function">awk</span> 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。
<span class="token function">cat</span> file.txt <span class="token operator">|</span> <span class="token function">awk</span> -F, <span class="token string">'{print ＄1 "," ＄3 }'</span>这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA
        命令输出结果为：Adam Bor, IndiaKerry Miller, USA
        2<span class="token punctuation">)</span> 概念: 管道, 重定向和 backtick
　　这些不是系统命令，但是他们真的很重要。
　　管道 <span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">)</span> 将一个命令的输出作为另外一个命令的输入。
                 <span class="token function">grep</span> <span class="token string">"hello"</span> file.txt <span class="token operator">|</span> <span class="token function">wc</span> -l
　　在file.txt中搜索包含有”hello”的行并计算其行数。
　　在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。
　　重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。
　　    <span class="token operator">&gt;</span> 写入文件并覆盖旧文件
　　    <span class="token operator">&gt;&gt;</span> 加到文件的尾部，保留旧文件内容。
        反短斜线
　    使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。
         命令：
           <span class="token function">find</span> <span class="token keyword">.</span> -mtime -1 -type f -print
　　   用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：
             <span class="token comment">#!/bin/sh</span>
             <span class="token comment"># The ticks are backticks (`) not normal quotes ('):</span>
              <span class="token function">tar</span> -zcvf lastmod.tar.gz <span class="token variable"><span class="token variable">`</span><span class="token function">find</span> <span class="token keyword">.</span> -mtime -1 -type f -print<span class="token variable">`</span></span>
       3<span class="token punctuation">)</span> 流程控制
        1.if
　　  <span class="token string">"if"</span> 表达式 如果条件为真则执行then后面的部分：
            <span class="token keyword">if</span> <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　          <span class="token punctuation">..</span><span class="token punctuation">..</span>
           <span class="token keyword">elif</span> <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　          <span class="token punctuation">..</span><span class="token punctuation">..</span>
           <span class="token keyword">else</span>
　          <span class="token punctuation">..</span><span class="token punctuation">..</span>
           <span class="token keyword">fi</span>
           大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…
　　  通常用<span class="token string">" [ ] "</span>来表示条件测试。注意这里的空格很重要。要确保方括号的空格。
                 <span class="token punctuation">[</span> -f <span class="token string">"somefile"</span> <span class="token punctuation">]</span> ：判断是否是一个文件
                 <span class="token punctuation">[</span> -x <span class="token string">"/bin/ls"</span> <span class="token punctuation">]</span> ：判断/bin/ls是否存在并有可执行权限
                 <span class="token punctuation">[</span> -n <span class="token string">"＄var"</span> <span class="token punctuation">]</span> ：判断＄var变量是否有值
                 <span class="token punctuation">[</span> <span class="token string">"＄a"</span> <span class="token operator">=</span> <span class="token string">"＄b"</span> <span class="token punctuation">]</span> ：判断＄a和＄b是否相等
　　  执行man test可以查看所有测试表达式可以比较和判断的类型。
　　 直接执行以下脚本：
               <span class="token comment">#!/bin/sh</span>
               <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"＄SHELL"</span> <span class="token operator">=</span> <span class="token string">"/bin/bash"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　                   <span class="token keyword">echo</span> <span class="token string">"your login shell is the bash (bourne again shell)"</span>
               <span class="token keyword">else</span>
　                   <span class="token keyword">echo</span> <span class="token string">"your login shell is not bash but ＄SHELL"</span>
               <span class="token keyword">fi</span>
　　 变量＄SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。
        
        快捷操作符
        熟悉C语言的朋友可能会很喜欢下面的表达式：
                  <span class="token punctuation">[</span> -f <span class="token string">"/etc/shadow"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"This computer uses shadow passwors"</span>
　　这里 <span class="token operator">&amp;&amp;</span> 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作<span class="token punctuation">(</span><span class="token operator">||</span><span class="token punctuation">)</span>在shell编程中也是可用的。这里有个例子：
                 <span class="token comment">#!/bin/sh</span>
                 mailfolder<span class="token operator">=</span>/var/spool/mail/james
                 <span class="token punctuation">[</span> -r <span class="token string">"＄mailfolder"</span> <span class="token punctuation">]</span><span class="token string">' '</span><span class="token punctuation">{</span> <span class="token keyword">echo</span> <span class="token string">"Can not read ＄mailfolder"</span> <span class="token punctuation">;</span> <span class="token keyword">exit</span> 1<span class="token punctuation">;</span> <span class="token punctuation">}</span>
                 <span class="token keyword">echo</span> <span class="token string">"＄mailfolder has mail from:"</span>
                 <span class="token function">grep</span> <span class="token string">"^From "</span> ＄mailfolder
        该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的<span class="token string">"From"</span> 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：
　　-打印错误信息
　　-退出程序
　　我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。
　　不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。

         2.case
               <span class="token keyword">case</span> :表达式可以用来匹配一个给定的字符串，而不是数字。
                      <span class="token keyword">case</span> <span class="token punctuation">..</span>. <span class="token keyword">in</span>
                            <span class="token punctuation">..</span>.<span class="token punctuation">)</span> <span class="token keyword">do</span> something here <span class="token punctuation">;</span><span class="token punctuation">;</span>
                      esac
　　       让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：
                     <span class="token function">file</span> lf.gz
　　                 这将返回：
                         lf.gz: <span class="token function">gzip</span> compressed data, deflated, original filename,
                         last modified: Mon Aug 27 23:09:18 2001, os: Unix
　            我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, <span class="token function">gzip</span> 和zip 类型的压缩文件：
               <span class="token comment">#!/bin/sh</span>
               ftype<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">file</span> <span class="token string">"＄1"</span><span class="token variable">`</span></span>
               <span class="token keyword">case</span> <span class="token string">"＄ftype"</span> <span class="token keyword">in</span>
                       <span class="token string">"＄1: Zip archive"</span>*<span class="token punctuation">)</span>
　　                unzip <span class="token string">"＄1"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
                         <span class="token string">"＄1: gzip compressed"</span>*<span class="token punctuation">)</span>
　　                  gunzip <span class="token string">"＄1"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
                          <span class="token string">"＄1: bzip2 compressed"</span>*<span class="token punctuation">)</span>
　　                   bunzip2 <span class="token string">"＄1"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>
                           *<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"File ＄1 can not be uncompressed with smartzip"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                esac
　　       您可能注意到我们在这里使用了一个特殊的变量＄1。该变量包含了传递给该程序的第一个参数值。
也就是说，当我们运行：
                    smartzip articles.zip
                    ＄1 就是字符串 articles.zip
                3. selsect
                  <span class="token keyword">select</span> 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。
                    <span class="token keyword">select</span> var <span class="token keyword">in</span> <span class="token punctuation">..</span>. <span class="token punctuation">;</span> <span class="token keyword">do</span>
　                        <span class="token keyword">break</span>
                            <span class="token keyword">done</span>
                            <span class="token punctuation">..</span><span class="token punctuation">..</span> now ＄ var can be used <span class="token punctuation">..</span><span class="token punctuation">..</span>
                   下面是一个例子：
                         <span class="token comment">#!/bin/sh</span>
                         <span class="token keyword">echo</span> <span class="token string">"What is your favourite OS?"</span>
                         <span class="token keyword">select</span> var <span class="token keyword">in</span> <span class="token string">"Linux"</span> <span class="token string">"Gnu Hurd"</span> <span class="token string">"Free BSD"</span> <span class="token string">"Other"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
　　　　                <span class="token keyword">break</span>
                                <span class="token keyword">done</span>
                           <span class="token keyword">echo</span> <span class="token string">"You have selected ＄var"</span>
　　            下面是该脚本运行的结果：
                               What is your favourite OS?
                                    1<span class="token punctuation">)</span> Linux
                                    2<span class="token punctuation">)</span> Gnu Hurd
                                    3<span class="token punctuation">)</span> Free BSD
                                    4<span class="token punctuation">)</span> Other
                                  <span class="token comment">#? 1</span>
                                You have selected Linux
         注：var是个变量，可以换成其它的值。break用来跳出循环，如果没有break则一直循环下去。done与select对应。
                  4.loop
                      loop表达式：
                            <span class="token keyword">while</span> <span class="token punctuation">..</span>.<span class="token punctuation">;</span> <span class="token keyword">do</span>
                                      <span class="token punctuation">..</span><span class="token punctuation">..</span>
                               <span class="token keyword">done</span>
　　           while-loop 将运行直到表达式测试为真。will run <span class="token keyword">while</span> the expression that we <span class="token function">test</span> <span class="token keyword">for</span> is true.
关键字<span class="token string">"break"</span> 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。
　　
                     for-loop表达式查看一个字符串列表 <span class="token punctuation">(</span>字符串用空格分隔<span class="token punctuation">)</span> 然后将其赋给一个变量：
                          1,   <span class="token keyword">for</span> var <span class="token keyword">in</span> <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
　                                <span class="token punctuation">..</span><span class="token punctuation">..</span>
                                <span class="token keyword">done</span>
                       在下面的例子中，将分别打印ABC到屏幕上：
                            <span class="token comment">#!/bin/sh</span>
                                    <span class="token keyword">for</span> var <span class="token keyword">in</span> A B C <span class="token punctuation">;</span> <span class="token keyword">do</span>
　                                <span class="token keyword">echo</span> <span class="token string">"var is ＄var"</span>
                                     <span class="token keyword">done</span>

                           2,   <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> 条件一<span class="token punctuation">;</span> 条件二<span class="token punctuation">;</span> 条件三 <span class="token punctuation">)</span><span class="token punctuation">;</span>do ... done 例： for <span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">=</span>＄[＄i<span class="token operator">+</span><span class="token number">1</span>]<span class="token punctuation">))</span></span><span class="token punctuation">;</span><span class="token keyword">do</span>

                             <span class="token keyword">echo</span> <span class="token string">"a"</span>
                          <span class="token keyword">done</span>
输出：

a
a
a
a
a
a
a
a
a

条件一：这可以看成是『初始值』，如上面的例子中，初始值是 i<span class="token operator">=</span>1 啦！
条件二：这可以看成是『符合值』，如上面的例子中，当 i<span class="token operator">&lt;=</span>100 的时候都是符合条件的！
条件三：这可以看成是『步阶』！也就是说， i 每次都加一！ 所以啦！上面的例子是说：由 i<span class="token operator">=</span>1 开始到 i<span class="token operator">&lt;=</span> 100 ，每次 i 都加一来执行底下的程序段（就是 s<span class="token operator">=</span>s+i ），当 i <span class="token operator">&gt;</span>100 （也就是 i<span class="token operator">=</span>101 ）就跳出这一段程序段！怎样！不难吧！




                        下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：
                          <span class="token comment">#!/bin/sh</span>
                          <span class="token comment"># list a content summary of a number of RPM packages</span>
                          <span class="token comment"># USAGE: showrpm rpmfile1 rpmfile2 ...</span>
                          <span class="token comment"># EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm</span>
                            <span class="token keyword">for</span> rpmpackage <span class="token keyword">in</span> ＄*<span class="token punctuation">;</span> <span class="token keyword">do</span>
　                        <span class="token keyword">if</span> <span class="token punctuation">[</span> -r <span class="token string">"＄rpmpackage"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>
　　                       <span class="token keyword">echo</span> <span class="token string">"=============== ＄rpmpackage =============="</span>
　　                        rpm -qi -p ＄rpmpackage
　                         <span class="token keyword">else</span>
　　                         <span class="token keyword">echo</span> <span class="token string">"ERROR: cannot read file ＄rpmpackage"</span>
　                        <span class="token keyword">fi</span>
                              <span class="token keyword">done</span>
　　                 这里出现了第二个特殊的变量＄*，该变量包含了所有输入的命令行参数值。
                        如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm
                                   此时 ＄* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.



『until：直到条件相同的时候才离开程序』；
『while：当条件相同的时候，就继续做！』  

<span class="token keyword">until</span> <span class="token punctuation">[</span> condition1 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token operator">||</span> <span class="token punctuation">}</span> <span class="token punctuation">[</span> condition2 <span class="token punctuation">]</span> <span class="token punctuation">..</span>.




                 5. 引号
                   在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防 止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。
          编译SHELL脚本
          <span class="token comment">#ch#!/bin/sh mod +x filename</span>
　cho *.jpg       ./filename 来执行您的脚本。
　　这将打印出<span class="token string">"mail.jpg tux.jpg"</span>的结果。
　 　　引号 <span class="token punctuation">(</span>单引号和双引号<span class="token punctuation">)</span> 将防止这种通配符扩展：
             <span class="token comment">#!/bin/sh</span>
             <span class="token keyword">echo</span> <span class="token string">"*.jpg"</span>
             <span class="token keyword">echo</span> <span class="token string">'*.jpg'</span>
　　这将打印<span class="token string">"*.jpg"</span> 两次。
　　单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。
         <span class="token comment">#!/bin/sh</span>
         <span class="token keyword">echo</span> ＄SHELL
         <span class="token keyword">echo</span> <span class="token string">"＄SHELL"</span>
         <span class="token keyword">echo</span> <span class="token string">'＄SHELL'</span>
　　 运行结果为：
             /bin/bash
             /bin/bash
             ＄SHELL
　　最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：
           <span class="token keyword">echo</span> *.jpg
           <span class="token keyword">echo</span> ＄SHELL
　　这将输出：
           *.jpg
           ＄SHELL
         6. Here documents
          当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译）一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents就不必用echo函数一行行输出。 一个 <span class="token string">"Here document"</span> 以 <span class="token operator">&lt;&lt;</span> 开头，后面接上一个字符串，这个字符串还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here documents打印帮助：
         <span class="token comment">#!/bin/sh</span>
         <span class="token comment"># we have less than 3 arguments. Print the help text:</span>
            <span class="token keyword">if</span> <span class="token punctuation">[</span> ＄<span class="token comment"># -lt 3 ] ; then</span>
                 <span class="token function">cat</span> <span class="token operator">&lt;</span>
                 ren -- renames a number of files using <span class="token function">sed</span> regular expressions
                 USAGE: ren <span class="token string">'regexp'</span> <span class="token string">'replacement'</span> files<span class="token punctuation">..</span>.
                 EXAMPLE: <span class="token function">rename</span> all *.HTM files <span class="token keyword">in</span> *.html:
　             ren <span class="token string">'HTM＄'</span> <span class="token string">'html'</span> *.HTM
                 HELP
　             <span class="token keyword">exit</span> 0
            <span class="token keyword">fi</span>
            OLD<span class="token operator">=</span><span class="token string">"＄1"</span>
            NEW<span class="token operator">=</span><span class="token string">"＄2"</span>
          <span class="token comment"># The shift command removes one argument from the list of</span>
          <span class="token comment"># command line arguments.</span>
          <span class="token function">shift</span>
          <span class="token function">shift</span>
          <span class="token comment"># ＄* contains now all the files:</span>
         <span class="token keyword">for</span> <span class="token function">file</span> <span class="token keyword">in</span> ＄*<span class="token punctuation">;</span> <span class="token keyword">do</span>
　　        <span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token string">"＄file"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　          newfile<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> <span class="token string">"＄file"</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/＄{OLD}/＄{NEW}/g"</span><span class="token variable">`</span></span>
　　　          <span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token string">"＄newfile"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　　              <span class="token keyword">echo</span> <span class="token string">"ERROR: ＄newfile exists already"</span>
　　　          <span class="token keyword">else</span>
　　　　              <span class="token keyword">echo</span> <span class="token string">"renaming ＄file to ＄newfile ..."</span>
　　　　              <span class="token function">mv</span> <span class="token string">"＄file"</span> <span class="token string">"＄newfile"</span>
　　　           <span class="token keyword">fi</span>
　　          <span class="token keyword">fi</span>
           <span class="token keyword">done</span>
　       这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 <span class="token punctuation">(</span>特殊变量＄<span class="token comment"># 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参数列表＄*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量＄file。接着我 们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目 的：得到了旧文件名和新</span>
文件名。然后使用mv命令进行重命名。
          4<span class="token punctuation">)</span>函数
             如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：
          functionname<span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
                 <span class="token comment"># inside the body ＄1 is the first argument given to the function</span>
                 <span class="token comment"># ＄2 the second ...</span>
                             body
            <span class="token punctuation">}</span>
          您需要在每个程序的开始对函数进行声明。
　　 下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。
           这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。
               <span class="token comment">#!/bin/sh</span>
               <span class="token comment"># vim: set sw=4 ts=4 et:</span>
               help<span class="token punctuation">(</span><span class="token punctuation">)</span>
               <span class="token punctuation">{</span>
　　            <span class="token function">cat</span> <span class="token operator">&lt;</span>
                     xtitlebar -- change the name of an xterm, gnome-terminal or kde konsole
                     USAGE: xtitlebar <span class="token punctuation">[</span>-h<span class="token punctuation">]</span> <span class="token string">"string_for_titelbar"</span>
                      OPTIONS: -h <span class="token function">help</span> text
                     EXAMPLE: xtitlebar <span class="token string">"cvs"</span>
                     HELP
　　           <span class="token keyword">exit</span> 0
               <span class="token punctuation">}</span>
               <span class="token comment"># in case of error or if -h is given we call the function help:</span>
               <span class="token punctuation">[</span> -z <span class="token string">"＄1"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">help</span>
               <span class="token punctuation">[</span> <span class="token string">"＄1"</span> <span class="token operator">=</span> <span class="token string">"-h"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">help</span>
               <span class="token comment"># send the escape sequence to change the xterm titelbar:</span>
                 <span class="token keyword">echo</span> -e <span class="token string">"33]0;＄107"</span>
                <span class="token comment">#</span>
            在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。
        命令行参数
　　我们已经见过＄* 和 ＄1, ＄2 <span class="token punctuation">..</span>. ＄9 等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的参数和查看帮助的-h选项）。 但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 <span class="token punctuation">(</span>比如文件名<span class="token punctuation">)</span>。有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。
         <span class="token comment">#!/bin/sh</span>
         help<span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
　           <span class="token function">cat</span> <span class="token operator">&lt;</span>
               This is a generic <span class="token function">command</span> line parser demo.
               USAGE EXAMPLE: cmdparser -l hello -f -- -somefile1 somefile2
               HELP
　           <span class="token keyword">exit</span> 0
         <span class="token punctuation">}</span>
          <span class="token keyword">while</span> <span class="token punctuation">[</span> -n <span class="token string">"＄1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
        <span class="token keyword">case</span> ＄1 <span class="token keyword">in</span>
　　     -h<span class="token punctuation">)</span> <span class="token function">help</span><span class="token punctuation">;</span><span class="token function">shift</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># function help is called</span>
　　     -f<span class="token punctuation">)</span> opt_f<span class="token operator">=</span>1<span class="token punctuation">;</span><span class="token function">shift</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># variable opt_f is set</span>
　　      -l<span class="token punctuation">)</span> opt_l<span class="token operator">=</span>＄2<span class="token punctuation">;</span><span class="token function">shift</span> 2<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># -l takes an argument -&gt; shift by 2</span>
　　      --<span class="token punctuation">)</span> <span class="token function">shift</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># end of options</span>
　　     -*<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"error: no such option ＄1. -h for help"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span>
　　     *<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
          esac
          <span class="token keyword">done</span>
          <span class="token keyword">echo</span> <span class="token string">"opt_f is ＄opt_f"</span>
          <span class="token keyword">echo</span> <span class="token string">"opt_l is ＄opt_l"</span>
          <span class="token keyword">echo</span> <span class="token string">"first arg is ＄1"</span>
          <span class="token keyword">echo</span> <span class="token string">"2nd arg is ＄2"</span>
　　您可以这样运行该脚本：
                 cmdparser -l hello -f -- -somefile1 somefile2
　　返回的结果是：
             opt_f is 1
             opt_l is hello
             first arg is -somefile1
             2nd arg is somefile2
　　这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数.


第2部分 实例

    现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：
<span class="token function">cp</span> framework.sh myscript
　然后再插入自己的函数。
　　让我们再看两个例子：
　　二进制到十进制的转换
　　脚本 b2d 将二进制数 <span class="token punctuation">(</span>比如 1101<span class="token punctuation">)</span> 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：
<span class="token comment">#!/bin/sh</span>
<span class="token comment"># vim: set sw=4 ts=4 et:</span>
help<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
　<span class="token function">cat</span> <span class="token operator">&lt;</span>
b2h -- convert binary to decimal
USAGE: b2h <span class="token punctuation">[</span>-h<span class="token punctuation">]</span> binarynum
OPTIONS: -h <span class="token function">help</span> text
EXAMPLE: b2h 111010
will <span class="token keyword">return</span> 58
HELP
　<span class="token keyword">exit</span> 0
<span class="token punctuation">}</span>
error<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
　　<span class="token comment"># print an error and exit</span>
　　<span class="token keyword">echo</span> <span class="token string">"＄1"</span>
　　<span class="token keyword">exit</span> 1
<span class="token punctuation">}</span>
lastchar<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
　　<span class="token comment"># return the last character of a string in ＄rval</span>
　　<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"＄1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　　<span class="token comment"># empty string</span>
　　　　rval<span class="token operator">=</span><span class="token string">""</span>
　　　　<span class="token keyword">return</span>
　　<span class="token keyword">fi</span>
　　<span class="token comment"># wc puts some space behind the output this is why we need sed:</span>
　　numofchar<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> -n <span class="token string">"＄1"</span> <span class="token operator">|</span> <span class="token function">wc</span> -c <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ //g'</span> <span class="token variable">`</span></span>
　　<span class="token comment"># now cut out the last char</span>
　　rval<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> -n <span class="token string">"＄1"</span> <span class="token operator">|</span> <span class="token function">cut</span> -b ＄numofchar<span class="token variable">`</span></span>
<span class="token punctuation">}</span>
chop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
　　<span class="token comment"># remove the last character in string and return it in ＄rval</span>
　　<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"＄1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　　<span class="token comment"># empty string</span>
　　　　rval<span class="token operator">=</span><span class="token string">""</span>
　　　　<span class="token keyword">return</span>
　　<span class="token keyword">fi</span>
　　<span class="token comment"># wc puts some space behind the output this is why we need sed:</span>
　　numofchar<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> -n <span class="token string">"＄1"</span> <span class="token operator">|</span> <span class="token function">wc</span> -c <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/ //g'</span> <span class="token variable">`</span></span>
　　<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"＄numofchar"</span> <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　　<span class="token comment"># only one char in string</span>
　　　　rval<span class="token operator">=</span><span class="token string">""</span>
　　　　<span class="token keyword">return</span>
　　<span class="token keyword">fi</span>
　　numofcharminus1<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> ＄numofchar <span class="token string">"-"</span> 1<span class="token variable">`</span></span>
　　<span class="token comment"># now cut all but the last char:</span>
　　rval<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">echo</span> -n <span class="token string">"＄1"</span> <span class="token operator">|</span> <span class="token function">cut</span> -b 0-＄<span class="token punctuation">{</span>numofcharminus1<span class="token punctuation">}</span><span class="token variable">`</span></span>
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> -n <span class="token string">"＄1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
<span class="token keyword">case</span> ＄1 <span class="token keyword">in</span>
　　-h<span class="token punctuation">)</span> <span class="token function">help</span><span class="token punctuation">;</span><span class="token function">shift</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># function help is called</span>
　　--<span class="token punctuation">)</span> <span class="token function">shift</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment"># end of options</span>
　　-*<span class="token punctuation">)</span> error <span class="token string">"error: no such option ＄1. -h for help"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
　　*<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
esac
<span class="token keyword">done</span>
<span class="token comment"># The main program</span>
sum<span class="token operator">=</span>0
weight<span class="token operator">=</span>1
<span class="token comment"># one arg must be given:</span>
<span class="token punctuation">[</span> -z <span class="token string">"＄1"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">help</span>
binnum<span class="token operator">=</span><span class="token string">"＄1"</span>
binnumorig<span class="token operator">=</span><span class="token string">"＄1"</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> -n <span class="token string">"＄binnum"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
　　lastchar <span class="token string">"＄binnum"</span>
　　<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"＄rval"</span> <span class="token operator">=</span> <span class="token string">"1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　　sum<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> <span class="token string">"＄weight"</span> <span class="token string">"+"</span> <span class="token string">"＄sum"</span><span class="token variable">`</span></span>
　　<span class="token keyword">fi</span>
　　<span class="token comment"># remove the last position in ＄binnum</span>
　　chop <span class="token string">"＄binnum"</span>
　　binnum<span class="token operator">=</span><span class="token string">"＄rval"</span>
　　weight<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> <span class="token string">"＄weight"</span> <span class="token string">"*"</span> 2<span class="token variable">`</span></span>
<span class="token keyword">done</span>
<span class="token keyword">echo</span> <span class="token string">"binary ＄binnumorig is decimal ＄sum"</span>
　  该脚本使用的算法是利用十进制和二进制数权值 <span class="token punctuation">(</span>1,2,4,8,16,<span class="token punctuation">..</span><span class="token punctuation">)</span>，比如二进制<span class="token string">"10"</span>可以这样转换成十进制：
0 * 1 + 1 * 2 <span class="token operator">=</span> 2
　　为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。
    文件循环程序
　　或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的 脚本rotatefile可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，而对于outmail.1就变成了outmail.2 等等等等<span class="token punctuation">..</span>.
<span class="token comment">#!/bin/sh</span>
<span class="token comment"># vim: set sw=4 ts=4 et:</span>
ver<span class="token operator">=</span><span class="token string">"0.1"</span>
help<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
　　<span class="token function">cat</span> <span class="token operator">&lt;</span>
rotatefile -- rotate the <span class="token function">file</span> name
USAGE: rotatefile <span class="token punctuation">[</span>-h<span class="token punctuation">]</span> filename
OPTIONS: -h <span class="token function">help</span> text
EXAMPLE: rotatefile out
This will e.g <span class="token function">rename</span> out.2 to out.3, out.1 to out.2, out to out.1
and create an empty out-file
The max number is 10
version ＄ver
HELP
　　<span class="token keyword">exit</span> 0
<span class="token punctuation">}</span>
error<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
　　<span class="token keyword">echo</span> <span class="token string">"＄1"</span>
　　<span class="token keyword">exit</span> 1
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> -n <span class="token string">"＄1"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
<span class="token keyword">case</span> ＄1 <span class="token keyword">in</span>
　　-h<span class="token punctuation">)</span> <span class="token function">help</span><span class="token punctuation">;</span><span class="token function">shift</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span>
　　--<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
　　-*<span class="token punctuation">)</span> <span class="token keyword">echo</span> <span class="token string">"error: no such option ＄1. -h for help"</span><span class="token punctuation">;</span><span class="token keyword">exit</span> 1<span class="token punctuation">;</span><span class="token punctuation">;</span>
　　*<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
esac
<span class="token keyword">done</span>
<span class="token comment"># input check:</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"＄1"</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span> <span class="token keyword">then</span>
error <span class="token string">"ERROR: you must specify a file, use -h for help"</span>
<span class="token keyword">fi</span>
filen<span class="token operator">=</span><span class="token string">"＄1"</span>
<span class="token comment"># rename any .1 , .2 etc file:</span>
<span class="token keyword">for</span> n <span class="token keyword">in</span> 9 8 7 6 5 4 3 2 1<span class="token punctuation">;</span> <span class="token keyword">do</span>
　　<span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token string">"＄filen.＄n"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　　　p<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> ＄n + 1<span class="token variable">`</span></span>
　　　　<span class="token keyword">echo</span> <span class="token string">"mv ＄filen.＄n ＄filen.＄p"</span>
　　　　<span class="token function">mv</span> ＄filen.＄n ＄filen.＄p
　　<span class="token keyword">fi</span>
<span class="token keyword">done</span>
<span class="token comment"># rename the original file:</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> -f <span class="token string">"＄filen"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
　　<span class="token keyword">echo</span> <span class="token string">"mv ＄filen ＄filen.1"</span>
　　<span class="token function">mv</span> ＄filen ＄filen.1
<span class="token keyword">fi</span>
<span class="token keyword">echo</span> <span class="token function">touch</span> ＄filen
<span class="token function">touch</span> ＄filen
　　这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。
调试
　　最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。
　　shell也有一个真实的调试模式。如果在脚本<span class="token string">"strangescript"</span> 中有错误，您可以这样来进行调试：
sh -x strangescript
　　这将执行该脚本并显示所有变量的值。
　　shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：
sh -n your_script
　　这将返回所有语法错误。



</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
