<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>shell编程基础 « NotBeCN</title>
  <meta name="description" content="                      shell编程基础           变量与局部变量      特殊变量      变量，参数展开      字符串展开      变量的删除，取代与替换      输入输出-READ      输入输出-ECHO      输入输出-PRINTF      函数  ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/code527_90138107.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">shell编程基础</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <ul> 
   <li><a href="#shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" rel="nofollow">shell编程基础</a> 
    <ul> 
     <li><a href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" rel="nofollow">变量与局部变量</a></li> 
     <li><a href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F" rel="nofollow">特殊变量</a></li> 
     <li><a href="#%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8F%82%E6%95%B0%E5%B1%95%E5%BC%80" rel="nofollow">变量，参数展开</a></li> 
     <li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B1%95%E5%BC%80" rel="nofollow">字符串展开</a></li> 
     <li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%8C%E5%8F%96%E4%BB%A3%E4%B8%8E%E6%9B%BF%E6%8D%A2" rel="nofollow">变量的删除，取代与替换</a></li> 
     <li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-READ" rel="nofollow">输入输出-READ</a></li> 
     <li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-ECHO" rel="nofollow">输入输出-ECHO</a></li> 
     <li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-PRINTF" rel="nofollow">输入输出-PRINTF</a></li> 
     <li><a href="#%E5%87%BD%E6%95%B0" rel="nofollow">函数</a></li> 
     <li><a href="#%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD" rel="nofollow">逻辑判断</a></li> 
     <li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-IF" rel="nofollow">流程控制-IF</a></li> 
     <li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-FOR" rel="nofollow">流程控制-FOR</a></li> 
     <li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-WHILE" rel="nofollow">流程控制-WHILE</a></li> 
     <li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-UNTIL" rel="nofollow">流程控制-UNTIL</a></li> 
     <li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-CASE" rel="nofollow">流程控制-CASE</a></li> 
     <li><a href="#%E6%95%B0%E7%BB%84" rel="nofollow">数组</a></li> 
     <li><a href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C" rel="nofollow">数组操作</a></li> 
     <li><a href="#%E5%9F%BA%E7%A1%80%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88" rel="nofollow">基础正则表达式字符集合</a></li> 
     <li><a href="#sed%E5%B7%A5%E5%85%B7" rel="nofollow">sed工具</a></li> 
     <li><a href="#shell%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6" rel="nofollow">shell获取字符串长度</a></li> 
    </ul> </li> 
  </ul> 
  <h1><a id="shell_22"></a>shell编程基础</h1> 
  <h2><a id="_24"></a>变量与局部变量</h2> 
  <blockquote> 
   <p>变量的定义</p> 
   <pre><code class="prism language-sh">a=12
a=helloword
a=`pwd`
a=$a:a
</code></pre> 
  </blockquote> 
  <blockquote> 
   <p>局部变量</p> 
   <pre><code class="prism language-sh">local a=12
</code></pre> 
  </blockquote> 
  <blockquote> 
   <p>取消变量</p> 
   <pre><code class="prism language-sh">unset a
</code></pre> 
  </blockquote> 
  <blockquote> 
   <p>生成环境变量</p> 
   <pre><code class="prism language-sh">export
</code></pre> 
  </blockquote> 
  <h2><a id="_54"></a>特殊变量</h2> 
  <blockquote> 
   <p>位置变量</p> 
   <pre><code class="prism language-sh">$0: 		#获取当前执行shell脚本的文件名，还包括路径。
$n: 		#获取当前执行脚本的第n个参数，n=1...9,如果n大于9，则需要将n使用大括号括起来；
$*: 		#获取当前shell的所有参数，将所有命令行参数视为单个字符串，相当于“$1$2$3”;
$#: 		#得到执行当前脚本的参数个数；
$@: 		#获取最高程序所有参数，并保留参数之间的任何空白，相当于“$1” “$2” “$3”,这是将参数传给其他程序的最好办法
</code></pre> 
  </blockquote> 
  <blockquote> 
   <p>状态变量</p> 
   <pre><code class="prism language-sh">$?: 		#判断上一指令是否成功执行，0为成功，非零为不成功
$$: 		#去当前进程的pid
$!: 		#上一个指令的pid
</code></pre> 
  </blockquote> 
  <h2><a id="_74"></a>变量，参数展开</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">${parameter:-word} 	#如果变量未定义，则表达式的值为word。
${parameter:=word} 	#如果变量未定义，则设置变量的值为word，返回表达式的值也是word。
${parameter:?word} 	#用于捕捉由于未定义而导致的错误并推出程序。
${parameter:+word} 	#如果变量已经定义，返回word，也就是真。
${!prefix*}
${!prefix@} 				#prefix开头的变量
</code></pre> 
  </blockquote> 
  <h2><a id="_86"></a>字符串展开</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">${#parameter} 								#输出字符长的长度
${parameter:offset} 					#从第offset字符开始截取
${parameter:offset:length} 		#从offset字符开始截取，取length长度
${parameter#pattern} 					#从头删除最短匹配
${parameter##pattern} 				#最长
${parameter%pattern} 					#从尾删除最短
${parameter%%pattern} 				#从尾删除最长
${parameter/pattern/string} 	#第一个匹配被替换
${parameter//pattern/string} 	#全部匹配被替换
${parameter/#pattern/string} 	#字符串开头的替换
${parameter/%pattern/string} 	#字符串结尾的替换
${parameter..} ${parameter^^} #全部转换为小写、大写
${parameter,} ${parameter^}	 	#首字母转换为小写、大写
</code></pre> 
  </blockquote> 
  <h2><a id="_105"></a>变量的删除，取代与替换</h2> 
  <blockquote> 
   <table> 
    <thead> 
     <tr> 
      <th>变量设置方式</th> 
      <th>str没有设置</th> 
      <th>str为空字符串</th> 
      <th>str已设置为非空字符串</th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>var=${str-expr}</td> 
      <td>var=expr</td> 
      <td>var=</td> 
      <td>var=$str</td> 
     </tr> 
     <tr> 
      <td>var=${str:-expr}</td> 
      <td>var=expr</td> 
      <td>var=expr</td> 
      <td>var=$str</td> 
     </tr> 
     <tr> 
      <td>var=${str+expr}</td> 
      <td>var=</td> 
      <td>var=expr</td> 
      <td>var=expr</td> 
     </tr> 
     <tr> 
      <td>var=${str:+expr}</td> 
      <td>var=</td> 
      <td>var=</td> 
      <td>var=expr</td> 
     </tr> 
     <tr> 
      <td>var=${str=expr}</td> 
      <td>str=expr ; var=expr</td> 
      <td>str不变 ； var=</td> 
      <td>str不变 ；var=$str</td> 
     </tr> 
     <tr> 
      <td>var=${str:=expr}</td> 
      <td>str=expr ; var=expr</td> 
      <td>str=expr ; expr</td> 
      <td>str不变 ； var=$str</td> 
     </tr> 
     <tr> 
      <td>var=${str?expr}</td> 
      <td>expr 输出至 stderr</td> 
      <td>var=</td> 
      <td>var=$str</td> 
     </tr> 
     <tr> 
      <td>var=${str:?expr}</td> 
      <td>expr 输出至 stderr</td> 
      <td>expr 输出至 stderr</td> 
      <td>var=$str</td> 
     </tr> 
    </tbody> 
   </table>
  </blockquote> 
  <h2><a id="ulimit_121"></a>限制命令：ulimit</h2> 
  <blockquote> 
   <p>ulimit [-SHacdflltu] [配额]</p> 
   <pre><code class="prism language-bash">-H		<span class="token comment">#hard limit,严格的设置，必定不能超过这个设置的数值</span>
-S		<span class="token comment">#soft limit,警告的设置，可以超过这个设置值，但是超过则有警告信息</span>
-a		<span class="token comment">#后面不接任何选项与参数，可列出所有的限制额度</span>
-c		<span class="token comment">#当某些程序发生错误时，系统可能将程序在内存中的信息写成文件</span>
-f		<span class="token comment">#此shell 可以建立的最大文件容量，</span>
-d		<span class="token comment">#程序可以用的最大段内存</span>
-l		<span class="token comment">#可用于锁定(lock)的内存量</span>
-t		<span class="token comment">#可使用的最大CPU时间</span>
-u		<span class="token comment">#单一使用者可以使用的最大进程数量</span>
</code></pre> 
  </blockquote> 
  <h2><a id="read_137"></a>输入输出：read</h2> 
  <blockquote> 
   <p>read [-options] [variable]</p> 
   <pre><code class="prism language-sh">-a array 			#把输入赋值到array中，从索引号零开始
-d delimiter 	#用字符串deliiter中的第一个字符指示输入结束，而不是一个换行符
-e  					#使用readline来处理输入。这使得与命令行相同的方式编辑输入
-n num 				#读取num个输入字符，而不是整行
-p prompt 		#为输入显示提示信息， 使用字符串prompt
-r 						#Raw mode 不把反斜杠字符解释为转义字符
-s 						#Silent mode寂寞模式
-t seconds 		#超时
-u fd 				#使用文件描述符fd中的输入，而不是标准输入
</code></pre> 
  </blockquote> 
  <h2><a id="declare_155"></a>变量声明：declare</h2> 
  <blockquote> 
   <p>declare [-aixr] variable</p> 
   <pre><code class="prism language-bash">-a		<span class="token comment">#将后面名为 variable 的变量定义成为数组 (array) 类型</span>
-i		<span class="token comment">#将后面名为 variable 的变量定义成为整数 (integer) 类型</span>
-x 		<span class="token comment">#用法与 export 一样，就是将后面的 variable 变成环境变量</span>
-r		<span class="token comment">#将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset</span>
</code></pre> 
  </blockquote> 
  <h2><a id="echo_168"></a>输入输出：echo</h2> 
  <blockquote> 
   <p>echo string</p> 
   <pre><code class="prism language-sh">echo -e "Hello HaiZei\n" #开启转义
echo "Hello $name, This is HaiZei"
echo "\"Hello HaiZei\""
</code></pre> 
  </blockquote> 
  <h2><a id="printf_178"></a>输入输出：printf</h2> 
  <blockquote> 
   <pre><code class="prism language-bash"><span class="token function">printf</span> format-string <span class="token punctuation">[</span>arguments<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
  </blockquote> 
  <h2><a id="alias_184"></a>命令别名：alias</h2> 
  <blockquote> 
   <pre><code class="prism language-bash"><span class="token function">alias</span> rm<span class="token operator">=</span><span class="token string">'rm -i'</span>
</code></pre> 
  </blockquote> 
  <h2><a id="history_190"></a>历史命令：history</h2> 
  <blockquote> 
   <p>history [-option] histfiles</p> 
   <pre><code class="prism language-bash">n		<span class="token comment">#数字，意思是要列出最近的n条命令表的意思</span>
-c		<span class="token comment">#将目前的 shell 中的所有 history 内容全部清除</span>
-a		<span class="token comment">#将目前新增加的 history 命令新增入 histfiles 中，若没有加 histfiles，则默认写入～/bash history</span>
-r		<span class="token comment">#将 histfiles 的内容读到目前这个 shell 的 history 记录中</span>
-w		<span class="token comment">#将目前的 history 记录的内容写入 histfiles 中</span>
</code></pre> 
  </blockquote> 
  <h2><a id="_204"></a>函数定义</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">#!/bin/bash
function _printf_ {
    echo $1
    return 
}

_printf_() {
    echo $1
    return
}

</code></pre> 
  </blockquote> 
  <h2><a id="_221"></a>逻辑判断</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">
-b #如果文件存在并且是块特殊文件，则为True。
-c #如果文件存在且是字符特殊文件，则为True。
-d #如果文件存在并且是一个目录，则为。
-e #如果文件存在(无论类型)，则文件为True。
-f #如果文件存在并且是常规文件，则为-f文件True。
-g #如果文件存在并设置了它的set group ID标志，则该文件为True。
-h #如果文件存在且是符号链接，则-h文件为真。保留此操作符是为了与此程序的以前版本兼容。不依赖它的存在;使用-l。
-k #文件为真，如果文件存在，并且它的粘性位被设置。
-n #如果字符串的长度非零，则为-n字符串True。
-p #如果文件是命名管道(FIFO)，则为-p文件True。
-r #如果文件存在且可读，则为-r文件True。
-s #如果文件存在且大小大于零，则为-s文件True。
-t #file_descriptor如果文件描述符编号为file_descriptor的文件打开并与终端关联，则为。
-u #如果文件存在并且设置了它的设置用户ID标志，则该文件为True。
-w #如果文件存在且可写，则w文件为真。True仅指示写标志处于打开状态。该文件甚至不能在只读文件系统上写入如果测试结果为真。
-x #如果文件存在且可执行，则该文件为True。True仅指示执行标志处于打开状态。如果file是一个目录，则true表示该文件可以搜索。
-z #如果字符串的长度为0，则-z字符串为真。
-L #如果文件存在并且是符号链接，则为。
-O #如果文件存在且其所有者与此进程的有效用户id匹配，则文件为True。
-G #如果文件存在且其组与此进程的有效组id匹配，则为-G文件True。
-S #如果文件存在且是套接字，则为-S文件True。

file1 -nt file2 #如果file1存在并且比file2更新，则为True。

file1 -ot file2 #如果file1存在且大于file2，则为True。

file1 -ef file2 #如果file1和file2存在并引用同一文件，则为True。

string 				#如果字符串不是空字符串，则为True。
s1 = s2       #如果字符串s1和s2相同，则s1 = s2为真。
s1 != s2      #如果字符串s1和s2不相同，则s1 != s2为真。
s1 &lt; s2       #如果字符串s1根据字符的二进制值出现在s2之前，则s1 &lt; s2为真。
s1 &gt; s2       #如果字符串s1根据字符的二进制值位于s2之后，则s1 &gt; s2为真。
n1 -eq n2     #如果整数n1和n2在代数上相等，则n1 -eq n2为真。
n1 -ne n2     #如果整数n1和n2在代数上不相等，n1 -ne n2为真。
n1 -gt n2     #如果整数n1在代数上大于整数n2，则n1 -gt n2为真。
n1 -ge n2     #如果整数n1在代数上大于或等于整数n2，则n1 -ge n2为真。
n1 -lt n2     #如果整数n1在代数上小于整数n2，那么n1 -lt ln2为真。
n1 -le n2	  	#如果整数n1在代数上小于或等于整数n2，那么n1 -le ln2为真。
expression1 -a expression2 #如果表达式1和表达式2都为真，则为真。
expression1 -o expression2 #如果表达式1或表达式2为真，则为真。
-a 运算符的优先级高于 -o 运算符。
任务：
find . -name "*.c" | xargs cat -n a | wc -l
</code></pre> 
  </blockquote> 
  <h2><a id="if_274"></a>流程控制：if</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">#!/bin/bash
if [[ condition ]]; then
	#statements
fi

if [[ condition ]]; then
	#statements
	else
	#statements
fi

if [[ condition ]]; then
	#statements
elif [[ condition ]]; then
	#statements
elif [[ condition ]]; then
	#statements
	else
	#statements
fi
</code></pre> 
  </blockquote> 
  <h2><a id="for_300"></a>流程控制：for</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">for i in `seq 1 100`; do
	#statements
	break
	continue
done

for (( i = 0; i &lt; 10; i++ )); do
	#statements
done
</code></pre> 
  </blockquote> 
  <h2><a id="while_317"></a>流程控制：while</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">#!/bin/bash
while [[ condition ]]; do
	#statementd
done
</code></pre> 
  </blockquote> 
  <h2><a id="until_327"></a>流程控制：until</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">#!/bin/bash
until [[ conition ]]; do
	#statements
done
</code></pre> 
  </blockquote> 
  <h2><a id="case_337"></a>流程控制：case</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">#!/bin/bash
case word in
	pattern1 )
	程序段
		;;
	pattern2 )
	程序段
		;;
	*)
		exit 1
		;;
esac
</code></pre> 
  </blockquote> 
  <h2><a id="_355"></a>数组声明</h2> 
  <p>declare -a a</p> 
  <blockquote> 
   <pre><code class="prism language-sh">name[subscript]=value
name=[value1 value2 ...]
</code></pre> 
  </blockquote> 
  <h2><a id="_364"></a>数组操作</h2> 
  <blockquote> 
   <p>输出数组内容</p> 
   <pre><code class="prism language-sh">${arry[*]}
${arry[@]}
</code></pre> 
   <p>确定数组元素个数</p> 
   <pre><code class="prism language-sh">${#arry[@]}
</code></pre> 
   <p>找到数组的下标</p> 
   <pre><code class="prism language-sh">${!arry[@]}
</code></pre> 
   <p>数组追加</p> 
   <pre><code class="prism language-sh">arry+=(a b c)
</code></pre> 
   <p>数组排序</p> 
   <pre><code class="prism language-sh">sort
</code></pre> 
   <p>删除数组与元素</p> 
   <pre><code class="prism language-sh">unset
</code></pre> 
  </blockquote> 
  <h2><a id="_405"></a>基础正则表达式字符集合</h2> 
  <blockquote> 
   <table> 
    <thead> 
     <tr> 
      <th>RE字符</th> 
      <th>意义</th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>^word</td> 
      <td>待查找的字符串（word）在行首</td> 
     </tr> 
     <tr> 
      <td>word$</td> 
      <td>待查找的字符串（word）在行尾</td> 
     </tr> 
     <tr> 
      <td>.</td> 
      <td>代表【一定有一个任意字符】的字符</td> 
     </tr> 
     <tr> 
      <td>\</td> 
      <td>转义符，将特殊符号的特殊意义去除</td> 
     </tr> 
     <tr> 
      <td>*</td> 
      <td>重复零个到无穷多个的前一个RE字符</td> 
     </tr> 
     <tr> 
      <td>[list]</td> 
      <td>字符集合的RE字符，里面列出想要选取的字符</td> 
     </tr> 
     <tr> 
      <td>[n1-n2]</td> 
      <td>字符集合的RE字符，里面列出想要选取的字符范围</td> 
     </tr> 
     <tr> 
      <td>[^list]</td> 
      <td>字符集合的RE字符，里面列出不要的字符串或范围</td> 
     </tr> 
     <tr> 
      <td>{n,m}</td> 
      <td>连续n到m个的【前一个RE字符】</td> 
     </tr> 
    </tbody> 
   </table>
  </blockquote> 
  <h2><a id="sed_420"></a>命名工具：sed</h2> 
  <blockquote> 
   <pre><code class="prism language-sh">sed [-nefr]
-n : 使用安静（slient）模式，在一般sed的用法中，所有来自stdin的数据一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的哪一行（或操作）才会被列出来。
-e : 直接在命令行模式上进行sed的操作编辑
-f : 直接将sed操作写在一个文本内，-f filename则可以执行filename内的操作
-r : sed的操作使用的是扩展型正则表达式的语法
-i : 直接修改读取的文件内容
a  : 新增，a的后面可以接字符，而这些字符会在新的一行出现（目前的下一行）
c  : 替换，c的后面可以接字符，这些字符可以替换n1， n2之间的行
d  : 删除， 因为是删除，所以d后面通常不接任何东西
i  : 插入， i的后面可以接字符，而这些字符会出现在新一行出现（目前的上一行）
p  : 打印， 亦即将某个选择的数据打印出来，通常p会与参数sed -n 一起运行
s  : 替换， 可以直接进行替换的工作，通常这个s的操作可以搭配正则表达式，
</code></pre> 
  </blockquote> 
  <h2><a id="shell_438"></a>shell获取字符串长度</h2> 
  <blockquote> 
   <p>有时在Linux操作系统中需要计算某个字符串的长度，通过查询资料整理了下目前Shell中获取字符串的长度的多种方法，在这里分享给大家，方法如下：<br> 方法1: 使用wc -L命令<br> wc -L可以获取到当前行的长度，因此对于单独行的字符串可以用这个简单的方法获取，另外wc -l则是获取当前字符串内容的行数。</p> 
   <pre><code class="prism language-sh">echo "abc" |wc -L
</code></pre> 
   <p>方法2: expr length string<br> 使用expr length可以获取string的长度<br> 方法3: awk获取域的个数，但是如果大于10个字符的长度时是否存在问题需要后面确认<br> 复制代码 代码如下:</p> 
   <pre><code class="prism language-sh">echo "abc" |awk -F "" '{print NF}'
</code></pre> 
   <p>方法4: 通过awk+length的方式获取字符串长度<br> 复制代码 代码如下:</p> 
   <pre><code class="prism language-sh">echo “Alex”|awk '{print length($0)}'
</code></pre> 
   <p>方法5: 通过echo ${#string}的方式（注意：这里的string是该字符串的变量名）<br> 复制代码 代码如下:</p> 
   <pre><code class="prism language-sh">name=Alex
echo ${#name}
</code></pre> 
  </blockquote> 
  <h2><a id="test_472"></a>测试命令：test</h2> 
  <blockquote> 
   <p>1.关于某个文件名的【文件类型】判断，如test -e filename 表示存在否</p> 
   <pre><code class="prism language-bash">-e		<span class="token comment">#该文件名是否存在 （常用）</span>
-f		<span class="token comment">#该文件名是否存在且为文件（file）（常用）</span>
-d		<span class="token comment">#该文件名是否存在且为目录（directory）（常用）</span>
-b		<span class="token comment">#该文件名是否存在且为一个 block device 设备</span>
-c		<span class="token comment">#该文件名是否存在且为一个 character device 设备</span>
-S		<span class="token comment">#该文件名是否存在且为一个 socket 文件</span>
-p		<span class="token comment">#该文件名是否存在且为一个FIFO （pipe）文件</span>
-L		<span class="token comment">#该文件名是否存在且为一个链接文件</span>
</code></pre> 
   <p>2.关于文件的权限检测，如 test -r filename 表示可读否 （但root权限常有例外）</p> 
   <pre><code class="prism language-bash">-r		<span class="token comment">#检测文件名是否存在且具有【可读】的权限</span>
-w		<span class="token comment">#检测文件名是否存在且具有【可写】的权限</span>
-x		<span class="token comment">#检测文件名是否存在且具有【可执行】的权限</span>
-u		<span class="token comment">#检测文件名是否存在且具有【SUID】的属性</span>
-g		<span class="token comment">#检测文件名是否存在且具有【SGID】的属性</span>
-k		<span class="token comment">#检测文件名是否存在且具有【Sticky bt】的属性</span>
-s		<span class="token comment">#检测文件名是否存在且为【非空文件】</span>
</code></pre> 
   <p>3.两个文件之间的比较，如：test file1 -nt file2</p> 
   <pre><code class="prism language-bash">-nt		<span class="token comment">#(newer than) 判断 file1 是否比 file2 新</span>
-ot		<span class="token comment">#(older than) 判断 file1 是否比 file2 旧</span>
-ef		<span class="token comment">#判断 file1 与 file2 是否为同一个文件，可用在判断 hard link 的判定上。主要意义在判定，两个文件是否均指向同一个文件</span>
</code></pre> 
   <p>4.关于两个整数之间的判定，例如 test n1 - n2</p> 
   <pre><code class="prism language-bash">-eq		<span class="token comment">#两数值相等（equal）</span>
-ne		<span class="token comment">#两数值不相等（not equal）</span>
-gt		<span class="token comment">#n1 大于 n2 （greater than）</span>
-lt		<span class="token comment">#n1 小于 n2 （less than）</span>
-ge		<span class="token comment">#n1 大于等于 n2 （greater than or equal）</span>
-le		<span class="token comment">#n1 小于等于 n2 （less than or equal）</span>
</code></pre> 
   <p>5.判定字符串的数据</p> 
   <pre><code class="prism language-bash"><span class="token function">test</span> -z string		<span class="token comment">#判定字符串是否为 0？若 string 为空字符串，则为true</span>
<span class="token function">test</span> -n string		<span class="token comment">#判定字符串是否非为 0？若 string 为空字符串，则为true</span>
<span class="token function">test</span> str1 <span class="token operator">==</span> str2	<span class="token comment">#判定 str1 是否等于 str2，若相等，则为true</span>
<span class="token function">test</span> str1 <span class="token operator">!=</span> str2	<span class="token comment">#判定 str1 是否不等于 str2， 若相等，则返回false</span>
</code></pre> 
   <p>6.多重条件判断，</p> 
   <pre><code class="prism language-bash">-a		<span class="token comment">#(and) 两条件同时成立，</span>
-o		<span class="token comment">#(or) 两条件任何一个成立。</span>
<span class="token operator">!</span>		<span class="token comment">#反向状态。</span>
</code></pre> 
  </blockquote> 
  <h2><a id="__535"></a>判断符号：[ ]</h2> 
  <blockquote> 
   <ul> 
    <li>在中括号内的每个组件都需要空格来分隔</li> 
    <li>在中括号内的变量，最好都以双引号括起来</li> 
    <li>子啊中括号中常数，最好都以单或双引号括起来</li> 
   </ul> 
  </blockquote> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
