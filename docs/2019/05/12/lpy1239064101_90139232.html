<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>数据结构查找算法和排序算法java实现 « NotBeCN</title>
  <meta name="description" content="          本博客纯粹为了记录一下，方便自己回顾知识点。   一、查找算法：   查找算法较为简单，常用的主要有两种：顺序查找和二分查找   顺序查找：按数据存储的顺序进行遍历查找，对存储顺序没有要求，性能较低。   二分查找：也叫折半查找，求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/lpy1239064101_90139232.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">数据结构查找算法和排序算法java实现</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>本博客纯粹为了记录一下，方便自己回顾知识点。</p> 
  <h1 id="%E4%B8%80%E3%80%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%9A">一、查找算法：</h1> 
  <p>查找算法较为简单，常用的主要有两种：顺序查找和二分查找</p> 
  <p>顺序查找：按数据存储的顺序进行遍历查找，对存储顺序没有要求，性能较低。</p> 
  <p>二分查找：也叫折半查找，求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p> 
  <p>（1）顺序查找实现：</p> 
  <pre class="has">
<code class="language-java">/**
     * 顺序查找
     * @param array
     * @param value
     * @return
     */
    public static int search(int[] array, int value) {
        for (int i=0;i &lt;= array.length -1; i ++) {
            if (value == array[i])
                return i + 1;
        }

        return -1;
    }</code></pre> 
  <p>（2）二分查找实现</p> 
  <p style="text-indent:50px;">递归实现：</p> 
  <pre class="has">
<code class="language-java">    /**
     * 递归实现
     * @param array
     * @param value
     * @return
     */
    public static int biSearch2(int[] array, int value,int low, int high) {

        if (low &gt; high) {
            return -1;
        }

        int middle = (low + high)/2;

        if (array[middle] == value) {
            return middle + 1;
        } else if (array[middle] &lt; value) {
            return biSearch2(array, value, middle + 1, high);
        } else {
            return biSearch2(array, value, low, middle -1);
        }
    }</code></pre> 
  <p>非递归实现：</p> 
  <pre class="has">
<code class="language-java">    /**
     * 非递归实现
     * @param array
     * @param value
     * @return
     */
    public static int biSearch(int[] array, int value) {
        int low = 0;
        int high = array.length -1;
        int middle;

        while (low &lt;= high) {
            middle = (low + high)/2;
            if (array[middle] == value) {
                return middle + 1;
            }

            if (array[middle] &gt; value) {
                high = middle -1;
            } else {
                low = middle + 1;
            }
        }

        return -1;
    }</code></pre> 
  <p>测试demo:</p> 
  <pre class="has">
<code class="language-java">    public static void main(String[] args) {
        int[] array = {1, 4, 6, 8, 25, 46, 73, 89,99, 100};

        System.out.println("===================非递归实现=================");
        int i = biSearch(array, 25);
        System.out.println(i);
        System.out.println(array[i-1]);

        System.out.println("===================递归实现=================");
        int m = biSearch2(array, 25, 0, array.length-1);
        System.out.println(m);
        System.out.println(array[m-1]);

        System.out.println("===================顺序查找=================");
        int n = search(array, 25);
        System.out.println(n);
        System.out.println(array[n-1]);
    }</code></pre> 
  <h1 id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">二、排序算法</h1> 
  <p>常用排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等</p> 
  <p>（1）冒泡排序：</p> 
  <p>原理：比较两个相邻的元素，将值大的元素交换至右端，最终形成一个从小到大的序列，需要比较比较n-1次即可。</p> 
  <p>核心实现：</p> 
  <pre class="has">
<code class="language-java">   public static void sort(int[] array) {
        for (int i = 0; i &lt; array.length-1; i ++) {
            for (int j = 0; j &lt; array.length - i-1; j++) {
                if (array[j] &gt; array[j+1]) {
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }

        System.out.println("排序后的数组为：");
        for (int num : array) {
            System.out.print(" " + num);
        }
    }</code></pre> 
  <p>（2）直接选择排序：</p> 
  <p style="text-indent:50px;">原理：每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。（这里只介绍常用的简单选择排序）</p> 
  <p style="text-indent:50px;">基本思想：给定数组：int[] arr={里面n个数据}；第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arrr[1]交换；第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与r[2]交换；以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换， 直到全部排序完成。</p> 
  <p>核心实现：</p> 
  <pre class="has">
<code class="language-java">    public static void selectSort(int[] arr) {
        for (int i = 0; i &lt; arr.length - 1; i ++) {
            int k = i;
            for(int j = k + 1; j &lt; arr.length; j ++) {
                if (arr[j] &lt; arr[k]) {
                    k = j;//找出最小值的下标
                }
            }
            //交换最小值
            if (i != k) {
                int temp = arr[i];
                arr[i] = arr[k];
                arr[k] = temp;
            }
        }

        System.out.println("排序后的顺序：");
        for (int num : arr) {
            System.out.print(" " + num);
        }
    }</code></pre> 
  <p>（3）直接插入排序</p> 
  <p>原理：<br> &nbsp; &nbsp; &nbsp; 利用插入法对无序数组排序时，我们其实是将数组R划分成两个子区间R[1...i-1]（已排好序的有序区）和R[i...n]（当前未排序的部分，可称无序区）。插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，使R[1...i]变为新的有序区。因为这种方法每次使有序区增加1个记录，通常称增量法。<br> 核心实现：</p> 
  <pre class="has">
<code class="language-java">    public static void insertSort(int[] arr) {
        for (int index=1; index &lt; arr.length; index ++) {
            int temp = arr[index]; //用于比较的数据
            int leftIndex = index -1;

            while (leftIndex &gt;= 0 &amp;&amp; arr[leftIndex] &gt; temp) {
                arr[leftIndex+1] = arr[leftIndex];
                leftIndex --;
            }
            arr[leftIndex + 1] = temp;

        }

        System.out.println("排序后的数组：");
        for (int num : arr) {
            System.out.print(" " + num);
        }
    }</code></pre> 
  <p>（4）希尔排序</p> 
  <p>原理：</p> 
  <p>（1）希尔排序（shell sort）这个排序方法又称为缩小增量排序，是基于插入排序的优化。该方法的基本思想是：设待排序元素序列有n个元素，首先取一个整数increment（小于n）作为间隔将全部元素分为increment个子序列，所有距离为increment的元素放在同一个子序列中，在每一个子序列中分别实行直接插入排序。然后缩小间隔increment，重复上述子序列划分和排序工作。直到最后取increment=1，将所有元素放在同一个子序列中排序为止。&nbsp;<br> （2）由于开始时，increment的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期increment取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</p> 
  <p>increment（增量）的取法：</p> 
  <p>增量increment的取法有各种方案。最初shell提出取increment=n/2向下取整，increment=increment/2向下取整，直到increment=1。但由于直到最后一步，在奇数位置的元素才会与偶数位置的元素进行比较，这样使用这个序列的效率会很低。后来Knuth提出取increment=n/3向下取整+1.还有人提出都取奇数为好，也有人提出increment互质为好。应用不同的序列会使希尔排序算法的性能有很大的差异。</p> 
  <p>核心实现：</p> 
  <pre class="has">
<code class="language-java">    public static void shellSort(int[] array) {
        //初始化间隔
        int h = 1;
        //计算最大间隔
        while (h &lt; array.length/3) {
            h = h * 3 + 1;
        }

        while (h &gt; 0) {
            //进行插入排序
            for (int index=h; index &lt; array.length; index ++) {
                int temp = array[index]; //用于比较的数据
                int leftIndex = index;

                while (leftIndex &gt;= h &amp;&amp; array[leftIndex - h] &gt; temp) {
                    array[leftIndex] = array[leftIndex - h];
                    leftIndex -=h;
                }
                array[leftIndex] = temp;
            }

            //减小间隔
            h = (h - 1)/3;
        }

        //打印排序后数组
        System.out.println("排序后数组：");
        for(int a : array) {
            System.out.print(a + " ");
        }
    }</code></pre> 
  <p>（5）快速排序</p> 
  <p>思想：基于分治的思想，是冒泡排序的改进型。首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率），然后分别从数组的两端扫描数组，设两个指示标志（left指向起始位置，right指向末尾)，首先从后半部分开始，如果发现有元素比该基准点的值小，就交换left和right位置的值，然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换left和right位置的值，如此往复循环，直到left&gt;=right然后把基准点的值放到right这个位置。一次排序就完成了。以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</p> 
  <p>算法分两步，</p> 
  <p>1. 数组划分</p> 
  <pre class="has">
<code class="language-java">    /**
     * 划分区域
     * @param arr
     * @param left
     * @param right
     * @param point
     * @return
     */
    public static int partition(long arr[],int left, int right,long point) {
        int leftPtr = left - 1;
        int rightPtr = right;
        while(true) {
            //做基准点左侧数据处理
            while(leftPtr &lt; rightPtr &amp;&amp; arr[++leftPtr] &lt; point);
            //对基准点右侧处理
            while(rightPtr &gt; leftPtr &amp;&amp; arr[--rightPtr] &gt; point);
            if(leftPtr &gt;= rightPtr) {
                break;
            } else {
                long tmp = arr[leftPtr];
                arr[leftPtr] =  arr[rightPtr];
                arr[rightPtr] = tmp;
            }
        }
        //
        long tmp = arr[leftPtr];
        arr[leftPtr] =  arr[right];
        arr[right] = tmp;
        return leftPtr;
    }</code></pre> 
  <p>2. 分区排序：</p> 
  <pre class="has">
<code class="language-java">    public static void sort(long[] arr, int left, int right) {
        if(right - left &lt;= 0) {
            return;
        } else {
            //选择基准点
            long point = arr[right];
            //划分区域
            int partition = partition(arr, left, right, point);
            //对左侧排序
            sort(arr,left,partition - 1);
            //对右侧排序
            sort(arr,partition + 1, right);
        }
    }</code></pre> 
  <p>&nbsp;这个算法可以继续进行优化，定点进行划分性能不是最高</p> 
  <p>（6）归并排序</p> 
  <p>原理：归并排序利用的是分治的思想实现。对于给定一组数据，利用递归与分治技术将数据序列划分成为越来越小的子序列，之后对子序列排序，最后再用递归方法将排好序的子序列合并成为有序序列。合并两个子序列时，需要申请两个子序列加起来长度的内存，临时存储新的生成序列，再将新生成的序列赋值到原数组相应的位置。<br> 核心代码：</p> 
  <pre class="has">
<code class="language-java">public static void main(String[] args) {
        int[] arr  = new int[10];
        for(int i = 0; i &lt; 10;i++) {
            arr[i] = (int) (Math.random() * 99);
        }

        displayArr(arr);

        mergeSort(arr, 0, arr.length - 1);

        displayArr(arr);
    }

    public static void displayArr(int[] arr) {
        System.out.print("[");
        for(int num : arr) {
            System.out.print(num + " ");
        }
        System.out.print("]");
        System.out.println();
    }

    public static void mergeSort(int[] arr,int left,int right){

        if(left&lt;right){
            int mid = (left+right)/2;
            mergeSort(arr,left,mid);//左边归并排序，使得左子序列有序
            mergeSort(arr,mid+1,right);//右边归并排序，使得右子序列有序
            merge(arr,left,mid,right);//合并两个子序列
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        //申请一个与原数组大小相同的数组
        int[] temp = new int[right - left + 1];
        int i = left;
        int j = mid+1;
        int k = 0;

        while(i&lt;=mid&amp;&amp;j&lt;=right){
            if (arr[i] &lt; arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        while(i&lt;=mid){//将左边剩余元素填充进temp中
            temp[k++] = arr[i++];
        }
        while(j&lt;=right){//将右序列剩余元素填充进temp中
            temp[k++] = arr[j++];
        }
        //将temp中的元素全部拷贝到原数组中
        for (int k2 = 0; k2 &lt; temp.length; k2++) {
            arr[k2 + left] = temp[k2];
        }
    }</code></pre> 
  <p>（7）堆排序</p> 
  <p>&nbsp;堆排序需要用到一种被称为最大堆的数据结构，与java或者lisp的gc不一样，这里的堆是一种数据结构，他可以被视为一种完全二叉树，即树里面除了最后一层其他层都是填满的。也正是因为这样，树里面每个节点的子女和双亲节点的序号都可以根据当前节点的序号直接求出。</p> 
  <p>（8）基数排序</p> 
  <p>思想：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br> 做法：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p> 
  <p>参考：<a href="https://www.cnblogs.com/skywang12345/p/3603669.html" rel="nofollow">基数排序</a></p> 
  <p>核心实现：</p> 
  <pre class="has">
<code class="language-java">public static void main(String[] args) {
        int[] array  = new int[10];
        for(int i = 0; i &lt; 10;i++) {
            array[i] = (int) (Math.random() * 999);
        }
        displayArr(array);
        radixSort(array);    // 基数排序
        displayArr(array);
    }

    /**
    * 基数排序
    *
    * 参数说明：
     *     a -- 数组
    */
    public static void radixSort(int[] a) {
        int exp;    // 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；
        int max = getMax(a);    // 数组a中的最大值

        // 从个位开始，对数组a按"指数"进行排序
        for (exp = 1; max/exp &gt; 0; exp *= 10)
            countSort(a, exp);
    }

    /**
     * 对数组按照"某个位数"进行排序(桶排序)
     * 参数说明：
     *     a -- 数组
     *     exp -- 指数。对数组a按照该指数进行排序。
     *    当exp=1表示按照"个位"对数组a进行排序
     *    当exp=10表示按照"十位"对数组a进行排序
     *    当exp=100表示按照"百位"对数组a进行排序
     *    ...
     */
    private static void countSort(int[] a, int exp) {
        int[] output = new int[a.length];    // 存储"被排序数据"的临时数组
        int[] buckets = new int[10];

        // 将数据出现的次数存储在buckets[]中
        for (int i = 0; i &lt; a.length; i++)
            buckets[ (a[i]/exp)%10 ]++;

        // 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。
        for (int i = 1; i &lt; 10; i++)
            buckets[i] += buckets[i - 1];

        // 将数据存储到临时数组output[]中
        for (int i = a.length - 1; i &gt;= 0; i--) {
            output[buckets[ (a[i]/exp)%10 ] - 1] = a[i];
            buckets[ (a[i]/exp)%10 ]--;
        }

        // 将排序好的数据赋值给a[]
        for (int i = 0; i &lt; a.length; i++)
            a[i] = output[i];

        output = null;
        buckets = null;
    }

    /*
     * 获取数组a中最大值
     * 参数说明：
     *     a -- 数组
     */
    private static int getMax(int[] a) {
        int max= a[0];
        for (int i = 1; i &lt; a.length; i++)
            if (a[i] &gt; max) max = a[i];
        return max;
    }</code></pre> 
  <p>稳定排序和不稳定排序：</p> 
  <ol>
   <li>稳定排序：排序前后两个相等的数相对位置不变，则算法稳定。有冒泡排序、插入排序、归并排序和基数排序</li> 
   <li>非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定。有选择排序、快速排序、希尔排序、堆排序</li> 
  </ol>
  <p>算法对比：</p> 
  <p><img alt="" class="has" height="286" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512190250982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xweTEyMzkwNjQxMDE=,size_16,color_FFFFFF,t_70" width="600"></p> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
