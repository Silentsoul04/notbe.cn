<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>java三年面试题（设计模式篇）不定期更新 « NotBeCN</title>
  <meta name="description" content="                  java三年面试题（设计模式篇）不定期更新   1. 什么是设计模式 ？   设计模式不是软件工程的专属名词，实际上设计模式是从建筑学引申到软件工程的。建筑学中研究将一个庭院设计的更美观，形成了一些公认的规范和标准，称之为设计模式。软件工程将其引申到软件设计上，旨在设计出更加美...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/zjltju1203_90124709.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">java三年面试题（设计模式篇）不定期更新</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="java_0"></a>java三年面试题（设计模式篇）不定期更新</h1> 
  <h4><a id="1___1"></a>1. 什么是设计模式 ？</h4> 
  <p>设计模式不是软件工程的专属名词，实际上设计模式是从建筑学引申到软件工程的。建筑学中研究将一个庭院设计的更美观，形成了一些公认的规范和标准，称之为设计模式。软件工程将其引申到软件设计上，旨在设计出更加美观，可维护更强的软件。</p> 
  <h4><a id="2_4"></a>2.工厂模式和抽象模式有什么区别？</h4> 
  <p>这两种设计模式主要的区别在于产品，工厂模式是用来创建同一个产品的不同类型的，但是抽象工厂模式是用来创建不同类的产品，一般来说，产品种类单一，适合用工厂模式；如果有多个种类，各种类型时，通过抽象工厂模式来进行创建是很合适的。</p> 
  <h4><a id="3_7"></a>3.面向对象设计原则有那些？</h4> 
  <ol> 
   <li> <p>单一职责原则SRP（Single Responsibility Principle）</p> </li> 
   <li> <p>开放-关闭原则OCP（Open-Closed Principle）<br> 所谓开放一关闭原则，指的是，一个类应该对扩展开放，对修改关闭。</p> </li> 
   <li> <p>里氏替换原则LSP（Liskov Substitution Principle）<br> 所谓里氏替换原则，指的是，子类型必须能够替换掉它们的父类型。</p> </li> 
   <li> <p>依赖倒置原则DIP（Dependence Inversion Principle）<br> 所谓依赖倒置原则，指的是，要依赖于抽象，不要依赖于具体类。</p> </li> 
   <li> <p>接口隔离原则ISP（Interface Segregation Principle）<br> 所谓接口隔离原则，指的是，不应该强迫客户依赖于他们不用的方法。</p> </li> 
   <li> <p>最少知识原则LKP（Least Knowledge Principle）<br> 所谓最少知识原则，指的是，只和你的朋友谈话。</p> </li> 
   <li> <p>其他原则<br> ■　面向接口编程；</p> <p>■　优先使用组合，而非继承。</p> <p>■　一个类需要的数据应该隐藏在类的内部；</p> <p>■　类之间应该零耦合，或者只有传导耦合，换句话说，类之间要么没有关系，要么只使用另一个类的接口提供的操作；</p> <p>■　在水平方向上尽可能统一地分布系统功能；</p> </li> 
  </ol> 
  <h4><a id="4_32"></a>4.简要概括各个设计模式？</h4> 
  <p>简单工厂的本质是：选择实现。<br> 外观模式的本质是：封装交互，简化调用。<br> 适配器模式的本质是：转换匹配，复用功能<br> 单例模式的本质：控制实例数目。<br> 工厂方法模式的本质：延迟到子类来选择实现。<br> 抽象工厂模式的本质：选择产品簇的实现。<br> 生成器模式的本质：分离整体构建算法和部件构造。<br> 原型模式的本质：克隆生成对象。<br> 中介者模式的本质：封装交互。<br> 代理模式的本质：控制对象访问。<br> 观察者模式的本质：触发联动。<br> 命令模式的本质：封装请求。<br> 迭代器模式的本质：控制访问聚合对象中的元素。<br> 组合模式的本质：统一叶子对象和组合对象。<br> 模板方法模式的本质：固定算法骨架。<br> 策略模式的本质：分离算法，选择实现。<br> 状态模式的本质：根据状态来分离和选择行为。<br> 备忘录模式的本质：保存和恢复内部状态。<br> 享元模式的本质：分离与共享。<br> 解释器模式的本质：分离实现，解释执行。<br> 装饰模式的本质：动态组合。<br> 职责链模式的本质：分离职责，动态组合。<br> 桥接模式的本质：分离抽象和实现。<br> 访问者模式的本质：预留通路，回调实现。</p> 
  <h4><a id="5_58"></a>5.适配器优缺点？</h4> 
  <p>适配器模式有如下优点：<br> ■　更好的复用性<br> 如果功能是已经有了的，只是接口不兼容，那么通过适配器模式就可以让这些功能得到更好的复用。<br> ■　更好的可扩展性<br> 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</p> 
  <p>适配器模式有如下缺点：<br> ■　过多地使用适配器，会让系统非常零乱，不容易整体进行把握。</p> 
  <h4><a id="6_67"></a>6.工厂模式优缺点？</h4> 
  <p>工厂方法模式的优点：<br> ■　可以在不知具体实现的情况下编程<br> ■　更容易扩展对象的新版本<br> ■　连接平行的类层次</p> 
  <p>工厂方法模式的缺点：<br> ■　具体产品对象和工厂方法的耦合性。<br> 在工厂方法模式中，工厂方法是需要创建产品对象的，也就是需要选择具体的产品对象，并创建它们的实例，因此具体产品对象和工厂方法是耦合的。</p> 
  <h4><a id="7_77"></a>7.抽象工厂的优缺点？</h4> 
  <p>抽象工厂模式的优点：<br> ■　分离接口和实现<br> ■　使得切换产品簇变得容易</p> 
  <p>抽象工厂模式的缺点：<br> ■　不太容易扩展新的产品<br> ■　容易造成类层次复杂</p> 
  <h4><a id="8_86"></a>8.观察者模式的优缺点</h4> 
  <p>观察者模式具有以下优点：<br> ■　观察者模式实现了观察者和目标之间的抽象耦合<br> ■　观察者模式实现了动态联动<br> ■　观察者模式支持广播通信</p> 
  <p>观察者模式的缺点是：<br> ■　可能会引起无谓的操作</p> 
  <p>由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法，如果观察者不需要执行相应处理，那么这次操作就浪费了。其实浪费了还好，最怕引起误更新，那就麻烦了，比如，本应该在执行这次状态更新前把某个观察者删除掉，这样通知的时候就没有这个观察者了，但是现在忘掉了，那么就会引起误操作。</p> 
  <h4><a id="9__97"></a>9. 策略模式的优缺点</h4> 
  <p>策略模式有以下优点：<br> ■　定义一系列算法<br> ■　避免多重条件语句<br> ■　更好的扩展性</p> 
  <p>策略模式有以下缺点：<br> ■　客户必须了解每种策略的不同<br> ■　增加了对象数目<br> ■　只适合扁平的算法结构</p> 
  <h4><a id="10　_109"></a>10.　装饰模式的优缺点</h4> 
  <p>装饰模式有以下优点：<br> ■　比继承更灵活<br> ■　更容易复用功能<br> ■　简化高层定义</p> 
  <p>装饰模式的缺点是：<br> 会产生很多细粒度对象。</p> 
  <h4><a id="11　_119"></a>11.　为什么使用桥接模式？</h4> 
  <p>■　分离抽象和实现部分</p> 
  <p>■　更好的扩展性</p> 
  <p>■　可动态地切换实现</p> 
  <p>■　可减少子类的个数</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
