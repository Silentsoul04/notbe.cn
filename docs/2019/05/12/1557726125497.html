<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>python基础教程：内置函数（一） « NotBeCN</title>
  <meta name="description" content="         Python解释器内置了很多函数和类型，可以随时随地在编程中使用。其实，我们在前面的学习中已经接触过好多内置函数。      这里把它们总结成下面的表格，方便我们学习它们的使用：      说明： 上面这个表格包含的有“内置函数”和“内置类型”，其中的内置类型可以作为函数使用，把其它类型的对象转...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726125497.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">python基础教程：内置函数（一）</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>Python解释器内置了很多函数和类型，可以随时随地在编程中使用。其实，我们在前面的学习中已经接触过好多内置函数。</p> 
  <p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/13090773-e8870d3033b01ab1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp"></p> 
  <p>这里把它们总结成下面的表格，方便我们学习它们的使用：</p> 
  <p><img alt="" class="has" src="//upload-images.jianshu.io/upload_images/13090773-188d3299f35fbfd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/729/format/webp"></p> 
  <p><strong>说明：</strong><br> 上面这个表格包含的有“内置函数”和“内置类型”，其中的内置类型可以作为函数使用，把其它类型的对象转变为该类型的对象。比如<code>int</code>是一个内置类型，<code>int('123')</code>就是把字符串转换成整数。两者在使用上没有什么区别，官方文档中也是把内置类型当做内置函数介绍的。</p> 
  <p><img alt="" class="has" height="72" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512142308820.png" width="287"></p> 
  <p>通过ipython，我们可以查看表格中的是函数还是类型。比如：</p> 
  <pre class="has">
<code>In [14]: abs?
Signature: abs(x, /)
Docstring: Return the absolute value of the argument.
Type:      builtin_function_or_method

In [15]: int?
Init signature: int(self, /, *args, **kwargs)
Docstring:     
int(x=0) -&gt; integer
int(x, base=10) -&gt; integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10\.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
&gt;&gt;&gt; int('0b100', base=0)
4
Type:           type
Subclasses:     bool, IntEnum, IntFlag, _NamedIntConstant

</code></pre> 
  <p>在ipython里面通过问号<code>?</code>来查看其对应的说明，其中的<code>Type</code>就是它的类型，可以看到<code>abs</code>是一个内置函数<code>builtin_function_or_method</code>，而<code>int</code>是一个类型<code>type</code>。</p> 
  <p>我们把这些内置函数（类型）分成几类进行介绍。</p> 
  <h2>数值型操作</h2> 
  <p><strong>abs(x)</strong><br> 求x的绝对值。x可以是整数或浮点数，如果是复数则返回它的模。</p> 
  <p><strong>bin(x)</strong><br> 将一个整数转变为一个前缀为<code>0b</code>的二进制字符串。结果是一个合法的 Python 表达式。如果 x 不是 Python 的 int 对象，那它需要定义 <strong>index</strong>() 方法返回一个整数。比如：</p> 
  <pre class="has">
<code>In [26]: bin(5)
Out[26]: '0b101'

In [27]: bin(-5)
Out[27]: '-0b101'

</code></pre> 
  <p>x 不能是浮点数，否则会报错。<br> 还可以通过<code>format()</code>函数来进行转换：</p> 
  <pre class="has">
<code>In [30]: format(5, '#b')
Out[30]: '0b101'

In [31]: format(5, 'b')
Out[31]: '101'

</code></pre> 
  <p>还可以用<code>f-string</code>格式化来转换：</p> 
  <pre class="has">
<code>In [32]: f'{5:#b}'
Out[32]: '0b101'

In [33]: f'{5:b}'
Out[33]: '101'

</code></pre> 
  <p><strong>chr(i)</strong><br> 返回 Unicode 码位为整数 i 的字符的字符串格式。例如，chr(97) 返回字符串 ‘a’，chr(20013) 返回字符串 ‘中’。这是 ord() 的逆函数。</p> 
  <p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 i 超过这个范围，会触发 ValueError 异常。</p> 
  <p><strong>divmod(a, b)</strong><br> 它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是 (q, a % b) ，q 通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b 和 a 基本相等；如果 a % b 非零，它的符号和 b 一样，并且 0 &lt;= abs(a % b) &lt; abs(b) 。</p> 
  <p><strong><code>format(value[, format_spec])</code></strong><br> 将 value 转换为 format_spec 控制的“格式化”表示。</p> 
  <p><strong>hex(x)</strong><br> 将整数转换为以“0x”为前缀的小写十六进制字符串。如果 x 不是 Python int 对象，则必须定义返回整数的 <strong>index</strong>() 方法。</p> 
  <p><strong>oct(x)</strong><br> 将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 x 不是 Python 的 int 对象，那它需要定义 <strong>index</strong>() 方法返回一个整数。</p> 
  <p><strong>ord(c)</strong><br> 对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 ord(‘a’) 返回整数 97， ord(‘€’) （欧元符合）返回 8364 。这是 chr() 的逆函数。</p> 
  <p><strong>pow(x, y[, z])</strong><br> 返回 x 的 y 次幂；如果 z 存在，则对 z 取余（比直接 pow(x, y) % z 计算更高效）。两个参数形式的 pow(x, y) 等价于幂运算符： <code>x**y</code>。</p> 
  <p><strong>round(number[, ndigits])</strong><br> 返回精确到小数点后ndigits精度的数。 如果省略ndigits或者为None，则返回其输入的最接近的整数。</p> 
  <p>对于支持round()的内置类型，值被舍入离前一位更近的一端（四舍六入）; 如果距离两端相等（5）则保留到偶数一边。（例如，round(0.5)和round(-0.5)均为0，round(1.5)为2）。 任何整数值对ndigits（正数，零或负数）有效。如果省略ndigits或None，则返回值为整数。 否则返回值与number的类型相同。</p> 
  <p>对于一般的Python对象number，将代理舍入为<code>number.__round__</code>。</p> 
  <p><strong>注释：</strong> round()对于浮点数的行为可能令人惊讶，比如，<code>round(2.675, 2)</code>得出<code>2.67</code>，而不是期望的<code>2.68</code>。这不是bug，这是因为大多数十进制小数不能准确表示为二进制的浮点数。</p> 
  <p><strong>sum(iterable[, start])</strong></p> 
  <p>从<code>start</code>开始由左到右累加可迭代的元素并返回总数。start默认为0. iterable的项通常是数字，起始值不允许是字符串。</p> 
  <p>对于某些用例，sum()有很好的替代方法。 连接字符串序列的首选快速方法是调用<code>''.join(sequence)</code>。 要以扩展精度累加浮点值，就用<code>math.fsum()</code>。要拼接一系列可迭代对象就考虑使用<code>itertools.chain()</code>。</p> 
  <h2>可迭代操作</h2> 
  <p><strong>all(iterable), any(iterable)</strong><br> 这两个函数，我们在前面学习list、dict等数据结构时已经多次学习。<br> all()： 如果iterable的所有元素都为真（或iterable为空）返回<code>True</code>；等价于：</p> 
  <pre class="has">
<code>def all(iterable):
    for item in iterable:
        if not item:
            return False
    return True

</code></pre> 
  <p>any()：如果iterable的任一个元素为真则返回<code>True</code>。如果iterable为空，则返回<code>False</code>。等价于：</p> 
  <pre class="has">
<code>def any(iterable):
    for item in iterable:
        if item:
        return True
    return False

</code></pre> 
  <p><strong>enumerate(iterable, start=0)</strong><br> 返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。 enumerate() 返回的迭代器的 <strong>next</strong>() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。</p> 
  <pre class="has">
<code>In [4]: ll = ['a', 'b', 'c', 'd']

In [5]: list(enumerate(ll))
Out[5]: [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]

In [6]: list(enumerate(ll, start=1))
Out[6]: [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]

</code></pre> 
  <p>等价于:</p> 
  <pre class="has">
<code>def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1

</code></pre> 
  <p><strong>filter(function, iterable)</strong><br> 用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器。iterable 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 function 是 None ，则会假设它是一个身份函数，即 iterable 中所有返回假的元素会被移除。</p> 
  <p>请注意， filter(function, iterable) 相当于一个生成器表达式，当 function 不是 None 的时候为 (item for item in iterable if function(item))；function 是 None 的时候为 (item for item in iterable if item) 。<br> 只有 function 返回 false 时才选取 iterable 中元素的补充函数。</p> 
  <p><strong>map(function, iterable, …)</strong><br> 产生一个将 function 应用于迭代器中所有元素并返回结果的迭代器。如果传递了额外的 iterable 实参，function 必须接受相同个数的实参，并使用所有迭代器中并行获取的元素。当有多个迭代器时，最短的迭代器耗尽则整个迭代结束。如果函数的输入已经是元组实参，请参阅 itertools.starmap()。</p> 
  <p><strong><code>zip(*iterables)</code></strong><br> 创建一个聚合来自每个可迭代的元素的迭代器。</p> 
  <p>返回元组的迭代器，其中第i个元组包含来自每个参数序列或迭代的第i个元素。当最短输入可迭代用尽时，迭代器停止。使用单个iterable参数，它返回一个1元组的迭代器。没有参数，它返回一个空迭代器。相当于：</p> 
  <pre class="has">
<code>def zip(*iterables):
    # zip('ABCD', 'xy') --&gt; Ax By
    sentinel = object()
    iterators = [iter(it) for it in iterables]
    while iterators:
        result = []
        for it in iterators:
            elem = next(it, sentinel)
            if elem is sentinel:
                return
            result.append(elem)
        yield tuple(result)

</code></pre> 
  <p>保证了迭代的从左到右的评估顺序。 这使得使用<code>zip(*[iter(s)]*n)</code>将数据系列聚类成n长度组的习惯成为可能。这会重复相同的迭代器n次，以便每个输出元组具有n次调用迭代器的结果。这具有将输入分成n长度块的效果。</p> 
  <p>当你不关心较长迭代的尾随，不匹配的值时，zip()只应与不等长度输入一起使用。如果这些值很重要，请改用<code>itertools.zip_longest()</code>。</p> 
  <p>zip()与<code>*</code>运算符一起用于解压缩列表：</p> 
  <pre class="has">
<code>In [80]: a = [1, 2, 3]

In [81]: b = ['a', 'b', 'c']

In [82]: zipped = zip(a, b)

In [83]: list(zipped)
Out[83]: [(1, 'a'), (2, 'b'), (3, 'c')]

In [84]: a2, b2 = zip(*zip(a, b))

In [85]: a == list(a2) and b == list(b2)
Out[86]: True

</code></pre> 
  <p><strong><code>max(iterable, *[, key, default])</code></strong><br> *<em>max(arg1, arg2, <em>args[, key])</em></em><br> 返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p> 
  <p>如果只提供了一个位置参数，它必须是非空 iterable，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p> 
  <p>有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。default 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则会触发 ValueError。</p> 
  <p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 sorted(iterable, key=keyfunc, reverse=True)[0] 和 heapq.nlargest(1, iterable, key=keyfunc) 保持一致。</p> 
  <p><strong><code>min(iterable, *[, key, default])</code></strong><br><strong><code>min(arg1, arg2, *args[, key])</code></strong><br> 返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p> 
  <p>如果只提供了一个位置参数，它必须是 iterable，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p> 
  <p>有两个可选只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。default 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则会触发 ValueError。</p> 
  <p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 sorted(iterable, key=keyfunc)[0] 和 heapq.nsmallest(1, iterable, key=keyfunc) 保持一致。</p> 
  <p><strong>reversed(seq)</strong><br> 返回反向迭代器。seq必须是一个具有<strong>reversed</strong>()方法的对象，或者支持序列协议（<strong>len</strong>()方法和<strong>getitem</strong>()方法，整数参数从0开始）。</p> 
  <p><strong><code>sorted(iterable, *, key=None, reverse=False)</code></strong></p> 
  <p>从iterable中的项返回一个新的排序列表。</p> 
  <p>有两个可选参数，必须指定为关键字参数。</p> 
  <p>key指定一个参数的函数，该函数用于从iterable中的每个元素中提取比较键（例如，key = str.lower）。默认值为None（直接比较元素）。</p> 
  <p>reverse是一个布尔值。 如果设置为True，则列表元素将按照每个比较相反的方式进行排序。</p> 
  <p>使用functools.cmp_to_key（）将旧式cmp函数转换为键函数。</p> 
  <p>内置的sorted()函数保证稳定。 如果排序保证不改变比较相等的元素的相对顺序，则排序是稳定的 – 这有助于多次传递排序（例如，按部门排序，然后按工资等级排序）。</p> 
  <p><strong>iter(object[, sentinel])</strong><br> 返回一个 iterator 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，object 必须是支持迭代协议（有 <strong>iter</strong>() 方法）的集合对象，或必须支持序列协议（有 <strong>getitem</strong>() 方法，且数字参数从 0 开始）。如果它不支持这些协议，会触发 TypeError。如果有第二个实参 sentinel，那么 object 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <strong>next</strong>() 方法时都会不带实参地调用 object；如果返回的结果是 sentinel 则触发 StopIteration，否则返回调用结果。</p> 
  <p><strong>next(iterator[, default])</strong><br> 通过调用 iterator 的 <strong>next</strong>() 方法获取下一个元素。如果迭代器耗尽，则返回给定的 default，如果没有默认值则触发 StopIteration。</p> 
  <h2>内置类型</h2> 
  <p>class <strong>bool([x])</strong><br> 说明：在文档中，函数的参数用方括号<code>[]</code>括起来表示这个参数可有可无（在参数列表中）。<br> 内置类型，返回一个布尔值：<code>True</code>或者<code>False</code>。<code>x</code>使用标注的真值测试过程来转换，关于真值测试的知识可以再回顾一下前面我们关于布尔值的章节。<br><code>bool</code>类是<code>int</code>的子类，这个bool类很特别，它不能被继承，且只有<code>True</code>和<code>False</code>两个实例。</p> 
  <p>class <strong>bytearray([source[, encoding[, errors]]])</strong><br> 返回一个新的 bytes 数组。 bytearray 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，同时有 bytes 类型的大部分方法。<br> 可选形参 source 可以用不同的方式来初始化数组：</p> 
  <p>如果是一个 string，您必须提供 encoding 参数（errors 参数仍是可选的）；bytearray() 会使用 str.encode() 方法来将 string 转变成 bytes。</p> 
  <ul>
   <li>如果是一个 integer，会初始化大小为该数字的数组，并使用 null 字节填充。</li> 
   <li>如果是一个符合 buffer 接口的对象，该对象的只读 buffer 会用来初始化字节数组。</li> 
   <li>如果是一个 iterable 可迭代对象，它的元素的范围必须是 0 &lt;= x &lt; 256 的整数，它会被用作数组的初始内容。</li> 
  </ul>
  <p>如果没有实参，则创建大小为 0 的数组。</p> 
  <p>class <strong>bytes([source[, encoding[, errors]]])</strong><br> 返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。bytes 是 bytearray 的不可变版本 – 它有其中不改变序列的方法和相同的索引、切片操作。</p> 
  <p>因此，构造函数的实参和 bytearray() 相同。</p> 
  <p>class <strong>complex([real[, imag]])</strong><br> 返回值为 <code>real + imag*1j</code> 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 imag，则默认值为零，构造函数会像 int 和 float 一样进行数值转换。如果两个实参都省略，则返回 0j。</p> 
  <p><em>注解</em> 当从字符串转换时，字符串在 + 或 – 的周围必须不能有空格。例如 complex(‘1+2j’) 是合法的，但 complex(‘1 + 2j’) 会触发 ValueError 异常。<br> 在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p> 
  <p>class <strong>float([x])</strong><br> 返回从数字或字符串 x 生成的浮点数。</p> 
  <p>如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以有符号，之前也可以有空格。可选的符号有 ‘+’ 和 ‘-‘ ； ‘+’ 对创建的值没有影响。实参也可以是 NaN（非数字）、正负无穷大的字符串。</p> 
  <p><strong>class int([x])</strong><br><strong>class int(x, base=10)</strong><br> 返回一个使用数字或字符串 x 生成的整数对象，或者没有实参的时候返回 0 。如果 x 定义了 <strong>int</strong>()，int(x) 返回 x.<strong>int</strong>() 。如果 x 定义了 <strong>trunc</strong>()，它返回 x.<strong>trunc</strong>() 。对于浮点数，它向零舍入。</p> 
  <p>如果 x 不是数字，或者有 base 参数，x 必须是字符串、bytes、表示进制为 base 的 整数文字 的 bytearray 实例。该文字前可以有 + 或 – （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 a 到 z （或 A 到 Z ）表示 10 到 35。默认的 base 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 0b/0B 、 0o/0O 、 0x/0X 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 int(‘010’, 0) 是非法的，但 int(‘010’) 和 int(‘010’, 8) 是合法的。</p> 
  <p>class <strong>str(object=”)</strong><br> class <strong>str(object=b”, encoding=’utf-8′, errors=’strict’)</strong></p> 
  <p>返回一个str类型的对象。<code>str</code>是内置字符串类</p> 
  <p>class <strong>list([iterable])</strong><br> 除了是函数，list 也是可变序列类型，详情请参阅 列表 和 Sequence Types — list, tuple, range。</p> 
  <p><strong>tuple([iterable])</strong><br> 元组是内置的不可变序列类型。<code>tuple()</code>生成一个元组对象，可选参数iterable的元素将被加入到新元组。</p> 
  <p>class <strong><code>dict(**kwarg)</code></strong><br> class <strong><code>dict(mapping, **kwarg)</code></strong><br> class <strong><code>dict(iterable, **kwarg)</code></strong><br> 创建一个新的字典。dict 对象是一个字典类<br> 其他容器类型，请参见内置的 list、set 和 tuple 类，以及 collections 模块。</p> 
  <p>class <strong>set([iterable])</strong><br> 返回一个set对象。可选参数iterable的元素将被加入新set对象里面。</p> 
  <p>class <strong>frozenset([iterable])</strong><br> 返回一个新的 frozenset 对象，它包含可选参数 iterable 中的元素。 frozenset 是一个内置的类。</p> 
  <p>class <strong>object</strong><br> 返回一个没有特征的新对象。object 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。</p> 
  <p>注解 由于 object 没有 <strong>dict</strong>，因此无法将任意属性赋给 object 的实例。</p> 
  <p>class <strong>range(stop)</strong><br> class <strong>range(start, stop[, step])</strong><br><code>range</code>其实是个不可变数字序列类型而不是一个函数，通常用于在for循环中循环特定次数。<br> 传给range的实参必须是整数（或是内置类型int，或是实现了<strong>index</strong>这个特殊方法的对象）。如果<code>step</code>参数省略了，则它默认为1.如果<code>start</code>省略了则默认为0。如果<code>step</code>为0，则报错：<code>ValueError</code>。</p> 
  <p>如果<code>step</code>为整数，range 的内容决定于公式：<code>r[i] = start + step*i</code>，其中<code>i &gt;= 0, r[i] &lt; stop</code>。</p> 
  <p>如果<code>step</code>是负数，range 的内容仍决定于公式：<code>r[i] = start + step*i</code>，其中<code>i &gt;= 0, r[i] &gt; stop</code>。</p> 
  <p>如果r[0]不满足值约束，则range对象将为空。 range确实支持负索引，但这些索引被解释为从正索引确定的序列末尾开始的索引。</p> 
  <p>range被允许包含绝对值大于<code>sys.maxsize</code>的值，但是某些特性（如len()）可能会报错：<code>OverflowError</code>。<br> 参看下面range的例子：</p> 
  <pre class="has">
<code>In [32]: list(range(9))
Out[32]: [0, 1, 2, 3, 4, 5, 6, 7, 8]

In [33]: list(range(3,9))
Out[33]: [3, 4, 5, 6, 7, 8]

In [34]: list(range(0, 20, 3))
Out[34]: [0, 3, 6, 9, 12, 15, 18]

In [35]: list(range(0, -10, -1))
Out[35]: [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]

In [36]: list(range(0))
Out[36]: []

In [37]: list(range(10, 0))
Out[37]: []

</code></pre> 
  <p>range类型比通常的list或tuple的优点是，range对线下总是占用相同（小的）数量的内存，不管它表示的范围有多大。因为它只存储<code>start</code>，<code>stop</code>和<code>step</code>的值，在需要的时候才计算单独的元素或子范围。</p> 
  <p>range对象实现了类似list或tuple序列的特性，比如包含测试，元素索引查找，切片和对负索引的支持。参见下面的例子：</p> 
  <pre class="has">
<code>In [43]: r = range(0, 10, 2)

In [44]: r
Out[44]: range(0, 10, 2)

In [45]: 5 in r
Out[45]: False

In [46]: 6 in r
Out[46]: True

In [47]: r.index(8)
Out[47]: 4

In [48]: r[3]
Out[48]: 6

In [49]: r[:3]
Out[49]: range(0, 6, 2)

In [50]: r[-1]
Out[50]: 8

</code></pre> 
  <p>通过<code>==</code>和<code>!=</code>测试两个range对象的相等性是把它们当做序列进行比较。也就是说，如果两个range对象表示相同的值的序列就认为它们实时相等的。</p> 
  <p><strong>注意：</strong>两个range对象相等但可能含有不同的<code>start</code>，<code>stop</code>和<code>step</code>属性，比如<code>range(0) == range(2, 1, 1)</code>或者<code>range(0, 3, 2) == range(0, 4, 2)</code>。</p> 
  <p>class <strong>slice(stop)</strong><br> class <strong>slice(start, stop[, step])</strong></p> 
  <p>返回一个切片对象，表示由range(start,stop,step)指定的索引集。start和step参数默认为None。Slice对象具有只读数据属性start，stop和step，它们只返回参数值（或它们的默认值）。他们没有其他明确的功能；但是它们被Numerical Python和其他第三方扩展使用。使用扩展索引语法时也会生成切片对象。例如：a[start:stop:step]或a[start:stop,i]。</p> 
  <p>class <strong>type(object)</strong><br> class <strong>type(name, bases, dict)</strong></p> 
  <p>传入一个参数object，则返回该对象的类型。返回值是一个type对象，通常和<code>object.__class__</code>返回的一样。<br> 建议使用isinstance（）内置函数来测试对象的类型，因为它需要考虑子类。<br> 使用三个参数，返回一个新类型对象。 这实际上是类语句的动态形式。 名称字符串是类名，并成为<strong>name</strong>属性; 基元元组列出基类并成为<strong>bases</strong>属性; 并且dict字典是包含类主体定义的命名空间，并被复制到标准字典以成为<strong>dict</strong>属性。 例如，以下两个语句创建相同的类型对象：</p> 
  <p><img alt="" class="has" src="https://upload-images.jianshu.io/upload_images/13090773-2d9795e33164f8d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp"></p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
