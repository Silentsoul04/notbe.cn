<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>python教程（十二）类 « NotBeCN</title>
  <meta name="description" content="         类   介绍   Python作用域和命名空间       作用域和命名空间示例      初探类       类定义语法      类对象      实例对象      方法对象      类和实例变量      补充说明      继承       多重继承      私有变量   &nbs...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/tianzhiya121_90136748.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">python教程（十二）类</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>类</h1> 
  <h1><span style="color:#3399ea;">介绍</span></h1> 
  <h1><span style="color:#3399ea;">Python作用域和命名空间</span></h1> 
  <ul>
   <li> <h2><span style="color:#3399ea;">作用域和命名空间示例</span></h2> </li> 
  </ul>
  <h1><span style="color:#3399ea;">初探类</span></h1> 
  <ul>
   <li> <h2><span style="color:#3399ea;">类定义语法</span></h2> </li> 
   <li> <h2><span style="color:#3399ea;">类对象</span></h2> </li> 
   <li> <h2><span style="color:#3399ea;">实例对象</span></h2> </li> 
   <li> <h2><span style="color:#3399ea;">方法对象</span></h2> </li> 
   <li> <h2><span style="color:#3399ea;">类和实例变量</span></h2> </li> 
   <li> <h2><span style="color:#3399ea;">补充说明</span></h2> </li> 
  </ul>
  <h1><span style="color:#3399ea;">继承</span></h1> 
  <ul>
   <li> <h2><span style="color:#3399ea;">多重继承</span></h2> </li> 
  </ul>
  <h1><span style="color:#3399ea;">私有变量</span></h1> 
  <p>&nbsp;</p> 
  <h1>介绍</h1> 
  <p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p> 
  <p>&nbsp;</p> 
  <h1>Python作用域和命名空间</h1> 
  <p>Python使用叫做命名空间的东西来记录变量的轨迹。命名空间是一个 字典（dictionary） ，它的键就是变量名，它的值就是那些变量的值。</p> 
  <p>在一个 Python 程序中的任何一个地方，都存在几个可用的命名空间。</p> 
  <p>&nbsp; &nbsp; &nbsp;1、每个函数都有着自已的命名空间，叫做局部命名空间，它记录了函数的变量，包括函数的参数和局部定义的变量。</p> 
  <p>&nbsp; &nbsp; &nbsp;2、每个模块拥有它自已的命名空间，叫做全局命名空间，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</p> 
  <p>&nbsp; &nbsp; &nbsp;3、还有就是内置命名空间，任何模块均可访问它，它存放着内置的函数和异常。</p> 
  <p><a href="https://www.cnblogs.com/windlaughing/archive/2013/05/26/3100362.html" rel="nofollow">参考</a></p> 
  <ul>
   <li> <h3>命名空间查找顺序</h3> </li> 
  </ul>
  <p>当一行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序：</p> 
  <p>&nbsp; &nbsp; &nbsp;1、局部命名空间：特指当前函数或类的方法。如果函数定义了一个局部变量 x，或一个参数 x，Python 将使用它，然后停止搜索。</p> 
  <p>&nbsp; &nbsp; &nbsp;2、全局命名空间：特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用它然后停止搜索。</p> 
  <p>&nbsp; &nbsp; &nbsp;3、内置命名空间：对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。</p> 
  <p>&nbsp; &nbsp; &nbsp;4、如果 Python 在这些名字空间找不到 x，它将放弃查找并引发一个 NameError 异常，如，NameError: name 'aa' is not defined。</p> 
  <p>&nbsp;</p> 
  <ul>
   <li> <h3>嵌套函数的情况：</h3> </li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp;1、先在当前 (嵌套的或 lambda) 函数的命名空间中搜索</p> 
  <p>&nbsp; &nbsp; &nbsp;2、然后是在父函数的命名空间中搜索</p> 
  <p>&nbsp; &nbsp; &nbsp;3、接着是模块命名空间中搜索</p> 
  <p>&nbsp; &nbsp; &nbsp;4、最后在内置命名空间中搜索</p> 
  <ul>
   <li> <h3>命名空间的生命周期：</h3> </li> 
  </ul>
  <p>&nbsp; &nbsp; &nbsp;1、内置命名空间在 Python 解释器启动时创建，会一直保留，不被删除。</p> 
  <p>&nbsp; &nbsp; &nbsp;2、模块的全局命名空间在模块定义被读入时创建，通常模块命名空间也会一直保存到解释器退出。</p> 
  <p>&nbsp; &nbsp; &nbsp;3、当函数被调用时创建一个局部命名空间，当函数返回结果 或 抛出异常时，被删除。每一个递归调用的函数都拥有自己的命名空间。</p> 
  <p>Python 的一个特别之处在于其赋值操作总是在最里层的作用域。赋值不会复制数据——只是将命名绑定到对象。删除也是如此："del y" 只是从局部作用域的命名空间中删除命名 y 。事实上，所有引入新命名的操作都作用于局部作用域。</p> 
  <pre class="has">
<code class="language-python">i = 1
def f1():
  i = i + 1
  print(i)
f1()
#错误：UnboundLocalError: local variable 'i' referenced before assignment</code></pre> 
  <p>由于创建命名空间时，python会检查代码并填充局部命名空间。在python运行那行代码之前，就发现了对i的赋值，并把它添加到局部命名空间中。当函数执行时，python解释器认为i在局部命名空间中但没有值，所以会产生错误。</p> 
  <ul>
   <li> <h2>命名空间的访问</h2> </li> 
  </ul>
  <p><strong>1、局部命名空间可以 locals() &nbsp;BIF来访问。</strong></p> 
  <p>locals 返回一个名字/值对的 dictionary。这个 dictionary 的键是字符串形式的变量名字，dictionary 的值是变量的实际值。</p> 
  <pre class="has">
<code class="language-python">i = 1
def f1(i, first):
  i = i + 1
  print(locals())
f1(1, 'first')#{'first': 'first', 'i': 2}
</code></pre> 
  <p><strong>2、全局 (模块级别)命名空间可以通过 globals() BIF来访问。</strong></p> 
  <pre class="has">
<code class="language-python">import copy 
from copy import deepcopy

gstr = 'global string'

def func1(i, info):
  x = 12345
  print(locals())
  
func1(1, 'first')

if __name__ == '__main__':
  dictionary=globals()
  print(dictionary)#{'x': 12345, 'info': 'first', 'i': 1}.....</code></pre> 
  <p>&nbsp;</p> 
  <h1>初探类</h1> 
  <p>类引入了一些新语法，三种新对象类型和一些新语义。</p> 
  <ul>
   <li> <h3>类定义语法</h3> </li> 
  </ul>
  <p>最简单的类定义看起来像这样:</p> 
  <pre class="has">
<code class="language-python">class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre> 
  <p>类定义与函数定义 (<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" rel="nofollow"><code>def</code></a>&nbsp;语句) 一样必须被执行才会起作用。</p> 
  <p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 --- 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p> 
  <ul>
   <li> <h3>类对象</h3> </li> 
  </ul>
  <p>类对象支持两种操作：属性引用和实例化。</p> 
  <p><em>属性引用</em>&nbsp;使用 Python 中所有属性引用所使用的标准语法:&nbsp;<code>obj.name</code>。</p> 
  <p>&nbsp;有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p> 
  <pre class="has">
<code class="language-python">class MyClass:
    '''A simple example class'''
    i = 12345

    def f(self):
        return 'hello world'</code></pre> 
  <p>那么&nbsp;<code>MyClass.i</code>&nbsp;和&nbsp;<code>MyClass.f</code>&nbsp;就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改&nbsp;<code>MyClass.i</code>&nbsp;的值。&nbsp;<code>__doc__</code>&nbsp;也是一个有效的属性，将返回所属类的文档字符串:&nbsp;<code>"A&nbsp;simpleexample&nbsp;class"</code>。</p> 
  <p>类的&nbsp;<em>实例化</em>&nbsp;是使用函数表示法。 可以相像类对象就是会返回一个新的类实例的不带参数的函数。</p> 
  <pre class="has">
<code class="language-python">X = MyClass()</code></pre> 
  <p>创建类的新&nbsp;<em>实例</em>&nbsp;并将此对象分配给局部变量&nbsp;<code>x</code>。</p> 
  <p>实例化操作（“调用”类对象）会创建一个空对象。 许多类喜欢创建带有特定初始状态的自定义实例。 为此类定义可能包含一个名为&nbsp;<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" rel="nofollow"><code>__init__()</code></a>&nbsp;的特殊方法，就像这样:</p> 
  <pre class="has">
<code class="language-python">def __init__(self):
    self.data = []</code></pre> 
  <p>当然，<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" rel="nofollow"><code>__init__()</code></a>&nbsp;方法还可以有额外参数以实现更高灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给&nbsp;<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" rel="nofollow"><code>__init__()</code></a>。 例如，:</p> 
  <pre class="has">
<code class="language-python">class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart


x = Complex(3.0, -4.5)
x.r, x.i#(3.0， -4.5)</code></pre> 
  <ul>
   <li> <h2>实例对象</h2> </li> 
  </ul>
  <p>实例对象理解的唯一操作是属性引用。有两种有效的属性名称，数据属性和方法。<em>数据属性</em>&nbsp;对应于 Smalltalk 中的“实例变量”，以及 C++ 中的“数据成员”。 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。 例如，如果&nbsp;<code>x</code>&nbsp;是上面创建的&nbsp;<code>MyClass</code>&nbsp;的实例，则以下代码段将打印数值&nbsp;<code>16</code>，且不保留任何追踪信息:</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code class="language-python">x.counter = 1
while x.counter &lt; 10:
    x.counter = x.counter * 2
print(x.counter)
del x.counter</code></pre> 
  <p>另一类实例属性引用称为&nbsp;<em>方法</em>。 方法是“从属于”对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对方也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明。）</p> 
  <p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因此在我们的示例中，<code>x.f</code>&nbsp;是有效的方法引用，因为&nbsp;<code>MyClass.f</code>&nbsp;是一个函数，而&nbsp;<code>x.i</code>&nbsp;不是方法，因为&nbsp;<code>MyClass.i</code>&nbsp;不是一个函数。 但是&nbsp;<code>x.f</code>&nbsp;与&nbsp;<code>MyClass.f</code>&nbsp;并不是一回事 --- 它是一个&nbsp;<em>方法对象</em>，不是函数对象。</p> 
  <ul>
   <li> <h3>方法对象</h3> </li> 
  </ul>
  <p>通常，方法在绑定后立即被调用:</p> 
  <pre class="has">
<code class="language-python">x.f()</code></pre> 
  <p>在&nbsp;<code>MyClass</code>&nbsp;示例中，这将返回字符串&nbsp;<code>'hello&nbsp;world'</code>。 但是，立即调用一个方法并不是必须的:&nbsp;<code>x.f</code>&nbsp;是一个方法对象，它可以被保存起来以后再调用。 例如:</p> 
  <pre class="has">
<code class="language-python">xf = x.f
while True:
    print(xf())</code></pre> 
  <p>将继续打印&nbsp;<code>hello&nbsp;world</code>，直到结束。</p> 
  <p>方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用&nbsp;<code>x.f()</code>&nbsp;其实就相当于&nbsp;<code>MyClass.f(x)</code>。 总之，调用一个具有&nbsp;<em>n</em>&nbsp;个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。</p> 
  <ul>
   <li> <h3>类和实例变量</h3> </li> 
  </ul>
  <p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p> 
  <pre class="has">
<code class="language-python">class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

&gt;&gt;&gt; d = Dog('Fido')
&gt;&gt;&gt; e = Dog('Buddy')
&gt;&gt;&gt; d.kind                  # shared by all dogs
'canine'
&gt;&gt;&gt; e.kind                  # shared by all dogs
'canine'
&gt;&gt;&gt; d.name                  # unique to d
'Fido'
&gt;&gt;&gt; e.name                  # unique to e
'Buddy'</code></pre> 
  <p>&nbsp;</p> 
  <p>正如&nbsp;<a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object" rel="nofollow">名称和对象</a>&nbsp;中已讨论过的，共享数据可能在涉及&nbsp;<a href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable" rel="nofollow">mutable</a>&nbsp;对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的&nbsp;<em>tricks</em>&nbsp;列表不应该被用作类变量，因为所有的&nbsp;<em>Dog</em>&nbsp;实例将只共享一个单独的列表:</p> 
  <pre class="has">
<code class="language-python">class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

&gt;&gt;&gt; d = Dog('Fido')
&gt;&gt;&gt; e = Dog('Buddy')
&gt;&gt;&gt; d.add_trick('roll over')
&gt;&gt;&gt; e.add_trick('play dead')
&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']</code></pre> 
  <p>正确的类设计应该使用实例变量：</p> 
  <pre class="has">
<code class="language-python">class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

&gt;&gt;&gt; d = Dog('Fido')
&gt;&gt;&gt; e = Dog('Buddy')
&gt;&gt;&gt; d.add_trick('roll over')
&gt;&gt;&gt; e.add_trick('play dead')
&gt;&gt;&gt; d.tricks
['roll over']
&gt;&gt;&gt; e.tricks
['play dead']</code></pre> 
  <h1>补充说明</h1> 
  <p>数据属性会覆盖掉具有相同名称的方法属性；为了避免会在大型程序中导致难以发现的错误的意外名称冲突，明智的做法是使用某种约定来最小化冲突的发生几率。 可能的约定包括方法名称使用大写字母，属性名称加上独特的短字符串前缀（或许只加一个下划线），或者是用动词来命名方法，而用名词来命名数据属性。</p> 
  <p>方法的第一个参数常常被命名为&nbsp;<code>self</code>。 这也不过就是一个约定:&nbsp;<code>self</code>&nbsp;这一名称在 Python 中绝对没有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，而且也可以想像一个&nbsp;<em>类浏览器</em>&nbsp;程序的编写可能会依赖于这样的约定。</p> 
  <p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:</p> 
  <pre class="has">
<code class="language-python"># Function defined outside the class
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1

    def g(self):
        return 'hello world'

    h = g</code></pre> 
  <p>现在&nbsp;<code>f</code>,&nbsp;<code>g</code>&nbsp;和&nbsp;<code>h</code>&nbsp;都是&nbsp;<code>C</code>&nbsp;类的引用函数对象的属性，因而它们就都是&nbsp;<code>C</code>&nbsp;的实例的方法 --- 其中&nbsp;<code>h</code>&nbsp;完全等同于&nbsp;<code>g</code>。 但请注意，本示例的做法通常只会令程序的阅读者感到迷惑。</p> 
  <p>方法可以通过使用&nbsp;<code>self</code>&nbsp;参数的方法属性调用其他方法:</p> 
  <pre class="has">
<code class="language-python">class Bag:
    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)</code></pre> 
  <p>&nbsp;</p> 
  <h1>继承</h1> 
  <p>当然，如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示:</p> 
  <pre class="has">
<code class="language-python">class DerivedClassName(BaseClassName):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre> 
  <p>名称&nbsp;<code>BaseClassName</code>&nbsp;必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p> 
  <pre class="has">
<code class="language-python">class DerivedClassName(modname.BaseClassName):</code></pre> 
  <p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p> 
  <p>派生类的实例化没有任何特殊之处:&nbsp;<code>DerivedClassName()</code>&nbsp;会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p> 
  <p>Python有两个内置函数可被用于继承机制：</p> 
  <ul>
   <li>使用&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" rel="nofollow"><code>isinstance()</code></a>&nbsp;来检查一个实例的类型:&nbsp;<code>isinstance(obj,&nbsp;int)</code>&nbsp;仅会在&nbsp;<code>obj.__class__</code>&nbsp;为&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#int" rel="nofollow"><code>int</code></a>&nbsp;或某个派生自&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#int" rel="nofollow"><code>int</code></a>&nbsp;的类时为&nbsp;<code>True</code>。</li> 
   <li>使用&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" rel="nofollow"><code>issubclass()</code></a>&nbsp;来检查类的继承关系:&nbsp;<code>issubclass(bool,&nbsp;int)</code>&nbsp;为&nbsp;<code>True</code>，因为&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#bool" rel="nofollow"><code>bool</code></a>&nbsp;是&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#int" rel="nofollow"><code>int</code></a>&nbsp;的子类。 但是，<code>issubclass(float,&nbsp;int)</code>&nbsp;为&nbsp;<code>False</code>，因为&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#float" rel="nofollow"><code>float</code></a>&nbsp;不是&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#int" rel="nofollow"><code>int</code></a>&nbsp;的子类。</li> 
  </ul>
  <p>&nbsp;</p> 
  <h2>多重继承</h2> 
  <p>对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在&nbsp;<code>DerivedClassName</code>&nbsp;中未找到，则会到&nbsp;<code>Base1</code>&nbsp;中搜索它，然后（递归地）到&nbsp;<code>Base1</code>&nbsp;的基类中搜索，如果在那里未找到，再到&nbsp;<code>Base2</code>&nbsp;中搜索，依此类推。</p> 
  <pre class="has">
<code class="language-python">class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre> 
  <p>真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#super" rel="nofollow"><code>super()</code></a>&nbsp;的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大</p> 
  <p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#object" rel="nofollow"><code>object</code></a>，因此任何多重继承的情况都提供了一条以上的路径可以通向&nbsp;<a href="https://docs.python.org/zh-cn/3/library/functions.html#object" rel="nofollow"><code>object</code></a>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅&nbsp;<a href="https://www.python.org/download/releases/2.3/mro/" rel="nofollow">https://www.python.org/download/releases/2.3/mro/</a>。</p> 
  <h1>私有变量</h1> 
  <p>private下标识的变量，类中可以访问，类外不能访问。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
