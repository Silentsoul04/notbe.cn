<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Makefile « NotBeCN</title>
  <meta name="description" content="                  概述   什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/code527_90138011.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Makefile</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2><a id="_0"></a>概述</h2> 
  <p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。</p> 
  <p>因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p> 
  <p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p> 
  <p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。</p> 
  <p>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p> 
  <h2><a id="_14"></a>编译和链接</h2> 
  <p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p> 
  <p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p> 
  <p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p> 
  <p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</p> 
  <h2><a id="1_Makefile__24"></a><strong>1. Makefile 简介</strong></h2> 
  <p>Makefile 是和 make 命令一起配合使用的.</p> 
  <p>很多大型项目的编译都是通过 Makefile 来组织的, 如果没有 Makefile, 那很多项目中各种库和代码之间的依赖关系不知会多复杂.</p> 
  <p>Makefile的组织流程的能力如此之强, 不仅可以用来编译项目, 还可以用来组织我们平时的一些日常操作. 这个需要大家发挥自己的想象力.</p> 
  <h3><a id="11_Makefile__5______32"></a><strong>1.1 Makefile 主要的 5个部分 (显示规则, 隐晦规则, 变量定义, 文件指示, 注释)</strong></h3> 
  <p>Makefile基本格式如下:</p> 
  <blockquote> 
   <pre><code class="prism language-c">target <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">:</span> prerequisites <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    command
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
  </blockquote> 
  <p>其中,</p> 
  <ul> 
   <li>target - 目标文件, 可以是 Object File, 也可以是可执行文件</li> 
   <li>prerequisites - 生成 target 所需要的文件或者目标</li> 
   <li>command - make需要执行的命令 (任意的shell命令), Makefile中的命令必须以 [tab] 开头</li> 
  </ul> 
  <ol> 
   <li><strong>显示规则 :: 说明如何生成一个或多个目标文件(包括 生成的文件, 文件的依赖文件, 生成的命令)</strong></li> 
   <li><strong>隐晦规则 :: make的自动推导功能所执行的规则</strong></li> 
   <li><strong>变量定义 :: Makefile中定义的变量</strong></li> 
   <li><strong>文件指示 :: Makefile中引用其他Makefile; 指定Makefile中有效部分; 定义一个多行命令</strong></li> 
   <li><strong>注释 :: Makefile只有行注释 “#”, 如果要使用或者输出"#"字符, 需要进行转义, "#"</strong></li> 
  </ol> 
  <h3><a id="12_GNU_make__59"></a><strong>1.2 GNU make 的工作方式</strong></h3> 
  <ol> 
   <li>读入主Makefile (主Makefile中可以引用其他Makefile)</li> 
   <li>读入被include的其他Makefile</li> 
   <li>初始化文件中的变量</li> 
   <li>推导隐晦规则, 并分析所有规则</li> 
   <li>为所有的目标文件创建依赖关系链</li> 
   <li>根据依赖关系, 决定哪些目标要重新生成</li> 
   <li>执行生成命令</li> 
  </ol> 
  <h2><a id="2_Makefile__71"></a><strong>2. Makefile 初级语法</strong></h2> 
  <h3><a id="21_Makefile__73"></a><strong>2.1 Makefile 规则</strong></h3> 
  <h4><a id="211__75"></a><strong>2.1.1 规则语法</strong></h4> 
  <p>规则主要有2部分: 依赖关系 和 生成目标的方法.</p> 
  <p>语法有以下2种:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile">target ... : prerequisites ...
    command
    ...
</code></pre> 
  </blockquote> 
  <p>或者</p> 
  <blockquote> 
   <pre><code class="prism language-makefile">target ... : prerequisites ; command
    command
    ...
</code></pre> 
  </blockquote> 
  <p>*<strong>注*</strong> command太长, 可以用 “” 作为换行符</p> 
  <h4><a id="212__99"></a><strong>2.1.2 规则中的通配符</strong></h4> 
  <ul> 
   <li>* :: 表示任意一个或多个字符</li> 
   <li>? :: 表示任意一个字符</li> 
   <li>[…] :: ex. [abcd] 表示a,b,c,d中任意一个字符, [^abcd]表示除a,b,c,d以外的字符, [0-9]表示 0~9中任意一个数字</li> 
   <li>~ :: 表示用户的home目录</li> 
  </ul> 
  <h4><a id="213__108"></a><strong>2.1.3 路径搜索</strong></h4> 
  <p>当一个Makefile中涉及到大量源文件时(这些源文件和Makefile极有可能不在同一个目录中),</p> 
  <p>这时, 最好将源文件的路径明确在Makefile中, 便于编译时查找. Makefile中有个特殊的变量 <strong>VPATH</strong> 就是完成这个功能的.</p> 
  <p>指定了 <strong>VPATH</strong> 之后, 如果当前目录中没有找到相应文件或依赖的文件, Makefile 回到 <strong>VPATH</strong> 指定的路径中再去查找…</p> 
  <p><strong>VPATH</strong> 使用方法:</p> 
  <ul> 
   <li>vpath :: 当前目录中找不到文件时, 就从中搜索</li> 
   <li>vpath :: 符合格式的文件, 就从中搜索</li> 
   <li>vpath :: 清除符合格式的文件搜索路径</li> 
   <li>vpath :: 清除所有已经设置好的文件路径</li> 
  </ul> 
  <blockquote> 
   <pre><code class="prism language-makefile"># 示例1 - 当前目录中找不到文件时, 按顺序从 src目录 ../parent-dir目录中查找文件
VPATH src:../parent-dir   

# 示例2 - .h结尾的文件都从 ./header 目录中查找
VPATH %.h ./header

# 示例3 - 清除示例2中设置的规则
VPATH %.h

# 示例4 - 清除所有VPATH的设置
VPATH
</code></pre> 
  </blockquote> 
  <h3><a id="22_Makefile__139"></a><strong>2.2 Makefile 中的变量</strong></h3> 
  <h4><a id="221____or___141"></a><strong>2.2.1 变量定义 ( = or := )</strong></h4> 
  <blockquote> 
   <pre><code class="prism language-makefile">OBJS = programA.o programB.o
OBJS-ADD = $(OBJS) programC.o
# 或者
OBJS := programA.o programB.o
OBJS-ADD := $(OBJS) programC.o
</code></pre> 
  </blockquote> 
  <p>其中 = 和 := 的区别在于, := 只能使用前面定义好的变量, = 可以使用后面定义的变量</p> 
  <p><strong>测试 =</strong></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile内容
OBJS2 = $(OBJS1) programC.o
OBJS1 = programA.o programB.o

all:
    @echo $(OBJS2)

# bash中执行 make, 可以看出虽然 OBJS1 是在 OBJS2 之后定义的, 但在 OBJS2中可以提前使用
$ make
programA.o programB.o programC.o
</code></pre> 
  </blockquote> 
  <p><strong>测试 :=</strong></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile内容
OBJS2 := $(OBJS1) programC.o
OBJS1 := programA.o programB.o

all:
    @echo $(OBJS2)

# bash中执行 make, 可以看出 OBJS2 中的 $(OBJS1) 为空
$ make
programC.o
</code></pre> 
  </blockquote> 
  <h4><a id="222__187"></a><strong>2.2.2 变量替换</strong></h4> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile内容
SRCS := programA.c programB.c programC.c
OBJS := $(SRCS:%.c=%.o)

all:
    @echo "SRCS: " $(SRCS)
    @echo "OBJS: " $(OBJS)

# bash中运行make
$ make
SRCS:  programA.c programB.c programC.c
OBJS:  programA.o programB.o programC.o
</code></pre> 
  </blockquote> 
  <h4><a id="223___206"></a><strong>2.2.3 变量追加值 +=</strong></h4> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile内容
SRCS := programA.c programB.c programC.c
SRCS += programD.c

all:
    @echo "SRCS: " $(SRCS)

# bash中运行make
$ make
SRCS:  programA.c programB.c programC.c programD.c
</code></pre> 
  </blockquote> 
  <h4><a id="224__override_223"></a><strong>2.2.4 变量覆盖 override</strong></h4> 
  <p>作用是使 Makefile中定义的变量能够覆盖 make 命令参数中指定的变量</p> 
  <p>语法:</p> 
  <ul> 
   <li>override = </li> 
   <li>override := </li> 
   <li>override += </li> 
  </ul> 
  <p>下面通过一个例子体会 override 的作用：</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile内容 (没有用override)
SRCS := programA.c programB.c programC.c

all:
    @echo "SRCS: " $(SRCS)

# bash中运行make
$ make SRCS=nothing
SRCS:  nothing

#################################################

# Makefile内容 (用override)
override SRCS := programA.c programB.c programC.c

all:
    @echo "SRCS: " $(SRCS)

# bash中运行make
$ make SRCS=nothing
SRCS:  programA.c programB.c programC.c
</code></pre> 
  </blockquote> 
  <h4><a id="225__263"></a><strong>2.2.5 目标变量</strong></h4> 
  <p>作用是使变量的作用域仅限于这个目标(target), 而不像之前例子中定义的变量, 对整个Makefile都有效.</p> 
  <p>语法:</p> 
  <ul> 
   <li>&lt;target …&gt; :: </li> 
   <li>&lt;target …&gt; :: override (override作用参见 变量覆盖的介绍)</li> 
  </ul> 
  <p>示例:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
SRCS := programA.c programB.c programC.c

target1: TARGET1-SRCS := programD.c
target1:
    @echo "SRCS: " $(SRCS)
    @echo "SRCS: " $(TARGET1-SRCS)

target2:
    @echo "SRCS: " $(SRCS)
    @echo "SRCS: " $(TARGET1-SRCS)

# bash中执行make
$ make target1
SRCS:  programA.c programB.c programC.c
SRCS:  programD.c

$ make target2     &lt;-- target2中显示不了 $(TARGET1-SRCS)
SRCS:  programA.c programB.c programC.c
SRCS:
</code></pre> 
  </blockquote> 
  <h3><a id="23_Makefile__299"></a><strong>2.3 Makefile 命令前缀</strong></h3> 
  <p>Makefile 中书写shell命令时可以加2种前缀 @ 和 -, 或者不用前缀.</p> 
  <p>3种格式的shell命令区别如下:</p> 
  <ul> 
   <li>不用前缀 :: 输出执行的命令以及命令执行的结果, 出错的话停止执行</li> 
   <li>前缀 @ :: 只输出命令执行的结果, 出错的话停止执行</li> 
   <li>前缀 - :: 命令执行有错的话, 忽略错误, 继续执行</li> 
  </ul> 
  <p>示例:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容 (不用前缀)
all:
    echo "没有前缀"
    cat this_file_not_exist
    echo "错误之后的命令"       &lt;-- 这条命令不会被执行

# bash中执行 make
$ make
echo "没有前缀"             &lt;-- 命令本身显示出来
没有前缀                    &lt;-- 命令执行结果显示出来
cat this_file_not_exist
cat: this_file_not_exist: No such file or directory
make: *** [all] Error 1

###########################################################

# Makefile 内容 (前缀 @)
all:
    @echo "没有前缀"
    @cat this_file_not_exist
    @echo "错误之后的命令"       &lt;-- 这条命令不会被执行

# bash中执行 make
$ make
没有前缀                         &lt;-- 只有命令执行的结果, 不显示命令本身
cat: this_file_not_exist: No such file or directory
make: *** [all] Error 1

###########################################################

# Makefile 内容 (前缀 -)
all:
    -echo "没有前缀"
    -cat this_file_not_exist
    -echo "错误之后的命令"       &lt;-- 这条命令会被执行

# bash中执行 make
$ make
echo "没有前缀"             &lt;-- 命令本身显示出来
没有前缀                    &lt;-- 命令执行结果显示出来
cat this_file_not_exist
cat: this_file_not_exist: No such file or directory
make: [all] Error 1 (ignored)
echo "错误之后的命令"       &lt;-- 出错之后的命令也会显示
错误之后的命令              &lt;-- 出错之后的命令也会执行
</code></pre> 
  </blockquote> 
  <h3><a id="24__361"></a><strong>2.4 伪目标</strong></h3> 
  <p>伪目标并不是一个"目标(target)", 不像真正的目标那样会生成一个目标文件.</p> 
  <p>典型的伪目标是 Makefile 中用来清理编译过程中中间文件的 clean 伪目标, 一般格式如下:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile">.PHONY: clean   &lt;-- 这句没有也行, 但是最好加上
clean:
    -rm -f *.o
</code></pre> 
  </blockquote> 
  <h3><a id="25__Makefile_375"></a><strong>2.5 引用其他的 Makefile</strong></h3> 
  <p>语法: include (filename 可以包含通配符和路径)</p> 
  <p>示例:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo "主 Makefile begin"
    @make other-all
    @echo "主 Makefile end"

include ./other/Makefile

# ./other/Makefile 内容
other-all:
    @echo "other makefile begin"
    @echo "other makefile end"

# bash中执行 make
$ ll
total 20K
-rw-r--r-- 1 wangyubin wangyubin  125 Sep 23 16:13 Makefile
-rw-r--r-- 1 wangyubin wangyubin  11K Sep 23 16:15 makefile.org   &lt;-- 这个文件不用管
drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 16:11 other
$ ll other/
total 4.0K
-rw-r--r-- 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile

$ make
主 Makefile begin
make[1]: Entering directory `/path/to/test/makefile'
other makefile begin
other makefile end
make[1]: Leaving directory `/path/to/test/makefile'
主 Makefile end
</code></pre> 
  </blockquote> 
  <h3><a id="26_C_417"></a><strong>2.6 查看C文件的依赖关系</strong></h3> 
  <p>写 Makefile 的时候, 需要确定每个目标的依赖关系.</p> 
  <p>GNU提供一个机制可以查看C代码文件依赖那些文件, 这样我们在写 Makefile 目标的时候就不用打开C源码来看其依赖那些文件了.</p> 
  <p>比如, 下面命令显示内核源码中 virt/kvm/kvm_main.c 中的依赖关系</p> 
  <blockquote> 
   <pre><code class="prism language-makefile">$ cd virt/kvm/
$ gcc -MM kvm_main.c 
kvm_main.o: kvm_main.c iodev.h coalesced_mmio.h async_pf.h   &lt;-- 这句就可以加到 Makefile 中作为编译 kvm_main.o 的依赖关系
</code></pre> 
  </blockquote> 
  <h3><a id="27_make__434"></a><strong>2.7 make 退出码</strong></h3> 
  <p>Makefile的退出码有以下3种：</p> 
  <ul> 
   <li>0 :: 表示成功执行</li> 
   <li>1 :: 表示make命令出现了错误</li> 
   <li>2 :: 使用了 “-q” 选项, 并且make使得一些目标不需要更新</li> 
  </ul> 
  <h3><a id="28__Makefile__444"></a><strong>2.8 指定 Makefile， 指定特定目标</strong></h3> 
  <p>默认执行 make 命令时, GNU make在当前目录下依次搜索下面3个文件 “GNUmakefile”, “makefile”, “Makefile”,</p> 
  <p>找到对应文件之后, 就开始执行此文件中的第一个目标(target). 如果找不到这3个文件就报错.</p> 
  <p>非默认情况下, 可以在 make 命令中指定特定的 Makefile 和特定的 目标.</p> 
  <p>示例：</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile文件名改为 MyMake, 内容
target1:
    @echo "target [1]  begin"
    @echo "target [1]  end"

target2:
    @echo "target [2]  begin"
    @echo "target [2]  end"

# bash 中执行 make
$ ls
Makefile
$ mv Makefile MyMake
$ ls
MyMake
$ make                     &lt;-- 找不到默认的 Makefile
make: *** No targets specified and no makefile found.  Stop.
$ make -f MyMake           &lt;-- 指定特定的Makefile
target [1]  begin
target [1]  end
$ make -f MyMake target2   &lt;-- 指定特定的目标(target)
target [2]  begin
target [2]  end
</code></pre> 
  </blockquote> 
  <h3><a id="29_make__483"></a><strong>2.9 make 参数介绍</strong></h3> 
  <p>make 的参数有很多, 可以通过 make -h 去查看, 下面只介绍几个我认为比较有用的.</p> 
  <blockquote> 
   <table> 
    <thead> 
     <tr> 
      <th><strong>参数</strong></th> 
      <th><strong>含义</strong></th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>–debug[=]</td> 
      <td>输出make的调试信息, options 可以是 a, b, v</td> 
     </tr> 
     <tr> 
      <td>-j --jobs</td> 
      <td>同时运行的命令的个数, 也就是多线程执行 Makefile</td> 
     </tr> 
     <tr> 
      <td>-r --no-builtin-rules</td> 
      <td>禁止使用任何隐含规则</td> 
     </tr> 
     <tr> 
      <td>-R --no-builtin-variabes</td> 
      <td>禁止使用任何作用于变量上的隐含规则</td> 
     </tr> 
     <tr> 
      <td>-B --always-make</td> 
      <td>假设所有目标都有更新, 即强制重编译</td> 
     </tr> 
    </tbody> 
   </table>
  </blockquote> 
  <h3><a id="210_Makefile__498"></a><strong>2.10 Makefile 隐含规则</strong></h3> 
  <p>这里只列一个和编译C相关的.</p> 
  <p>编译C时，.o 的目标会自动推导为 .c</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 中
main : main.o
    gcc -o main main.o

#会自动变为:
main : main.o
    gcc -o main main.o

main.o: main.c    &lt;-- main.o 这个目标是隐含生成的
    gcc -c main.c
</code></pre> 
  </blockquote> 
  <h3><a id="211_____520"></a><strong>2.11 隐含规则中的 命令变量 和 命令参数变量</strong></h3> 
  <h4><a id="2111__Makefile_shell_522"></a><strong>2.11.1 命令变量, 书写Makefile可以直接写 shell时用这些变量.</strong></h4> 
  <p>下面只列出一些C相关的</p> 
  <blockquote> 
   <table> 
    <thead> 
     <tr> 
      <th><strong>变量名</strong></th> 
      <th><strong>含义</strong></th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>RM</td> 
      <td>rm -f</td> 
     </tr> 
     <tr> 
      <td>AR</td> 
      <td>ar</td> 
     </tr> 
     <tr> 
      <td>CC</td> 
      <td>cc</td> 
     </tr> 
     <tr> 
      <td>CXX</td> 
      <td>g++</td> 
     </tr> 
    </tbody> 
   </table>
  </blockquote> 
  <p>示例:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(RM)
    @echo $(AR)
    @echo $(CC)
    @echo $(CXX)

# bash 中执行make, 显示各个变量的值
$ make
rm -f
ar
cc
g++
</code></pre> 
  </blockquote> 
  <h4><a id="2112__555"></a><strong>2.11.2 命令参数变量</strong></h4> 
  <table> 
   <thead> 
    <tr> 
     <th><strong>变量名</strong></th> 
     <th><strong>含义</strong></th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>ARFLAGS</td> 
     <td>AR命令的参数</td> 
    </tr> 
    <tr> 
     <td>CFLAGS</td> 
     <td>C语言编译器的参数</td> 
    </tr> 
    <tr> 
     <td>CXXFLAGS</td> 
     <td>C++语言编译器的参数</td> 
    </tr> 
   </tbody> 
  </table>
  <p>示例: 下面以 CFLAGS 为例演示</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># test.c 内容
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf ("Hello Makefile\n");
    return 0;
}

# Makefile 内容
test: test.o
    $(CC) -o test test.o

# bash 中用 make 来测试
$ ll
total 24K
-rw-r--r-- 1 wangyubin wangyubin  69 Sep 23 17:31 Makefile
-rw-r--r-- 1 wangyubin wangyubin 14K Sep 23 19:51 makefile.org   &lt;-- 请忽略这个文件
-rw-r--r-- 1 wangyubin wangyubin 392 Sep 23 17:31 test.c

$ make
cc    -c -o test.o test.c
cc -o test test.o               &lt;-- 这个是自动推导的

$ rm -f test test.o

$ make CFLAGS=-Wall             &lt;-- 命令中加的编译器参数自动追加入下面的编译中了
cc -Wall   -c -o test.o test.c
cc -o test test.o
</code></pre> 
  </blockquote> 
  <h3><a id="212__602"></a><strong>2.12 自动变量</strong></h3> 
  <p>Makefile 中很多时候通过自动变量来简化书写, 各个自动变量的含义如下:</p> 
  <blockquote> 
   <table> 
    <thead> 
     <tr> 
      <th><strong>自动变量</strong></th> 
      <th><strong>含义</strong></th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>$@</td> 
      <td>目标集合</td> 
     </tr> 
     <tr> 
      <td>$%</td> 
      <td>当目标是函数库文件时, 表示其中的目标文件名</td> 
     </tr> 
     <tr> 
      <td>$&lt;</td> 
      <td>第一个依赖目标. 如果依赖目标是多个, 逐个表示依赖目标</td> 
     </tr> 
     <tr> 
      <td>$?</td> 
      <td>比目标新的依赖目标的集合</td> 
     </tr> 
     <tr> 
      <td>$^</td> 
      <td>所有依赖目标的集合, 会去除重复的依赖目标</td> 
     </tr> 
     <tr> 
      <td>$+</td> 
      <td>所有依赖目标的集合, 不会去除重复的依赖目标</td> 
     </tr> 
     <tr> 
      <td>$*</td> 
      <td>这个是GNU make特有的, 其它的make不一定支持</td> 
     </tr> 
    </tbody> 
   </table>
  </blockquote> 
  <h3><a id="3_Makefile__619"></a><strong>3. Makefile 高级语法</strong></h3> 
  <h3><a id="31_Makefile_621"></a><strong>3.1 嵌套Makefile</strong></h3> 
  <p>在 Makefile 初级语法中已经提到过引用其它 Makefile的方法. 这里有另一种写法, 并且可以向引用的其它 Makefile 传递参数.</p> 
  <p>示例: (不传递参数, 只是调用子文件夹 other 中的Makefile)</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo "主 Makefile begin"
    @cd ./other &amp;&amp; make
    @echo "主 Makefile end"


# ./other/Makefile 内容
other-all:
    @echo "other makefile begin"
    @echo "other makefile end"

# bash中执行 make
$ ll
total 28K
-rw-r--r-- 1 wangyubin wangyubin  104 Sep 23 20:43 Makefile
-rw-r--r-- 1 wangyubin wangyubin  17K Sep 23 20:44 makefile.org   &lt;-- 这个文件不用管
drwxr-xr-x 2 wangyubin wangyubin 4.0K Sep 23 20:42 other
$ ll other/
total 4.0K
-rw-r--r-- 1 wangyubin wangyubin 71 Sep 23 16:11 Makefile

$ make
主 Makefile begin
make[1]: Entering directory `/path/to/test/makefile/other'
other makefile begin
other makefile end
make[1]: Leaving directory `/path/to/test/makefile/other'
主 Makefile end
</code></pre> 
  </blockquote> 
  <p>示例: (用export传递参数)</p> 
  <blockquote> 
   <pre><code class="prism language-bash"><span class="token comment"># Makefile 内容</span>
<span class="token function">export</span> VALUE1 :<span class="token operator">=</span> export.c    <span class="token operator">&lt;</span>-- 用了 export, 此变量能够传递到 ./other/Makefile 中
VALUE2 :<span class="token operator">=</span> no-export.c        <span class="token operator">&lt;</span>-- 此变量不能传递到 ./other/Makefile 中

all:
    @echo <span class="token string">"主 Makefile begin"</span>
    @cd ./other <span class="token operator">&amp;&amp;</span> <span class="token function">make</span>
    @echo <span class="token string">"主 Makefile end"</span>


<span class="token comment"># ./other/Makefile 内容</span>
other-all:
    @echo <span class="token string">"other makefile begin"</span>
    @echo <span class="token string">"VALUE1: "</span> <span class="token variable"><span class="token variable">$(</span>VALUE1<span class="token variable">)</span></span>
    @echo <span class="token string">"VALUE2: "</span> <span class="token variable"><span class="token variable">$(</span>VALUE2<span class="token variable">)</span></span>
    @echo <span class="token string">"other makefile end"</span>

<span class="token comment"># bash中执行 make</span>
$ <span class="token function">make</span>
主 Makefile begin
make<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Entering directory <span class="token variable"><span class="token variable">`</span>/path/to/test/makefile/other' other makefile begin VALUE1: export.c <span class="token operator">&lt;</span>-- VALUE1 传递成功 VALUE2: <span class="token operator">&lt;</span>-- VALUE2 传递失败 other makefile end make<span class="token punctuation">[</span>1<span class="token punctuation">]</span>: Leaving directory <span class="token variable">`</span></span>/path/to/test/makefile/other'
主 Makefile end
</code></pre> 
  </blockquote> 
  <p>*<strong>补充*</strong> export 语法格式如下:</p> 
  <ul> 
   <li>export variable = value</li> 
   <li>export variable := value</li> 
   <li>export variable += value</li> 
  </ul> 
  <h3><a id="32__705"></a><strong>3.2 定义命令包</strong></h3> 
  <p>命令包有点像是个函数, 将连续的相同的命令合成一条, 减少 Makefile 中的代码量, 便于以后维护.</p> 
  <p><strong>语法:</strong></p> 
  <blockquote> 
   <pre><code>define &lt;command-name&gt;
command
...
endef
</code></pre> 
  </blockquote> 
  <p><strong>示例:</strong></p> 
  <blockquote> 
   <pre><code class="prism language-bash"><span class="token comment"># Makefile 内容</span>
define run-hello-makefile
@echo -n <span class="token string">"Hello"</span>
@echo <span class="token string">" Makefile!"</span>
@echo <span class="token string">"这里可以执行多条 Shell 命令!"</span>
endef

all:
    <span class="token variable"><span class="token variable">$(</span>run-hello-makefile<span class="token variable">)</span></span>


<span class="token comment"># bash 中运行make</span>
$ <span class="token function">make</span>
Hello Makefile<span class="token operator">!</span>
这里可以执行多条 Shell 命令<span class="token operator">!</span>
</code></pre> 
  </blockquote> 
  <h3><a id="33__744"></a><strong>3.3 条件判断</strong></h3> 
  <p>条件判断的关键字主要有 <strong>ifeq ifneq ifdef ifndef</strong></p> 
  <p><strong>语法:</strong></p> 
  <blockquote> 
   <pre><code class="prism language-bash"><span class="token operator">&lt;</span>conditional-directive<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>text-if-true<span class="token operator">&gt;</span>
endif

<span class="token comment"># 或者</span>
<span class="token operator">&lt;</span>conditional-directive<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>text-if-true<span class="token operator">&gt;</span>
<span class="token keyword">else</span>
<span class="token operator">&lt;</span>text-if-false<span class="token operator">&gt;</span>
endif
</code></pre> 
  </blockquote> 
  <p><strong>示例:</strong> ifeq的例子, ifneq和ifeq的使用方法类似, 就是取反</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
ifeq ("aa", "bb")
    @echo "equal"
else
    @echo "not equal"
endif

# bash 中执行 make
$ make
not equal
</code></pre> 
  </blockquote> 
  <p><strong>示例:</strong> ifdef的例子, ifndef和ifdef的使用方法类似, 就是取反</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
SRCS := program.c

all:
ifdef SRCS
    @echo $(SRCS)
else
    @echo "no SRCS"
endif

# bash 中执行 make
$ make
program.c
</code></pre> 
  </blockquote> 
  <h3><a id="34_Makefile__806"></a><strong>3.4 Makefile 中的函数</strong></h3> 
  <p>Makefile 中自带了一些函数, 利用这些函数可以简化 Makefile 的编写.</p> 
  <p>函数调用语法如下:</p> 
  <blockquote> 
   <pre><code class="prism language-makefile">$(&lt;function&gt; &lt;arguments&gt;)
# 或者
${&lt;function&gt; &lt;arguments&gt;}
</code></pre> 
  </blockquote> 
  <ul> 
   <li> 是函数名</li> 
   <li> 是函数参数</li> 
  </ul> 
  <h4><a id="341__824"></a><strong>3.4.1 字符串函数</strong></h4> 
  <p><strong>字符串替换函数: $(subst ,,
    <text>
     )
    </text></strong></p> 
  <p>功能: 把字符串
   <text>
     中的 替换为 
   </text></p> 
  <p>返回: 替换过的字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(subst t,e,maktfilt)  &lt;-- 将t替换为e

# bash 中执行 make
$ make
makefile
</code></pre> 
  </blockquote> 
  <p><strong>模式字符串替换函数: $(patsubst ,,
    <text>
     )
    </text></strong></p> 
  <p>功能: 查找
   <text>
    中的单词(单词以"空格", “tab”, "换行"来分割) 是否符合 , 符合的话, 用 替代.
   </text></p> 
  <p>返回: 替换过的字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(patsubst %.c,%.o,programA.c programB.c)

# bash 中执行 make
$ make
programA.o programB.o
</code></pre> 
  </blockquote> 
  <p><strong>去空格函数: $(strip )</strong></p> 
  <p>功能: 去掉 字符串中开头和结尾的空字符</p> 
  <p>返回: 被去掉空格的字符串值</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
VAL := "       aa  bb  cc "

all:
    @echo "去除空格前: " $(VAL)
    @echo "去除空格后: " $(strip $(VAL))

# bash 中执行 make
$ make
去除空格前:         aa  bb  cc 
去除空格后:   aa bb cc
</code></pre> 
  </blockquote> 
  <p><strong>查找字符串函数: $(findstring ,)</strong></p> 
  <p>功能: 在字符串 中查找 字符串</p> 
  <p>返回: 如果找到, 返回 字符串, 否则返回空字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
VAL := "       aa  bb  cc "

all:
    @echo $(findstring aa,$(VAL))
    @echo $(findstring ab,$(VAL))

# bash 中执行 make
$ make
aa
</code></pre> 
  </blockquote> 
  <p><strong>过滤函数: $(filter &lt;pattern…&gt;,
    <text>
     )
    </text></strong></p> 
  <p>功能: 以 模式过滤字符串 
   <text>
    , 
    <em>保留</em> 符合模式 的单词, 可以有多个模式
   </text></p> 
  <p>返回: 符合模式 的字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(filter %.o %.a,program.c program.o program.a)


# bash 中执行 make
$ make
program.o program.a
</code></pre> 
  </blockquote> 
  <p><strong>反过滤函数: $(filter-out &lt;pattern…&gt;,
    <text>
     )
    </text></strong></p> 
  <p>功能: 以 模式过滤字符串 
   <text>
    , 
    <em>去除</em> 符合模式 的单词, 可以有多个模式
   </text></p> 
  <p>返回: 不符合模式 的字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(filter-out %.o %.a,program.c program.o program.a)

# bash 中执行 make
$ make
program.c
</code></pre> 
  </blockquote> 
  <p><strong>排序函数: $(sort )</strong></p> 
  <p>功能: 给字符串 中的单词排序 (升序)</p> 
  <p>返回: 排序后的字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(sort bac abc acb cab)

# bash 中执行 make
$ make
abc acb bac cab
</code></pre> 
  </blockquote> 
  <p><strong>取单词函数: $(word ,
    <text>
     )
    </text></strong></p> 
  <p>功能: 取字符串 
   <text>
     中的 第个单词 (n从1开始)
   </text></p> 
  <p>返回: 
   <text>
     中的第个单词, 如果 比 
    <text>
      中单词个数要大, 则返回空字符串
    </text>
   </text></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(word 1,aa bb cc dd)
    @echo $(word 5,aa bb cc dd)
    @echo $(word 4,aa bb cc dd)

# bash 中执行 make
$ make
aa

dd
</code></pre> 
  </blockquote> 
  <p><strong>取单词串函数: $(wordlist <s>,,
     <text>
      )
     </text></s></strong></p> 
  <p>功能: 从字符串
   <text>
    中取从
    <s>开始到的单词串. <s>和是一个数字.</s></s>
   </text></p> 
  <p>返回: 从<s>到的字符串</s></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(wordlist 1,3,aa bb cc dd)
    @echo $(word 5,6,aa bb cc dd)
    @echo $(word 2,5,aa bb cc dd)


# bash 中执行 make
$ make
aa bb cc

bb
</code></pre> 
  </blockquote> 
  <p><strong>单词个数统计函数: $(words 
    <text>
     )
    </text></strong></p> 
  <p>功能: 统计字符串 
   <text>
     中单词的个数
   </text></p> 
  <p>返回: 单词个数</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容

all:
    @echo $(words aa bb cc dd)
    @echo $(words aabbccdd)
    @echo $(words )

# bash 中执行 make
$ make
4
1
0
</code></pre> 
  </blockquote> 
  <p><strong>首单词函数: $(firstword 
    <text>
     )
    </text></strong></p> 
  <p>功能: 取字符串 
   <text>
     中的第一个单词
   </text></p> 
  <p>返回: 字符串 
   <text>
     中的第一个单词
   </text></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(firstword aa bb cc dd)
    @echo $(firstword aabbccdd)
    @echo $(firstword )

# bash 中执行 make
$ make
aa
aabbccdd
</code></pre> 
  </blockquote> 
  <h4><a id="342__1064"></a><strong>3.4.2 文件名函数</strong></h4> 
  <p><strong>取目录函数: $(dir &lt;names…&gt;)</strong></p> 
  <p>功能: 从文件名序列 中取出目录部分</p> 
  <p>返回: 文件名序列 中的目录部分</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(dir /home/a.c ./bb.c ../c.c d.c)


# bash 中执行 make
$ make
/home/ ./ ../ ./
</code></pre> 
  </blockquote> 
  <p><strong>取文件函数: $(notdir &lt;names…&gt;)</strong></p> 
  <p>功能: 从文件名序列 中取出非目录部分</p> 
  <p>返回: 文件名序列 中的非目录部分</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(notdir /home/a.c ./bb.c ../c.c d.c)

# bash 中执行 make
$ make
a.c bb.c c.c d.c
</code></pre> 
  </blockquote> 
  <p><strong>取后缀函数: $(suffix &lt;names…&gt;)</strong></p> 
  <p>功能: 从文件名序列 中取出各个文件名的后缀</p> 
  <p>返回: 文件名序列 中各个文件名的后缀, 没有后缀则返回空字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(suffix /home/a.c ./b.o ../c.a d)

# bash 中执行 make
$ make
.c .o .a
</code></pre> 
  </blockquote> 
  <p><strong>取前缀函数: $(basename &lt;names…&gt;)</strong></p> 
  <p>功能: 从文件名序列 中取出各个文件名的前缀</p> 
  <p>返回: 文件名序列 中各个文件名的前缀, 没有前缀则返回空字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(basename /home/a.c ./b.o ../c.a /home/.d .e)


# bash 中执行 make
$ make
/home/a ./b ../c /home/
</code></pre> 
  </blockquote> 
  <p><strong>加后缀函数: $(addsuffix ,&lt;names…&gt;)</strong></p> 
  <p>功能: 把后缀 加到 中的每个单词后面</p> 
  <p>返回: 加过后缀的文件名序列</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(addsuffix .c,/home/a b ./c.o ../d.c)


# bash 中执行 make
$ make
/home/a.c b.c ./c.o.c ../d.c.c
</code></pre> 
  </blockquote> 
  <p><strong>加前缀函数: $(addprefix ,&lt;names…&gt;)</strong></p> 
  <p>功能: 把前缀 加到 中的每个单词前面</p> 
  <p>返回: 加过前缀的文件名序列</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(addprefix test_,/home/a.c b.c ./d.c)

# bash 中执行 make
$ make
test_/home/a.c test_b.c test_./d.c
</code></pre> 
  </blockquote> 
  <p><strong>连接函数: $(join ,)</strong></p> 
  <p>功能: 中对应的单词加到 后面</p> 
  <p>返回: 连接后的字符串</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    @echo $(join a b c d,1 2 3 4)
    @echo $(join a b c d,1 2 3 4 5)
    @echo $(join a b c d e,1 2 3 4)

# bash 中执行 make
$ make
a1 b2 c3 d4
a1 b2 c3 d4 5
a1 b2 c3 d4 e
</code></pre> 
  </blockquote> 
  <h4><a id="343_foreach_1206"></a><strong>3.4.3 foreach</strong></h4> 
  <p><strong>语法:</strong></p> 
  <p>$(foreach <var>,,
    <text>
     )
    </text></var></p> 
  <p><strong>示例:</strong></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
targets := a b c d
objects := $(foreach i,$(targets),$(i).o)

all:
    @echo $(targets)
    @echo $(objects)

# bash 中执行 make
$ make
a b c d
a.o b.o c.o d.o
</code></pre> 
  </blockquote> 
  <h4><a id="344_if_1232"></a><strong>3.4.4 if</strong></h4> 
  <p>这里的if是个函数, 和前面的条件判断不一样, 前面的条件判断属于Makefile的关键字</p> 
  <p><strong>语法:</strong></p> 
  <p>$(if ,)</p> 
  <p>$(if ,,)</p> 
  <p><strong>示例:</strong></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
val := a
objects := $(if $(val),$(val).o,nothing)
no-objects := $(if $(no-val),$(val).o,nothing)

all:
    @echo $(objects)
    @echo $(no-objects)

# bash 中执行 make
$ make
a.o
nothing
</code></pre> 
  </blockquote> 
  <h4><a id="345_call___1265"></a><strong>3.4.5 call - 创建新的参数化函数</strong></h4> 
  <p><strong>语法:</strong></p> 
  <p>$(call ,,,…)</p> 
  <p><strong>示例:</strong></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
log = "====debug====" $(1) "====end===="

all:
    @echo $(call log,"正在 Make")

# bash 中执行 make
$ make
====debug==== 正在 Make ====end====
</code></pre> 
  </blockquote> 
  <h4><a id="346_origin___1288"></a><strong>3.4.6 origin - 判断变量的来源</strong></h4> 
  <p><strong>语法:</strong></p> 
  <p>$(origin )</p> 
  <p>返回值有如下类型:</p> 
  <table> 
   <thead> 
    <tr> 
     <th><strong>类型</strong></th> 
     <th><strong>含义</strong></th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>undefined</td> 
     <td> 没有定义过</td> 
    </tr> 
    <tr> 
     <td>default</td> 
     <td> 是个默认的定义, 比如 CC 变量</td> 
    </tr> 
    <tr> 
     <td>environment</td> 
     <td> 是个环境变量, 并且 make时没有使用 -e 参数</td> 
    </tr> 
    <tr> 
     <td>file</td> 
     <td> 定义在Makefile中</td> 
    </tr> 
    <tr> 
     <td>command line</td> 
     <td> 定义在命令行中</td> 
    </tr> 
    <tr> 
     <td>override</td> 
     <td> 被 override 重新定义过</td> 
    </tr> 
    <tr> 
     <td>automatic</td> 
     <td> 是自动化变量</td> 
    </tr> 
   </tbody> 
  </table>
  <p><strong>示例:</strong></p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
val-in-file := test-file
override val-override := test-override

all:
    @echo $(origin not-define)    # not-define 没有定义
    @echo $(origin CC)            # CC 是Makefile默认定义的变量
    @echo $(origin PATH)         # PATH 是 bash 环境变量
    @echo $(origin val-in-file)    # 此Makefile中定义的变量
    @echo $(origin val-in-cmd)    # 这个变量会加在 make 的参数中
    @echo $(origin val-override) # 此Makefile中定义的override变量
    @echo $(origin @)             # 自动变量, 具体前面的介绍

# bash 中执行 make
$ make val-in-cmd=val-cmd
undefined
default
environment
file
command line
override
automatic
</code></pre> 
  </blockquote> 
  <h4><a id="347_shell_1338"></a><strong>3.4.7 shell</strong></h4> 
  <p><strong>语法:</strong></p> 
  <p>$(shell )</p> 
  <p>它的作用就是执行一个shell命令, 并将shell命令的结果作为函数的返回.</p> 
  <p>作用和 <code>&lt;shell command&gt;</code> 一样, <strong>`</strong> 是反引号</p> 
  <h4><a id="348_make__1350"></a><strong>3.4.8 make 控制函数</strong></h4> 
  <p><strong>产生一个致命错误: $(error &lt;text …&gt;)</strong></p> 
  <p>功能: 输出错误信息, 停止Makefile的运行</p> 
  <blockquote> 
   <pre><code class="prism language-makefile"># Makefile 内容
all:
    $(error there is an error!)
    @echo "这里不会执行!"

# bash 中执行 make
$ make
Makefile:2: *** there is an error!.  Stop.
</code></pre> 
  </blockquote> 
  <p><strong>输出警告: $(warning &lt;text …&gt;)</strong></p> 
  <p>功能: 输出警告信息, Makefile继续运行</p> 
  <p>按 Ctrl+C 复制代码</p> 
  <p>按 Ctrl+C 复制代码</p> 
  <h3><a id="35_MakefileGNU_1380"></a><strong>3.5 Makefile中一些GNU约定俗成的伪目标</strong></h3> 
  <p>如果有过在Linux上, 从源码安装软件的经历的话, 就会对 make clean, make install 比较熟悉.</p> 
  <p>像 clean, install 这些伪目标, 广为人知, 不用解释就大家知道是什么意思了.</p> 
  <p>下面列举一些常用的伪目标, 如果在自己项目的Makefile合理使用这些伪目标的话, 可以让我们自己的Makefile看起来更专业, 呵呵 😃</p> 
  <blockquote> 
   <table> 
    <thead> 
     <tr> 
      <th><strong>伪目标</strong></th> 
      <th><strong>含义</strong></th> 
     </tr> 
    </thead> 
    <tbody> 
     <tr> 
      <td>all</td> 
      <td>所有目标的目标，其功能一般是编译所有的目标</td> 
     </tr> 
     <tr> 
      <td>clean</td> 
      <td>删除所有被make创建的文件</td> 
     </tr> 
     <tr> 
      <td>install</td> 
      <td>安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去</td> 
     </tr> 
     <tr> 
      <td>print</td> 
      <td>列出改变过的源文件</td> 
     </tr> 
     <tr> 
      <td>tar</td> 
      <td>把源程序打包备份. 也就是一个tar文件</td> 
     </tr> 
     <tr> 
      <td>dist</td> 
      <td>创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件</td> 
     </tr> 
     <tr> 
      <td>TAGS</td> 
      <td>更新所有的目标, 以备完整地重编译使用</td> 
     </tr> 
     <tr> 
      <td>check 或 test</td> 
      <td>一般用来测试makefile的流程</td> 
     </tr> 
    </tbody> 
   </table>
  </blockquote> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
