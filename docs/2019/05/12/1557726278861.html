<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>为什么前后端分离了，你比从前更痛苦？ « NotBeCN</title>
  <meta name="description" content="         你有没有遇到过：      前端代码刚写完，后端的接口又变了。    接口文档永远都是不对的。    测试工作永远只能临近上线才能开始。     为什么前后端分离了，你比从前更痛苦？   前后端分离早已经不是新闻，当真正分离之后确遇到了更多问题。要想解决现在的痛，就要知道痛的原因：   为什么接...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726278861.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">为什么前后端分离了，你比从前更痛苦？</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>你有没有遇到过：</p> 
  <ul>
   <li>前端代码刚写完，后端的接口又变了。</li> 
   <li>接口文档永远都是不对的。</li> 
   <li>测试工作永远只能临近上线才能开始。</li> 
  </ul>
  <p>为什么前后端分离了，你比从前更痛苦？</p> 
  <p>前后端分离早已经不是新闻，当真正分离之后确遇到了更多问题。要想解决现在的痛，就要知道痛的原因：</p> 
  <p>为什么接口会频繁变动？</p> 
  <p><strong>设计之初没有想好。</strong>&nbsp;这需要提高需求的理解能力和接口设计能力。</p> 
  <p><strong>变动的成本较低。</strong></p> 
  <p>德国有句谚语：“朝汤里吐口水。” 只有这样，才能让人们放弃那碗汤，停止不合理的行为。前后端同学坐在一起工作的时候效率会有提升，当后端同学接口变化时，只需要口头上通知一下即可，我们没有文档，我们很敏捷啊。没错，我们需要承认这样配合开发的效率会很高，但是频繁的变动会导致不断返工，造成了另一种浪费，这种浪费是可以被减少，甚至是被消除的。</p> 
  <p>为什么接口文档永远都是不对的？</p> 
  <p>接口文档在定接口时起到一定作用，写完接口就没有用了。后面接口的频繁变化，文档必定会永远落后于实际接口，维护文档的带来了一定的成本却没能带来价值。除非对外提供的接口，否则文档谁来看呢？没人看，用处又在哪？</p> 
  <p>有些公司干脆丢掉接口文档，说我们要拥抱敏捷。</p> 
  <p>所以接口文档落后的原因在于<strong>没有给我们带来价值</strong>。</p> 
  <p>为什么测试工作永远只能临近上线才能开始？</p> 
  <p>一个需求，后端开发 4 天，前端开发 4 天，联调 4 天，留给测试同学只有2天时间甚至更少，测不完只能带 bug 上线。</p> 
  <p><img alt="为什么前后端分离了，你比从前更痛苦？" class="has" src="http://p1.pstatp.com/large/pgc-image/1539738464350d77a211567"></p> 
  <blockquote> 
   <p>如果还在IT编程的世界里迷茫，不知道自己的未来规划，学习没有动力，东也学一下，西也学习一下，那你可以加入web前端学习交流群：539738200,&nbsp;里面有大神一起交流并走出迷茫。新手可进群免费领取学习资料，分享一些学习的方法和需要注意的小细节，每晚八点也会准时的讲一些前端的小案例项目。</p> 
  </blockquote> 
  <p>在开发阶段测试同学无法介入，接口在变，前端也在变，&nbsp;<strong>“提测”</strong>&nbsp;之前只能喝茶，“提测” 之后又忙的要命。</p> 
  <p>自动化？想都别想，空有一身好本领，在 “拥抱变化” 之后只能手工测试。偶尔还要拉上前台美眉客串一下测试小妹。手工测试枯燥乏味，乏味的工作就容易出错，而且还不能快速重复，无法对测试过的功能快速回归。</p> 
  <p>怎么破？</p> 
  <p>解决以上问题要<strong>让接口文档发挥价值，提高变动接口的成本，测试尽早介入。</strong></p> 
  <p>接口文档发挥出价值，就要赋予契约的意义，就如同签字画押谁也不许变，来约束我们只认契约不认人。</p> 
  <p>契约应该由前端同学来驱动，前后端共同协商。由于前端同学与 UX 接触比较紧密，更了解页面所需的数据以及整体的 User Journey，前端同学驱动会更加合理。</p> 
  <p>契约敲定之后要帮助我们生成 Mock Server（后面我们会介绍一个工具），前后端同学就要依照契约各自开发。Mock Server 可暂时替代后台服务，帮组前端开发，同时，测试同学也可以依照契约文档来编写测试脚本，使用 Mock Server 进行脚本验证。</p> 
  <p><img alt="为什么前后端分离了，你比从前更痛苦？" class="has" src="http://p1.pstatp.com/large/pgc-image/1539738464369539128190d"></p> 
  <p>&nbsp;</p> 
  <p>当后端接口发生变化除了口头通知以外必须修改契约，前端同学和测试同学才能各自修改。如此一来修改契约的成本变高，人们在定契约时则会更加慎重，也会促使我们提高接口的设计能力。</p> 
  <p>看到图中没有&nbsp;<strong>“联调”</strong>&nbsp;的环节，并不是画错了，而是 “联调“ 不再是一项工作，在部署后只需要更改代理的配置即可。甚至使用现代前端框架（如，Vue 或者 React）只要在开发时配置一下，之后都不需要调整任何代码。</p> 
  <p><strong>“提测”</strong>&nbsp;呢？测试一直都在进行，也就不再有一个 ”提测“ 的环节，无论前后端任意一方完成开发，测试同学都可以进行测试。</p> 
  <p>理论终于扯完了，说起来容易做起来难啊，需要工具来帮助我们。接口描述的工具有很多，比较知名的 Swagger 和 Raml，我个人更倾向于 Raml 。</p> 
  <p><img alt="为什么前后端分离了，你比从前更痛苦？" class="has" src="http://p1.pstatp.com/large/pgc-image/1539738464426f0cdbe078c"></p> 
  <p>描述工具生成文档还不够，还要生成 Mock Server，如果描述工具和 Mock Server 是分离又带来了额外的工作，好在有她——raml-mocker。</p> 
  <p>raml-mocker</p> 
  <p>raml-mocker 是一个基于 Raml 使用 Nodejs 开发的 Mock Server 工具，使用 Raml 描述接口中设置 response 的 example 指令即可，raml-mocker 会解析 Raml 文件，并启动一个 Mock Server，将 example 的内容返回给浏览器。</p> 
  <p>开始</p> 
  <p>初始化项目</p> 
  <blockquote> 
   <pre>
git clone https://github.com/xbl/raml-mocker-starter.git raml-api
cd raml-api
git remote rm origin
</pre> 
  </blockquote> 
  <p>安装</p> 
  <blockquote> 
   <pre>
yarn
# or
npm install
</pre> 
  </blockquote> 
  <p>启动 mock server</p> 
  <blockquote> 
   <pre>
yarn start
# or
npm start
</pre> 
  </blockquote> 
  <p>测试</p> 
  <blockquote> 
   <pre>
curl -i http://localhost:3000/api/v1/users/1/books/
# or
curl -i http://localhost:3000/api/v1/users/1/books/1
</pre> 
  </blockquote> 
  <p>生成 API 可视化文档</p> 
  <blockquote> 
   <pre>
yarn run build
# or
npm run build
</pre> 
  </blockquote> 
  <p>此功能使用了raml2html。</p> 
  <p>配置 .raml-config.json</p> 
  <blockquote> 
   <pre>
{
 "controller": "./controller",
 "raml": "./raml",
 "main": "api.raml",
 "port": 3000,
 "plugins": []
}
</pre> 
  </blockquote> 
  <ul>
   <li>controller: controller 目录路径，在高级篇中会有更详细说明</li> 
   <li>raml: raml 文件目录</li> 
   <li>main: raml 目录下的入口文件</li> 
   <li>port: mock server 服务端口号</li> 
   <li>plugins: 插件</li> 
  </ul>
  <p>入门篇：Mock Server</p> 
  <p>raml-mocker 只需要在response 添加 example:</p> 
  <blockquote> 
   <pre>
/books:
 /:id:
 post:
 body:
 application/json:
 type: abc
 responses:
 200:
 body:
 application/json:
 type: song
 # 返回的 Mock 数据
 example: !include ./books_200.json
</pre> 
   <p>books_200.json</p> 
   <pre>
{
 "code": 200,
 "data": [
 {
 "id": 1,
 "title": "books title",
 "description": "books desccription1"
 },
 {
 "id": 2,
 "title": "books title",
 "description": "books desccription2"
 }
 ]
}
</pre> 
  </blockquote> 
  <p>通过 curl 请求：</p> 
  <pre>
curl -i http://localhost:3000/api/v1/users/1/books
</pre> 
  <p>就会得到 example 的数据，唯一不足是无法根据参数动态返回不同数据。别急，请往下看。</p> 
  <p>高级篇：动态 Server</p> 
  <p>如果静态的 Mock 数据不能满足你的需求，Raml-mocker 还提供了动态的功能。</p> 
  <p>在 raml 文档中添加 (controller) 指令，即可添加动态的 Server，如：</p> 
  <blockquote> 
   <pre>
/books:
 type:
 resourceList:
 get:
 description: 获取用户的书籍
 (controller): user#getBook
 responses:
 200:
 body:
 type: song[]
 example: !include ./books_200.json
</pre> 
  </blockquote> 
  <p>在文档中 (controller) 表示 controller 目录下 user.js 中 getBook 函数。</p> 
  <blockquote> 
   <p>controller/user.js</p> 
   <pre>
exports.getBook = (req, res, webApi) =&gt; {
 console.log(webApi);
 res.send('Hello World!');
}
</pre> 
  </blockquote> 
  <p>Raml-mocker 是在 expressjs 基础上进行开发，req、res 可以参考 express 文档。</p> 
  <p>webApi 会返回文档中的配置：</p> 
  <blockquote> 
   <p>{</p> 
   <p>"absoluteUri": "/api/:version/users/:user_id/books",</p> 
   <p>"method": "get",</p> 
   <p>"controller": "user#getBook",</p> 
   <p>"responses": [</p> 
   <p>{</p> 
   <p>"code": "200",</p> 
   <p>"body": "... example ...",</p> 
   <p>"mimeType": "application/json"</p> 
   <p>}</p> 
   <p>]</p> 
   <p>}</p> 
  </blockquote> 
  <p>如此，raml-mocker 提供了更多可扩展空间，我们甚至可以在 controller 中实现一定的逻辑。</p> 
  <p>插件</p> 
  <p>Raml-mocker 提供了插件机制，允许我们在不使用 controller 指令的时候对 response 的内容进行处理，例如使用 Mockjs。</p> 
  <blockquote> 
   <p>.raml-config.json</p> 
   <p>{</p> 
   <p>"controller": "./controller",</p> 
   <p>"raml": "./raml",</p> 
   <p>"main": "api.raml",</p> 
   <p>"port": 3000,</p> 
   <p>"plugins": ["./plugins/mock.js"]</p> 
   <p>}</p> 
   <p>./plugins/mock.js</p> 
   <pre>
var { mock } = require('mockjs');
module.exports = (body) =&gt; {
 try {
 return mock(JSON.parse(body));
 } catch(e) {}
 return body;
}
</pre> 
  </blockquote> 
  <p>Enjoy it！</p> 
  <p>总结</p> 
  <p>前后端分离可以让我们的职责更清晰，打破前端发挥的局限，工作解耦之后能更好的提高开发效率。然而因为没有规划好开发流程，导致了我们没有发挥出其应有的价值，造成了更多的浪费。</p> 
  <p>raml-mocker 能够帮助我们在工具上解决一定的问题，更重要的是持续改进的思想，只有团队的思想是统一的才有可能达到快速交付。</p> 
  <h1><strong>最后，想学习前端的小伙伴们！</strong></h1> 
  <blockquote> 
   <p>如果还在IT编程的世界里迷茫，不知道自己的未来规划，学习没有动力，东也学一下，西也学习一下，那你可以加入web前端学习交流群：539738200,&nbsp;里面有大神一起交流并走出迷茫。新手可进群免费领取学习资料，分享一些学习的方法和需要注意的小细节，每晚八点也会准时的讲一些前端的小案例项目。</p> 
  </blockquote> 
  <p>点击：<a href="https://jq.qq.com/?_wv=1027&amp;k=5NaoWbN" rel="nofollow">加入群</a></p> 
  <p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181218160829117"></p> 
  <p><strong><strong><strong>如果想看到更加系统的文章和学习方法经验可以关注的微信号：‘web前端技术圈’或者‘webxh6’关注后回复‘2019’可以领取一套完整的学习视频</strong></strong></strong></p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
