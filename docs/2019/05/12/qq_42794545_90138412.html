<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>历届试题 车轮轴迹 « NotBeCN</title>
  <meta name="description" content="             /* 历届试题 车轮轴迹        锦囊1     计算几何。       问题描述 　　栋栋每天骑自行车回家需要经过一条狭长的林荫道。道路由于年久失修，变得非常不平整。虽然栋栋每次都很颠簸，但他仍把骑车经过林荫道当成一种乐趣。 　　由于颠簸，栋栋骑车回家的路径是一条上下起伏的曲线，...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/qq_42794545_90138412.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">历届试题 车轮轴迹</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <blockquote> 
   <p>/*<br> 历届试题 车轮轴迹</p> 
   <ul>
    <li>锦囊1</li> 
    <li>计算几何。</li> 
   </ul>
   <p>问题描述<br> 　　栋栋每天骑自行车回家需要经过一条狭长的林荫道。道路由于年久失修，变得非常不平整。虽然栋栋每次都很颠簸，但他仍把骑车经过林荫道当成一种乐趣。<br> 　　由于颠簸，栋栋骑车回家的路径是一条上下起伏的曲线，栋栋想知道，他回家的这条曲线的长度究竟是多长呢？更准确的，栋栋想知道从林荫道的起点到林荫道的终点，他的车前轮的轴（圆心）经过的路径的长度。<br> 　　栋栋对路面进行了测量。他把道路简化成一条条长短不等的直线段，这些直线段首尾相连，且位于同一平面内。并在该平面内建立了一个直角坐标系，把所有线段的端点坐标都计算好。<br> 　　假设栋栋的自行车在行进的过程中前轮一直是贴着路面前进的。<br> &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; 图片请百度</p> 
   <p>　　上图给出了一个简单的路面的例子，其中蓝色实线为路面，红色虚线为车轮轴经过的路径。在这个例子中，栋栋的前轮轴从A点出发，水平走到B点，然后绕着地面的F点到C点（绕出一个圆弧），再沿直线下坡到D点，最后水平走到E点，在这个图中地面的坐标依次为：(0, 0), (2, 0), (4, -1), (6, -1)，前轮半径为1.50，前轮轴前进的距离依次为：<br> 　　AB=2.0000；弧长BC=0.6955；CD=1.8820；DE=1.6459。<br> 　　总长度为6.2233。</p> 
   <p>　　下图给出了一个较为复杂的路面的例子，在这个例子中，车轮在第一个下坡还没下完时（D点）就开始上坡了，之后在坡的顶点要从E绕一个较大的圆弧到F点。这个图中前轮的半径为1，每一段的长度依次为：<br> 　　AB=3.0000；弧长BC=0.9828；CD=1.1913；DE=2.6848；弧长EF=2.6224； FG=2.4415；GH=2.2792。<br> 　　总长度为15.2021。<br> &nbsp; &nbsp;&nbsp;<br> &nbsp; &nbsp; 图片请百度<br> &nbsp; &nbsp;&nbsp;<br> 　　现在给出了车轮的半径和路面的描述，请求出车轮轴轨迹的总长度。<br> 输入格式<br> 　　输入的第一行包含一个整数n和一个实数r，用一个空格分隔，表示描述路面的坐标点数和车轮的半径。<br> 　　接下来n行，每个包含两个实数，其中第i行的两个实数x[i], y[i]表示描述路面的第i个点的坐标。<br> 　　路面定义为所有路面坐标点顺次连接起来的折线。给定的路面的一定满足以下性质：</p> 
   <p>　　*第一个坐标点一定是(0, 0)；<br> 　　*第一个点和第二个点的纵坐标相同；<br> 　　*倒数第一个点和倒数第二个点的纵坐标相同；<br> 　　*第一个点和第二个点的距离不少于车轮半径；<br> 　　*倒数第一个点和倒数第二个点的的距离不少于车轮半径；<br> 　　*后一个坐标点的横坐标大于前一个坐标点的横坐标，即对于所有的i，x[i+1]&gt;x[i]。<br> 输出格式<br> 　　输出一个实数，四舍五入保留两个小数，表示车轮轴经过的总长度。<br> 　　你的结果必须和参考答案一模一样才能得分。数据保证答案精确值的小数点后第三位不是4或5。<br> 样例输入<br> 4 1.50<br> 0.00 0.00<br> 2.00 0.00<br> 4.00 -1.00<br> 6.00 -1.00<br> 样例输出<br> 6.22<br> 样例说明<br> 　　这个样例对应第一个图。<br> 样例输入<br> 6 1.00<br> 0.00 0.00<br> 3.00 0.00<br> 5.00 -3.00<br> 6.00 2.00<br> 7.00 -1.00<br> 10.00 -1.00<br> 样例输出<br> 15.20<br> 样例说明<br> 　　这个样例对应第二个图<br> 数据规模和约定<br> 　　对于20%的数据，n=4；<br> 　　对于40%的数据，n≤10；<br> 　　对于100%的数据，4≤n≤100，0.5≤r≤20.0，x[i] ≤2000.0，-2000.0≤y[i] ≤2000.0。</p> 
   <p>*/</p> 
   <p>&nbsp;</p> 
  </blockquote> 
  <p><strong>参考链接：<a href="http://www.cnblogs.com/Ambrose/p/5100750.html" rel="nofollow">http://www.cnblogs.com/Ambrose/p/5100750.html</a></strong>&nbsp;</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
 
 
using namespace std;
 
const int MAXN = 10000;
const double PI = atan(1.0) * 4;
const double EPS = 1e-10;
 
class Point {
public:
    double x, y;
    Point() {}
    Point(double x, double y) : x(x), y(y) {}
    Point operator - (const Point &amp;r) const { return Point(x-r.x, y-r.y); }
    Point operator + (const Point &amp;r) const { return Point(x+r.x, y+r.y); }
    Point &amp;operator += (const Point &amp;r) { x += r.x; y += r.y; return *this; }
    Point &amp;operator *= (double m) { x *= m; y *= m; return *this; }
    Point pOfRotate(double angle) const {
        double cosA = cos(angle);
        double sinA = sin(angle);
        return Point(cosA*x-sinA*y, sinA*x+cosA*y);
    }
    Point pOfRotate90() const { return Point(-y, x); }
    double length() const { return sqrt(x*x+y*y); }
    Point pOfNormal() const {
        double len = length();
        return Point(x/len, y/len);
    }
    double angle() const { return atan2(y, x); }
};
 
ostream &amp; operator &lt;&lt;(ostream &amp;os, const Point &amp;v)
{
    os &lt;&lt; "(" &lt;&lt; v.x &lt;&lt; "," &lt;&lt; v.y &lt;&lt; ")";
    return os;
}
 
class Segment;
class Circle;
 
class Seg {
public:
    virtual double getLeft() const = 0;
    virtual double getRight() const = 0;
    virtual double getY(double x) const = 0;
    virtual double getLength(double x1, double x2) const = 0;
    virtual void intersect(Seg *r) const = 0;
    virtual void intersect(const Segment &amp;v) const = 0;
    virtual void intersect(const Circle &amp;v) const = 0;
    bool contains(double x) const { return x&gt;=getLeft() &amp;&amp; x&lt;=getRight(); }
    virtual void acceptPrint(ostream &amp;os) const = 0;
};
 
ostream &amp; operator &lt;&lt;(ostream &amp;os, const Seg &amp;v)
{
    v.acceptPrint(os);
    return os;
}
 
Point intersectRet[4];
int tIntersectRet;
 
class Segment : public Seg {
public:
    Point a, b;
    Segment &amp;moveLeft(double dis)
    {
        Point tmp = ((b-a).pOfRotate90().pOfNormal() *= dis);
        a += tmp;
        b += tmp;
        return *this;
    }
    virtual double getLeft() const { return a.x; }
    virtual double getRight() const { return b.x; }
    virtual double getY(double x) const {
        return (x-a.x)*(b.y-a.y)/(b.x-a.x)+a.y;
    }
    virtual double getLength(double x1, double x2) const {
        return (x2-x1) * (b-a).length() / (b.x-a.x);
    }
    virtual void intersect(Seg *r) const {
        r-&gt;intersect(*this);
    }
    virtual void intersect(const Segment &amp;v) const {
        tIntersectRet = 0;
        double ang = (b-a).angle();
        Point c = (v.a-a).pOfRotate(-ang);
        Point d = (v.b-a).pOfRotate(-ang);
        // Bug
        //double di = b.length();
        double di = (b-a).length();
        if (!((c.y&gt;0&amp;&amp;d.y&lt;0) || (c.y&lt;0&amp;&amp;d.y&gt;0)))
            return ;
        double x = (d.x-c.x) * (-c.y) / (d.y-c.y) + c.x;
        if (x&lt;0 || x&gt;di)
            return ;
        Point ret = Point(x,0).pOfRotate(ang)+a;
        intersectRet[tIntersectRet++] = ret;
    }
    virtual void intersect(const Circle &amp;v) const;
    virtual void acceptPrint(ostream &amp;os) const {
        os &lt;&lt; a &lt;&lt; "-" &lt;&lt; b;
    }
};
 
class Circle : public Seg {
public:
    Point c;
    double r;
    virtual double getLeft() const { return c.x - r; }
    virtual double getRight() const { return c.x + r; }
    virtual double getY(double x) const {
        double y2 = r * r - (c.x - x) * (c.x - x);
        if (y2&lt;0) y2 = 0;
        return c.y + sqrt(y2);
    }
    virtual double getLength(double x1, double x2) const {
        x1 -= c.x; x2 -= c.x;
        double a1 = Point(x1, sqrt(abs(r*r-x1*x1))).angle(), a2 = Point(x2, sqrt(abs(r*r-x2*x2))).angle();
        return (a1-a2) * r;
    }
    virtual void intersect(Seg *r) const {
        r-&gt;intersect(*this);
    }
    virtual void intersect(const Segment &amp;v) const {
        tIntersectRet = 0;
        Point a = v.a - c;
        Point b = v.b - c;
        double ang = (b-a).angle();
        Point nA = a.pOfRotate(-ang);
        Point nB = b.pOfRotate(-ang);
        double y = nA.y;
        if (y&gt;r || y&lt;-r)
            return ;
        double x = sqrt(r*r - y*y);
        if (x&gt;=nA.x &amp;&amp; x&lt;=nB.x)
            intersectRet[tIntersectRet++] = Point(x, y).pOfRotate(ang) + c;
        if (-x&gt;=nA.x &amp;&amp; -x&lt;=nB.x)
            intersectRet[tIntersectRet++] = Point(-x, y).pOfRotate(ang) + c;
    }
    virtual void intersect(const Circle &amp;v) const {
        tIntersectRet = 0;
        Point p = v.c - c;
        double d = p.length();
        if (d &gt; r + v.r || d==0)
            return ;
        double x = (r*r - v.r*v.r + d*d) / (2*d);
        if (x &lt;= r)
        {
            double y = sqrt(abs(r*r - x*x));
            double ang = p.angle();
            intersectRet[tIntersectRet++] = Point(x,y).pOfRotate(ang) + c;
            intersectRet[tIntersectRet++] = Point(x,-y).pOfRotate(ang) + c;
        }
    }
    virtual void acceptPrint(ostream &amp;os) const {
        os &lt;&lt; c &lt;&lt; "," &lt;&lt; r;
    }
};
 
void Segment::intersect(const Circle &amp;v) const {
    v.intersect(*this);
}
 
int n;
Point inps[MAXN];
vector&lt;Seg *&gt; segs;
vector&lt;double&gt; spes;
double radius = 1;
 
void input()
{
    scanf("%d%lf", &amp;n, &amp;radius);
    for (int i = 0; i &lt; n; ++i)
    {
        double x, y;
        scanf("%lf%lf", &amp;x, &amp;y);
        inps[i] = Point(x, y);
    }
}
 
void process()
{
    segs.clear();
    spes.clear();
    for (int i = 1; i + 1 &lt; n; ++i)
    {
        Circle *tmp = new Circle;
        tmp-&gt;c = inps[i];
        tmp-&gt;r = radius;
        segs.push_back(tmp);
    }
    for (int i = 0; i + 1 &lt; n; ++i)
    {
        Segment *tmp = new Segment;
        tmp-&gt;a = inps[i];
        tmp-&gt;b = inps[i+1];
        tmp-&gt;moveLeft(radius);
        segs.push_back(tmp);
    }
    for (int i = 0; i &lt; (int)segs.size(); ++i)
    {
        spes.push_back(segs[i]-&gt;getLeft());
        spes.push_back(segs[i]-&gt;getRight());
    }
    for (int i = 0; i &lt; (int)segs.size(); ++i)
    {
        for (int j = i+1; j &lt; (int)segs.size(); ++j)
        {
            segs[i]-&gt;intersect(segs[j]);
            if (tIntersectRet &gt; 0)
            {
                for (int id = 0; id &lt; tIntersectRet; ++id)
                {
                    //cout &lt;&lt; *segs[i] &lt;&lt; " " &lt;&lt; *segs[j] &lt;&lt; " : " &lt;&lt; intersectRet[id] &lt;&lt; endl;
                    spes.push_back(intersectRet[id].x);
                }
            }
        }
    }
    sort(spes.begin(), spes.end());
    double pre = spes[0];
    const double NONE = 1e30;
    double preEnd = NONE;
    double totalLen = 0;
    for (int i = 1; i &lt; (int)spes.size(); ++i)
    {
        if (spes[i]-pre &lt; EPS)
            continue;
        double cur = (pre+spes[i]) / 2;
        //cout &lt;&lt; "Processing " &lt;&lt; cur &lt;&lt; "  from " &lt;&lt; pre &lt;&lt; " to " &lt;&lt; spes[i] &lt;&lt; endl;
        if (cur&gt;=inps[0].x &amp;&amp; cur&lt;=inps[n-1].x)
        {
            double MY = -NONE;
            int who;
            for (int j = 0; j &lt; (int)segs.size(); ++j)
            {
                if (!segs[j]-&gt;contains(cur))
                    continue;
                double y = segs[j]-&gt;getY(cur);
                if (y &gt; MY)
                {
                    MY = y;
                    who = j;
                }
            }
            if (preEnd != NONE)
            {
                double LY = segs[who]-&gt;getY(pre);
                //cout &lt;&lt; "Drop info " &lt;&lt; *segs[who] &lt;&lt; " " &lt;&lt; "[" &lt;&lt; pre &lt;&lt; "]" &lt;&lt; endl;
                totalLen += abs(preEnd-LY);
                //cout &lt;&lt; "Pre drop = " &lt;&lt; abs(preEnd-LY) &lt;&lt; "  from " &lt;&lt; preEnd &lt;&lt; " to " &lt;&lt; LY &lt;&lt; endl;
            }
            double len = segs[who]-&gt;getLength(pre, spes[i]);
            if (len &lt; 0)
                printf("Error!\n");
            //cout &lt;&lt; "Curlen = " &lt;&lt; len &lt;&lt; " from " &lt;&lt; pre &lt;&lt; " to " &lt;&lt; spes[i] &lt;&lt; endl;
            totalLen += len;
            preEnd = segs[who]-&gt;getY(spes[i]);
        }
        pre = spes[i];
    }
    printf("%0.2lf\n", totalLen);
    for (int i = 0; i &lt; (int)segs.size(); ++i)
        delete segs[i];
    segs.clear();
}
 
int main()
{
    input();
    process();
    return 0;
}</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
