<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>十分钟快速入门 Python，看完即会，不用收藏！ « NotBeCN</title>
  <meta name="description" content="                  本文以 Eric Matthes 的《Python编程：从入门到实践》为基础，以有一定其他语言经验的程序员视角，对书中内容提炼总结，化繁为简，将这本书的精髓融合成一篇10分钟能读完的文章。   读完本篇文章后，可对 Python 语言特性、编码风格有一定了解，并可写出简单的 P...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726346863.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">十分钟快速入门 Python，看完即会，不用收藏！</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>本文以 Eric Matthes 的《Python编程：从入门到实践》为基础，以有一定其他语言经验的程序员视角，对书中内容提炼总结，化繁为简，将这本书的精髓融合成一篇10分钟能读完的文章。</p> 
  <p>读完本篇文章后，可对 Python 语言特性、编码风格有一定了解，并可写出简单的 Python 程序。</p> 
  <blockquote> 
   <p><code>100</code>&nbsp;多位经验丰富的开发者参与，在 Github 上获得了近&nbsp;<code>1000</code>&nbsp;个&nbsp;<code>star</code>&nbsp;的开源项目想了解下吗？<br> 项目地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcachecats%2Fcoderiver" rel="nofollow">github.com/cachecats/c…</a></p> 
  </blockquote> 
  <h2><a id="_7"></a>一、安装与运行</h2> 
  <p>各个系统的 Python 安装教程请自行查阅资料，这里不再赘述。</p> 
  <p>检查 Python 版本，在命令行输入&nbsp;<code>python</code>&nbsp;即可，同时会进入命令行交互模式，可以在这里执行 python 命令。</p> 
  <p>如果电脑中安装了 python2.x 和 python3.x 两个版本，输入&nbsp;<code>python</code>&nbsp;运行的是 2.x 版本。想运行 3.x，则需输入&nbsp;<code>python3</code>。</p> 
  <p>在命令行输入&nbsp;<code>python</code>&nbsp;：</p> 
  <pre><code>Solo-mac:~ solo$ python
Python 2.7.10 (default, Aug 17 2018, 19:45:58)
[GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.0.42)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;

</code></pre> 
  <p>在命令行输入&nbsp;<code>python3</code>&nbsp;：</p> 
  <pre><code>Solo-mac:~ solo$ python3
Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 26 2018, 23:26:24)
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;

</code></pre> 
  <p>输入&nbsp;<code>exit()</code>&nbsp;即可退出命令行模式。</p> 
  <h3><a id="_python__39"></a>命令行运行 python 文件</h3> 
  <p>如果是写好了一个 python 文件，想通过命令行运行它，进入这个目录，在命令行输入&nbsp;<code>python 文件名.py</code>&nbsp;即可。</p> 
  <p>比如桌面上有个文件&nbsp;<code>hello.py</code>，内容是打印一句话：</p> 
  <pre><code>print("Hello, Python")

</code></pre> 
  <p>想运行它，先进入 Desktop 目录，再在命令行输入&nbsp;<code>python hello.py</code>&nbsp;就能运行：</p> 
  <pre><code>Solo-mac:Desktop solo$ python hello.py
Hello, Python

</code></pre> 
  <blockquote> 
   <p><strong>大家在学python的时候肯定会遇到很多难题，以及对于新技术的追求，这里推荐一下我们的Python学习扣qun：784758214，这里是python学习者聚集地！！同时，自己是一名高级python开发工程师，从基础的python脚本到web开发、爬虫、django、数据挖掘等，零基础到项目实战的资料都有整理。送给每一位python的小伙伴！每日分享一些学习的方法和需要注意的小细节</strong></p> 
  </blockquote> 
  <p><img src="https://upload-images.jianshu.io/upload_images/13090773-2d9795e33164f8d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> 
  <h2><a id="_62"></a>二、变量和简单数据类型</h2> 
  <h3><a id="21__64"></a>2.1 变量命名规则</h3> 
  <ul> 
   <li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打 头，例如，可将变量命名为message_1，但不能将其命名为1_message。</li> 
   <li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message 可行，但变量名greeting message会引发错误。</li> 
   <li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词， 如print。</li> 
   <li>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好。</li> 
   <li>慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。</li> 
  </ul> 
  <p>变量名应该是小写的，虽然没有强制规定，但是约定俗称的规则。</p> 
  <h3><a id="22__74"></a>2.2 字符串</h3> 
  <p>字符串就是一系列字符。在Python中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号，还可以同时使用。如：</p> 
  <pre><code>"This is a string." 
'This is also a string.'
"I love 'python'"

</code></pre> 
  <h4><a id="221__85"></a>2.2.1 字符串的简单运算</h4> 
  <p>下面介绍字符串的简单运算。</p> 
  <h5><a id="title_89"></a>title()</h5> 
  <p>title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。</p> 
  <pre><code>&gt;&gt;&gt; name = 'solo coder'
&gt;&gt;&gt; name.title()
'Solo Coder'

</code></pre> 
  <h5><a id="upperlower_100"></a>upper()、lower()</h5> 
  <p>将字符串改为全部大写或全部小写。</p> 
  <pre><code>&gt;&gt;&gt; name
'solo coder'
&gt;&gt;&gt; name.upper()
'SOLO CODER'
&gt;&gt;&gt; name.lower()
'solo coder'
&gt;&gt;&gt; name
'solo coder'

</code></pre> 
  <p>注意：title()、upper()、lower() 均不改变原字符串，只是输出了一个新的字符串。</p> 
  <h4><a id="222__118"></a>2.2.2 合并（拼接）字符串</h4> 
  <p>Python使用加号(+)来合并字符串。</p> 
  <pre><code>&gt;&gt;&gt; first = 'solo'
&gt;&gt;&gt; last = 'coder'
&gt;&gt;&gt; full = first + ' ' + last
&gt;&gt;&gt; full
'solo coder'

</code></pre> 
  <h4><a id="223__131"></a>2.2.3 使用制表符或换行符来添加空白</h4> 
  <p>在编程中，空白泛指任何非打印字符，如空格、制表符和换行符。</p> 
  <p>要在字符串中添加制表符，可使用字符组合&nbsp;<code>\t</code>，要在字符串中添加换行符，可使用字符组合&nbsp;<code>\n</code>&nbsp;。</p> 
  <pre><code>&gt;&gt;&gt; print('\tPython')
	Python
&gt;&gt;&gt; print('Hello,\nPython')
Hello,
Python

</code></pre> 
  <h4><a id="224__146"></a>2.2.4 删除空白</h4> 
  <p><code>rstrip()</code>&nbsp;删除右侧空白，<code>lstrip()</code>&nbsp;删除左侧空白，<code>strip()</code>&nbsp;删除两端空白。</p> 
  <pre><code>&gt;&gt;&gt; msg = ' Python '
&gt;&gt;&gt; msg
' Python '
&gt;&gt;&gt; msg.rstrip()
' Python'
&gt;&gt;&gt; msg.lstrip()
'Python '
&gt;&gt;&gt; msg.strip()
'Python'
&gt;&gt;&gt; msg
' Python '

</code></pre> 
  <p>注意执行完去空格命令后，再打印出 msg，还是原来的字符串，这说明&nbsp;<code>strip()</code>&nbsp;也不改变原来的字符串。</p> 
  <h4><a id="225_Python_2__print__167"></a>2.2.5 Python 2 中的 print 语句</h4> 
  <p>在Python 2中，print语句的语法稍有不同:</p> 
  <pre><code>&gt;&gt;&gt; python2.7
&gt;&gt;&gt; print "Hello Python 2.7 world!" 
Hello Python 2.7 world!

</code></pre> 
  <p>在Python 2中，无需将要打印的内容放在括号内。从技术上说，Python 3中的print是一个函数，因此括号必不可少。有些Python 2 print语句也包含括号，但其行为与Python 3中稍有不同。简单地说，在Python 2代码中，有些print语句包含括号，有些不包含。</p> 
  <h3><a id="23__180"></a>2.3 数字</h3> 
  <h4><a id="231__182"></a>2.3.1 整数</h4> 
  <p>在Python中，可对整数执行加(+)减(-)乘(*)除(/)运算。</p> 
  <pre><code>&gt;&gt;&gt; 2 + 3 
5
&gt;&gt;&gt; 3 - 2 
1
&gt;&gt;&gt; 2 * 3 
6
&gt;&gt;&gt; 3 / 2 
1.5

</code></pre> 
  <p>Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修 改运算次序，让Python按你指定的次序执行运算，如下所示:</p> 
  <pre><code>&gt;&gt;&gt; 2 + 3*4
14
&gt;&gt;&gt; (2 + 3) * 4 20

</code></pre> 
  <h4><a id="232__207"></a>2.3.2 浮点数</h4> 
  <p>Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样一个事实:小数点可出现在数字的任何位置。</p> 
  <p>从很大程度上说，使用浮点数时都无需考虑其行为。你只需输入要使用的数字，Python通常都会按你期望的方式处理它们:</p> 
  <pre><code>&gt;&gt;&gt; 0.1 + 0.1
0.2
&gt;&gt;&gt; 0.2 + 0.2 9 0.4
&gt;&gt;&gt;2 * 0.1
0.2
&gt;&gt;&gt;2 * 0.2
0.4

</code></pre> 
  <p>但需要注意的是，结果包含的小数位数可能是不确定的:</p> 
  <pre><code>&gt;&gt;&gt; 0.2 + 0.1 
0.30000000000000004 
&gt;&gt;&gt; 3 * 0.1 
0.30000000000000004

</code></pre> 
  <p>所有语言都存在这种问题，没有什么可担心的。Python会尽力找到一种方式，以尽可能精确地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。后面将会学习更多的处理方式。</p> 
  <h4><a id="233_str_236"></a>2.3.3 使用函数str()避免类型错误</h4> 
  <p>如果用数字跟字符串拼接，就会出现类型错误。为避免这个问题，可以使用&nbsp;<code>str()</code>&nbsp;将数字转换为字符串再进行操作。</p> 
  <pre><code>&gt;&gt;&gt; age = 18
&gt;&gt;&gt; print('my age is ' + age)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate str (not "int") to str
&gt;&gt;&gt; print('my age is ' + str(age))
my age is 18

</code></pre> 
  <h4><a id="234_Python_2__251"></a>2.3.4 Python 2 中的整数</h4> 
  <p>在Python 2中，将两个整数相除得到的结果稍有不同:</p> 
  <pre><code>&gt;&gt;&gt; python2.7 
&gt;&gt;&gt; 3 / 2
1

</code></pre> 
  <p>Python返回的结果为1，而不是1.5。在Python 2中，整数除法的结果只包含整数部分，小数部 分被删除。请注意，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。</p> 
  <p>在Python 2中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为 浮点数:</p> 
  <pre><code>&gt;&gt;&gt; 3 / 2
1
&gt;&gt;&gt; 3.0 / 2
1.5
&gt;&gt;&gt; 3 / 2.0 
1.5
&gt;&gt;&gt; 3.0 / 2.0 
1.5

</code></pre> 
  <p>从Python 3转而用Python 2或从Python 2转而用Python 3时，这种除法行为常常会令人迷惑。使用或编写同时使用浮点数和整数的代码时，一定要注意这种异常行为。</p> 
  <h4><a id="235__280"></a>2.3.5 注释</h4> 
  <p>在Python中，注释用井号(#)标识。井号后面的内容都会被Python解释器忽略。如</p> 
  <pre><code># 向大家问好
print("Hello Python people!")

</code></pre> 
  <h2><a id="_290"></a>三、列表</h2> 
  <p>列表由一系列按特定顺序排列的元素组成。</p> 
  <p>在Python中，用方括号([])来表示列表，并用逗号来分隔其中的元素。</p> 
  <pre><code>&gt;&gt;&gt; list = []
&gt;&gt;&gt; list.append('haha')
&gt;&gt;&gt; list.append('heihei')
&gt;&gt;&gt; list.append('hehe')
&gt;&gt;&gt; list
['haha', 'heihei', 'hehe']
&gt;&gt;&gt; list[0]
'haha'

</code></pre> 
  <blockquote> 
   <p>获取最后一个元素可以用 -1，如 list[-1] 是获取最后一个元素，list[-2] 是获取倒数第二个元素。</p> 
  </blockquote> 
  <h3><a id="31__310"></a>3.1 列表的增删改查</h3> 
  <h4><a id="311__312"></a>3.1.1 修改元素</h4> 
  <p>修改元素直接用索引修改</p> 
  <pre><code>&gt;&gt;&gt; list[0] = 'nihao'
&gt;&gt;&gt; list
['nihao', 'heihei', 'hehe']

</code></pre> 
  <h4><a id="312__323"></a>3.1.2 添加元素</h4> 
  <p>可以在末尾添加，也可以在任意位置插入。</p> 
  <p><strong>在末尾添加：append</strong></p> 
  <pre><code>&gt;&gt;&gt; list.append('wa')
&gt;&gt;&gt; list
['nihao', 'heihei', 'hehe', 'wa']

</code></pre> 
  <p><strong>插入：insert</strong></p> 
  <pre><code>&gt;&gt;&gt; list.insert(1, 'hello')
&gt;&gt;&gt; list
['nihao', 'hello', 'heihei', 'hehe', 'wa']

</code></pre> 
  <h4><a id="313__345"></a>3.1.3 删除元素</h4> 
  <p>删除有三种方式：</p> 
  <ul> 
   <li>del：按索引删除</li> 
   <li>pop()：删除列表最后一个元素并返回最后一个元素的值。也可以传索引删除任意位置的值。</li> 
   <li>remove()：按值删除</li> 
  </ul> 
  <pre><code>&gt;&gt;&gt; list
['nihao', 'hello', 'heihei', 'hehe', 'wa']
&gt;&gt;&gt; del list[1]
&gt;&gt;&gt; list
['nihao', 'heihei', 'hehe', 'wa']
&gt;&gt;&gt; list.pop()
'wa'
&gt;&gt;&gt; list.remove('hehe')
&gt;&gt;&gt; list
['nihao', 'heihei']

</code></pre> 
  <p>给&nbsp;<code>pop()</code>&nbsp;传索引删除其他位置的值</p> 
  <pre><code>&gt;&gt;&gt; list
['nihao', 'heihei']
&gt;&gt;&gt; list.pop(0)
'nihao'
&gt;&gt;&gt; list
['heihei']

</code></pre> 
  <blockquote> 
   <p>注意：</p> 
   <p>方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。</p> 
   <p>如果你不确定该使用del语句还是pop()方法，下面是一个简单的判断标准:如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句;如果你要在删除元素后还能继续使用它，就使用方法pop()。</p> 
  </blockquote> 
  <h3><a id="32__385"></a>3.2 组织列表</h3> 
  <p>本节将介绍列表的排序、反转、计算长度等操作。</p> 
  <p>列表的排序主要有两种方式：</p> 
  <ul> 
   <li>使用方法sort()对列表进行永久性排序</li> 
   <li>使用函数sorted()对列表进行临时排序</li> 
  </ul> 
  <h4><a id="321_sort_394"></a>3.2.1 使用方法sort()对列表进行永久性排序</h4> 
  <p>使用&nbsp;<code>sort()</code>&nbsp;方法将改变原列表。如果要反转排序，只需向sort()方法传递参数 reverse=True。</p> 
  <pre><code>&gt;&gt;&gt; list
['zhangsan', 'lisi', 'bob', 'alex']
&gt;&gt;&gt; list.sort()
&gt;&gt;&gt; list
['alex', 'bob', 'lisi', 'zhangsan']
&gt;&gt;&gt; list.sort(reverse=True)
&gt;&gt;&gt; list
['zhangsan', 'lisi', 'bob', 'alex']

</code></pre> 
  <h4><a id="322_sorted_410"></a>3.2.2 使用函数sorted()对列表进行临时排序</h4> 
  <p>函数&nbsp;<code>sorted()</code>&nbsp;让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。</p> 
  <p>如果要反转排序，只需向&nbsp;<code>sorted()</code>&nbsp;传递参数 reverse=True。</p> 
  <pre><code>&gt;&gt;&gt; list = ['douglas','alex','solo','super']
&gt;&gt;&gt; sorted(list)
['alex', 'douglas', 'solo', 'super']
&gt;&gt;&gt; list
['douglas', 'alex', 'solo', 'super']
&gt;&gt;&gt; sorted(list, reverse=True)
['super', 'solo', 'douglas', 'alex']
&gt;&gt;&gt; list
['douglas', 'alex', 'solo', 'super']

</code></pre> 
  <h4><a id="323__429"></a>3.2.3 反转列表</h4> 
  <p>要反转列表元素的排列顺序，可使用方法&nbsp;<code>reverse()</code>。&nbsp;<code>reverse()</code>&nbsp;也会改变原始列表。</p> 
  <p><code>reverse()</code>&nbsp;只会按原来的顺序反转，不会进行额外的按字母排序。</p> 
  <pre><code>&gt;&gt;&gt; list
['douglas', 'alex', 'solo', 'super']
&gt;&gt;&gt; list.reverse()
&gt;&gt;&gt; list
['super', 'solo', 'alex', 'douglas']

</code></pre> 
  <h4><a id="324__444"></a>3.2.4 确定列表的长度</h4> 
  <p>使用函数len()可快速获悉列表的长度。</p> 
  <pre><code>&gt;&gt;&gt; list
['super', 'solo', 'alex', 'douglas']
&gt;&gt;&gt; len(list)
4

</code></pre> 
  <h3><a id="33__456"></a>3.3 操作列表</h3> 
  <h4><a id="331__458"></a>3.3.1 循环</h4> 
  <p>使用&nbsp;<code>for…in</code>&nbsp;循环。</p> 
  <p>python 以缩进来区分代码块，所以需要正确的缩进</p> 
  <pre><code>&gt;&gt;&gt; cats
['super', 'solo', 'alex', 'douglas']
&gt;&gt;&gt; for cat in cats:
...     print(cat)
...
super
solo
alex
douglas

</code></pre> 
  <h4><a id="332_range_477"></a>3.3.2 range()</h4> 
  <p>Python函数range()让你能够轻松地生成一系列的数字。</p> 
  <pre><code>&gt;&gt;&gt; for value in range(1,5):
...     print(value)
...
1
2
3
4

</code></pre> 
  <p>注意：range() 会产生包含第一个参数但不包含第二个参数的一系列数值。</p> 
  <p>使用&nbsp;<code>range()</code>&nbsp;创建列表</p> 
  <pre><code>&gt;&gt;&gt; numbers = list(range(1,6))
&gt;&gt;&gt; numbers
[1, 2, 3, 4, 5]

</code></pre> 
  <p><code>range()</code>&nbsp;还可以指定步长。下面的例子生成了从0开始，到11的偶数：</p> 
  <pre><code>&gt;&gt;&gt; nums = list(range(0,11,2))
&gt;&gt;&gt; nums
[0, 2, 4, 6, 8, 10]

</code></pre> 
  <h4><a id="333__512"></a>3.3.3 对列表简单的计算</h4> 
  <p>有几个专门用于处理数字列表的Python函数。</p> 
  <ul> 
   <li>min()：计算最小值</li> 
   <li>max()：计算最大值</li> 
   <li>sum()：计算总和</li> 
  </ul> 
  <pre><code>&gt;&gt;&gt; numbers
[1, 2, 3, 4, 5]
&gt;&gt;&gt; min(numbers)
1
&gt;&gt;&gt; max(numbers)
5
&gt;&gt;&gt; sum(numbers)
15

</code></pre> 
  <h4><a id="334__532"></a>3.3.4 列表解析</h4> 
  <p>列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。</p> 
  <pre><code>&gt;&gt;&gt; squares = [value**2 for value in range(1,11)]
&gt;&gt;&gt; squares
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

</code></pre> 
  <p>要使用这种语法，首先指定一个描述性的列表名，如squares;然后，指定一个左方括号， 并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为 value ** 2，它计 算平方值。接下来，编写一个for循环，用于给表达式提供值，再加上右方括号。在这个示例中， for循环为for value in range(1,11)，它将值1~10提供给表达式 value ** 2。请注意，这里的for 语句末尾没有冒号。</p> 
  <h3><a id="34__545"></a>3.4 切片</h3> 
  <p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3，这将输出分别为0、1和2的元素。</p> 
  <pre><code>&gt;&gt;&gt; names = ['aa','bb','cc','dd']
&gt;&gt;&gt; print(names[1:4])
['bb', 'cc', 'dd']

</code></pre> 
  <p>如果你没有指定第一个索引，Python将自动从列表开头开始:</p> 
  <pre><code>&gt;&gt;&gt; print(names[:4])
['aa', 'bb', 'cc', 'dd']

</code></pre> 
  <p>如果没有指定终止索引，将自动取到列表末尾</p> 
  <pre><code>&gt;&gt;&gt; print(names[2:])
['cc', 'dd']

</code></pre> 
  <p>也可以使用负数索引，比如返回最后三个元素</p> 
  <pre><code>&gt;&gt;&gt; print(names[-3:])
['bb', 'cc', 'dd']

</code></pre> 
  <p>遍历切片</p> 
  <pre><code>&gt;&gt;&gt; for name in names[1:3]:
...     print(name)
...
bb
cc

</code></pre> 
  <h3><a id="35__591"></a>3.5 复制列表</h3> 
  <p>可以使用切片来快速复制列表，不指定开始索引和结束索引。</p> 
  <pre><code>&gt;&gt;&gt; names
['aa', 'bb', 'cc', 'dd']
&gt;&gt;&gt; names2 = names[:]
&gt;&gt;&gt; names2
['aa', 'bb', 'cc', 'dd']

</code></pre> 
  <p>用切片复制出来的新列表，跟原来的列表是完全不同的列表，改变其实一个不会影响另一个列表。</p> 
  <pre><code>&gt;&gt;&gt; names.append('ee')
&gt;&gt;&gt; names
['aa', 'bb', 'cc', 'dd', 'ee']
&gt;&gt;&gt; names2
['aa', 'bb', 'cc', 'dd']

</code></pre> 
  <p>而如果简单的通过赋值将 names 赋值给 names2，就不能得到两个列表，实际上它们都指向了同一个列表。如果改变其中一个，另一个也将被改变。</p> 
  <pre><code>&gt;&gt;&gt; names
['aa', 'bb', 'cc', 'dd']
&gt;&gt;&gt; names2 = names
&gt;&gt;&gt; names2
['aa', 'bb', 'cc', 'dd']
&gt;&gt;&gt; names.append('ee')
&gt;&gt;&gt; names
['aa', 'bb', 'cc', 'dd', 'ee']
&gt;&gt;&gt; names2
['aa', 'bb', 'cc', 'dd', 'ee']

</code></pre> 
  <h3><a id="36__631"></a>3.6 元组</h3> 
  <p>Python将不能修改的值称为不可变的，而不可变的列表被称为元组。</p> 
  <p>元组看起来犹如列表，但使用圆括号而不是方括号来标识。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。</p> 
  <pre><code>&gt;&gt;&gt; food = ('apple', 'orange')
&gt;&gt;&gt; food[0]
'apple'
&gt;&gt;&gt; food[1]
'orange'
&gt;&gt;&gt; food[1] = 'banana'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment

</code></pre> 
  <p>遍历用法跟列表一致。</p> 
  <h2><a id="_652"></a>四、条件判断</h2> 
  <p>每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。</p> 
  <ul> 
   <li> <p>检查是否相等，用&nbsp;<code>==</code></p> </li> 
   <li> <p>检查是否不相等，用&nbsp;<code>!=</code></p> </li> 
   <li> <p>数字比较&nbsp;<code>&gt;</code>、&nbsp;<code>&lt;</code>、&nbsp;<code>&gt;=</code>、&nbsp;<code>&lt;=</code></p> </li> 
   <li> <p>多个条件与&nbsp;<code>and</code></p> </li> 
   <li> <p>多个条件或&nbsp;<code>or</code></p> </li> 
   <li> <p>判断列表是否包含某元素&nbsp;<code>in</code></p> <pre><code>&gt;&gt;&gt; names
['aa', 'bb', 'cc', 'dd', 'ee']
&gt;&gt;&gt; 'bb' in names
True

</code></pre> </li> 
   <li> <p>判断列表是否不包含某元素</p> <pre><code>&gt;&gt;&gt; names
['aa', 'bb', 'cc', 'dd', 'ee']
&gt;&gt;&gt; 'ff' not in names
True

</code></pre> </li> 
  </ul> 
  <h3><a id="if__686"></a>if 语句</h3> 
  <p>简单的 if-else</p> 
  <pre><code>&gt;&gt;&gt; a = 10
&gt;&gt;&gt; if a &gt; 10:
...     print('hello')
... else:
...     print('bye')
...
bye

</code></pre> 
  <p>if-elif-else</p> 
  <pre><code>&gt;&gt;&gt; if a&lt;5:
...     print(a&lt;5)
... elif 5&lt;a&lt;10:
...     print('5&lt;a&lt;10')
... else:
...     print('a&gt;10')
...
a&gt;10

</code></pre> 
  <h2><a id="_715"></a>五、字典</h2> 
  <p>在Python中，字典是一系列键-值对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p> 
  <h3><a id="51__719"></a>5.1 字典的增删改查</h3> 
  <h4><a id="_721"></a>使用字典</h4> 
  <p>在Python中，字典用放在花括号{}中的一系列键-值对表示。</p> 
  <pre><code>&gt;&gt;&gt; user = {'name':'bob', 'sex':'male', 'age':20}
&gt;&gt;&gt; user
{'name': 'bob', 'sex': 'male', 'age': 20}

</code></pre> 
  <h4><a id="_732"></a>访问字典中的值</h4> 
  <p>要获取与键相关联的值，可依次指定字典名和放在方括号内的键。</p> 
  <pre><code>&gt;&gt;&gt; user
{'name': 'bob', 'sex': 'male', 'age': 20}
&gt;&gt;&gt; user['name']
'bob'
&gt;&gt;&gt; user['age']
20

</code></pre> 
  <h4><a id="_746"></a>添加键值对</h4> 
  <p>字典是一种动态结构，可随时在其中添加键—值对。</p> 
  <pre><code>&gt;&gt;&gt; user['city']='beijing'
&gt;&gt;&gt; user
{'name': 'bob', 'sex': 'male', 'age': 20, 'city': 'beijing'}

</code></pre> 
  <h4><a id="_757"></a>修改字典中的值</h4> 
  <p>要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。</p> 
  <pre><code>&gt;&gt;&gt; cat = {}
&gt;&gt;&gt; cat['color'] = 'white'
&gt;&gt;&gt; cat['age'] = 4
&gt;&gt;&gt; cat
{'color': 'white', 'age': 4}
&gt;&gt;&gt; cat['age'] = 6
&gt;&gt;&gt; cat
{'color': 'white', 'age': 6}

</code></pre> 
  <h4><a id="_773"></a>删除键值对</h4> 
  <p>对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。使用del语句时，必须指定字典名和要删除的键。</p> 
  <pre><code>&gt;&gt;&gt; del cat['color']
&gt;&gt;&gt; cat
{'age': 6}

</code></pre> 
  <h3><a id="52__784"></a>5.2 遍历字典</h3> 
  <p>字典可用于以各种方式存储信息，因此有多种遍历字典的方式:可遍历字典的所有键—值对、键或值。</p> 
  <h4><a id="&nbsp;items_788"></a>遍历所有键值对&nbsp;<code>items()</code></h4> 
  <pre><code>&gt;&gt;&gt; cat
{'age': 6, 'color': 'white', 'city': 'beijing'}
&gt;&gt;&gt; for k,v in cat.items():
...     print(k + '-' + str(v))
...
age-6
color-white
city-beijing

</code></pre> 
  <p>通过&nbsp;<code>for k,v in cat.items()</code>&nbsp;的方式遍历所有的键值对，<code>k</code>&nbsp;代表键，<code>v</code>&nbsp;代表值。</p> 
  <blockquote> 
   <p>注意：即便遍历字典时，键—值对的返回顺序也与存储顺序不同。Python不关心键—值对的存储顺序，而只跟踪键和值之间的关联关系。</p> 
  </blockquote> 
  <h4><a id="&nbsp;keys_806"></a>遍历所有键&nbsp;<code>keys()</code></h4> 
  <p>如果不需要用值，可以用&nbsp;<code>keys()</code>&nbsp;遍历出所有的键。</p> 
  <pre><code>&gt;&gt;&gt; cat
{'age': 6, 'color': 'white', 'city': 'beijing'}
&gt;&gt;&gt; for k in cat.keys():
...     print(k.title())
...
Age
Color
City

</code></pre> 
  <p>上面的例子打印出了&nbsp;<code>cat</code>&nbsp;的所有键，用字符串的&nbsp;<code>title()</code>&nbsp;方法使每个单词的首字母大写。</p> 
  <p>遍历字典时会默认遍历所有的键，<code>for k in cat.keys()</code>&nbsp;和&nbsp;<code>for k in cat</code>&nbsp;的效果一样。</p> 
  <p>按顺序遍历所有键，可用&nbsp;<code>sorted()</code>&nbsp;排序，这让Python列出字典中的所有键，并在遍历前对这个列表进行排序。</p> 
  <pre><code>&gt;&gt;&gt; for k in sorted(cat.keys()):
...     print(k.title())
...
Age
City
Color

</code></pre> 
  <h4><a id="&nbsp;values_838"></a>遍历所有值&nbsp;<code>values()</code></h4> 
  <pre><code>&gt;&gt;&gt; for value in cat.values():
...     print(str(value))
...
6
white
beijing

</code></pre> 
  <p>如果需要剔除重复项，可以使用&nbsp;<code>set()</code></p> 
  <pre><code>&gt;&gt;&gt; cat
{'age': 6, 'color': 'white', 'city': 'beijing', 'city2': 'beijing'}
&gt;&gt;&gt; for value in cat.values():
...     print(str(value))
...
6
white
beijing
beijing
&gt;&gt;&gt; for value in set(cat.values()):
...     print(str(value))
...
beijing
white
6

</code></pre> 
  <h3><a id="53__871"></a>5.3 嵌套</h3> 
  <p>可以在列表中嵌套字典、在字典中嵌套列表以及在字典中嵌套字典。这里就不演示了。</p> 
  <h2><a id="while_875"></a>六、用户输入和while循环</h2> 
  <h3><a id="61__877"></a>6.1 用户输入</h3> 
  <p>函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。</p> 
  <pre><code>&gt;&gt;&gt; msg = input('Please input your name: ')
Please input your name: solo
&gt;&gt;&gt; msg
'solo'

</code></pre> 
  <p>如果你使用的是Python 2.7，应使用函数raw_input()来提示用户输入。这个函数与Python 3中的input()一样，也将输入解读为字符串。</p> 
  <p>Python 2.7也包含函数input()，但它将用户输入解读为Python代码，并尝试运行它们。如果你使用的是Python 2.7，请使用raw_input()而不是input()来获取输入。</p> 
  <p>如果想将输入的内容转换为数字，可以用&nbsp;<code>int()</code>&nbsp;来转换。</p> 
  <h3><a id="62_while__895"></a>6.2 while 循环</h3> 
  <p>for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条件不满足为止。</p> 
  <pre><code>&gt;&gt;&gt; num = 1
&gt;&gt;&gt; while num &lt;= 5:
...     print(str(num))
...     num += 1
...
1
2
3
4
5

</code></pre> 
  <h4><a id="break_913"></a>break</h4> 
  <p>要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句。break语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</p> 
  <h4><a id="continue_917"></a>continue</h4> 
  <p>要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像 break 语句那样不再执行余下的代码并退出整个循环。</p> 
  <h2><a id="_921"></a>七、函数</h2> 
  <p>Python 用关键字&nbsp;<code>def</code>&nbsp;来定义函数，函数名以冒号&nbsp;<code>:</code>&nbsp;结尾，冒号之后的缩进里的内容都是函数体。</p> 
  <pre><code>&gt;&gt;&gt; def greet():
...     print('Hello World!')
...
&gt;&gt;&gt; greet()
Hello World!

</code></pre> 
  <h3><a id="71__934"></a>7.1 函数参数</h3> 
  <p>可以向函数传递参数。下面的例子向函数&nbsp;<code>greet()</code>&nbsp;传递了个参数&nbsp;<code>name</code>。其中&nbsp;<code>name</code>&nbsp;是形参，<code>solo</code>&nbsp;是实参。</p> 
  <pre><code>&gt;&gt;&gt; def greet(name):
...     print('Hello,' + name)
...
&gt;&gt;&gt; greet('solo')
Hello,solo

</code></pre> 
  <p>向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同;也可使用关键字实参，其 中每个实参都由变量名和值组成;还可使用列表和字典。</p> 
  <h4><a id="_949"></a>位置实参</h4> 
  <p>你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。</p> 
  <pre><code>&gt;&gt;&gt; def student(name, age):
...     print('Hello, My name is ' + name + ', I am ' + str(age) + ' years old')
...
&gt;&gt;&gt; student('solo', 18)
Hello, My name is solo, I am 18 years old

</code></pre> 
  <p>按照形参定义的顺序传递的实参就称为位置实参。</p> 
  <h4><a id="_964"></a>关键字实参</h4> 
  <p>关键字实参是传递给函数的名称—值对。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。</p> 
  <pre><code>&gt;&gt;&gt; student(age=18, name='solo')
Hello, My name is solo, I am 18 years old

</code></pre> 
  <p>接着位置实参中的例子，<code>student(name, age)</code>&nbsp;方法第一个参数是&nbsp;<code>name</code>，第二个参数是&nbsp;<code>age</code>&nbsp;。我们用关键字实参指明传递的是哪一个，即使顺序写乱了得到的结果也不会乱。</p> 
  <h4><a id="_976"></a>默认值</h4> 
  <p>编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值;否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</p> 
  <pre><code>&gt;&gt;&gt; def student(name, age=18):
...     print('Hello, My name is ' + name + ', I am ' + str(age) + ' years old')
...
&gt;&gt;&gt; student('bob')
Hello, My name is bob, I am 18 years old
&gt;&gt;&gt; student('nicole')
Hello, My name is nicole, I am 18 years old
&gt;&gt;&gt; student('bob', 20)
Hello, My name is bob, I am 20 years old

</code></pre> 
  <p>如上，给&nbsp;<code>student()</code>&nbsp;函数定义的第二个参数&nbsp;<code>age</code>&nbsp;设置了默认值&nbsp;<code>18</code>，如果调用时只传一个参数，无论传的是什么&nbsp;<code>age</code>&nbsp;都是 18。当传两个参数时，传递的实参就会覆盖掉默认值。</p> 
  <blockquote> 
   <p>注意：使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让Python依然能够正确地解读位置实参。</p> 
  </blockquote> 
  <h3><a id="72__997"></a>7.2 返回值</h3> 
  <p>函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回 的值被称为返回值。在函数中，可使用return语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。</p> 
  <pre><code>&gt;&gt;&gt; def student(name):
...     return name
...
&gt;&gt;&gt; name = student('solo')
&gt;&gt;&gt; name
'solo'

</code></pre> 
  <h4><a id="_1011"></a>返回字典</h4> 
  <p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。例如，下面的函数接受姓名和年龄，并返回一个表示人的字典:</p> 
  <pre><code>&gt;&gt;&gt; def build_person(name,age):
...     person = {'name':name, 'age':age}
...     return person
...
&gt;&gt;&gt; p = build_person('solo',18)
&gt;&gt;&gt; p
{'name': 'solo', 'age': 18}

</code></pre> 
  <h3><a id="73__1026"></a>7.3 传递任意数量的实参</h3> 
  <p>有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。</p> 
  <pre><code>&gt;&gt;&gt; def person(*args):
...     print(args)
...
&gt;&gt;&gt; person('name','age','address')
('name', 'age', 'address')

</code></pre> 
  <p>上面定义了一个函数&nbsp;<code>person()</code>&nbsp;，只有一个形参&nbsp;<code>*args</code>&nbsp;。形参名&nbsp;<code>*args</code>&nbsp;中的星号让 Python 创建一个名为&nbsp;<code>args</code>&nbsp;的空元组，并将收到的所有值都封装到这个元组中。</p> 
  <h4><a id="_1041"></a>结合使用位置实参和任意数量实参</h4> 
  <p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python 先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p> 
  <pre><code>&gt;&gt;&gt; def person(city, *args):
...     print('city: ' + city + ', other args:')
...     for value in args:
...             print(value)
...
&gt;&gt;&gt; person('beijing', 'name', 'age', 'tel')
city: beijing, other args:
name
age
tel

</code></pre> 
  <p>函数&nbsp;<code>person()</code>&nbsp;有两个形参，第一个&nbsp;<code>city</code>&nbsp;是普通的位置实参，第二个&nbsp;<code>*args</code>&nbsp;是可变参数。</p> 
  <h4><a id="_1061"></a>使用任意数量的关键字实参</h4> 
  <p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。一个这样的示例是创建用户简介:你知道你将收到有关用户的信息，但不确定会是什么样的信息。</p> 
  <pre><code>def build_profile(first, last, **user_info):
	profile = {}
	profile['first_name'] = first
	profile['last_name'] = last

	for key,value in user_info.items():
		profile[key] = value

	return profile

user = build_profile('steven', 'bob', city='beijing', age=18)

print(user)

</code></pre> 
  <p>执行代码，输出结果是：</p> 
  <pre><code>{'first_name': 'steven', 'last_name': 'bob', 'city': 'beijing', 'age': 18}

</code></pre> 
  <h3><a id="74__1089"></a>7.4 导入导出</h3> 
  <p>可以将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块中的代码。</p> 
  <h4><a id="741__1093"></a>7.4.1 导入整个模块</h4> 
  <p>模块是扩展名为.py的文件，包含要导入到程序中的代码。</p> 
  <blockquote> 
   <p><a href="https://link.juejin.im/?target=http%3A%2F%2Fcat.py" rel="nofollow">cat.py</a></p> 
  </blockquote> 
  <pre><code>def eat(food):
    print('I am cat, I eat ' + food)

</code></pre> 
  <blockquote> 
   <p><a href="https://link.juejin.im/?target=http%3A%2F%2Fanimal.py" rel="nofollow">animal.py</a></p> 
  </blockquote> 
  <pre><code>import cat

cat.eat('fish')

</code></pre> 
  <p>控制台输出</p> 
  <pre><code>I am cat, I eat fish

</code></pre> 
  <h4><a id="742__1121"></a>7.4.2 导入特定的函数</h4> 
  <p>你还可以导入模块中的特定函数，这种导入方法的语法如下:</p> 
  <pre><code>from module_name import function_name 

</code></pre> 
  <p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数:</p> 
  <pre><code>from module_name import function_0, function_1, function_2 

</code></pre> 
  <p>上面的例子只导入&nbsp;<code>cat.py</code>&nbsp;中的&nbsp;<code>eat()</code>&nbsp;方法</p> 
  <pre><code>from cat import eat

eat('fish')

</code></pre> 
  <p>得到相同的结果。</p> 
  <h4><a id="743__as__1148"></a>7.4.3 使用 as 给函数指定别名</h4> 
  <p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名——函数的另一个名称，类似于外号。要给函数指定这种特殊外号，需要在导入它时这样做。</p> 
  <pre><code>from cat import eat as cat_eat

cat_eat('fish')

</code></pre> 
  <p>将&nbsp;<code>cat.py</code>&nbsp;中的&nbsp;<code>eat()</code>&nbsp;方法导入并指定了别名&nbsp;<code>cat_eat</code>，使用时可以直接用别名使用。</p> 
  <h4><a id="744__as__1161"></a>7.4.4 使用 as 给模块指定别名</h4> 
  <p>你还可以给模块指定别名。通过给模块指定简短的别名，让你 能够更轻松地调用模块中的函数。</p> 
  <p>通用语法：<code>import module_name as mn</code></p> 
  <pre><code>import cat as c

c.eat('fish')

</code></pre> 
  <h4><a id="745__1174"></a>7.4.5 导入模块中的所有函数</h4> 
  <p>使用星号(*)运算符可让Python导入模块中的所有函数:</p> 
  <blockquote> 
   <p><a href="https://link.juejin.im/?target=http%3A%2F%2Fcat.py" rel="nofollow">cat.py</a></p> 
  </blockquote> 
  <pre><code>def eat(food):
    print('I am cat, I eat ' + food)

def run():
    print('cat run')

</code></pre> 
  <blockquote> 
   <p><a href="https://link.juejin.im/?target=http%3A%2F%2Fanimal.py" rel="nofollow">animal.py</a></p> 
  </blockquote> 
  <pre><code>from cat import *

eat('fish')
run()

</code></pre> 
  <p>输出结果</p> 
  <pre><code>I am cat, I eat fish
cat run

</code></pre> 
  <p>由于导入 了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用并非自己编写的 大型模块时，最好不要采用这种导入方法:如果模块中有函数的名称与你的项目中使用的名称相 同，可能导致意想不到的结果: Python 可能遇到多个名称相同的函数或变量，进而覆盖函数，而 不是分别导入所有的函数。</p> 
  <p>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能 让代码更清晰，更容易阅读和理解。</p> 
  <h3><a id="75__1211"></a>7.5 函数编写指南</h3> 
  <ul> 
   <li> <p>应给函数指定描述性名称</p> </li> 
   <li> <p>函数名应只包含小写字母和下划线</p> </li> 
   <li> <p>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。</p> </li> 
   <li> <p>给形参指定默认值时，等号两边不要有空格:</p> <pre><code>def function_name(parameter_0, parameter_1='default value')

</code></pre> <p>对于函数调用中的关键字实参，也应遵循这种约定:</p> <pre><code>function_name(value_0, parameter_1='value')

</code></pre> </li> 
   <li> <p>如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</p> </li> 
   <li> <p>所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p> </li> 
  </ul> 
  <h2><a id="_1237"></a>八、类</h2> 
  <h3><a id="81__1239"></a>8.1 创建和使用类</h3> 
  <pre><code>class Cat():
    def __init__(self, name, color):
        self.name = name
        self.color = color

    def eat(self):
        print('cat ' + self.name + ' color ' + self.color + ', now eat')

    def run(self):
        print('cat ' + self.name + ' color ' + self.color + ', now run')

my_cat = Cat('Spring', 'white')
print(my_cat.name)
print(my_cat.color)
my_cat.eat()
my_cat.run()

</code></pre> 
  <p>上面创建了类&nbsp;<code>Cat</code>&nbsp;，并实例化了&nbsp;<code>my_cat</code>，然后调用了类的方法&nbsp;<code>eat()</code>&nbsp;和&nbsp;<code>run()</code>。输出结果：</p> 
  <pre><code>Spring
white
cat Spring color white, now eat
cat Spring color white, now run

</code></pre> 
  <p>类中的函数称为方法。<code>__init__()</code>&nbsp;是函数的构造方法，每档创建新实例时 Python 都会自动运行它。注意构造方法名字必须是这个，是规定好的。</p> 
  <p>上面的例子中<code>__init__(self, name, color)</code>&nbsp;有三个形参，第一个形参&nbsp;<code>self</code>&nbsp;必不可少，还必须位于其他形参的前面。其他的形参可以根据需要调整。<code>self</code>&nbsp;是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</p> 
  <p>还可以通过实例直接访问属性：<code>my_cat.name</code>。但在其他语言中并不建议这样做。</p> 
  <h4><a id="Python_27_1277"></a>在Python 2.7中创建类</h4> 
  <p>在Python 2.7中创建类时，需要做细微的修改——在括号内包含单词object:</p> 
  <pre><code>class ClassName(object):

</code></pre> 
  <h3><a id="82__1286"></a>8.2 类的属性</h3> 
  <h4><a id="821__1288"></a>8.2.1 给属性设置默认值</h4> 
  <p>类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法<code>__init__()</code>&nbsp;内指定这种初始值是可行的;如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</p> 
  <p>重新定义&nbsp;<code>Cat</code>&nbsp;，在构造方法中给属性&nbsp;<code>age</code>&nbsp;设置默认值。</p> 
  <pre><code>class Cat():
    def __init__(self, name, color):
        self.name = name
        self.color = color
        self.age = 3

    def eat(self):
        print('cat ' + self.name + ' color ' + self.color + ', now eat')

    def run(self):
        print('cat ' + self.name + ' color ' + self.color + ', now run')

    def print_age(self):
        print('cat`s age is ' + str(self.age))

</code></pre> 
  <h4><a id="822__1312"></a>8.2.2 修改属性的值</h4> 
  <p>可以以三种不同的方式修改属性的值：直接通过实例进行修改，通过方法进行设置。</p> 
  <h5><a id="1__1316"></a>1. 直接修改属性的值</h5> 
  <p>要修改属性的值，最简单的方式是通过实例直接访问它。</p> 
  <pre><code>class Cat():
    def __init__(self, name, color):
        self.name = name
        self.color = color
        self.age = 3

    def eat(self):
        print('cat ' + self.name + ' color ' + self.color + ', now eat')

    def run(self):
        print('cat ' + self.name + ' color ' + self.color + ', now run')

    def print_age(self):
        print('cat`s age is ' + str(self.age))

my_cat = Cat('Spring', 'white')

my_cat.print_age()
my_cat.age = 4
my_cat.print_age()

</code></pre> 
  <p>输出结果为</p> 
  <pre><code>cat`s age is 3
cat`s age is 4
复制代码
</code></pre> 
  <p>上例直接通过&nbsp;<code>my_cat.age = 4</code>&nbsp;修改了&nbsp;<code>age</code>&nbsp;属性的值。</p> 
  <h5><a id="2__1354"></a>2. 通过方法修改属性的值</h5> 
  <p>再来更新代码，加入&nbsp;<code>update_age()</code>&nbsp;方法来修改&nbsp;<code>age</code>&nbsp;的属性。</p> 
  <pre><code>class Cat():
    def __init__(self, name, color):
        self.name = name
        self.color = color
        self.age = 3

    def eat(self):
        print('cat ' + self.name + ' color ' + self.color + ', now eat')

    def run(self):
        print('cat ' + self.name + ' color ' + self.color + ', now run')

    def print_age(self):
        print('cat`s age is ' + str(self.age))

    def update_age(self, age):
        self.age = age

my_cat = Cat('Spring', 'white')
my_cat.print_age()
my_cat.update_age(10)
my_cat.print_age()

</code></pre> 
  <p>运行代码输出：</p> 
  <pre><code>cat`s age is 3
cat`s age is 10

</code></pre> 
  <h3><a id="83__1392"></a>8.3 继承</h3> 
  <p>一个类继承另一个类时，它将自动获得另一个类的所有属性和方法;原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</p> 
  <pre><code>class Animal():
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def run(self):
        print('Animal ' + self.name + ' run')

class Cat(Animal):
    def __init__(self, name, age):
        super().__init__(name, age)

cat = Cat('Tony', 2)
cat.run()

</code></pre> 
  <p>运行程序，输出：</p> 
  <pre><code>Animal Tony run

</code></pre> 
  <p>先定义了类&nbsp;<code>Animal</code>，又定义了&nbsp;<code>Cat</code>&nbsp;继承自&nbsp;<code>Animal</code>。&nbsp;<code>Animal</code>称为父类，&nbsp;<code>Cat</code>&nbsp;称为子类。通过输出可以验证，子类继承了父类的方法。</p> 
  <p>在子类的构造方法中要先实现父类的构造方法：<code>super().__init__(name, age)</code>。</p> 
  <p>还可以给子类定义自己的方法，或者重写父类的方法。</p> 
  <pre><code>class Animal():
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def run(self):
        print('Animal ' + self.name + ' run')

class Cat(Animal):
    def __init__(self, name, age):
        super().__init__(name, age)

    def play(self):
        print('Cat ' + self.name + ' play')

    def run(self):
        print('Cat ' + self.name + ' run')

cat = Cat('Tony', 2)
cat.run()
cat.play()

</code></pre> 
  <p>我们来修改下程序，<code>Animal</code>&nbsp;类不变，<code>Cat</code>&nbsp;类还是继承了&nbsp;<code>Animal</code>&nbsp;，但定义了自己的方法&nbsp;<code>play()</code>&nbsp;并重写了父类方法&nbsp;<code>run()</code>&nbsp;。运行程序，得到输出：</p> 
  <pre><code>Cat Tony run
Cat Tony play

</code></pre> 
  <h4><a id="Python27__1460"></a>Python2.7 中的继承</h4> 
  <p>在Python 2.7中，继承语法稍有不同，ElectricCar类的定义类似于下面这样:</p> 
  <pre><code>class Car(object):
	def __init__(self, make, model, year):
    	--snip--

class ElectricCar(Car):
	def __init__(self, make, model, year):
		super(ElectricCar, self).__init__(make, model, year)
		--snip--

</code></pre> 
  <p>函数super()需要两个实参:子类名和对象self。为帮助Python将父类和子类关联起来，这些实参必不可少。另外，在Python 2.7中使用继承时，务必在定义父类时在括号内指定object。</p> 
  <h3><a id="84__1478"></a>8.4 导入类</h3> 
  <p>当一个文件过长时，可以将其中一部分代码抽离出去，然后导入到主文件中。</p> 
  <p>导入方式有多种：</p> 
  <ul> 
   <li> <p>导入单个类</p> <p>假如&nbsp;<code>car.py</code>&nbsp;里定义了类&nbsp;<code>Car</code></p> <pre><code>from car import Car

</code></pre> </li> 
   <li> <p>从一个模块中导入多个类</p> <p>假如&nbsp;<code>car.py</code>&nbsp;包含了三个类&nbsp;<code>Car</code>&nbsp;，&nbsp;<code>Battery</code>&nbsp;和&nbsp;<code>ElectricCar</code>&nbsp;。</p> <p>只导入一个类：</p> <pre><code>from car import ElectricCar

</code></pre> <p>导入多个类，中间用逗号隔开：</p> <pre><code>from car import Car, ElectricCar

</code></pre> </li> 
   <li> <p>导入整个模块</p> <p>还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。</p> <pre><code>import car
my_car = car.Car()

</code></pre> </li> 
   <li> <p>导入模块中的所有类</p> <p>要导入模块中的每个类，可使用下面的语法:</p> <pre><code>from module_name import *

</code></pre> 
    <blockquote> 
     <p>不推荐使用这种导入方式，其原因有二。</p> 
     <p>首先，如果只要看一下文件开头的import语句，就 能清楚地知道程序使用了哪些类，将大有裨益;但这种导入方式没有明确地指出你使用了模块中 的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其 他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使 用这种方式，但你可能会在别人编写的代码中见到它。</p> 
     <p>需要从一个模块中导入很多类时，最好导入整个模块，并使用module_name.class_name语法 来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地 方使用了导入的模块;你还避免了导入模块中的每个类可能引发的名称冲突。</p> 
    </blockquote> </li> 
  </ul> 
  <h2><a id="_1536"></a>九、文件和异常</h2> 
  <h3><a id="91__1538"></a>9.1 从文件中读取数据</h3> 
  <p>要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。</p> 
  <h4><a id="911__1542"></a>9.1.1 读取整个文件</h4> 
  <pre><code>with open('test.txt') as file_obj:
    contents = file_obj.read()
    print(contents)

</code></pre> 
  <p><code>open()</code>&nbsp;用于打开一个文件，参数为文件的路径。</p> 
  <p>关键字&nbsp;<code>with</code>&nbsp;在不再需要访问文件后将其关闭。有了&nbsp;<code>with</code>&nbsp;你只管打开文件，并在需要时使用它，Python自会 在合适的时候自动将其关闭。</p> 
  <p>相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢?因为&nbsp;<code>read()</code>&nbsp;到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print语句中使用&nbsp;<code>rstrip()</code>。</p> 
  <p>文件路径可以是相对路径，也可以是绝对路径。</p> 
  <h4><a id="912__1559"></a>9.1.2 逐行读取</h4> 
  <pre><code>with open('test.txt') as file_obj:
    for line in file_obj:
        print(line.rstrip())

</code></pre> 
  <p>要以每次一行的方式检查文件，可对文件对象使用for循环。</p> 
  <h3><a id="92__1570"></a>9.2 写入文件</h3> 
  <pre><code>with open('test.txt', 'w') as file_obj:
    file_obj.write("I love python")

</code></pre> 
  <p>在这个示例中，调用open()时提供了两个实参，第一个实参也是要打开的文件的名称；第二个实参(‘w’)告诉Python，我们要以写入模式打开这个文件。</p> 
  <p>可选模式：</p> 
  <ul> 
   <li><code>r</code>&nbsp;：只读。</li> 
   <li><code>w</code>&nbsp;: 只写。如果文件不存在则创建，如果文件存在则先清空，再写入。</li> 
   <li><code>a</code>&nbsp;：附加模式，写入的内容追加到原始文件后面。如果文件不存在则创建。</li> 
   <li><code>r+</code>&nbsp;：可读可写。</li> 
  </ul> 
  <p>如果你省略了模式实参，Python将以默认的只读模式打开文件。</p> 
  <h3><a id="93__1589"></a>9.3 异常</h3> 
  <p>异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。</p> 
  <pre><code>try:
    print(5/0)
except ZeroDivisionError:
    print("You can't divide by zero!")

</code></pre> 
  <h4><a id="else__1601"></a>else 代码块</h4> 
  <pre><code>try:
    print(5/0)
except ZeroDivisionError:
    print("You can't divide by zero!")
else:
	print("no exception")

</code></pre> 
  <p>如果&nbsp;<code>try</code>&nbsp;中的代码运行成功，没有出现异常，则执行&nbsp;<code>else</code>&nbsp;代码块中的代码。</p> 
  <h3><a id="94__json__1615"></a>9.4 用 json 存储数据</h3> 
  <p>Python 中使用&nbsp;<code>json.dump()</code>&nbsp;和&nbsp;<code>json.load()</code>&nbsp;来存储和读取 json 文件。</p> 
  <pre><code>import json

userInfo = {'username': 'jack', 'age': 18}

with open('test.txt', 'w') as obj:
    json.dump(userInfo, obj)

with open('test.txt') as obj:
    content = json.load(obj)
    print(content)

</code></pre> 
  <p>上例中用&nbsp;<code>json.dump()</code>&nbsp;把数据存入到了&nbsp;<code>test.txt</code>&nbsp;中，又用&nbsp;<code>json.load()</code>&nbsp;把数据从文件中取出并打印。</p> 
  <p>注意使用前先导入 json 模块。</p> 
  <h2><a id="_1637"></a>十、单元测试</h2> 
  <p>先定义一个拼接名字的函数&nbsp;<code>name_function.py</code></p> 
  <pre><code>def get_formatted_name(first, last):
    full_name = first + ' ' + last
    return full_name.title()

</code></pre> 
  <p>再写测试类来测试这个函数</p> 
  <pre><code>import unittest
from name_function import get_formatted_name

class NamesTestCase(unittest.TestCase):

    def test_name_function(self):
        full_name = get_formatted_name('david', 'alex')
        self.assertEqual(full_name, 'David Alex')

unittest.main()

</code></pre> 
  <p>测试类要继承&nbsp;<code>unittest.TestCase</code>&nbsp;，通过&nbsp;<code>self.assertEqual</code>&nbsp;断言是否得到的结果和预期相等。</p> 
  <h4><a id="_1666"></a>常见的断言方法</h4> 
  <table> 
   <thead> 
    <tr> 
     <th>方法</th> 
     <th>用途</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>assertEqual(a, b)</td> 
     <td>核实a == b</td> 
    </tr> 
    <tr> 
     <td>assertNotEqual(a, b)</td> 
     <td>核实a != b</td> 
    </tr> 
    <tr> 
     <td>assertTrue(x)</td> 
     <td>核实x为True</td> 
    </tr> 
    <tr> 
     <td>assertFalse(x)</td> 
     <td>核实x为False</td> 
    </tr> 
    <tr> 
     <td>assertIn(item, list)</td> 
     <td>核实item在list中</td> 
    </tr> 
    <tr> 
     <td>assertNotIn(item, list)</td> 
     <td>核实item不在list中</td> 
    </tr> 
   </tbody> 
  </table>
  <h4><a id="setUp&nbsp;_1677"></a><code>setUp()</code>&nbsp;方法</h4> 
  <p>如果你在TestCase类中包含了方法&nbsp;<code>setUp()</code>&nbsp;，Python将先运行它，再运行各个以test_打头的方法。</p> 
  <p>通常用于做一些初始化操作。</p> 
  <hr> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
