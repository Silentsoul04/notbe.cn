<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>关于算法的一些知识点 « NotBeCN</title>
  <meta name="description" content="         1.set创建字符串数组：   #include &lt;set&gt;set&lt;string&gt; str;   使用set 可以很好的创建字符串数组；   这是他的方法：   1. begin()--返回指向第一个元素的迭代器   2. clear()--清除所有元素   3. cou...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/a362682954_90137894.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">关于算法的一些知识点</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>1.set创建字符串数组：</h1> 
  <pre class="has">
<code>#include &lt;set&gt;
set&lt;string&gt; str;</code></pre> 
  <p>使用set 可以很好的创建字符串数组；</p> 
  <p>这是他的方法：</p> 
  <p>1. begin()--返回指向第一个元素的迭代器</p> 
  <p>2. clear()--清除所有元素</p> 
  <p>3. count()--返回某个值元素的个数</p> 
  <p>4. empty()--如果集合为空，返回true</p> 
  <p>5. end()--返回指向最后一个元素的迭代器</p> 
  <p>6. equal_range()--返回集合中与给定值相等的上下限的两个迭代器</p> 
  <p>7. erase()--删除集合中的元素</p> 
  <p>8. find()--返回一个指向被查找到元素的迭代器</p> 
  <p>9. get_allocator()--返回集合的分配器</p> 
  <p>10. insert()--在集合中插入元素</p> 
  <p>11. lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器</p> 
  <p>12. key_comp()--返回一个用于元素间值比较的函数</p> 
  <p>13. max_size()--返回集合能容纳的元素的最大限值</p> 
  <p>14. rbegin()--返回指向集合中最后一个元素的反向迭代器</p> 
  <p>15. rend()--返回指向集合中第一个元素的反向迭代器</p> 
  <p>16. size()--集合中元素的数目</p> 
  <p>17. swap()--交换两个集合变量</p> 
  <p>18. upper_bound()--返回大于某个值元素的迭代器</p> 
  <p>19. value_comp()--返回一个用于比较元素间的值的函数</p> 
  <p>使用</p> 
  <pre class="has">
<code>str.count(ss)</code></pre> 
  <p>可以判断是否存在这个字符串，来避免重复。</p> 
  <p>对字符串的遍历：</p> 
  <pre class="has">
<code>set&lt;string&gt;::iterator iter=str.begin();
    while(iter!=str.end())
    {
        cout&lt;&lt;*iter&lt;&lt;endl;
        ++iter;
    }</code></pre> 
  <p>最后，set里面字符串已经按字典序排序过了，所以不需要再排序。</p> 
  <h1>2.string的一些方法</h1> 
  <p>下面转自：<a href="http://www.cnblogs.com/xFreedom/archive/2011/05/16/2048037.html" rel="nofollow">http://www.cnblogs.com/xFreedom/archive/2011/05/16/2048037.html</a></p> 
  <p>要想使用标准C++中string类，必须要包含</p> 
  <p>#include &lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件</p> 
  <p><br><strong>string类的构造函数：</strong></p> 
  <p>string(const char *s);&nbsp;&nbsp;&nbsp; //用c字符串s初始化<br> string(int n,char c);&nbsp;&nbsp;&nbsp;&nbsp; //用n个字符c初始化<br> 此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2="hello"；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；</p> 
  <p><br><strong>string类的字符操作：</strong><br> const char &amp;operator[](int n)const;<br> const char &amp;at(int n)const;<br> char &amp;operator[](int n);<br> char &amp;at(int n);<br> operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br> const char *data()const;//返回一个非null终止的c字符数组<br> const char *c_str()const;//返回一个以null终止的c字符串<br> int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p> 
  <p><br><strong>string的特性描述:</strong><br> int capacity()const;&nbsp;&nbsp;&nbsp; //返回当前容量（即string中不必增加内存即可存放的元素个数）<br> int max_size()const;&nbsp;&nbsp;&nbsp; //返回string对象中可存放的最大字符串的长度<br> int size()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回当前字符串的大小<br> int length()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回当前字符串的长度<br> bool empty()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //当前字符串是否为空<br> void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p> 
  <p><strong>string类的输入输出操作:</strong><br> string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br> 函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符'\n'分开。</p> 
  <p><strong>string的赋值：</strong><br> string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br> string &amp;assign(const char *s);//用c类型字符串s赋值<br> string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值<br> string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br> string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br> string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br> string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p> 
  <p><strong>string的连接：</strong><br> string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾&nbsp;<br> string &amp;append(const char *s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //把c类型字符串s连接到当前字符串结尾<br> string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br> string &amp;append(const string &amp;s);&nbsp;&nbsp;&nbsp; //同operator+=()<br> string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br> string &amp;append(int n,char c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //在当前字符串结尾添加n个字符c<br> string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p> 
  <p><br><strong>string的比较：</strong><br> bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br> 运算符"&gt;","&lt;","&gt;=","&lt;=","!="均被重载用于字符串的比较；<br> int compare(const string &amp;s) const;//比较当前字符串和s的大小<br> int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br> int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中</p> 
  <p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//pos2开始的n2个字符组成的字符串的大小<br> int compare(const char *s) const;<br> int compare(int pos, int n,const char *s) const;<br> int compare(int pos, int n,const char *s, int pos2) const;<br> compare函数在&gt;时返回1，&lt;时返回-1，==时返回0&nbsp;&nbsp;</p> 
  <p><br><strong>string的子串：</strong><br> string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p> 
  <p><strong>string的交换：</strong><br> void swap(string &amp;s2);&nbsp;&nbsp;&nbsp; //交换当前字符串与s2的值</p> 
  <p><br><strong>string类的查找函数：</strong>&nbsp;<br> int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br> int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br> int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br> int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br> //查找成功时返回所在位置，失败返回string::npos的值&nbsp;<br> int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br> int rfind(const char *s, int pos = npos) const;<br> int rfind(const char *s, int pos, int n = npos) const;<br> int rfind(const string &amp;s,int pos = npos) const;<br> //从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值&nbsp;<br> int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br> int find_first_of(const char *s, int pos = 0) const;<br> int find_first_of(const char *s, int pos, int n) const;<br> int find_first_of(const string &amp;s,int pos = 0) const;<br> //从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos&nbsp;<br> int find_first_not_of(char c, int pos = 0) const;<br> int find_first_not_of(const char *s, int pos = 0) const;<br> int find_first_not_of(const char *s, int pos,int n) const;<br> int find_first_not_of(const string &amp;s,int pos = 0) const;<br> //从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos&nbsp;<br> int find_last_of(char c, int pos = npos) const;<br> int find_last_of(const char *s, int pos = npos) const;<br> int find_last_of(const char *s, int pos, int n = npos) const;<br> int find_last_of(const string &amp;s,int pos = npos) const;&nbsp;<br> int find_last_not_of(char c, int pos = npos) const;<br> int find_last_not_of(const char *s, int pos = npos) const;<br> int find_last_not_of(const char *s, int pos, int n) const;<br> int find_last_not_of(const string &amp;s,int pos = npos) const;<br> //find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p> 
  <p><br><strong>string类的替换函数：</strong>&nbsp;<br> string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s<br> string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br> string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br> string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br> string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br> string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s<br> string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br> string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br> string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br> string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p> 
  <p><br><strong>string类的插入函数：</strong>&nbsp;<br> string &amp;insert(int p0, const char *s);<br> string &amp;insert(int p0, const char *s, int n);<br> string &amp;insert(int p0,const string &amp;s);<br> string &amp;insert(int p0,const string &amp;s, int pos, int n);<br> //前4个函数在p0位置插入字符串s中pos开始的前n个字符<br> string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br> iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br> void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br> void insert(iterator it, int n, char c);//在it处插入n个字符c</p> 
  <p><br><strong>string类的删除函数&nbsp;</strong><br> iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br> iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br> string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p> 
  <p><br><strong>string类的迭代器处理：</strong>&nbsp;<br> string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。<br> 用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br> const_iterator begin()const;<br> iterator begin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string的起始位置<br> const_iterator end()const;<br> iterator end();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string的最后一个字符后面的位置<br> const_iterator rbegin()const;<br> iterator rbegin();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string的最后一个字符的位置<br> const_iterator rend()const;<br> iterator rend();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回string第一个字符位置的前面<br> rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p> 
  <p>下面转自：<a href="https://www.runoob.com/cplusplus/cpp-strings.html" rel="nofollow">https://www.runoob.com/cplusplus/cpp-strings.html</a></p> 
  <table>
   <tbody>
    <tr>
     <th>序号</th> 
     <th>函数 &amp; 目的</th> 
    </tr>
    <tr>
     <td>1</td> 
     <td><strong>strcpy(s1, s2);</strong><br> 复制字符串 s2 到字符串 s1。</td> 
    </tr>
    <tr>
     <td>2</td> 
     <td><strong>strcat(s1, s2);</strong><br> 连接字符串 s2 到字符串 s1 的末尾。</td> 
    </tr>
    <tr>
     <td>3</td> 
     <td><strong>strlen(s1);</strong><br> 返回字符串 s1 的长度。</td> 
    </tr>
    <tr>
     <td>4</td> 
     <td><strong>strcmp(s1, s2);</strong><br> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td> 
    </tr>
    <tr>
     <td>5</td> 
     <td><strong>strchr(s1, ch);</strong><br> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td> 
    </tr>
    <tr>
     <td>6</td> 
     <td><strong>strstr(s1, s2);</strong><br> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td> 
    </tr>
   </tbody>
  </table>
  <h1>3.map使用</h1> 
  <p>参考：https://blog.csdn.net/ajianyingxiaoqinghan/article/details/78540736&nbsp;</p> 
  <p>一、原型</p> 
  <ol>
   <li> <p><code>template &lt; class Key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // map::key_type</code></p> </li> 
   <li> <p><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;class T, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // map::mapped_type</code></p> </li> 
   <li> <p><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;class Compare = less&lt;Key&gt;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // map::key_compare</code></p> </li> 
   <li> <p><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; &nbsp; &nbsp;// map::allocator_type</code></p> </li> 
   <li> <p><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt; class map;</code></p> </li> 
  </ol>
  <p><br> 二、说明<br> map 是一种容器，用来存储若干元素，这些元素都是由关键值 (Key Value，以下称为 Key 值) 和映射值 (Mapped Value，以下依旧称为映射值) 配对组成的，具体说明如下：&nbsp;<br> 在一个 map 中， Key 值通常用来排序或特指元素，映射值用来存储与该 Key 值绑定的内容。 Key 值与映射值的数据类型可以不同，而且可以一起被放进成员类型 value_type 中，value_type 是一种配对类型，定义如下：</p> 
  <pre class="has">
<code>typedef pair&lt;const Key, T&gt; value_type;</code></pre> 
  <p><br> 在 map 内部的元素通常按照其 Key 值排序，且排序方式是根据某种明确、严格的弱排序标准进行的，这种排序标准是由 map 内部的比较对象（即 map::key_comp）指定的。&nbsp;<br> map 容器通过 Key 值访问特定元素的速度，相较于 unordered_map 容器通常较慢，但 map 容器允许基于它们的顺序对子集进行直接迭代。&nbsp;<br> map 中的映射值可以使用括号运算符 (operator[]) 通过其关联的 Key 值直接访问。&nbsp;<br> map 通常使用二叉搜索树实现。</p> 
  <p>三、map 容器属性<br> 关联性：&nbsp;<br> 关联容器中的元素的参考地址指的是其 Key 值，而不是他们在容器中的绝对地址；<br> 有序性：&nbsp;<br> 容器中的元素一直按照排序方式严格排序，所有插入元素都按照该顺序排列；<br> 映射：&nbsp;<br> 每个元素中，一个 Key 值与一个映射值相关。Key 值是用来标识其主要内容是映射值的元素；<br> 唯一 Key 值：&nbsp;<br> 容器中不存在同时拥有相同 Key 值的两个元素；<br> 分配感知 (Allocator-aware)：&nbsp;<br> map 容器使用分配器对象动态处理其存储需求。<br> 四、模板参数<br> Key&nbsp;<br> Key 值的类型。在 map 中的每个元素都是由其 Key 值唯一指定的。<br> 别名为成员类型 map::key_type<br> T&nbsp;<br> 映射值的类型。在 map 中的每个元素，都存储了一些数据作为其映射值。<br> 别名为成员类型 map::mapped_type<br> Compare&nbsp;<br> 一个二元值，它将两个元素的 Key 值作为输入参数，并返回一个布尔值。表达式 comp(a, b)，其中 comp 是该类型的对象，a, b是 Key 值，如果按照函数定义的严格弱排序，参数 a 被认为排在参数 b 之前，则返回 true。<br> map 对象使用该表达式确定元素在容器中的位置，并判断两个元素的 Key 值是否相等（通过自反比较：如果 (!comp(a,b) &amp;&amp; !comp(b,a) ) 结果为真，则 a, b 等价）。map 容器中没有两个元素拥有相同的 Key 值。<br> Compare 可以使一个函数指针，或者函数对象（详细请参阅示例构造函数）。默认值小于&lt;T&gt;，返回应用小于运算符 (a &lt; b) 相同的值；<br> 别名为成员类型 map::key_compare<br> Alloc&nbsp;<br> 用于定义存储分配模型的分配器对象的类型。默认情况下使用分配器类模板，它定义了最简单的模型分配模型，而且与值无关。<br> 别名为成员类型 map::allocator_type<br> 五、常用函数<br> 构造函数&nbsp;<br> 在后续的程序示例中展示了五种不同的构造函数；<br> clear&nbsp;<br> 清除 map 中所有元素；<br> erase&nbsp;<br> 删除 map 中指定位置的元素；<br> insert&nbsp;<br> 在 map 指定位置添加 pair 类型的元素；<br> find&nbsp;<br> 获取 map 中元素的迭代器；<br> begin, end&nbsp;<br> map 的正向迭代器的起始位置与终点位置；<br> rbegin, rend&nbsp;<br> map 的反向迭代器的起始位置与终点位置；<br> 六、程序示例<br> 以下源码摘自《C++STL之map学习》，笔者对其进行注释。</p> 
  <pre class="has">
<code>#include &lt;iostream&gt;

#include &lt;map&gt;


using namespace std;


// 比较函数（用于后面的函数指针定义）

bool fncomp(char lhs, char rhs){

return lhs &lt; rhs;

}


// 定义一个 Compare 对象，且内部对运算符 () 进行重载

struct classcomp{

bool operator() (const char&amp; lhs, const char&amp; rhs){

return lhs &lt; rhs;

}

};


int main(int argc, char* argv[])

{

//=========================

// map 的多种构造函数

//=========================


// 1. 直接定义

map&lt;char,int&gt; mymap;

mymap['a'] = 10;

mymap['b'] = 60;

mymap['c'] = 30;

mymap['d'] = 90;

mymap['e'] = 50;


// 2. 复制

map&lt;char, int&gt; second(mymap);


// 3. 通过迭代器

map&lt;char, int&gt; third(mymap.begin(),mymap.end());


// 4. 重新定义 Compare 对象，该对象内部对运算符 () 进行重载

map&lt;char, int, classcomp&gt; fourth;


// 5. 通过函数指针

bool(*fn_pt)(char, char) = fncomp;

map&lt;char, int, bool(*)(char, char)&gt; fifth(fn_pt);


//=========================

// 以最初定义的mymap 为例，讲解 map 的使用

//=========================

map&lt;char,int&gt;::key_compare key_comp;

map&lt;char,int&gt;::iterator it;

it = mymap.begin();



//=========================

// 1. 输出所有 Pair 元素

//=========================

// 迭代器遍历 map

for (it; it != mymap.end(); it++)

{

// map的迭代器，可以用 first 访问std::pair的第一个成员(Type1)，second 访问第二个成员 (Type2)

cout&lt;&lt;it-&gt;first&lt;&lt;":"&lt;&lt;it-&gt;second&lt;&lt;endl;

}

cout&lt;&lt;"================================="&lt;&lt;endl;


//=========================

// 2. 修改映射值

//=========================

second.clear();

second['a']=1002;

second['b']=10023;

while (!second.empty())

{

cout &lt;&lt; second.begin()-&gt;first &lt;&lt; " =&gt; ";

cout &lt;&lt; second.begin()-&gt;second &lt;&lt; endl;

second.erase(second.begin());

}

cout&lt;&lt;"================================="&lt;&lt;endl;


//=========================

// 3. 插入

//=========================

mymap.insert(pair&lt;char,int&gt;('f',100) );

mymap.insert(pair&lt;char,int&gt;('g',200) );

cout&lt;&lt;"f =&gt; " &lt;&lt;mymap.find('f')-&gt;second&lt;&lt;endl;

cout&lt;&lt;"g =&gt; " &lt;&lt;mymap.find('g')-&gt;second&lt;&lt;endl;


cout&lt;&lt;"================================="&lt;&lt;endl;


//=========================

// 4. Compare 参数的使用

//=========================

key_comp = mymap.key_comp();

cout &lt;&lt; "mymap contains:\n";


// 迭代器反向遍历的起始位置

char highest = mymap.rbegin()-&gt;first; // key value of last element

it = mymap.begin();

do {

cout &lt;&lt; (*it).first &lt;&lt; " =&gt; " &lt;&lt; (*it).second &lt;&lt; endl;

} while ( key_comp((*it++).first, highest) );


cout &lt;&lt; endl;

return 0;

}</code></pre> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
