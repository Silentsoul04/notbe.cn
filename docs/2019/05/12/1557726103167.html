<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ehcache高级用法-缓存查询 « NotBeCN</title>
  <meta name="description" content="         一，简单实用与工具类   pom.xml:   &lt;dependency&gt;				&lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;				&lt;artifactId&gt;ehcache&lt;/artifactId&gt;         ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726103167.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Ehcache高级用法-缓存查询</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>一，简单实用与工具类</h1> 
  <p>pom.xml:</p> 
  <pre class="has">
<code>&lt;dependency&gt;
				&lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
				&lt;artifactId&gt;ehcache&lt;/artifactId&gt;
                &lt;version&gt;2.10.3&lt;/version&gt;
			&lt;/dependency&gt;</code></pre> 
  <p>EhcacheUtils.java</p> 
  <pre class="has">
<code>package com.equaker.facedemo.api.utils;

import net.sf.ehcache.Cache;
import net.sf.ehcache.CacheManager;
import net.sf.ehcache.Element;

import java.net.URL;

public class EhcacheUtil {

    private static final String path = "/ehcache.xml";

    private URL url;
    private static CacheManager manager;
    private static EhcacheUtil ehCache;

    private EhcacheUtil(String path) {

        url = getClass().getResource(path);
        manager = CacheManager.create(url);
    }

    public static EhcacheUtil getInstance() {
        if (ehCache == null) {
            ehCache = new EhcacheUtil(path);
        }
        return ehCache;
    }
    static {
        getInstance();
    }
    public static void put(String cacheName, Object key, Object value) {
        Cache cache = manager.getCache(cacheName);
        Element element = new Element(key, value);
        cache.put(element);
    }

    public static Object get(String cacheName, Object key) {
        Cache cache = manager.getCache(cacheName);
        Element element = cache.get(key);
        return element == null ? null : element.getObjectValue();
    }

    public static Cache get(String cacheName) {
        return manager.getCache(cacheName);
    }

    public static void remove(String cacheName, Object key) {
        Cache cache = manager.getCache(cacheName);
        cache.remove(key);
    }

}
</code></pre> 
  <p>ehcache,.xml:</p> 
  <pre class="has">
<code>&lt;!-- Ehcache2.x的变化(取自https://github.com/springside/springside4/wiki/Ehcache) --&gt;  
    &lt;!-- 1)最好在ehcache.xml中声明不进行updateCheck --&gt;  
    &lt;!-- 2)为了配合BigMemory和Size Limit,原来的属性最好改名 --&gt;  
    &lt;!--   maxElementsInMemory-&gt;maxEntriesLocalHeap --&gt;  
    &lt;!--   maxElementsOnDisk-&gt;maxEntriesLocalDisk --&gt;  
    &lt;ehcache&gt;  
        &lt;diskStore path="F:\\logs\\ehcache"/&gt;  
        &lt;defaultCache  
               maxElementsInMemory="1000"  
               eternal="false"  
               timeToIdleSeconds="120"  
               timeToLiveSeconds="120"  
               overflowToDisk="false"/&gt;  
        &lt;cache name="user"
               maxElementsOnDisk="20000"  
               maxElementsInMemory="2000"  
               eternal="false"  
               timeToIdleSeconds="120"  
               timeToLiveSeconds="120"
               overflowToDisk="true"  
               diskPersistent="true"/&gt;
         &lt;cache name="queryCache"
               maxElementsOnDisk="200"  
               maxElementsInMemory="200"  
               eternal="false"  
               timeToIdleSeconds="120"  
               timeToLiveSeconds="120"&gt;
             &lt;searchable keys="true" values="true"&gt;
&lt;!--                  可查询属性标识 --&gt;
                 &lt;searchAttribute name="id" expression="value.getId()"/&gt;
                 &lt;searchAttribute name="age" expression="value.getAge()"/&gt;
             &lt;/searchable&gt;
         &lt;/cache&gt;       
    &lt;/ehcache&gt;  
    &lt;!--  
    &lt;diskStore&gt;==========当内存缓存中对象数量超过maxElementsInMemory时,将缓存对象写到磁盘缓存中(需对象实现序列化接口)  
    &lt;diskStore path=""&gt;==用来配置磁盘缓存使用的物理路径,Ehcache磁盘缓存使用的文件后缀名是*.data和*.index  
    name=================缓存名称,cache的唯一标识(ehcache会把这个cache放到HashMap里)  
    maxElementsOnDisk====磁盘缓存中最多可以存放的元素数量,0表示无穷大  
    maxElementsInMemory==内存缓存中最多可以存放的元素数量,若放入Cache中的元素超过这个数值,则有以下两种情况  
                         1)若overflowToDisk=true,则会将Cache中多出的元素放入磁盘文件中  
                         2)若overflowToDisk=false,则根据memoryStoreEvictionPolicy策略替换Cache中原有的元素  
    eternal==============缓存中对象是否永久有效,即是否永驻内存,true时将忽略timeToIdleSeconds和timeToLiveSeconds  
    timeToIdleSeconds====缓存数据在失效前的允许闲置时间(单位:秒),仅当eternal=false时使用,默认值是0表示可闲置时间无穷大,此为可选属性  
                         即访问这个cache中元素的最大间隔时间,若超过这个时间没有访问此Cache中的某个元素,那么此元素将被从Cache中清除  
    timeToLiveSeconds====缓存数据在失效前的允许存活时间(单位:秒),仅当eternal=false时使用,默认值是0表示可存活时间无穷大  
                         即Cache中的某元素从创建到清楚的生存时间,也就是说从创建开始计时,当超过这个时间时,此元素将从Cache中清除  
    overflowToDisk=======内存不足时,是否启用磁盘缓存(即内存中对象数量达到maxElementsInMemory时,Ehcache会将对象写到磁盘中)  
                         会根据标签中path值查找对应的属性值,写入磁盘的文件会放在path文件夹下,文件的名称是cache的名称,后缀名是data  
    diskPersistent=======是否持久化磁盘缓存,当这个属性的值为true时,系统在初始化时会在磁盘中查找文件名为cache名称,后缀名为index的文件  
                         这个文件中存放了已经持久化在磁盘中的cache的index,找到后会把cache加载到内存  
                         要想把cache真正持久化到磁盘,写程序时注意执行net.sf.ehcache.Cache.put(Element element)后要调用flush()方法  
    diskExpiryThreadIntervalSeconds==磁盘缓存的清理线程运行间隔,默认是120秒  
    diskSpoolBufferSizeMB============设置DiskStore（磁盘缓存）的缓存区大小,默认是30MB  
    memoryStoreEvictionPolicy========内存存储与释放策略,即达到maxElementsInMemory限制时,Ehcache会根据指定策略清理内存  
                                     共有三种策略,分别为LRU(最近最少使用)、LFU(最常用的)、FIFO(先进先出)  
    --&gt;</code></pre> 
  <p>具体参数后面会用到。</p> 
  <p>*************************************分割线**************************************************************************************</p> 
  <p>下面介绍ehcache的高级功能缓存查询：</p> 
  <h1><strong>缓存的查询</strong></h1> 
  <p><strong>目录</strong></p> 
  <p>1.&nbsp;&nbsp;&nbsp;&nbsp;使Cache可查询</p> 
  <p>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于Xml配置</p> 
  <p>1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于代码的配置</p> 
  <p>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定可搜索的属性</p> 
  <p>2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可查询属性类型</p> 
  <p>2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性的提取</p> 
  <p>2.2.1&nbsp;&nbsp;&nbsp;&nbsp;定义自己的AttributeExtractor</p> 
  <p>2.2.2&nbsp;&nbsp;&nbsp; JavaBeanAttributeExtractor</p> 
  <p>2.2.3&nbsp;&nbsp;&nbsp; ReflectionAttributeExtractor</p> 
  <p>2.2.4&nbsp;&nbsp;&nbsp; DynamicAttributesExtractor</p> 
  <p>2.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过程序指定可查询属性</p> 
  <p>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询</p> 
  <p>3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建查询与筛选条件</p> 
  <p>3.1.1&nbsp;&nbsp;&nbsp;&nbsp;获取查询属性</p> 
  <p>3.1.2&nbsp;&nbsp;&nbsp;&nbsp;筛选类型</p> 
  <p>3.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询内容</p> 
  <p>3.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果</p> 
  <p>3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;统计</p> 
  <p>3.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序</p> 
  <p>3.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分组</p> 
  <p>3.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让Query不可变</p> 
  <p>3.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对BeanShell的支持</p> 
  <p>3.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ehcache中为我们提供了可以对Cache中缓存的元素进行查找的方式。其逻辑类似于SQL中的查找。通过给定各种限制条件，我们可以构造各种复杂的查询，然后返回结果集，也可以对查询进行分组和排序等。</p> 
  <h1>1.&nbsp;&nbsp;&nbsp;使Cache可查询</h1> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ehcache中的查询是针对于Cache而言的。但并不是所有的Cache都可以进行查询操作，我们需要指定其为一个可查询的Cache之后才可以对该Cache进行查询操作。因为在配置Cache的时候有基于xml文件的配置和基于程序代码的配置，所以对应的使一个Cache可查询也有两种方式。</p> 
  <h2>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于Xml配置</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们的Cache定义是基于Xml文件的配置时，我们只需在对应Cache定义下声明一个子元素searchable即可使当前Cache拥有可查询的功能。</p> 
  <pre class="has">
<code>&lt;cache name="searchableCache"&nbsp;maxBytesLocalHeap="100M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable/&gt;&nbsp;

&lt;/cache&gt;&nbsp;</code></pre> 
  <h2><br><span style="font-size:16px;font-weight:400;">&nbsp; &nbsp; &nbsp; &nbsp;基于代码的配置是通过新建Searchable对象，然后指定需要设置为可查询Cache对应的CacheConfiguration的Searchable对象为我们新建的Searchable对象即可。</span></h2> 
  <h2>1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于代码的配置</h2> 
  <pre class="has">
<code>public&nbsp;void&nbsp;test() {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheConfiguration cacheConfig =&nbsp;new&nbsp;CacheConfiguration();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cacheConfig.name("cache1").maxBytesLocalHeap(100, MemoryUnit.MEGABYTES);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searchable searchable =&nbsp;new&nbsp;Searchable();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//指定Cache的Searchable对象。&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cacheConfig.searchable(searchable);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如下指定也行&nbsp;

//&nbsp;&nbsp;&nbsp; cacheConfig.addSearchable(searchable);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cache cache1 =&nbsp;new&nbsp;Cache(cacheConfig);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cacheManager.addCache(cache1);&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;</code></pre> 
  <p><br><strong style="font-size:28px;font-weight:700;">2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定可搜索的属性</strong></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置了Cache可查询后，我们还需要配置当前Cache可以对哪些属性进行查询，即可以把哪些属性作为条件来对Cache进行查询。在Ehcache中使用一个net.sf.ehcache.search.Attribute来表示一个可查询的属性。这些可查询的属性可以是我们的key、value或者它们对应的属性。定义可查询属性是通过searchable元素的子元素searchAttribute来定义的，如：</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code>&lt;cache name="userCache"&nbsp;maxBytesLocalHeap="50M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="name"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;&nbsp;</code></pre> 
  <p>&nbsp; &nbsp;其中name表示我们所定义的可查询属性的名称，是必须指定的属性。这里会通过属性提取机制提取key或者value中name所对应的属性，这里是name属性，来进行索引。关于属性提取机制将在后续讲解。</p> 
  <h2>2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可查询属性类型</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并不是所有的属性都可以用来作为Cache的可查询属性，它必须是以下类型之一：</p> 
  <p>l&nbsp;&nbsp;Boolean</p> 
  <p>l&nbsp;&nbsp;Byte</p> 
  <p>l&nbsp;&nbsp;Short</p> 
  <p>l&nbsp;&nbsp;Character</p> 
  <p>l&nbsp;&nbsp;Integer</p> 
  <p>l&nbsp;&nbsp;Long</p> 
  <p>l&nbsp;&nbsp;Float</p> 
  <p>l&nbsp;&nbsp;Double</p> 
  <p>l&nbsp;&nbsp;String</p> 
  <p>l&nbsp;&nbsp;java.util.Date</p> 
  <p>l&nbsp;&nbsp;java.sql.Date</p> 
  <p>l&nbsp;&nbsp;Enum</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，系统会自动把我们存入可查询Cache中元素的key和value作为可查询属性，命名为key和value，当它们是以上可查询类型时我们可以直接对它们进行查询。如果不需要默认将我们的key和value作为可查询属性的话，我们可以在指定Cache为一个可查询Cache时指定searchable元素的keys属性和values属性为false即可。如：</p> 
  <pre class="has">
<code>&lt;cache name="searchableCache"&nbsp;maxBytesLocalHeap="100M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable keys="false"&nbsp;values="false"/&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <p><strong style="font-size:24px;font-weight:700;">2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性的提取</strong></p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们的key或者value不是可查询类型，然而我们又希望对它们进行查询时，我们就需要把key或者value中的属性提取出来作为Cache的一个可查询属性。这是通过AttributeExtractor来进行的，AttributeExtractor是一个接口，其中只定义了一个方法Object attributeFor(Element element, String attributeName)。其返回值必须是可查询属性类型之一。当然，返回null也是可以的。下面我们来看看如何定义自己的AttributeExtractor。</p> 
  <h3>2.2.1 &nbsp; 定义自己的AttributeExtractor</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们有一个名叫userCache的缓存，其中存放的元素值都是一个User对象。而我们的User对象有一个String类型的name属性。假设我们现在指定了我们的userCache的一个可查询属性为user，而其真正对应的内容是我们的Element中存放的value的name。（这个需求可能会比较奇怪）。那么这个时候我们的AttributeExtractor实现大概会是这个样子：</p> 
  <pre class="has">
<code>public&nbsp;class&nbsp;UserAttributeExtractor&nbsp;implements&nbsp;AttributeExtractor{&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;
    public&nbsp;Object attributeFor(Element element, StringattributeName)&nbsp;throws&nbsp;AttributeExtractorException {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;User user = (User) element.getObjectValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return&nbsp;user.getName();&nbsp;&nbsp;&nbsp;
&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;}</code></pre> 
  <p>&nbsp; &nbsp; &nbsp; 定义好了AttributeExtractor之后，我们要告诉Ehcache，缓存userCache的可查询属性user对应的AttributeExtractor是我们定义的UserAttributeExtractor，这只需要指定searchAttribute元素的class属性即可。</p> 
  <pre class="has">
<code>&lt;cache name="userCache"&nbsp;maxBytesLocalHeap="50M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="user"&nbsp;class="com.xxx.UserAttributeExtractor"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <p>之后我们通过user属性来查询时就可以通过User对象的name属性来过滤一些结果集了。如果我们的AttributeExtractor还需要接收其它的参数的话，我们可以通过searchAttribute元素的properties属性来指定，其对应的参数是键值对的形式，中间用等号“=”隔开，多个参数之间用逗号隔开。如：</p> 
  <pre class="has">
<code>&lt;cache name="userCache"&nbsp;maxBytesLocalHeap="50M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="user"&nbsp;class="com.xxx.UserAttributeExtractor"&nbsp;properties="a=1,b=2"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;&nbsp;</code></pre> 
  <p>&nbsp;我们指定了properties属性后，我们对应的AttributeExtractor必须给定一个以Properties对象为参数的构造方法才可以接收到这些指定的参数。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了定义自己的属性提取实现类之外，Ehcache还为我们提供了一些实现类。包括KeyObjectAttributeExtractor、ValueObjectAttributeExtractor，这两个属性提取器就是默认情况下Ehcache用来把key和value提取为一个可查询属性的方式。此外还有JavaBeanAttributeExtractor和ReflectionAttributeExtractor。</p> 
  <h3>2.2.2 &nbsp; JavaBeanAttributeExtractor</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们定义一个可查询属性searchAttribute只指定了其name属性时，系统所使用的AttributeExtractor就是JavaBeanAttributeExtractor。该AttributeExtractor会从元素的key或者value中取searchAttribute的name属性值所对应的属性。如果我们有如下这样一个可查询缓存的定义，我们的Ehcache在给可查询属性address建立索引时就会获取元素key的address属性或者value的address属性来作为查询属性address的值。</p> 
  <pre class="has">
<code>&lt;cache name="searchableCache"&nbsp;maxBytesLocalHeap="100M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable keys="false"&nbsp;values="false"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="address"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <p>注意：使用JavaBeanAttributeExtractor时，如果key和value中都包含可查询属性，则系统会抛出异常，如果都不包含的话也会抛出异常。</p> 
  <p>&nbsp;</p> 
  <h3>2.2.3 &nbsp; ReflectionAttributeExtractor</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们定义一个可查询属性searchAttribute时指定了expression属性时，系统就会使用ReflectionAttributeExtractor来提取属性的值。此属性提取器是通过反射来提取属性值的。expression必须以key、value或element开始，然后中间以点“.”来连接它们所对应的属性或方法，以及属性的属性，方法的方法。key表示元素的key，value表示元素的value，element表示元素本身。下面来看几个示例。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>1.</strong><strong>查询属性address</strong><strong>的值是对应的value</strong><strong>的address</strong><strong>属性。</strong></p> 
  <pre class="has">
<code>&lt;cache name="searchableCache"&nbsp;maxBytesLocalHeap="100M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable keys="false"&nbsp;values="false"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="address"&nbsp;expression="value.address"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <p>&nbsp;&nbsp;<strong>2.</strong><strong>查询属性address</strong><strong>的值是对应的value</strong><strong>的extraInfo</strong><strong>属性的getAddress()</strong><strong>方法的返回值。</strong></p> 
  <pre class="has">
<code>&lt;cache name="searchableCache"&nbsp;maxBytesLocalHeap="100M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable keys="false"&nbsp;values="false"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="address"&nbsp;expression="value.extraInfo.getAddress()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <p>&nbsp;<strong>3.</strong><strong>查询属性hitCount</strong><strong>的值是对应的element</strong><strong>的getHitCount()</strong><strong>方法的返回值。</strong></p> 
  <pre class="has">
<code>&lt;cache name="searchableCache"&nbsp;maxBytesLocalHeap="100M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable keys="false"&nbsp;values="false"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="hitCount"&nbsp;expression="element.getHitCount()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <h3>2.2.4 &nbsp; DynamicAttributesExtractor</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前介绍的AttributeExtractor都是在Cache实例化之前定义的，其会在Cache实例化时初始化这些可查询属性。而DynamicAttributesExtractor允许我们在Cache实例化后添加可查询属性。DynamicAttributesExtractor是一个接口，它跟AttributeExtractor接口没有任何关系。该接口中仅定义了一个方法attributesFor()，该方法将接收一个Element对象作为参数，然后返回一个将作为可查询属性的Map，该Map的key对应可查询属性的名称，而value则对应可查询属性的值。那么我们在实现DynamicAttributesExtractor接口时只需要实现attributesFor()方法即可。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用DynamicAttributeExtractor时我们的Cache对应的Searchable必须是支持该提取器才行，这是通过Searchable对象的allowDynamicIndexing属性来指定的，使用xml配置时该属性是直接配置在searchable元素上的，而使用程序来定义时则需要通过Searchable对象来指定了。之后我们需要把它注册给我们的Cache。通过Cache的registerDynamicAttributesExtractor()方法我们就可以给Cache注册一个动态的属性提取器了，该提取器将在往Cache中put或者replace元素时被调用。通过文字说明会比较抽象，接下来我们来看一个相应的示例。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们定义了如下这样一个专门用来缓存User的Cache，其中User中含有属性name。我们在定义该Cache的时候即指定了其是一个可查询的Cache，同时通过指定allowDynamicIndexing为true使其支持动态属性提取，我们还给该Cache指定了一个可查询属性name。</p> 
  <pre class="has">
<code>&lt;cache name="userCache"&nbsp;maxBytesLocalHeap="50M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable allowDynamicIndexing="true"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="name"&nbsp;expression="value.getName()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;</code></pre> 
  <p>&nbsp;接下来我们将在该Cache初始化之后注册一个DynamicAttributesExtractor，用于索引元素被查询到的次数hitCount。代码如下所示，我们在userCache初始化后给其注册了一个DynamicAttributesExtractor，在DynamicAttributesExtractor实现类中我们实现了attributesFor方法，在该方法体内我们构造了一个Map，并往其中放入了一个key为hitCount的元素。当我们往userCache中put或者replace元素的时候，就会触发我们注册的DynamicAttributesExtractor的attributesFor方法，然后Ehcache会对返回的动态可查询属性hitCount进行索引。在下面的代码中，我们的在给userCache注册了DynamicAttributesExtractor之后，马上列出其中包含的可查询属性，这个时候肯定只会包含预定义好的key、value和name，因为我们注册的DynamicAttributesExtractor还没有被执行。之后往其中放入元素之后，userCache中包含的可查询属性才会有通过DynamicAttributesExtractor返回的hitCount。</p> 
  <pre class="has">
<code>@Test&nbsp;

public&nbsp;void&nbsp;dynamicExtractor() {&nbsp;

&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;Cache userCache = cacheManager.getCache("userCache");&nbsp;

&nbsp;&nbsp;&nbsp;userCache.registerDynamicAttributesExtractor(new&nbsp;DynamicAttributesExtractor() {&nbsp;

&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Map&lt;String, Object&gt; attributesFor(Element element) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String, Object&gt; attrMap =&nbsp;new&nbsp;HashMap&lt;String, Object&gt;();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attrMap.put("hitCount", element.getHitCount());&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;attrMap;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;});&nbsp;

&nbsp;&nbsp;&nbsp;this.listSearchableAttrs(userCache);&nbsp;//key、value和name&nbsp;

&nbsp;&nbsp;&nbsp;userCache.put(new&nbsp;Element("1",&nbsp;new&nbsp;User()));&nbsp;

&nbsp;&nbsp;&nbsp;this.listSearchableAttrs(userCache);&nbsp;//key、value、name和hitCount&nbsp;

}&nbsp;

&nbsp;&nbsp;&nbsp;

/**

&nbsp;* 输出当前Ehcache中可查询的属性

&nbsp;* @param cache

&nbsp;*/&nbsp;

private&nbsp;void&nbsp;listSearchableAttrs(Ehcache cache) {&nbsp;

&nbsp;&nbsp;&nbsp;Set&lt;Attribute&gt; attrSet = cache.getSearchAttributes();&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(Attribute attr : attrSet) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(attr.getAttributeName());&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

}&nbsp;</code></pre> 
  <p>&nbsp;&nbsp;&nbsp;一个Cache只能注册有一个DynamicAttributesExtractor，当同时注册多个时，后者会将前者覆盖。但是DynamicAttributesExtractor和其它AttributeExtractor是可以并存的，所以因为其它AttributeExtractor是在Cache初始化前定义的，所以DynamicAttributesExtractor不能返回已经通过AttributeExtractor提取过的同名属性。</p> 
  <p>&nbsp;</p> 
  <h2>2.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过程序指定可查询属性</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过前面的内容我们知道设置可查询属性时除了DynamicAttributesExtractor可以在Cache初始化后再添加可查询属性外，我们的可查询属性必须是在Cache初始化之前进行指定，否则在对Cache进行查询时我们就不能使用该查询属性进行查询。如下面这一段代码，我们在Cache初始化后通过获取其配置信息，再往其对应的Searchalbe对象中新增一个名叫hello的查询属性，那么我们在今后对该Cache进行查询时将不能使用hello属性进行查询。</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code>@Test&nbsp;

public&nbsp;void&nbsp;setSearchAttrInProgram() {&nbsp;

&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;Cache cache = cacheManager.getCache("searchableCache");&nbsp;

&nbsp;&nbsp;&nbsp;CacheConfiguration cacheConfig = cache.getCacheConfiguration();&nbsp;

&nbsp;&nbsp;&nbsp;Searchable searchable = cacheConfig.getSearchable();&nbsp;

&nbsp;&nbsp;&nbsp;SearchAttribute searchAttribute =&nbsp;new&nbsp;SearchAttribute();&nbsp;

&nbsp;&nbsp;&nbsp;searchAttribute.name("hello");&nbsp;

&nbsp;&nbsp;&nbsp;searchable.addSearchAttribute(searchAttribute);&nbsp;

&nbsp;&nbsp;&nbsp;this.listSearchableAttrs(cache);&nbsp;

}</code></pre> 
  <p>&nbsp;由于定义非动态查询属性时需要在Cache初始化时定义，所以当我们需要在程序中定义查询属性时对应的Cache也需要是在程序中声明的才行。下面是在程序中指定可查询属性的一个示例。</p> 
  <pre class="has">
<code>@Test&nbsp;

public&nbsp;void&nbsp;setSearchAttrInProgram() {&nbsp;

&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;CacheConfiguration cacheConfig =&nbsp;new&nbsp;CacheConfiguration();&nbsp;

&nbsp;&nbsp;&nbsp;cacheConfig.name("cacheName").maxBytesLocalHeap(100, MemoryUnit.MEGABYTES);&nbsp;

&nbsp;&nbsp;&nbsp;//新建一个Searchable对象&nbsp;

&nbsp;&nbsp;&nbsp;Searchable searchable =&nbsp;new&nbsp;Searchable();&nbsp;

&nbsp;&nbsp;&nbsp;//给Cache配置Searchable对象，表明该Cache是一个可查询的Cache&nbsp;

&nbsp;&nbsp;&nbsp;cacheConfig.searchable(searchable);&nbsp;

&nbsp;&nbsp;&nbsp;//新建一个查询属性&nbsp;

&nbsp;&nbsp;&nbsp;SearchAttribute searchAttribute =&nbsp;new&nbsp;SearchAttribute();&nbsp;

&nbsp;&nbsp;&nbsp;//指定查询属性的名称和属性提取器的类名&nbsp;

&nbsp;&nbsp;&nbsp;searchAttribute.name("查询属性名称");&nbsp;

&nbsp;&nbsp;&nbsp;//searchAttribute.className("属性提取器的类名");&nbsp;

&nbsp;&nbsp;&nbsp;//Searchalbe对象添加查询属性&nbsp;

&nbsp;&nbsp;&nbsp;searchable.addSearchAttribute(searchAttribute);&nbsp;

&nbsp;&nbsp;&nbsp;//使用CacheConfig创建Cache对象&nbsp;

&nbsp;&nbsp;&nbsp;Cache cache =&nbsp;new&nbsp;Cache(cacheConfig);&nbsp;

&nbsp;&nbsp;&nbsp;//把Cache对象纳入CacheManager的管理中&nbsp;

&nbsp;&nbsp;&nbsp;cacheManager.addCache(cache);&nbsp;

&nbsp;&nbsp;&nbsp;this.listSearchableAttrs(cache);&nbsp;

}&nbsp;</code></pre> 
  <h1>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询</h1> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ehcache中是通过一个net.sf.ehcache.search.Query对象来表示一个查询的，通过该对象我们可以对缓存中的元素进行查询，查询条件就是我们之前定义好的可查询属性，而查询结果可以是缓存的key、value或可查询属性，也可以是针对于可查询属性的一些统计结果。</p> 
  <h2>3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建查询与筛选条件</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对Cache进行查询前我们需要先创建一个Query对象。Query对象是通过EhCache接口定义的createQuery()方法创建的，Cache类对它进行了实现。有了Query对象之后，我们需要使用Query对象的addCriteria(Criteria criteria)方法给该Query对象添加一些限制条件来对其中缓存的元素进行筛选，否则返回的结果将是针对于所有的缓存元素的。</p> 
  <pre class="has">
<code>@Test&nbsp;

public&nbsp;void&nbsp;search () {&nbsp;

&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;Cache userCache = cacheManager.getCache("userCache");&nbsp;

&nbsp;&nbsp;&nbsp;User user;&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0; i&lt;10; i++) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user =&nbsp;new&nbsp;User(i,&nbsp;"name"+(i%2),&nbsp;30+i);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userCache.put(new&nbsp;Element(user.getId(), user));&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;Query query = userCache.createQuery();&nbsp;

}</code></pre> 
  <p>Criteria是一个接口，在net.sf.ehcache.search.expression定义了其一系列的实现类，我们也可以直接通过new一个Criteria实现类的实例来对Query结果进行筛选。但通常我们不需要这样做，因为Ehcache中已经为我们实现了的Criteria通常已经可以满足我们的需求了。Ehcache中代表查询属性的Attribute类已经为我们提供了获取针对于该属性的各种Criteria的方法。好，现在我们已经知道了可以通过查询属性直接获取到针对于该属性的限制Criteria对象，那么我们该如何获取查询属性呢？</p> 
  <h3>3.1.1 &nbsp; 获取查询属性</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取查询属性Attribute主要有两种方式，一种是直接new一个Attribute实例对象，另一种是通过Ehcache接口定义的getSearchAttribute(String attrName)获取到可查询缓存中对应属性名称的可查询属性对象Attribute。常用的还是通过getSearchAttribute(String attrName)方法来获取对应的查询属性Attribute。当调用可查询Cache的getSearchAttribute(String attrName)方法来获取当前缓存的可查询属性时，如果对应名称的可查询属性不存在，则会抛出异常。</p> 
  <pre class="has">
<code>CacheManager cacheManager = CacheManager.create();&nbsp;

Cache cache = cacheManager.getCache("userCache");&nbsp;

Attribute&lt;String&gt; name = cache.getSearchAttribute("name");</code></pre> 
  <p>Attribute类使用了泛型定义，其表示当前属性值的类型。</p> 
  <h3>3.1.2 &nbsp; 筛选类型</h3> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了可查询属性Attribute之后，我们就可以通过Attribute类定义的一系列方法获取到当前Attribute的某种限制，从而对Query的查询结果进行筛选。如我们要筛选name为“name1”的查询结果时我们可以通过name.eq(“name1”)来进行筛选。</p> 
  <pre class="has">
<code>public&nbsp;void&nbsp;search2() {&nbsp;

&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;Cache userCache = cacheManager.getCache("userCache");&nbsp;

&nbsp;&nbsp;&nbsp;User user;&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0; i&lt;10; i++) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user =&nbsp;new&nbsp;User(i,&nbsp;"name"+(i%2),&nbsp;30+i);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userCache.put(new&nbsp;Element(user.getId(), user));&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;//获取名称为name的可查询属性Attribute对象&nbsp;

&nbsp;&nbsp;&nbsp;Attribute&lt;String&gt; name = userCache.getSearchAttribute("name");&nbsp;

&nbsp;&nbsp;&nbsp;//创建一个用于查询的Query对象&nbsp;

&nbsp;&nbsp;&nbsp;Query query = userCache.createQuery();&nbsp;

&nbsp;&nbsp;&nbsp;//给当前query添加一个筛选条件——可查询属性name的值等于“name1”&nbsp;

&nbsp;&nbsp;&nbsp;query.addCriteria(name.eq("name1"));&nbsp;

}</code></pre> 
  <p>&nbsp;&nbsp;接下来我们来看一下Attribute类为我们提供的获取对应Criteria的方法有哪些。</p> 
  <p>&nbsp;</p> 
  <table border="1" cellpadding="0" cellspacing="0">
   <tbody>
    <tr>
     <td> <p><strong>Attribute</strong><strong>方法</strong></p> </td> 
     <td> <p><strong>对应</strong><strong>Criteria</strong><strong>实现类</strong></p> </td> 
     <td> <p><strong>描述</strong></p> </td> 
    </tr>
    <tr>
     <td> <p>between</p> </td> 
     <td> <p>Between</p> </td> 
     <td> <p>属性值在给定的范围之间</p> </td> 
    </tr>
    <tr>
     <td> <p>in</p> </td> 
     <td> <p>InCollection</p> </td> 
     <td> <p>在给定的集合之中</p> </td> 
    </tr>
    <tr>
     <td> <p>ne</p> </td> 
     <td> <p>NotEqualTo</p> </td> 
     <td> <p>不等于给定的值</p> </td> 
    </tr>
    <tr>
     <td> <p>eq</p> </td> 
     <td> <p>EqualTo</p> </td> 
     <td> <p>等于给定的值</p> </td> 
    </tr>
    <tr>
     <td> <p>lt</p> </td> 
     <td> <p>LessThan</p> </td> 
     <td> <p>小于给定的值</p> </td> 
    </tr>
    <tr>
     <td> <p>le</p> </td> 
     <td> <p>LessThanOrEqual</p> </td> 
     <td> <p>小于或等于给定的值</p> </td> 
    </tr>
    <tr>
     <td> <p>gt</p> </td> 
     <td> <p>GreaterThan</p> </td> 
     <td> <p>大于给定的值</p> </td> 
    </tr>
    <tr>
     <td> <p>ge</p> </td> 
     <td> <p>GreaterThanOrEqual</p> </td> 
     <td> <p>大于或等于给定的值</p> </td> 
    </tr>
    <tr>
     <td> <p>ilike</p> </td> 
     <td> <p>ILike</p> </td> 
     <td> <p>匹配给定的表达式，表达式中可以使用“*”来代表任意多个字符，使用“？”来代表任意一个字符</p> </td> 
    </tr>
    <tr>
     <td> <p>notIlike</p> </td> 
     <td> <p>NotILike</p> </td> 
     <td> <p>不匹配给定的表达式</p> </td> 
    </tr>
    <tr>
     <td> <p>isNull</p> </td> 
     <td> <p>IsNull</p> </td> 
     <td> <p>等于null</p> </td> 
    </tr>
    <tr>
     <td> <p>notNull</p> </td> 
     <td> <p>NotNull</p> </td> 
     <td> <p>不等于null</p> </td> 
    </tr>
   </tbody>
  </table>
  <p>&nbsp;</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那当我们要实现与或非的逻辑时怎么办呢？Criteria为我们提供了对应的方法，分别对应and(Criteria criteria)方法、or(Criteria criteria)方法和not()方法，然后这三个方法的返回结果还是一个Criteria，它们对应的Criteria实现类分别为And、Or和Not。当我们使用Query的addCriteria(Criteria criteria)方法来添加一个筛选条件时默认都是对应的and操作。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们来看一些使用Criteria的例子。先假设我们有如下定义的一个Cache，其中存放的元素的value都是一个User对象，下面将给出一些针对于该Cache使用Criteria进行筛选查询的一些示例</p> 
  <pre class="has">
<code>cache name="userCache"&nbsp;maxBytesLocalHeap="50M"&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;searchable&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="name"&nbsp;expression="value.getName()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="age"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="unitNo"&nbsp;expression="value.unit.unitNo"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="unitName"&nbsp;expression="value.unit.getUnitName()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="mobile"&nbsp;expression="value.getMobile()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;searchAttribute name="hitCount"&nbsp;expression="element.getHitCount()"/&gt;&nbsp;

&nbsp;&nbsp;&nbsp;&lt;/searchable&gt;&nbsp;

&lt;/cache&gt;&nbsp;</code></pre> 
  <p>&nbsp;1、年龄在25岁到35岁之间且属于单位002的。</p> 
  <pre class="has">
<code>Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

&nbsp;&nbsp;&nbsp;Attribute&lt;String&gt; unitNo = userCache.getSearchAttribute("unitNo");&nbsp;

&nbsp;&nbsp;&nbsp;query.addCriteria(age.between(25,&nbsp;35).and(unitNo.eq("002")));&nbsp;

&nbsp;&nbsp;&nbsp;//或者使用两次addCriteria&nbsp;

// query.addCriteria(age.between(25, 35)).addCriteria(unitNo.eq("002"));</code></pre> 
  <p>2、属于单位002或者单位003，手机号码以137开始且年龄大于35岁的。</p> 
  <pre class="has">
<code>Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

Attribute&lt;String&gt; unitNo = userCache.getSearchAttribute("unitNo");&nbsp;

Attribute&lt;String&gt; mobile = userCache.getSearchAttribute("mobile");&nbsp;

ry.addCriteria(age.gt(35).and(unitNo.eq("002").or(unitNo.eq("003"))).and(mobile.ilike("137*")));</code></pre> 
  <p>3、不属于单位002且年龄小于30的。</p> 
  <pre class="has">
<code>Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

Attribute&lt;String&gt; unitNo = userCache.getSearchAttribute("unitNo");&nbsp;

query.addCriteria(unitNo.ne("002").and(age.lt(30)));&nbsp;

//或者使用not()方法&nbsp;

query.addCriteria(unitNo.eq("002").not().and(age.lt(30)));</code></pre> 
  <h2>3.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询内容</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个Query在查询之前，我们必须告诉它需要查询什么内容，也就是说查询的结果中会包含哪些信息。如果在执行查询操作之前没有告诉Query我们要查询什么内容，Ehcache将抛出异常。可以查询的内容包括缓存中存入元素的key、value，可查询属性对应的值，以及针对于当前查询结果中某个可查询属性的统计信息。针对于这四种可以查询内容Query中提供了四个include方法来表示当前Query的查询结果中会包含对应的内容。下面用一个表格来做个展示。</p> 
  <table border="1" cellpadding="0" cellspacing="0">
   <tbody>
    <tr>
     <td> <p><strong>Query</strong><strong>方法</strong></p> </td> 
     <td> <p><strong>描述</strong></p> </td> 
    </tr>
    <tr>
     <td> <p>includeKeys()</p> </td> 
     <td> <p>查询结果中包含所存元素的key</p> </td> 
    </tr>
    <tr>
     <td> <p>includeValues()</p> </td> 
     <td> <p>查询结果中包含所存元素的value</p> </td> 
    </tr>
    <tr>
     <td> <p>includeAttribute(Attribute&lt;?&gt;... attributes)</p> </td> 
     <td> <p>查询结果中要包含的可查询属性</p> </td> 
    </tr>
    <tr>
     <td> <p>includeAggregator(Aggregator... aggregators)</p> </td> 
     <td> <p>查询结果中所要包含的统计信息，关于Aggregator将在后文介绍统计的时候进行讲解</p> </td> 
    </tr>
   </tbody>
  </table>
  <p>&nbsp;</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下的代码表示我们的查询结果中会包含元素的key、可查询属性name和age对应的值。</p> 
  <pre class="has">
<code>Attribute&lt;String&gt; name = userCache.getSearchAttribute("name");&nbsp;

Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

query.includeAttribute(name, age);</code></pre> 
  <p>在实际应用中，为了让我们的程序具有更好的性能，我们的查询结果最好只包含我们需要的信息。如只需要获取某个属性的值就不必返回整个value。</p> 
  <h2>3.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了Query之后我们就可以来执行对应的查询操作，获取返回的查询结果。通过调用Query的execute()方法就可以对当前Query执行查询操作，并获取其返回的结果。Ehcache中使用一个Results接口来代表一个Query的查询结果，使用Result接口来代表对应的一条记录。Results中定义了一个方法all()用于返回查询出来的所有Result组成的List，查询的缓存中有多少元素满足查询条件，查询结果Results中就会包含多少个Result对象。Result中定义有getKey()、getValue()、getAttribute()和getAggregatorResults()方法用于获取查询结果中对应元素的key、value、可查询属性对应的值，以及针对于当前查询的统计信息组成的List。如果查询结果中不包含对应的信息，那么在Result调用对应方法获取信息时将抛出异常。Results针对于查询结果中是否包含这四方面的信息给我们提供了四个has方法：hasKeys()、hasValues()、hasAttributes()和hasAggregators()。Results和Result这两个接口Ehcache中都已经存在对应的实现了，我们在使用时只要直接利用接口来进行操作就可以了。</p> 
  <pre class="has">
<code>//执行查询操作，返回查询结果Results&nbsp;

Results results = query.execute();&nbsp;

//获取Results中包含的所有的Result对象&nbsp;

List&lt;Result&gt; resultList = results.all();&nbsp;

if&nbsp;(resultList !=&nbsp;null&nbsp;&amp;&amp; !resultList.isEmpty()) {&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(Result result : resultList) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//结果中包含key时可以获取key&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(results.hasKeys()) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.getKey();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//结果中包含value时可以获取value&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(results.hasValues()) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.getValue();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//结果中包含属性时可以获取某个属性的值&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(results.hasAttributes()) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attribute&lt;String&gt; attribute = userCache.getSearchAttribute("name");&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.getAttribute(attribute);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//结果中包含统计信息时可以获取统计信息组成的List&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(results.hasAggregators()) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.getAggregatorResults();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

}</code></pre> 
  <p>当然，如果你已经清楚的知道了查询结果中已经包含了key时你在获取key前就可以不用调用Results的hasKeys()方法进行判断了，其它结果也一样。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Results中的all()方法可以返回当前查询的结果中的所有Result组成的List。另外，Results中还提供了一个range(int start, int count)方法用于获取当前结果集的一个子集，其底层默认实现使用的是List的subList()方法。该方法可以用于对查询结果的分页操作。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，我们在对Cache进行查询时，查询结果将返回所有满足查询条件的记录。当返回的记录非常多时，系统可能会因为内存不足而报错。Query中定义了一个maxResults(int maxResults)方法用于限制当前查询返回查询结果的最大记录数。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是由于元素过期的问题，我们查询结果中的元素不一定还存在。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们利用完Results之后，我们需要通过调用Results的discard()方法来释放资源。</p> 
  <p>&nbsp;</p> 
  <h2>3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;统计</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ehcache为我们提供了一个Aggregator接口用于在查询过程中对某个查询属性进行统计。我们可以实现自己的Aggregator，也可以使用Ehcache为我们提供的实现类。Ehcache中已经为我们提供了五个Aggregator实现类，分别是Min、Max、Sum、Count和Average。看了名称我应该就知道这五个Aggregator分别是做什么用的。Min是求最小值、Max是求最大值、Sum是求和、Count是计数、Average是求平均值。那么在使用这五个Aggregator时也是非常方便的，因为我们的Attribute已经为我们针对这五个Aggregator定义了对应的方法。方法名称就是对应Aggregator实现类简称的首字母小写，如Min在Attribute中就对应min()方法。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们需要对某个查询属性进行统计时，我们需要把对应的Aggregator通过调用Query的includeAggregator()方法添加到查询的结果中。</p> 
  <pre class="has">
<code>//创建一个用于查询的Query对象&nbsp;

Query query = userCache.createQuery();&nbsp;

Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

//查询结果中包含age的平均值和age的最大值&nbsp;

query.includeAggregator(age.average(), age.max());&nbsp;

Results results = query.execute();&nbsp;

List&lt;Result&gt; resultList = results.all();&nbsp;

if&nbsp;(resultList !=&nbsp;null&nbsp;&amp;&amp; !resultList.isEmpty()) {&nbsp;

&nbsp;&nbsp;&nbsp;//每一个查询结果Result中都会包含对查询结果的统计信息。&nbsp;

&nbsp;&nbsp;&nbsp;Result result = resultList.get(0);&nbsp;

&nbsp;&nbsp;&nbsp;//多个统计信息将会组成一个List进行返回&nbsp;

&nbsp;&nbsp;&nbsp;List&lt;Object&gt; aggregatorResults = result.getAggregatorResults();&nbsp;

&nbsp;&nbsp;&nbsp;Number averageAge = (Number)aggregatorResults.get(0);&nbsp;

&nbsp;&nbsp;&nbsp;Integer maxAge = (Integer)aggregatorResults.get(1);&nbsp;

&nbsp;&nbsp;&nbsp;System.out.println(averageAge +&nbsp;"---"&nbsp;+ maxAge);&nbsp;

}</code></pre> 
  <p>&nbsp;当我们的查询结果中只包含有统计信息时，我们的查询结果Results中只会有一条记录，即一个Result对象。当包含其它信息时查询结果就可能会有多条记录，而且每条记录中都会包含有对应的统计信息。</p> 
  <p>&nbsp;</p> 
  <h2>3.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ehcache中对于Cache的查询也是可以进行排序的，这是通过Query的addOrderBy()方法来指定的。该方法接收两个参数，第一个参数表示需要进行排序的属性Attribute，第二个参数是排序的方向Direction。Direction有两个可选值，Direction.ASCENDING和Direction.DESCENDING。当需要对多个属性进行排序时则需要调用多次addOrderBy()方法。</p> 
  <pre class="has">
<code>Attribute&lt;String&gt; unitNo = userCache.getSearchAttribute("unitNo");&nbsp;

Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

//查询结果按部门编号的升序和年龄的降序进行排列&nbsp;

query.addOrderBy(unitNo, Direction.ASCENDING).addOrderBy(age, Direction.DESCENDING);</code></pre> 
  <h2>3.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分组</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ehcache也支持对查询的缓存进行分组。这是通过Query的addGroupBy()方法来定义的，该方法接收一个Attribute作为参数，表示要对哪个Attribute进行分组，当需要对多个Attribute进行分组时，则需要调用多次addGroupBy()方法。使用分组的语法基本上跟SQL里面分组的语法是一样的，当使用分组时查询结果只能包含分组的属性和统计信息，统计信息是对分组后的情况进行统计。唯一不同的是Ehcahce中查询分组时无法对分组后的情况进行筛选。</p> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是一个通过单位编码进行分组统计各单位员工的平均年龄、最大年龄和员工的人数的示例。</p> 
  <pre class="has">
<code>//创建一个用于查询的Query对象&nbsp;

Query query = userCache.createQuery();&nbsp;

Attribute&lt;String&gt; unitNo = userCache.getSearchAttribute("unitNo");&nbsp;

Attribute&lt;Integer&gt; age = userCache.getSearchAttribute("age");&nbsp;

//对单位编号进行分组&nbsp;

query.addGroupBy(unitNo);&nbsp;

//各单位年龄的平均值、最大值以及人数。&nbsp;

query.includeAggregator(age.average(), age.max(), age.count());&nbsp;

//查询结果中还包含单位编码&nbsp;

query.includeAttribute(unitNo);&nbsp;

Results results = query.execute();&nbsp;

List&lt;Result&gt; resultList = results.all();&nbsp;

if&nbsp;(resultList !=&nbsp;null&nbsp;&amp;&amp; !resultList.isEmpty()) {&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(Result result : resultList) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String unitNoVal = result.getAttribute(unitNo);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//多个统计信息将会组成一个List进行返回&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Object&gt; aggregatorResults = result.getAggregatorResults();&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Number averageAge = (Number)aggregatorResults.get(0);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer maxAge = (Integer)aggregatorResults.get(1);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer count = (Integer)aggregatorResults.get(2);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("单位编号："&nbsp;+ unitNoVal +&nbsp;"---"&nbsp;+ averageAge +&nbsp;"，"&nbsp;+ maxAge +&nbsp;"，"&nbsp;+ count);&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

}&nbsp;</code></pre> 
  <h2>3.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让Query不可变</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，我们的Query可以在执行后修改某些属性后继续查询。但是一旦我们调用了Query的end()方法之后我们将不能够再更改Query的一些属性。这包括调用include来定义返回结果中需要包含的信息、指定排序的属性、指定分组的属性、添加Criteria限制条件和调用maxResults()方法指定最大返回记录数。</p> 
  <p>&nbsp;</p> 
  <h2>3.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对BeanShell的支持</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BeanShell是用Java写的，能够对Java字符串表达式进行解释执行的一个工具。如果在实际应用中我们需要让用户来自定义查询的脚本时，我们就可以使用BeanShell来对查询脚本进行解释执行了。使用BeanShell前我们需加入BeanShell的jar包到类路径，笔者下面的示例中使用的是BeanShell2.0的第4个测试版本。</p> 
  <pre class="has">
<code>@Test&nbsp;

public&nbsp;void&nbsp;beanShell()&nbsp;throws&nbsp;EvalError {&nbsp;

&nbsp;&nbsp;&nbsp;CacheManager cacheManager = CacheManager.create();&nbsp;

&nbsp;&nbsp;&nbsp;Cache userCache = cacheManager.getCache("userCache");&nbsp;

&nbsp;&nbsp;&nbsp;User user;&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0; i&lt;10; i++) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user =&nbsp;new&nbsp;User(i,&nbsp;"name"+(i%2),&nbsp;25+i);&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userCache.put(new&nbsp;Element(user.getId(), user));&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;//BeanShell解释器，需引入BeanShell相关jar包&nbsp;

&nbsp;&nbsp;&nbsp;Interpreter interpreter =&nbsp;new&nbsp;Interpreter();&nbsp;

&nbsp;&nbsp;&nbsp;Query query = userCache.createQuery().includeValues();&nbsp;

&nbsp;&nbsp;&nbsp;//Interpreter进行计算的字符串中出现的变量都需要放入Interpreter的环境中&nbsp;

&nbsp;&nbsp;&nbsp;interpreter.set("query", query);//把query放入Interpreter环境中&nbsp;

&nbsp;&nbsp;&nbsp;//把age放入Interpreter环境中&nbsp;

&nbsp;&nbsp;&nbsp;interpreter.set("age", userCache.getSearchAttribute("age"));&nbsp;

&nbsp;&nbsp;&nbsp;String queryStr =&nbsp;"query.addCriteria(age.lt(30)).execute();";&nbsp;

&nbsp;&nbsp;&nbsp;//BeanShell执行字符串表达式对userCache进行查询，并返回Results&nbsp;

&nbsp;&nbsp;&nbsp;Results results = (Results)interpreter.eval(queryStr);&nbsp;

&nbsp;&nbsp;&nbsp;for&nbsp;(Result result : results.all()) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(result);&nbsp;

&nbsp;&nbsp;&nbsp;}&nbsp;

&nbsp;&nbsp;&nbsp;results.discard();&nbsp;

}&nbsp;</code></pre> 
  <p>关于BeanShell的更多了解请访问BeanShell的官方网站www.beanshell.org。</p> 
  <h2>3.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结</h2> 
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;纵观整个Ehcahce中对于Cache的查询Query，我们可以发现其基本的逻辑和规则与SQL查询是一样的。可以进行筛选、选择要查询的结果、统计、排序和分组。Ehcache中的查询也是先通过Criteria进行筛选，再进行分组和排序。redis可能不具备这样的功能哦。</p> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
