<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>kotlin基本篇：kotlin与java语法不同写法比较 « NotBeCN</title>
  <meta name="description" content="         写在前面   &nbsp; &nbsp; &nbsp; &nbsp; 最近谷歌大会强调Kotlin将在今后广泛拓展应用，毕竟相比java优势凸显，所以学习 Kotlin 已经成为我们必经之路。本想着等到某一天大佬们把坑踩得差不多了，又或者我们开发中要用到了，再学也不迟，毕竟我们还是要优先把时间和...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/P876643136_90123284.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">kotlin基本篇：kotlin与java语法不同写法比较</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h3><span style="color:#3399ea;">写在前面</span></h3> 
  <p>&nbsp; &nbsp; &nbsp; &nbsp; 最近谷歌大会强调Kotlin将在今后广泛拓展应用，毕竟相比java优势凸显，所以学习 Kotlin 已经成为我们必经之路。本想着等到某一天大佬们把坑踩得差不多了，又或者我们开发中要用到了，再学也不迟，毕竟我们还是要优先把时间和精力留给实际开发中需要学习的知识上，而现在呢也只能跟着冲锋陷阵了不然就落后了。</p> 
  <p>对象</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>MainActivity.this
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>this@MainActivity
</code></pre> 
  <p>类</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>MainActivity.class
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>MainActivity::class.java
</code></pre> 
  <p>继承</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MainActivity extends AppCompatActivity {
    
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（在 Kotlin 中被继承类必须被 open 关键字修饰）</p> 
  </blockquote> 
  <pre class="has">
<code>class MainActivity : AppCompatActivity() {
    
}
</code></pre> 
  <p>变量</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>Intent intent = new Intent();
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>var intent = Intent()
</code></pre> 
  <p>常量</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>final String text = "";
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>val text = ""
</code></pre> 
  <p>静态常量</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MainActivity extends AppCompatActivity {

    static final String text = "";
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（需要注意的是要把静态变量定义在类上方）</p> 
  </blockquote> 
  <pre class="has">
<code>const val text = ""

class MainActivity : AppCompatActivity() {

}
</code></pre> 
  <p>定义方法</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public void test(String message) {

}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（Unit 跟 void 一样效果）</p> 
  </blockquote> 
  <pre class="has">
<code>fun test(message : String) : Unit {

}
</code></pre> 
  <hr>
  <pre class="has">
<code>// 在 Kotlin 可以省略 Unit 这种返回值
fun test(message : String) {

}
</code></pre> 
  <p>重载方法</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }
}
</code></pre> 
  <p>基本数据类型</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>int i = 1;
long l = 2;
boolean b = true;
float f = 0;
double d = 0;
char c = 'A';
String s = "text";
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>var i : Int = 1
var l : Long = 2
var b : Boolean = true
var f : Float = 0F
var d : Double = 0.0
var c : Char = 'A'
var s : String = "text"
</code></pre> 
  <hr>
  <pre class="has">
<code>// 更简洁点可以这样，自动推倒类型
var i = 1
var l = 2
var b = true
var f = 0F
var d = 0.0
var c = 'A'
var s = "text"
</code></pre> 
  <p>比较类型</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>if ("" instanceof String) {

}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>if ("" is String) {

}
</code></pre> 
  <p>转换符</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>int number = 100;
System.out.println(String.format("商品数量有%d", number));
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>var number = 100
println("商品数量有${number}")
</code></pre> 
  <hr>
  <pre class="has">
<code>// 换种简洁的写法
var number = 100
println("商品数量有$number")
</code></pre> 
  <hr>
  <pre class="has">
<code>// 如果不想字符串被转义可以使用\$
var number = 100
println("商品数量有\$number")
</code></pre> 
  <p>字符串比较</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>String s1 = "text";
String s2 = "text";
if (s1.equals(s2)) {
    
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（Kotlin 对字符串比较的写法进行优化了，其他类型对象对比还是要用 equals 方法）</p> 
  </blockquote> 
  <pre class="has">
<code>var s1 = "text"
var s2 = "text"
if (s1 == s2) {

}
</code></pre> 
  <p>数组</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>int[] array1 = {1, 2, 3};
float[] array2 = {1f, 2f, 3f};
String[] array3 = {"1", "2", "3"};
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>val array1 = intArrayOf(1, 2, 3)
val array2 = floatArrayOf(1f, 2f, 3f)
val array3 = arrayListOf("1", "2", "3")
</code></pre> 
  <p>循环</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>String[] array = {"1", "2", "3"};

for (int i = 0; i &lt; array.length; i++) {
    System.out.println(array[i]);
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>val array = arrayListOf("1", "2", "3")

for (i in array.indices) {
    println(array[i])
}
</code></pre> 
  <p>角标循环</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>String[] array = {"1", "2", "3"};

for (int i = 1; i &lt; array.length; i++) {
    System.out.println(array[i]);
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（这种写法在 Kotlin 中称之为区间）</p> 
  </blockquote> 
  <pre class="has">
<code>val array = arrayListOf("1", "2", "3")

for (i in IntRange(1, array.size - 1)) {
    println(array[i])
}
</code></pre> 
  <hr>
  <pre class="has">
<code>// 换种更简洁的写法
val array = arrayListOf("1", "2", "3")

for (i in 1..array.size - 1) {
    println(array[i])
}
</code></pre> 
  <hr>
  <pre class="has">
<code>// 编译器提示要我们换种写法
val array = arrayListOf("1", "2", "3")

for (i in 1 until array.size) {
    println(array[i])
}
</code></pre> 
  <p>高级循环</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>String[] array = {"1", "2", "3"};

for (String text : array) {
    System.out.println(text);
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>val array = arrayListOf("1", "2", "3")

for (text in array) {
    println(text)
}
</code></pre> 
  <p>判断器</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>int count = 1;

switch (count) {
    case 0:
        System.out.println(count);
        break;
    case 1:
    case 2:
        System.out.println(count);
        break;
    default:
        System.out.println(count);
        break;
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>var count = 1

when (count) {
    0 -&gt; {
        println(count)
    }
    in 1..2 -&gt; {
        println(count)
    }
    else -&gt; {
        println(count)
    }
}
</code></pre> 
  <hr>
  <pre class="has">
<code>var count = 1

// 换种更简洁的写法
when (count) {
    0 -&gt; println(count)
    in 1..2 -&gt; println(count)
    else -&gt; println(count)
}
</code></pre> 
  <p>构造函数</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MyView extends View {

    public MyView(Context context) {
        this(context, null);
    }

    public MyView(Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public MyView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class MyView : View {

    constructor(context : Context) : this(context, null) {

    }

    constructor(context : Context, attrs : AttributeSet?) : this(context, attrs, 0) {

    }

    constructor(context : Context, attrs : AttributeSet?, defStyleAttr : Int) : super(context, attrs, defStyleAttr) {

    }
}
</code></pre> 
  <hr>
  <pre class="has">
<code>// 换种更简洁的写法
class MyView : View {

    constructor(context : Context) : this(context, null)

    constructor(context : Context, attrs : AttributeSet?) : this(context, attrs, 0)

    constructor(context : Context, attrs : AttributeSet?, defStyleAttr : Int) : super(context, attrs, defStyleAttr)
}
</code></pre> 
  <hr>
  <pre class="has">
<code>// 只有一种构造函数的还可以这样写
class MyView(context: Context?) : View(context) {

}
</code></pre> 
  <p>类创建</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class Person {

    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre> 
  <hr>
  <pre class="has">
<code>Person person = new Person("Android轮子哥", 100);
person.setName("HJQ");
person.setAge(50);
System.out.println("name: " + person.getName() + ", age: " + person.getAge());
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（如果不想暴露成员变量的set方法，可以将 var 改成 val )</p> 
  </blockquote> 
  <pre class="has">
<code>class Person {

    var name : String? = null
    get() = field
    set(value) {field = value}

    var age : Int = 0
    get() = field
    set(value) {field = value}
}
</code></pre> 
  <hr>
  <pre class="has">
<code>// 换种更简洁的写法
class Person(var name : String, var age : Int)
</code></pre> 
  <hr>
  <pre class="has">
<code>var person = Person("Android轮子哥", 100)
person.name = "HJQ"
person.age = 50
println("name: {$person.name}, age: {$person.age}")
</code></pre> 
  <p>私有化 set 方法</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class Person {

    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    private void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    private void setAge(int age) {
        this.age = age;
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class Person {

    var name : String? = null
    private set

    var age : Int = 0
    private set
}
</code></pre> 
  <p>私有化 get 方法</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class Person {

    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String getName() {
        return name;
    }

    private void setName(String name) {
        this.name = name;
    }

    private int getAge() {
        return age;
    }

    private void setAge(int age) {
        this.age = age;
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class Person {

    private var name : String? = null

    private var age : Int = 0
}
</code></pre> 
  <p>枚举</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>enum Sex {

    MAN(true), WOMAN(false);

    Sex(boolean isMan) {}
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>enum class Sex (var isMan: Boolean) {

    MAN(true), WOMAN(false)
}
</code></pre> 
  <p>接口</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public interface Callback {
    void onSuccess();
    void onFail();
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（Kotlin接口方法里面是可以自己实现，这里就不再演示了）</p> 
  </blockquote> 
  <pre class="has">
<code>interface Callback {
    fun onSuccess()
    fun onFail()
}
</code></pre> 
  <p>匿名内部类</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>new Callback() {

    @Override
    public void onSuccess() {
        
    }

    @Override
    public void onFail() {

    }
};
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>object:Callback {

    override fun onSuccess() {
        
    }

    override fun onFail() {
        
    }
}
</code></pre> 
  <p>内部类</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MainActivity extends AppCompatActivity {

    public class MyTask {

    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class MainActivity : AppCompatActivity() {

    inner class MyTask {
        
    }
}
</code></pre> 
  <p>内部类访问外部类同名变量</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>String name = "Android轮子哥";

public class MyTask {

    String name = "HJQ";

    public void show() {
        System.out.println(name + "---" + MainActivity.this.name);
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>var name = "Android轮子哥"

inner class MyTask {

    var name = "HJQ"

    fun show() {
        println(name + "---" + this@MainActivity.name)
    }
}
</code></pre> 
  <p>抽象类</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public abstract class BaseActivity extends AppCompatActivity implements Runnable {

    abstract void init();
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>abstract class BaseActivity : AppCompatActivity(), Runnable {

    abstract fun init()
}
</code></pre> 
  <p>静态变量和方法</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class ToastUtils {

    public static Toast sToast;

    public static void show() {
        sToast.show();
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法（在 Kotlin 将这种方式称之为伴生对象）</p> 
  </blockquote> 
  <pre class="has">
<code>companion object ToastUtils {

    var sToast : Toast? = null

    fun show() {
        sToast!!.show()
    }
}
</code></pre> 
  <p>可变参数</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public int add(int... array) {
    int count = 0;
    for (int i : array) {
        count += i;
    }
    return count;
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>fun add(vararg array: Int) : Int {
    var count = 0
    //for (i in array) {
    //    count += i
    //}
    array.forEach {
        count += it
    }
    return count
}
</code></pre> 
  <p>泛型</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class Bean&lt;T extends String&gt; {

    T data;
    public Bean(T t) {
        this.data = t;
    }
}
</code></pre> 
  <hr>
  <pre class="has">
<code>Bean&lt;String&gt; bean = new Bean&lt;&gt;("666666");
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class Bean&lt;T : Comparable&lt;String&gt;&gt;(t: T) {
    var data = t
}
</code></pre> 
  <hr>
  <pre class="has">
<code>var bean = Bean&lt;String&gt;("666666")
</code></pre> 
  <hr>
  <pre class="has">
<code>// 换种更简洁的写法
var bean = Bean("666666")
</code></pre> 
  <p>构造代码块</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MainActivity extends AppCompatActivity {

    int number;

    {
        number = 1;
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class MainActivity : AppCompatActivity() {

    var number = 0

    init {
        number = 1
    }
}
</code></pre> 
  <p>静态代码块</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>public class MainActivity extends AppCompatActivity {

    static int number;

    static {
        number = 1;
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>class MainActivity : AppCompatActivity() {

    companion object {
        
        var number = 0
        
        init {
            number = 1
        }
    }
}
</code></pre> 
  <p>方法代码块</p> 
  <blockquote> 
   <p>Java 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>void test(){
    {
        int a = 1;
    }
}
</code></pre> 
  <blockquote> 
   <p>Kotlin 的写法</p> 
  </blockquote> 
  <pre class="has">
<code>fun test() {
    run {
        var a =1
    }
}
</code></pre> 
  <p>可见修饰符</p> 
  <blockquote> 
   <p>Java 的写法（默认为 default）</p> 
  </blockquote> 
  <table>
   <thead>
    <tr>
     <th>修饰符</th> 
     <th>作用</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>public</td> 
     <td>所有类可见</td> 
    </tr>
    <tr>
     <td>protected</td> 
     <td>子类可见</td> 
    </tr>
    <tr>
     <td>default</td> 
     <td>同一包下的类可见</td> 
    </tr>
    <tr>
     <td>private</td> 
     <td>仅对自己类可见</td> 
    </tr>
   </tbody>
  </table>
  <blockquote> 
   <p>Kotlin 的写法（默认为 public）</p> 
  </blockquote> 
  <table>
   <thead>
    <tr>
     <th>修饰符</th> 
     <th>作用</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>public</td> 
     <td>所有类可见</td> 
    </tr>
    <tr>
     <td>internal</td> 
     <td>同 Module 下的类可见</td> 
    </tr>
    <tr>
     <td>protected</td> 
     <td>子类可见</td> 
    </tr>
    <tr>
     <td>private</td> 
     <td>仅对自己类可见</td> 
    </tr>
   </tbody>
  </table>
  <p><br> &nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
