<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Java 基础概念的一些总结 « NotBeCN</title>
  <meta name="description" content="                   好久没有做笔记整理了，最近一直在学 java， 也参加了一些相关的笔试面试，发现基础知识很重要，而这些基础的东西常常又是容易忘记或者说是不那么好完整定义的，所以花了点时间进行总结一下。 其中一些内容也是摘自网络和书上的，还有就是一些课堂上的记录，当然也有一些是自己理解总结的。...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/lanyandong_90137371.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Java 基础概念的一些总结</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-tomorrow-night"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>好久没有做笔记整理了，最近一直在学 java， 也参加了一些相关的笔试面试，发现基础知识很重要，而这些基础的东西常常又是容易忘记或者说是不那么好完整定义的，所以花了点时间进行总结一下。<br> 其中一些内容也是摘自网络和书上的，还有就是一些课堂上的记录，当然也有一些是自己理解总结的。好记性不如烂笔头，记录一下印象可能更深刻。</p> 
  <h3><a id="1__3"></a>1. 面向对象和面向过程的区别</h3> 
  <h4><a id="_5"></a>面向过程</h4> 
  <p><strong>优点：</strong> 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br> <strong>缺点：</strong> 没有面向对象易维护、易复用、易扩展</p> 
  <h4><a id="_10"></a>面向对象</h4> 
  <p><strong>优点：</strong> 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护<br> <strong>缺点：</strong> 性能比面向过程低</p> 
  <h3><a id="2_Java__17"></a>2. Java 语言有哪些特点</h3> 
  <blockquote> 
   <ol> 
    <li>平台无关性（ Java 虚拟机实现平台无关性）</li> 
    <li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）</li> 
    <li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）</li> 
    <li>编译与解释并存</li> 
   </ol> 
  </blockquote> 
  <h4><a id="JavaC_24"></a>Java和C++的区别</h4> 
  <blockquote> 
   <ul> 
    <li>都是面向对象的语言，都支持封装、继承和多态</li> 
    <li>Java 不提供指针来直接访问内存，程序内存更加安全</li> 
    <li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li> 
    <li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li> 
   </ul> 
  </blockquote> 
  <h3><a id="3__JDK__JRE_JVM__32"></a>3. JDK 、 JRE 、JVM 三者之间的联系与区别</h3> 
  <p><strong>JDK:</strong> 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。</p> 
  <p><strong>JRE:</strong> 普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。</p> 
  <p><strong>JVM：</strong> 当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是 java 程序可以一次编写多处执行的原因。</p> 
  <p><strong>区别与联系：</strong></p> 
  <blockquote> 
   <ol> 
    <li>JDK 用于开发，JRE 用于运行java程序</li> 
    <li>JDK 和 JRE 中都包含 JVM</li> 
    <li>JVM 是 Java 编程语言的核心并且具有平台独立性</li> 
   </ol> 
  </blockquote> 
  <h3><a id="4__46"></a>4. 采用字节码的好处</h3> 
  <p><strong>java 中的编译器和解释器：</strong></p> 
  <p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p> 
  <p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p> 
  <p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。</p> 
  <blockquote> 
   <p>Java 源代码----&gt;编译器----&gt;jvm 可执行的 Java 字节码(即虚拟指令)----&gt;jvm----&gt;jvm 中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</p> 
  </blockquote> 
  <p><strong>java 中的字节码：</strong></p> 
  <p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p> 
  <h3><a id="5__63"></a>5. 字符型常量和字符串常量的区别</h3> 
  <blockquote> 
   <ol> 
    <li>形式上: 字符常量是单引号引起的一个字符 ，字符串常量是双引号引起的若干个字符。</li> 
    <li>含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 ，字符串常量代表一个地址值(该字符串在内存中存放位置)。</li> 
    <li>占内存大小 字符常量只占2个字节，字符串常量占若干个字节(至少一个字符结束标志) (<strong>注意： char在Java中占两个字节</strong>)</li> 
   </ol> 
  </blockquote> 
  <h3><a id="6__69"></a>6. 什么是自动拆装箱？</h3> 
  <p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；<br> <strong>拆箱</strong>：将包装类型转换为基本数据类型；</p> 
  <p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p> 
  <h3><a id="7__78"></a>7. 重载和重写的区别</h3> 
  <p><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</p> 
  <p><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</p> 
  <h3><a id="8__86"></a>8. 封装、继承、多态</h3> 
  <h4><a id="_88"></a>封装</h4> 
  <p>封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</p> 
  <p>下面列出了使用封装的一些好处：</p> 
  <blockquote> 
   <p>通过隐藏对象的属性来保护对象内部的状态。<br> 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。<br> 禁止对象之间的不良交互提高模块化。</p> 
  </blockquote> 
  <h4><a id="_99"></a>继承</h4> 
  <p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。</p> 
  <p><strong>关于继承如下 3 点请记住：</strong></p> 
  <blockquote> 
   <ol> 
    <li>子类拥有父类非 private 的属性和方法。</li> 
    <li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li> 
    <li>子类可以用自己的方式实现父类的方法。</li> 
   </ol> 
  </blockquote> 
  <h4><a id="_109"></a>多态</h4> 
  <p>多态：相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。 对象的实例变量不具备多态性。</p> 
  <p>Java引用变量有两个类型：<strong>编译时类型</strong>，**运行时类型 **<br> 编译时类型由声明该变量时使用的类型决定 ，运行时类型由实际赋给该变量的对象决定 。如果编译时类型和运行时类型不一致，就可能出现多态（Polymorphism）</p> 
  <h4><a id="_115"></a>抽象</h4> 
  <p>抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。<br> 抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</p> 
  <h3><a id="9_String_StringBufferStringBuilder_121"></a>9. String 、StringBuffer、StringBuilder</h3> 
  <p><strong>可变性</strong></p> 
  <p>简单的来说：String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p> 
  <p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。</p> 
  <p><strong>线程安全性</strong></p> 
  <p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p> 
  <p><strong>性能</strong></p> 
  <p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p> 
  <p><strong>对于三者使用的总结：</strong></p> 
  <blockquote> 
   <ol> 
    <li>操作少量的数据 = String</li> 
    <li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li> 
    <li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li> 
   </ol> 
  </blockquote> 
  <h3><a id="10__148"></a>10. 没有参数的构造方法</h3> 
  <p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p> 
  <h3><a id="11__154"></a>11. 接口和抽象类的区别是什么</h3> 
  <blockquote> 
   <ol> 
    <li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法。</li> 
    <li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li> 
    <li>一个类可以实现多个接口，但最多只能实现一个抽象类</li> 
    <li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li> 
    <li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li> 
   </ol> 
  </blockquote> 
  <h3><a id="12__163"></a>12. 成员变量与局部变量的区别</h3> 
  <ol> 
   <li> <p>从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；</p> </li> 
   <li> <p>从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</p> </li> 
   <li> <p>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p> </li> 
   <li> <p>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。</p> </li> 
  </ol> 
  <h3><a id="13__175"></a>13. 构造方法有哪些特性</h3> 
  <ol> 
   <li>名字与类名相同；</li> 
   <li>没有返回值，但不能用void声明构造函数；</li> 
   <li>生成类的对象时自动执行，无需调用。</li> 
  </ol> 
  <h3><a id="14__182"></a>14. 静态方法和实例方法有何不同</h3> 
  <ol> 
   <li>在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li> 
   <li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制.</li> 
  </ol> 
  <h3><a id="15___equals_189"></a>15. == 与 equals</h3> 
  <p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型<code>==</code>比较的是值，引用数据类型<code>==</code>比较的是内存地址)。</p> 
  <p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p> 
  <ul> 
   <li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li> 
   <li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li> 
   <li>简单说就是没有重写的话比较的是对象地址，重写的话比较的是对象的内容。</li> 
  </ul> 
  <h3><a id="16_hashCode__equals_201"></a>16. hashCode 与 equals</h3> 
  <h4><a id="hashCode_203"></a>hashCode（）介绍</h4> 
  <p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p> 
  <p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p> 
  <h4><a id="_hashCode_209"></a>为什么要有 hashCode</h4> 
  <p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong></p> 
  <p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p> 
  <h4><a id="hashCodeequals_215"></a>hashCode（）与equals（）的相关规定</h4> 
  <blockquote> 
   <ol> 
    <li>如果两个对象相等，则hashcode一定也是相同的</li> 
    <li>两个对象相等,对两个对象分别调用equals方法都返回true</li> 
    <li>两个对象有相同的hashcode值，它们也不一定是相等的</li> 
    <li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li> 
    <li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li> 
   </ol> 
  </blockquote> 
  <h3><a id="17__226"></a>17. 简述程序、进程、线程的基本概念。</h3> 
  <p><strong>程序</strong> 是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p> 
  <p><strong>进程</strong> 是程序的一次执行过程，是程序运行的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。</p> 
  <p><strong>线程</strong> 与进程相似，但线程是一个比进程更小的执行单位（资源分配）。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p> 
  <p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p> 
  <h3><a id="18__238"></a>18. 线程有哪些基本状态？</h3> 
  <ol> 
   <li> <p><strong>新建(new)</strong>：新创建了一个线程对象。</p> </li> 
   <li> <p><strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。</p> </li> 
   <li> <p><strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。</p> </li> 
   <li> <p><strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，暂时停止运行。直到线程进入可运行状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：</p> 
    <blockquote> 
     <p>(一). 等待阻塞：运行的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。</p> 
     <p>(二). 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p> 
     <p>(三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p> 
    </blockquote> </li> 
   <li> <p><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p> </li> 
  </ol> 
  <h3><a id="19__final__254"></a>19. 关于 final 关键字</h3> 
  <p>final关键字主要用在三个地方：变量、方法、类。</p> 
  <ol> 
   <li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li> 
   <li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li> 
   <li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为fianl。</li> 
  </ol> 
  <h3><a id="20_Java__264"></a>20. Java 中的异常处理</h3> 
  <p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable类</strong>。它有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p> 
  <p><strong>Error（错误）:是程序无法处理的错误</strong><br> 表示运行应用程序中较严重问题。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p> 
  <p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。常见的异常类型有：</p> 
  <table> 
   <thead> 
    <tr> 
     <th></th> 
     <th></th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>Exception</td> 
     <td>异常层次结构的根类</td> 
    </tr> 
    <tr> 
     <td>ArithmeticException</td> 
     <td>算数错误情形</td> 
    </tr> 
    <tr> 
     <td>ArrayIndexOutOfBoundsException</td> 
     <td>数组下标越界</td> 
    </tr> 
    <tr> 
     <td>NullPointerException</td> 
     <td>尝试访问null对象成员</td> 
    </tr> 
    <tr> 
     <td>ClassNotFoundException</td> 
     <td>不能加载所需的类</td> 
    </tr> 
    <tr> 
     <td>InputMismatchException</td> 
     <td>欲得到的数据类型与实际输入的类型不匹配</td> 
    </tr> 
    <tr> 
     <td>IllegalArgumentException</td> 
     <td>方法接受到非法参数</td> 
    </tr> 
    <tr> 
     <td>ClassCastException</td> 
     <td>对象强制类型转换出错</td> 
    </tr> 
    <tr> 
     <td>NumberFormatException</td> 
     <td>数字格式转换异常</td> 
    </tr> 
   </tbody> 
  </table>
  <p><strong>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</strong></p> 
  <h4><a id="_288"></a>异常处理总结</h4> 
  <ul> 
   <li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li> 
   <li>catch 块：用于处理try捕获到的异常。</li> 
   <li>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</li> 
  </ul> 
  <p><strong>在以下4种特殊情况下，finally块不会被执行：</strong></p> 
  <ol> 
   <li>在finally语句块中发生了异常。</li> 
   <li>在前面的代码中用了System.exit()退出程序。</li> 
   <li>程序所在的线程死亡。</li> 
   <li>关闭CPU。</li> 
  </ol> 
  <h3><a id="21__302"></a>21. 同步方法和同步代码块的区别是什么？</h3> 
  <p>同步方法默认用this或者当前类class对象作为锁；</p> 
  <p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p> 
  <p>同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用 synchronized（object）{代码内容}进行修饰</p> 
  <h3><a id="22_Java_312"></a>22. Java集合类框架的基本接口有哪些？</h3> 
  <p>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：<br> Collection：代表一组对象，每一个对象都是它的子元素。<br> Set：不包含重复元素的Collection。<br> List：有顺序的collection，并且可以包含重复元素。<br> Map：可以把键(key)映射到值(value)的对象，键不能重复。</p> 
  <h3><a id="23_Java_320"></a>23. Java中的垃圾回收</h3> 
  <p>垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。</p> 
  <p>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p> 
  <p>System.gc()和Runtime.gc()这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p> 
  <p>如果对象的引用被置为null，垃圾收集器不会立即释放对象占用的内存，而是在下一个垃圾回收周期中，这个对象将被回收。</p> 
  <h3><a id="24_Java_332"></a>24. Java堆的结构是什么样子的？</h3> 
  <p>JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</p> 
  <p>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</p> 
  <h3><a id="25_Java_applet_340"></a>25. Java applet有哪些限制条件？</h3> 
  <p>主要是由于安全的原因，给applet施加了以下的限制：<br> applet不能够载入类库或者定义本地方法。<br> applet不能在宿主机上读写文件。<br> applet不能读取特定的系统属性。<br> applet不能发起网络连接，除非是跟宿主机。<br> applet不能够开启宿主机上其他任何的程序。</p> 
  <h3><a id="26_Servlet_351"></a>26. 什么是Servlet？</h3> 
  <p>Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。</p> 
  <p>所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。</p> 
  <p>对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet的destroy()方法把Servlet删除掉。</p> 
  <h4><a id="Servlet_359"></a>Servlet的生命周期</h4> 
  <p>Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。</p> 
  <blockquote> 
   <p>(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet</p> 
   <p>(2)创建：通过调用servlet构造函数创建一个servlet对象</p> 
   <p>(3)初始化：调用init方法初始化</p> 
   <p>(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求</p> 
   <p>(5)卸载：调用destroy方法让servlet自己释放其占用的资源。</p> 
  </blockquote> 
  <h3><a id="27_AppletServlet_375"></a>27. Applet和Servlet有什么区别？</h3> 
  <p>Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。</p> 
  <h3><a id="28_HTTP_381"></a>28. HTTP响应的结构是怎么样的？</h3> 
  <p>HTTP的<strong>请求报文</strong>的组成： 请求方法 + 请求的资源的URI + 协议版本 + 可选的请求首部字段 + 内容实体。</p> 
  <p>HTTP的<strong>响应报文</strong>的组成： 协议版本 + 状态码 + 用于解释状态码的原因短语 + 可选的响应首部字段 + 实体主体。</p> 
  <h3><a id="29_doGetdoPost_389"></a>29. doGet()方法和doPost()方法有什么区别？</h3> 
  <p>doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。<br> doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。</p> 
  <h3><a id="30_cookiesessioncookie_396"></a>30. 什么是cookie？session和cookie有什么区别？</h3> 
  <p>cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的状态。服务器还可以根据需要修改cookie的内容。</p> 
  <p>session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p> 
  <h3><a id="31_JSP_403"></a>31. 什么是JSP页面？</h3> 
  <p>jsp是java开发的专门用于动态显示页面的技术。jsp编译时，会首先编译成servlet文件，然后编译成class文件。包含9大内置对象：response、request、exception、out、application、pagecontext、config、session、page。有四个域对象：request、pagecontext、session、application 。</p> 
  <p>客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。</p> 
  <p>JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。</p> 
  <h3><a id="32_TCPUDP_413"></a>32. TCP和UDP的区别？</h3> 
  <p>答:TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br> TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br> TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br> TCP对应的协议和UDP对应的协议<br> <strong>TCP对应的协议：</strong></p> 
  <blockquote> 
   <p>（1）FTP：定义了文件传输协议，使用21端口。<br> （2）Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br> （3）SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br> （4）POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br> （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。</p> 
  </blockquote> 
  <p><strong>UDP对应的协议：</strong></p> 
  <blockquote> 
   <p>（1）DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br> （2）SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br> （3）TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p> 
  </blockquote> 
  <h3><a id="33_TCP_436"></a>33. TCP三次握手和四次挥手的全过程</h3> 
  <blockquote> 
   <p>三次握手：</p> 
   <ol> 
    <li>客户端发送SYN请求，进入SYN_SEND状态</li> 
    <li>服务端收到SYN请求，并返回一个ACK应答，并发送一个SYN其请求，服务器进入SYN_RECV状态</li> 
    <li>客户端收到服务端的SYN请求和ACK应答，发送ACK应答，客户端进入ESTABLISH状态，服务端收到应答后进入ESTABLISH。</li> 
   </ol> 
   <p>如果没有收到应答，数据包都会根据TCP的重传机制进行重传。</p> 
   <p>四次挥手：</p> 
   <ol> 
    <li>客户端发送FIN包，请求断开连接，客户端进入FIN_WAIT1状态</li> 
    <li>服务端收到FIN包后返回应答，进入CLOSE_WAIT状态</li> 
    <li>客户端收到FIN的应答后进入FIN_WAIT2状态</li> 
    <li>服务端发送FIN请求包，进入LAST_ACK状态</li> 
    <li>客户端收到FIN请求包后，发送应答进入TIME_WAIT状态</li> 
    <li>服务器收到ACK应答后，进入close状态。三次握手：</li> 
   </ol> 
  </blockquote> 
  <p>最后叨叨：因为是自己理解的笔记整理，可能会出现一些纰漏，请谨慎参考。现在类似这样的快餐贴也越来越多，可能一部分人也是出于记录的目的发帖，所以在参考时还是要客观判断，私以为想要系统地学习和掌握一门新的知识，还得回归书本和教程，然后亲自去实践。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
