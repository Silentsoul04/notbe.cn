<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>线程本地存储TLS详解 « NotBeCN</title>
  <meta name="description" content="                  博客的大部分原理转自：https://blog.csdn.net/zhangmiaoping23/article/details/44345341 本人自己把觉得自己需要的部分自己进行了综合。   TLS(Thread Local Storage)是为了多线程考虑其线程本身需要...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/qq_40890756_90139709.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">线程本地存储TLS详解</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>博客的大部分原理转自：<a href="https://blog.csdn.net/zhangmiaoping23/article/details/44345341" rel="nofollow">https://blog.csdn.net/zhangmiaoping23/article/details/44345341</a><br> 本人自己把觉得自己需要的部分自己进行了综合。</p> 
  <p>TLS(Thread Local Storage)是为了多线程考虑其线程本身需要维持一些状态而设置的一种机制.<br> TLS在概念上并不复杂。常规设计是将所有对TLS的访问都通过<strong>TEB中的指针</strong>来进行间接访问，<strong>TEB</strong>操作系统定义的每个线程一份的数据结构，用于保存一些线程相关的信息。使用Tls可以用<strong>隐式</strong>或者<strong>显式</strong>两种方式<br> kernel32有一组可以<strong>显式</strong>使用TLS的函数：TlsGetValue、TlsSetValue、TlsAlloc、TlsFree。通过名字就很容易知道他们的具体功能是干嘛的。TlsAlloc用于为要维持的变量分配空间，TlsSetValue设置变量的值。其他两个也是类似如此。<br> 由加载器、编译器和链接器来支持<strong>隐式</strong>使用线程局部存储，方法是在要维持状态的变量上加上_declspec(thread)，用隐式可以很方便的不需要通过显式调用TlsAlloc函数，而是由加载器自动根据变量个数来分配空间。</p> 
  <h2><a id="TLS_9"></a>TLS显式存储</h2> 
  <p>从实现来看，显式TLS API是目前两类实现TLS方法中较简单的一种，因此这种方法很少涉及内部实现的可变部分。正如我上次提到的，显式TLSAPI主要是4个函数。其中最重要的两个是<strong>TlsGetValue</strong>和<strong>TlsSetValue</strong>，分别负责设置和获取线程相关的数据。<br> 其背后的<strong>核心机制</strong>是他们是使用<strong>dwTlsIndex</strong>为索引来访问TEB中两个数组的“dumb accessors”（内部使用2个数组来实现：<strong>TlsSlots</strong>和<strong>TlsExpansionSlots</strong>，这两个函数用于根据索引访问这两个数组）</p> 
  <p>先看下TlsAlloc和TlsGetValue原型<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512122424140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaTFpZ2VsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512122513897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaTFpZ2VsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <pre><code class="prism language-c">LPVOID <span class="token function">TlsGetValue</span><span class="token punctuation">(</span>
  DWORD dwTlsIndex
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
  <p>可以看出在显式使用这些API的的时候，是通过index来访问这些变量的，下面看下他们的源码</p> 
  <pre><code class="prism language-c">LPVOID __stdcall <span class="token function">TlsGetValue</span><span class="token punctuation">(</span>_In_ DWORD dwTlsIndex<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       PTEB Teb <span class="token operator">=</span> <span class="token function">NtCurrentTeb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取Teb</span>
       Teb<span class="token operator">-&gt;</span>LastErrorValue<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//可以看到我们调用GetLastError的时候是从TEB的LastErrorValue中获取 错误值 的</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>dwTlsIndex <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">)</span>
              <span class="token comment">//64个指针大小的空间</span>
              <span class="token keyword">return</span> Teb<span class="token operator">-&gt;</span>TlsSlots<span class="token punctuation">[</span>dwTlsIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>dwTlsIndex<span class="token operator">&gt;=</span> <span class="token number">1088</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//440h</span>
              <span class="token comment">//总共有1088个slot，超出就错误了 所以最多只支持1088个tls变量</span>
              <span class="token function">SetLastError</span><span class="token punctuation">(</span>ERROR_INVALID_PARAMETER<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>Teb<span class="token operator">-&gt;</span>TlsExpansionSlots<span class="token punctuation">)</span><span class="token comment">//当 TlsIndex &gt;= 64的时候 会去TlsExpansionSlots这个数组里去寻找值</span>
              <span class="token keyword">return</span> Teb<span class="token operator">-&gt;</span>TlsExpansionSlots<span class="token punctuation">[</span>dwTlsIndex <span class="token operator">-</span> <span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token keyword">else</span>
              <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

 

BOOL __stdcall <span class="token function">TlsSetValue</span><span class="token punctuation">(</span>_In_ DWORD dwTlsIndex<span class="token punctuation">,</span> _In_ LPVOID lpTlsValue<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       PTEB Teb<span class="token operator">=</span> <span class="token function">NtCurrentTeb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//跟GetValue一样首先判断范围是否合理，假如 &lt; 64 那么将TlsSlots对应index的值设置为我们的指针</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span> dwTlsIndex <span class="token operator">&lt;</span> <span class="token number">64</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
              Teb<span class="token operator">-&gt;</span>TlsSlots<span class="token punctuation">[</span>dwTlsIndex<span class="token punctuation">]</span><span class="token operator">=</span> lpTlsValue<span class="token punctuation">;</span>
              <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>dwTlsIndex <span class="token operator">&gt;=</span> <span class="token number">1088</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token function">SetLastError</span><span class="token punctuation">(</span>ERROR_INVALID_PARAMETER<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token comment">//处理扩展Slot的情况</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>Teb<span class="token operator">-&gt;</span>TlsExpansionSlots <span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token comment">//第一次进入需要为扩展Slot分配内存</span>
              <span class="token function">RtlAcquirePebLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进行加锁处理</span>
              <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Teb<span class="token operator">-&gt;</span>TlsExpansionSlots<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//先判断是否存在TlsExpansionSlots</span>
                     LPVOIDTmp <span class="token operator">=</span> <span class="token function">RtlAllocateHeap</span><span class="token punctuation">(</span>Teb<span class="token operator">-&gt;</span>Peb<span class="token operator">-&gt;</span>ProcessHeap<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//若不存在 调用RtlAllocateHeap分出一块内存给TlsExpansionSlots使用</span>
                     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>
                            <span class="token comment">//资源不足</span>
                            <span class="token function">RtlReleasePebLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token function">SetLastError</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
                     <span class="token punctuation">}</span>
                     Teb<span class="token operator">-&gt;</span>TlsExpansionSlots<span class="token operator">=</span> <span class="token punctuation">(</span>PVOID<span class="token operator">*</span><span class="token punctuation">)</span>Tmp<span class="token punctuation">;</span><span class="token comment">//分配的空间首地址给TlsExpansionSlots</span>
              <span class="token punctuation">}</span>
              <span class="token function">RtlReleasePebLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放锁</span>
       <span class="token punctuation">}</span>
       Teb<span class="token operator">-&gt;</span>TlsExpansionSlots<span class="token punctuation">[</span>dwTlsIndex<span class="token operator">-</span> <span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> lpTlsValue<span class="token punctuation">;</span><span class="token comment">//将TlsExpansionSlots的值设置为我们的指针</span>
       <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
  <p>TlsSolts在 <strong>TEB</strong> 的0xe10的位置,TlsExpansionSlots在0xf94的位置<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512154920554.png" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512154948510.png" alt="在这里插入图片描述"></p> 
  <p>TlsAlloc和TlsFree的实现正如你想象的那样：它们获得一个锁，查找未分配的Tls槽（如果找到就返回槽的索引，否则告诉调用者没有空余的槽了）。如果最初的64个槽用完了（TlsSlots用完）且TlsExpansionSlots指针为NULL，则TlsAlloc将会分配<strong>1024个TLS槽</strong>（每个槽为<strong>指针大小 == sizeof(PVIOD)</strong>），将这块内存清0，然后更新TlsExpansionSlots，使其引用这块内存。<br> 在内部，TlsAlloc和TlsFree利用<strong>Rtl Bitmap</strong>来记录Tls槽的使用情况；bitmap中的每个位记录一个槽的使用情况（使用或未被使用）。这样既可以快速查找TLS槽的使用映射情况，同时节省了内存空间。</p> 
  <p><strong>当一个线程正常退出，如果TlsExpansionSlots指针已经分配了内存，它将被释放。（当然，如果线程调用TerminateThread结束，该块内存就leak了。这也是无数为什么你要远离TerminateThread的原因之一）。</strong></p> 
  <h2><a id="TLS_88"></a>TLS隐式存储</h2> 
  <p>编译器和链接器会搭配，将tls状态变量存放到.tls节中。在数据目录表中我们可以获取到它的RVA，但是首先我们先讲一下TLS目录的结构。<br> 通过fs:[0x2c]可以获取到TLS的指针<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512153816494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaTFpZ2VsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> TLS的结构</p> 
  <pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _IMAGE_TLS_DIRECTORY32 <span class="token punctuation">{</span>
    DWORD   StartAddressOfRawData<span class="token punctuation">;</span>　　　　<span class="token comment">//TLS初始化数据的起始地址</span>
    DWORD   EndAddressOfRawData<span class="token punctuation">;</span>　　　　　 <span class="token comment">//TLS初始化数据的结束地址 两个正好定位一个范围,范围放初始化的值</span>
    DWORD   AddressOfIndex<span class="token punctuation">;</span>              <span class="token comment">//TLS 索引的位置 </span>
    DWORD   AddressOfCallBacks<span class="token punctuation">;</span>          <span class="token comment">//PIMAGE_TLS_CALLBACK函数指针数组的地址。这里回调函数类型为PIMAGE_TLS_CALLBACK，TLS目录指向一个以NULL结尾的callbacks数组（这些函数将按顺序调用）。</span>
    DWORD   SizeOfZeroFill<span class="token punctuation">;</span>　　　　　　　　 <span class="token comment">//填充0的个数</span>
    DWORD 	Characteristic<span class="token punctuation">;</span>				<span class="token comment">//保留，目前设置为0</span>

<span class="token punctuation">}</span> IMAGE_TLS_DIRECTORY32<span class="token punctuation">;</span>
</code></pre> 
  <p><strong>AddressOfCallBacks</strong>是线程建立和退出时的回调函数，包括主线程和其他线程。一个线程被<strong>建立</strong>或被<strong>销毁</strong>后，<strong>列表中的回调函数会被调用</strong>。需要注意的是，TLS数据初始化和TLS回调函数是在<strong>入口点之前执行</strong>(这个具体的实现我会在以后的博客中会讲)。</p> 
  <p>注意：IMAGE_TLS_DIRECTORY结构中的地址是虚拟地址，而不是RVA。这说明了假如程序不是运行在期望地址上时<strong>会被重定位</strong>。</p> 
  <p>下面实战下：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512155523178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaTFpZ2VsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">看下文件偏移<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512155542485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaTFpZ2VsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512155631123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9uaTFpZ2VsLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>StartAddressOfRawData</strong>地址是0x403000,<strong>EndAddressOfRawData</strong>是0x403200,说明TLS初始化数据的范围大小是0x200。<strong>AddressOfIndex</strong>的位置是0x402030,<strong>AddressOfCallBacks</strong>是0x402000。</p> 
  <h2><a id="_118"></a>编译器和加载器所做的工作</h2> 
  <p>C运行时库中声明变量_tls_used的源代码位于tlssup.c文件中（与Visual Studio一起发布）。_tls_used标准的声明方式如下所示：</p> 
  <pre><code class="prism language-c"><span class="token function">_CRTALLOC</span><span class="token punctuation">(</span><span class="token string">".rdata$T"</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> IMAGE_TLS_DIRECTORY _tls_used <span class="token operator">=</span>
<span class="token punctuation">{</span>
       <span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span><span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span> <span class="token operator">&amp;</span>_tls_start<span class="token punctuation">,</span> <span class="token comment">// start of tls data</span>
       <span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span><span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span> <span class="token operator">&amp;</span>_tls_end<span class="token punctuation">,</span>  <span class="token comment">// end of tls data</span>
       <span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span><span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span> <span class="token operator">&amp;</span>_tls_index<span class="token punctuation">,</span> <span class="token comment">// address of tls_index</span>
       <span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span><span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>__xl_a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// pointer to call back array</span>
       <span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">,</span>                      <span class="token comment">//size of tls zero fill</span>
       <span class="token punctuation">(</span>ULONG<span class="token punctuation">)</span> <span class="token number">0</span>                       <span class="token comment">//characteristics</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
  <p>为了使用CRT提供的TLS回调支持，需要我们声明一个存放在以“.CRT$XLx“为名的节里面，这里x是一个位于A和Z之间的字母。例如，如下的代码片段：</p> 
  <pre><code class="prism language-c">  <span class="token macro property">#<span class="token directive keyword">pragma</span> section(“.CRT$XLY”,long,read)</span>
    <span class="token keyword">extern</span> “C” <span class="token function">__declspec</span><span class="token punctuation">(</span><span class="token function">allocate</span><span class="token punctuation">(</span>“<span class="token punctuation">.</span>CRT$XLY”<span class="token punctuation">)</span><span class="token punctuation">)</span>
    PIMAGE_TLS_CALLBACK _xl_y <span class="token operator">=</span> MyTlsCallback<span class="token punctuation">;</span>
</code></pre> 
  <p>需要如此奇怪的节名是因为TLS回调指针需要进行内存排序的原因。为了理解这种特殊声明的作用，需要首先明白编译器和链接器是如何组织PE文件中的数据的。<br> PE文件中，除了头部数据，其它均是分不同节存储的，节就是具有相同属性（也保护属性）集合的内存区域。关键字__declspec(allocate(“section-name”))告诉编译器（这里应该是链接器，原文有错，下同，但仍然按原文翻译）在最终PE文件中其作用域内的内容放在指定的节内。编译器额外支持<strong>将相似名字的节合并为一个大节</strong>的功能。该功能通过使用<strong>节名前缀+$+任意字符串 的形式来激活</strong>。编译器将<strong>合并具有相同节名前缀的节</strong>为<strong>一个大节</strong>。</p> 
  <p>编译器对于相似节<strong>采用字典顺序进行合并</strong>（对<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi mathvariant="normal">
          后
         </mi>
         <mi mathvariant="normal">
          的
         </mi>
         <mi mathvariant="normal">
          字
         </mi>
         <mi mathvariant="normal">
          符
         </mi>
         <mi mathvariant="normal">
          串
         </mi>
         <mi mathvariant="normal">
          进
         </mi>
         <mi mathvariant="normal">
          行
         </mi>
         <mi mathvariant="normal">
          排
         </mi>
         <mi mathvariant="normal">
          序
         </mi>
         <mi mathvariant="normal">
          ）
         </mi>
         <mi mathvariant="normal">
          。
         </mi>
         <mi mathvariant="normal">
          这
         </mi>
         <mi mathvariant="normal">
          意
         </mi>
         <mi mathvariant="normal">
          味
         </mi>
         <mi mathvariant="normal">
          着
         </mi>
         <mi mathvariant="normal">
          在
         </mi>
         <mi mathvariant="normal">
          内
         </mi>
         <mi mathvariant="normal">
          存
         </mi>
         <mi mathvariant="normal">
          中
         </mi>
         <mi mathvariant="normal">
          ，
         </mi>
         <mi mathvariant="normal">
          位
         </mi>
         <mi mathvariant="normal">
          于
         </mi>
         <mi mathvariant="normal">
          节
         </mi>
         <mi mathvariant="normal">
          “
         </mi>
         <mi mathvariant="normal">
          .
         </mi>
         <mi>
          C
         </mi>
         <mi>
          R
         </mi>
         <mi>
          T
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         后的字符串进行排序）。这意味着在内存中，位于节“.CRT
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">排</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">味</span><span class="mord cjk_fallback">着</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">节</span><span class="mord">“</span><span class="mord">.</span><span style="margin-right: 0.07153em;" class="mord mathit">C</span><span style="margin-right: 0.00773em;" class="mord mathit">R</span><span style="margin-right: 0.13889em;" class="mord mathit">T</span></span></span></span></span>XLB”中的变量将在位于节“.CRT<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          X
         </mi>
         <mi>
          L
         </mi>
         <mi>
          A
         </mi>
         <mi mathvariant="normal">
          ”
         </mi>
         <mi mathvariant="normal">
          中
         </mi>
         <mi mathvariant="normal">
          变
         </mi>
         <mi mathvariant="normal">
          量
         </mi>
         <mi mathvariant="normal">
          位
         </mi>
         <mi mathvariant="normal">
          置
         </mi>
         <mi mathvariant="normal">
          的
         </mi>
         <mi mathvariant="normal">
          后
         </mi>
         <mi mathvariant="normal">
          面
         </mi>
         <mi mathvariant="normal">
          ，
         </mi>
         <mi mathvariant="normal">
          但
         </mi>
         <mi mathvariant="normal">
          是
         </mi>
         <mi mathvariant="normal">
          在
         </mi>
         <mi mathvariant="normal">
          位
         </mi>
         <mi mathvariant="normal">
          于
         </mi>
         <mi mathvariant="normal">
          节
         </mi>
         <mi mathvariant="normal">
          “
         </mi>
         <mi mathvariant="normal">
          .
         </mi>
         <mi>
          C
         </mi>
         <mi>
          R
         </mi>
         <mi>
          T
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         XLA”中变量位置的后面，但是在位于节“.CRT
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.07847em;" class="mord mathit">X</span><span class="mord mathit">L</span><span class="mord mathit">A</span><span class="mord">”</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">节</span><span class="mord">“</span><span class="mord">.</span><span style="margin-right: 0.07153em;" class="mord mathit">C</span><span style="margin-right: 0.00773em;" class="mord mathit">R</span><span style="margin-right: 0.13889em;" class="mord mathit">T</span></span></span></span></span>XLZ”中的变量的前面。C运行时库利用编译器的这一特性来<strong>创建一个以NULL结尾的TLS回调数组</strong>（将节“.CRT<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      <math>
       <semantics>
        <mrow>
         <mi>
          X
         </mi>
         <mi>
          L
         </mi>
         <mi>
          Z
         </mi>
         <mi mathvariant="normal">
          ”
         </mi>
         <mi mathvariant="normal">
          中
         </mi>
         <mi mathvariant="normal">
          放
         </mi>
         <mi mathvariant="normal">
          置
         </mi>
         <mi mathvariant="normal">
          一
         </mi>
         <mi mathvariant="normal">
          个
         </mi>
         <mi>
          N
         </mi>
         <mi>
          U
         </mi>
         <mi>
          L
         </mi>
         <mi>
          L
         </mi>
         <mi mathvariant="normal">
          指
         </mi>
         <mi mathvariant="normal">
          针
         </mi>
         <mi mathvariant="normal">
          ）
         </mi>
         <mi mathvariant="normal">
          。
         </mi>
         <mi mathvariant="normal">
          因
         </mi>
         <mi mathvariant="normal">
          此
         </mi>
         <mi mathvariant="normal">
          为
         </mi>
         <mi mathvariant="normal">
          了
         </mi>
         <mi mathvariant="normal">
          保
         </mi>
         <mi mathvariant="normal">
          证
         </mi>
         <mi mathvariant="normal">
          声
         </mi>
         <mi mathvariant="normal">
          明
         </mi>
         <mi mathvariant="normal">
          的
         </mi>
         <mi mathvariant="normal">
          函
         </mi>
         <mi mathvariant="normal">
          数
         </mi>
         <mi mathvariant="normal">
          指
         </mi>
         <mi mathvariant="normal">
          针
         </mi>
         <mi mathvariant="normal">
          位
         </mi>
         <mi mathvariant="normal">
          于
         </mi>
         <mi>
          T
         </mi>
         <mi>
          L
         </mi>
         <mi>
          S
         </mi>
         <mi mathvariant="normal">
          回
         </mi>
         <mi mathvariant="normal">
          调
         </mi>
         <mi mathvariant="normal">
          数
         </mi>
         <mi mathvariant="normal">
          组
         </mi>
         <mi mathvariant="normal">
          内
         </mi>
         <mi mathvariant="normal">
          部
         </mi>
         <mi mathvariant="normal">
          ，
         </mi>
         <mi mathvariant="normal">
          必
         </mi>
         <mi mathvariant="normal">
          须
         </mi>
         <mi mathvariant="normal">
          将
         </mi>
         <mi mathvariant="normal">
          它
         </mi>
         <mi mathvariant="normal">
          放
         </mi>
         <mi mathvariant="normal">
          在
         </mi>
         <mi mathvariant="normal">
          节
         </mi>
         <mi mathvariant="normal">
          “
         </mi>
         <mi mathvariant="normal">
          .
         </mi>
         <mi>
          C
         </mi>
         <mi>
          R
         </mi>
         <mi>
          T
         </mi>
        </mrow>
        <annotation encoding="application/x-tex">
         XLZ”中放置一个NULL指针）。因此为了保证声明的函数指针位于TLS回调数组内部，必须将它放在节“.CRT
        </annotation>
       </semantics>
      </math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span style="margin-right: 0.07847em;" class="mord mathit">X</span><span class="mord mathit">L</span><span style="margin-right: 0.07153em;" class="mord mathit">Z</span><span class="mord">”</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">置</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span style="margin-right: 0.10903em;" class="mord mathit">N</span><span style="margin-right: 0.10903em;" class="mord mathit">U</span><span class="mord mathit">L</span><span class="mord mathit">L</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">针</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">声</span><span class="mord cjk_fallback">明</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">针</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">于</span><span style="margin-right: 0.13889em;" class="mord mathit">T</span><span class="mord mathit">L</span><span style="margin-right: 0.05764em;" class="mord mathit">S</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">部</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">必</span><span class="mord cjk_fallback">须</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">节</span><span class="mord">“</span><span class="mord">.</span><span style="margin-right: 0.07153em;" class="mord mathit">C</span><span style="margin-right: 0.00773em;" class="mord mathit">R</span><span style="margin-right: 0.13889em;" class="mord mathit">T</span></span></span></span></span>XLx”中。</p> 
  <p>编译器和链接器将会自动为所有的__declspec(thread)变量放置在默认段.tls段，在最终的PE文件中这些变量将会被放置在_tls_start和_tls_end中间。下面看下它的实现</p> 
  <pre><code class="prism language-c"><span class="token comment">/* Special symbols to mark start and end of ThreadLocal Storage area. */</span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> data_seg(".tls")</span>

<span class="token macro property">#<span class="token directive keyword">if</span> defined (_M_IA64) || defined (_M_AMD64)</span>
<span class="token function">_CRTALLOC</span><span class="token punctuation">(</span><span class="token string">".tls"</span><span class="token punctuation">)</span>
<span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment">/*defined (_M_IA64) || defined (_M_AMD64) */</span>

<span class="token keyword">char</span> _tls_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">pragma</span> data_seg(".tls$ZZZ")</span>

<span class="token macro property">#<span class="token directive keyword">if</span> defined (_M_IA64) || defined (_M_AMD64)</span>
<span class="token function">_CRTALLOC</span><span class="token punctuation">(</span><span class="token string">".tls$ZZZ"</span><span class="token punctuation">)</span>
<span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment">/*defined (_M_IA64) || defined (_M_AMD64) */</span>

<span class="token keyword">char</span> _tls_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">pragma</span> data_seg()</span>
</code></pre> 
  <p>可以看到_tls_start是被放到了节最开始的位置，而_tls_end被放置在了.tls$ZZZ，即最后一个Section，这样在合并为同一个大区的时候，_tls_start和_tls_end就正好表示了开始和结束的地址（因为TLS存储局部变量是存放在连续地址上的）。<br> 现在我们知道了在语言层次上__declspec(thread)是如何来工作的，接下来有必要了解下编译器产生的访问__declspec(thread)变量的支持代码。幸运的是这些支持代码非常直观。考虑如下测试程序：</p> 
  <pre><code class="prism language-c"> <span class="token function">__declspec</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> <span class="token keyword">int</span> threadedint <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> ac<span class="token punctuation">,</span>wchar_t<span class="token operator">*</span><span class="token operator">*</span>av<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	threadedint <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
  <p><strong>编译</strong>产生的x64汇编代码如下：</p> 
  <pre><code class="prism language-c"> mov ecx<span class="token punctuation">,</span>DWORD PTR _tls_index

mov rax<span class="token punctuation">,</span>QWORD PTR gs<span class="token punctuation">:</span><span class="token number">58</span>h<span class="token comment">//ThreadLocalStoragePointer的位置</span>

mov edx<span class="token punctuation">,</span>OFFSET FLAT<span class="token punctuation">:</span>threadedint

mov rax<span class="token punctuation">,</span>QWORD PTR <span class="token punctuation">[</span>rax<span class="token operator">+</span>rcx<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token comment">//ThreadLocalStoragePointer[index]</span>

mov DWORD PTR<span class="token punctuation">[</span>rdx<span class="token operator">+</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">42</span>
</code></pre> 
  <p>但是，如果我们在运行时查看代码将会是下面这个样子：</p> 
  <pre><code class="prism language-c">mov     ecx<span class="token punctuation">,</span>cs<span class="token punctuation">:</span>_tls_index

mov     rax<span class="token punctuation">,</span>gs<span class="token punctuation">:</span><span class="token number">58</span>h

mov     edx<span class="token punctuation">,</span><span class="token number">4</span>

mov     rax<span class="token punctuation">,</span><span class="token punctuation">[</span>rax<span class="token operator">+</span>rcx<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">]</span>

mov     dword ptr <span class="token punctuation">[</span>rdx<span class="token operator">+</span>rax<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span>Ah <span class="token punctuation">;</span> <span class="token number">42</span>

xor     eax<span class="token punctuation">,</span>eax
</code></pre> 
  <p>可以发现“threadedint”变量被解析成了一个小值（4）。回忆在单独编译时，mov edx，4指令对应mov edx，OFFSET FLAT:threadedint。<br> 现在，4不是一个平坦地址（我们希望的是一个范围位于可执行文件使用范围的地址）发生了什么事情了？<br> ok，原来这里链接器玩了一个小把戏。当链接器解析对__declspec(thread)变量的引用时，将偏移假定为相对于.tls节的起始位置。如果检查PE文件中的.tls段，事情将变得更清晰：</p> 
  <pre><code class="prism language-c"><span class="token number">0000000001007000</span> _tls segment para public <span class="token string">'DATA'</span>use64

<span class="token number">0000000001007000</span>      assume cs<span class="token punctuation">:</span>_tls

<span class="token number">0000000001007000</span>    <span class="token punctuation">;</span>org <span class="token number">1007000</span>h

<span class="token number">0000000001007000</span> _tls_start        dd <span class="token number">0</span>

<span class="token number">0000000001007004</span> <span class="token punctuation">;</span> <span class="token keyword">int</span> threadedint

<span class="token number">0000000001007004</span> <span class="token operator">?</span>threadedint@@<span class="token number">3</span>HA dd <span class="token number">0</span>

<span class="token number">0000000001007008</span> _tls_end          dd <span class="token number">0</span>
</code></pre> 
  <p>“threadedint”相对于.tls节起始位置的偏移确实是4，所以使用_declsprc(thread)声明的变量的时候，使用变量的地址解析成tls变量的偏移了，那么它又是怎么使用这个偏移的呢？<br> 这里诀窍就藏在接下来的三条指令当中：</p> 
  <pre><code class="prism language-c">mov     ecx<span class="token punctuation">,</span>cs<span class="token punctuation">:</span>_tls_index

mov     rax<span class="token punctuation">,</span>gs<span class="token punctuation">:</span><span class="token number">58</span>h

mov     rax<span class="token punctuation">,</span><span class="token punctuation">[</span>rax<span class="token operator">+</span>rcx<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">]</span>
</code></pre> 
  <p>这三条指令获取TEB中ThreadLocalStoragePointer的值并用_tls_index来索引其指向的空间。获得指针代表的地址在使用threadedint进行索引来合成一个完成的访问该线程所有threadedint变量的地址。<br> （其实可以这样认为：对于每个线程都有新分配了一块和.tls同样大小的内存，用ThreadLocalStoragePointer引用，这样该变量的值和偏移加起来就是变量的地址了。其实就是ThreadLocalStoragePointer[_tls_index]指向的是这个线程的tls变量的存储地址，加上某个tls变量的偏移就是指向本变量所拥有的空间了）。<br> 采用C描述，编译器产生的代码将是下面的样子,用c描述后真的非常的通俗易懂鸭：</p> 
  <pre><code class="prism language-c"><span class="token comment">// This represents the ".tls" section</span>
<span class="token keyword">struct</span> _MODULE_TLS_DATA
<span class="token punctuation">{</span>
   inttls_start<span class="token punctuation">;</span>
   intthreadedint<span class="token punctuation">;</span>
   inttls_end<span class="token punctuation">;</span>
<span class="token punctuation">}</span> MODULE_TLS_DATA<span class="token punctuation">,</span> <span class="token operator">*</span> PMODULE_TLS_DATA<span class="token punctuation">;</span>

PTEB Teb<span class="token punctuation">;</span>
PMODULE_TLS_DATA TlsData<span class="token punctuation">;</span>
Teb <span class="token operator">=</span> <span class="token function">NtCurrentTeb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
TlsData <span class="token operator">=</span> Teb<span class="token operator">-&gt;</span>ThreadLocalStoragePointer<span class="token punctuation">[</span>_tls_index <span class="token punctuation">]</span><span class="token punctuation">;</span>
TlsData<span class="token operator">-&gt;</span>threadedint <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre> 
  <p>从代码生成角度来看，隐式TLS变量的工作机制存在一条额外的曲线。你可能注意到示例中为X64版本中访问__declspec(thread)变量的代码；这是因为默认情况下，X86在构建exe文件时包含一个特殊的优化选项（/GA,Optimize for Windows Application,也许是有史以来编译器选项名字中最烂的一个），该优化假定_tls_index为0从而消除了对其的引用过程(这样加快了对线程局部变量的访问)。</p> 
  <p>该优化仅仅对进程的主模块起作用（一般是exe文件）。该假定成立的原因是加载器按照模块加载顺序为_tls_index指定序列值，而<strong>主模块将在第二个被加载</strong>，ntdll是<strong>第一个加载的</strong>模块（显然ntdll中不能使用__declspec(thread)变量，否则该模块将是0索引，即_tls_index值为0）。值得注意的是，在exe具有导出函数且使用了__declspec(thread)变量时，该优化将会导致应用程序随机崩溃。</p> 
  <p>以备参考，当/GA选项开启时，X86版编译生成如下指令：</p> 
  <pre><code class="prism language-c">mov     eax<span class="token punctuation">,</span>large fs<span class="token punctuation">:</span><span class="token number">2</span>Ch

mov     ecx<span class="token punctuation">,</span><span class="token punctuation">[</span>eax<span class="token punctuation">]</span>

mov     dwordptr <span class="token punctuation">[</span>ecx<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span>Ah <span class="token punctuation">;</span> <span class="token number">42</span>
</code></pre> 
  <p>记得在X86系统中，fs的基地址引用TEB的首地址，ThreadLocalStoragePointer所在的偏移为0x2C。<br> 注意这里并没有对_tls_index的引用；编译器假定使用0值。如果是X86平台下构建dll，该优化始终是关闭的，_tls_index将如之前那样来使用。<br> 但是，__declspec(thread)变量背后的事情远不是编译器和链接器能搞定的。某某仍然需要为每个线程分配存储空间，这个某某就是加载器。</p> 
  <h2><a id="_271"></a>加载器所做的工作</h2> 
  <p>上次说了编译器和链接器为访问__declspec(thread)扩展类变量所使用的生成代码的机制。尽管此时它们已经为隐式TLS布置了舞台，但为了使整体能够工作，仍然需要加载器这个组件来提供必需的运行时支持。</p> 
  <p>具体的，加载器将负责为每个模块分配TLS索引值，为每个线程的TEB中的ThreadLocalStoragePointer分配内存空间。此外加载器还需要为每个模块分配TLS存储空间。</p> 
  <ol> 
   <li><strong>进程初始化阶段</strong>，为变量_tls_index分配索引值，确定每个模块所需的TLS空间内存的大小，然后调用TLS和DLL初始化函数（同一模块，<strong>先调用TLS初始化函数</strong>，<strong>后调用DllMain初始化函数</strong>）(这里说的我会在我以后的博客详细说明，这篇文章并没有代码讲解)。</li> 
   <li>在<strong>线程初始化阶段</strong>，为<strong>每一个</strong>使用了TLS的模块<strong>分配TLS内存</strong>并初始化，根据使用TLS的模块数目<strong>为当前线程分配ThreadLocalStoragePointer数组</strong>，然后将各个模块的TLS内存和ThreadLocalStoragePointer数组中的<strong>对应项相关联</strong>。然后为当前线程<strong>调用TLS初始化函数</strong>和<strong>DLLMain初始化函数</strong>。</li> 
   <li>在线程终止的时候，调用<strong>TLS初始化函数</strong>和<strong>DLLMain函数</strong>（根据参数确定是线程终止），<strong>释放</strong>当前线程中每个模块对应的<strong>TLS内存</strong>，然后<strong>释放ThreadLocalStoragePointer数组</strong>。</li> 
   <li>在进程终止时，也调用TLS和DLlmain初始化函数（可以把它们看成dwReason对应的不同值，我们在处理dwReason的时候不是会进行switch，分别在线程开始，结束，进程开始，结束时的对应处理函数吗，这里也就是类似的结果，不过每次是先进行TLS的初始化，然后是DllMain）。</li> 
  </ol> 
  <p>除了进程初始化以外，其它大部分操作都非常直观。进程初始化主要是由ntdll中的<strong>LdrpInitializeTls</strong>和<strong>LdrpAllocateTls</strong>两个例程来完成的。<br> 当所有静态连接的dll文件被载入之后，所有其它初始化例程被调用之前，<strong>LdrpInitializeTls被调用</strong>（说明优先级比较高，是关键的部分）。基本上，该函数要遍历<strong>所有加载模块</strong>，为每一个具有有效TLS目录的模块统计出它使用的TLS内存的大小。<strong>对每一个使用了TLS的模块，会分配一个数据结构来记录该模块所使用的TLS内存大小并为其分配的索引号（_tls_used）</strong>。（早在Xp系统中，LDR_DATA_TABLE_ENTRY结构中的TlsIndex域貌似就没有使用了。而在WINME系统中将该值误用为模块的TLS索引，因此假定该值为-1在WINME系统中是不可靠的）</p> 
  <p>使用了TLS的模块在调用LdrpInitializeProcess(即LdrPEStartup)的过程中将被标记为始终位于内存当中（这种模块的LoadCount值为0xFFFF）。实际中，这个不是什么问题，因为这种模块必须是静态链接的或是被主模块隐式依赖，不可能中途退场。</p> 
  <p>在函数LdrpInitializeTls为模块<strong>分类了TLS索引</strong>之后，将调用LdrpAllocateTls为初始线程<strong>初始化TLS值</strong>。</p> 
  <p>这时，进程继续初始化，最后每个模块的TLS初始化和DLLmain初始化函数会被调用。（注意应用程序主模块可以有多个TLS回调函数，但是没有DLLmain函数）</p> 
  <p>一个有意思的事情是同一个DLL模块的TLS初始化函数始终在DLL初始化函数之前调用。（这个过程按顺序进行，例如先A.dll的TLS初始化，A.dll的DLLmain初始化，B.dll的TLS初始化，B.dll的Dllmain初始化，以此类推）。这意味着在TLS初始化函数中要慎重使用CRT的函数（(as the C runtime is initialized before the user’s DllMain routineis called, by the actual DLL initializer entrypoint, such that the CRT will notbe initialized when a TLS initializer for the module is invoked).）。这将非常危险，因为<strong>全局数据还没有被创建</strong>；除非导入被跳过，否则模块将处于一个完全未初始化的状态。</p> 
  <p>另一个值得一提的有关加载器对TLS支持的方面是PE文件格式标准中，IMAGE_TLS_DIRECTORY结构中的SizeOfZeroFill域并没有被链接器和加载器使用。<strong>这意味着在现实中，所有TLS模板数据都将初始化，TLS内存块的大小不像PE文件格式标准所陈述的的那样包含域SizeOfZeroFill</strong>。</p> 
  <p>一些软件滥用TLS回调来用于反调试的目的（通过创建一个TLS回调项来在入口函数获得执行权之前执行代码），虽然可以，<strong>但是实际中这点将非常明显，因为大部分PE文件都不会使用TLS回调。</strong></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
