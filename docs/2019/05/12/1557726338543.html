<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>多进程与多线程 « NotBeCN</title>
  <meta name="description" content="                  多线程   导入线程模块   import threading   线程对象的创建   创建一个线程，指向的函数，不接收参数的情况   t = threading.Thread（target=函数名）   创建一个线程，指向的函数，收参数的情况   t = threading....">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726338543.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">多进程与多线程</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="_0"></a>多线程</h1> 
  <h2><a id="_1"></a>导入线程模块</h2> 
  <pre><code>import threading
</code></pre> 
  <h2><a id="_7"></a>线程对象的创建</h2> 
  <p>创建一个线程，指向的函数，不接收参数的情况</p> 
  <pre><code>t = threading.Thread（target=函数名）
</code></pre> 
  <p>创建一个线程，指向的函数，收参数的情况</p> 
  <pre><code>t = threading.Thread（target=函数名, args=(实参1,)）
</code></pre> 
  <h2><a id="_21"></a>运行线程对象</h2> 
  <pre><code>线程对象名.start()
</code></pre> 
  <h2><a id="__27"></a>## 主线程与子线程的关系</h2> 
  <p>生命周期</p> 
  <p>我们的py文件运行起来的时候，就会有一个主线程</p> 
  <p>当子线程对象创建后，当子线程对象运行时，才会创造出来新的线程，叫做子线程</p> 
  <p>子线程如果代码没有运行结束，主线程是会等待子线程的</p> 
  <p>直接子线程全部运行完毕</p> 
  <p>主线程才会结束</p> 
  <h1><a id="_42"></a>多进程</h1> 
  <h2><a id="_44"></a>导入多进程模块</h2> 
  <pre><code>import multiprocessing
</code></pre> 
  <h2><a id="_48"></a>创建一个进程对象</h2> 
  <pre><code>p = multiprocessing.Process（target=函数名）
</code></pre> 
  <h2><a id="_52"></a>运行进程对象</h2> 
  <pre><code>进程对象名.start()
</code></pre> 
  <h2><a id="_56"></a>进程对象等待连接</h2> 
  <pre><code>进程对象名.join()
# 当代码运行到这里时，解释器会判断进程对象是否已执行完成
# 如果没有执行完成，代码会卡住，直到该进程执行完成，才会执行后面的代码
</code></pre> 
  <h2><a id="id_62"></a>查看进程的id</h2> 
  <p>查看当前进程的id</p> 
  <pre><code>os.getpid()
</code></pre> 
  <p>通过进程对象查</p> 
  <pre><code>进程对象.id
</code></pre> 
  <p>查看当前进程的父进程id</p> 
  <pre><code>os.getppid()
</code></pre> 
  <p>判断进程对象p是否存活</p> 
  <pre><code>p.is_alive
</code></pre> 
  <h1><a id="_85"></a>进程与线程的关系</h1> 
  <h2><a id="_87"></a>进程的主要功能</h2> 
  <p>分配资源</p> 
  <h2><a id="_91"></a>线程的主要功能</h2> 
  <p>执行任务</p> 
  <h2><a id="_95"></a>包含关系</h2> 
  <p>进程包含线程</p> 
  <p>每开一个进程出来，都必然会有一个主线程</p> 
  <p>进程提供了资源（内存空间）</p> 
  <p>线程主要执行任务</p> 
  <h1><a id="_106"></a>进程与线程的比较</h1> 
  <p>多线程可以共享全局变量<br> 多进程不可以共享全局变量</p> 
  <h1><a id="_110"></a>线程锁</h1> 
  <ul> 
   <li> <p>功能</p> <p>解决多个线程同时使用全局变量，有可能会造成的数据的混乱</p> </li> 
  </ul> 
  <h2><a id="_115"></a>使用线程锁</h2> 
  <ul> 
   <li>创建锁<br> <code>锁对象 = threading.Lock()</code></li> 
   <li>上锁<br> <code>锁对象.acquire()</code></li> 
   <li>需要上锁的代码块</li> 
   <li>解锁<br> <code>锁对象.release()</code></li> 
  </ul> 
  <h1><a id="_124"></a>进程锁</h1> 
  <ul> 
   <li>创建锁<br> <code>锁对象 = multiprocessing.Lock()</code></li> 
  </ul> 
  <p>使用方法与线程锁相同</p> 
  <h1><a id="_131"></a>信号量</h1> 
  <p>Semaphore是同时允许一定数量的线程更改数据</p> 
  <ul> 
   <li>创建对象</li> 
  </ul> 
  <pre><code>信号量对象 = multiprocessing.Semaphore(钥匙的数量)
</code></pre> 
  <ul> 
   <li> <p>使用</p> 
    <ul> 
     <li> <p>获得-从面版上拿</p> <pre><code>信号量对象.acquire()
</code></pre> </li> 
     <li> <p>释放-归还到面版上</p> <pre><code>信号量对象.release()
</code></pre> </li> 
    </ul> </li> 
  </ul> 
  <h1><a id="_151"></a>进程间通信</h1> 
  <h2><a id="_153"></a>队列</h2> 
  <p>创建队列对象</p> 
  <pre><code>队列对象 = multiprocessing.Queue(容量)
</code></pre> 
  <ul> 
   <li> <p>传送数据</p> <pre><code>队列对象.put(数据)
</code></pre> <p>阻塞的情况：当队列已经被塞满数据时，就会阻塞。无法put放入数据。当队列中有空位置时，就会解阻塞。</p> </li> 
   <li> <p>接收数据</p> <pre><code>数据 = 队列对象.get()
</code></pre> <p>阻塞的情况：当队列空了，出不了数据了，就会阻塞。直到队列中有新数据时，会解阻塞。</p> </li> 
   <li> <p>接收数据，且不等待</p> <pre><code>数据 = 队列对象.get_nowait()
</code></pre> <p>如果队列中有数据，可以获得，如果队列中无数据，那就报错。</p> </li> 
  </ul> 
  <h2><a id="joinablequeue_176"></a>可等待的队列joinablequeue</h2> 
  <ul> 
   <li> <p>特点</p> 
    <ul> 
     <li>比普通的进程队列功能增强，多了task_done与join方法</li> 
    </ul> </li> 
   <li> <p>用法</p> 
    <ul> 
     <li> <p>创建</p> <pre><code>jq = multiprocessing.JoinableQueue(容量)
</code></pre> </li> 
     <li> <p>取数据时</p> <pre><code>jq.get()
jq.task_done()
</code></pre> <p>取出数据后一定要调一下task_done()，否则计数不减的话，join()无法感知</p> </li> 
     <li> <p>等待连接</p> <pre><code>jq.join()
</code></pre> <p>当队列中有数据时会阻塞，当队列中的数据计数为零时，会解阻塞</p> </li> 
    </ul> </li> 
  </ul> 
  <h2><a id="_210"></a>事件</h2> 
  <ul> 
   <li> <p>创建事件对象</p> <pre><code>事件对象 = multiprocessing.Event()
</code></pre> <p>理解为，制定了一个行动计划</p> </li> 
   <li> <p>等待行动指令</p> <pre><code>事件对象.wait(）
</code></pre> </li> 
   <li> <p>开始行动</p> <pre><code>事件对象.set()
</code></pre> </li> 
   <li> <p>取消行动，继续回归到等待状态（潜伏状态）</p> <pre><code>事件对象.clear()
</code></pre> </li> 
   <li> <p>判断当前的事件状态</p> <pre><code>事件对象.is_set()
</code></pre> </li> 
  </ul> 
  <h2><a id="Manager_239"></a>进程Manager</h2> 
  <p>功能</p> 
  <blockquote> 
   <p>数据同步，无需接收与传递参数，数据变化自动同步</p> 
  </blockquote> 
  <p>用法</p> 
  <ul> 
   <li> <p>创建对象</p> <pre><code>m = multiprocessing.Manager()
</code></pre> </li> 
   <li> <p>调用方法获得特殊的数据对象</p> <pre><code>data = m.dict({"num": 0})
</code></pre> </li> 
   <li> <p>数据对象进行传递并可在另一进程内修改数据</p> </li> 
  </ul> 
  <p>注意</p> 
  <ul> 
   <li>子进程要join一下，在主进程中要join一下，否则会报错</li> 
   <li>多个子进程同时修改数据会发生数据冲突，解决办法，加进程锁</li> 
  </ul> 
  <h2><a id="_262"></a>进程池</h2> 
  <ul> 
   <li> <p>优点：提升效率，减少开劈进程与销毁进程的时间开销</p> </li> 
   <li> <p>用法：</p> 
    <ul> 
     <li> <p>创建对象</p> <pre><code>进程池对象 = multiprocessing.Pool(池子的数量)
</code></pre> </li> 
     <li> <p>两种执行方式</p> 
      <ul> 
       <li>同步</li> 
      </ul> <pre><code>r = 进程池.apply(函数名， args=(参数1，))
</code></pre> <p>可以让函数直接跑起来的，但是是同步的。<br> 同步模式运行，代码效率低下<br> 返回值r 就是函数的返回值</p> 
      <ul> 
       <li>异步的</li> 
      </ul> <pre><code>  r = 进程池.apply_async（函数名， args(参数1，))
</code></pre> 
      <ul> 
       <li>异步模式运行，真异步模式，主进程不等待子进程</li> 
       <li>如果希望主进程等待子进程，办法如下： 
        <ul> 
         <li> <p>pool.close（），让进程池对象的入口关闭，不再接收任务进来</p> </li> 
         <li> <p>pool.join()， 让进程池对象等待池子队列中的任务执行。未完成阻塞，完成后解阻塞<br> 例：</p> <pre><code>     import multiprocessingimport time
     
	def func(n):
    	print(n)
    	time.sleep(1)
    	
	if __name__ == '__main__':
		p = multiprocessing.Pool(3)
		
		for i in range(10):
	    	p.apply_async(func, args=(i,))
	    	
	    p.close()
	    p.join()
</code></pre> 
          <ul> 
           <li>如果希望主进程等待子进程，另一种办法如下： 
            <ul> 
             <li>接收 pool.apply_async()对象</li> 
            </ul> </li> 
          </ul> <pre><code>      import multiprocessing
      import time
      
      
      def func(n):
          print(n)
          time.sleep(1)
      
      if __name__ == '__main__':
          p = multiprocessing.Pool(3)
      
          ret_list = []
          for i in range(10):
              ret = p.apply_async(func, args=(i,))
              ret_list.append(ret)
      
          for ret in ret_list:
              ret.get()
</code></pre> </li> 
        </ul> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
