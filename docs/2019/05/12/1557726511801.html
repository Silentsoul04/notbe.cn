<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>计算机网络第四弹——网络层 « NotBeCN</title>
  <meta name="description" content="          彩蛋   计算机网络谢希仁第七版原版ppt获取方式：公众号后台回复”N3“即可获取。   由于公众号不支持显示LaTeX公式且公众号排版混乱，建议大家关注微信公众号"IT工匠"，后台回复"N4-3"获取xmind源文件以及本文原文pdf文件获取更佳阅读体验。   本文主要内容：      网络...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/1557726511801.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">计算机网络第四弹——网络层</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1>彩蛋</h1> 
  <p><strong>计算机网络谢希仁第七版原版ppt获取方式：公众号后台回复”N3“即可获取。</strong></p> 
  <p><strong>由于公众号不支持显示LaTeX公式且公众号排版混乱，建议大家关注微信公众号"IT工匠"，后台回复"N4-3"获取xmind源文件以及本文原文pdf文件获取更佳阅读体验。</strong></p> 
  <p><strong>本文主要内容：</strong></p> 
  <p><img alt="计算机网络第四弹——网络层" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2ylm3tficj31cy0u04qp.jpg"></p> 
  <p>网络层主要负责把运输层产生的<strong>报文段(TCP)</strong>或<strong>用户数据报(UDP)</strong>封装成<strong>分组</strong>或<strong>包</strong>进行传送。</p> 
  <p>在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做<strong>IP数据报</strong>，或简称为<strong>数据报</strong>。</p> 
  <h2 id="-2">网络层提供的两种服务</h2> 
  <p>在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。 争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？针对这一点，有两种观点：</p> 
  <p>1：让网络负责可靠交付</p> 
  <p>2：网络提供数据报服务</p> 
  <h3 id="-3">让网络负责可靠交付——虚电路服务</h3> 
  <p>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应<strong>模仿电信网络</strong>，使用<strong>面向连接</strong>的通信方式。 通信之前先建立<strong>虚电路 (Virtual Circuit)</strong>，以保证双方通信所需的一切网络资源。 如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复，如图1-1所示：</p> 
  <p><img alt="image-20190511163727019" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xpsdglfaj30zu0egaca.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图1-1:H1 发送给 H2 的所有分组都沿着同一条虚电路传送</p> 
  <p>&nbsp;</p> 
  <p>虚电路表示这只是一条<strong>逻辑</strong>上的连接，分组都沿着这条<strong>逻辑连接</strong>按照存储转发方式传送，而并不是真正建立了一条物理连接。 请注意，电路交换的电话通信是先建立了一条真正的连接。 因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</p> 
  <h3 id="-4">网络提供数据报服务——数据报服务</h3> 
  <p>互联网的先驱者提出了一种崭新的网络设计思路。 网络层向上只提供<strong>简单灵活的、无连接的</strong>、<strong>尽最大努力交付</strong>的数据报服务。 网络在发送分组时<strong>不需要先建立连接</strong>。<strong>每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号</strong>）。 网络层不提供服务质量的承诺。即<strong>所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限</strong>，如图1-2所示：</p> 
  <p><img alt="image-20190511164039937" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xgvf33tbj30zu0egafu.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图1-2：H1 发送给 H2 的分组可能沿着不同路径传送</p> 
  <p>&nbsp;</p> 
  <p>由于传输网络<strong>不提供端到端的可靠传输服务</strong>，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。 如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的<strong>运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。 采用这种设计思路的好处是：<strong>网络的造价大大降低，运行方式灵活，能够适应多种应用</strong>。 互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</p> 
  <h3 id="-5">虚电路服务与数据报服务的对比</h3> 
  <table>
   <thead>
    <tr>
     <th><strong>对比的方面</strong></th> 
     <th><strong>虚电路服务</strong></th> 
     <th><strong>数据报服务</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>思路</strong></td> 
     <td><strong>可靠通信应当由网络来保证</strong></td> 
     <td><strong>可靠通信应当由用户主机来保证</strong></td> 
    </tr>
    <tr>
     <td><strong>连接的建立</strong></td> 
     <td><strong>必须有</strong></td> 
     <td><strong>不需要</strong></td> 
    </tr>
    <tr>
     <td><strong>终点地址</strong></td> 
     <td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td> 
     <td><strong>每个分组都有终点的完整地址</strong></td> 
    </tr>
    <tr>
     <td><strong>分组的转发</strong></td> 
     <td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td> 
     <td><strong>每个分组独立选择路由进行转发</strong></td> 
    </tr>
    <tr>
     <td><strong>当结点出故障时</strong></td> 
     <td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td> 
     <td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td> 
    </tr>
    <tr>
     <td><strong>分组的顺序</strong></td> 
     <td><strong>总是按发送顺序到达终点</strong></td> 
     <td><strong>到达终点时不一定按发送顺序</strong></td> 
    </tr>
    <tr>
     <td><strong>端到端的差错处理和流量控制</strong></td> 
     <td><strong>可以由网络负责，也可以由用户主机负责</strong></td> 
     <td><strong>由用户主机负责</strong></td> 
    </tr>
   </tbody>
  </table>
  <h2 id="ip">网际协议IP</h2> 
  <p><strong>网际协议 IP</strong> 是 TCP/IP 体系中两个最主要的协议之一。 与 IP 协议配套使用的还有三个协议：</p> 
  <ol>
   <li><strong>地址解析协议 ARP (Address Resolution Protocol)</strong></li> 
   <li><strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong></li> 
   <li><strong>网际组管理协议 IGMP (Internet Group Management Protocol)</strong></li> 
  </ol>
  <p>图2-1画出了这三种协议与网际协议IP的关系：</p> 
  <p><img alt="image-20190511165034613" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2xpsbzhx8j30zu0eg76v.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-1：网际协议IP及其配套协议</p> 
  <p>&nbsp;</p> 
  <p>可以看到，在网络层中，ARP画在最下面，因为IP经常要使用这个协议，ICMP和IGMP画在这一层的上部，因为他们要使用IP协议。这三个协议在后面会做介绍。由于网际协议IP是用来使互联起来的许多计算机网络能够进行通信的，因此TCP/IP体系中的网络层常常被称为<strong>网际层</strong>或<strong>IP层</strong>。使用网际层是为了强调这是由很多网络构成的互联网络。</p> 
  <p>在介绍网际协议IP之前，必须先了解一下什么是<strong>虚拟互联网络</strong>。</p> 
  <h3 id="-6">虚拟互联网络</h3> 
  <p>将网络互连并能够互相通信，会遇到许多问题需要解决，如：</p> 
  <ol>
   <li>不同的寻址方案</li> 
   <li>不同的最大分组长度</li> 
   <li>不同的网络接入机制</li> 
   <li>不同的超时控制</li> 
   <li>不同的差错恢复方法</li> 
   <li>不同的状态报告方法</li> 
   <li>不同的路由选择技术</li> 
   <li>不同的用户接入控制</li> 
   <li>不同的服务（面向连接服务和无连接服务）</li> 
   <li>不同的管理与控制方式等</li> 
  </ol>
  <p>没有一种单一的网络能够适应所有用户的需求，要将异构的网络互相连接起来，需要使用一些中间设备。 中间设备又称为<strong>中间系统</strong>或<strong>中继 (relay)系</strong>统。 有以下五种不同的中间设备：</p> 
  <ol>
   <li><strong>物理层</strong>中继系统：<strong>转发器 (repeater)</strong>。</li> 
   <li><strong>数据链路层</strong>中继系统：<strong>网桥</strong>&nbsp;或&nbsp;<strong>桥接器 (bridge)</strong>。</li> 
   <li><strong>网络层</strong>中继系统：<strong>路由器 (router)</strong>。</li> 
   <li><strong>网桥</strong>和<strong>路由器</strong>的混合物：<strong>桥路器 (brouter)</strong>。</li> 
   <li><strong>网络层以上</strong>的中继系统：<strong>网关 (gateway)</strong>。</li> 
  </ol>
  <p>当中继系统是<strong>转发器</strong>或<strong>网桥</strong>时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。 <strong>网关</strong>由于比较复杂，目前使用得较少。 <strong>网络互连都是指用路由器进行网络互连和路由选择</strong>，路由器其实就是一台<strong>专用计算机</strong>，用来在互联网中进行路由选择。<strong>由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为网关。</strong></p> 
  <p>可能很多读者觉得这里的<strong>"网络互连"</strong>和<strong>"网络扩大"</strong>很抽象，我们来举个例子：</p> 
  <p><img alt="image-20190511180457961" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xjb44ms1j30zu0egwlm.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-2：IP网的概念</p> 
  <p>&nbsp;</p> 
  <p>如图2-2(a)表示有许多计算机网络通过一些<strong>路由器</strong>进行互连。由于参加互连的计算机网络都是用相应的<strong>网际协议IP</strong>，因此可以把互连以后的计算机网络看成如图2-2(b)所示的一个<strong>虚拟互联网络</strong>。所谓<strong>虚拟互联网络</strong>也就是<strong>逻辑互联网络</strong>，他的意思就是互连起来的各种物理网络的<strong>异构性本来是客观存在的</strong>，但是我们<strong>利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络</strong>，这种使用IP协议的互联网络可简称为IP网。使用IP网的好处是当IP网上的主机进行通信时，就<strong>好像在一个单个网络上通信一样</strong>，它们看不见互连的各网络的<strong>具体异构细节</strong>(如具体的<strong>编址方案</strong>、<strong>路由选择协议</strong>，等等)。如果在这种覆盖全球的Ip网的上层使用<strong>Tcp协议</strong>，那么就是现在的<strong>互联网(Internet)</strong>。</p> 
  <p><img alt="image-20190511181509897" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xjlqk9waj31020h046x.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-3：分组在互联网中的传送</p> 
  <p>&nbsp;</p> 
  <p>当很多<strong>异构网络</strong>通过路由器互连起来时，如果所有的网络都使用相同的IP协议，那在网络层讨论问题就显得很方便。现在用一个例子来说明。</p> 
  <p>在图4-4所示的互联网中的源主机H1,要把一个IP数据报发送给目的主机H2。根据<strong>分组交换的存储转发</strong>概念，主机H1,先要查找自己的路由表，看目的主机是否在本网络上。如是，则不需要经过任何路由器而是直接交付，任务就完成了。如不是，则须把IP数据报发送给某个路由器(图中的R1)。R1在査找自己的路由表后，知道应当数据报转发给R2进行<strong>间接交付</strong>。这样一直转发下去，最后由路由器R5知道自己是和H2 接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报直接交付目的主机H2。图中画出了<strong>源主机</strong>、<strong>目的主机</strong>以及各<strong>路由器的协议栈</strong>。我们注意到，<strong>主机的协议栈有五层</strong>，但<strong>路由器的协议栈只有下三层</strong>。图中还画出了数据在各协议栈中流动的方向(用红色线表示)。我们还可注意到，在R4和R5之间使用了<strong>卫星链路</strong>，而R5所连接的是个<strong>无局域网</strong>。在R1到R4之间的三个网络则可以是<strong>任意类型的网络</strong>。总之，这里强调的是<strong>互联网可以由多种异构网络互连组成</strong>。如果我们只从网络层考虑问题，那么IP数据报就可以想象是在网络层中传送，其传送的路径就如图2-4所示：</p> 
  <p><img alt="image-20190511182004486" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2xjqu7h5ej31020bq41c.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-4:只从网络层考虑IP数据报的传送路径</p> 
  <p>&nbsp;</p> 
  <p>这样就不必画出许多完整的协议栈，使问题的描述更加简单。有了<strong>虚拟互连网络</strong>的概念后，我们再讨论在这样的虚拟网络上如何寻址。</p> 
  <h3 id="ip-1">分类的IP地址</h3> 
  <p>在 TCP/IP 体系中，<strong>IP 地址</strong>是一个最基本的概念。</p> 
  <p>IP地址及其表示方法</p> 
  <p>我们把整个互联网看成为一个单一的、抽象的网络， <strong>IP 地址</strong>就是给<strong>每个连接在互联网上的主机（或路由器）</strong>分配一个在<strong>全世界范围是唯一的 32 位的标识符</strong>。 IP 地址现在由<strong>互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers)</strong>进行分配。</p> 
  <p>IP地址的编址方法共经历过了三个历史阶段：</p> 
  <ol>
   <li><strong>分类的 IP 地址</strong>。这是<strong>最基本的编址方法</strong>，在1981年就通过了相应的标准协议。</li> 
   <li><strong>子网的划分</strong>。这是对最基本的编址方法的改进，其标准[RFC 950]在1985年通过。</li> 
   <li><strong>构成超网</strong>。这是比较新的<strong>无分类</strong>编址方法。1993年提出后很快就得到推广应用。</li> 
  </ol>
  <p>本节只讨论<strong>最基本的分类的IP地址</strong>，后两种将在下一节"划分子网和构造超网"讨论。</p> 
  <p>所谓的"分类的IP地址"就是将IP地址划分为<strong>若干个固定类</strong>。 每一类地址都由<strong>两个固定长度的字段</strong>组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的<strong>网络</strong>，而另一个字段则是<strong>主机号 host-id</strong>，它标志该<strong>主机（或路由器）</strong>。 主机号在它前面的<strong>网络号所指明的网络范围内</strong>必须是唯一的。 由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>，这种两级的IP地址可以记为： $$ IP地址::={&lt;网络号&gt;,&lt;主机号&gt;} $$ 式(1)中的$::=$表示<strong>"定义为"</strong>，图2-5给出了各种IP地址的网络号字段和主机号字段，这里的A类、B类、C类地址都是<strong>单播地址(一对一通信)</strong>，是最常用的。</p> 
  <p><img alt="image-20190511182958179" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2xk14zx68j31020f0gp7.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-5：IP地址中的网络号字段和主机号字段</p> 
  <p>&nbsp;</p> 
  <p>从上图可以看到：</p> 
  <ol>
   <li>A类、B类和C类地址的网络号字段(在图中这个字段是灰色的)分别为1个、2个和3个字节长，而在网络号字段的最前面有1～3位的类别位，其数值分别规定为0, 10 和 110.</li> 
   <li>A类、B类和C类地址的主机号字段分别为3个、2个和1个字节长。</li> 
   <li>D类地址(前4位是1110)用于多播(一对多通信)。我们将在IPV6节讨论IP多播。</li> 
   <li>E类地址(前4位是1111)保留为以后用。</li> 
  </ol>
  <p><strong>点分十进制记法：</strong></p> 
  <p><img alt="image-20190511183618645" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2xk7qeddsj30zu0euafl.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-6：点分十进制法能够提高可读性</p> 
  <p>&nbsp;</p> 
  <p><strong>易知A、B、C、D、E类地址的高8位分别为：</strong></p> 
  <ol>
   <li>A类：0xxxxxxx，表示的十进制范围为0——127</li> 
   <li>B类：10xxxxxx，表示的十进制范围为128——191</li> 
   <li>C类：110xxxxx，表示的十进制范围为192——223</li> 
   <li>D类：1110xxxx，表示的十进制范围为224——239</li> 
   <li>E类：1111xxxx，表示的十进制范围为240——255</li> 
  </ol>
  <p><strong>把Ip地址分为A、B、C三个类别的原因：</strong></p> 
  <p>各种网络的差异很大，有的网络拥有很多主机，而有的网络的主机则很少，把IP地址划分为A、B、C类是为了更好地满足不同用户的要求，当某个单位申请到一个IP地址时，实际上是获得了<strong>具有同样网络号</strong>的一块地址，其中具体的<strong>各台主机号则由该单位自行分配</strong>，只要做到在<strong>该单位管辖的范围内无重复的主机号即可</strong>。</p> 
  <p>常用的3中IP地址</p> 
  <table>
   <thead>
    <tr>
     <th><strong>网络</strong><strong>类别</strong></th> 
     <th><strong>最大可指派</strong><strong>的网络数</strong></th> 
     <th><strong>第一个可指派的</strong><strong>网络号</strong></th> 
     <th><strong>最后一个可指派的</strong><strong>网络号</strong></th> 
     <th><strong>每个网络中</strong><strong>最大主机数</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>A</strong></td> 
     <td>$126 (2^7– 2) $</td> 
     <td><strong>1</strong></td> 
     <td><strong>126</strong></td> 
     <td><strong>16777214</strong></td> 
    </tr>
    <tr>
     <td><strong>B</strong></td> 
     <td>$16383 (2^{14} – 1)$</td> 
     <td><strong>128.1</strong></td> 
     <td><strong>191.255</strong></td> 
     <td><strong>65534</strong></td> 
    </tr>
    <tr>
     <td><strong>C</strong></td> 
     <td>$ 2097151 (2^{21}– 1)$</td> 
     <td><strong>192.0.1</strong></td> 
     <td><strong>223.255.255</strong></td> 
     <td><strong>254</strong></td> 
    </tr>
   </tbody>
  </table>
  <p><strong>一般不适用的特殊IP地址：</strong></p> 
  <table>
   <thead>
    <tr>
     <th><strong>网络号</strong></th> 
     <th><strong>主机号</strong></th> 
     <th><strong>源地址</strong><strong>使用</strong></th> 
     <th><strong>目的地址</strong><strong>使用</strong></th> 
     <th><strong>代表的意思</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>0</strong></td> 
     <td><strong>0</strong></td> 
     <td><strong>可以</strong></td> 
     <td><strong>不可</strong></td> 
     <td><strong>在本网络上的本主机（见</strong>&nbsp;<strong>6.6</strong>&nbsp;<strong>节</strong><strong>DHCP</strong>&nbsp;<strong>协议）</strong></td> 
    </tr>
    <tr>
     <td><strong>0</strong></td> 
     <td><strong>host-id</strong></td> 
     <td><strong>可以</strong></td> 
     <td><strong>不可</strong></td> 
     <td><strong>在本网络上的某台主机</strong>&nbsp;<strong>host-id</strong></td> 
    </tr>
    <tr>
     <td><strong>全</strong>&nbsp;<strong>1</strong></td> 
     <td><strong>全</strong>&nbsp;<strong>1</strong></td> 
     <td><strong>不可</strong></td> 
     <td><strong>可以</strong></td> 
     <td><strong>只在本网络上进行广播（各路由器均不转发）</strong></td> 
    </tr>
    <tr>
     <td><strong>net-id</strong></td> 
     <td><strong>全</strong>&nbsp;<strong>1</strong></td> 
     <td><strong>不可</strong></td> 
     <td><strong>可以</strong></td> 
     <td><strong>对</strong>&nbsp;<strong>net-id</strong>&nbsp;<strong>上的所有主机进行广播</strong></td> 
    </tr>
    <tr>
     <td><strong>127</strong></td> 
     <td><strong>非全</strong>&nbsp;<strong>0</strong>&nbsp;<strong>或全</strong>&nbsp;<strong>1</strong><strong>的任何数</strong></td> 
     <td><strong>可以</strong></td> 
     <td><strong>可以</strong></td> 
     <td><strong>用于本地软件环回测试</strong></td> 
    </tr>
   </tbody>
  </table>
  <p><strong>IP地址的一些重要特点：</strong></p> 
  <ol>
   <li> <p>IP 地址是一种<strong>分等级</strong>的地址结构。分两个等级的好处是：</p> <p>第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</p> <p>第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</p> </li> 
   <li> <p>实际上 IP 地址是标志一个<strong>主机（或路由器）</strong>和<strong>一条链路</strong>的接口。 当一个主机同时连接到两个网络上时，该主机就必须同时具有<strong>两个相应的 IP 地址</strong>，其<strong>网络号 net-id 必须是不同的</strong>。这种主机称为<strong>多归属主机 (multihomed host)</strong>。 由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</p> </li> 
   <li> <p>用<strong>转发器</strong>或<strong>网桥</strong>连接起来的若干个局域网仍为一个网络，因此这些局域网都<strong>具有同样的网络号 net-id</strong>。</p> </li> 
   <li> <p>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是<strong>平等</strong>的。</p> </li> 
  </ol>
  <p><strong>互联网中的IP地址：</strong></p> 
  <p><img alt="image-20190511203852409" class="has" src="https://ws4.sinaimg.cn/large/006tNc79gy1g2xpscjke1j30pu0eg778.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-7：互联网中的IP地址1</p> 
  <p>&nbsp;</p> 
  <p>在同一个<strong>局域网上</strong>的主机或路由器的 <strong>IP 地址中的网络号必须是一样的</strong>。 图2-7中的网络号就是 IP 地址中的 net-id。</p> 
  <p><img alt="image-20190511204102243" class="has" src="https://ws4.sinaimg.cn/large/006tNc79gy1g2xntk3v3dj30pu0eggsu.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-8：互联网中的IP地址2</p> 
  <p>&nbsp;</p> 
  <p>如图2-8所示，路由器总是具有两个或两个以上的IP地址，路由器的每一个接口都有一个不同网络号的IP地址。</p> 
  <p>两个路由器直接相连的接口处，可指明也可不指明IP地址，如指明IP地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” ，现在常不指明IP地址。</p> 
  <h3 id="ip-3">IP地址与硬件地址</h3> 
  <p>IP 地址与硬件地址是不同的地址。 从层次的角度看， <strong>硬件地址（或物理地址）</strong>是<strong>数据链路层</strong>和<strong>物理层</strong>使用的地址。 <strong>IP 地址</strong>是<strong>网络层</strong>和<strong>以上各层</strong>使用的地址，是一种<strong>逻辑地址</strong>（称 IP 地址是逻辑地址是因为 IP 地址是用<strong>软件实现</strong>的），IP 地址放在 <strong>IP 数据报</strong>的首部，而硬件地址则放在 <strong>MAC 帧</strong>的首部。如图2-9所示。</p> 
  <p><img alt="image-20190511204608395" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2xnytp19bj30ss0b641u.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-9:IP地址与硬件地址的区别</p> 
  <p>&nbsp;</p> 
  <p>这里需要注意这几点：</p> 
  <ol>
   <li>在IP层抽象的互联网上只能看到IP数据报</li> 
   <li>虽然在IP数据报首部有源站IP地址，但是路由器只根据目的站的IP地址的<strong>网络号</strong>进行路由选择</li> 
   <li>在局域网的链路层，只能看到MAC帧</li> 
   <li>IP 层抽象的互联网屏蔽了下层很复杂的细节。 在抽象的网络层上讨论问题，就能够使用 统一的、抽象的 IP 地址 研究主机和主机或主机和路由器之间的通信 。</li> 
  </ol>
  <h3 id="arp">地址解析协议ARP</h3> 
  <p>通信时我们主要使用了两个地址： IP 地址（网络层地址）和 MAC 地址（数据链路层地址），那么当我们知道 IP地址，如何知道器MAC地址呢？ARP协议就是为了解决这个问题而存在的。</p> 
  <p><img alt="image-20190511205346624" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xo6ropkxj30le09ogmx.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-10：ARP协议的作用</p> 
  <p>&nbsp;</p> 
  <p>如图2-10，ARP协议的作用是<strong>从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址</strong>。</p> 
  <p>ARP协议的要点</p> 
  <p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。 每一个主机都设有一个 <strong>ARP 高速缓存 (ARP cache)</strong>，里面有<strong>所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表</strong>，这个映射表的每一行格式如下： $$ &lt; IP address；MAC address；TTL &gt; $$ 其中<strong>TTL (Time To Live)</strong>为<strong>地址映射有效时间</strong> 。</p> 
  <p><img alt="image-20190511210235228" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xofxubb0j30yi0gs7c2.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-11：ARP请求的过程</p> 
  <p>&nbsp;</p> 
  <p>ARP请求的过程如图2-11所示，当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 <strong>ARP 高速缓存</strong>中查看有无主机 B 的 IP 地址：</p> 
  <ol>
   <li>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</li> 
   <li>如没有，&nbsp;<strong>ARP 进程</strong>在本局域网上<strong>广播发送一个 ARP 请求分组</strong>。<strong>收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</strong></li> 
  </ol>
  <p><strong>ARP请求分组</strong>：包含<strong>发送方硬件地址</strong> - <strong>发送方 IP 地址</strong> - <strong>目标方硬件地址(未知时填 0)</strong> -<strong>目标方 IP 地址</strong>。</p> 
  <p><strong>本地</strong>广播 ARP 请求（<strong>路由器不转发ARP请求</strong>）。</p> 
  <p><strong>ARP 响应分组</strong>：包含<strong>发送方硬件地址</strong> - <strong>发送方 IP地址</strong> - <strong>目标方硬件地址</strong> - <strong>目标方 IP 地址</strong>。</p> 
  <p><strong>ARP 分组封装在物理网络的帧中传输。</strong></p> 
  <p>ARP高速缓存的作用</p> 
  <ol>
   <li>存放最近获得的 IP 地址到 MAC 地址的绑定，以<strong>减少 ARP 广播的数量</strong>。</li> 
   <li>为了<strong>减少网络上的通信量</strong>，主机 A 在<strong>发送其 ARP 请求分组时</strong>，就<strong>将自己的 IP 地址到硬件地址的映射</strong>写入 ARP 请求分组。</li> 
   <li>当主机 B 收到 A 的 ARP 请求分组时，就<em>将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存</em>中。这对<strong>主机 B 以后向 A 发送数据报</strong>时就更方便了。</li> 
  </ol>
  <p><strong>注意：</strong></p> 
  <ol>
   <li>ARP 用于解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。</li> 
   <li>如果所要找的主机和源主机<strong>不在同一个局域网</strong>上，那么就要通过 ARP 找到一个位于本局域网上的某个<strong>路由器的硬件地址</strong>，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</li> 
   <li>从&nbsp;<strong>IP 地址到硬件地址</strong>的解析是<strong>自动进行</strong>的，主机的用户对这种地址解析过程是不知道的。</li> 
   <li>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，<strong>ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址</strong>。</li> 
  </ol>
  <p>ARP请求的四种常见场景</p> 
  <ol>
   <li>发送方是<strong>主机</strong>，要把 IP 数据报发送到<strong>本网络上的另一个主机</strong>。这时用 ARP 找到目的主机的硬件地址。</li> 
   <li>发送方是<strong>主机</strong>，要把 IP 数据报发送到<strong>另一个网络上的一个主机</strong>。这时用 ARP 找到本网络上的一个<strong>路由器</strong>的硬件地址。剩下的工作由这个路由器来完成。</li> 
   <li>发送方是<strong>路由器</strong>，要把 IP 数据报转发到<strong>本网络上的一个主机</strong>。这时用 ARP 找到目的主机的硬件地址。</li> 
   <li>发送方是<strong>路由器</strong>，要把 IP 数据报转发到<strong>另一个网络上的一个主机</strong>。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li> 
  </ol>
  <p><strong>既然我们最终通信还是要使用硬件地址，为什么要引入IP地址，为什么不能直接使用硬件地址进行网络通信呢？</strong></p> 
  <p>由于全世界存在着各式各样的网络，它们使用<strong>不同的硬件地址</strong>。要使这些<strong>异构网络</strong>能够互相通信就必须进行非常复杂的硬<strong>件地址转换</strong>工作，因此几乎是不可能的事。 IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。 因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便。</p> 
  <h3 id="ip-4">IP数据报的格式</h3> 
  <p><img alt="image-20190511211107272" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2xootin8yj30uk0fk78e.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-11：IP数据报的格式</p> 
  <p>&nbsp;</p> 
  <p>如图2-11，一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。 首部的前一部分是<strong>固定长度</strong>，共 <strong>20 字节</strong>，是<strong>所有 IP 数据报必须具有的</strong>，首部的固定部分的后面是一些<strong>可选字段</strong>，其<strong>长度是可变</strong>的。</p> 
  <p>IP数据报首部的固定部分</p> 
  <p>IP 数据报首部的固定部分中的各字段:</p> 
  <ol>
   <li> <p><strong>版本</strong>——占 4 位，指 <strong>IP 协议的版本</strong>。 目前的 IP 协议版本号为 4 (即 IPv4)。</p> </li> 
   <li> <p><strong>首部长度</strong>——占 4 位，可表示的最大十进制数值是15 个单位(一个单位为 4 字节)， 因此 IP 的首部长度的最大值是 60 字节。</p> </li> 
   <li> <p><strong>区分服务</strong>——占 8 位，用来获得更好的服务。 在旧标准中叫做服务类型，但实际上一直未被使用过。 1998 年这个字段改名为区分服务。 只有在使用区分服务（DiffServ）时，这个字段才起作用。 在一般的情况下都不使用这个字段</p> </li> 
   <li> <p><strong>总长度</strong>——占 16 位，指<strong>首部和数据之和</strong>的长度， 单位为字节，因此<strong>数据报的最大长度</strong>为 65535 字节。 总长度必须<strong>不超过最大传送单元MTU</strong>。</p> </li> 
   <li> <p><strong>标识(identification)</strong> ——占 16 位， 它是一个计数器，用来<strong>产生 IP 数据报的标识</strong>，相同的标识使分片后的各数据报片最后能正确地重装为原来的数据报。</p> </li> 
   <li> <p><strong>标志(flag)</strong> ——占 3 位，目前只有前两位有意义。</p> </li> 
  </ol>
  <ul>
   <li>标志字段的最低位是&nbsp;<strong>MF (More Fragment)</strong>。 MF=1 表示后面“还有分片”。MF=0 表示最后一个分片。</li> 
   <li>标志字段中间的一位是&nbsp;<strong>DF (Don't Fragment)</strong>&nbsp;。 只有当&nbsp;<strong>DF=0</strong>&nbsp;时才<strong>允许分片</strong>。</li> 
  </ul>
  <ol>
   <li><strong>片偏移</strong>——占13 位，指出：<strong>较长的分组</strong>在<strong>分片后</strong>某片在原分组中的<strong>相对位置</strong>。 片偏移以&nbsp;<strong>8 个字节为偏移单位</strong>。</li> 
  </ol>
  <blockquote> 
   <p>例题：一数据报的<strong>总长度</strong>为 3820 字节，其<strong>数据部分</strong>的长度为 3800 字节（使用<strong>固定首部</strong>），需要分片为<strong>长度不超过 1420 字节</strong>的数据报片。 因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。 于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。 原始数据报首部被复制为各数据报片的首部，但必须<strong>修改有关字段的值</strong>。</p> 
   <p><img alt="image-20190511212141145" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2xoztan7wj30zq0eyjws.jpg"></p> 
   <p>IP 数据报首部中与分片有关的字段中的数值：</p> 
   <table>
    <thead>
     <tr>
      <th>&nbsp;</th> 
      <th><strong>总长度</strong></th> 
      <th><strong>标识</strong></th> 
      <th><strong>MF</strong></th> 
      <th><strong>DF</strong></th> 
      <th><strong>片偏移</strong></th> 
     </tr>
    </thead>
    <tbody>
     <tr>
      <td><strong>原始数据报</strong></td> 
      <td><strong>3820</strong></td> 
      <td><strong>12345</strong></td> 
      <td><strong>0</strong></td> 
      <td><strong>0</strong></td> 
      <td><strong>0</strong></td> 
     </tr>
     <tr>
      <td><strong>数据报片1</strong></td> 
      <td><strong>1420</strong></td> 
      <td><strong>12345</strong></td> 
      <td><strong>1</strong></td> 
      <td><strong>0</strong></td> 
      <td><strong>0</strong></td> 
     </tr>
     <tr>
      <td><strong>数据报片2</strong></td> 
      <td><strong>1420</strong></td> 
      <td><strong>12345</strong></td> 
      <td><strong>1</strong></td> 
      <td><strong>0</strong></td> 
      <td><strong>175</strong></td> 
     </tr>
     <tr>
      <td><strong>数据报片3</strong></td> 
      <td><strong>1020</strong></td> 
      <td><strong>12345</strong></td> 
      <td><strong>0</strong></td> 
      <td><strong>0</strong></td> 
      <td><strong>350</strong></td> 
     </tr>
    </tbody>
   </table>
  </blockquote> 
  <ol>
   <li> <p><strong>生存时间</strong>——占8位，生存时间的英文缩写是TTL(Time to line)，目的是为了防止无法提交的数据报无限制地在互联网中兜圈子(例如从路由器R1到路由器R2，再有路由器R2到路由器R1)，从而浪费计算机资源。刚开始TTL的单位是时间，每经历一个路由器就将TTL的值减去在路由器中所消耗的一段时间，后来由于网络越来越快，就将TTL的单位设为跳数，每经过一个路由器就减1.</p> </li> 
   <li> <p><strong>协议</strong>——占8 位，指出此数据报携带的数据使用何种协议， 以便目的主机的 IP 层将数据部分上交给上层的对应协议进行处理。协议字段指出应将数据部分交给哪一个进程</p> </li> 
  </ol>
  <blockquote> 
   <p><img alt="image-20190511212956260" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2xp8e9npmj30rk0bmjuq.jpg"></p> 
   <p>如上图所示，<strong>IP</strong> <strong>协议支持多种协议，IP 数据报可以封装多种协议</strong> <strong>PDU**</strong>。</p> 
  </blockquote> 
  <ol>
   <li> <p><strong>首部检验和</strong>——占16 位，只检验数据报的<strong>首部</strong>， 不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法:</p> 
    <blockquote> 
     <p><img alt="image-20190511213445160" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2xpdeh076j30te0gswk9.jpg"></p> 
     <p>如上图所示，检验过程为：</p> 
     <p>在发送方，先把IP数据报首部划分为许多<strong>16位字</strong>的序列，并把<strong>检验和字段置零</strong>。用<strong>反码算术运算</strong>把所有16位字相加后，将得到的<strong>和的反码</strong>写入检验和字段。</p> 
     <p>接收方收到数据报后，将首部的所有16位字再使用<strong>反码算术运算</strong>相加一次。将<strong>得到的和取反码</strong>，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0,于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。</p> 
     <p>注意这里提到的<strong>"反码求和"</strong>的过程是：从低位到高位逐列进行计算。0和0相加是0,0和1相加是1,1和1相加是0，但要产生一个<strong>进位1</strong>,加到下一列。若最高位相加后产生进位，则最后得到的结果要加1.请注意，<strong>反码(onc'scomplement)</strong>和<strong>补码(two'scomplement)</strong>是不一样的，</p> 
    </blockquote> </li> 
   <li> <p><strong>源地址</strong>和<strong>目的地址</strong>都各占 4 字节</p> </li> 
  </ol>
  <p>IP数据报首部的可变部分</p> 
  <p>IP 首部的可变部分就是一个<strong>选项字段</strong>（可选），用来支持排错、测量以及安全等措施，内容很丰富。 选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。 增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。 实际上这些选项<strong>很少被使用</strong>。</p> 
  <h3 id="ip-7">IP层转发分组的流程</h3> 
  <p><strong>注意：</strong>互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong></p> 
  <p>假设：有四个 A 类网络通过三个路由器连接在一起，每一个网络上都可能有成千上万个主机。 可以想象，若按<strong>目的主机号</strong>来制作路由表，每一个路由表就有 4 万个项目，即 4 万行（每一行对应于一台主机），则所得出的路由表就会过于庞大。 若按主机所在的<strong>网络地址</strong>来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目（每一行对应于一个网络），这样就可使路由表大大简化。</p> 
  <p>在路由表中，对每一条路由，最主要的是<strong>（目的网络地址，下一跳地址）</strong></p> 
  <p><img alt="image-20190511214332252" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2xpmjpx6lj30zu0gmq9y.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-12：路由表举例</p> 
  <p>&nbsp;</p> 
  <p>根据目的网络地址就能确定下一跳路由器，这样做的结果是：</p> 
  <ol>
   <li>IP 数据报最终一定可以找到目的主机<strong>所在目的网络</strong>上的路由器（可能要通过多次的间接交付）。</li> 
   <li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li> 
  </ol>
  <p><strong>特定主机路由</strong></p> 
  <p>虽然互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>，但在大多数情况下都允许有这样的特例，即<strong>为特定的目的主机指明一个路由</strong>，这种路由叫做<strong>特定主机路由</strong>。 采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由，在对网络的连接或路由表进行排错时，指明到某一台主机的特殊路由就十分有用。</p> 
  <p><strong>默认路由</strong>&nbsp;<strong>(default route)</strong></p> 
  <p>路由器还可采用默认路由以<strong>减少路由表所占用的空间</strong>和<strong>搜索路由表所用的时间</strong>。 这种转发方式在<strong>一个网络只有很少的对外连接</strong>时是很有用的。 默认路由在主机发送 IP 数据报时往往更能显示出它的好处。 如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。</p> 
  <p><img alt="image-20190512102904396" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2ybr35kxqj30zi0amgpd.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图2-13：路由器R1充当网络N1的默认路由器</p> 
  <p>&nbsp;</p> 
  <p>例如，在图2-13的互联网中，连接在网络N1上的任何一台路主机中的路由表中只需要3个项目即可：</p> 
  <ol>
   <li>本网络主机的路由，目的网络为本身，不需要路由器转发，直接交付</li> 
   <li>到网络N2的路由，对应下一跳是R2</li> 
   <li><strong>默认路由</strong>，只要目的网络是<strong>其他网络</strong>(不是N1也不是N2)，就一律使用默认路由</li> 
  </ol>
  <p>像上图中路由表中的<strong>"直接"</strong>和<strong>"默认"</strong>字符在实际的路由表中是用<strong>"0.0.0.0"</strong>表示的。</p> 
  <p><strong>必须注意：</strong></p> 
  <p>IP 数据报的首部中没有地方可以用来指明<strong>“下一跳路由器的 IP 地址”</strong>。 当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的<strong>网络接口软件</strong>。 网络接口软件使用 <strong>ARP</strong> 负责将下一跳路由器的 <strong>IP 地址转换成硬件地址</strong>，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p> 
  <p>分组转发完整流程</p> 
  <ol>
   <li>从数据报的首部提取目的主机的&nbsp;<strong>IP 地址</strong>&nbsp;D, 得出目的<strong>网络地址</strong>为 N（<strong>IP地址包含网络地址和主机地址，分组转发只需要知道网络地址即可</strong>）。</li> 
   <li>若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行 (3)。</li> 
   <li>若路由表中有目的地址为 D 的<strong>特定主机路由</strong>，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。</li> 
   <li>若路由表中有到达网络 N 的<strong>路由</strong>，则把数据报传送给路由表指明的<strong>下一跳路由器</strong>；否则，执行 (5)。</li> 
   <li>若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表中所指明的<strong>默认路由器</strong>；否则，执行 (6)。</li> 
   <li>报告转发分组出错。</li> 
  </ol>
  <p>关于路由表</p> 
  <p>路由表<strong>没有给分组指明到某个网络的完整路径</strong>。路由表指出，到某个网络应当先到某个<strong>路由器（即下一跳路由器）</strong>。在到达下一跳路由器后，再继续查找其路由表，知道再下一步应当到哪一个路由器。这样一步一步地查找下去，直到最后到达目的网络。</p> 
  <h2 id="-10">划分子网和构造超网</h2> 
  <h3 id="ipip">从两级IP地址到三级IP地址(构造子网)</h3> 
  <p>两级IP地址的缺点</p> 
  <p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p> 
  <ol>
   <li>IP 地址<strong>空间的利用率有时很低</strong>。</li> 
  </ol>
  <blockquote> 
   <p>有的单位申请到一个B类地址网络，但是所连接的主机并不多，但是又不愿意申请一个足够用的C类地址网络，理由是考虑到今后可能的发展，这样就造成了IP地址的浪费。</p> 
  </blockquote> 
  <ol>
   <li> <p>给每一个物理网络分配一个网络号会使<strong>路由表变得太大</strong>因而使网络性能变坏。</p> </li> 
   <li> <p>两级的 IP 地址<strong>不够灵活</strong>。</p> </li> 
  </ol>
  <blockquote> 
   <p>有时一个单位需要紧急在新的地点马上开通一个新的网络，但是在申请到一个新的IP地址之前，新增加的网是不可能连接到互联网上工作的。所以我们希望有一种办法可以使一个单位灵活地增加本单位的网络，而不必实现到互联网管理机构去申请新的网络号。原先的2级IP地址无法做到这一点。</p> 
  </blockquote> 
  <p>从 1985 年起在 IP 地址中又增加了一个<strong>“子网号字段”</strong>，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。 这种做法叫做<strong>划分子网 (subnetting)</strong> 。 划分子网已成为互联网的正式标准协议。</p> 
  <p>划分子网的基本思路</p> 
  <p>划分子网纯属一个<strong>单位内部</strong>的事情。单位<strong>对外仍然表现为没有划分子网的网络</strong>。 从主机号借用若干个位作为子网号 <strong>subnet-id</strong>，而主机号 <strong>host-id</strong> 也就相应减少了若干个位，如图3-1所示：</p> 
  <p><img alt="image-20190512105001192" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2yccvg9ezj308r02s747.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图3-1:划分子网后的IP组成</p> 
  <p>&nbsp;</p> 
  <p>所以这样IP地址的格式就变为了： $$ IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;} $$ 凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 <strong>net-id</strong>，先找到连接在本单位网络上的路由器。 然后此路由器在收到 IP 数据报后，再按目的网络号 <strong>net-id</strong> 和子网号 <strong>subnet-id</strong> 找到<strong>目的子网</strong>，最后就将 IP 数据报直接交付目的主机。</p> 
  <p><img alt="image-20190512105622058" class="has" src="https://ws4.sinaimg.cn/large/006tNc79gy1g2ycjhg1hgj30wc0u0dwj.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图3-2：划分子网前后对比</p> 
  <p>&nbsp;</p> 
  <p>如图3-2所示，划分子网知识把IP地址的主机号部分再进行划分，而不改变IP地址原来的网络号，<strong>划分子网</strong>纯属一个单位内部的事情，对外部网络透明，<strong>对外仍然表现为没有划分子网的一个网络</strong>。</p> 
  <p>子网掩码</p> 
  <p>划分子网之后有个问题就是，如图3-2，假定现在有一个数据报，其目的地址是145.13.3.10，已经达到了路由器R1，那么这个路由器如何把它转发到子网145.13.3.0呢？</p> 
  <p>我们知道，从一个 IP 数据报的首部并<strong>无法判断源主机或目的主机所连接的网络是否进行了子网划分</strong>。 因此需要使用子网掩码，使用<strong>子网掩码 (subnet mask)</strong> 可以找出 IP 地址中的子网部分。</p> 
  <p><strong>规则：</strong></p> 
  <p>子网掩码长度 ＝ 32 位</p> 
  <p>子网掩码<strong>左边部分</strong>的一连串 1，对应于<strong>网络号</strong>和<strong>子网号</strong></p> 
  <p>子网掩码<strong>右边部分</strong>的一连串 0，对应于<strong>主机号</strong></p> 
  <p><img alt="image-20190512110614081" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2yctqt8hrj30yw0jg156.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图3-2：子网掩码示意图</p> 
  <p>&nbsp;</p> 
  <p>如图3-3所示，子网掩码要解决的就是找到网络号，对于两级IP地址，其网络号为前16位(如图3-2(a)所示)，对于三级IP地址，其网络号为前24位(如图3-2(c)所示)，子网掩码和IP地址一样一共有32位，原理就是，<strong>如果是两级IP地址，子网掩码的前16位为1，后16位为0，如果是三级IP地址，子网掩码前24位为1，后8位为0</strong>，这样做的好处是， 拿到一个IP地址之后，只需要将IP地址与本路由器的子网掩码<strong>"按位向与"</strong>，得到的结果一定是网络号(因为主机号与的对象是0，与完之后的结果一定也是0)，这样就得到了网络号。</p> 
  <p>那么还有一个问题就是，在不划分子网的时候是否还需要子网掩码？答案是肯定的，因为路由器并不能自动判断当前IP是否划分子网了啊，他只能对所有来的IP都用子网掩码进行按位向与，这样其实也利于查找网络号，如果是两级IP，路由器不再需要查找改地址的类别位，直接使用子网掩码就能提取出来网络号，所以，如果一个网络没有进行子网划分，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>，很明显，各类IP的默认子网掩码为：</p> 
  <p><img alt="image-20190512111420135" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2yd266afkj30ou0dwq5w.jpg"></p> 
  <p>&nbsp;</p> 
  <p>3-3:各类IP地址的默认子网掩码</p> 
  <p>&nbsp;</p> 
  <p>子网掩码是一个网络或一个子网的重要属性，路由器在和相邻路由器交换路由信息时，<strong>必须把自己所在网络（或子网）的子网掩码告诉相邻路由器</strong>。路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的<strong>子网掩码</strong>。<strong>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码</strong>。</p> 
  <p>子网划分有<strong>固定长度子网</strong>和<strong>变长子网</strong>两种子网划分方法。 在采用<strong>固定长度子网</strong>时，所划分的<strong>所有子网的子网掩码都是相同的</strong>。 虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。 划分子网增加了灵活性，但却<strong>减少了能够连接在网络上的主机总数</strong>。</p> 
  <p>需要注意的是同一个IP和<strong>不同的子网掩码计算后得出的网络号可能是相同的</strong>，因为如果IP地址的某一位是0，那么不管子网号的对应为是0还是1，计算的结果的对应为都是0，也就是说两个子网掩码计算得到的网络号是一样的。</p> 
  <p>但是两个可以计算得到同样网络号的子网掩码也只是针对特定IP来说的，两个子网掩码的<strong>实际效果并不同</strong>。</p> 
  <p>使用子网时分组的转发</p> 
  <p>在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。 但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为<strong>网络地址取决于那个网络所采用的子网掩码</strong>，但数据报的首部并没有提供子网掩码的信息。 因此分组转发的算法也必须做相应的改动，步骤如下：</p> 
  <ol>
   <li>从收到的分组的首部提取<strong>目的 IP 地址</strong>&nbsp;D。</li> 
   <li>先用各网络的<strong>子网掩码</strong>和 D 逐位相“与”，看<strong>是否和相应的网络地址匹配</strong>。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。</li> 
   <li>若路由表中有目的地址为 D 的<strong>特定主机路由</strong>，则将分组传送给指明的下一跳路由器；否则，执行 (4)。</li> 
   <li>对路由表中的每一行，将子网掩码和 D 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。</li> 
   <li>若路由表中有一个<strong>默认路由</strong>，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。</li> 
   <li>报告转发分组出错。</li> 
  </ol>
  <p><strong>例题：</strong></p> 
  <p>如图3-4，有三个子网，两个路由器，以及路由器R1中的部分路由表，现在源主机H1向目的主机H2发送分组，试讨论分组转发过程。</p> 
  <p><img alt="image-20190512120526235" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2yejcf4nzj311w0i0wo3.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图3-4：主机H1向主机H2发送分组</p> 
  <p>&nbsp;</p> 
  <p><strong>【解】</strong></p> 
  <ol>
   <li>源主机H1向目的主机H2发送的分组的目的地址是H2的IP地址128.30.33.138。源主机H1首先要进行的操作是要判断发送的这个分组是在本子网上进行直接交付还是要通过本子网上的路由器进行间接交付，源主机H1把本子网的"子网掩码“255.255.255.128与目的主机H2的IP地址128.30.33.138逐位相与(即逐位进行AND操作)，得出128.30.33.128，它不等于H1的网络地址(128.30.33.0)。这说明H2与H1不在同一个子网上，因此H1不能把分组直接交付H2，而必须交给子网上的<strong>默认路由器</strong>R1，由R1来转发。</li> 
   <li>路由器R1在收到一个分组后，就在其路由表中逐行寻找有无匹配的网络地址。先看R1路由表中的第一行。用这一行的"子网掩码”255.255.255.128和收到的分组的"目的地址“128.30.33.138逐位相与(即逐位进行AND操作)，得出128.30.33.128，然后和这一行给出的目的网络地址128.30.33.0进行比较，比较的结果不一致(即不匹配)。用同样方法继续往下找第二行。用第二行的子网掩码255.255.255.128和该分组的"目的地址”128.30.33.138逐位相"与"(即逐位进行AND操作)，结果也是128.30.33.128，这个结果和第二行的目的网络地址128.30.33.128相匹配，说明这个网络(子网2)就是收到的分组所要寻找的目的网络。于是不需要再继续查找下去，R1把分组从接口1直接交付主机H2(它们都在一个子网上)。</li> 
  </ol>
  <h3 id="cidr">无分类编址CIDR(构造超网)</h3> 
  <p>网络前缀</p> 
  <p>划分子网在一定程度上<strong>缓解了互联网在发展中遇到的困难</strong>。然而在 1992 年互联网仍然面临三个必须尽早解决的问题：</p> 
  <ol>
   <li>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</li> 
   <li>互联网主干网上的<strong>路由表中的项目数急剧增长</strong>（从几千个增长到几万个）。</li> 
   <li>整个 IPv4 的地址空间最终将全部耗尽。</li> 
  </ol>
  <p>1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码，使用<strong>变长子网掩码 VLSM (Variable Length Subnet Mask)</strong>可进一步提高 IP 地址资源的利用率， 在 VLSM 的基础上又进一步研究出<strong>无分类编址方</strong>法，它的正式名字是<strong>无分类域间路由选择 CIDR (Classless Inter-Domain Routing)</strong>。</p> 
  <p>CIDR的主要特点</p> 
  <ol>
   <li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</li> 
   <li>CIDR使用各种长度的<strong>“网络前缀”(network-prefix)</strong>来代替分类地址中的网络号和子网号。</li> 
   <li>IP 地址从三级编址（使用子网掩码）又回到了<strong>两级编址</strong>。</li> 
  </ol>
  <p>无分类的两级编址的记法是：</p> 
  <p><img alt="image-20190512121654071" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2yev9nrabj30hy03y74i.jpg"></p> 
  <p>即： $$ IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;} $$ CIDR 使用<strong>“斜线记法”(slash notation)</strong>，它又称为 CIDR 记法，即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于<strong>三级编址中子网掩码中 1 的个数</strong>），例如： 220.78.168.0/24。</p> 
  <p>CIDR 把网络前缀都相同的连续的 IP 地址组成<strong>“CIDR 地址块”</strong>。</p> 
  <p>128.14.32.0/20 表示的地址块共有$ 2^{12}$ 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。 这个地址块的起始地址是 128.14.32.0， 在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</p> 
  <p>128.14.32.0/20 地址块的最小地址：128.14.32.0， 128.14.32.0/20 地址块的最大地址：128.14.47.255 ，即<strong>主机号从全0到全1.</strong></p> 
  <p><strong>全 0 和全 1 的主机号地址一般不使用。</strong></p> 
  <p>路由聚合</p> 
  <p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为<strong>路由聚合</strong>，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由，路由聚合有利于<strong>减少路由器之间的路由选择信息的交换</strong>，从而提高了整个互联网的性能，路由聚合也称为<strong>构成超网 (supernetting)</strong>。 CIDR 虽然不使用子网了，但仍然使用<strong>“掩码”</strong>这一名词（但<strong>不叫子网掩码</strong>）， 对于 /20 地址块，它的掩码是 20 个连续的 1， 斜线记法中的数字就是掩码中1的个数。</p> 
  <p>CIDR记法的多种形式</p> 
  <ol>
   <li> <p>10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。</p> </li> 
   <li> <p>10.0.0.0/10 隐含地指出 IP 地址 10.0.0.0 的掩码是 255.192.0.0。此掩码可表示为：</p> </li> 
  </ol>
  <p><img alt="image-20190512122638804" class="has" src="https://ws4.sinaimg.cn/large/006tNc79gy1g2yf5evifoj30jq068758.jpg"></p> 
  <ol>
   <li>网络前缀的后面加一个星号 * 的表示方法，如 00001010 00*，在星号 * 之前是<strong>网络前缀</strong>，而星号 * 表示 IP 地址中的<strong>主机号</strong>，可以是<strong>任意值</strong>。</li> 
  </ol>
  <p>构成超网</p> 
  <p>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址，这些 C 类地址合起来就构成了超网。 CIDR 地址块中的地址数一定是 2 的整数次幂，网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p> 
  <p>CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要<strong>分配适当大小的 CIDR 地址块</strong>。</p> 
  <p>最长前缀匹配</p> 
  <p>使用 CIDR 时，路由表中的每个项目由<strong>“网络前缀”</strong>和<strong>“下一跳地址”</strong>组成，在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择<strong>具有最长网络前缀</strong>的路由：<strong>最长前缀匹配 (longest-prefix matching)</strong>。 网络前缀越长，其地址块就越小，因而路由就越<strong>具体 (more specific)</strong> 。</p> 
  <p>最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</p> 
  <p><strong>举例：</strong></p> 
  <p>某个上属ISP地址块为206.0.64.0/18的大学，该大学分到地址块为：206.0.68.0/22，这个大学里的计算机系分到的地址块为：206.0.71.128/25，假定计算机系希望ISP收到属于自己的数据报后直接发送给自己而不要经过大学的路由器，那么在ISP的路由器的路由表中就至少要有以下两个项目：206.0.68.0/22（大学）、206.0.71.128/25（计算机系），现在假定ISP收到一个数据报，其目的IP地址D=206.0.71.130,把D和其路由表中的两个项目的掩码逐位相与：</p> 
  <ol>
   <li>D和11111111111111111111110000000000相与，结果为206.0.68.0/22，匹配</li> 
   <li>D和11111111111111111111111110000000相与，结果为206.0.71.128/25，匹配</li> 
  </ol>
  <p>那么根据<strong>最长前缀匹配原则</strong>，就算206.0.68.0/22匹配成功，最终ISP的路由器也会将本数据报转发给206.0.71.128/25，因为206.0.71.128/25匹配器到的地址更加具体。</p> 
  <p>使用二叉线索查找路由表</p> 
  <p>当路由表的项目数很大时，怎样设法<strong>减小路由表的查找时间</strong>就成为一个非常重要的问题。 为了进行更加有效的查找，通常是将<strong>无分类编址</strong>的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索 (binary trie)</strong>。 IP 地址中从左到右的比特值决定了<strong>从根结点逐层向下层延伸的路径</strong>，而二叉线索中的各个路径就代表路由表中存放的各个地址， 为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</p> 
  <p>从二叉线索的根节点自顶向下的深度<strong>最多有 32 层</strong>，每一层对应于IP地址中的一位。</p> 
  <p>一个IP地址存入二叉线索的规则很简单，先检查IP地址左边的第一位，如为 0，则第一层的节点就在根节点的左下方，如为 1，则在右下方，然后再检查地址的第二位，构造出第二层的节点，依此类推，直到唯一前缀的最后一位。</p> 
  <h3 id="icmp">网际控制报文协议ICMP</h3> 
  <p>为了<strong>更有效地转发 IP 数据报</strong>和<strong>提高交付成功的机会</strong>，在网际层使用了<strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong>， ICMP 是互联网的标准协议， ICMP <strong>允许主机或路由器报告差错情况</strong>和<strong>提供有关异常情况的报告</strong>。 但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。</p> 
  <p>ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去，ICMP报文格式如图3-5所示：</p> 
  <p><img alt="image-20190512125451554" class="has" src="https://ws4.sinaimg.cn/large/006tNc79gy1g2yfyrqh07j30zk0emgpv.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图3-5：ICMP报文格式</p> 
  <p>&nbsp;</p> 
  <p>ICMP报文的种类</p> 
  <p>ICMP 报文的种类有两种：</p> 
  <ol>
   <li> <p>ICMP <strong>差错报告</strong>报文</p> </li> 
   <li> <p>ICMP <strong>询问</strong>报文</p> <p>ICMP 报文的前 4 个字节是<strong>统一的格式</strong>，共有三个字段：即<strong>类型</strong>、<strong>代码</strong>和<strong>检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。</p> </li> 
  </ol>
  <p>ICMP差错报告报文</p> 
  <p>ICMP差错报告报文有4种：</p> 
  <ol>
   <li>终点不可达</li> 
  </ol>
  <blockquote> 
   <p>当路由器或主机不能交付数据报时就向源主点发送终点不可达报文</p> 
  </blockquote> 
  <ol>
   <li>时间超过</li> 
  </ol>
  <blockquote> 
   <ul>
    <li>当路由器收到生存时间为零的报文时，除了丢弃该报文，还要向源点发送时间超过报文</li> 
    <li>当终点在预先规定的时间内不能收到一个数据报的全部数据时，就把收到的数据报片都丢弃，并向源点发送时间超过报文</li> 
   </ul>
  </blockquote> 
  <ol>
   <li>参数问题</li> 
  </ol>
  <blockquote> 
   <p>当路路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该报文，并向源点发送参数问题报文</p> 
  </blockquote> 
  <ol>
   <li>改变路由（重定向）(Redirect)</li> 
  </ol>
  <blockquote> 
   <p>路由器把改变路由报文发给主机，让主机知道下次应该直接把数据报发送给另外的路由器(可通过更好的路由)</p> 
  </blockquote> 
  <p>所有的ICMP差错报文中的数据字段都具有相同的格式，如图3-6所示，把收到的进行差错报告的IP数据报首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了<strong>ICMP差错报告报文</strong>。提取收到的数据报的数据字段前8个字节是<strong>为了得到运输层的端口号</strong>(对于TCP和UDP)以及运输层报文的<strong>发送序号</strong>(对于TCP)。这些信息对源点通知高层协议是有用的(端口的作用将在写一篇运输层讲解)。整个ICMP报文作为IP数据报的数据字段发送给源点。</p> 
  <p><img alt="image-20190512130716058" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2ygbo68zgj30zu0eotdg.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图3-6：ICMP差错报文的数据字段的内容</p> 
  <p>&nbsp;</p> 
  <p>不应发送ICMP 差错报告报文的几种情况：</p> 
  <ol>
   <li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li> 
   <li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li> 
   <li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li> 
   <li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li> 
  </ol>
  <p>ICMP询问报文</p> 
  <p>有2种：</p> 
  <ol>
   <li>回送请求和回答报文</li> 
   <li>时间戳请求和回答报文</li> 
  </ol>
  <p>ICMP的应用举例</p> 
  <p>Ping</p> 
  <p>PING (Packet InterNet Groper) 用来测试两个主机之间的<strong>连通性</strong>。 PING 使用了 <strong>ICMP 回送请求</strong>与<strong>回送回答报文</strong>。 PING 是应用层<strong>直接使用网络层 ICMP</strong> 的例子，它<strong>没有通过运输层的 TCP 或UDP</strong>。</p> 
  <p>Traceroute</p> 
  <p>在 Windows 操作系统中这个命令是 tracert。 用来<strong>跟踪一个分组从源点到终点的路径</strong>。 它利用 IP 数据报中的 TTL 字段和 <strong>ICMP 时间超过差错报告报文</strong>实现对从源点到终点的路径的跟踪。</p> 
  <h2 id="-19">互联网的路由选择协议</h2> 
  <h3 id="-20">有关路由选择协议的几个基本概念</h3> 
  <p>理想的路由算法</p> 
  <ol>
   <li> <p>算法必须是正确的和完整的。</p> </li> 
   <li> <p>算法在计算上应简单。</p> </li> 
   <li> <p>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。</p> </li> 
   <li> <p>算法应具有稳定性。</p> </li> 
   <li> <p>算法应是公平的。</p> </li> 
   <li> <p>算法应是最佳的。</p> </li> 
  </ol>
  <blockquote> 
   <p>不存在一种<strong>绝对的最佳路由算法</strong>。 所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。 实际的路由选择算法，应尽可能接近于理想的算法。 路由选择是个非常复杂的问题 它是网络中的所有结点共同协调工作的结果。 路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。</p> 
  </blockquote> 
  <p>倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则路由算法只有两大类：</p> 
  <ol>
   <li><strong>静态路由选择策略</strong>——即<strong>非自适应路由选择</strong>，其特点是简单和开销较小，但不能及时适应网络状态的变化。</li> 
   <li><strong>动态路由选择策略</strong>——即<strong>自适应路由选择</strong>，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</li> 
  </ol>
  <p>分层次的路由选择协议</p> 
  <p>互联网采用分层次的路由选择协议。这是因为：</p> 
  <ol>
   <li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li> 
   <li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。</li> 
  </ol>
  <p>为此，可以把整个互联网划分成许多较小的<strong>自治系统(autonomous system)</strong>，一般记为AS。</p> 
  <p><strong>自治系统 AS</strong> 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。 现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。</p> 
  <p><strong>互联网的两大类路由选择协议：</strong></p> 
  <ol>
   <li><strong>内部网关协议 IGP (Interior Gateway Protocol)</strong>&nbsp;在一个<strong>自治系统内部</strong>使用的路由选择协议。 目前这类路由选择协议使用得最多，如&nbsp;<strong>RIP</strong>&nbsp;和&nbsp;<strong>OSPF</strong>&nbsp;协议。</li> 
   <li><strong>外部网关协议 EGP (External Gateway Protocol)</strong>&nbsp;若源站和目的站处在<strong>不同的自治系统</strong>中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。 在外部网关协议中目前使用最多的是&nbsp;<strong>BGP-4</strong>。</li> 
  </ol>
  <p><img alt="image-20190512131940450" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2ygol6w9sj30zu09on17.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-1：自制系统和内部网关协议、外部网关协议</p> 
  <p>&nbsp;</p> 
  <p>自治系统之间的路由选择也叫做<strong>域间路由选择 (interdomain routing)</strong>，在自治系统内部的路由选择叫做<strong>域内路由选择 (intradomain routing)</strong> 。</p> 
  <p>互联网的早期 RFC 文档中未使用<strong>“路由器”</strong>而是使用<strong>“网关”</strong>这一名词。但是在新的 RFC 文档中又使用了“路由器”这一名词。应当把这两个术语当作<strong>同义词</strong>。</p> 
  <p>内部网关协议RIP</p> 
  <p>工作原理</p> 
  <p><strong>路由信息协议 RIP (Routing Information Protocol)</strong> 是内部网关协议 IGP 中最先得到广泛使用的协议。 RIP 是一种<strong>分布式</strong>的、基于<strong>距离向量</strong>的路由选择协议。 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的<strong>距离</strong>记录。</p> 
  <p>"距离"的定义</p> 
  <p>从一个路由器到<strong>直接连接的网络</strong>的距离定义为 1， 从一个路由器到非直接连接的网络的距离定义为<strong>所经过的路由器数加 1</strong>。 RIP 协议中的<strong>“距离”</strong>也称为<strong>“跳数”(hop count)</strong>，因为<strong>每经过一个路由器</strong>，<strong>跳数就加 1</strong>。 这里的<strong>“距离”</strong>实际上指的是<strong>“最短距离”</strong>。</p> 
  <p>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”， RIP 允许<strong>一条路径最多只能包含 15 个路由器</strong>。 <strong>“距离”</strong>的<strong>最大值为 16 时即相当于不可达</strong>，可见 RIP <strong>只适用于小型互联网</strong>。 RIP 不能在两个网络之间同时使用多条路由，RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由，即<strong>选择最短的，不一定是最快的</strong>。</p> 
  <p>RIP协议的特点</p> 
  <ol>
   <li>仅和<strong>相邻路由器交换信息</strong>。 交换的信息是<strong>当前本路由器所知道的全部信息</strong>，即<strong>自己的路由表</strong>。</li> 
   <li>按<strong>固定的时间间隔交换路由信息</strong>，例如，每隔 30 秒。</li> 
   <li>当<strong>网络拓扑发生变化</strong>时，路由器也及时向相邻路由器<strong>通告拓扑变化后的路由信息</strong>。</li> 
  </ol>
  <p>路由表的建立方法</p> 
  <p>路由器在<strong>刚刚开始工作</strong>时，只知道到<strong>直接连接的网络的距离</strong>（此距离定义为 1），它的路由表是空的，接着，每一个路由器也只和数目非常有限的<strong>相邻路由器</strong>交换并更新路由信息，但经过若干次更新后，所有的路由器最终都会知道<strong>到达本自治系统中任何一个网络的最短距离</strong>和<strong>下一跳路由器的地址</strong>。</p> 
  <p>RIP 协议的<strong>收敛 (convergence)</strong> 过程较快。<strong>“收敛”</strong>就是在自治系统中<strong>所有的结点都得到正确的路由选择信息的过程</strong>。</p> 
  <p>路由表中最主要的信息是：<strong>到某个网络的距离(即最短距离)</strong>，以及<strong>经过的下一跳地址</strong>。路由表更新的原则是<strong>找出每个目的网络的最短距离</strong>，这种更新算法又称为<strong>距离向量算法</strong>。</p> 
  <p>距离向量算法</p> 
  <p>路由器收到<strong>相邻路由器（相邻路由器的地址为 X）</strong>的一个 <strong>RIP 报文</strong>：</p> 
  <ol>
   <li>先修改此 RIP 报文中的所有项目：把<strong>“下一跳”</strong>字段中的地址都改为 X，并把所有的“距离”字段的值加 1，每一个项目都有三个关键数据：到目的网络<strong>N</strong>，距离是<strong>d</strong>，下一跳路由器是<strong>X</strong>。</li> 
   <li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：</li> 
  </ol>
  <ul>
   <li>若原来的路由表没有目的网络N，则把该项目加到路由表中。</li> 
   <li>否则(即在路由表中有目的网络N，这时就再查看下一跳路由器地址) 
    <ul>
     <li>若下一跳字段给出的路由器地址是X，则把收到的项目替换原路由表中的项目。</li> 
     <li>否则(即这个项目是：到目的网络N，但下一跳路由器不是X)</li> 
     <li>若收到项目中的距离小于路由表中的距离，则进行更新</li> 
     <li>否则，什么也不做。</li> 
    </ul></li> 
  </ul>
  <ol>
   <li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 16（表示不可达）。</li> 
   <li>返回。</li> 
  </ol>
  <p>距离向量算法的基础就是 <strong>Bellman-Ford 算法（或 Ford-Fulkerson 算法）</strong>。 这种算法的要点是这样的： 设X是结点 A 到 B 的最短路径上的一个结点，若把路径 A→B 拆成两段路径 A→X 和 X→B，则每一段路径 A→X 和 X→B 也都分别是结点 A 到 X 和结点 X 到 B 的最短路径。</p> 
  <p>光看概念困死了，需要一个栗子清醒一下：</p> 
  <p>已知路由器 R6 有表4-1所示的路由表。现在收到相邻路由器 R4 发来的路由更新信息，如表4-2所示。试更新路由器 R6 的路由表。</p> 
  <table>
   <thead>
    <tr>
     <th><strong>目的网络</strong></th> 
     <th><strong>距离</strong></th> 
     <th><strong>下一跳路由器</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>Net2</strong></td> 
     <td><strong>3</strong></td> 
     <td><strong>R4</strong></td> 
    </tr>
    <tr>
     <td><strong>Net3</strong></td> 
     <td><strong>4</strong></td> 
     <td><strong>R5</strong></td> 
    </tr>
    <tr>
     <td><strong>…</strong></td> 
     <td><strong>…</strong></td> 
     <td><strong>…</strong></td> 
    </tr>
   </tbody>
  </table>
  <p>&nbsp;</p> 
  <p>表4-1，R6</p> 
  <p>&nbsp;</p> 
  <table>
   <thead>
    <tr>
     <th><strong>目的网络</strong></th> 
     <th><strong>距离</strong></th> 
     <th><strong>下一跳路由器</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>Net1</strong></td> 
     <td><strong>3</strong></td> 
     <td><strong>R1</strong></td> 
    </tr>
    <tr>
     <td><strong>Net2</strong></td> 
     <td><strong>4</strong></td> 
     <td><strong>R2</strong></td> 
    </tr>
    <tr>
     <td><strong>Net3</strong></td> 
     <td><strong>1</strong></td> 
     <td><strong>直接交付</strong></td> 
    </tr>
   </tbody>
  </table>
  <p>&nbsp;</p> 
  <p>表4-2，R4</p> 
  <p>&nbsp;</p> 
  <p>首先将收到的报文中的所有项目（R4的路由表）的下一跳字段改为R4，距离字段加1，修改后如下表：</p> 
  <table>
   <thead>
    <tr>
     <th><strong>目的网络</strong></th> 
     <th><strong>距离</strong></th> 
     <th><strong>下一跳路由器</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>Net1</strong></td> 
     <td><strong>4</strong></td> 
     <td><strong>R4</strong></td> 
    </tr>
    <tr>
     <td><strong>Net2</strong></td> 
     <td>5</td> 
     <td><strong>R4</strong></td> 
    </tr>
    <tr>
     <td><strong>Net3</strong></td> 
     <td>2</td> 
     <td><strong>R4</strong></td> 
    </tr>
   </tbody>
  </table>
  <p>然后：</p> 
  <p>第一行在表4-1中没有，因此将这一行添加到表4-1中。</p> 
  <p>第二行在表4-1中有，且下一跳路由器也是R4，因此要更新(距离增大了，应该将3更新为5).</p> 
  <p>第三行在表4-1中有，但下一跳路由器不同，于是就要比较距离，新的路由信息中的距离是2，比原来的4小，所以更新原路由表的这一行的下一跳路由器为R4，距离为2。</p> 
  <p>至此，路由表更新完毕，更新之后的R6的路由表如下表所示：</p> 
  <table>
   <thead>
    <tr>
     <th><strong>目的网络</strong></th> 
     <th><strong>距离</strong></th> 
     <th><strong>下一跳路由器</strong></th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td><strong>Net1</strong></td> 
     <td><strong>4</strong></td> 
     <td><strong>R4</strong></td> 
    </tr>
    <tr>
     <td><strong>Net2</strong></td> 
     <td>5</td> 
     <td><strong>R4</strong></td> 
    </tr>
    <tr>
     <td><strong>Net3</strong></td> 
     <td>2</td> 
     <td><strong>R4</strong></td> 
    </tr>
    <tr>
     <td>...</td> 
     <td>...</td> 
     <td>...</td> 
    </tr>
   </tbody>
  </table>
  <p>RIP协议的报文格式</p> 
  <p>现在比较新的RIP版本是1998年公布的RIP2，RIP2 报文由<strong>首部</strong>和<strong>路由</strong>部分组成。</p> 
  <p>RIP2 报文中的<strong>路由部分</strong>由若干个<strong>路由信息</strong>组成，每个路由信息需要用 20 个字节，<strong>地址族标识符</strong>（又称为<strong>地址类别</strong>）字段用来<strong>标志所使用的地址协议</strong>。</p> 
  <p><strong>路由标记</strong>填入<strong>自治系统的号码</strong>，这是考虑使 RIP 有可能收到<strong>本自治系统以外的路由选择信息</strong>， 再后面指出某个<strong>网络地址</strong>、<strong>该网络的子网掩码</strong>、<strong>下一跳路由器地址</strong>以及<strong>到此网络的距离</strong>。</p> 
  <p>一个 RIP 报文最多可包括 <strong>25 个路由</strong>，因而 RIP 报文的最大长度是 <strong>4+20 x25=504</strong> 字节。如超过，必须再用一个 RIP 报文来传送。</p> 
  <p>RIP2 具有简单的<strong>鉴别功能</strong>，若使用鉴别功能，则将原来写入第一个路由信息（20 个字节）的位置用作鉴别。 在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。</p> 
  <p><img alt="image-20190512135712501" class="has" src="https://ws4.sinaimg.cn/large/006tNc79gy1g2yhrn9b49j30zu0iq16y.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-2：RIP2报文的格式</p> 
  <p>&nbsp;</p> 
  <p>好消息传播的快、坏消息传播的慢</p> 
  <p>RIP 协议特点：<strong>好消息传播得快，坏消息传播得慢</strong>，即当网络出现故障时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器。</p> 
  <p>举个栗子说明：</p> 
  <p><img alt="image-20190512140310745" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2yhxv0ajgj30zu0i4483.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-3：好消息传播的快、坏消息传播的慢</p> 
  <p>&nbsp;</p> 
  <p>如图4-3，设三个网络通过两个路由器互连起来，并且都已建立了各自的路由表。图中路由器交换的信息只给出了我们感兴趣的一行内容。路由器R1中的“1，1，直接"表示"到网1的距离是1,直接交付"，路由器R2中的“1,2，R1”表示"到网1的距离是2，下一跳经过R1“。现在假定路由器R1到网1的链路出了故障，R1无法到达网1，于是路由器R1把到网的距离改为16(表示到网1不可达)，因而在R1的路由表中的相应项目变为”1，16，直接"，但是，很可能要经过30秒钟后R1才把更新信息发送给R2，然而R2可能已经先把自己的路由表发送给了R1其中有”1, 2，R1“这一项，R1收到R2的更新报文后，误认为可经过R2到达网1，于是把收到的路由信息”1，2，R1“修改为”1，3，R2“，表明我到网1的距离是3，下一跳经过R2，并把更新后的信息发送给R2。同理，R2接着又更新自己的路由表为”114，R1“，以为"我到网1距离是4，下一跳经过R1，这样的更新一直继续下去，直到R1和R2到网1的距离都增大到16时，R1和R2才知道原来网1是不可达的。RIP协议的这一特点叫做<strong>好消息传播得快，而坏消息传播得慢</strong>。<strong>网络出故障的传播时间往往需要较长的时间(例如数分钟)</strong>，这是RIP的一个主要缺点。</p> 
  <p>RIP协议的优缺点</p> 
  <p><strong>优点：</strong></p> 
  <p>实现简单，开销较小。</p> 
  <p><strong>缺点：</strong></p> 
  <ol>
   <li> <p>RIP <strong>限制了网络的规模</strong>，它能使用的最大距离为 15（16 表示不可达）。</p> </li> 
   <li> <p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p> </li> 
   <li> <p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p> </li> 
  </ol>
  <h3 id="ospf">内部网关协议OSPF</h3> 
  <p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong>是为克服 RIP 的缺点在 1989 年开发出来的。 OSPF 的原理很简单，但实现起来却较复杂。</p> 
  <p>OSPF 协议的基本特点</p> 
  <p><strong>“开放”</strong>表明 OSPF 协议不是受某一家厂商控制，而是公开发表的， <strong>“最短路径优先”</strong>是因为使用了 <strong>Dijkstra</strong> 提出的<strong>最短路径算法 SPF</strong> ，采用分布式的<strong>链路状态协议 (link state protocol)</strong>。</p> 
  <p>注意：OSPF 只是一个协议的名字，它<strong>并不表示其他的路由选择协议不是“最短路径优先”</strong>。</p> 
  <p>OSPF的3个要点：</p> 
  <ol>
   <li>向<strong>本自治系统</strong>中<strong>所有路由器</strong>发送信息，这里使用的方法是<strong>洪泛法</strong>。</li> 
   <li>发送的信息就是与<strong>本路由器相邻的所有路由器的链路状态</strong>，但这<strong>只是路由器所知道的部分信息</strong>。</li> 
   <li>“链路状态”就是<strong>说明本路由器都和哪些路由器相邻</strong>，以及该链路的<strong>“度量”(metric)</strong>。</li> 
   <li>只有当<strong>链路状态发生变化</strong>时，路由器才用洪泛法向所有路由器发送此信息。</li> 
  </ol>
  <p><strong>链路状态数据库 (link-state database)：</strong></p> 
  <p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>。 这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是一致的（这称为链路状态数据库的同步）。 OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。 OSPF 的<strong>更新过程收敛得快</strong>是其重要优点。</p> 
  <p><strong>OSPF 的区域 (area)：</strong></p> 
  <p>为了使 OSPF 能够用于规模很大的网络，OSPF <strong>将一个自治系统再划分为若干个更小的范围</strong>，叫做<strong>区域</strong>。 每一个区域都有一个 <strong>32 位的区域标识符（用点分十进制表示）</strong>。 区域也不能太大，在一个区域内的路由器最好不超过 <strong>200</strong> 个。划分区域的好处就是将利用洪泛法交换链路状态信息的范围<strong>局限于每一个区域</strong>而不是整个的<strong>自治系统</strong>，这就<strong>减少了整个网络上的通信量</strong>。 在一个区域内部的路由器只知道<strong>本区域的完整网络拓扑</strong>，而不知道其他区域的网络拓扑的情况。 OSPF 使用<strong>层次结构</strong>的区域划分。在<strong>上层</strong>的区域叫做<strong>主干区域 (backbone area)</strong>，主干区域的路由器称为<strong>主干路由器</strong>， 非主干区域的路由器叫<strong>区域边界路由器</strong>，主干区域的标识符规定为<strong>0.0.0.0</strong>。主干区域的作用是用来<strong>连通其他在下层的区域</strong>。</p> 
  <p><img alt="image-20190512150717900" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2yjskq3jfj30zg0f248h.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-4：OSPF划分为两种不同的区域</p> 
  <p>&nbsp;</p> 
  <p>如图4-4所示，R6为连接<strong>本自治系统</strong>与其他<strong>自治系统</strong>的路由器，而其所属的区域随之称为<strong>主干区域</strong>。</p> 
  <p>OSPF 不用 UDP 而是<strong>直接用 IP 数据报</strong>传送， OSPF 构成的数据报很短，这样做可<strong>减少路由信息的通信量</strong>。 数据报很短的另一好处是可以<strong>不必将长的数据报分片传送</strong>，因为分片传送的数据报<strong>只要丢失一个</strong>，就<strong>无法组装成原来的数据报</strong>，而<strong>整个数据报就必须重传</strong>。</p> 
  <p><strong>OSPF的特点：</strong></p> 
  <ol>
   <li>OSPF 允许管理员对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF<strong>对于不同类型的业务</strong>可<strong>计算出不同的路由</strong>。</li> 
   <li>如果到同一个目的网络有<strong>多条相同代价的路径</strong>，那么可以将<strong>通信量分配给这几条路径</strong>，这叫做<strong>多路径间的负载平衡</strong>。</li> 
   <li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。</li> 
   <li>支持<strong>可变长度的子网划分</strong>和<strong>无分类编址 CIDR</strong>。</li> 
   <li>每一个链路状态都带上一个&nbsp;<strong>32 位的序号</strong>，<strong>序号越大状态就越新</strong>。</li> 
  </ol>
  <p>OSPF的5种分组类型</p> 
  <ol>
   <li>类型1，<strong>问候 (Hello)</strong>&nbsp;分组，用来发现和维持邻站的可达性</li> 
   <li>类型2，<strong>数据库描述 (Database Description)</strong>&nbsp;分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li> 
   <li>类型3，<strong>链路状态请求 (Link State Request)</strong>&nbsp;分组，向对方请求发送某些链路状态项目的详细信息</li> 
   <li>类型4，<strong>链路状态更新 (Link State Update)</strong>&nbsp;分组，用洪泛法对全网更新链路状态</li> 
   <li>类型5，<strong>链路状态确认 (Link State Acknowledgment)</strong>分组，对链路更新分组的确认</li> 
  </ol>
  <p>OSPF让每一个路由器用<strong>数据库描述分组</strong>和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出<strong>有哪些路由器的链路状态信息(以及其序号)已经写入了数据库</strong>。经过与相邻路由器交换数据库描述分组后，路由器就使用<strong>链路状态请求分组</strong>，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。图4-5给出了OSPF的基本操作，说明了两个路由器需要交换各种类型的分组。</p> 
  <p><img alt="image-20190512152037462" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2yk6fr6khj31020eydkl.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-5:OSPF的基本操作</p> 
  <p>&nbsp;</p> 
  <p>在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用<strong>链路状态更新分组</strong>，用洪泛法<strong>向全网更新链路状态</strong>，OSPF使用的是<strong>可靠的洪泛法</strong>，其要点见图4-6所示。设路由器R用洪泛法发出链路状态更新分组，图中用一些小的箭头表示<strong>更新分组</strong>。第一次先发给相邻的三个路由器，这三个路由器将收到的分组再进行转发时，要将其<strong>上游路由器</strong>除外。可靠的洪泛法是在收到更新分组后要<strong>发送确认(收到重复的更新分组只需要发送一次确认)</strong>，图中的空心箭头表示确认分组。</p> 
  <p><img alt="image-20190512152833269" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2ykeoqysnj310e0guq97.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-6：用可靠的洪泛法发送更新分组</p> 
  <p>&nbsp;</p> 
  <p><strong>OSPF的其他特点：</strong></p> 
  <ol>
   <li>为了确保链路状态数据库与全网的状态保持一致，OSPF还规定每隔一段时间，如30分钟，要<strong>刷新一次数据库中的链路状态</strong>。</li> 
   <li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而<strong>与整个互联网的规模并无直接关系</strong>。因此当<strong>互联网规模很大</strong>时，<strong>OSPF协议要比距离向量协议RIP好得多</strong>。</li> 
   <li>由于OSPF没有"坏消息传播得慢的问题，据统计，其响应网络变化的时间小于100 ms 。</li> 
   <li>若干个路由器连接在一个以太网上，则每个路由器要向其他<strong>(N-1)</strong>个路由器发送链路状态信息，因而共有<strong>N(N一1)</strong>个链路状态要在这个以太网上传送。OSPF协议对这种多点接入的局域网采用了<strong>指定的路由器(designMed router)</strong>的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。<strong>指定的路由器</strong>代表该局域网上<strong>所有的链路向连接到该网络上的各路由器发送状态信息</strong>。</li> 
  </ol>
  <h3 id="bgp">外部网关协议BGP</h3> 
  <p>BGP 是<strong>不同自治系统</strong>的路由器之间交换路由信息的协议。</p> 
  <p>互联网的规模太大，使得自治系统之间路由选择非常困难，对于自治系统之间的路由选择，要<strong>寻找最佳路由是很不现实的</strong>。 当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。 比较合理的做法是在 AS 之间交换<strong>“可达性”</strong>信息。 自</p> 
  <p>治系统之间的路由选择必须考虑有关策略。 因此，边界网关协议 BGP 只能是<strong>力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子）</strong>，而<strong>并非要寻找一条最佳路由</strong>。</p> 
  <p><strong>BGP</strong> <strong>发言人：</strong></p> 
  <p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的<strong>“ BGP 发言人” (BGP speaker)</strong> 。 一般说来，两个 BGP 发言人都是<strong>通过一个共享网络连接在一起的</strong>，而 BGP 发言人往往就是 BGP <strong>边界路由器</strong>，但<strong>也可以不是 BGP 边界路由器。</strong>每一个BGP发言人除了必须运行BGP协议之外，还<strong>必须运行该自治系统的内部网关协议，如OSPF或RIP。</strong></p> 
  <p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先<strong>建立 TCP 连接</strong>，然后在此连接上交换 BGP 报文以建立 <strong>BGP 会话(session)</strong>，利用 BGP 会话交换路由信息。 使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。 使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站(neighbor)</strong>或<strong>对等站(peer)。</strong></p> 
  <p><img alt="image-20190512153505189" class="has" src="https://ws1.sinaimg.cn/large/006tNc79gy1g2yklhlrsfj30zo0eqn5s.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-7：BGP发言人和自治系统AS的关系</p> 
  <p>&nbsp;</p> 
  <p>BGP 所交换的网络可达性的信息就是<strong>要到达某个网络所要经过的一系列 AS</strong>。 当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略<strong>从收到的路由信息中找出到达各 AS 的较好路由</strong>。</p> 
  <p><img alt="image-20190512153908625" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2ykpp9b46j30vo0dgadi.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-8：BGP发言人交换路径向量的例子</p> 
  <p>&nbsp;</p> 
  <p>图4-8给出了一个BGP发言人交换路径向量的例子，自治系统 AS2 的 BGP 发言人通知主干网 AS1 的 BGP 发言人：“要到达网络 N1、 N2、N3 和 N4 可经过 AS2。”，主干网在收到这个通知后，就发出通知："要到达网络 N1、 N2、N3 和 N4 可沿路径(AS1，AS2) "，主干网还可发出通知：“要到达网络 N5、N6 和 N7 可沿路径（AS1, AS3）。”</p> 
  <p>从上面的讨论可以看出，BGP 协议交换路由信息的结点<strong>数量级</strong>是<strong>自治系统数的量级</strong>，这要比这些自治系统中的网络数少很多，每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的，这样就使得自治系统之间的路由选择不致过分复杂。</p> 
  <p><strong>BGP协议的特点：</strong></p> 
  <ol>
   <li>BGP 支持&nbsp;<strong>CIDR</strong>，因此 BGP 的路由表也就应当包括<strong>目的网络前缀</strong>、<strong>下一跳路由器</strong>，以及<strong>到达该目的网络所要经过的各个自治系统序列</strong>。</li> 
   <li>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表，但以后只需要在发生变化时<strong>更新有变化的部分</strong>，这样做对<strong>节省网络带宽和减少路由器的处理开销</strong>都有好处。</li> 
  </ol>
  <p>BGP的4种报文：</p> 
  <ol>
   <li><strong>打开 (OPEN)</strong>&nbsp;报文，用来与相邻的另一个BGP发言人<strong>建立关系</strong>。</li> 
   <li><strong>更新 (UPDATE)</strong>&nbsp;报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li> 
   <li><strong>保活 (KEEPALIVE)</strong>&nbsp;报文，用来<strong>确认打开报文和周期性地证实邻站关系</strong>。</li> 
   <li><strong>通知 (NOTIFICATION)</strong>&nbsp;报文，用来<strong>发送检测到的差错</strong>。</li> 
  </ol>
  <p>若两个邻站属于两个<strong>不同AS</strong>，而其中一个邻站打算和另一个邻站定期地交换路由信息，这就应当有一个商谈的过程(因为很可能对方路由器的负荷已很重因而不愿意再加重负担)。因此，一开始向邻站进行商谈时就必须发送<strong>OPEN报文</strong>。如果邻站接受这种邻站关系，就用<strong>KEEPALTVE报文</strong>响应。这样，两个BGP发言人的邻站关系就建立了。一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存在的，且一直在保持这种邻站关系。为此，这两个BGP发言人彼此要<strong>周期性地交换KEEPALIVE报文</strong>(一般每隔30秒)。KEEPALIVE报文只有19字节长(只用BGP报文的通用首部)，因此<strong>不会造成网络上太大的开销</strong>。<strong>UPDATE报文</strong>是<strong>BGP协议的核心内容</strong>。BGP发言人可以用UPDATE报文<strong>撤销它以前曾经通知过的路由</strong>，也可以<strong>宣布增加新的路由</strong>。<strong>撤销路由</strong>可以<strong>一次撤销许多条</strong>，但<strong>增加新路由</strong>时，毎个更新报文<strong>只能增加一条</strong>。</p> 
  <p>BGP可以很容易地解决距离向量路由选择算法中的"坏消息传播得慢"这一问题。当某个路由器或链路出故障时，由于BGP发言人可以<strong>从不止一个邻站获得路由信息</strong>，因此<strong>很容易选择出新的路由</strong>。距离向量算法往往不能给出正确的选择，是因为这些算法<strong>不能指出哪些邻站到目的站的路由是独立的</strong>。</p> 
  <p><img alt="image-20190512155134798" class="has" src="https://ws2.sinaimg.cn/large/006tNc79gy1g2yl2n4puaj30zi0ekdj9.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-9：BGP报文具有的通用首部</p> 
  <p>&nbsp;</p> 
  <p>图4-9给出了BGP报文的格式。四种类型的BGP报文具有<strong>同样的通用首部</strong>，其长度为19字节。通用首部分为三个字段。<strong>标记(marker)</strong>字段为16字节长，用来鉴别收到的BGP报文(这是假定将来有人会发明出合理的鉴别方案)。当不使用鉴别时，标记字段要置为全1。<strong>长度字段</strong>指出包括通用首部在内的整个BGP报文以字节为单位的长度，最小值是19,最大值是4096。<strong>类型字段</strong>的值为1到4，分别对应于上述四种BGP报文中的一种。</p> 
  <p><strong>OPEN报文</strong>共有6个字段，即<strong>版本(1字节，现在的值是4)</strong>、<strong>本自治系统号(2字节，使用全球唯一的16位自治系统号，由ICANN地区登记机构分配)</strong>、<strong>保持时间(2字节，以秒计算的保持为邻站关系的时间)</strong>、<strong>BGP标识符(4字节，通常就是该路由器的IP地址)</strong>、<strong>可选参数长度(1字节)</strong>和<strong>可选参数</strong>。</p> 
  <p><strong>UPDATE报文</strong>共有5个字段，即<strong>不可行路由长度(2字节，指明下一个字段的长度)</strong>、<strong>撤销的路由(列出所有要撤销的路由)</strong>、<strong>路径属性总长度(2字节，指明下一个字段的长度)</strong>、<strong>路径属性(定义在这个报文中增加的路径的属性)</strong>和<strong>网络层可达性信息NLRI(Network Layer Reachability Information)</strong>。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP地址前缀。KEEPALIVE报文只有BGP的19字节长的通用首部。</p> 
  <p><strong>NOTIFICATION报文</strong>有3个字段，即<strong>差错代码(1字节)</strong>、<strong>差错子代码(1字节)</strong>和<strong>差错数据(给出有关差错的诊断信息)</strong>。</p> 
  <p>在讨论完路由选择之后，我们再来介绍路由器的构成。</p> 
  <h3 id="-28">路由器的组成</h3> 
  <p>路由器是一种典型的<strong>网络层设备</strong>，是互联网中的关键设备。</p> 
  <p>路由器的主要作用是：</p> 
  <ol>
   <li>连通不同的网络。</li> 
   <li>选择信息传送的线路，选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。</li> 
  </ol>
  <p>路由器的结构</p> 
  <p>路由器是一种具有<strong>多个输入端口</strong>和<strong>多个输出端口</strong>的专用计算机，其任务是<strong>转发分组</strong>。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。 下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。 路由器的转发分组正是网络层的主要工作。</p> 
  <p><img alt="image-20190512155320758" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2yl4hl0wdj30zs0eyq8s.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-10：典型路由器的结构</p> 
  <p>&nbsp;</p> 
  <p>如图4-10，整个的路由器结构可划分为两大部分：</p> 
  <ol>
   <li>路由选择部分</li> 
  </ol>
  <blockquote> 
   <p>也叫做控制部分，其核心构件是路由选择处理机。</p> 
   <p>路由选择部分路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。</p> 
  </blockquote> 
  <ol>
   <li>分组转发部分</li> 
  </ol>
  <blockquote> 
   <p>由三部分组成：</p> 
   <ul>
    <li>交换结构 (switching fabric)：又称为交换组织，其作用是根据转发表 (forwarding table) 对分组进行处理。</li> 
    <li>一组输入端口</li> 
    <li>一组输出端口</li> 
   </ul>
   <p>(请注意：这里的端口就是硬件接口）</p> 
  </blockquote> 
  <p>“转发”和“路由选择”的区别</p> 
  <p><strong>“转发”(forwarding)</strong> 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</p> 
  <p><strong>“路由选择”(routing)</strong> 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地<strong>改变所选择的路由</strong>。 <strong>路由表是根据路由选择算法得出的</strong>，而<strong>转发表是从路由表</strong>得出的。 在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。</p> 
  <p>输入端口对线路上收到的分组的处理</p> 
  <p>如图4-11所示，路由器的输入端口里面装有物理层、数据链路层和网络层的处理模块。 数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理，这会产生一定的时延。 输入端口中的查找和转发功能在路由器的交换功能中是最重要的。</p> 
  <p><img alt="image-20190512155706959" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2yl8emrdwj30zs0eytdi.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-11</p> 
  <p>&nbsp;</p> 
  <p><strong>输出端口将交换结构传送来的分组发送到线路</strong></p> 
  <p>如图4-12所示，输出端口里面装有物理层、数据链路层和网络层的处理模块。 输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。 在网络层的处理模块中设有一个缓冲区（队列）。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。 数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</p> 
  <p><img alt="" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2yl8tkqqtj30zs0ey78v.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-12</p> 
  <p>&nbsp;</p> 
  <p>分组丢弃</p> 
  <p>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</p> 
  <p>交换结构</p> 
  <p><img alt="image-20190512160037273" class="has" src="https://ws3.sinaimg.cn/large/006tNc79gy1g2ylc1ogirj31040gowku.jpg"></p> 
  <p>&nbsp;</p> 
  <p>图4-13</p> 
  <p>&nbsp;</p> 
  <p>交换结构是路由器的关键构件， 正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。 实现交换有多种方法，如图4-13所示，常用交换方法有三种：</p> 
  <ol>
   <li> <p>通过存储器</p> </li> 
   <li> <p>通过总线</p> </li> 
   <li> <p>通过纵横交换结构</p> </li> 
  </ol>
  <p>通过存储器</p> 
  <p>(1) 当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。</p> 
  <p>(2) 路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。</p> 
  <p>(3) 若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）一定小于 M/2。</p> 
  <p>通过总线</p> 
  <p>(1) 数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。</p> 
  <p>(2) 因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。</p> 
  <p>(3) 现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。</p> 
  <p>通过纵横交换结构 (crossbar switch fabric)</p> 
  <p>(1) 这种交换结构常称为互连网络 (interconnection network)。</p> 
  <p>(2) 它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接。</p> 
  <p>(3) 当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。</p> 
  <p>(4) 若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。</p> 
  <p>(5) 但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到达的分组就被阻塞，必须在输入端口排队。</p> 
  <h2 id="ipv6">IPV6</h2> 
  <h2 id="ip-9">IP多播</h2> 
  <h2 id="vpnnat">虚拟专用网VPN和网络地址转换NAT</h2> 
  <h2 id="mpls">多协议标记交换MPLS</h2> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
