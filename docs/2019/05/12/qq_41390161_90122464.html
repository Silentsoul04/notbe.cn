<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>基于python-scrapy框架的爬虫系统（可以做毕业设计） « NotBeCN</title>
  <meta name="description" content="                  爬虫简单介绍   需要毕设的同学可以联系我：609997553/wechat:wwj901521   一、爬虫：就是抓取网页数据的程序 二、爬虫如何抓取： 网页三大特征：       网页都有自己唯一的URL（统一资源定位符）来进行定位    网页都使用HTML （超文本标记语...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/qq_41390161_90122464.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">基于python-scrapy框架的爬虫系统（可以做毕业设计）</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h1><a id="_1"></a>爬虫简单介绍</h1> 
  <h2><a id="609997553wechatwwj901521_3"></a>需要毕设的同学可以联系我：609997553/wechat:wwj901521</h2> 
  <p>一、爬虫：就是抓取网页数据的程序<br> 二、爬虫如何抓取：<br> 网页三大特征：</p> 
  <ol> 
   <li>网页都有自己唯一的URL（统一资源定位符）来进行定位</li> 
   <li>网页都使用HTML （超文本标记语言）来描述页面信息。</li> 
   <li>网页都使用HTTP/HTTPS（超文本传输协议）协议来传输HTML数据。</li> 
  </ol> 
  <p>爬虫的设计思路：</p> 
  <ol> 
   <li>首先确定需要爬取的网页URL地址。</li> 
   <li>通过HTTP/HTTP协议来获取对应的HTML页面。</li> 
   <li>提取HTML页面里有用的数据：<br> a. 如果是需要的数据，就保存起来。<br> b. 如果是页面里的其他URL，那就继续执行第二步。</li> 
  </ol> 
  <p>通用爬虫工作流程：<br> 爬取网页 - 存储数据 - 内容处理 - 提供检索/排名服务</p> 
  <h2><a id="1　___22"></a>第1章　绪 论</h2> 
  <p>伴随着互联网不断的发展，很多从事计算机行业的工作者不再满足于不能自己控制的目标不够明确的搜索引擎，于是网络爬虫应景而生。网络爬虫是一种按照程序设计者所设定的规则，自我驱动抓取网页信息的程序或者脚本。网络爬虫的先进性在于它不仅可以爬取整个网页并保存，而且具有高度的可自定义性。我们可以根据自己想要获取的数据格式来调整爬虫，使其剔除掉无用的部分而保留有效信息。当今著名的搜索引擎公司都采用了不同的爬虫算法，在其他领域如金融、教育等行业，爬虫也在发挥着重大的作用。<br> 1.1选题的意义<br> 进入 21世纪，特别是第二个十年，世界互联网取得了惊人的快速发展。根据分析师玛丽·米克尔 (Mary Mikel) 2016年发布的一份互联网趋势报告，到2016年年中，全球互联网用户超过30亿，约占全球总人口的40%，中国超过6.9亿互联网用户维持了多年来全球最大的互联网用户市场。互联网的快速发展，同时互联网产生的数据量也随着互联网用户的不断涌入而产生了爆炸性的增长，世界进入了"大数据"时代。欧洲最大的电子优惠券应用提供商Vouchercloud在2015年发布的一份报告显示，每天在互联网上生成的数据高达2.5万亿字节 (五分之一字节)，这些数据可以充满超过1亿张蓝光光盘 (25GB)容量)。因此，如何在互联网上查询海量信息中的有价值数据，成为一个需要解决的问题。<br> 在互联网的早期，人们主要通过浏览门户网站获得所需的信息，但随着 WEB 技术的快速发展，使用这种方法来查找所需的信息变得越来越困难。随着互联网的发展和壮大，人们对信息的获取逐渐被网络所取代。目前，人们大多通过搜索引擎获得有用的信息，因此，搜索引擎技术的发展将直接影响人们获得所需信息的速度和质量。<br> 然而，随着互联网上数据量的迅速增长，由于不同领域对相同或相似关键字的模糊性，使用通用搜索引擎检索到的结果包含大量的干扰信息，户往往需要额外支付精力人工去筛选出有效信息。特别是在互联网快速发展的今天，人们的衣、食、住、行都与互联网紧紧联系到了一起。例如，在住房租赁市场上，已经逐步完成了市场对传统线下实体向互联网在线迁移的关注，越来越多的租房者通过互联网寻找合适的住房。互联网上有越来越多的网站可以提供有关租赁上市的信息。在实际搜索人们的租赁信息的过程中，租赁信息可能会分布在网站的各个页面上，人们如果想对信息进行比较，往往需要同时打开多个页面作为参考，所以要想收集多个信息， 这是一个繁琐和枯燥的过程，它需要大量的时间。此外，当搜索完成时， 如果对租赁信息的分类和整理，也是一条一条记录，很容易产生错误，所以这种传统的手动查询不能满足现实生活的需要，在这种工作状态下集中体现了以下两个方面的问题：<br> 一是步骤繁琐，人员工作量繁重，导致工作效率和准确性下降。<br> 其次，可能导致信息重复、错误、遗漏率高、增加时间成本、与高效处理问题的概念偏离。<br> 因此，可以采用现代计算机网络技术，构建分布式租赁信息自动抓取系统，不仅可以快速、高效地收集、分类、提取、分析和处理租赁信息，与原手工查询信息相比，提高了信息资源的利用率，降低了人工时间的成本。<br> 1.2 国内外现状<br> 1.2.1网页采集的研究现状<br> 如今，国内外的信息收集系统越来越多，包括各种开源或商用爬虫。其一般是一个广义的信息采集系统，具有典型的特点是: 针对所有的网络平台进行探索。<br> 其分类包括:<br> (1)个性化的WEB信息获取<br> 根据用户的需求和偏好，以及和用户的互动等，可以尽可能满足用户个性化、多样化的信息需求，这是用户的一个重要特点。个性化的 WEB 信息收集。根据用户的习惯进行分析，设置根系统提供的接口是获取个性化信息的两种最常见的方法。SPHINX 是最具代表性的个性化信息采集系统。<br> (2)面向主题为导向的WEB信息获取<br> 根据主题的手动设置，有针对性地获取与主题相关的页面信息是面向主题的Web信息获取 (Focused Web Crawling) 的一个重要特征。关键词、样本采集信息通常被确定为阐述的要点。与包含所有WEB范围的信息采集系统相比，它具有个性化、针对性， 并能节省硬件和网络资源，这是一个非常突出的优势。<br> (3)增量WEB信息获取在收集信息<br> 有必要定期更新和优化网页，这通常是通过增量Web信息获取来实现的。它的特点是，在很长一段时间内，在要收集的信息更新后，随后的信息收集工作将以更新页面为目标，不会去重新捕获以前收集的信息。高采集效率是其典型特征。其中最具代表性的包括: 天网增量采集系统、ChileCrawler、WebFountain和Univ。<br> (4)所有基于web的信息获取<br> 目前， 最广泛使用的信息获取方法是基于整个WEB范围的信息获取。以最初设置的URL作为入口沿链接在网页上收集，在硬件系统的允许条件下，这种信息采集的范围可以涵盖整个互联网，所以这样的爬行策略是非常适合大最典型的代表是谷歌。<br> (5)分布式WEB信息采集<br> 分布式WEB信息采集作为一种协调， 是通过多个协同并行采集目标网站收集网络信息收集器的一种机制，也是最大的这种采集方法和其他采集方法的优点是分布式WEB信息采集的速度和性能较高。这种信息获取方式还存在两个困难，即如何快速处理页面负载协调和服务数据共享问题。<br> (6)迁移信息采集信息<br> 通过Web采集器上传到目标区域的方式收集的，最终结果反馈给本地，这是迁移获取的一个重要特征。进一步减少了对本地资源的需求，这是一个典型的优势。缺陷意味着这种模式会给目标区域带来病毒攻击的威胁。<br> 1.2.2 网页信息抽取的技术现状<br> 网页中的信息大多是以半结构化的形式存在的，这些半结构化的信息并不能被索引，所以要把半结构化的数据抓换成结构化的数据。网页信息抽取是指，根据用户的需要从半结构化的网页中识别并抽取嵌套在HTML标签中的信息。按照信息抽取工作的实现原理可分为如下几类：<br> （1）基于包装器模型的信息抽取<br> 包装器是一种基于规则的文本信息抽取模型。这种抽取方式只依靠语义上下文就可以实现信息定位。这中信息抽取方式的最大特点就是根据大量的样本运用机器学习的归纳算法进行训练生成抽取规则，根据训练生成的抽取规则进行进行信息抽取。<br> （2）基于网页结构的信息抽取<br> 这种抽取方式主要是将HTML文档解析成DOM树，DOM树结构是十分便于信息抽取。这种方法十分突出的优点就是使用相对简单的操作精准的将网页中的信息抽取出来。<br> （3）基于自然语言处理的信息抽取<br> 这种抽取方式存在比较大的缺点就是抽取的速度很慢，由于此技术还处在发展阶段在抽取信息时存在抽取出来的内容和对于文本内容的理解差异比较大的情况。它的优势是擅长抽取对象是大量文本的信息源。<br> （4）基于ontology的信息抽取<br> 这种抽取方式应用的范围较小，主要的原因是该方法需要大量的人工介入，目前只形成了一套半自动化的抽取方式。这种方式的有点是不依赖网页结构通过对数据本身的描述信息就能完成的对信息的抽取。<br> 1.2.3 网络爬虫发展趋势<br> 自1994年以来，世界上第一个网络搜索工具网络爬虫问世，目前比较流行的搜索引擎有百度、谷歌、雅虎、必应等。出于商业保密的考虑，各种搜索引擎使用的爬虫系统的技术内部人员一般不公开，现有文献仅限于摘要介绍。随着网络信息资源的指数化增长和网络信息资源的动态变化，传统搜索引擎提供的信息检索服务已不能满足人们对个性化服务日益增长的需求，正面临着巨大的挑战。以什么样的网络接入策略，提高搜索效率，已成为近年来专业搜索引擎网络爬虫研究的主要问题之一。<br> 1.3 论文研究主要内容<br> 本文研究的内容主要是爬虫技术在租房信息爬取中的应用，并采用python实现的开源爬虫框架Scrapy来开发，解决单进程单机爬虫的瓶颈，使用Xpath技术对下载的网页进行提取解析，再利用成熟的数据可视化框架对爬取的数据进行友好可视化。<br> 因此本文的核心研究内容可以总结为以下几点：<br> 1.分布式爬虫系统环境的搭建；<br> 2.网页内容的正确解析；<br> 3.分布式队列的实现；<br> 4.租房数据的存储与可视化。</p> 
  <h2><a id="2　_68"></a>第2章　关键技术介绍</h2> 
  <p>本系统设计的目的是让需要出租或求租的用户能够在海量网页中快速找到目标房源信息，此次设计选择58同城的房屋租赁信息，通过爬虫来爬取有关网页，实现关键信息抽取。下面简要介绍该系统使用的关键技术：<br> 2.1 Python语言及开源库的介绍<br> 2.1.1 python语言简介<br> 本系统的开发语言为Python，它是一种近些年来逐渐流行的编程语言，是一种解释型的、面向对象的、带有动态语义的高级程序设计语言；Python程序的可读性是业界得到公认的代码最具可读性性的语言，读python的代码如同读英文一样简单易懂，其创始人Guido van Rossum的初衷就是创造一门具有高度可读性且功能强大的语言。目前Python不仅在机器学习和大数据处理方面得到广泛应用，而且在网络信息爬取和收集方面发挥着重要的作用。它不仅能够高效地爬取大量信息，可以简单而迅速地在互联网上获取自己所感兴趣的信息，而且在关键内容解析和提取方面相对于其他语言更加有优势。<br> 2.1.2 requests库简介<br> requests库是一个基于Python开发的请求网络数据并进行抓取的开源第三方库，requests库的宣言是:HTTP for Humans（给人用的 HTTP 库）。的确，正如其宣言所说的那样，相比Python自带的urllib和urllib2库，虽然二者的功能和requests库一样，但urllib和urllib2库语法使用和接口调用并不符合高级程序语言的习惯，而是更加接近底层语言。当然这种模式为程序的执行效率带来了一定的优势。而requests库有着优雅的语法和符合高级语言的使用特点。<br> （1）requests库的安装：以Windows操作系统为例，其实如果配置了并安装了python3以上版本的python源代码。则可以通过Python语言安装Python库的通用方法pip3命令来安装，在命令行窗口输入命令代码为：pip3 install packgename，packgename为要安装的安装包的名字。比如这里安装rquests库，那么代码就是pip3 install requests。如果命令行窗口提示requests install Successfully则表明安装成功。<br> （2）requests的功能说明及具体实例：requests的最基本的操作，就是以HTTP的某种方法向服务器端发送一个请求，而requests库就是这么做的，requests库设计的非常自然。函数requests.get就是以HTTP的get方法向服务器端发送一个request，其程序的一切工作方式和真实环境中人为操作完全类似，这就是为什么requests库被称为最具人性化的库的原因。现在通过域名“.58.com”在PC浏览器端登录了58同城北京的首页，这一个操作就是向58同城服务器发出一个request，58同城服务器在收到请求后给返回请求的数据，也就是58同城北京首页。而request库的工作原理和这样人为请求完全类似。<br> 2.1.3 lxml库简介<br> Lxml库是一个可以从HTML或XML等文件中提取任意想要数据的Python库.它能够通过转换器实现惯用的文档导航，查找，修改文档的方式. Lxml会帮普通开发者节省数小时甚至数天的工作时间，尤其对于那些不太了解网页HTML，CSS，JS等开发语言的开发者来说更是一大福音。<br> 由于Xpth方式在对网页元素筛选时具有比另外一种网页解析库Beautiful Soup具有更高的效率，其对网页的解析速度是Beautiful Soup库的十倍左右。所以XPath在Python的爬虫学习中，起着举足轻重的地位，所以得到了广泛的应用。对比正则表达式 re两者可以其实可以实现一样的功能，但XPath明显比re具有优势，在网页分析上使re退居二线。<br> 2.2 爬虫技术及scrapy框架介绍<br> 2.2.1 爬虫技术简介<br> 使用爬虫的前提是了解HTTP协议，通过浏览器浏览网页的时候，每点击一个按钮，都是向服务器发送一个request，而加载出来的网页就是服务器返回来的数据，把返回数据的这一行为叫做response。而爬虫的工作原理就是在模拟真实的浏览器或者使用浏览器的用户的上网行为，去向服务器发送请求，然后服务器返回给该爬虫向服务器所请求的数据。一般通用的爬虫设计方式是：先从某个网站的已知的URL开始，下载网站头网页后，解析出里面有用的URL，并把链接URL作为种子URL存放到待处理的队列中，作为将来爬虫进行下一步爬取的入口。然后根据一定的爬虫算法如广度优先算法、深度优先算法，最佳优先搜索算法等进行搜索抓取网页，直到满足特定的条件为止。被网络爬虫抓取的网页会被存储系统存储，进行分析与处理，进而建立去重索引，已避免爬虫的重复爬取。<br> 2.2.2 Scrapy框架简介<br> Scrapy作为用python实现的爬虫库，被广泛使用。它为您提供了从网站中高效提取数据、根据需要处理数据以及以首选结构和格式存储数据所需的所有工具。由于互联网是多样化的，在从网站中提取数据时，没有 “一刀切” 的方法。很多时候都会采取临时方法， 如果您开始为执行的每个小任务编写代码， 那么使用Scrapy框架是最佳的选择，因为其提供了一系列方便的应用模板。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511235223527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzkwMTYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <pre><code>                                                     图2.1 Scrapy架构图
</code></pre> 
  <p>Scrapy Engine：负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。<br> Scheduler：它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。<br> Downloader：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理。<br> Spider：它负责处理所有Responses，从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)。<br> Item Pipeline：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。<br> Spider Middlewares：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）。</p> 
  <h2><a id="4　_96"></a>第4章　系统设计</h2> 
  <p>4.1 爬虫的流程设计<br> 一般情况下，一个通用的网络爬虫包括种子URL，待抓取URL，已抓取URL，已下载的网页库四部分组成。具体如图4.1所示。其具体的工作流程为：<br> 1.首先确认种子URL，这个URL可能是网站的首页域名。总之目的是从该网页获得以后要抓取内容的网页的URL，并选取其中想要爬取的种子URL。<br> 2.将这些种子URL放入待抓取URL队列中，为了便于后期的去重处理，这些URL一般存储在数据库里或者列表里。<br> 3.爬虫系统每次运行时从待抓取URL队列中取出一个URL，解析其DNS，并且得到主机服务器的IP地址，并将URL对应的网页下载下来，后用LXML库解析出关键信息并存到数据库。最后将这些已经使用过的URL放进已抓取URL队列中。<br> 4.分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</p> 
  <p>图4.1 网络爬虫流程<br> 4.2 数据库设计<br> 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。在目前市面上流行的数据库无非两种，一种是关系型数据库，另一种是非关系型数据库。<br> 关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。市面上主流的数据库如Mysql，oracle，SQLserver都属于关系型数据库，通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。本项目这里使用Mysql进行数据的存储，数据表的设计如下：</p> 
  <h2><a id="5　_108"></a>第5章　系统实现</h2> 
  <p>5.1 URL管理实现<br> 爬取租房信息详情模块是爬虫系统的核心，种子URL在该程序模块一般仍然需要再次加工，因为要爬虫自动爬取所有租房信息，但第一个程序抓取的类目URL只能进入商品第一页。可以肯定的是这种大规模的网站的商品列表并不止一页，如图5.1所示。</p> 
  <p>图5.1 58同城租房信息列表页页码<br> 所以需要让程序实现自动更换页码。这种情况需要观察不同页码URL的样式，找出其中的规律，然后利用程序实现自动换页。观察58同城同一类目下不同页码的商品列表页的链接地址。<br> 页面2的域名为：<br> “<a href="http://bj.58.com/chuzu/0/pn2/?PGTID=0d300024-0000-1e7f-ec58-54933d31024c&amp;ClickID=3%E2%80%9D" rel="nofollow">http://bj.58.com/chuzu/0/pn2/?PGTID=0d300024-0000-1e7f-ec58-54933d31024c&amp;ClickID=3”</a><br> 页面3的域名为：<br> “<a href="http://bj.58.com/chuzu/0/pn3/?PGTID=0d300024-0000-1c5a-e5e6-3f9c6886871c&amp;ClickID=2%E2%80%9D" rel="nofollow">http://bj.58.com/chuzu/0/pn3/?PGTID=0d300024-0000-1c5a-e5e6-3f9c6886871c&amp;ClickID=2”</a><br> 观察后不难发现，两页的域名只是随着页码的改变而改变，页面二的域名是pn2，页码3的域名是pn3，其他都一样（至于域名中问号后面的内容不会影响网页的加载，所以是否一样并不大碍）。所以就可以利用python自带的format函数来实现该功能。程序运行的结果如图5.2所示。</p> 
  <p>图5.2 租房信息详情页链接<br> 为了规避一些特殊的情况的发生：如爬取到了不存在的页面，无论是404页面，还是页面无信息的页面，都需要做程序做异常处理，以免爬虫程序出现瘫痪。<br> 这种情况一般根据极限页面与普通页面的不同来进行筛选。比如正常情况下的页面都是有某个标签组成，但极限页面无此标签。所以此时可以使用find()函数来过滤极限页面，筛选普通页面。而404页面是不存在的页面。比如58同城里已近下架或者已近出售。58的系统会自动将该页面进行删除。以防其他人再联系卖家。给卖家带来不便。如果程序不对这种类型的页面做处理，就会使得程序出现报错而崩溃。对于这种页面的处理是通过404页面的特点进行判断然后筛选过滤。这种情况一般用状态码来做判断，所谓状态吗是指网页返回的Code，一般为404，403和200。<br> 5.2 页面数据解析实现<br> 在进行数据爬取的时候，如果爬虫如果不构造合理的请求头，就不会将这些字段发送给对方的服务器。对方的反爬程序会将这种请求视为非人类的请求而不予响应或者直接封杀请求来源的IP地址。就好比，人家每家都有门，现在以一个路人的身份直接闯进去显然不是很礼貌。而且有一些站点不喜欢被程序（非人为访问）访问，有可能会拒绝你的访问请求。但是如果我们用一个合法的身份去请求别人网站，显然人家就是欢迎的，所以我们就应该给我们的这个代码加上一个身份，就是所谓的User-Agent头。<br> 所以爬虫这时候需要伪造其爬取的目标网站的请求头，以避开对方的反爬虫系统。HTTP的请求头是在你在每次向网络服务器发送请求时，传递的一组属性和配置信息。比如58同城的请求头，如图5.3所示。</p> 
  <p>图5.3 HTTP请求头<br> 而前面介绍过的requests模块是一个设置请求头的利器，具体的为将目标网站的头文件伪造成浏览器的样式进行发送，具体代码如下：<br> headers = {<br> ‘User-Agent’: userAgent，<br> ‘Accept’: ‘text/html，application/xhtml+xml，application/xml;q=0.9，image/webp，<em>/</em>;q=0.8’，<br> ‘Accept-Encoding’: ‘gzip， deflate， sdch’，<br> ‘Accept-Language’: ‘zh-CN，zh;q=0.8’，<br> ‘Cache-Control’: ‘max-age=0’，<br> ‘Connection’: ‘keep-alive’<br> ‘Cookie’:‘id58=BYP9vldY+bKkELYW/4OXgw==;mcity=qhd;myfeet_tooltip=end; bj58_new_session=1; bj58_init_refer=“<a href="http://qhd.58.com/sale.shtml?utm_source=link&amp;spm=s-35409279166478-pe-f-809.pes_pcshop_ershou" rel="nofollow">http://qhd.58.com/sale.shtml?utm_source=link&amp;spm=s-35409279166478-pe-f-809.pes_pcshop_ershou</a>”;bj58_new_uv=1; bj58_id58s=“K2lUSHM2WUE1TDQyMzY5NA==”; sessionid=3807a2ee-e5bb-40aa-a1b2-8566a4daa9a2;__utmt=1; __utma=253535702.1391934569.1465450349.1465450349.1465450349.1; __utmb=253535702.1.10.1465450349;__utmc=253535702; __utmz=253535702.1465450349.1.1.utmcsr=link|utmccn=(not%20set)|utmcmd=(not%20set); als=0; bj=201669133230; 58home=bj; ipcity=qhd%7C%u79E6%u7687%u5C9B%7C0; f=n; city=bj; 58tj_uuid=d855a902-f081-4b23-9340-1b08713c0090; new_session=0; new_uv=1; utm_source=link;spm=s-35409279166478-pe-f-809.pes_pcshop_ershou; init_refer=http%253A%252F%<a href="http://252Fwww.1shoping.net" rel="nofollow">252Fwww.1shoping.net</a>%252F’<br> }<br> 而对于数据的爬取，如获取标题信息：</p> 
  <p>图5.4 标题信息例图<br> 对应的html内容为：</p> 
  <p>图5.5 标题信息对应的html内容<br> 接着使用下列代码即可获取标题：<br> html=etree.parse(response.read() )<br> title=html.xpath(’/html/body/div[4]/div/div[5]/div[2]/ul/li[1]/div[2]/h2/a/text()’)<br> 其他信息的获取方式类似，不再赘述。<br> 5.3数据存储及可视化实现<br> 5.3.1数据存储实现<br> 在数据存储方面，我们使用Python下的Pymysql库实现数据库的连接与数据插入。连接语句如下所示。<br> pymysql.connect(host=yinxing.settings.MYSQL_HOST，port=3306， db=yinxing.settings.MYSQL_DBNAME，user=yinxing.settings.MYSQL_USER，passwd=yinxing.settings.MYSQL_PASSWD，charset=‘utf8’，use_unicode=True)<br> 通过上面的操作，我们将爬取的租房信息中的标题，地址，价格等信息依次存储到数据库里面，前提是事先我们已经在数据库建好了数据表。<br> 图5.6是以北京房源为例的数据表信息（因数据过长，只展示部分数据）。<br> 图5.6 存储的房源数据<br> 5.3.2 数据可视化实现</p> 
  <p>数据分析与可视化本质上是数据挖掘与分析最关键的一环，可以想象如果不能将数据分析做好，前面所做的一切都将无任何意义。在这里我们选择Echarts库来进行数据的可视化，Echarts库是一个由纯 Javascript开发的图表库，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。因为是用Javascript开发，所以其兼容性非常优秀，可在目前市面上所有的浏览器上运行。<br> 在用Echarts时，只能在获得数据后在HTML文件里单独调用Echarts。将主要介绍Echarts的使用方式。<br> Echarts使用方法：<br> 1）到百度Echarts官网下载Echarts，把该文件放在建立的HTML文件夹下。<br> 2）在HTML文件里为Echarts准备一个具备大小的DOM。<br> 3）在HTML文件里引入Echarts<br> 4）在HTML直接调用需要用到的Echarts函数<br> 具体代码如下：</p> 
  <title>ECharts</title> 
  <!-- 1.&#24341;&#20837; echarts.js --> 
  <p>可视化的结果如图所示：</p> 
  <p>图5.6 数据可视化结果</p> 
  <p>图5.7 北京市各地区租房数量占比</p> 
  <h2><a id="6　_213"></a>第6章　系统测试</h2> 
  <p>一个软件的产生是需要经过一个生命周期的，软件生存周期或者系统开发生命周期都可以称为软件生命周期，该周期不仅记录了软件从产生到废弃的过程，周期内有问题定义、可行性分析、需求分析、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等各个阶段。对于软件来说其中的每一个阶段都是不可或缺的，但是软件测试在其中起着极其重要的作用，只有该系统满足了系统的需求分析并且能够正常使用，那么这个系统才是完整的。<br> 软件测试是在软件设计完成后对该系统进行严谨的测试，以发现系统在整个设计过程中存在的问题并对该问题进行修改，是对软件需求分析、设计、编码的最终复查的一系列过程，是软件质量保证的关键步骤。<br> 本次主要对于网页数据解析部分进行系统的功能测试，该测试主要是为了保证数据抓取的完整性和有效性，防止有效数据的缺失，在完成本部分功能基础上，实现整个分布式爬虫系统的正常和稳定工作。<br> 6.1 测试环境<br> 本次测试的软硬件环境如下所示：<br> 处理器：Inter® Core ™2 i5-4200U CPU @ 1.60GHz 2.30GHz<br> 内存：4GB<br> 硬盘：750G<br> 操作系统：Windows 7<br> 数据库：MySQL<br> Python 版本：3.6.5<br> Scrapy版本：1.5.1<br> 6.2 测试方案及测试用例<br> 根据系统的设计功能和要求，采用黑盒测试的方法对基于Scrapy框架的网络爬虫系统进行测试。黑盒测试本质上是根据软件的需求规格对软件所实施的测试，该类测试不涉及软件内部的运作原理，只对结果进行判断，因此软件对用户来说就像一个黑盒子。软件测试人员以用户的角度，通过观察软件的各种输入和输出结果来发现软件存在的缺陷，从而为后期维护和修改提供参考。</p> 
  <p>表6-1测试内容<br> 测试内容 测试用例 测试结果<br> 自动翻页 从首页爬取，统计爬取最终数量 正常翻页<br> 价格信息解析 随机选取几个详情页面进行测试 正常解析价格信息<br> 重复UrL处理 加入重复地址进行测试 对重复地址进行了丢弃<br> 404页面处理 进入404页面 正常跳过</p> 
  <p>6.3 测试结论</p> 
  <p>通过上述的几项测试，我们针对测试结果，分析测试报错原因，并进行调试解决报错问题。经过再次对基于Scrapy框架的网络爬虫系统进行调试，系统最终运行平稳，各个模块之间接口顺畅，房屋租赁信息爬取功能正常有效；分布式爬取功能也能够有效开展，系统能够提供各项预期的服务，满足系统运行目标的实现，符合系统开发要求，也达到了测试的目的。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
