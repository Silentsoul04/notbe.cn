<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>物联网第二步： Tornado-接口与模版 « NotBeCN</title>
  <meta name="description" content="          3.3 输出   1. write(chunk)   将chunk数据写到输出缓冲区。如我们在之前的示例代码中写的：   class IndexHandler(RequestHandler):    def get(self):        self.write("hello itcast!...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/sinat_26940175_90137513.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">物联网第二步： Tornado-接口与模版</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <h1 id="33-输出">3.3 输出</h1> 
  <h2 id="1-writechunk">1. write(chunk)</h2> 
  <p>将chunk数据写到输出缓冲区。如我们在之前的示例代码中写的：</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        self.write("hello itcast!")
</code></pre> 
  <p>想一想，可不可以在同一个处理方法中多次使用write方法？</p> 
  <p><strong>下面的代码会出现什么效果？</strong></p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        self.write("hello itcast 1!")
        self.write("hello itcast 2!")
        self.write("hello itcast 3!")
</code></pre> 
  <blockquote> 
   <p>write方法是写到缓冲区的，我们可以像写文件一样多次使用write方法不断追加响应内容，最终所有写到缓冲区的内容一起作为本次请求的响应输出。</p> 
  </blockquote> 
  <p>想一想，如何利用write方法写json数据？</p> 
  <pre class="has">
<code>import json

class IndexHandler(RequestHandler):
    def get(self):
        stu = {
            "name":"zhangsan",
            "age":24,
            "gender":1,
        }
        stu_json = json.dumps(stu)
        self.write(stu_json)
</code></pre> 
  <p><strong>实际上，我们可以不用自己手动去做json序列化，当write方法检测到我们传入的chunk参数是字典类型后，会自动帮我们转换为json字符串。</strong></p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        stu = {
            "name":"zhangsan",
            "age":24,
            "gender":1,
        }
        self.write(stu)
</code></pre> 
  <p>两种方式有什么差异？</p> 
  <p>对比一下两种方式的响应头header中<code>Content-Type</code>字段，自己手动序列化时为<code>Content-Type:text/html; charset=UTF-8</code>，而采用write方法时为<code>Content-Type:application/json; charset=UTF-8</code>。</p> 
  <p><strong>write方法除了帮我们将字典转换为json字符串之外，还帮我们将<code>Content-Type</code>设置为<code>application/json; charset=UTF-8</code>。</strong></p> 
  <h2 id="2-setheadername-value">2. set_header(name, value)</h2> 
  <p>利用set_header(name, value)方法，可以手动设置一个名为name、值为value的响应头header字段。</p> 
  <p>用set_header方法来完成上面write所做的工作。</p> 
  <pre class="has">
<code>import json

class IndexHandler(RequestHandler):
    def get(self):
        stu = {
            "name":"zhangsan",
            "age":24,
            "gender":1,
        }
        stu_json = json.dumps(stu)
        self.write(stu_json)
        self.set_header("Content-Type", "application/json; charset=UTF-8")
</code></pre> 
  <h2 id="3-setdefaultheaders">3. set_default_headers()</h2> 
  <p>该方法会在进入HTTP处理方法前先被调用，可以重写此方法来预先设置默认的headers。<strong>注意：在HTTP处理方法中使用set_header()方法会覆盖掉在set_default_headers()方法中设置的同名header。</strong></p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def set_default_headers(self):
        print "执行了set_default_headers()"
        # 设置get与post方式的默认响应体格式为json
        self.set_header("Content-Type", "application/json; charset=UTF-8")
        # 设置一个名为itcast、值为python的header
        self.set_header("itcast", "python")

    def get(self):
        print "执行了get()"
        stu = {
            "name":"zhangsan",
            "age":24,
            "gender":1,
        }
        stu_json = json.dumps(stu)
        self.write(stu_json)
        self.set_header("itcast", "i love python") # 注意此处重写了header中的itcast字段

    def post(self):
        print "执行了post()"
        stu = {
            "name":"zhangsan",
            "age":24,
            "gender":1,
        }
        stu_json = json.dumps(stu)
        self.write(stu_json)
</code></pre> 
  <p>终端中打印出的执行顺序：</p> 
  <p><img alt="" class="has" height="141" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100738946.png" width="553"></p> 
  <p>get请求方式的响应header:</p> 
  <p><img alt="" class="has" height="198" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100759845.png" width="574"></p> 
  <p>post请求方式的响应header:</p> 
  <p><img alt="" class="has" height="408" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100819235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="821"></p> 
  <h2 id="4-setstatusstatuscode-reasonnone">4. set_status(status_code, reason=None)</h2> 
  <p>为响应设置状态码。</p> 
  <p>参数说明：</p> 
  <ul>
   <li>status_code int类型，状态码，若reason为None，则状态码必须为下表中的。</li> 
   <li>reason string类型，描述状态码的词组，若为None，则会被自动填充为下表中的内容。</li> 
  </ul>
  <table>
   <thead>
    <tr>
     <th>Code</th> 
     <th>Enum Name</th> 
     <th>Details</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>100</td> 
     <td>CONTINUE</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.2.1</td> 
    </tr>
    <tr>
     <td>101</td> 
     <td>SWITCHING_PROTOCOLS</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.2.2</td> 
    </tr>
    <tr>
     <td>102</td> 
     <td>PROCESSING</td> 
     <td>WebDAV RFC 2518, Section 10.1</td> 
    </tr>
    <tr>
     <td>200</td> 
     <td>OK</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.3.1</td> 
    </tr>
    <tr>
     <td>201</td> 
     <td>CREATED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.3.2</td> 
    </tr>
    <tr>
     <td>202</td> 
     <td>ACCEPTED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.3.3</td> 
    </tr>
    <tr>
     <td>203</td> 
     <td>NON_AUTHORITATIVE_INFORMATION</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.3.4</td> 
    </tr>
    <tr>
     <td>204</td> 
     <td>NO_CONTENT</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.3.5</td> 
    </tr>
    <tr>
     <td>205</td> 
     <td>RESET_CONTENT</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.3.6</td> 
    </tr>
    <tr>
     <td>206</td> 
     <td>PARTIAL_CONTENT</td> 
     <td>HTTP/1.1 RFC 7233, Section 4.1</td> 
    </tr>
    <tr>
     <td>207</td> 
     <td>MULTI_STATUS</td> 
     <td>WebDAV RFC 4918, Section 11.1</td> 
    </tr>
    <tr>
     <td>208</td> 
     <td>ALREADY_REPORTED</td> 
     <td>WebDAV Binding Extensions RFC 5842, Section 7.1 (Experimental)</td> 
    </tr>
    <tr>
     <td>226</td> 
     <td>IM_USED</td> 
     <td>Delta Encoding in HTTP RFC 3229, Section 10.4.1</td> 
    </tr>
    <tr>
     <td>300</td> 
     <td>MULTIPLE_CHOICES</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.4.1</td> 
    </tr>
    <tr>
     <td>301</td> 
     <td>MOVED_PERMANENTLY</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.4.2</td> 
    </tr>
    <tr>
     <td>302</td> 
     <td>FOUND</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.4.3</td> 
    </tr>
    <tr>
     <td>303</td> 
     <td>SEE_OTHER</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.4.4</td> 
    </tr>
    <tr>
     <td>304</td> 
     <td>NOT_MODIFIED</td> 
     <td>HTTP/1.1 RFC 7232, Section 4.1</td> 
    </tr>
    <tr>
     <td>305</td> 
     <td>USE_PROXY</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.4.5</td> 
    </tr>
    <tr>
     <td>307</td> 
     <td>TEMPORARY_REDIRECT</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.4.7</td> 
    </tr>
    <tr>
     <td>308</td> 
     <td>PERMANENT_REDIRECT</td> 
     <td>Permanent Redirect RFC 7238, Section 3 (Experimental)</td> 
    </tr>
    <tr>
     <td>400</td> 
     <td>BAD_REQUEST</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.1</td> 
    </tr>
    <tr>
     <td>401</td> 
     <td>UNAUTHORIZED</td> 
     <td>HTTP/1.1 Authentication RFC 7235, Section 3.1</td> 
    </tr>
    <tr>
     <td>402</td> 
     <td>PAYMENT_REQUIRED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.2</td> 
    </tr>
    <tr>
     <td>403</td> 
     <td>FORBIDDEN</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.3</td> 
    </tr>
    <tr>
     <td>404</td> 
     <td>NOT_FOUND</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.4</td> 
    </tr>
    <tr>
     <td>405</td> 
     <td>METHOD_NOT_ALLOWED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.5</td> 
    </tr>
    <tr>
     <td>406</td> 
     <td>NOT_ACCEPTABLE</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.6</td> 
    </tr>
    <tr>
     <td>407</td> 
     <td>PROXY_AUTHENTICATION_REQUIRED</td> 
     <td>HTTP/1.1 Authentication RFC 7235, Section 3.2</td> 
    </tr>
    <tr>
     <td>408</td> 
     <td>REQUEST_TIMEOUT</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.7</td> 
    </tr>
    <tr>
     <td>409</td> 
     <td>CONFLICT</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.8</td> 
    </tr>
    <tr>
     <td>410</td> 
     <td>GONE</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.9</td> 
    </tr>
    <tr>
     <td>411</td> 
     <td>LENGTH_REQUIRED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.10</td> 
    </tr>
    <tr>
     <td>412</td> 
     <td>PRECONDITION_FAILED</td> 
     <td>HTTP/1.1 RFC 7232, Section 4.2</td> 
    </tr>
    <tr>
     <td>413</td> 
     <td>REQUEST_ENTITY_TOO_LARGE</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.11</td> 
    </tr>
    <tr>
     <td>414</td> 
     <td>REQUEST_URI_TOO_LONG</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.12</td> 
    </tr>
    <tr>
     <td>415</td> 
     <td>UNSUPPORTED_MEDIA_TYPE</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.13</td> 
    </tr>
    <tr>
     <td>416</td> 
     <td>REQUEST_RANGE_NOT_SATISFIABLE</td> 
     <td>HTTP/1.1 Range Requests RFC 7233, Section 4.4</td> 
    </tr>
    <tr>
     <td>417</td> 
     <td>EXPECTATION_FAILED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.14</td> 
    </tr>
    <tr>
     <td>422</td> 
     <td>UNPROCESSABLE_ENTITY</td> 
     <td>WebDAV RFC 4918, Section 11.2</td> 
    </tr>
    <tr>
     <td>423</td> 
     <td>LOCKED</td> 
     <td>WebDAV RFC 4918, Section 11.3</td> 
    </tr>
    <tr>
     <td>424</td> 
     <td>FAILED_DEPENDENCY</td> 
     <td>WebDAV RFC 4918, Section 11.4</td> 
    </tr>
    <tr>
     <td>426</td> 
     <td>UPGRADE_REQUIRED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.5.15</td> 
    </tr>
    <tr>
     <td>428</td> 
     <td>PRECONDITION_REQUIRED</td> 
     <td>Additional HTTP Status Codes RFC 6585</td> 
    </tr>
    <tr>
     <td>429</td> 
     <td>TOO_MANY_REQUESTS</td> 
     <td>Additional HTTP Status Codes RFC 6585</td> 
    </tr>
    <tr>
     <td>431</td> 
     <td>REQUEST_HEADER_FIELDS_TOO_LARGE Additional</td> 
     <td>HTTP Status Codes RFC 6585</td> 
    </tr>
    <tr>
     <td>500</td> 
     <td>INTERNAL_SERVER_ERROR</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.6.1</td> 
    </tr>
    <tr>
     <td>501</td> 
     <td>NOT_IMPLEMENTED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.6.2</td> 
    </tr>
    <tr>
     <td>502</td> 
     <td>BAD_GATEWAY</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.6.3</td> 
    </tr>
    <tr>
     <td>503</td> 
     <td>SERVICE_UNAVAILABLE</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.6.4</td> 
    </tr>
    <tr>
     <td>504</td> 
     <td>GATEWAY_TIMEOUT</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.6.5</td> 
    </tr>
    <tr>
     <td>505</td> 
     <td>HTTP_VERSION_NOT_SUPPORTED</td> 
     <td>HTTP/1.1 RFC 7231, Section 6.6.6</td> 
    </tr>
    <tr>
     <td>506</td> 
     <td>VARIANT_ALSO_NEGOTIATES</td> 
     <td>Transparent Content Negotiation in HTTP RFC 2295, Section 8.1 (Experimental)</td> 
    </tr>
    <tr>
     <td>507</td> 
     <td>INSUFFICIENT_STORAGE</td> 
     <td>WebDAV RFC 4918, Section 11.5</td> 
    </tr>
    <tr>
     <td>508</td> 
     <td>LOOP_DETECTED</td> 
     <td>WebDAV Binding Extensions RFC 5842, Section 7.2 (Experimental)</td> 
    </tr>
    <tr>
     <td>510</td> 
     <td>NOT_EXTENDED</td> 
     <td>An HTTP Extension Framework RFC 2774, Section 7 (Experimental)</td> 
    </tr>
    <tr>
     <td>511</td> 
     <td>NETWORK_AUTHENTICATION_REQUIRED</td> 
     <td>Additional HTTP Status Codes RFC 6585, Section 6</td> 
    </tr>
   </tbody>
  </table>
  <pre class="has">
<code>class Err404Handler(RequestHandler):
    """对应/err/404"""
    def get(self):
        self.write("hello itcast")
        self.set_status(404) # 标准状态码，不用设置reason

class Err210Handler(RequestHandler):
    """对应/err/210"""
    def get(self):
        self.write("hello itcast")
        self.set_status(210, "itcast error") # 非标准状态码，设置了reason

class Err211Handler(RequestHandler):
    """对应/err/211"""
    def get(self):
        self.write("hello itcast")
        self.set_status(211) # 非标准状态码，未设置reason，错误
</code></pre> 
  <p><img alt="" class="has" height="93" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100852854.png" width="485"></p> 
  <p><img alt="" class="has" height="93" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100923614.png" width="440"></p> 
  <p><img alt="" class="has" height="392" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100942527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="742"></p> 
  <h2 id="5-redirecturl">5. redirect(url)</h2> 
  <p>告知浏览器跳转到url。</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    """对应/"""
    def get(self):
        self.write("主页")

class LoginHandler(RequestHandler):
    """对应/login"""
    def get(self):
        self.write('&lt;form method="post"&gt;&lt;input type="submit" value="登陆"&gt;&lt;/form&gt;')

    def post(self):
        self.redirect("/")
</code></pre> 
  <h2 id="6-senderrorstatuscode500-kwargs">6. send_error(status_code=500, **kwargs)</h2> 
  <p>抛出HTTP错误状态码status_code，默认为500，kwargs为可变命名参数。使用send_error抛出错误后tornado会调用write_error()方法进行处理，并返回给浏览器处理后的错误页面。</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        self.write("主页")
        self.send_error(404, content="出现404错误")
</code></pre> 
  <p><strong>注意：默认的<code>write\_error()</code>方法不会处理<code>send\_error</code>抛出的kwargs参数，即上面的代码中<code>content="出现404错误"</code>是没有意义的。</strong></p> 
  <p>尝试下面的代码会出现什么问题？</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        self.write("主页")
        self.send_error(404, content="出现404错误")
        self.write("结束") # 我们在send_error再次向输出缓冲区写内容
</code></pre> 
  <p><img alt="" class="has" height="363" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512101011874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="813"></p> 
  <p><strong>注意：使用send_error()方法后就不要再向输出缓冲区写内容了！</strong></p> 
  <h2 id="7-writeerrorstatuscode-kwargs">7. write_error(status_code, **kwargs)</h2> 
  <p>用来处理send_error抛出的错误信息并返回给浏览器错误信息页面。可以重写此方法来定制自己的错误显示页面。</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        err_code = self.get_argument("code", None) # 注意返回的是unicode字符串，下同
        err_title = self.get_argument("title", "")
        err_content = self.get_argument("content", "")
        if err_code:
            self.send_error(err_code, title=err_title, content=err_content)
        else:
            self.write("主页")

    def write_error(self, status_code, **kwargs):
        self.write(u"&lt;h1&gt;出错了，程序员GG正在赶过来！&lt;/h1&gt;")
        self.write(u"&lt;p&gt;错误名：%s&lt;/p&gt;" % kwargs["title"])
        self.write(u"&lt;p&gt;错误详情：%s&lt;/p&gt;" % kwargs["content"])
</code></pre> 
  <p><img alt="" class="has" height="413" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512101032311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="901"></p> 
  <h1 id="34-接口与调用顺序">3.4 接口与调用顺序</h1> 
  <p>下面的接口方法是由tornado框架进行调用的，我们可以选择性的重写这些方法。</p> 
  <h2 id="1-initialize">1. initialize()</h2> 
  <p>对应每个请求的处理类Handler在构造一个实例后首先执行initialize()方法。在讲输入时提到，<strong>路由映射中的第三个字典型参数会作为该方法的命名参数传递，</strong>如：</p> 
  <pre class="has">
<code>class ProfileHandler(RequestHandler):
    def initialize(self, database):
        self.database = database

    def get(self):
        ...

app = Application([
    (r'/user/(.*)', ProfileHandler, dict(database=database)),
    ])
</code></pre> 
  <p><strong>此方法通常用来初始化参数（对象属性），很少使用。</strong></p> 
  <h2 id="2-prepare">2. prepare()</h2> 
  <p>预处理，即在执行对应请求方式的HTTP方法（如get、post等）前先执行，<strong>注意：不论以何种HTTP方式请求，都会执行prepare()方法</strong>。</p> 
  <p>以预处理请求体中的json数据为例：</p> 
  <pre class="has">
<code>import json

class IndexHandler(RequestHandler):
    def prepare(self):
        if self.request.headers.get("Content-Type").startswith("application/json"):
            self.json_dict = json.loads(self.request.body)
        else:
            self.json_dict = None

    def post(self):
        if self.json_dict:
            for key, value in self.json_dict.items():
                self.write("&lt;h3&gt;%s&lt;/h3&gt;&lt;p&gt;%s&lt;/p&gt;" % (key, value))

    def put(self):
        if self.json_dict:
            for key, value in self.json_dict.items():
                self.write("&lt;h3&gt;%s&lt;/h3&gt;&lt;p&gt;%s&lt;/p&gt;" % (key, value))
</code></pre> 
  <p>用post方式发送json数据时：</p> 
  <p><img alt="" class="has" height="571" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512101127780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="921"></p> 
  <p>用put方式发送json数据时：</p> 
  <p><img alt="" class="has" height="572" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512101157289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="929"></p> 
  <h2 id="3-http方法">3. HTTP方法</h2> 
  <table>
   <thead>
    <tr>
     <th>方法</th> 
     <th>描述</th> 
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>get</td> 
     <td>请求指定的页面信息，并返回实体主体。</td> 
    </tr>
    <tr>
     <td>head</td> 
     <td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td> 
    </tr>
    <tr>
     <td>post</td> 
     <td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td> 
    </tr>
    <tr>
     <td>delete</td> 
     <td>请求服务器删除指定的内容。</td> 
    </tr>
    <tr>
     <td>patch</td> 
     <td>请求修改局部数据。</td> 
    </tr>
    <tr>
     <td>put</td> 
     <td>从客户端向服务器传送的数据取代指定的文档的内容。</td> 
    </tr>
    <tr>
     <td>options</td> 
     <td>返回给定URL支持的所有HTTP方法。</td> 
    </tr>
   </tbody>
  </table>
  <h2 id="4-onfinish">4. on_finish()</h2> 
  <p>在请求处理结束后调用，即在调用HTTP方法后调用。通常该方法用来进行资源清理释放或处理日志等。<strong>注意：请尽量不要在此方法中进行响应输出。</strong></p> 
  <h2 id="5-setdefaultheaders">5. set_default_headers()</h2> 
  <h2 id="6-writeerror">6. write_error()</h2> 
  <h2 id="7-调用顺序">7. 调用顺序</h2> 
  <p>我们通过一段程序来看上面这些接口的调用顺序。</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):

    def initialize(self):
        print "调用了initialize()"

    def prepare(self):
        print "调用了prepare()"

    def set_default_headers(self):
        print "调用了set_default_headers()"

    def write_error(self, status_code, **kwargs):
        print "调用了write_error()"

    def get(self):
        print "调用了get()"

    def post(self):
        print "调用了post()"
        self.send_error(200)  # 注意此出抛出了错误

    def on_finish(self):
        print "调用了on_finish()"
</code></pre> 
  <p><img alt="" class="has" height="293" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512101242198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzI2OTQwMTc1,size_16,color_FFFFFF,t_70" width="709"></p> 
  <p><strong>在正常情况未抛出错误时，调用顺序为：</strong></p> 
  <ol>
   <li>set_defautl_headers()</li> 
   <li>initialize()</li> 
   <li>prepare()</li> 
   <li>HTTP方法</li> 
   <li>on_finish()</li> 
  </ol>
  <p><strong>在有错误抛出时，调用顺序为：</strong></p> 
  <ol>
   <li>set_default_headers()</li> 
   <li>initialize()</li> 
   <li>prepare()</li> 
   <li>HTTP方法</li> 
   <li><strong>set_default_headers()</strong></li> 
   <li>write_error()</li> 
   <li>on_finish()</li> 
  </ol>
  <h1 id="35-练习">3.5 练习</h1> 
  <ol>
   <li> <p>将Application的设置参数（目前只学习了debug）抽离为一个字典类型变量settings，并在构造Application对象时使用settings。</p> </li> 
   <li> <p>熟练使用RequestHandler的各种输入输出方法。</p> </li> 
   <li> <p>尝试抽象出BaseHandler基类，继承自RequestHandler，并在此基类中实现prepare（解析json数据）、write_error两个接口。</p> </li> 
  </ol>
  <h1 id="4-模板">4 模板</h1> 
  <h2 id="知识点">知识点</h2> 
  <ul>
   <li>静态文件配置 
    <ul>
     <li>static_path</li> 
     <li>StaticFileHandler</li> 
    </ul></li> 
   <li>模板使用 
    <ul>
     <li>变量与表达式</li> 
     <li>控制语句</li> 
     <li>函数</li> 
     <li>块</li> 
    </ul></li> 
  </ul>
  <h1 id="41-静态文件">4.1 静态文件</h1> 
  <p>现在有一个预先写好的静态页面文件 （<a href="statics/template_statics.tar.gz" rel="nofollow">下载静态文件资源</a>）， 我们来看下如何用tornado提供静态文件。</p> 
  <h2 id="staticpath">static_path</h2> 
  <p>我们可以通过向web.Application类的构造函数传递一个名为<strong>static_path</strong>的参数来告诉Tornado从文件系统的一个特定位置提供静态文件，如：</p> 
  <pre class="has">
<code>app = tornado.web.Application(
    [(r'/', IndexHandler)],
    static_path=os.path.join(os.path.dirname(__file__), "statics"),
)
</code></pre> 
  <p>在这里，我们设置了一个当前应用目录下名为statics的子目录作为static_path的参数。现在应用将以读取statics目录下的filename.ext来响应诸如/static/filename.ext的请求，并在响应的主体中返回。</p> 
  <p>对于静态文件目录的命名，为了便于部署，建议使用static</p> 
  <p>对于我们提供的静态文件资源，可以通过<code>http://127.0.0.1/static/html/index.html</code>来访问。而且在index.html中引用的静态资源文件，我们给定的路径也符合/static/...的格式，故页面可以正常浏览。</p> 
  <pre class="has">
<code>&lt;link href="/static/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt;
&lt;link href="/static/plugins/font-awesome/css/font-awesome.min.css" rel="stylesheet"&gt;
&lt;link href="/static/css/reset.css" rel="stylesheet"&gt;
&lt;link href="/static/css/main.css" rel="stylesheet"&gt;
&lt;link href="/static/css/index.css" rel="stylesheet"&gt;

&lt;script src="/static/js/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="/static/plugins/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;script src="/static/js/index.js"&gt;&lt;/script&gt;
</code></pre> 
  <h2 id="staticfilehandler">StaticFileHandler</h2> 
  <p>我们再看刚刚访问页面时使用的路径<code>http://127.0.0.1/static/html/index.html</code>，这中url显然对用户是不友好的，访问很不方便。我们可以通过<strong>tornado.web.StaticFileHandler</strong>来自由映射静态文件与其访问路径url。</p> 
  <p>tornado.web.StaticFileHandler是tornado预置的用来提供静态资源文件的handler。</p> 
  <pre class="has">
<code>import os

current_path = os.path.dirname(__file__)
app = tornado.web.Application(
    [
        (r'^/()$', StaticFileHandler, {"path":os.path.join(current_path, "statics/html"), "default_filename":"index.html"}),
        (r'^/view/(.*)$', StaticFileHandler, {"path":os.path.join(current_path, "statics/html")}),
    ],
    static_path=os.path.join(current_path, "statics"),
)
</code></pre> 
  <ul>
   <li><strong>path</strong>&nbsp;用来指明提供静态文件的根路径，并在此目录中寻找在路由中用正则表达式提取的文件名。</li> 
   <li><strong>default_filename</strong>&nbsp;用来指定访问路由中未指明文件名时，默认提供的文件。</li> 
  </ul>
  <p>现在，对于静态文件statics/html/index.html，可以通过三种方式进行访问：</p> 
  <ol>
   <li><a href="http://127.0.0.1/static/html/index.html" rel="nofollow">http://127.0.0.1/static/html/index.html</a></li> 
   <li><a href="http://127.0.0.1/" rel="nofollow">http://127.0.0.1/</a></li> 
   <li><a href="http://127.0.0.1/view/index.html" rel="nofollow">http://127.0.0.1/view/index.html</a></li> 
  </ol>
  <h1 id="42-使用模板">4.2 使用模板</h1> 
  <h2 id="1-路径与渲染">1. 路径与渲染</h2> 
  <p>使用模板，需要仿照静态文件路径设置一样，向web.Application类的构造函数传递一个名为<strong>template_path</strong>的参数来告诉Tornado从文件系统的一个特定位置提供模板文件，如：</p> 
  <pre class="has">
<code>app = tornado.web.Application(
    [(r'/', IndexHandler)],
    static_path=os.path.join(os.path.dirname(__file__), "statics"),
    template_path=os.path.join(os.path.dirname(__file__), "templates"),
)
</code></pre> 
  <p>在这里，我们设置了一个当前应用目录下名为templates的子目录作为template_path的参数。在handler中使用的模板将在此目录中寻找。</p> 
  <p>现在我们将静态文件目录statics/html中的index.html复制一份到templates目录中，此时文件目录结构为：</p> 
  <pre class="has">
<code>.
├── statics
│   ├── css
│   │   ├── index.css
│   │   ├── main.css
│   │   └── reset.css
│   ├── html
│   │   └── index.html
│   ├── images
│   │   ├── home01.jpg
│   │   ├── home02.jpg
│   │   ├── home03.jpg
│   │   └── landlord01.jpg
│   ├── js
│   │   ├── index.js
│   │   └── jquery.min.js
│   └── plugins
│       ├── bootstrap
│       │   └─...
│       └── font-awesome
│           └─...
├── templates
│   └── index.html
└── test.py
</code></pre> 
  <p><strong>在handler中使用render()方法来渲染模板并返回给客户端</strong>。</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        self.render("index.html") # 渲染主页模板，并返回给客户端。



current_path = os.path.dirname(__file__)
app = tornado.web.Application(
    [
        (r'^/$', IndexHandler),
        (r'^/view/(.*)$', StaticFileHandler, {"path":os.path.join(current_path, "statics/html")}),
    ],
    static_path=os.path.join(current_path, "statics"),
    template_path=os.path.join(os.path.dirname(__file__), "templates"),
)
</code></pre> 
  <h2 id="2-模板语法">2. 模板语法</h2> 
  <h3 id="21-变量与表达式">2-1 变量与表达式</h3> 
  <p>在tornado的模板中使用{{}}作为变量或表达式的占位符，使用render渲染后占位符{{}}会被替换为相应的结果值。</p> 
  <p>我们将index.html中的一条房源信息记录</p> 
  <pre class="has">
<code>&lt;li class="house-item"&gt;
    &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
    &lt;div class="house-desc"&gt;
        &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
        &lt;div class="house-price"&gt;￥&lt;span&gt;398&lt;/span&gt;/晚&lt;/div&gt;
        &lt;div class="house-intro"&gt;
            &lt;span class="house-title"&gt;宽窄巷子+160平大空间+文化保护区双地铁&lt;/span&gt;
            &lt;em&gt;整套出租 - 5分/6点评 - 北京市丰台区六里桥地铁&lt;/em&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre> 
  <p>改为模板：</p> 
  <pre class="has">
<code>&lt;li class="house-item"&gt;
    &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
    &lt;div class="house-desc"&gt;
        &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
        &lt;div class="house-price"&gt;￥&lt;span&gt;{{price}}&lt;/span&gt;/晚&lt;/div&gt;
        &lt;div class="house-intro"&gt;
            &lt;span class="house-title"&gt;{{title}}&lt;/span&gt;
            &lt;em&gt;整套出租 - {{score}}分/{{comments}}点评 - {{position}}&lt;/em&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre> 
  <p>渲染方式如下：</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        house_info = {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }
        self.render("index.html", **house_info)
</code></pre> 
  <p>{{}}不仅可以包含变量，还可以是表达式，如：</p> 
  <pre class="has">
<code>&lt;li class="house-item"&gt;
    &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
    &lt;div class="house-desc"&gt;
        &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
        &lt;div class="house-price"&gt;￥&lt;span&gt;{{p1 + p2}}&lt;/span&gt;/晚&lt;/div&gt;
        &lt;div class="house-intro"&gt;
            &lt;span class="house-title"&gt;{{"+".join(titles)}}&lt;/span&gt;
            &lt;em&gt;整套出租 - {{score}}分/{{comments}}点评 - {{position}}&lt;/em&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        house_info = {
            "p1": 198,
            "p2": 200,
            "titles": ["宽窄巷子", "160平大空间", "文化保护区双地铁"],
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }
        self.render("index.html", **house_info)
</code></pre> 
  <h3 id="22-控制语句">2-2 控制语句</h3> 
  <p>可以在Tornado模板中使用Python条件和循环语句。控制语句以{\%和\%}包围，并以类似下面的形式被使用：</p> 
  <pre class="has">
<code>{% if page is None %}
</code></pre> 
  <p>或</p> 
  <pre class="has">
<code>{% if len(entries) == 3 %}
</code></pre> 
  <p>控制语句的大部分就像对应的Python语句一样工作，支持if、for、while，<strong>注意end</strong>:</p> 
  <pre class="has">
<code>{% if ... %} ... {% elif ... %} ... {% else ... %} ... {% end %}
{% for ... in ... %} ... {% end %}
{% while ... %} ... {% end %}
</code></pre> 
  <p>再次修改index.html:</p> 
  <pre class="has">
<code>&lt;ul class="house-list"&gt;
    {% if len(houses) &gt; 0 %}
        {% for house in houses %}
        &lt;li class="house-item"&gt;
            &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
            &lt;div class="house-desc"&gt;
                &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
                &lt;div class="house-price"&gt;￥&lt;span&gt;{{house["price"]}}&lt;/span&gt;/晚&lt;/div&gt;
                &lt;div class="house-intro"&gt;
                    &lt;span class="house-title"&gt;{{house["title"]}}&lt;/span&gt;
                    &lt;em&gt;整套出租 - {{house["score"]}}分/{{house["comments"]}}点评 - {{house["position"]}}&lt;/em&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        {% end %}
    {% else %}
        对不起，暂时没有房源。
    {% end %}
&lt;/ul&gt;
</code></pre> 
  <p>python中渲染语句为：</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        houses = [
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }]
        self.render("index.html", houses=houses)
</code></pre> 
  <h3 id="23-函数">2-3 函数</h3> 
  <p>static_url()</p> 
  <p>Tornado模板模块提供了一个叫作static_url的函数来生成静态文件目录下文件的URL。如下面的示例代码：</p> 
  <pre class="has">
<code>&lt;link rel="stylesheet" href="{{ static_url("style.css") }}"&gt;
</code></pre> 
  <p>这个对static_url的调用生成了URL的值，并渲染输出类似下面的代码：</p> 
  <pre class="has">
<code>&lt;link rel="stylesheet" href="/static/style.css?v=ab12"&gt;
</code></pre> 
  <p><strong>优点：</strong></p> 
  <ul>
   <li>static_url函数创建了一个基于文件内容的hash值，并将其添加到URL末尾（查询字符串的参数v）。这个hash值确保浏览器总是加载一个文件的最新版而不是之前的缓存版本。无论是在你应用的开发阶段，还是在部署到生产环境使用时，都非常有用，因为你的用户不必再为了看到你的静态内容而清除浏览器缓存了。</li> 
   <li>另一个好处是你可以改变你应用URL的结构，而不需要改变模板中的代码。例如，可以通过设置<strong>static_url_prefix</strong>来更改Tornado的默认静态路径前缀/static。如果使用static_url而不是硬编码的话，代码不需要改变。</li> 
  </ul>
  <p>转义</p> 
  <p>我们新建一个表单页面new.html</p> 
  <pre class="has">
<code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;新建房源&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form method="post"&gt;
            &lt;textarea name="text"&gt;&lt;/textarea&gt;
            &lt;input type="submit" value="提交"&gt;
        &lt;/form&gt;
        {{text}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
  <p>对应的handler为：</p> 
  <pre class="has">
<code>class NewHandler(RequestHandler):

    def get(self):
        self.render("new.html", text="")

    def post(self):
        text = self.get_argument("text", "") 
        print text
        self.render("new.html", text=text)
</code></pre> 
  <p>当我们在表单中填入如下内容时：</p> 
  <pre class="has">
<code>&lt;script&gt;alert("hello!");&lt;/script&gt;
</code></pre> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="153" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051408583071.png" width="356"></p> 
  <p>写入的js程序并没有运行，而是显示出来了：</p> 
  <p><img alt="" class="has" height="131" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190514085746389.png" width="310"></p> 
  <p>我们查看页面源代码，发现&lt;、&gt;、"等被转换为对应的html字符。</p> 
  <pre class="has">
<code>&amp;lt;script&amp;gt;alert(&amp;quot;hello!&amp;quot;);&amp;lt;/script&amp;gt;
</code></pre> 
  <p>这是因为tornado中默认开启了模板自动转义功能，防止网站受到恶意攻击。</p> 
  <p>我们可以通过raw语句来输出不被转义的原始格式，如：</p> 
  <pre class="has">
<code>{% raw text %}
</code></pre> 
  <blockquote> 
   <p>注意：在Firefox浏览器中会直接弹出alert窗口，而在Chrome浏览器中，需要set_header("X-XSS-Protection", 0)</p> 
  </blockquote> 
  <p>若要关闭自动转义，一种方法是在Application构造函数中传递<strong>autoescape=None</strong>，另一种方法是在每页模板中修改自动转义行为，添加如下语句：</p> 
  <pre class="has">
<code>{% autoescape None %}
</code></pre> 
  <p><strong>escape()</strong></p> 
  <p>关闭自动转义后，可以使用escape()函数来对特定变量进行转义，如：</p> 
  <pre class="has">
<code>{{ escape(text) }}
</code></pre> 
  <p>自定义函数</p> 
  <p>在模板中还可以使用一个自己编写的函数，只需要将函数名作为模板的参数传递即可，就像其他变量一样。</p> 
  <p>我们修改后端如下：</p> 
  <pre class="has">
<code>def house_title_join(titles):
    return "+".join(titles)

class IndexHandler(RequestHandler):
    def get(self):
        house_list = [
        {
            "price": 398,
            "titles": ["宽窄巷子", "160平大空间", "文化保护区双地铁"],
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "titles": ["宽窄巷子", "160平大空间", "文化保护区双地铁"],
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }]
        self.render("index.html", houses=house_list, title_join = house_title_join)
</code></pre> 
  <p>前段模板我们修改为：</p> 
  <pre class="has">
<code>&lt;ul class="house-list"&gt;
    {% if len(houses) &gt; 0 %}
        {% for house in houses %}
        &lt;li class="house-item"&gt;
            &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
            &lt;div class="house-desc"&gt;
                &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
                &lt;div class="house-price"&gt;￥&lt;span&gt;{{house["price"]}}&lt;/span&gt;/晚&lt;/div&gt;
                &lt;div class="house-intro"&gt;
                    &lt;span class="house-title"&gt;{{title_join(house["titles"])}}&lt;/span&gt;
                    &lt;em&gt;整套出租 - {{house["score"]}}分/{{house["comments"]}}点评 - {{house["position"]}}&lt;/em&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        {% end %}
    {% else %}
        对不起，暂时没有房源。
    {% end %}
&lt;/ul&gt;
</code></pre> 
  <h3 id="24-块">2-4 块</h3> 
  <p>我们可以使用块来复用模板，块语法如下：</p> 
  <pre class="has">
<code>{% block block_name %} {% end %}
</code></pre> 
  <p>现在，我们对模板index.html进行抽象，抽离出父模板base.html如下：</p> 
  <pre class="has">
<code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; 
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt;
    {% block page_title %}{% end %}
    &lt;link href="{{static_url('plugins/bootstrap/css/bootstrap.min.css')}}" rel="stylesheet"&gt;
    &lt;link href="{{static_url('plugins/font-awesome/css/font-awesome.min.css')}}" rel="stylesheet"&gt;
    &lt;link href="{{static_url('css/reset.css')}}" rel="stylesheet"&gt;
    &lt;link href="{{static_url('css/main.css')}}" rel="stylesheet"&gt;
    {% block css_files %}{% end %}
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="top-bar"&gt;
            {% block header %}{% end %}
        &lt;/div&gt;
        {% block body %}{% end %}
        &lt;div class="footer"&gt;
            {% block footer %}{% end %}
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="{{static_url('js/jquery.min.js')}}"&gt;&lt;/script&gt;
    &lt;script src="{{static_url('plugins/bootstrap/js/bootstrap.min.js')}}"&gt;&lt;/script&gt;
    {% block js_files %}{% end %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
  <p>而子模板index.html使用extends来使用父模板base.html，如下：</p> 
  <pre class="has">
<code>{% extends "base.html" %}

{% block page_title %}
    &lt;title&gt;爱家-房源&lt;/title&gt;
{% end %}

{% block css_files %}
    &lt;link href="{{static_url('css/index.css')}}" rel="stylesheet"&gt;
{% end %} 

{% block js_files %}
    &lt;script src="{{static_url('js/index.js')}}"&gt;&lt;/script&gt;
{% end %}

{% block header %}
    &lt;div class="nav-bar"&gt;
        &lt;h3 class="page-title"&gt;房 源&lt;/h3&gt;
    &lt;/div&gt;
{% end %}

{% block body %}
    &lt;ul class="house-list"&gt;
    {% if len(houses) &gt; 0 %}
        {% for house in houses %}
        &lt;li class="house-item"&gt;
            &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
            &lt;div class="house-desc"&gt;
                &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
                &lt;div class="house-price"&gt;￥&lt;span&gt;{{house["price"]}}&lt;/span&gt;/晚&lt;/div&gt;
                &lt;div class="house-intro"&gt;
                    &lt;span class="house-title"&gt;{{title_join(house["titles"])}}&lt;/span&gt;
                    &lt;em&gt;整套出租 - {{house["score"]}}分/{{house["comments"]}}点评 - {{house["position"]}}&lt;/em&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        {% end %}
    {% else %}
        对不起，暂时没有房源。
    {% end %}
    &lt;/ul&gt;
{% end %}

{% block footer %}
    &lt;p&gt;&lt;span&gt;&lt;i class="fa fa-copyright"&gt;&lt;/i&gt;&lt;/span&gt;爱家租房&amp;nbsp;&amp;nbsp;享受家的温馨&lt;/p&gt;
{% end %}</code></pre> 
  <h1 id="43-练习">4.3 练习</h1> 
  <ol>
   <li> <p>对比Django模板与Tornado模板的异同。</p> </li> 
   <li> <p>练习使用Tornado模板的语法。</p> </li> 
  </ol>
  <h1>4.2 使用模板</h1> 
  <h2>1. 路径与渲染</h2> 
  <p>使用模板，需要仿照静态文件路径设置一样，向web.Application类的构造函数传递一个名为<strong>template_path</strong>的参数来告诉Tornado从文件系统的一个特定位置提供模板文件，如：</p> 
  <pre class="has">
<code>app = tornado.web.Application(
    [(r'/', IndexHandler)],
    static_path=os.path.join(os.path.dirname(__file__), "statics"),
    template_path=os.path.join(os.path.dirname(__file__), "templates"),
)
</code></pre> 
  <p>在这里，我们设置了一个当前应用目录下名为templates的子目录作为template_path的参数。在handler中使用的模板将在此目录中寻找。</p> 
  <p>现在我们将静态文件目录statics/html中的index.html复制一份到templates目录中，此时文件目录结构为：</p> 
  <pre class="has">
<code>.
├── statics
│   ├── css
│   │   ├── index.css
│   │   ├── main.css
│   │   └── reset.css
│   ├── html
│   │   └── index.html
│   ├── images
│   │   ├── home01.jpg
│   │   ├── home02.jpg
│   │   ├── home03.jpg
│   │   └── landlord01.jpg
│   ├── js
│   │   ├── index.js
│   │   └── jquery.min.js
│   └── plugins
│       ├── bootstrap
│       │   └─...
│       └── font-awesome
│           └─...
├── templates
│   └── index.html
└── test.py
</code></pre> 
  <p><strong>在handler中使用render()方法来渲染模板并返回给客户端</strong>。</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        self.render("index.html") # 渲染主页模板，并返回给客户端。



current_path = os.path.dirname(__file__)
app = tornado.web.Application(
    [
        (r'^/$', IndexHandler),
        (r'^/view/(.*)$', StaticFileHandler, {"path":os.path.join(current_path, "statics/html")}),
    ],
    static_path=os.path.join(current_path, "statics"),
    template_path=os.path.join(os.path.dirname(__file__), "templates"),
)
</code></pre> 
  <h2>2. 模板语法</h2> 
  <h3>2-1 变量与表达式</h3> 
  <p>在tornado的模板中使用{{}}作为变量或表达式的占位符，使用render渲染后占位符{{}}会被替换为相应的结果值。</p> 
  <p>我们将index.html中的一条房源信息记录</p> 
  <pre class="has">
<code>&lt;li class="house-item"&gt;
    &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
    &lt;div class="house-desc"&gt;
        &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
        &lt;div class="house-price"&gt;￥&lt;span&gt;398&lt;/span&gt;/晚&lt;/div&gt;
        &lt;div class="house-intro"&gt;
            &lt;span class="house-title"&gt;宽窄巷子+160平大空间+文化保护区双地铁&lt;/span&gt;
            &lt;em&gt;整套出租 - 5分/6点评 - 北京市丰台区六里桥地铁&lt;/em&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre> 
  <p>改为模板：</p> 
  <pre class="has">
<code>&lt;li class="house-item"&gt;
    &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
    &lt;div class="house-desc"&gt;
        &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
        &lt;div class="house-price"&gt;￥&lt;span&gt;{{price}}&lt;/span&gt;/晚&lt;/div&gt;
        &lt;div class="house-intro"&gt;
            &lt;span class="house-title"&gt;{{title}}&lt;/span&gt;
            &lt;em&gt;整套出租 - {{score}}分/{{comments}}点评 - {{position}}&lt;/em&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre> 
  <p>渲染方式如下：</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        house_info = {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }
        self.render("index.html", **house_info)
</code></pre> 
  <p>{{}}不仅可以包含变量，还可以是表达式，如：</p> 
  <pre class="has">
<code>&lt;li class="house-item"&gt;
    &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
    &lt;div class="house-desc"&gt;
        &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
        &lt;div class="house-price"&gt;￥&lt;span&gt;{{p1 + p2}}&lt;/span&gt;/晚&lt;/div&gt;
        &lt;div class="house-intro"&gt;
            &lt;span class="house-title"&gt;{{"+".join(titles)}}&lt;/span&gt;
            &lt;em&gt;整套出租 - {{score}}分/{{comments}}点评 - {{position}}&lt;/em&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/li&gt;
</code></pre> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        house_info = {
            "p1": 198,
            "p2": 200,
            "titles": ["宽窄巷子", "160平大空间", "文化保护区双地铁"],
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }
        self.render("index.html", **house_info)
</code></pre> 
  <h3>2-2 控制语句</h3> 
  <p>可以在Tornado模板中使用Python条件和循环语句。控制语句以{\%和\%}包围，并以类似下面的形式被使用：</p> 
  <pre class="has">
<code>{% if page is None %}
</code></pre> 
  <p>或</p> 
  <pre class="has">
<code>{% if len(entries) == 3 %}
</code></pre> 
  <p>控制语句的大部分就像对应的Python语句一样工作，支持if、for、while，<strong>注意end</strong>:</p> 
  <pre class="has">
<code>{% if ... %} ... {% elif ... %} ... {% else ... %} ... {% end %}
{% for ... in ... %} ... {% end %}
{% while ... %} ... {% end %}
</code></pre> 
  <p>再次修改index.html:</p> 
  <pre class="has">
<code>&lt;ul class="house-list"&gt;
    {% if len(houses) &gt; 0 %}
        {% for house in houses %}
        &lt;li class="house-item"&gt;
            &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
            &lt;div class="house-desc"&gt;
                &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
                &lt;div class="house-price"&gt;￥&lt;span&gt;{{house["price"]}}&lt;/span&gt;/晚&lt;/div&gt;
                &lt;div class="house-intro"&gt;
                    &lt;span class="house-title"&gt;{{house["title"]}}&lt;/span&gt;
                    &lt;em&gt;整套出租 - {{house["score"]}}分/{{house["comments"]}}点评 - {{house["position"]}}&lt;/em&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        {% end %}
    {% else %}
        对不起，暂时没有房源。
    {% end %}
&lt;/ul&gt;
</code></pre> 
  <p>python中渲染语句为：</p> 
  <pre class="has">
<code>class IndexHandler(RequestHandler):
    def get(self):
        houses = [
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "title": "宽窄巷子+160平大空间+文化保护区双地铁",
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }]
        self.render("index.html", houses=houses)
</code></pre> 
  <h3>2-3 函数</h3> 
  <p>static_url()</p> 
  <p>Tornado模板模块提供了一个叫作static_url的函数来生成静态文件目录下文件的URL。如下面的示例代码：</p> 
  <pre class="has">
<code>&lt;link rel="stylesheet" href="{{ static_url("style.css") }}"&gt;
</code></pre> 
  <p>这个对static_url的调用生成了URL的值，并渲染输出类似下面的代码：</p> 
  <pre class="has">
<code>&lt;link rel="stylesheet" href="/static/style.css?v=ab12"&gt;
</code></pre> 
  <p><strong>优点：</strong></p> 
  <ul>
   <li>static_url函数创建了一个基于文件内容的hash值，并将其添加到URL末尾（查询字符串的参数v）。这个hash值确保浏览器总是加载一个文件的最新版而不是之前的缓存版本。无论是在你应用的开发阶段，还是在部署到生产环境使用时，都非常有用，因为你的用户不必再为了看到你的静态内容而清除浏览器缓存了。</li> 
   <li>另一个好处是你可以改变你应用URL的结构，而不需要改变模板中的代码。例如，可以通过设置<strong>static_url_prefix</strong>来更改Tornado的默认静态路径前缀/static。如果使用static_url而不是硬编码的话，代码不需要改变。</li> 
  </ul>
  <p>转义</p> 
  <p>我们新建一个表单页面new.html</p> 
  <pre class="has">
<code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;新建房源&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form method="post"&gt;
            &lt;textarea name="text"&gt;&lt;/textarea&gt;
            &lt;input type="submit" value="提交"&gt;
        &lt;/form&gt;
        {{text}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
  <p>对应的handler为：</p> 
  <pre class="has">
<code>class NewHandler(RequestHandler):

    def get(self):
        self.render("new.html", text="")

    def post(self):
        text = self.get_argument("text", "") 
        print text
        self.render("new.html", text=text)
</code></pre> 
  <p>当我们在表单中填入如下内容时：</p> 
  <pre class="has">
<code>&lt;script&gt;alert("hello!");&lt;/script&gt;
</code></pre> 
  <p><img alt="" class="has" height="153" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190514085950448.png" width="356"></p> 
  <p>写入的js程序并没有运行，而是显示出来了：</p> 
  <p><img alt="" class="has" height="131" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190514090000401.png" width="310"></p> 
  <p>我们查看页面源代码，发现&lt;、&gt;、"等被转换为对应的html字符。</p> 
  <pre class="has">
<code>&amp;lt;script&amp;gt;alert(&amp;quot;hello!&amp;quot;);&amp;lt;/script&amp;gt;
</code></pre> 
  <p>这是因为tornado中默认开启了模板自动转义功能，防止网站受到恶意攻击。</p> 
  <p>我们可以通过raw语句来输出不被转义的原始格式，如：</p> 
  <pre class="has">
<code>{% raw text %}
</code></pre> 
  <blockquote> 
   <p>注意：在Firefox浏览器中会直接弹出alert窗口，而在Chrome浏览器中，需要set_header("X-XSS-Protection", 0)</p> 
  </blockquote> 
  <p>若要关闭自动转义，一种方法是在Application构造函数中传递<strong>autoescape=None</strong>，另一种方法是在每页模板中修改自动转义行为，添加如下语句：</p> 
  <pre class="has">
<code>{% autoescape None %}
</code></pre> 
  <p><strong>escape()</strong></p> 
  <p>关闭自动转义后，可以使用escape()函数来对特定变量进行转义，如：</p> 
  <pre class="has">
<code>{{ escape(text) }}
</code></pre> 
  <p>自定义函数</p> 
  <p>在模板中还可以使用一个自己编写的函数，只需要将函数名作为模板的参数传递即可，就像其他变量一样。</p> 
  <p>我们修改后端如下：</p> 
  <pre class="has">
<code>def house_title_join(titles):
    return "+".join(titles)

class IndexHandler(RequestHandler):
    def get(self):
        house_list = [
        {
            "price": 398,
            "titles": ["宽窄巷子", "160平大空间", "文化保护区双地铁"],
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        },
        {
            "price": 398,
            "titles": ["宽窄巷子", "160平大空间", "文化保护区双地铁"],
            "score": 5,
            "comments": 6,
            "position": "北京市丰台区六里桥地铁"
        }]
        self.render("index.html", houses=house_list, title_join = house_title_join)
</code></pre> 
  <p>前段模板我们修改为：</p> 
  <pre class="has">
<code>&lt;ul class="house-list"&gt;
    {% if len(houses) &gt; 0 %}
        {% for house in houses %}
        &lt;li class="house-item"&gt;
            &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
            &lt;div class="house-desc"&gt;
                &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
                &lt;div class="house-price"&gt;￥&lt;span&gt;{{house["price"]}}&lt;/span&gt;/晚&lt;/div&gt;
                &lt;div class="house-intro"&gt;
                    &lt;span class="house-title"&gt;{{title_join(house["titles"])}}&lt;/span&gt;
                    &lt;em&gt;整套出租 - {{house["score"]}}分/{{house["comments"]}}点评 - {{house["position"]}}&lt;/em&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        {% end %}
    {% else %}
        对不起，暂时没有房源。
    {% end %}
&lt;/ul&gt;
</code></pre> 
  <h3>2-4 块</h3> 
  <p>我们可以使用块来复用模板，块语法如下：</p> 
  <pre class="has">
<code>{% block block_name %} {% end %}
</code></pre> 
  <p>现在，我们对模板index.html进行抽象，抽离出父模板base.html如下：</p> 
  <pre class="has">
<code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; 
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt;
    {% block page_title %}{% end %}
    &lt;link href="{{static_url('plugins/bootstrap/css/bootstrap.min.css')}}" rel="stylesheet"&gt;
    &lt;link href="{{static_url('plugins/font-awesome/css/font-awesome.min.css')}}" rel="stylesheet"&gt;
    &lt;link href="{{static_url('css/reset.css')}}" rel="stylesheet"&gt;
    &lt;link href="{{static_url('css/main.css')}}" rel="stylesheet"&gt;
    {% block css_files %}{% end %}
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="top-bar"&gt;
            {% block header %}{% end %}
        &lt;/div&gt;
        {% block body %}{% end %}
        &lt;div class="footer"&gt;
            {% block footer %}{% end %}
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="{{static_url('js/jquery.min.js')}}"&gt;&lt;/script&gt;
    &lt;script src="{{static_url('plugins/bootstrap/js/bootstrap.min.js')}}"&gt;&lt;/script&gt;
    {% block js_files %}{% end %}
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
  <p>而子模板index.html使用extends来使用父模板base.html，如下：</p> 
  <pre class="has">
<code>{% extends "base.html" %}

{% block page_title %}
    &lt;title&gt;爱家-房源&lt;/title&gt;
{% end %}

{% block css_files %}
    &lt;link href="{{static_url('css/index.css')}}" rel="stylesheet"&gt;
{% end %} 

{% block js_files %}
    &lt;script src="{{static_url('js/index.js')}}"&gt;&lt;/script&gt;
{% end %}

{% block header %}
    &lt;div class="nav-bar"&gt;
        &lt;h3 class="page-title"&gt;房 源&lt;/h3&gt;
    &lt;/div&gt;
{% end %}

{% block body %}
    &lt;ul class="house-list"&gt;
    {% if len(houses) &gt; 0 %}
        {% for house in houses %}
        &lt;li class="house-item"&gt;
            &lt;a href=""&gt;&lt;img src="/static/images/home01.jpg"&gt;&lt;/a&gt;
            &lt;div class="house-desc"&gt;
                &lt;div class="landlord-pic"&gt;&lt;img src="/static/images/landlord01.jpg"&gt;&lt;/div&gt;
                &lt;div class="house-price"&gt;￥&lt;span&gt;{{house["price"]}}&lt;/span&gt;/晚&lt;/div&gt;
                &lt;div class="house-intro"&gt;
                    &lt;span class="house-title"&gt;{{title_join(house["titles"])}}&lt;/span&gt;
                    &lt;em&gt;整套出租 - {{house["score"]}}分/{{house["comments"]}}点评 - {{house["position"]}}&lt;/em&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/li&gt;
        {% end %}
    {% else %}
        对不起，暂时没有房源。
    {% end %}
    &lt;/ul&gt;
{% end %}

{% block footer %}
    &lt;p&gt;&lt;span&gt;&lt;i class="fa fa-copyright"&gt;&lt;/i&gt;&lt;/span&gt;爱家租房&amp;nbsp;&amp;nbsp;享受家的温馨&lt;/p&gt;
{% end %}</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
