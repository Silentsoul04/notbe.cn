<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Iris鸢尾花数据集可视化、线性回归、决策树分析、KMeans聚类分析 « NotBeCN</title>
  <meta name="description" content="         在进行可视化及聚类分析前，我们需要为IDE安装sklearn库，scikit-learn是Python的一个开源机器学习模块，它建立在NumPy，SciPy和matplotlib模块之上能够为用户提供各种机器学习算法接口，可以让用户简单、高效地进行数据挖掘和数据分析。   以下皆是在cmd命令行...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/H_lukong_90139700.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Iris鸢尾花数据集可视化、线性回归、决策树分析、KMeans聚类分析</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>在进行可视化及聚类分析前，我们需要为IDE安装sklearn库，scikit-learn是Python的一个开源机器学习模块，它建立在NumPy，SciPy和matplotlib模块之上能够为用户提供各种机器学习算法接口，可以让用户简单、高效地进行数据挖掘和数据分析。</p> 
  <p><span style="color:#f33b45;"><strong>以下皆是在cmd命令行进行。</strong></span></p> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">一、全部代码</a></p> 
  <p id="%E5%88%86%E6%AD%A5%E9%AA%A4%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%88%86%E6%AD%A5%E9%AA%A4%E6%93%8D%E4%BD%9C" rel="nofollow">二、分步骤浏览</a></p> 
  <p id="python%E4%B8%AD%E5%AE%89%E8%A3%85sklearn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93-toc" style="margin-left:40px;"><a href="#python%E4%B8%AD%E5%AE%89%E8%A3%85sklearn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93" rel="nofollow">python中安装sklearn机器学习库</a></p> 
  <p id="%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8F%AF%E8%A7%86%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8F%AF%E8%A7%86%E5%8C%96" rel="nofollow">1、数据集可视化</a></p> 
  <p id="%C2%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-toc" style="margin-left:80px;"><a href="#%C2%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92" rel="nofollow">&nbsp;2、线性回归</a></p> 
  <p id="%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E6%9E%90" rel="nofollow">3、决策树分析</a></p> 
  <p id="KMeans%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#KMeans%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90" rel="nofollow">4、KMeans聚类分析</a></p> 
  <hr id="hr-toc">
  <h1 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><strong>一、全部代码</strong></h1> 
  <pre class="has">
<code class="language-python">#安装 numpy、scipy、matplotlib三个库
pip install numpy
pip install scipy
pip install matplotlib
pip install sklearn

#导入包
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


from pylab import *
mpl.rcParams['font.sans-serif'] = ['SimHei']    #用于画图时显示中文


from sklearn.datasets import load_iris #导入数据集iris  
iris = load_iris() #载入数据集
print(iris.data)  #打印输出数据集


#共150条记录，分别代表50条山鸢尾 (Iris-setosa)、变色鸢尾(Iris-versicolor)、维吉尼亚鸢尾(Iris-virginica)
print(iris.target) 

iris.data.shape  # iris数据集150行4列的二维数组




url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"  
names = ['花萼-length', '花萼-width', '花瓣-length', '花瓣-width', 'class']  
dataset = pd.read_csv(url, names=names)


#************************可视化显示*************************************#
#显示直方图
zhifangtu=dataset.hist() #数据直方图histograms
plt.show(zhifangtu.data) 


print(dataset.describe())


#显示散点图
sandian=dataset.plot(x='花萼-length', y='花萼-width', kind='scatter') #散点图，x轴表示花萼长度，y轴表示花萼宽度
plt.show(sandian)  


#kde图
plt.show(dataset.plot(kind='kde')) #KDE图，也被称作密度图(Kernel Density Estimate,核密度估计)


#显示箱图
#kind='box'绘制箱图,包含子图且子图的行列布局layout为2*2，子图共用x轴、y轴刻度，标签为False
xiangtu = dataset.plot(kind='box', subplots=True, layout=(2,2), sharex=False, sharey=False)

plt.show(xiangtu.data)



#*****************************线性回归*************************************#

pos = pd.DataFrame(dataset)
#获取花瓣的长和宽，转换Series为ndarray
x = pos['花瓣-length'].values
y = pos['花瓣-width'].values
x = x.reshape(len(x),1)
y = y.reshape(len(y),1)

from sklearn.linear_model import LinearRegression
clf = LinearRegression()
clf.fit(x,y)
pre = clf.predict(x)

plt.scatter(x,y,s=100)
plt.plot(x,pre,'r-',linewidth=4)
for idx, m in enumerate(x):  
    plt.plot([m,m],[y[idx],pre[idx]], 'g-')  
plt.show()

#*****************************决策树分析***********************************#

from sklearn.datasets import load_iris   
from sklearn.tree import DecisionTreeClassifier     
iris = load_iris()      
clf = DecisionTreeClassifier()    
clf.fit(iris.data, iris.target)     
predicted = clf.predict(iris.data)    
    
#获取花卉两列数据集      
L1 = pos['花萼-length'].values   
L2 = pos['花萼-width'].values   
  
    
import numpy as np    
import matplotlib.pyplot as plt    
plt.scatter(L1, L2, c=predicted, marker='x')  #cmap=plt.cm.Paired    
plt.title("DTC")    
plt.show()  


#将iris_data分为70%的训练，30%的进行预测 然后进行优化 输出准确率、召回率等，优化后的完整代码如下：


from sklearn.tree import DecisionTreeClassifier    
from sklearn.model_selection import train_test_split
from sklearn import metrics

x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target, test_size=0.3)
clf = DecisionTreeClassifier()
clf.fit(x_train,y_train)
predict_target = clf.predict(x_test)

print(sum(predict_target == y_test)) #预测结果与真实结果比对
print(metrics.classification_report(y_test,predict_target))
print(metrics.confusion_matrix(y_test,predict_target))

L1 = [n[0] for n in x_test]
L2 = [n[1] for n in x_test]
plt.scatter(L1,L2, c=predict_target,marker='x')
plt.title('决策树分类器')
plt.show()



#*****************************KMeans聚类分析*******************************#

from sklearn.cluster import KMeans
from sklearn.datasets import load_iris
iris = load_iris()
clf = KMeans()
clf.fit(iris.data,iris.target)
predicted = clf.predict(iris.data)

pos = pd.DataFrame(dataset)    
L1 = pos['花萼-length'].values   
L2 = pos['花萼-width'].values    

plt.scatter(L1, L2, c=predicted, marker='s',s=100,cmap=plt.cm.Paired)    
plt.title("KMeans聚类分析")    
plt.show() 

#*******************************************


from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier

# Parameters
n_classes = 3
plot_colors = "ryb"
plot_step = 0.02

# Load data
iris = load_iris()

for pairidx, pair in enumerate([[0, 1], [0, 2], [0, 3],
                                [1, 2], [1, 3], [2, 3]]):
    # We only take the two corresponding features
    X = iris.data[:, pair]
    y = iris.target

    # Train
    clf = DecisionTreeClassifier().fit(X, y)

    # Plot the decision boundary
    plt.subplot(2, 3, pairidx + 1)

    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, plot_step),
                         np.arange(y_min, y_max, plot_step))
    plt.tight_layout(h_pad=0.5, w_pad=0.5, pad=2.5)

    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    cs = plt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu)

    plt.xlabel(iris.feature_names[pair[0]])
    plt.ylabel(iris.feature_names[pair[1]])

    # Plot the training points
    for i, color in zip(range(n_classes), plot_colors):
        idx = np.where(y == i)
        plt.scatter(X[idx, 0], X[idx, 1], c=color, label=iris.target_names[i],
                    cmap=plt.cm.RdYlBu, edgecolor='black', s=15)

plt.suptitle("Decision surface of a decision tree using paired features")
plt.legend(loc='lower right', borderpad=0, handletextpad=0)
plt.axis("tight")
plt.show()</code></pre> 
  <h1 id="%E5%88%86%E6%AD%A5%E9%AA%A4%E6%93%8D%E4%BD%9C">二、分步骤浏览</h1> 
  <h2 id="python%E4%B8%AD%E5%AE%89%E8%A3%85sklearn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%93">python中安装sklearn机器学习库</h2> 
  <p>安装sklearn前。需要先安装 numpy、scipy、matplotlib三个库。</p> 
  <pre class="has">
<code class="language-python">pip install numpy
pip install scipy
pip install matplotlib
pip install sklearn</code></pre> 
  <h3 id="%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8F%AF%E8%A7%86%E5%8C%96">1、数据集可视化</h3> 
  <p>采用Python的Sklearn机器学习库中自带的数据集——鸢尾花数据集。简单分析数据集之间特征的关系图，根据花瓣长度、花瓣宽度、花萼长度、花萼宽度四个特征进行绘图</p> 
  <p>Iris plants 数据集可以从<code>KEEL dataset</code>数据集网站获取，也可以直接从<code>Sklearn.datasets</code>机器学习包得到。数据集共包含4个特征变量、1个类别变量，共有150个样本。类别变量分别对应鸢尾花的三个亚属，分别是<code>山鸢尾 (Iris-setosa)</code>、<code>变色鸢尾(Iris-versicolor)</code>和<code>维吉尼亚鸢尾(Iris-virginica)</code> 分别用<code>[0,1,2]</code>来做映射</p> 
  <pre class="has">
<code class="language-python">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


from pylab import *
mpl.rcParams['font.sans-serif'] = ['SimHei']    #用于画图时显示中文


from sklearn.datasets import load_iris #导入数据集iris  </code></pre> 
  <pre class="has">
<code class="language-python">iris = load_iris() #载入数据集
print(iris.data)  #打印输出显示</code></pre> 
  <p><img alt="" class="has" height="436" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512142600257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="641"></p> 
  <pre class="has">
<code class="language-python">#共150条记录，分别代表50条山鸢尾 (Iris-setosa)、变色鸢尾(Iris-versicolor)、维吉尼亚鸢尾(Iris-virginica)
print(iris.target) 

iris.data.shape  # iris数据集150行4列的二维数组</code></pre> 
  <pre class="has">
<code class="language-python">url = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"  
names = ['花萼-length', '花萼-width', '花瓣-length', '花瓣-width', 'class']  
dataset = pd.read_csv(url, names=names)
zhifangtu=dataset.hist() #数据直方图histograms

plt.show(zhifangtu) #显示直方图</code></pre> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="480" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512144553293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="640"></p> 
  <pre class="has">
<code class="language-python">print(dataset.describe())</code></pre> 
  <p><img alt="" class="has" height="165" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512144657617.png" width="496"></p> 
  <pre class="has">
<code class="language-python">dataset.plot(x='花萼-length', y='花萼-width', kind='scatter') #散点图，x轴表示花萼长度，y轴表示花萼宽度
plt.show(dataset.plot)  #显示散点图</code></pre> 
  <p><img alt="" class="has" height="480" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512145037812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="640"></p> 
  <pre class="has">
<code class="language-python">plt.show(dataset.plot(kind='kde')) #KDE图，也被称作密度图(Kernel Density Estimate,核密度估计)</code></pre> 
  <p><img alt="" class="has" height="480" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512145510445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="640"></p> 
  <pre class="has">
<code class="language-python">#kind='box'绘制箱图,包含子图且子图的行列布局layout为2*2，子图共用x轴、y轴刻度，标签为False
xiangtu = dataset.plot(kind='box', subplots=True, layout=(2,2), sharex=False, sharey=False)

plt.show(xiangtu)#显示箱图</code></pre> 
  <p><img alt="" class="has" height="480" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512145826365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="640"></p> 
  <h3 id="RadViz%EF%BC%88%E9%9B%B7%E8%BE%BE%E5%9B%BE%EF%BC%89"><a href="https://link.jianshu.com?t=http%3A%2F%2Fpandas.pydata.org%2Fpandas-docs%2Fstable%2Fvisualization.html%23radviz" rel="nofollow">RadViz（雷达图）</a></h3> 
  <p><code>RadViz</code>是一种可视化多维数据的方式。它基于基本的弹簧压力最小化算法（在复杂网络分析中也会经常应用）。简单来说，将一组点放在一个平面上，每一个点代表一个属性，我们案例中有四个点，被放在一个单位圆上，接下来你可以设想每个数据集通过一个弹簧联接到每个点上，弹力和他们属性值成正比（属性值已经标准化），数据集在平面上的位置是弹簧的均衡位置。不同类的样本用不同颜色表示。</p> 
  <pre class="has">
<code class="language-python">from pandas.plotting import radviz
radviz(dataset,'class')</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="381" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512161838699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="575"></p> 
  <h3><a href="https://link.jianshu.com/?t=http%3A%2F%2Fpandas.pydata.org%2Fpandas-docs%2Fstable%2Fvisualization.html%23andrews-curves" rel="nofollow">Andrews曲线</a></h3> 
  <p><code>Andrews</code>曲线将每个样本的属性值转化为傅里叶序列的系数来创建曲线。通过将每一类曲线标成不同颜色可以可视化聚类数据，属于相同类别的样本的曲线通常更加接近并构成了更大的结构。</p> 
  <pre class="has">
<code class="language-python">from pandas.plotting import andrews_curves
andrews_curves(dataset,'class')</code></pre> 
  <p><img alt="" class="has" height="384" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512162037975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="575"></p> 
  <h3><a href="https://link.jianshu.com/?t=http%3A%2F%2Fpandas.pydata.org%2Fpandas-docs%2Fstable%2Fvisualization.html%23parallel-coordinates" rel="nofollow">平行坐标</a></h3> 
  <p>平行坐标也是一种多维可视化技术。它可以看到数据中的类别以及从视觉上估计其他的统计量。使用平行坐标时，每个点用线段联接。每个垂直的线代表一个属性。一组联接的线段表示一个数据点。可能是一类的数据点会更加接近。</p> 
  <pre class="has">
<code class="language-python">from pandas.plotting import parallel_coordinates
parallel_coordinates(dataset,'class')</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="380" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512162157834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="594"></p> 
  <p><a href="https://link.jianshu.com/?t=http%3A%2F%2Fpandas.pydata.org%2Fpandas-docs%2Fstable%2Fvisualization.html%23scatter-matrix-plot" rel="nofollow">散点图矩阵</a></p> 
  <p><code>scatter_matrix</code>散点矩阵图代表了两变量的相关程度，如果呈现出沿着对角线分布的趋势，说明它们的相关性较高。</p> 
  <pre class="has">
<code class="language-python">from pandas.plotting import scatter_matrix   
scatter_matrix(dataset, alpha=0.2, figsize=(6, 6), diagonal='kde') </code></pre> 
  <p>&nbsp;<img alt="" class="has" height="379" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512162343904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="402"></p> 
  <p>&nbsp;</p> 
  <h3 id="%C2%A0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">&nbsp;2、线性回归</h3> 
  <p>采用线性回归算法对鸢尾花的特征数据进行分析，预测花瓣长度、花瓣宽度、花萼长度、花萼宽度四个特征之间的线性关系。核心代码如下:</p> 
  <pre class="has">
<code class="language-python">pos = pd.DataFrame(dataset)
#获取花瓣的长和宽，转换Series为ndarray
x = pos['花瓣-length'].values
y = pos['花瓣-width'].values
x = x.reshape(len(x),1)
y = y.reshape(len(y),1)

from sklearn.linear_model import LinearRegression
clf = LinearRegression()
clf.fit(x,y)
pre = clf.predict(x)

plt.scatter(x,y,s=100)
plt.plot(x,pre,'r-',linewidth=4)
for idx, m in enumerate(x):  
    plt.plot([m,m],[y[idx],pre[idx]], 'g-')  
plt.show()</code></pre> 
  <p>&nbsp;<img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512162618241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70"></p> 
  <h3 id="%E5%86%B3%E7%AD%96%E6%A0%91%E5%88%86%E6%9E%90">3、决策树分析</h3> 
  <p>Sklearn机器学习包中，决策树实现类是DecisionTreeClassifier，能够执行数据集的多类分类。</p> 
  <pre class="has">
<code class="language-python">from sklearn.datasets import load_iris   
from sklearn.tree import DecisionTreeClassifier     
iris = load_iris()      
clf = DecisionTreeClassifier()    
clf.fit(iris.data, iris.target)     
predicted = clf.predict(iris.data)    
    
#获取花卉两列数据集      
L1 = pos['花萼-length'].values   
L2 = pos['花萼-width'].values   
  
    
import numpy as np    
import matplotlib.pyplot as plt    
plt.scatter(L1, L2, c=predicted, marker='x')  #cmap=plt.cm.Paired    
plt.title("DTC")    
plt.show()  </code></pre> 
  <p>&nbsp;<img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512162900503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70"></p> 
  <p><strong>将iris_data分为70%的训练，30%的进行预测 然后进行优化 输出准确率、召回率等，优化后的完整代码如下：</strong></p> 
  <pre class="has">
<code class="language-python">from sklearn.tree import DecisionTreeClassifier    
from sklearn.model_selection import train_test_split
from sklearn import metrics

x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target, test_size=0.3)
clf = DecisionTreeClassifier()
clf.fit(x_train,y_train)
predict_target = clf.predict(x_test)

print(sum(predict_target == y_test)) #预测结果与真实结果比对
print(metrics.classification_report(y_test,predict_target))
print(metrics.confusion_matrix(y_test,predict_target))

L1 = [n[0] for n in x_test]
L2 = [n[1] for n in x_test]
plt.scatter(L1,L2, c=predict_target,marker='x')
plt.title('DecisionTreeClassifier')
plt.show()</code></pre> 
  <p>&nbsp;<img alt="" class="has" height="387" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512163056207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70" width="506"></p> 
  <h3>4、KMeans聚类分析</h3> 
  <pre class="has">
<code class="language-python">from sklearn.cluster import KMeans
from sklearn.datasets import load_iris
iris = load_iris()
clf = KMeans()
clf.fit(iris.data,iris.target)
predicted = clf.predict(iris.data)

pos = pd.DataFrame(dataset)    
L1 = pos['花萼-length'].values   
L2 = pos['花萼-width'].values    

plt.scatter(L1, L2, c=predicted, marker='s',s=100,cmap=plt.cm.Paired)    
plt.title("KMeans聚类分析")    
plt.show() </code></pre> 
  <p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512163350988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70"></p> 
  <pre class="has">
<code class="language-python">from sklearn.datasets import load_iris
from sklearn.tree import DecisionTreeClassifier

# Parameters
n_classes = 3
plot_colors = "ryb"
plot_step = 0.02

# Load data
iris = load_iris()

for pairidx, pair in enumerate([[0, 1], [0, 2], [0, 3],
                                [1, 2], [1, 3], [2, 3]]):
    # We only take the two corresponding features
    X = iris.data[:, pair]
    y = iris.target

    # Train
    clf = DecisionTreeClassifier().fit(X, y)

    # Plot the decision boundary
    plt.subplot(2, 3, pairidx + 1)

    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, plot_step),
                         np.arange(y_min, y_max, plot_step))
    plt.tight_layout(h_pad=0.5, w_pad=0.5, pad=2.5)

    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    cs = plt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu)

    plt.xlabel(iris.feature_names[pair[0]])
    plt.ylabel(iris.feature_names[pair[1]])

    # Plot the training points
    for i, color in zip(range(n_classes), plot_colors):
        idx = np.where(y == i)
        plt.scatter(X[idx, 0], X[idx, 1], c=color, label=iris.target_names[i],
                    cmap=plt.cm.RdYlBu, edgecolor='black', s=15)

plt.suptitle("Decision surface of a decision tree using paired features")
plt.legend(loc='lower right', borderpad=0, handletextpad=0)
plt.axis("tight")
plt.show()</code></pre> 
  <p>&nbsp;<img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512163513706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hfbHVrb25n,size_16,color_FFFFFF,t_70"></p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
