<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>死锁的基本概念 « NotBeCN</title>
  <meta name="description" content="                  一、死锁的基本概念   1、死锁的定义：一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到资源，这种现象叫做进程死锁，这一组进程就被称为死锁进程   2、如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃   从死锁的定义中可以得到几个推论：   ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/12/w15977858408_90138076.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">死锁的基本概念</h1>
    <p class="post-meta">May 12, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <h2><a id="_0"></a><strong>一、死锁的基本概念</strong></h2> 
  <p>1、<strong>死锁的定义</strong>：一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到资源，这种现象叫做进程死锁，这一组进程就被称为死锁进程</p> 
  <p>2、如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃</p> 
  <p>从死锁的定义中可以得到几个推论：</p> 
  <p>1、参与死锁的所有进程都在等待资源（处于等待状态、阻塞状态）<br> 2、参与死锁的进程是当前系统中所有进程的子集（是部分进程首先发生的死锁现象，如果有更多的新的进程进入到死锁中，那么这个子集就会一直扩大，就会导致系统的崩溃）</p> 
  <h2><a id="_11"></a><strong>二、死锁的现象</strong></h2> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512092236748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxNTk3Nzg1ODQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 如果没有交通控制，随意让这些车往前走的话，就有可能出现这样的现象<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512092541917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxNTk3Nzg1ODQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 大家都在等待其他车给自己让位置，这就形成了死锁现象。</p> 
  <h2><a id="_18"></a><strong>三、为什么会产生死锁</strong></h2> 
  <p>1、资源数量有限、锁和信号量错误使用</p> 
  <p>2、从资源的使用方式来看：<br> “申请–分配–使用–释放”模式</p> 
  <p>可重用资源：可被多个进程多次使用<br> （1）可抢占资源（处理器CPU）与不可抢占资源（打印机）<br> （2）处理器、I/O部件、内存、文件、数据库、信号量<br> 可消耗资源：只可以使用一次、可创建和销毁的资源<br> （1）信号、中断、消息</p> 
  <h2><a id="_31"></a><strong>四、进程竞争可重用资源</strong></h2> 
  <p>第一个例子：<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512095631754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxNTk3Nzg1ODQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 进程Q可能要先申请一个<strong>磁带</strong>，然后使用的时候先上锁，不受别的进程的干扰，然后又去申请一个<strong>磁盘文件</strong>，有可能是把磁盘文件读到磁带上，或者是把磁带上的文件读到磁盘上，一样的要先上锁，然后执行相应的过程，比如拷贝数据的操作，最后用完资源就就锁这样一个过程。那么如果另外一个进程也要使用这种资源，当进程P拿到了磁盘这个资源，而进程Q拿到了磁带这个资源，而进程P又想要磁带，进程Q又想要磁盘，那么实际上这两个进程就是在互相等待，就导致了死锁的发生。</p> 
  <p>第二个例子:以内存分配为例<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512100514873.png" alt="在这里插入图片描述"><br> 首先可分配的内存就一共200KB，对于P1进程，他要先申请80K，在申请60K。而对于P2进程，他要先申请70K，在申请80K。那么两个进程所需要资源的总和超过了可分配的资源数量，如果P1申请到了80K，P2申请到了70K，他们要在申请剩余他们要的资源，就都不能满足，因为系统的可以资源已经没了，所以P1、P2就要等待，如果系统中没有剩余的资源了，那么这两个进程就处于死锁了。</p> 
  <h2><a id="_41"></a><strong>五、进程竞争可消耗资源</strong></h2> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512101145938.png" alt="在这里插入图片描述"><br> 首先，P1要做的事是从P2得到一个消息，然后再给P2发一个信息，而P2是要从P1得到一个消息，然后给P1发一个信息，如果代码是这个一个编写过程，那么P1没有得到P2发过来的消息的时候，P1就等待，P2没有得到P1发过来的消息的时候，P2也等待，于是他们两就互相等待，都等对方给自己发消息，就产生了死锁现象。</p> 
  <h2><a id="_46"></a><strong>六、活锁和饥饿</strong></h2> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190512103131217.png" alt="在这里插入图片描述"><br> 在一个并发系统中，因为两个进程是并发执行的，如果恰好出现了这样一种情况，PA已经拿到了资源1的使用权，然后他被切换，下面是PB上CPU执行，他获取了资源2的使用权，之后，不管是PA执行还是PB执行，资源1或资源2都会导致这个进程在CPU上盲等待，Peterson算法是一个盲等待的算法，就是如果PA上CPU了，他想获得资源2，他就会不断的探寻资源2是不是能获得，PB也是一样。这两个进程的特点是都能上到CPU执行，但都没有向前进展，</p> 
  <p><strong>活锁总结：</strong><br> （1）先加锁（获得这个资源就加锁）<br> （2）在轮询（想要获得其他资源的锁，就要去轮询）<br> —&gt;他们的状态就是每个进程可以上CPU，时间片到了就下CPU，但是无进展也没有阻塞</p> 
  <p>**饥饿：**一个进程所申请的资源总是被优先于自己的其他进程占用，而长时间处于不能被调度执行的状态（长时间处于就绪或者阻塞状态），这种现象叫做“饥饿”。即使是由资源分配的策略决定的。</p> 
  <h2><a id="_58"></a><strong>七、产生死锁的必要条件</strong></h2> 
  <p>1、互斥使用（资源独占）：<br> 一个资源每次只能给一个进程使用（打印机）</p> 
  <p>2、占有且等待（请求和保持，部分分配）<br> 进程在申请新的资源的同时保持对原有资源的占有。即一个进程请求资源得不到满足而阻塞自己时，并不释放自己已经分配得到的资源</p> 
  <p>3、不可抢占（不可剥夺）<br> 进程所获得的资源在未使用完毕之前不能被其他进程 抢占，而只能由占有该资源的进程自己释放</p> 
  <p>4、循环等待<br> 存在一个进程等待队列{P1,P2,…Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。</p> 
  <p>小结：当出现死锁时，这四个条件都成立，其中任何一个条件不成立，就一定没有死锁发生。</p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
