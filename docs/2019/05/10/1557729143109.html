<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>数据结构与算法之美 : 排序 « NotBeCN</title>
  <meta name="description" content="         &nbsp;   &nbsp;      &nbsp;   执行效率：从以下3个方面来衡量    1）最好情况、最坏情况、平均情况时间复杂度 2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑 3）比较次数和交换（或移动）次数   &nbsp;   内存&amp; 稳定性   &nbsp...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/10/1557729143109.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">数据结构与算法之美 : 排序</h1>
    <p class="post-meta">May 10, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="349" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510165518607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="509"></p> 
  <p>&nbsp;</p> 
  <h3>执行效率：从以下3个方面来衡量</h3> 
  <p><br> 1）最好情况、最坏情况、平均情况时间复杂度<br> 2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑<br> 3）比较次数和交换（或移动）次数</p> 
  <p>&nbsp;</p> 
  <h2>内存&amp; 稳定性</h2> 
  <p>&nbsp;</p> 
  <h3>原地排序:</h3> 
  <p>空间复杂度为 O(1)&nbsp;</p> 
  <p>&nbsp;</p> 
  <h3>稳定排序:&nbsp;</h3> 
  <p>比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p> 
  <p>&nbsp;</p> 
  <p><strong>这组数据里有两个 3</strong>。</p> 
  <p>&nbsp;</p> 
  <p>经过某种排序算法排序之后，如果两个 3&nbsp;的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；</p> 
  <p>如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法。</strong><br> &nbsp;</p> 
  <p>以客户下单举例:</p> 
  <p>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。 如图</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" src="https://static001.geekbang.org/resource/image/13/59/1381c1f3f7819ae61ab17455ed7f0b59.jpg"></p> 
  <p>&nbsp;</p> 
  <h1>冒泡排序</h1> 
  <p>&nbsp;</p> 
  <h3>4,5,6,3,2,1 从小到大排序.&nbsp;</h3> 
  <p><img alt="" class="has" height="690" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510165836651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="1035"></p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="667" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510170021374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="850"></p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="380" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510170119437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="638"></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code>// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n &lt;= 1) return;
 
 for (int i = 0; i &lt; n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j &lt; n - i - 1; ++j) {
      if (a[j] &gt; a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>冒泡排序:</p> 
  <ol>
   <li>空间复杂度为 O(1) , 原地排序算法.</li> 
   <li>是稳定排序, 当相邻两个元素大小相等的时候,不做交换</li> 
   <li>时间复杂度: 最好的情况 O(n)&nbsp; , 最坏 O(n^2) , 平均O(n^2)</li> 
  </ol>
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="161" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510170841390.png" width="659"></p> 
  <p>&nbsp;</p> 
  <p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。</p> 
  <blockquote> 
   <p>有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。<br> &nbsp;</p> 
  </blockquote> 
  <p><img alt="" class="has" height="306" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510171158898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="608"></p> 
  <p>&nbsp;</p> 
  <p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；</p> 
  <p>对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是<span style="color:#7c79e5;"><strong>n*(n-1)/2</strong></span>，也就是 15。</p> 
  <p>我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p> 
  <p>&nbsp;</p> 
  <p><strong>逆序度</strong>的定义正好跟有序度相反（默认从小到大为有序）</p> 
  <blockquote> 
   <p>逆序元素对：a[i] &gt; a[j], 如果 i &lt; j。<br> &nbsp;</p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <blockquote> 
   <p>逆序度 = 满有序度 - 有序度</p> 
  </blockquote> 
  <p>&nbsp;</p> 
  <p><strong>排序的过程就是增加有序度,减少逆序度的过程,最后达到满有序度.就说明排序完成了.</strong></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，</p> 
  <p>所以有序度是3。</p> 
  <p>n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。</p> 
  <h1><img alt="" class="has" height="402" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510171941402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="615"></h1> 
  <p>&nbsp;</p> 
  <p>冒泡排序有两个操作因子:&nbsp; &nbsp;<strong>比较</strong>和<strong>交换</strong></p> 
  <p>没交换一次,有序度就会增加1. 不管算法怎么改进, 交换次数总是确定的,即<strong>逆序度.</strong></p> 
  <h1>n*(n-1)/2 - 初始有序度</h1> 
  <p>&nbsp;</p> 
  <p>15-3 = 12 . 要进行 12 次交换操作.</p> 
  <p>&nbsp;</p> 
  <p>最坏情况: 有序度是 0, 需要 n*(n-1)/2 次交换</p> 
  <p>最好情况: 有序度是n*(n-1)/2 , 不需要交换</p> 
  <p>平均情况:&nbsp; n*(n-1)/4&nbsp; &nbsp; &nbsp;时间复杂度 O (n^2)</p> 
  <h1>&nbsp;</h1> 
  <h1>插入排序(Insertion Sort)</h1> 
  <p><br> &nbsp;</p> 
  <p><img alt="" class="has" height="395" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510172846355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="604"></p> 
  <h3>思想:</h3> 
  <p>将数组中的数据分为两个区间, 已排序区间和未排序空间. 初始排序区间只有一个元素. 是数组中的第一个元素.</p> 
  <p>取未排序区间中的元素,在已排序区间中找到合适的插入位置,将其插入,并保证已排序区间数据一直有序.</p> 
  <p>重复这个过程,知道未排序区间中的元素为空,算法结束.</p> 
  <p><img alt="" class="has" height="671" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510173228894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="872"></p> 
  <p>&nbsp;</p> 
  <p>插入排序也包含两种操作,一种是元素比较, 一种是元素移动.</p> 
  <p>&nbsp;</p> 
  <p>对于不同的查找插入点方法(从头到尾/从尾到头), 元素的比较次数是有区别的.</p> 
  <p>对于一个给定的初始序列,移动操作的次数总是固定的,等于逆序度.有序度是 n*(n-1)/2=15，</p> 
  <p>初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。</p> 
  <p>&nbsp;</p> 
  <p><strong>初始有序度为 5 : (4,5)&nbsp; (4,6)&nbsp; (5,6)&nbsp; (1,3)&nbsp; (1,2)</strong></p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="423" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510173819129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="601"></p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code>// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n &lt;= 1) return;

  for (int i = 1; i &lt; n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j &gt;= 0; --j) {
      if (a[j] &gt; value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>插入排序:</p> 
  <ol>
   <li>空间复杂度 O(1)</li> 
   <li>稳定的排序算法</li> 
   <li>最好情况 O(n)&nbsp; 从尾到头遍历已经有序的数据. 最坏 O(n^2&nbsp;)&nbsp; &nbsp;平均 O(n^2&nbsp;)&nbsp; &nbsp;</li> 
  </ol>
  <p>&nbsp;</p> 
  <h1>选择排序(Selection Sort)</h1> 
  <p>选择排序算法的实现思路有点类似插入排序, 也分已排序和未排序区间.</p> 
  <p>但是选择排序每次都会从未排序区间中找最小的元素,放到已排序区间的末尾.</p> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="481" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510175539320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="480"></p> 
  <p>&nbsp;</p> 
  <p>选择排序:</p> 
  <ol>
   <li>空间复杂度为 O(1)</li> 
   <li>是一种不稳定排序算法.</li> 
  </ol>
  <p>&nbsp;</p> 
  <h2>为什么插入排序比冒泡排序更受欢迎?</h2> 
  <p>时间复杂度一样,但是性能上 插入排序要比冒泡高. 因为交换值的时候, 冒泡要三个操作, 插入排序需要一个.</p> 
  <p>10000 个数组, 每个数组里面包含 200 个数组, 冒泡排序用时 700ms , 插入排序只需要 100ms 搞定</p> 
  <p>&nbsp;</p> 
  <pre class="has">
<code>冒泡排序中数据的交换操作：
if (a[j] &gt; a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] &gt; value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p><img alt="" class="has" height="326" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190510180248591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" width="670"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h1>总结：</h1> 
  <p><br> 一、几种经典排序算法及其时间复杂度级别<br> 冒泡、插入、选择 O(n^2) 基于比较<br> 快排、归并 O(nlogn) 基于比较<br> 计数、基数、桶 O(n) 不基于比较<br> 二、如何分析一个排序算法？<br> 1.学习排序算法的思路？明确原理、掌握实现以及分析性能。<br> 2.如何分析排序算法性能？从执行效率、内存消耗以及稳定性3个方面分析排序算法的性能。<br> 3.执行效率：从以下3个方面来衡量<br> 1）最好情况、最坏情况、平均情况时间复杂度<br> 2）时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑<br> 3）比较次数和交换（或移动）次数<br> 4.内存消耗：通过空间复杂度来衡量。针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为O(1)的排序算法。<br> 5.稳定性：如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。<br> 三、冒泡排序<br> 1.排序原理<br> 1）冒泡排序只会操作相邻的两个数据。<br> 2）对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。<br> 3）一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。<br> 4）优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。<br> 2.代码实现（见下一条留言）<br> 3.性能分析<br> 1）执行效率：最小时间复杂度、最大时间复杂度、平均时间复杂度<br> 最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是O(n)。<br> 最大时间复杂度：数据倒序排序时，需要n次冒泡操作，时间复杂度是O(n^2)。<br> 平均时间复杂度：通过有序度和逆序度来分析。<br> 什么是有序度？<br> 有序度是数组中具有有序关系的元素对的个数，比如[2,4,3,1,5,6]这组数据的有序度就是11，分别是[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]。同理，对于一个倒序数组，比如[6,5,4,3,2,1]，有序度是0；对于一个完全有序的数组，比如[1,2,3,4,5,6]，有序度为n*(n-1)/2，也就是15，完全有序的情况称为满有序度。<br> 什么是逆序度？逆序度的定义正好和有序度相反。核心公式：逆序度=满有序度-有序度。<br> 排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。<br> 冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加1。不管算法如何改进，交换的次数总是确定的，即逆序度。<br> 对于包含n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为0，所以要进行n*(n-1)/2交换。最好情况下，初始状态有序度是n*(n-1)/2，就不需要进行交互。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。<br> 换句话说，平均情况下，需要n*(n-1)/4次交换操作，比较操作可定比交换操作多，而复杂度的上限是O(n^2)，所以平均情况时间复杂度就是O(n^2)。<br> 以上的分析并不严格，但很实用，这就够了。<br> 2）空间复杂度：每次交换仅需1个临时变量，故空间复杂度为O(1)，是原地排序算法。<br> 3）算法稳定性：如果两个值相等，就不会交换位置，故是稳定排序算法。<br> 四、插入排序<br> 1.算法原理<br> 首先，我们将数组中的数据分为2个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。<br> 2.代码实现（见下一条留言）<br> 3.性能分析<br> 1）时间复杂度：最好、最坏、平均情况<br> 如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以时间复杂度是O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此时间复杂度是O(n^2)。而在一个数组中插入一个元素的平均时间复杂都是O(n)，插入排序需要n次插入，所以平均时间复杂度是O(n^2)。<br> 2）空间复杂度：从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是原地排序算法。<br> 3）算法稳定性：在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
