<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>JAVA 后台面试之操作系统问题集锦 « NotBeCN</title>
  <meta name="description" content="              JAVA 后台面试之操作系统问题集锦                   1.进程和线程以及他们的区别      2.进程间通信的几种方式      3.线程同步的方式      4.死锁      5.分页和分段有什么区别？（内存管理）      6.操作系统中进程调度的策略有哪几种...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/qq_39382769_90136591.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">JAVA 后台面试之操作系统问题集锦</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="post"> 
   <h1 class="postTitle"> <a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yinbiao/p/10662698.html" rel="nofollow">JAVA 后台面试之操作系统问题集锦</a> </h1> 
   <div class="clear"></div> 
   <div class="postBody"> 
    <div id="cnblogs_post_body" class="blogpost-body">
     <p><a href="#m1" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">1.进程和线程以及他们的区别</span></a></p> 
     <p><a href="#m2" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">2.进程间通信的几种方式</span></a></p> 
     <p><a href="#m3" rel="nofollow"><span style="font-family:'楷体';font-size:18px;"><span style="font-family:'楷体';">3.线程同步的方式</span></span></a></p> 
     <p><a href="#m4" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">4.死锁</span></a></p> 
     <p><a href="#m5" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">5.分页和分段有什么区别？（内存管理）</span></a></p> 
     <p><a href="#m6" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">6.操作系统中进程调度的策略有哪几种？</span></a></p> 
     <p><a href="#m7" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">7.页面置换算法：</span></a></p> 
     <p><a href="#m8" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">8.系统颠簸</span></a></p> 
     <p><a href="#m9" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">9.程序局部性原理</span></a></p> 
     <p>&nbsp;</p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m1"></a>1.进程和线程以及他们的区别</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*一个程序至少一个进程，一个进程至少一个线程，线程依赖于进程而存在</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*进程拥有独立的内存单元，而线程共享进程的内存单元</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m2"></a>2.进程间通信的几种方式</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*管道以及命名管道：管道用于具有父子关系的进程通信，有名管道无论两个进程间有没有关系，都可以通信</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*信号：用于通知接收进程某个事情已经发生</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*消息队列：消息的链接表，克服了上面两种方式中信号量有限的缺点，对消息队列具有写权限的进程可以按照一定的规则向消息队列中添加消息，对消息队列具有读权限的进程可以从消息队列中读取信息</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*共享内存：进程间最有用的通信方式，需要同步方式，比如互斥锁和信号量等</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*信号量：进程间或同一进程不同线程间同步和互斥的手段</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*套接字：应用于网络中的一般进程间的通信方式</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m3"></a>3.线程同步的方式</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">1）互斥量（Synchronized/Lock）：互斥对象机制</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2）信号量：运行同一时刻同一线程访问同一资源，但是要控制同一时刻访问此资源的最大线程数量</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">3）时间（信号）（Wait/Notify）：通过通知操作来保持多线程同步，还可以方便的实现多线程优先级的比较操作</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m4"></a>4.死锁</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">1）死锁产生的四个必要条件</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*互斥</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*占用并等待</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*非抢占：不能抢占，只能自愿释放</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*循环等待</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2）死锁的基本处理策略</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2.1)死锁预防：打破死锁四个必要条件中的一个就可以了</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*打破互斥条件：允许进程同时访问某些资源，但是某些资源因为自身属性问题，不能被同时访问，所以这种方法实用性不大</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*打破占用并等待条件：可以实行资源先分配策略（进程在运行前一次性向系统申请它需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行，只有当系统能满足当前线程所需全部资源时，才一次性将所需资源全部分配给该进程）或者只允许进程在没有占用资源时间才允许申请资源（一个进程可以申请一些资源并使用他们，但是在当前进程申请更多资源之前，它必须全部释放当前所占用的资源，但是这种策略也存在一些缺点：很多情况下，无法预知一个进程所需要的全部资源，因为进程是动态运行的，不可预知，同时会降低资源的利用效率，降低进程的并发性</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*打破非抢占条件：允许某个进程在资源得不到满足时强行从其他进程那里获取资源，实现起来困难，会降低系统性能</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*打破循环等待条件：实行资源有序分配策略，对所有资源排序编号，所有进程对资源的请求必须严格按照资源序号递增的顺序提出，即只有占用了小号资源才能占用大号资源，这样就不产生回环路，预防死锁</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2.2）死锁避免：动态的检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">安全状态:存在安全序列，使得系统处于安全状态</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">比如银行家算法和资源分配图算法</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2.3)死锁解除：进程终止和资源抢占</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">所谓进程终止是指简单的终止一个或者多个进程以打破循环等待，包括：终止所有死锁进程和一次只终止一个进程直到死锁消失</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">这个时候必须考虑三个问题：</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*选择一个牺牲品</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*回滚到安全状态</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">*饥饿（在代价因素中加上回滚次数，回滚得越多则越不可能继续作为牺牲品，避免一个进程总是被回滚）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m5"></a>5.分页和分段有什么区别？（内存管理）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">段式储存管理是一种符合用户视角的内存分配管理方案，在段式储存管理中，将程序地址空间划分为若干段，比如代码段，数据段，这样每一个进程有一个二维空间地址空间，相互独立，互不干扰，段式管理的优点是：没有内存碎片（因为段大小可变，改变段来消除内碎片），但段换入换出时，会产生外碎片（比如4K的段换5K的段，会产生1K的外碎片）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">页式储存管理方案用户视角和物理内存相分离的内存分配管理方案，在页式存储中，将程序逻辑地址划分为固定大小的页，而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一帧，这些帧不必连续，从而实现了离散分离，页式存储管理的优点是：没有外碎片，因为页的大小固定，但会产生内碎片（一个页可能填充不满）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">两者的不同点：</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">目的不同：分页是由于系统管理的需要而不是用户的需要，它是物理信息的单位，分段的目的是为了能够更好的用户的需要，它是信息的逻辑单位，它含有一组意义相对完整的信息</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">大小不同：页的大小固定且由系统决定，段的长度不固定，大小由其功能决定</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">地址空间不同：段向用户提供二维地址空间，页向用户提供一维地址空间</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">信息共享：段是信息的逻辑单位，便于储存保护和信息共享，页的信息保护和共享收到限制</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">内存碎片：页式没有外碎片，但是有内碎片，段式有内碎片，但是没有外碎片</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m6"></a>6.操作系统中进程调度的策略有哪几种？</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">1）FCFS（先来先服务，队列实现，非抢占）：先请求CPU的进程先分配CPU</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2)SJF(最短作业优先调度算法）：平均等待时间最短的优先</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">3）优先级调度算法（可以是抢占的，也可以是非抢占的）：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿，解决方案：老化</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">4）时间片轮转调度算法（可抢占）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">5）多级队列调度算法：将就绪队列分成多个独立队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度，其中，一个进程根据自身属性被永久的分配到一个队列中</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">6）多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动，若进程过多使用CPU时间，那么它会被转移到更低优先级的队列，在较低优先级队列等待时间过长的进程会被转移到更高的优先级，以防止饥饿发生</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m7"></a>7.页面置换算法：</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">1）FIFO（先进先出算法）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2）LRU（最近最少使用算法）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">3）LFU（最少使用次数算法）</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">4）OPT（最优置换算法）：理论的最优，理论：保证被置换出去等待是不再被使用的页，或者是在实际内存中使用最晚的页</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m8"></a>8.系统颠簸：频繁的页面调度行为，因为不断产生缺页中断，导致不断要调入页调出页</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">解决方案：</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">1）替换合适的页面调度算法</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">2）因为运行的程度太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">3）终止该进程或者增加物理内存容量</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;"><a name="m9"></a>9.程序局部性原理</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">空间上的局部性：内存中被访问的页的周围的页页很有可能被访问</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">时间上的局部性：最近被访问的页在不久的将来还会被访问</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:16px;">&nbsp;</span></p>
    </div>
    <div id="MySignature"></div> 
    <div class="clear"></div> 
    <div id="blog_post_info_block"> 
     <div id="BlogPostCategory"></div> 
     <div id="EntryTag"></div> 
     <div id="blog_post_info"> 
     </div> 
     <div class="clear"></div> 
     <div id="post_next_prev"></div> 
    </div> 
   </div> 
   <div class="postDesc">
    posted @ 
    <span id="post-date">2019-05-11 08:05</span> 
    <a href="https://www.cnblogs.com/yinbiao/" rel="nofollow">Y先森0.0</a> 阅读(
    <span id="post_view_count">...</span>) 评论(
    <span id="post_comment_count">...</span>) 
    <a href="https://i.cnblogs.com/EditPosts.aspx?postid=10662698" rel="nofollow">编辑</a> 
    <a href="#" rel="nofollow">收藏</a>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
