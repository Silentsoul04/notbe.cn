<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux就该这么学——第5天（20190511） « NotBeCN</title>
  <meta name="description" content="                  Linux就该这么学——第5天（20190511） 1、学习了Vim编辑器，一些常用的命令； 2、学习了一些简单的Shell命令脚本；   1、Vim文本编辑器   Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/weixin_43034500_90116131.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux就该这么学——第5天（20190511）</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>Linux就该这么学——第5天（20190511）<br> 1、学习了Vim编辑器，一些常用的命令；<br> 2、学习了一些简单的Shell命令脚本；</p> 
  <h1><a id="1Vim_3"></a>1、Vim文本编辑器</h1> 
  <p>Vim之所以能得到广大厂商与用户的认可，原因在于Vim编辑器中设置了三种模式—命令模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工作效率，而且用户在习惯之后也会觉得相当顺手。</p> 
  <blockquote> 
   <p>命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。</p> 
   <p>输入模式：正常的文本录入。</p> 
   <p>末行模式：保存或退出文档，以及设置编辑环境。</p> 
  </blockquote> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051121254460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzNDUwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
  <table> 
   <thead> 
    <tr> 
     <th>命令</th> 
     <th>作用</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>dd</td> 
     <td>删除（剪切）光标所在整行</td> 
    </tr> 
    <tr> 
     <td>5dd</td> 
     <td>删除（剪切）从光标处开始的5行</td> 
    </tr> 
    <tr> 
     <td>yy</td> 
     <td>复制光标所在整行</td> 
    </tr> 
    <tr> 
     <td>5yy</td> 
     <td>复制从光标处开始的5行</td> 
    </tr> 
    <tr> 
     <td>n</td> 
     <td>显示搜索命令定位到的下一个字符串</td> 
    </tr> 
    <tr> 
     <td>N</td> 
     <td>显示搜索命令定位到的上一个字符串</td> 
    </tr> 
    <tr> 
     <td>u</td> 
     <td>撤销上一步的操作</td> 
    </tr> 
    <tr> 
     <td>p</td> 
     <td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td> 
    </tr> 
   </tbody> 
  </table>
  <p><strong>末行模式主要用于保存或退出文件，以及设置Vim编辑器的工作环境，还可以让用户执行外部的Linux命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中输入一个冒号就可以了。</strong></p> 
  <table> 
   <thead> 
    <tr> 
     <th>命令</th> 
     <th>作用</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>:w</td> 
     <td>保存</td> 
    </tr> 
    <tr> 
     <td>:q</td> 
     <td>退出</td> 
    </tr> 
    <tr> 
     <td>:q!</td> 
     <td>强制退出（放弃对文档的修改内容）</td> 
    </tr> 
    <tr> 
     <td>:wq!</td> 
     <td>强制保存退出</td> 
    </tr> 
    <tr> 
     <td>:set nu</td> 
     <td>显示行号</td> 
    </tr> 
    <tr> 
     <td>:set nonu</td> 
     <td>不显示行号</td> 
    </tr> 
    <tr> 
     <td>:命令</td> 
     <td>执行该命令</td> 
    </tr> 
    <tr> 
     <td>:整数</td> 
     <td>跳转到该行</td> 
    </tr> 
    <tr> 
     <td>: s/one/two</td> 
     <td>将当前光标所在行的第一个one替换成two</td> 
    </tr> 
    <tr> 
     <td>: s/one/two/g</td> 
     <td>将当前光标所在行的所有one替换成two</td> 
    </tr> 
    <tr> 
     <td>:%s/one/two/g</td> 
     <td>将全文中的所有one替换成two</td> 
    </tr> 
    <tr> 
     <td>?字符串</td> 
     <td>在文本中从下至上搜索该字符串</td> 
    </tr> 
    <tr> 
     <td>/字符串</td> 
     <td>在文本中从上至下搜索该字符串</td> 
    </tr> 
   </tbody> 
  </table>
  <h2><a id="11_42"></a>1.1、配置主机名称</h2> 
  <p>为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在Linux系统中，主机名大多保存在/etc/hostname文件中，接下来将/etc/hostname文件的内容修改为“<a href="http://linuxprobe.com" rel="nofollow">linuxprobe.com</a>”，步骤如下：</p> 
  <blockquote> 
   <p>第1步：使用Vim编辑器修改“/etc/hostname”主机名称文件。</p> 
   <p>第2步：把原始主机名称删除后追加“<a href="http://linuxprobe.com" rel="nofollow">linuxprobe.com</a>”。注意，使用Vim编辑器修改主机名称文件后，要在末行模式下执行:wq!命令才能保存并退出文档。</p> 
   <p>第3步：保存并退出文档，然后使用hostname命令检查是否修改成功。</p> 
  </blockquote> 
  <h2><a id="12_51"></a>1.2、配置网卡信息</h2> 
  <p>现在有一个名称为ifcfg-eno16777736的网卡设备，我们将其配置为开机自启动，并且IP地址、子网、网关等信息由人工指定，其步骤应该如下所示。</p> 
  <p><strong>第1步：首先切换到/etc/sysconfig/network-scripts目录中（存放着网卡的配置文件）。<br> 第2步：使用Vim编辑器修改网卡文件ifcfg-eno16777736，逐项写入下面的配置参数并保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用ifconfig命令自行确认各自网卡的默认名称。</strong></p> 
  <blockquote> 
   <p>设备类型：TYPE=Ethernet<br> 地址分配模式：BOOTPROTO=static</p> 
   <p>网卡名称：NAME=eno16777736</p> 
   <p>是否启动：ONBOOT=yes</p> 
   <p>IP地址：IPADDR=192.168.10.10</p> 
   <p>子网掩码：NETMASK=255.255.255.0</p> 
   <p>网关地址：GATEWAY=192.168.10.1</p> 
   <p>DNS地址：DNS1=192.168.10.1</p> 
  </blockquote> 
  <p><strong>第3步：重启网络服务并测试网络是否联通。<br> 进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：</strong></p> 
  <pre><code>[root@linuxprobe ~]# cd /etc/sysconfig/network-scripts/
[root@linuxprobe network-scripts]# vim ifcfg-eno16777736
TYPE=Ethernet
BOOTPROTO=static
NAME=eno16777736
ONBOOT=yes
IPADDR=192.168.10.10
NETMASK=255.255.255.0
GATEWAY=192.168.10.1
DNS1=192.168.10.1
</code></pre> 
  <p><strong>执行重启网卡设备的命令（在正常情况下不会有提示信息），然后通过ping命令测试网络能否联通。由于在Linux系统中ping命令不会自动终止，因此需要手动按下Ctrl-c键来强行结束进程。</strong></p> 
  <pre><code>[root@linuxprobe network-scripts]# systemctl restart network
[root@linuxprobe network-scripts]# ping 192.168.10.10
PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.
64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.081 ms
64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.083 ms
64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.059 ms
64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.097 ms
^C
--- 192.168.10.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2999ms
rtt min/avg/max/mdev = 0.059/0.080/0.097/0.013 ms
</code></pre> 
  <h2><a id="13Yum_99"></a>1.3、配置Yum仓库</h2> 
  <p><strong>第1步：进入到/etc/yum.repos.d/目录中（因为该目录存放着Yum软件仓库的配置文件）。<br> 第2步：使用Vim编辑器创建一个名为rhel7.repo的新配置文件（文件名称可随意，但后缀必须为.repo），逐项写入下面加粗的配置参数并保存退出（不要写后面的中文注释）。</strong></p> 
  <blockquote> 
   <p>[rhel-media] ：Yum软件仓库唯一标识符，避免与其他仓库冲突。</p> 
   <p>name=linuxprobe：Yum软件仓库的名称描述，易于识别仓库用处。</p> 
   <p>baseurl=file:///media/cdrom：提供的方式包括FTP（ftp://…）、HTTP（http://…）、本地（file:///…）。</p> 
   <p>enabled=1：设置此源是否可用；1为可用，0为禁用。</p> 
   <p>gpgcheck=1：设置此源是否校验文件；1为校验，0为不校验。</p> 
   <p>gpgkey=file:///media/cdrom/RPM-GPG-KEY-redhat-release：若上面参数开启校验，那么请指定公钥文件地址。</p> 
  </blockquote> 
  <p><strong>第3步：按配置参数的路径挂载光盘，并把光盘挂载信息写入到/etc/fstab文件中。<br> 第4步：使用“yum install httpd -y”命令检查Yum软件仓库是否已经可用。<br> 进入/etc/yum.repos.d目录中后创建Yum配置文件：</strong></p> 
  <pre><code>[root@linuxprobe ~]# cd /etc/yum.repos.d/
[root@linuxprobe yum.repos.d]# vim rhel7.repo
[rhel7]
name=rhel7
baseurl=file:///media/cdrom
enabled=1
gpgcheck=0
</code></pre> 
  <h1><a id="2Shell_126"></a>2、编写Shell脚本</h1> 
  <p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有两种：交互式和批处理。</p> 
  <blockquote> 
   <p>交互式（Interactive）：用户每输入一条命令就立即执行。</p> 
   <p>批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p> 
  </blockquote> 
  <p><strong>查看SHELL变量可以发现当前系统已经默认使用Bash作为命令行终端解释器了：</strong></p> 
  <pre><code>[root@linuxprobe ~]# echo $SHELL
/bin/bash
</code></pre> 
  <h2><a id="21_137"></a>2.1、编写简单的脚本</h2> 
  <p>例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：</p> 
  <pre><code>[root@linuxprobe ~]# vim example.sh
#!/bin/bash 
#For Example BY linuxprobe.com 
pwd 
ls -al
</code></pre> 
  <p><mark><strong>Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以表示是一个脚本文件。</strong></mark> 在上面的这个example.sh脚本中实际上出现了三种不同的元素：</p> 
  <blockquote> 
   <p>第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；<br> 第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；<br> 第三、四行的可执行语句也就是我们平时执行的Linux命令了。</p> 
  </blockquote> 
  <pre><code>[root@linuxprobe ~]# bash example.sh
/root/Desktop
total 8
drwxr-xr-x. 2 root root 23 Jul 23 17:31 .
dr-xr-x---. 14 root root 4096 Jul 23 17:31 ..
-rwxr--r--. 1 root root 55 Jul 23 17:31 example.sh
</code></pre> 
  <h2><a id="22_158"></a>2.2、接收用户的参数</h2> 
  <p>为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。<br> Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间可以使用空格间隔。例如 <mark>$0</mark> 对应的是当前Shell脚本程序的名称， <mark>$#</mark> 对应的是总共有几个参数， <mark>$*</mark> 对应的是所有位置的参数值， <mark>$?</mark> 对应的是显示上一次命令的执行返回值，而 <mark>$1、$2、$3</mark> ……则分别对应着第N个位置的参数值.<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051122062979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzNDUwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 尝试编写一个脚本程序示例，通过引用上面的变量参数来看下真实效果：</p> 
  <pre><code>[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第1个参数为$1，第5个为$5。"
[root@linuxprobe ~]# sh example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。
</code></pre> 
  <h2><a id="23_174"></a>2.3、判断用户的参数</h2> 
  <p>系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。条件测试语法的执行格式如下图所示。 <mark><strong>切记，条件表达式两边均应有一个空格。</strong></mark><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511220916351.png" alt="在这里插入图片描述"><br> 按照测试对象来划分，条件测试语句可以分为4种：</p> 
  <blockquote> 
   <p>文件测试语句；</p> 
   <p>逻辑测试语句；</p> 
   <p>整数值比较语句；</p> 
   <p>字符串比较语句。</p> 
  </blockquote> 
  <p>文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如下表所示：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>操作符</th> 
     <th>作用</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>-d</td> 
     <td>测试文件是否为目录类型</td> 
    </tr> 
    <tr> 
     <td>-e</td> 
     <td>测试文件是否存在</td> 
    </tr> 
    <tr> 
     <td>-f</td> 
     <td>判断是否为一般文件</td> 
    </tr> 
    <tr> 
     <td>-r</td> 
     <td>测试当前用户是否有权限读取</td> 
    </tr> 
    <tr> 
     <td>-w</td> 
     <td>测试当前用户是否有权限写入</td> 
    </tr> 
    <tr> 
     <td>-x</td> 
     <td>测试当前用户是否有权限执行</td> 
    </tr> 
   </tbody> 
  </table>
  <p>下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着目录不存在：</p> 
  <pre><code>[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?
1
</code></pre> 
  <p>逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。</p> 
  <blockquote> 
   <p>第一种：逻辑“与”的运算符号是&amp;&amp;，它表示当前面的命令执行成功后才会执行它后面的命令；<br> 第二种：逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的命令执行失败后才会执行它后面的命令；<br> 第三种：第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。</p> 
  </blockquote> 
  <h2><a id="24_208"></a>2.4、整数比较运算符</h2> 
  <p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如下表所示：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>操作符</th> 
     <th>作用</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>-eq</td> 
     <td>是否等于</td> 
    </tr> 
    <tr> 
     <td>-ne</td> 
     <td>是否不等于</td> 
    </tr> 
    <tr> 
     <td>-gt</td> 
     <td>是否大于</td> 
    </tr> 
    <tr> 
     <td>-lt</td> 
     <td>是否小于</td> 
    </tr> 
    <tr> 
     <td>-le</td> 
     <td>是否等于或小于</td> 
    </tr> 
    <tr> 
     <td>-ge</td> 
     <td>是否大于或等于</td> 
    </tr> 
   </tbody> 
  </table>
  <p>接下来小试牛刀。我们先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：</p> 
  <pre><code>[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?
1
[root@linuxprobe ~]# [ 10 -eq 10 ]
[root@linuxprobe ~]# echo $?
0
</code></pre> 
  <h2><a id="25_227"></a>2.5、字符串比较语句</h2> 
  <p>字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如下表所示：</p> 
  <table> 
   <thead> 
    <tr> 
     <th>操作符</th> 
     <th>作用</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>=</td> 
     <td>比较字符串内容是否相同</td> 
    </tr> 
    <tr> 
     <td>!=</td> 
     <td>比较字符串内容是否不同</td> 
    </tr> 
    <tr> 
     <td>-z</td> 
     <td>判断字符串内容是否为空</td> 
    </tr> 
   </tbody> 
  </table>
  <p>接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：</p> 
  <pre><code>[root@linuxprobe ~]# [ -z $String ]
[root@linuxprobe ~]# echo $?
0
</code></pre> 
  <h1><a id="3_240"></a>3、流程控制语句</h1> 
  <p><strong>if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。</strong><br> if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图所示。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511221939660.png" alt="在这里插入图片描述"><br> if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图所示。</p> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511222033557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzNDUwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络联通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。</p> 
  <pre><code>[root@linuxprobe ~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null
if [ $? -eq 0 ]
then
echo "Host $1 is On-line."
else
echo "Host $1 is Off-line."
fi
</code></pre> 
  <p><mark>$?</mark> 变量作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则 <mark>$?</mark> 变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断 <mark>$?</mark> 变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：</p> 
  <pre><code>[root@linuxprobe ~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@linuxprobe ~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.
</code></pre> 
  <p>if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图所示。<br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511222419714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzNDUwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一定的提示信息。在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：</p> 
  <pre><code>[root@linuxprobe ~]# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ] ; then
echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ] ; then
echo "$GRADE is Pass"
else
echo "$GRADE is Fail" 
fi
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@linuxprobe ~]# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass
</code></pre> 
  <p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511222958482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzNDUwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223023885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzNDUwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
