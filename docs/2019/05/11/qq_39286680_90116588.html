<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>【ICPC模板】组合数学（更新中） « NotBeCN</title>
  <meta name="description" content="          目录   Combinatorics（组合数学）   康托展开   Catalan Number (卡特兰数)   通项公式   递推关系   渐进关系   相关问题   卡特兰数扩展问题   字典序下一个排列   STL内置函数   范德蒙恒等式   推论   杨辉恒等式   纵向递推式  ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/qq_39286680_90116588.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">【ICPC模板】组合数学（更新中）</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="Combinatorics%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89-toc" style="margin-left:0px;"><a href="#Combinatorics%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89" rel="nofollow">Combinatorics（组合数学）</a></p> 
  <p id="%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80-toc" style="margin-left:40px;"><a href="#%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80" rel="nofollow">康托展开</a></p> 
  <p id="Catalan%20Number%20(%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0)-toc" style="margin-left:40px;"><a href="#Catalan%20Number%20(%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0)" rel="nofollow">Catalan Number (卡特兰数)</a></p> 
  <p id="%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F" rel="nofollow">通项公式</a></p> 
  <p id="%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB-toc" style="margin-left:80px;"><a href="#%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB" rel="nofollow">递推关系</a></p> 
  <p id="%E6%B8%90%E8%BF%9B%E5%85%B3%E7%B3%BB-toc" style="margin-left:80px;"><a href="#%E6%B8%90%E8%BF%9B%E5%85%B3%E7%B3%BB" rel="nofollow">渐进关系</a></p> 
  <p id="%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98" rel="nofollow">相关问题</a></p> 
  <p id="%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98" rel="nofollow">卡特兰数扩展问题</a></p> 
  <p id="%E5%AD%97%E5%85%B8%E5%BA%8F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-toc" style="margin-left:80px;"><a href="#%E5%AD%97%E5%85%B8%E5%BA%8F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97" rel="nofollow">字典序下一个排列</a></p> 
  <p id="STL%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#STL%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0" rel="nofollow">STL内置函数</a></p> 
  <p id="%E8%8C%83%E5%BE%B7%E8%92%99%E6%81%92%E7%AD%89%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E8%8C%83%E5%BE%B7%E8%92%99%E6%81%92%E7%AD%89%E5%BC%8F" rel="nofollow">范德蒙恒等式</a></p> 
  <p id="%E6%8E%A8%E8%AE%BA-toc" style="margin-left:80px;"><a href="#%E6%8E%A8%E8%AE%BA" rel="nofollow">推论</a></p> 
  <p id="%E6%9D%A8%E8%BE%89%E6%81%92%E7%AD%89%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E6%9D%A8%E8%BE%89%E6%81%92%E7%AD%89%E5%BC%8F" rel="nofollow">杨辉恒等式</a></p> 
  <p id="%E7%BA%B5%E5%90%91%E9%80%92%E6%8E%A8%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E7%BA%B5%E5%90%91%E9%80%92%E6%8E%A8%E5%BC%8F" rel="nofollow">纵向递推式</a></p> 
  <p id="%E6%A8%AA%E5%90%91%E9%80%92%E6%8E%A8%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E6%A8%AA%E5%90%91%E9%80%92%E6%8E%A8%E5%BC%8F" rel="nofollow">横向递推式</a></p> 
  <p id="%E5%AF%B9%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">对称表达式</a></p> 
  <p id="%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88%E6%80%A7%E6%81%92%E7%AD%89%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88%E6%80%A7%E6%81%92%E7%AD%89%E5%BC%8F" rel="nofollow">组合聚合性恒等式</a></p> 
  <p style="margin-left:80px;"><a href="#%E6%8E%A8%E8%AE%BA" rel="nofollow">推论</a></p> 
  <p id="%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86" rel="nofollow">二项式定理</a></p> 
  <p style="margin-left:80px;"><a href="#%E6%8E%A8%E8%AE%BA" rel="nofollow">推论</a></p> 
  <p id="%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E6%8E%92%E5%88%97%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E6%8E%92%E5%88%97%E6%95%B0" rel="nofollow">多重集合排列数</a></p> 
  <p id="%E6%97%A0%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86-toc" style="margin-left:40px;"><a href="#%E6%97%A0%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86" rel="nofollow">无限多重集</a></p> 
  <p id="%E6%9C%89%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86-toc" style="margin-left:80px;"><a href="#%E6%9C%89%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86" rel="nofollow">有限多重集</a></p> 
  <p id="%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E7%BB%84%E5%90%88%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E7%BB%84%E5%90%88%E6%95%B0" rel="nofollow">多重集合组合数</a></p> 
  <p style="margin-left:80px;"><a href="#%E6%97%A0%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86" rel="nofollow">无限多重集</a></p> 
  <p style="margin-left:80px;"><a href="#%E6%9C%89%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86" rel="nofollow">有限多重集</a></p> 
  <hr id="hr-toc">
  <p>&nbsp;</p> 
  <h1 id="Combinatorics%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89">Combinatorics（组合数学）</h1> 
  <h2 id="%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80">康托展开</h2> 
  <p style="margin-left:0cm;">由一个排列计算它是全排列中的第几个排列的方法。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="38" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230007185.png" width="415"></p> 
  <p style="margin-left:0cm;">公式中x!表示x的阶乘，如果将排列元素写成一行，则a[n]表示从右向左数的第n个数，在其左边没有出现过且比当前数小的数的个数。</p> 
  <p style="margin-left:0cm;">如3 5 2 1 4中，比3小的数有2和1，一共2个，则a[5] = 2；到5时，比5小的且没有在它左边出现过的数有1, 2, 4，一共3个，则a[4] = 3……</p> 
  <p style="margin-left:0cm;">可以发现对于字典序最小的排列如1 2 3 4 5，使用此公式得到的值是0。这个函数的函数值取值范围是0 ~ (n! – 1)之间的所有整数（包括0和n! - 1）。</p> 
  <p style="margin-left:0cm;">利用此公式可以建立一个从排列到连续自然数的双射函数，可用来建立散列表或者将一些全排列相关状态压缩成一个数。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">说明：</p> 
  <p style="margin-left:0cm;">使用树状数组(Binary Indexed Tree)来获得到当前位置，有多少未出现过的且比它小的数的个数。初始时每个数的个数都是1，遍历过一个数后就把它置0，这样每次只需要查询前缀和就可以获得比当前数小且没遍历到的数的个数。</p> 
  <p style="margin-left:0cm;">数据：</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; permutation[]，存放一个全排列。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; cantor_pre[]，用来维护前缀的树状数组。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; fac[]，阶乘表，对于一个有n个元素的排列，需要建立0 ~ n – 1的阶乘表。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">常量：</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; const int OFF，偏移量(offset)，如果permutation数组中的排列不是从1开始的（比如经常会见到从0开始的全排列），那么就需要将OFF设置成一个数值，使得它加上这个全排列的最小值后等于1（如最小值是0时，OFF需要设置成1）。这是建立树状数组的需要，错误的OFF值可能会导致错误的运算结果或是非法内存访问。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; const int LIM，排列元素数量上限。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">函数：</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; lowbit(int x)，树状数组结点索引计算需要。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; cantor_update(int idx, int diff)，树状数组的更新函数。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; cantor_query(int idx)，树状数组的查询函数。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; cantor_init(int n)，树状数组的初始化函数，参数n是排列的元素个数。初始化时利用了树状数组第i个结点的值，是原始数据i – lowbit(i) + 1的数据到i的数据之和，因为这里初始化时数据都是1，所以等价于i – (i – lowbit(i)) = lowbit(i)。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; cantor_expansion(int n)，康托展开的主函数，参数n是排列元素个数，排列应当被存储在permutaion数组中，且从0号下标处开始存储。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; inverse_cantor(int n, int x)，将第x个排列还原到permutation数组中，是cantor_expansion()函数的逆过程。</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int LIM = 10;
const int OFF = 0;
int cantor_pre[LIM];
int permutation[LIM] = {3, 5, 7, 4, 1, 2, 9, 6, 8};
int fac[LIM] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};;
inline int lowbit(int x) {return x &amp; (-x);}
inline void cantor_update(int idx, int diff) {
    for (; idx &lt; LIM; idx += lowbit(idx))
        cantor_pre[idx] += diff;
}
inline int cantor_query(int idx) {
    int ret = 0;
    for (; idx &gt; 0; idx -= lowbit(idx))
        ret += cantor_pre[idx];
    return ret;
}
inline void cantor_init(int n) {
    memset(cantor_pre, 0, sizeof cantor_pre);
    for (int i = 0; i &lt; n; i++) {
        int x = permutation[i] + OFF;
        cantor_pre[x] += lowbit(x);
    }
}
int cantor_expansion(int n) {
    cantor_init(n);
    int ret = 0;
    for (int i = 1; i &lt;= n; i++) {
        ret += cantor_query(permutation[i - 1] + OFF - 1) * fac[n - i];
        cantor_update(permutation[i - 1] + OFF, -1);
    }
    return ret;
}
void inverse_cantor(int n, int x) {
    memset(cantor_pre, 0, sizeof cantor_pre);
    for (int i = 1; i &lt;= n; i++) {
        int tmp = x / fac[n - i], t;
        int cur = tmp + 1;
        x %= fac[n - i];
        while ((t = cantor_query(cur) + tmp + 1) != cur)
            cur = t;
        permutation[i - 1] = cur - OFF;
        cantor_update(permutation[i - 1] + OFF, 1);
    }
}

int main(void) {
    printf("The permutation is:\n");
    for (int i = 0; i &lt; 9; i++) {
        if (i) putchar(' ');
        printf("%d", permutation[i]);
    }
    putchar('\n');
    int tmp;
    printf("idx: %d\n", tmp = cantor_expansion(9));
    memset(permutation, 0, sizeof permutation);
    inverse_cantor(9, tmp);
    printf("Inverse_cantor:\n");
    for (int i = 0; i &lt; 9; i++) {
        if (i) putchar(' ');
        printf("%d", permutation[i]);
    }
    putchar('\n');
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">Time Complexity: O(nlogn)</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="Catalan%20Number%20(%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0)" style="margin-left:0cm;">Catalan Number (卡特兰数)</h2> 
  <h3 id="%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F">通项公式</h3> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230054266.png" width="450"></p> 
  <p style="margin-left:0cm;">其中Cn表示Catalan数序列的第n项。</p> 
  <p style="margin-left:0cm;">上述通项公式可以被理解为：在一个二维直角坐标平面内，从(0, 0)点出发走到(2n, 0)点的路径数，这条路径要求对于任意点(x, y)对于其横坐标相邻点的纵坐标差值的绝对值等于1，且合法的路径要求任意一个点都不在横坐标下方。先不考虑合法与不合法，如果只要求能够从(0, 0)到达(2n, 0)，则要求有一半的点选择向上走，一半的点选择向下走，因此数量应等于2n中抽取n个元素的组合数。接着排除不合法的情况，对于所有不合法的情况，按照上述的走法，可以确保能够找到第一个点(x, y)满足：它的纵坐标等于-1，且是从左到右第一个这样的点，以这个点做平行于x轴的直线，将这个点之前的点做这条直线x = -1的对称点，则起点(0, 0)被翻折到(0, -2)，由于每一条不合法路径都满足这个条件，而反过来，对于每一个从(0, -2)出发到达(2n, 0)的路径都可以按照刚才的翻折方法逆着翻折回去，得到一条不合法路径，这样的路径有2n中抽取n + 1的组合数条，因为要从纵坐标-2走到0必须保证选择向上走的点数比向下走的点数多2，从刚才C(2n, n)中排除掉这里的C(2n, n+1)就得到了卡特兰数第n项Cn。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB" style="margin-left:0cm;">递推关系</h3> 
  <p style="margin-left:0cm;">将n – 1项与n项求出，作商，得到递推公式。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051123011823.png" width="171"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%B8%90%E8%BF%9B%E5%85%B3%E7%B3%BB" style="margin-left:0cm;">渐进关系</h3> 
  <p style="margin-left:0cm;">核心：利用斯特林公式进行推导。</p> 
  <p style="margin-left:0cm;">可以得到</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="76" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230142697.png" width="158"></p> 
  <p style="margin-left:0cm;">~表示当n趋向于∞时，左式除以右式的商趋向于1.</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98" style="margin-left:0cm;">相关问题</h3> 
  <p style="margin-left:0cm;">1.Cn可以表示长度为2n的Dyck Words的种类数，Dyck Words由n个A字符与n个B字符组成，且满足在任意位置上，前缀中A的数量不小于B的数量，如果A用(代替，把B用)代替，就是一个典型的括号表达式，因此也可以用来表示合法的表达式个数。</p> 
  <p style="margin-left:0cm;">2.Cn可以表示有n个结点的不同构的二叉树的种类数。</p> 
  <p style="margin-left:0cm;">3.Cn可以表示有2n + 1个结点的不同构的满二叉树的种类数。</p> 
  <p style="margin-left:0cm;">4.Cn可以表示在n*n的格点中从左下角延格线走到右上角且始终不超过对角线的方案数。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="227" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230219499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mjg2Njgw,size_16,color_FFFFFF,t_70" width="463"></p> 
  <p style="margin-left:0cm;">5.Cn可以表示通过连接顶点将n + 2个顶点的凸多边形划分成三角形的方案数。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="189" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230232187.png" width="428"></p> 
  <p style="margin-left:0cm;">6.Cn表示有n个元素的出栈顺序的种类数。</p> 
  <p style="margin-left:0cm;">7.Cn可以用在买票找零钱问题上，对于2n的观众，收银台初始没有钱，无法找零，接下来有n个人拿a元买票，n个人拿2a元买票（需要找零钱数为a），能够保证每一个需要找零的观众来的时候都能够得到找零的合法方案数。</p> 
  <p style="margin-left:0cm;">8.Cn可以表示在二维直角坐标系中，从(0, 0)走到(2n, 0)点，每个相邻整数点的纵坐标差值的绝对值为1，且点始终不会落到x轴下方的方案数。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98" style="margin-left:0cm;">卡特兰数扩展问题</h3> 
  <p style="margin-left:0cm;">从(0, 0)点沿网格格线走到(a, b)点，且路径上始终不越过对角线x = y的方案数有</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230256313.png" width="173"></p> 
  <p style="margin-left:0cm;">种，证明思路与一般卡特兰数通项公式的类似，先计算出全部可能方案数，再减去非法方案数，对于每个非法方案，总可以找到其越过对角线的第一个点，过这点做对角线的平行线，将这个点之前的所有路径都以此直线为对称轴进行翻折，起点(0, 0)必然会翻折到(-1, 1)点上，因此非法方案数的数目等同于从(-1, 1)点走到(a, b)点的路径数。</p> 
  <p style="margin-left:0cm;">假设对于一个找零问题，题目给定初始条件是没有零钱，接着会来a个拿50元的人，b个拿100元的人（需要找零的人），并要求最后剩下的50元零钱的张数在[L, R]之间，使用这里的定理，对于要剩下j张50元零钱，可以将(n + j) / 2代入a，(n – j) / 2代入b，考虑到n + j为奇数的情况下必然无法达成条件，因此代入式子后，前面的b向下取整，后面的b向上取整，即：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="72" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230307288.png" width="257"></p> 
  <p style="margin-left:0cm;">对j取[L, R]每一个整数，求和，分j为奇偶讨论可归纳出：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230316362.png" width="246"></p> 
  <p style="margin-left:0cm;">所以求和式得到：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230323935.png" width="202"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E5%AD%97%E5%85%B8%E5%BA%8F%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97" style="margin-left:0cm;">字典序下一个排列</h3> 
  <h3 id="STL%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">STL内置函数</h3> 
  <p style="margin-left:0cm;">使用STL在algorithm中的相关函数：</p> 
  <table border="1" cellspacing="0">
   <tbody>
    <tr>
     <td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">bool next_permutation (BidirectionalIterator first, BidirectionalIterator last)</p> <p style="margin-left:0cm;">bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp)</p> </td> 
    </tr>
   </tbody>
  </table>
  <p style="margin-left:0cm;">将[first, last)的数据生成下一个排列。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E8%8C%83%E5%BE%B7%E8%92%99%E6%81%92%E7%AD%89%E5%BC%8F" style="margin-left:0cm;">范德蒙恒等式</h2> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230404934.png" width="250"></p> 
  <p>&nbsp;</p> 
  <h3 id="%E6%8E%A8%E8%AE%BA">推论</h3> 
  <p style="margin-left:0cm;">令n = x, m = y, k取min(x, y)，则有：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230429172.png" width="226"></p> 
  <p style="margin-left:0cm;">等号左侧原本是k的位置填x和y都可以，因为C(x + y, x) = C(x + y, y)。右侧将k – i放到与k取值相同的那一侧，如果k取y，则是C(y, k – i) = C(y, y – i) = C(y, i)，反过来k取x时同理。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E6%9D%A8%E8%BE%89%E6%81%92%E7%AD%89%E5%BC%8F" style="margin-left:0cm;">杨辉恒等式</h2> 
  <h3 id="%E7%BA%B5%E5%90%91%E9%80%92%E6%8E%A8%E5%BC%8F">纵向递推式</h3> 
  <p style="margin-left:0cm;">可用来从上到下递推建立杨辉三角。</p> 
  <p style="margin-left:0cm;">常见用途：</p> 
  <p style="margin-left:0cm;">从上到下建立组合数（二项式系数）表，对于C++中64位的long long int类型，大致可以安全（不溢出）建立到50~60+行左右的组合数表。如果加入取余可以求解更大范围的组合数，但是如果n与m的范围过大，而取余的数是素数，则使用Lucas定理求解更为快捷。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230504853.png" width="242"></p> 
  <p style="margin-left:0cm;">代码说明：</p> 
  <p style="margin-left:0cm;">函数：buildC()，调用后组合数表会建立在数组C[][]中。</p> 
  <p style="margin-left:0cm;">使用：数组元素C[i][j]存放着表示i个元素选取j个元素的组合数(i, j)。</p> 
  <p style="margin-left:0cm;">代码：</p> 
  <pre class="has">
<code class="language-cpp">typedef long long LL;
LL C[100][100];
inline void buildC() {
    C[1][1] = C[1][0] = 1;
    C[0][0] = 1;
    for (int i = 2; i &lt; 60; i++) {
        C[i][0] = 1;
        for (int j = 1; j &lt;= i; j++) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    }
}

int main(void) {
    // build table
    buildC();
    // test for output
    printf("%10lld\n%10lld%10lld\n", C[0][0], C[1][0], C[1][1]);
    for (int i = 2; i &lt; 60; i++) {
        for (int j = 0; j &lt;= i; j++) printf("%10lld", C[i][j]);
        putchar('\n');
    }
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">纵向单项递推。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230531564.png" width="260"></p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230536919.png" width="233"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%A8%AA%E5%90%91%E9%80%92%E6%8E%A8%E5%BC%8F" style="margin-left:0cm;">横向递推式</h3> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">可用来在杨辉三角同层进行递推。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230633219.png" width="223"></p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230640352.png" width="255"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E5%AF%B9%E7%A7%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" style="margin-left:0cm;">对称表达式</h3> 
  <p style="margin-left:0cm;">描述了杨辉三角的对称性。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="49" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230700907.png" width="145"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E7%BB%84%E5%90%88%E8%81%9A%E5%90%88%E6%80%A7%E6%81%92%E7%AD%89%E5%BC%8F" style="margin-left:0cm;">组合聚合性恒等式</h2> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230716468.png" width="265"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h3>推论</h3> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230727723.png" width="184"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86">二项式定理</h2> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230741208.png" width="236"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h3>推论</h3> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051123075454.png" width="205"></p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230759574.png" width="253"></p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230803733.png" width="377"></p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230807561.png" width="456"></p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230812200.png" width="190"></p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230816798.png" width="216"></p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230823220.png" width="267"></p> 
  <p>&nbsp;</p> 
  <h2 id="%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E6%8E%92%E5%88%97%E6%95%B0">多重集合排列数</h2> 
  <h2 id="%E6%97%A0%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86">无限多重集</h2> 
  <p style="margin-left:0cm;">对于集合{∞·1, ∞·2, ……, ∞·k}，即有k种物品的无穷集合，现选取一个长度为r的排列，则排列有pow(k, r)种，其中pow(k, r)表示以k为底数、r为指数的幂。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%9C%89%E9%99%90%E5%A4%9A%E9%87%8D%E9%9B%86" style="margin-left:0cm;">有限多重集</h3> 
  <p style="margin-left:0cm;">对于集合</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230917512.png" width="184"></p> 
  <p style="margin-left:0cm;">其中n_i表示第i种元素的个数，定义n表示它们的和</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="68" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230927440.png" width="121"></p> 
  <p style="margin-left:0cm;">则排列数如下：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="45" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511230935396.png" width="163"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88%E7%BB%84%E5%90%88%E6%95%B0" style="margin-left:0cm;">多重集合组合数</h2> 
  <h3>无限多重集</h3> 
  <p style="margin-left:0cm;">无限多重集取r个的组合数的计算方法称为隔板法，问题也等价于求解下述不动方程的非负整数解组数</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511231006561.png" width="193"></p> 
  <p style="margin-left:0cm;">将不定方程映射到这个问题中，x_i就表示第i种元素选取的个数。</p> 
  <p style="margin-left:0cm;">使用隔板法求解的思路是，思考有r个1，此时想把(k – 1)个隔板放到这些1之间的间隔中，或者是开头、末尾的空白处，如：||11|11|1，(k - 1)个隔板可以将空间分割成k个区域，于是从左到右第i个区域中1的个数就表示第i种物品选取的个数，此时问题转化为r个物品1与(k – 1)个物品|的排列数，即有限多重集的排列数问题，因此组合数为：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="53" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511231018986.png" width="348"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 style="margin-left:0cm;">有限多重集</h3> 
  <p style="margin-left:0cm;">考虑集合：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511231040289.png" width="195"></p> 
  <p style="margin-left:0cm;">现选取r个元素，分两类情况。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">1.如果下述不等式成立</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511231052628.png" width="138"></p> 
  <p style="margin-left:0cm;">即每种元素的个数都不小于要选取的元素个数r，则此问题与无限多重集组合数一致，可以使用下述公式求解。</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="53" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051123110365.png" width="348"></p> 
  <p style="margin-left:0cm;">2.若至少存在一种元素的个数满足n_i &lt; r，则需要通过容斥定理或母函数求解。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
