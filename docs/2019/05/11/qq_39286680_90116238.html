<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>【ICPC模板】数论（更新中） « NotBeCN</title>
  <meta name="description" content="          &nbsp;   目录   Number Theory（数论)   扩展欧几里得   递归实现   递推实现   得到(0, mod]之间最小同余整数   得到[-mod, 0)之间最大同余整数   一元线性同余方程(Linear Congruence Equation)   多元一次不定方程...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/qq_39286680_90116238.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">【ICPC模板】数论（更新中）</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">  
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="Number%20Theory%EF%BC%88%E6%95%B0%E8%AE%BA)-toc" style="margin-left:0px;"><a href="#Number%20Theory%EF%BC%88%E6%95%B0%E8%AE%BA)" rel="nofollow">Number Theory（数论)</a></p> 
  <p id="%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97-toc" style="margin-left:40px;"><a href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97" rel="nofollow">扩展欧几里得</a></p> 
  <p id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">递归实现</a></p> 
  <p id="%E9%80%92%E6%8E%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E9%80%92%E6%8E%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">递推实现</a></p> 
  <p id="%E5%BE%97%E5%88%B0(0%2C%20mod%5D%E4%B9%8B%E9%97%B4%E6%9C%80%E5%B0%8F%E5%90%8C%E4%BD%99%E6%95%B4%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%BE%97%E5%88%B0(0%2C%20mod%5D%E4%B9%8B%E9%97%B4%E6%9C%80%E5%B0%8F%E5%90%8C%E4%BD%99%E6%95%B4%E6%95%B0" rel="nofollow">得到(0, mod]之间最小同余整数</a></p> 
  <p id="%E5%BE%97%E5%88%B0%5B-mod%2C%200)%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E5%90%8C%E4%BD%99%E6%95%B4%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%BE%97%E5%88%B0%5B-mod%2C%200)%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E5%90%8C%E4%BD%99%E6%95%B4%E6%95%B0" rel="nofollow">得到[-mod, 0)之间最大同余整数</a></p> 
  <p id="%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B(Linear%20Congruence%20Equation)-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B(Linear%20Congruence%20Equation)" rel="nofollow">一元线性同余方程(Linear Congruence Equation)</a></p> 
  <p id="%E5%A4%9A%E5%85%83%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%EF%BC%88%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B%EF%BC%89%E6%B1%82%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E5%85%83%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%EF%BC%88%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B%EF%BC%89%E6%B1%82%E8%A7%A3" rel="nofollow">多元一次不定方程（丢番图方程）求解</a></p> 
  <p id="%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%20(Chinese%20Remander%20Theorem%2C%20CRT)-toc" style="margin-left:40px;"><a href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%20(Chinese%20Remander%20Theorem%2C%20CRT)" rel="nofollow">中国剩余定理 (Chinese Remander Theorem, CRT)</a></p> 
  <p id="%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%20(%E6%89%A9%E5%B1%95CRT)-toc" style="margin-left:40px;"><a href="#%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%20(%E6%89%A9%E5%B1%95CRT)" rel="nofollow">扩展中国剩余定理 (扩展CRT)</a></p> 
  <p id="%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84" rel="nofollow">勾股数组</a></p> 
  <p id="%E6%9C%AC%E6%BA%90%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%B6%E4%B8%80%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%9C%AC%E6%BA%90%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%B6%E4%B8%80%EF%BC%89" rel="nofollow">本源勾股数组枚举方法（其一）</a></p> 
  <p id="%E6%9C%AC%E6%BA%90%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%B6%E4%BA%8C%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%9C%AC%E6%BA%90%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%B6%E4%BA%8C%EF%BC%89" rel="nofollow">本源勾股数组枚举方法（其二）</a></p> 
  <p id="%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px;"><a href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8" rel="nofollow">相关性质</a></p> 
  <p id="%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E6%95%B0%E4%B8%BA%E5%A5%87%E6%95%B0%E7%9A%84%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E6%95%B0%E4%B8%BA%E5%A5%87%E6%95%B0%E7%9A%84%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95" rel="nofollow">寻找最小数为奇数的勾股数组的快速方法</a></p> 
  <p id="%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%9D%A1%E7%9B%B4%E8%A7%92%E8%BE%B9%E6%9E%84%E9%80%A0%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%9D%A1%E7%9B%B4%E8%A7%92%E8%BE%B9%E6%9E%84%E9%80%A0%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84" rel="nofollow">已知一条直角边构造勾股数组</a></p> 
  <p id="%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%20(Le%20dernier%20th%C3%A9or%C3%A8me%20de%20Fermat)-toc" style="margin-left:40px;"><a href="#%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%20(Le%20dernier%20th%C3%A9or%C3%A8me%20de%20Fermat)" rel="nofollow">费马大定理 (Le dernier théorème de Fermat)</a></p> 
  <p id="%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%20(Fermat's%20little%20theorem)%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%20(Fermat' rel=" nofollow"s%20little%20theorem)%c2%a0">费马小定理 (Fermat's little theorem)&nbsp;</a></p> 
  <p id="%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86-toc" style="margin-left:40px;"><a href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86" rel="nofollow">欧拉定理</a></p> 
  <p id="%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86-toc" style="margin-left:40px;"><a href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86" rel="nofollow">扩展欧拉定理</a></p> 
  <p id="%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E5%87%BD%E6%95%B0" rel="nofollow">卡迈克尔函数</a></p> 
  <p id="%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E6%95%B0" rel="nofollow">卡迈克尔数</a></p> 
  <p id="%E5%8F%96%E6%A8%A1%E9%80%86%E5%85%83%EF%BC%88%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%8F%96%E6%A8%A1%E9%80%86%E5%85%83%EF%BC%88%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0%EF%BC%89" rel="nofollow">取模逆元（模反元素）</a></p> 
  <p id="%E4%BA%92%E7%B4%A0%E6%83%85%E5%BD%A2-toc" style="margin-left:80px;"><a href="#%E4%BA%92%E7%B4%A0%E6%83%85%E5%BD%A2" rel="nofollow">互素情形</a></p> 
  <p id="%E9%9D%9E%E4%BA%92%E7%B4%A0%E6%83%85%E5%BD%A2-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E4%BA%92%E7%B4%A0%E6%83%85%E5%BD%A2" rel="nofollow">非互素情形</a></p> 
  <p id="%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%E6%B3%95" rel="nofollow">欧拉线性筛素数法</a></p> 
  <p id="%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86-toc" style="margin-left:40px;"><a href="#%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86" rel="nofollow">威尔逊定理</a></p> 
  <p id="%E6%9C%80%E5%B0%8F%E8%B4%A8%E5%9B%A0%E5%AD%90-toc" style="margin-left:40px;"><a href="#%E6%9C%80%E5%B0%8F%E8%B4%A8%E5%9B%A0%E5%AD%90" rel="nofollow">最小质因子</a></p> 
  <p id="%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%89%93%E8%A1%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%89%93%E8%A1%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">欧拉线性筛打表实现</a></p> 
  <p id="Miller-Rabin%20Primality%20Test(%E7%B1%B3%E5%8B%92-%E7%BD%97%E5%AE%BE%E9%9A%8F%E6%9C%BA%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95)-toc" style="margin-left:40px;"><a href="#Miller-Rabin%20Primality%20Test(%E7%B1%B3%E5%8B%92-%E7%BD%97%E5%AE%BE%E9%9A%8F%E6%9C%BA%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95)" rel="nofollow">Miller-Rabin Primality Test(米勒-罗宾随机素性测试)</a></p> 
  <p id="%E9%9D%99%E6%80%81%E7%B4%A0%E6%95%B0%E8%AF%81%E6%8D%AE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%9D%9E%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E9%9D%99%E6%80%81%E7%B4%A0%E6%95%B0%E8%AF%81%E6%8D%AE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%9D%9E%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">静态素数证据表实现（非随机数实现）</a></p> 
  <p id="%E4%BD%BF%E7%94%A8Java%E5%A4%A7%E6%95%B0%E7%B1%BB%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8Java%E5%A4%A7%E6%95%B0%E7%B1%BB%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0" rel="nofollow">使用Java大数类判断素数</a></p> 
  <p id="%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0" rel="nofollow">欧拉函数</a></p> 
  <p id="%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%95%E6%AC%A1%E6%B1%82%E5%80%BC%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%95%E6%AC%A1%E6%B1%82%E5%80%BC%EF%BC%89" rel="nofollow">质因数分解实现（适用于单次求值）</a></p> 
  <p id="%E6%89%93%E8%A1%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E6%89%93%E8%A1%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">打表实现</a></p> 
  <p id="%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px;"><a href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">欧拉函数的性质</a></p> 
  <p id="%CF%83%E5%9B%A0%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%CF%83%E5%9B%A0%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0" rel="nofollow">σ因数和函数</a></p> 
  <p id="%E6%95%B4%E6%95%B0%E5%88%86%E6%8B%86-toc" style="margin-left:40px;"><a href="#%E6%95%B4%E6%95%B0%E5%88%86%E6%8B%86" rel="nofollow">整数分拆</a></p> 
  <p id="%E6%9D%9C%E6%95%99%E7%AD%9B-toc" style="margin-left:40px;"><a href="#%E6%9D%9C%E6%95%99%E7%AD%9B" rel="nofollow">杜教筛</a></p> 
  <p id="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-toc" style="margin-left:40px;"><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" rel="nofollow">斐波那契数列</a></p> 
  <p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
  <p id="%C2%A0%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%A7%E8%B4%A8" rel="nofollow">&nbsp;前缀和性质</a></p> 
  <p id="%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86-toc" style="margin-left:40px;"><a href="#%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86" rel="nofollow">卢卡斯定理</a></p> 
  <p id="%E6%8E%A8%E8%AE%BA-toc" style="margin-left:80px;"><a href="#%E6%8E%A8%E8%AE%BA" rel="nofollow">推论</a></p> 
  <p id="%E6%95%B4%E9%99%A4%E6%83%85%E5%BD%A2%E7%9A%84%E6%8E%A8%E8%AE%BA-toc" style="margin-left:80px;"><a href="#%E6%95%B4%E9%99%A4%E6%83%85%E5%BD%A2%E7%9A%84%E6%8E%A8%E8%AE%BA" rel="nofollow">整除情形的推论</a></p> 
  <hr id="hr-toc">
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h1 id="Number%20Theory%EF%BC%88%E6%95%B0%E8%AE%BA)" style="margin-left:0cm;">Number Theory（数论)</h1> 
  <h2 id="%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97" style="margin-left:0cm;"><br> 扩展欧几里得</h2> 
  <h3 id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" style="margin-left:0cm;"><br> 递归实现</h3> 
  <p style="margin-left:0cm;"><br> 代码较简短<br> &nbsp;</p> 
  <pre class="has">
<code class="language-cpp">// ret value which is gcd(a, b)
// x is coefficient of a
// y is coefficient of b
void ex_gcd(LL a, LL b, LL &amp;r, LL &amp;x, LL &amp;y) {
    if (!b) {r = a, x = 1, y = 0;}
    else {
        ex_gcd(b, a % b, r, y, x);
        y -= x * (a / b);
    }
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h3 id="%E9%80%92%E6%8E%A8%E5%AE%9E%E7%8E%B0">递推实现</h3> 
  <p style="margin-left:0cm;">使用这个函数可以求解形如ax + by = gcd(a, b)方程的x和y整数解。</p> 
  <p style="margin-left:0cm;">注意：这个gcd函数假设了b不为0，b如果为0会出现除以0的错误。另外，a如果为0，结果也将不正确。</p> 
  <pre class="has">
<code class="language-cpp">/* ax + by = gcd(a, b) */
/* x = xpp - q * xp */
/* y = ypp - q * yp */
/* xpp 表示 x pre pre, 即x(n - 2), 其余同理 */
LL ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y) {
    LL xp, xpp, yp, ypp;
    LL r, q;
    q = a / b, r = a % b;
    xpp = x = 0, ypp = y = 1;
    if (!r) return b;
    xp = x = 1, yp = y = -q;
    while (true) {
        a = b, b = r;
        q = a / b, r = a % b;
        if (!r) return b;
        x = xpp - xp * q;
        y = ypp - yp * q;
        xpp = xp, ypp = yp;
        xp = x, yp = y;
    }
}
</code></pre> 
  <p>&nbsp;</p> 
  <h2 id="%E5%BE%97%E5%88%B0(0%2C%20mod%5D%E4%B9%8B%E9%97%B4%E6%9C%80%E5%B0%8F%E5%90%8C%E4%BD%99%E6%95%B4%E6%95%B0">得到(0, mod]之间最小同余整数</h2> 
  <pre class="has">
<code>// 介于(0, mod]的最小模mod同余整数
template &lt;class T&gt;
T toPositive(T x, T mod) {
    x = ((x % mod) + mod) % mod;
    return x ? x : mod;
}
</code></pre> 
  <p>&nbsp;</p> 
  <h2 id="%E5%BE%97%E5%88%B0%5B-mod%2C%200)%E4%B9%8B%E9%97%B4%E6%9C%80%E5%A4%A7%E5%90%8C%E4%BD%99%E6%95%B4%E6%95%B0">得到[-mod, 0)之间最大同余整数</h2> 
  <pre class="has">
<code class="language-cpp">// 介于[-mod, 0)的最大模mod同余整数
template &lt;class T&gt;
T toNegative(T x, T mod) {
    x = ((x % mod) - mod) % mod;
    return x ? x : -mod;
}
</code></pre> 
  <p>&nbsp;</p> 
  <h2 id="%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B(Linear%20Congruence%20Equation)">一元线性同余方程(Linear Congruence Equation)</h2> 
  <p style="text-align:center;"><img alt="" class="has" height="41" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223213863.png" width="181"></p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

typedef long long LL;

/* ax + by = gcd(a, b) */
/* x = xpp - q * xp */
/* y = ypp - q * yp */
/* xpp 表示 x pre pre, 即x(n - 2), 其余同理 */
template &lt;class T&gt;
T ex_gcd(T a, T b, T &amp;x, T &amp;y) {
    T xpp, xp;
    T ypp, yp;
    T r = a % b, q = a / b;
    if (!r) {
        x = 0, y = 1;
        return b;
    }
    xpp = 0, ypp = 1;
    x = xp = 1, y = yp = -q;
    while (true) {
        a = b;
        b = r;
        q = a / b, r = a % b;
        if (!r) return b;
        x = xpp - q * xp, y = ypp - q * yp;
        xpp = xp, ypp = yp;
        xp = x, yp = y;
    }
}

// 介于(0, mod]的最小模mod同余整数
template &lt;class T&gt;
T toPositive(T x, T mod) {
    x = ((x % mod) + mod) % mod;
    return x ? x : mod;
}

// 介于[-mod, 0)的最大模mod同余整数
template &lt;class T&gt;
T toNegative(T x, T mod) {
    x = ((x % mod) - mod) % mod;
    return x ? x : -mod;
}

// EVERY表示任意值都是解, NIL表示无解
enum {EVERY = -2, NIL = -1};
// 求解形如ax = b (mod c)的Linear Congruence Equaltion(线性同余方程)
// 使用ex_gcd求解ax + cy = b
LL linearCongruence(LL a, LL b, LL c) {
    a = toPositive(a, c) % c;
    b = toPositive(b, c) % c;
    // if (!a &amp;&amp; !b) return EVERY;
    if ((!a &amp;&amp; b) || !c) return NIL;
    // else if (a &amp;&amp; !b) return 0;
    // 当a小于0时, 将符号交给x, 此时xnf为真
    // 表示x Negative Flag
    bool xnf = false, ynf = false;
    if (a &lt; 0) xnf = true, a = -a;
    if (c &lt; 0) ynf = true, c = -c;
    b = toPositive(b, c);
    // g = gcd(a, c)
    LL x, y, g;
    g = ex_gcd(a, c, x, y);
    if (b % g) return NIL;
    if (xnf) {
        x = toNegative(x, c / g);
        x = -x;
    } else {
        x = toPositive(x, c / g);
    }
    // b此时一定能被g整除
    // 括号在一定程度上防止因为极端数据导致溢出
    // 对c取模得到[0, c / g - 1]之间解，即最小正数解
    return x * (b / g) % (c / g);
}
</code></pre> 
  <p>依赖：<br> &nbsp;&nbsp; &nbsp;-扩展欧几里得<br> &nbsp;&nbsp; &nbsp;-得到(0, mod]之间最小同余整数<br> &nbsp;&nbsp; &nbsp;-得到[-mod, 0)之间最大同余整数</p> 
  <p>&nbsp;</p> 
  <h2 id="%E5%A4%9A%E5%85%83%E4%B8%80%E6%AC%A1%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B%EF%BC%88%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B%EF%BC%89%E6%B1%82%E8%A7%A3">多元一次不定方程（丢番图方程）求解</h2> 
  <p>核心：<br> 首先移项，左边仅剩下ax + by，使用扩展欧几里得求解x和y，其右侧值应当满足能够整除gcd(a, b)，接着用扩展gcd求解gcd(a, b)和c的参数，c的参数z将作为中间过程的答案，而gcd(a, b)的倍数将用来给前面求过的所有结果翻倍，以此类推。<br> 方程有解当且仅当右侧常数c能够整除gcd(a, b, c, d……)。<br> 代码：</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

typedef long long LL;

int ex_gcd(int a, int b, int &amp;x, int &amp;y) {
    int xp, xpp, yp, ypp;
    int r, q;
    q = a / b, r = a % b;
    xpp = x = 0, ypp = y = 1;
    if (!r) return b;
    xp = x = 1, yp = y = -q;
    while (true) {
        a = b, b = r;
        q = a / b, r = a % b;
        if (!r) return b;
        x = xpp - xp * q;
        y = ypp - yp * q;
        xpp = xp, ypp = yp;
        xp = x, yp = y;
    }
}

// 返回false表示无解
// 当所有元素的gcd无法整除常数c时，方程无整数解
const int LIM = 1e6 + 10;
int multi[LIM], ans[LIM], coefficient[LIM];
bool indeterEqualtion(int *coefficient, int *ans, int len, int c) {
    if (len == 1) {
        if (c % coefficient[0]) return false;
        ans[0] = c / coefficient[0];
        return true;
    }
    // init
    int g = ex_gcd(coefficient[0], coefficient[1], ans[0], ans[1]);
    for (int i = 2; i &lt; len; i++)
        g = ex_gcd(g, coefficient[i], multi[i - 1], ans[i]);
    if (c % g) return false;
    int sufmul = 1;
    for (int i = len - 2; i; i--)
        sufmul *= multi[i], ans[i] *= sufmul;
    ans[0] *= sufmul;
    return true;
}

int main(void) {
    ios::sync_with_stdio(false);
    coefficient[0] = 155;
    coefficient[1] = 341;
    coefficient[2] = 385;
    indeterEqualtion(coefficient, ans, 3, 1);
    for (int i = 0; i &lt; 3; i++) {
        if (i) cout &lt;&lt; ' ';
        cout &lt;&lt; ans[i];
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <h2 id="%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%20(Chinese%20Remander%20Theorem%2C%20CRT)">中国剩余定理 (Chinese Remander Theorem, CRT)</h2> 
  <p>中国剩余定理描述的是一种求解一元线性方程同余组的方法，形如下图：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="111" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223403396.png" width="227"></p> 
  <p style="margin-left:0cm;">使用这一方法有一个前提是：对于任意两个模数m[i]和m[j]（注：此处[]中的内容表示下标），应有gcd(m[i], m[j]) = 1，即二者互素。</p> 
  <p style="margin-left:0cm;">中国剩余定理的核心是“构造”，它给出了一种构造此类方程组解的方法。</p> 
  <p style="margin-left:0cm;">令M表示全体模数m[i]的乘积，用M[i]表示全体模数的乘积M除以m[i]的值（即除了第i个模数m[i]之外所有模数的乘积）。接着令t[i]表示M[i]对m[i]取模的逆元，此时有t[i] * M[i]模除m[i]后余数为1.</p> 
  <p style="margin-left:0cm;">接着，使用a[i]乘上t[i] * M[i]，得到的结果(即a[i] * t[i] * M[i])具有这样的性质：如果将它对m[i]取余，则因为t[i] * M[i]对m[i]取余是1，因此a[i] * t[i] * M[i]对m[i]取余得到a[i]；如果将它对排除m[i]之外任意一个模数（后面用m[j]表示）取模，因为M[i]表示排除m[i]之后所有模数的乘积，可知m[j]是M[i]的因数，那么m[j]就可以整除a[i]*t[i]*M[i]，余数为0.</p> 
  <p style="margin-left:0cm;">根据这样的性质，将所有的a[i] * t[i] * M[i]加和就得到这个方程组的一个解，实际上它加减任意个M都是这个方程组的解。</p> 
  <p style="margin-left:0cm;">解的通式符号表示如下：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="40" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223420533.png" width="378"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%20(%E6%89%A9%E5%B1%95CRT)">扩展中国剩余定理 (扩展CRT)</h2> 
  <p>扩展CRT问题与一般CRT问题相同，可以理解为是CRT问题的一种更加通用的解法。<br> 相较于一般的中国剩余定理，它可以用来解决模数之间不互质的情况，同时仍然可以解决互质的情况。需要使用扩展欧几里得方法。<br> 整体方法是合并，将多个同余式合并，直到最后只剩下一个，进行求解。<br> 对于两个同余式：<br><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223453804.png" width="151"></p> 
  <p><img alt="" class="has" height="23" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223459858.png" width="151"></p> 
  <p style="margin-left:0cm;">写成等式的形式，并进行联立：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="38" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223514457.png" width="235"></p> 
  <p style="margin-left:0cm;">移项得到①式：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="36" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223525249.png" width="244"></p> 
  <p style="margin-left:0cm;">当且仅当：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="33" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051122353561.png" width="228"></p> 
  <p style="margin-left:0cm;">成立时方程有整数解k1与k2，这将作为判断不定方程组是否有解的条件。</p> 
  <p style="margin-left:0cm;">在有解的情况下，可以将①式整理成：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223548535.png" width="233"></p> 
  <p style="margin-left:0cm;">其中g = gcd(m1, m2)</p> 
  <p style="margin-left:0cm;">这等价于：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223602870.png" width="272"></p> 
  <p style="margin-left:0cm;">令I(a, b)表示a在模b运算下的逆元。</p> 
  <p style="margin-left:0cm;">则上式左右同乘m1/g的逆元可以得到：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223614441.png" width="351"></p> 
  <p style="margin-left:0cm;">将上式带回到最初的x = a1 + m1k1中，消去k1可得到：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="53" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223624852.png" width="497"></p> 
  <p style="margin-left:0cm;">多次使用此式，将不定方程组全部方程合并，得到的最终方程使用扩展欧几里得方法求解。</p> 
  <p style="margin-left:0cm;">要注意在数据较大时long long也存在溢出可能。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84">勾股数组</h2> 
  <h3 id="%E6%9C%AC%E6%BA%90%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%B6%E4%B8%80%EF%BC%89"><br> 本源勾股数组枚举方法（其一）</h3> 
  <p><br> 取n &lt; m且满足(n &amp; 1) ^ (m &amp; 1)为1（这里的^为异或，此表达式说明二者奇偶不同），同时gcd(n, m) = 1（即二者互素），则可得到满足sqr(a) + sqr(b) = sqr(c)（其中sqr()表示平方）的勾股数组：<br> &nbsp;&nbsp; &nbsp;a = sqr(m) – sqr(n)<br> &nbsp;&nbsp; &nbsp;b = 2nm<br> &nbsp;&nbsp; &nbsp;c = sqr(m) + sqr(n)<br> 如果按照顺序枚举满足上述条件（奇偶不同的互素n &lt; m二元组（n, m）），就可以得到所有的本源勾股数组，同时它们的整数倍也是勾股数组。这个方法可以取得所有的勾股数组。</p> 
  <h3 id="%E6%9C%AC%E6%BA%90%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E6%9E%9A%E4%B8%BE%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%B6%E4%BA%8C%EF%BC%89"><br> 本源勾股数组枚举方法（其二）</h3> 
  <p><br> 对于每个满足sq(a) + sq(b) = sq(c)的本源勾股数组(a, b, c)（其中a为奇数，b为偶数），可以取两个互质奇数s, t(s &gt; t &gt; 0)，则：<br> a = st, b = (sq(s) – sq(t)) / 2, c = (sq(s) + sq(t)) / 2.</p> 
  <h3 id="%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8"><br> 相关性质</h3> 
  <p><br> gcd(a, b) = gcd(a, c) = gcd(b, c) = gcd(a, b, c)</p> 
  <p>对于任何大于1的正整数x，sqr(x) + 1, sqr(x) – 1以及2x一定构成勾股数组。</p> 
  <h3 id="%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F%E6%95%B0%E4%B8%BA%E5%A5%87%E6%95%B0%E7%9A%84%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95"><br> 寻找最小数为奇数的勾股数组的快速方法</h3> 
  <p><br> 任取大于3的奇数a，平方后，除以2取结果向下取整得到b，向上取整得到c，这三个数a, b, c必然构成勾股数组，且保证最小数a为奇数，但是不一定是本源勾股数组。</p> 
  <h3 id="%E5%B7%B2%E7%9F%A5%E4%B8%80%E6%9D%A1%E7%9B%B4%E8%A7%92%E8%BE%B9%E6%9E%84%E9%80%A0%E5%8B%BE%E8%82%A1%E6%95%B0%E7%BB%84"><br> 已知一条直角边构造勾股数组</h3> 
  <p><br> 对于勾股数组sq(a) + sq(b) = sq(c)，如果已知a，则：<br> 若a是奇数(a = 2n + 1), b = 2sq(n) + 2n, c = 2sq(n) + 2n + 1.<br> 若a是偶数(a = 2n且大于等于4), b = sq(n) – 1, c = sq(n) + 1.<br> &nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%20(Le%20dernier%20th%C3%A9or%C3%A8me%20de%20Fermat)">费马大定理 (Le dernier théorème de Fermat)</h2> 
  <p><br> 也叫做费马最后定理 (Fermat's Last Theorem)，这一定理说对于n &gt; 2的情况，下面的不定方程没有整数解。<br> &nbsp;</p> 
  <p style="text-align:center;"><img alt="" class="has" height="26" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223748647.png" width="113"></p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%20(Fermat's%20little%20theorem)%C2%A0">费马小定理 (Fermat's little theorem)&nbsp;</h2> 
  <p style="margin-left:0cm;">对于素数p，有下图所示同余式成立：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="29" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223828677.png" width="151"></p> 
  <p>&nbsp;更多情况下，写作下面的等价形式：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="27" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051122384474.png" width="151"></p> 
  <p style="margin-left:0cm;">注意：费马小定理的逆命题为假，也就是说，满足上式的数p不一定是素数，这样的合数被称为伪素数，因此不能使用这个定理来判定素性。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86" style="margin-left:0cm;">欧拉定理</h2> 
  <p>&nbsp;费马小定理是欧拉定理的一个特殊情况，欧拉定理如下：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="33" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511223941250.png" width="189"></p> 
  <p>其中φ(n)是n的欧拉函数值，表示小于n的正整数中满足gcd(n, x) = 1的数x的个数，可以理解为小于n且与n互素的整数的个数，需要特别注意整数1也满足与n的最大公约数为1的条件，因此它也被计数在内。</p> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">扩展欧拉定理</h2> 
  <p>如下图所示，一般用来优化模幂运算，减少运算次数。</p> 
  <p style="text-align:center;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224031970.png" width="151"></p> 
  <p>&nbsp;</p> 
  <h2 id="%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E5%87%BD%E6%95%B0">卡迈克尔函数</h2> 
  <p style="margin-left:0cm;">定义函数λ(n)为：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="41" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224100645.png" width="454"></p> 
  <p style="margin-left:0cm;">当n为1, 2, 4或奇质数的幂、或奇质数的幂的二倍时，这一函数的函数值等于n的欧拉函数值；当n为2、4之外的2的幂时，这一函数的函数值等于n的欧拉函数值的一半。</p> 
  <p style="margin-left:0cm;">这一函数满足：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="36" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224112229.png" width="189"></p> 
  <p style="margin-left:0cm;">欧拉定理与费马小定理都是此式的特殊情况。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E6%95%B0" style="margin-left:0cm;">卡迈克尔数</h2> 
  <p style="margin-left:0cm;">卡迈克尔数都是伪素数，最小的卡迈克尔数是561。</p> 
  <p style="margin-left:0cm;">它满足费马小定理所提出的同余式，但是它不是素数。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E5%8F%96%E6%A8%A1%E9%80%86%E5%85%83%EF%BC%88%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0%EF%BC%89" style="margin-left:0cm;">取模逆元（模反元素）</h2> 
  <h3 id="%E4%BA%92%E7%B4%A0%E6%83%85%E5%BD%A2">互素情形</h3> 
  <p style="margin-left:0cm;">抽象代数中的逆元指的是，对于现有的一个集合S以及定义在其上的二元运算R，任意元素与其逆元进行这个运算后可以得到单位元。</p> 
  <p style="margin-left:0cm;">取模逆元的条件定义在同余式的乘法下，即对于两个整数a和b，如果有：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="39" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224256617.png" width="252"></p> 
  <p style="margin-left:0cm;">则将b称作a的逆元，同时a也是b的逆元。</p> 
  <p style="margin-left:0cm;">取模逆元常常用在计算取模表达式时有除法的情况，因为取模运算对除法不具有分配律，对于形如(u / v) % n的情形，考虑到u / v等价于u * (1 / v)，即u * v^-1【备注：此处的^表示幂次】，显然有v * v^-1 = 1，且在同余式的情况下仍然成立，那么可以预先计算v模除n的逆元，在需要除以v时乘上v的模n逆元。</p> 
  <p style="margin-left:0cm;">计算一个数的取模逆元需要用到费马小定理（当模除的数为素数时）或欧拉定理（题目中通常模除的数会是1e9 + 7这个素数，因此可以使用费马小定理来计算取模逆元）。</p> 
  <p style="margin-left:0cm;">计算方法：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="40" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224307754.png" width="220"></p> 
  <p style="margin-left:0cm;">其中p是素数。</p> 
  <p style="margin-left:0cm;">原理是：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="31" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224320447.png" width="189"></p> 
  <p style="margin-left:0cm;">第二个同余号部分使用了费马小定理。</p> 
  <p style="margin-left:0cm;">如果p不是素数，则需要使用欧拉定理，将p – 1替换成φ(p)。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E9%9D%9E%E4%BA%92%E7%B4%A0%E6%83%85%E5%BD%A2" style="margin-left:0cm;">非互素情形</h3> 
  <p style="margin-left:0cm;">对于将逆元用在代替除法的情景下， 可以对模数p进行质因数分解，之后将需要取逆元的数的所有与p相同的因子分离出来，并且记录个数，剩下的与p互质的部分求取逆元，使用时分两步，逆元部分直接乘，分离出的公因子部分做减法（分子上这个公因子的个数减去分母上的个数），之后用快速模幂法，将结果乘回去。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0%E6%B3%95" style="margin-left:0cm;">欧拉线性筛素数法</h3> 
  <p style="margin-left:0cm;">时间复杂度O(n)，生成的素数紧密存放在prime数组中，primepos是它的元素个数。</p> 
  <p style="margin-left:0cm;">注意：if(!(i % prime[j]))保证每个数仅被其最小的质因数筛去，并且保证j不会超过当前已找出的素数的个数。</p> 
  <pre class="has">
<code class="language-cpp">const int LIM = 1e5 + 10;       /* The limit of number to be test */
int prime[LIM / 3];
bool notPrime[LIM];
int primepos;
void eulerLinearMethod() {
    int tmp = 0;
    memset(notPrime, false, sizeof notPrime);
    primepos = 0;
    for (int i = 2; i &lt; LIM; i++) {
        if (!notPrime[i]) prime[primepos++] = i;
        for (int j = 0; (tmp = i * prime[j]) &lt; LIM; j++) {
            notPrime[tmp] = true;
            if (!(i % prime[j])) break;
        }
    }
}
</code></pre> 
  <p style="margin-left:0cm;">Time Complexity: O(n)</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86" style="margin-left:0cm;">威尔逊定理</h2> 
  <p style="margin-left:0cm;">若p是素数，则(p – 1)!与p – 1即-1模除p同余。等价的说法是：如果p是素数，则(p – 1)! + 1能被p整除。值得注意的一点是，这个定理的逆命题，即如果对于一个数x，满足条件(x – 1)! + 1可以被x整除，那么x是素数。</p> 
  <p style="margin-left:0cm;">综上，威尔逊定理给出了判定一个数是否是素数的充要条件，但是因为阶乘函数值的增长非常快，所以使用这个定理来判断一个数的素性会比较低效。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E6%9C%80%E5%B0%8F%E8%B4%A8%E5%9B%A0%E5%AD%90" style="margin-left:0cm;">最小质因子</h2> 
  <h3 id="%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%89%93%E8%A1%A8%E5%AE%9E%E7%8E%B0">欧拉线性筛打表实现</h3> 
  <p style="margin-left:0cm;">原理：欧拉线性筛素数法，每个数仅使用其最小素因数筛去。</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

inline int mini(int a, int b) {return a &lt; b ? a : b;}

// 使用欧拉线性筛打最小质因子表
const int LIM = 1e6 + 10;       /* The limit of number to be test */
int prime[LIM / 3];
int miniFactor[LIM];
int primepos;
void euler() {
    int tmp;
    for (int i = 2; i &lt; LIM; i++) {
        if (!miniFactor[i]) prime[primepos++] = i, miniFactor[i] = i;
        for (int j = 0; (tmp = i * prime[j]) &lt; LIM; j++) {
            miniFactor[tmp] = prime[j];
            if (!(i % prime[j])) break;
        }
    }
}

// test program
int main(void) {
    euler();
    for (int i = 1; i &lt;= 10; i++) {
        printf("the mini factor of %d is %d\n", i, miniFactor[i]);
    }
    printf("the mini factor of 47 is %d\n", miniFactor[47]);
    printf("the mini factor of 61 is %d\n", miniFactor[61]);
    printf("the mini factor of 561 is %d\n", miniFactor[561]);

    return 0;
}
</code></pre> 
  <p>Time Comlexity: O(n)</p> 
  <p>&nbsp;</p> 
  <h2 id="Miller-Rabin%20Primality%20Test(%E7%B1%B3%E5%8B%92-%E7%BD%97%E5%AE%BE%E9%9A%8F%E6%9C%BA%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95)">Miller-Rabin Primality Test(米勒-罗宾随机素性测试)</h2> 
  <h3 id="%E9%9D%99%E6%80%81%E7%B4%A0%E6%95%B0%E8%AF%81%E6%8D%AE%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%9D%9E%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AE%9E%E7%8E%B0%EF%BC%89">静态素数证据表实现（非随机数实现）</h3> 
  <p style="margin-left:0cm;">函数MillerRabin(LL n, LL a)为一次米勒-罗宾测试结果，true表示测试数n有3/4的把握为素数，false表示n一定是合数。</p> 
  <p style="margin-left:0cm;">调用bool isPrime(LL n)来判断数n是否为素数。</p> 
  <p style="margin-left:0cm;">bool isPrime(LL n)中的素数表可根据需要增加或减少，增加素数表会使测试的准确率升高，但是测试时间会增长。</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

typedef long long LL;

LL fastPowMod(LL base, LL p, LL mod) {
    LL ret = 1;
    base %= mod;
    do {
        if (p &amp; 1) ret = ret * base % mod;
        base = base * base % mod;
    } while (p &gt;&gt;= 1);
    return ret;
}

// true: prime a is evidence of "n is prime"
bool MillerRabin(LL n, LL a) {
    if (n == 2 || n == a) return true;
    if (!(n &amp; 1)) return false;
    LL q = n - 1, cnt = 0;
    while (!(q &amp; 1)) q &gt;&gt;= 1, cnt++;
    LL tmp = fastPowMod(a, q, n);
    if (tmp == 1) return true;
    for (LL i = 0; i &lt; cnt; i++, tmp = tmp * tmp % n)
        if (tmp == n - 1) return true;
    return false;
}

bool isPrime(LL n) {
    if (n &lt; 2) return false;
    else if (n == 2) return true;
    LL p[] = {2, 3, 13, 61, 127, 4013, 9973};
    for (LL i = 0; i &lt; 7; i++)
        if (!MillerRabin(n, p[i])) return false;
    return true;
}

int main(void) {
    for (LL i = 1; i &lt;= 100; i++) {
        cout &lt;&lt; i &lt;&lt; " is Prime ? " &lt;&lt; (isPrime(i) ? "YES" : "NO") &lt;&lt; "\n";
    }
    // 561是合数，是一个卡米歇尔数（强伪素数）
    cout &lt;&lt; 561 &lt;&lt; " is Prime ? " &lt;&lt; (isPrime(561) ? "YES" : "NO") &lt;&lt; "\n";
    return 0;
}
</code></pre> 
  <p>Time Complexity: O(log n)</p> 
  <p style="margin-left:0cm;">依赖：</p> 
  <p style="margin-left:0cm;">-整数快速模幂（逐次平方法）</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E4%BD%BF%E7%94%A8Java%E5%A4%A7%E6%95%B0%E7%B1%BB%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0" style="margin-left:0cm;">使用Java大数类判断素数</h3> 
  <p style="margin-left:0cm;">使用BigInteger类的isProbablePrime方法可以进行素性测试。</p> 
  <table border="1" cellspacing="0">
   <tbody>
    <tr>
     <td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">public boolean isProbablePrime(int certainty)</p> </td> 
    </tr>
   </tbody>
  </table>
  <p style="margin-left:0cm;">其中certainly表示确信程度，如果返回false，可以断言这个数不是素数，而如果返回true，这个数将有(1 – 1 / 2^certainly)的概率可能是素数，这个参数将会影响此方法所占用的时间。</p> 
  <p style="margin-left:0cm;">生成可能素数的方法：</p> 
  <table border="1" cellspacing="0">
   <tbody>
    <tr>
     <td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">public static BigInteger probablePrime(int bitLength, Random rnd)</p> </td> 
    </tr>
   </tbody>
  </table>
  <p style="margin-left:0cm;">其中bitlength表示生成素数的二进制位数上限，应当不小于2，Random用来生成随机数来进行素性测试。</p> 
  <p style="margin-left:0cm;">寻找下一个素数的方法：</p> 
  <table border="1" cellspacing="0">
   <tbody>
    <tr>
     <td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">public BigInteger nextProbablePrime()</p> </td> 
    </tr>
   </tbody>
  </table>
  <p style="margin-left:0cm;">此方法保证寻找到的下一个素数与当前素数之间不存在其它任何素数。</p> 
  <p style="margin-left:0cm;">示例程序：</p> 
  <pre class="has">
<code class="language-java">import java.math.BigInteger;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        BigInteger tmp = new BigInteger("1000000007");
        System.out.println(tmp.isProbablePrime(5) ? "Yes" : "No");
        BigInteger prime = BigInteger.probablePrime(5, new Random());
        System.out.println(prime);
        System.out.println("next is: " + prime.nextProbablePrime());
    }
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</h2> 
  <h3 id="%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%95%E6%AC%A1%E6%B1%82%E5%80%BC%EF%BC%89">质因数分解实现（适用于单次求值）</h3> 
  <p style="text-align:center;"><img alt="" class="has" height="38" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224736684.png" width="86"></p> 
  <p style="margin-left:0cm;">含义：小于n且与n互素的正整数个数。</p> 
  <p style="margin-left:0cm;">积性：如果gcd(n, m) = 1，则</p> 
  <p style="text-align:center;"><img alt="" class="has" height="49" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224752209.png" width="231"></p> 
  <p>求值公式：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="44" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224803901.png" width="370"></p> 
  <p>特别地：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="39" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224820756.png" width="136"></p> 
  <p style="margin-left:0cm;">注意：此实现需要提前调用euler()筛素数函数</p> 
  <p>代码：</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

typedef long long LL;

// 欧拉线性筛素数
const int LIM = 1e6 + 10;       /* The limit of number to be test */
int prime[LIM / 3];
bool notPrime[LIM];
int primepos;
void euler() {
    int tmp = 0;
    memset(notPrime, false, sizeof notPrime);
    primepos = 0;
    for (int i = 2; i &lt; LIM; i++) {
        if (!notPrime[i]) prime[primepos++] = i;
        for (int j = 0; j &lt; primepos &amp;&amp; (tmp = i * prime[j]) &lt; LIM; j++) {
            notPrime[tmp] = true;
            if (!(i % prime[j])) break;
        }
    }
}

LL fastPow(LL base, LL p) {
    LL ret = 1;
    do {
        if (p &amp; 1) ret = ret * base;
        base = base * base;
    } while (p &gt;&gt;= 1);
    return ret;
}

// 欧拉函数
int phi(int n) {
    int ret = 1;
    for (int i = 0; i &lt; primepos &amp;&amp; n; i++) {
        int cnt = 0;
        while (!(n % prime[i])) n /= prime[i], cnt++;
        if (cnt) ret *= fastPow(prime[i], cnt - 1) * (prime[i] - 1);
    }
    return ret;
}

int main(void) {
    euler();
    for (int i = 1; i &lt;= 10; i++) {
        printf("phi(%d) = %d\n", i, phi(i));
    }
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">下面是更简便且时间复杂度为O(sqrt(n))的方法：</p> 
  <pre class="has">
<code class="language-cpp">LL phi(LL n) {
    LL ret = 1;
    for (LL i = 2; i * i &lt;= n; i++) {
        if (!(n % i)) {
            ret *= i - 1;
            n /= i;
            while (!(n % i))
                ret *= i, n /= i;
        }
    }
    if (n ^ 1) ret *= (n - 1);
    return ret;
}
</code></pre> 
  <p style="margin-left:0cm;">Time Complexity: O(Sqrt(n))</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%89%93%E8%A1%A8%E5%AE%9E%E7%8E%B0" style="margin-left:0cm;">打表实现</h3> 
  <p style="margin-left:0cm;">递推性质：</p> 
  <p style="margin-left:0cm;">我们假设对于每个数n，它的最小质因子是p，接下来的递推分两类讨论，</p> 
  <p style="margin-left:0cm;">如果</p> 
  <p style="text-align:center;"><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051122493454.png" width="66"></p> 
  <p>则</p> 
  <p style="text-align:center;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511224948141.png" width="147"></p> 
  <p>&nbsp;如果</p> 
  <p style="text-align:center;"><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225003702.png" width="65"></p> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">则</p> 
  <p style="text-align:center;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225019598.png" width="280"></p> 
  <p style="margin-left:0cm;">简单证明：</p> 
  <p style="margin-left:0cm;">对于一个数m，可以将其某个质因子拆出来，如下：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051122504526.png" width="93"></p> 
  <p>则如果p | m，即k不等于0，那么有：</p> 
  <p><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225103915.png" width="280"></p> 
  <p><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019051122510863.png" width="276"></p> 
  <p><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225120209.png" width="145"></p> 
  <p><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225125720.png" width="132"></p> 
  <p style="margin-left:0cm;">如果k等于0，则m中不含有因子p，显然gcd(m, p) = 1，则可直接使用欧拉函数的积性公式：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="28" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225135973.png" width="179"></p> 
  <p style="margin-left:0cm;">令n = m * p即得到上述递推式。</p> 
  <p style="margin-left:0cm;">证毕。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">如果取n的最小质因子p，则可以通过筛素数打表来找到每个数n的p，这一点十分便于实现，于是我们取p为n的最小质因子。</p> 
  <p style="margin-left:0cm;">代码：</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

inline int mini(int a, int b) {return a &lt; b ? a : b;}

// 使用欧拉线性筛打最小质因子表
const int LIM = 1e6 + 10;       /* The limit of number to be test */
int prime[LIM / 3];
int miniFactor[LIM];
int primepos;
void euler() {
    int tmp;
    for (int i = 2; i &lt; LIM; i++) {
        if (!miniFactor[i]) prime[primepos++] = i, miniFactor[i] = i;
        for (int j = 0; j &lt; primepos &amp;&amp; (tmp = i * prime[j]) &lt; LIM; j++) {
            miniFactor[tmp] = mini(prime[j], miniFactor[i]);
            if (!(i % prime[j])) break;
        }
    }
}

int phi[LIM];
void phiTable() {
    phi[1] = 1;
    for (int i = 2; i &lt; LIM; i++) {
        phi[i] = phi[i / miniFactor[i]]
            * ((i / miniFactor[i]) % miniFactor[i] ? miniFactor[i] - 1 : miniFactor[i]);
    }
}

int main(void) {
    // mini factor test
    euler();
    for (int i = 1; i &lt;= 10; i++) {
        printf("the mini factor of %d is %d\n", i, miniFactor[i]);
    }
    printf("the mini factor of 47 is %d\n", miniFactor[47]);
    printf("the mini factor of 61 is %d\n", miniFactor[61]);
    printf("the mini factor of 561 is %d\n", miniFactor[561]);

    // phi table test
    phiTable();
    for (int i = 1; i &lt;= 10; i++) {
        printf("phi(%d) = %d\n", i, phi[i]);
    }
    for (int i = 1; i &lt; LIM; i++)
        if (phi[i] &lt;= 0) printf("Overflow at %d\n", i);
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">Time Complexity: O(n)</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">上面的方法实际上复杂度为2n，因为预先打出了一个最大素因子表，但是实际上可以直接将欧拉函数打表与素数筛选操作合并，如下。</p> 
  <p style="margin-left:0cm;">直接打表：</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int LIM = 1e6 + 10;
int pricur = 0;
int prime[LIM / 3];
int phi[LIM];
void build_phi() {
    int tmp;
    phi[1] = 1;
    for (int i = 2; i &lt; LIM; i++) {
        if (!phi[i]) {
            phi[i] = i - 1;
            prime[pricur++] = i;
        }
        for (int j = 0; (tmp = i * prime[j]) &lt; LIM; j++) {
            if (i % prime[j]) {
                phi[tmp] = phi[i] * (prime[j] - 1);
            } else {
                phi[tmp] = phi[i] * prime[j];
                break;
            }
        }
    }
}

int main(void) {
    build_phi();
    for (int i = 1; i &lt; 100; i++) {
        printf("[%d] : %d\n", i, phi[i]);
    }
    return 0;
}
</code></pre> 
  <p style="margin-left:0cm;">Time Comlexity: O(n)</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8" style="margin-left:0cm;">欧拉函数的性质</h3> 
  <p>偶数性质</p> 
  <p style="margin-left:0cm;">除了1和2的欧拉函数值为1外，其余正整数的欧拉函数值均为偶数，因为对于数a如果满足a &lt; n且gcd(a, n) = 1，即a与n互质，那么一定有gcd(n – a, n) = 1成立，那么对于小于n的与n互质的正整数，总是可以用n减去它找到另外一个与n互质的正整数，如果担心n – a = a是否会导致上面的规律被破坏，可以特别考虑一下，因为唯一一个满足n – x = x的数x是当n为偶数时的n / 2，但是显然这个数不与n互质，有gcd(n / 2, n) = n / 2。因此上面的规律可以确定存在。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%CF%83%E5%9B%A0%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0" style="margin-left:0cm;">σ因数和函数</h2> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">含义：σ(n)表示从1到n（包含）的所有n 的因数之和。</p> 
  <p style="margin-left:0cm;">积性：如果gcd(n, m) = 1，有σ(nm) = σ(n) * σ(m)</p> 
  <p style="margin-left:0cm;">求值公式：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="76" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225319896.png" width="367"></p> 
  <p style="margin-left:0cm;">特别地：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="60" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225331882.png" width="174"></p> 
  <p style="margin-left:0cm;">代码：</p> 
  <pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int LIM = 1e7;
int prime[LIM];
int pos;
bool notPrime[LIM];

void Euler() {
    for (int i = 2; i &lt; LIM; i++) {
        if (!notPrime[i]) prime[pos++] = i;
        for (int j = 0; j &lt; pos; j++) {
            int tmp = prime[j] * i;
            if (tmp &gt;= LIM || tmp &lt; 0) break;
            notPrime[tmp] = true;
        }
    }
}

int fastPow(int b, int p) {
    int ret = 1;
    while (p) {
        if (p &amp; 1) ret *= b;
        b *= b;
        p &gt;&gt;= 1;
    }
    return ret;
}

// sigma因数和函数
int sigma(int n) {
    int ret = 1;
    for (int i = 0; i &lt; pos &amp;&amp; n &gt; 1; i++) {
        int cnt = 0;
        while (!(n % prime[i])) n /= prime[i], cnt++;
        if (cnt) ret *= (fastPow(prime[i], cnt + 1) - 1) / (prime[i] - 1);
    }
    return ret;
}

int main(void) {
    Euler();
    int t, n;
    scanf("%d", &amp;t);
    while (t--) {
        scanf("%d", &amp;n);
        printf("%d\n", sigma(n) - n);
    }
    return 0;
}
</code></pre> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <p style="margin-left:0cm;">依赖：</p> 
  <p style="margin-left:0cm;">-欧拉线性筛素数函数</p> 
  <p style="margin-left:0cm;">-快速幂（逐次平方法）函数</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E6%95%B4%E6%95%B0%E5%88%86%E6%8B%86" style="margin-left:0cm;">整数分拆</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E6%9D%9C%E6%95%99%E7%AD%9B">杜教筛</h2> 
  <p>&nbsp;</p> 
  <p>&nbsp;</p> 
  <h2 id="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</h2> 
  <h3 id="%E5%AE%9A%E4%B9%89">定义</h3> 
  <p style="text-align:center;"><img alt="" class="has" height="76" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225443338.png" width="211"></p> 
  <p>&nbsp;</p> 
  <h3 id="%C2%A0%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%A7%E8%B4%A8">&nbsp;前缀和性质</h3> 
  <p style="margin-left:0cm;">前缀和定义：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="49" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225518175.png" width="184"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">性质：</p> 
  <p style="text-align:center;"><img alt="" class="has" height="38" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225528380.png" width="117"></p> 
  <p style="margin-left:0cm;">证明使用数学归纳法，对于i = 0，有F(2) = 1, S(0) = 0成立。</p> 
  <p style="margin-left:0cm;">假设对于k，有S(k) = F(k + 2) – 1成立。</p> 
  <p style="margin-left:0cm;">对于k + 1，有S(k + 1) = S(k) + F(k + 1) = F(k + 2) + F(k + 1) – 1 = F(k + 3) – 1 = F((k + 1) + 2) - 1成立。</p> 
  <p style="margin-left:0cm;">证毕。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h2 id="%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86" style="margin-left:0cm;">卢卡斯定理</h2> 
  <p style="margin-left:0cm;">用于求解二项式系数在模除素数p后的值的一种快速方法。</p> 
  <p style="margin-left:0cm;">注意：模数必要是素数。</p> 
  <p style="margin-left:0cm;">对于二项式系数(n, m) % p的值，可等价转化为对n和m进行p进制分解，之后对n和m在p进制下的每一位数求解二项式系数(n[i], m[i])，其中n[i]表示n在p进制下第i位的数，m[i]同理，将这些二项式系数连乘并对p取余，即可得到所要求的(n, m) % p。</p> 
  <p style="margin-left:0cm;">数学表示：</p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225602262.png" width="212"></p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">其中：<img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225611687.png" width="179"></p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225618327.png" width="224"></p> 
  <p style="margin-left:0cm;"><img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225623216.png" width="280"></p> 
  <p>&nbsp;特别规定，不合理情况的二项式系数为0：</p> 
  <p><img alt="" class="has" height="57" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190511225636184.png" width="205"></p> 
  <p>&nbsp;</p> 
  <h3 id="%E6%8E%A8%E8%AE%BA">推论</h3> 
  <p>整除情形</p> 
  <p style="margin-left:0cm;">概述：</p> 
  <p style="margin-left:0cm;">在模除素数p情形下，二项式系数(n, m)可以被p整除，当且仅当对n与m进行p进制分解后，存在某一位上m的数值比n的数值大。</p> 
  <p style="margin-left:0cm;">主要用途：</p> 
  <p style="margin-left:0cm;">可以用来求解模p情形下的二项式系数，特别对于n与m较大，而p不是很大的情形。</p> 
  <p style="margin-left:0cm;">证明：</p> 
  <p style="margin-left:0cm;">必要性：假设m[i] &gt; n[i]，则(n[i], m[i]) = 0，于是连乘之积等于0，由此说明被p整除，必要性得证。</p> 
  <p style="margin-left:0cm;">充分性：假设二项式系数(n, m)可以被p整除，则说明其连乘的几个二项式系数中至少存在一个其值为0，由于二项式系数值仅在当二项式系数(a, b)中b &lt; 0或b &gt; a时才为0，且对m[i]与n[i]都不小于0，则说明必然存在m[i] &gt; n[i]，充分性得证。</p> 
  <p style="margin-left:0cm;">证毕。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <h3 id="%E6%95%B4%E9%99%A4%E6%83%85%E5%BD%A2%E7%9A%84%E6%8E%A8%E8%AE%BA" style="margin-left:0cm;">整除情形的推论</h3> 
  <p style="margin-left:0cm;"><strong>整除情形的推论</strong></p> 
  <p style="margin-left:0cm;">二项式系数(n, m)为奇数，当且仅当n &amp; m = m。</p> 
  <p style="margin-left:0cm;">证明：</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; 充分性：当(n, m)为奇数，(n, m) % 2得到1，因为2是一个素数，故根据lucas定理，(n, m)可拆解为n与m的2进制分解后每位对应的二项式系数的连乘之积，在二进制下，n[i]与m[i]取值只可能是0与1，则(n[i], m[i])取值也只可能是0和1，由于(n, m) % 2 = 1，故可知对于所有的i，满足(n[i], m[i]) = 1，故可以去除掉(n[i], m[i]) = 0的情形，即n[i] = 0，m[i] = 1的情形，只留下三种可归纳为n[i] &gt;= m[i]的情形，这蕴含着对于n的每一个二进制位，如果m[i]取1，则n[i]也取1，二者在这个位置上进行二进制与运算后得到的值是1与m[i]相同，而如果m[i]取0，则无论n[i]取0或1，这个位置上进行与运算后得到的都是0从而与m[i]相同，不存在n[i]为0而m[i]为1的情形，故由于每一位进行与运算后都与m的对应位置上的值相同，所以n &amp; m = m，充分性得证。</p> 
  <p style="margin-left:0cm;">&nbsp;&nbsp;&nbsp; 必要性：当n &amp; m = m时，可以推出对于n和m的每一个二进制位有n[i] &gt;= m[i]，因此组合数只有(1, 0), (1, 1), (0, 0)三种取值为1的情形，而它们之积必然为1，由Lucas定理得知，它们的乘积与(n, m) % 2同余，即说明(n, m) % 2 = 1，因此说明(n, m)为奇数，必要性得证。</p> 
  <p style="margin-left:0cm;">证毕。</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
  <p style="margin-left:0cm;">&nbsp;</p> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
