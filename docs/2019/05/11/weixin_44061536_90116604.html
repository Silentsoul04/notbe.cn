<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>面向对象特点 « NotBeCN</title>
  <meta name="description" content="                  面向对象： 三大特征：封装 继承 多态 封装：把一类事物的特征抽象为变量，把事物的行为抽象为方法，加以访问控制属性的限制称为封装 封装的意义： 保护 抽象 [访问控制属性]class 类名{ //属性 修饰词 属性类型 属性名; 方法 修饰词 返回值类型 方法名(参数列表)[异...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/weixin_44061536_90116604.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">面向对象特点</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>面向对象：<br> 三大特征：封装 继承 多态<br> 封装：把一类事物的特征抽象为变量，把事物的行为抽象为方法，加以访问控制属性的限制称为封装<br> 封装的意义： 保护<br> 抽象<br> [访问控制属性]class 类名{<br> //属性<br> 修饰词 属性类型 属性名;<br> 方法<br> 修饰词 返回值类型 方法名(参数列表)[异常声明]{<br> 方法体<br> }<br> 构造方法：(实例化对象、构造对象时会根据参数来调用构造方法)<br> 1.没有返回值类型 也不能是void<br> 2.方法名和类型相同<br> 3.子类构造的构造方法: 默认调用父类无参的构造方法 super();<br> 4.显示调用父类中的构造方法 super(参数);–只能在第一行<br> }<br> java语法规定：<br> 一个 .java文件中只能有一个public的类，而且这个类和文件名相同</p> 
  <pre><code>访问控制属性：
	public               在任何地方都可能通过对象访问该类的属性或者方法
	protected            只能在本类或者子类中访问  本包中也可以访问
	默认[default]        在本包中可以访问
	private              只能在本类中访问


类类型  引用变量  = new 类型名(参数列表);
		左边是声明了引用变量    右边是实例化对象(在堆内存中分配内存)
		
局部变量：
	1.定义在方法中
	2.不会自动初始化(不初始化不能使用)
	3.生命周期： 方法调用到方法结束
	4.存储位置： 栈内存
成员变量(属性)：
	1.定义在类里面，方法外
	2.对象实例化之后，自动初始化
		byte int short long       0
		boolean                   false
		char                      '\u0000'
		引用数据类型              null
	3.生命周期： 对象实例化之后，对象回收之前
	4.存储位置： 堆内存

对象：当一个对象没有引用变量再引用时，该对象将无法再访问
	JVM有一个独立的线程，当对象没有引用变量引用时，将回收该对象的内存
	java的内存回收机制   垃圾回收机制
	

成员方法里面(构造方法):有一个隐含的this引用变量
	this引用正在构造的对象或者调用该方法的对象

static:
	1.static修饰属性(不能修饰局部变量)：表示类属性 属于类，不属于对象
		该类所有的对象都共享一份
		可以直接通过  类名.属性名 直接进行访问
		也可以通过对象进行访问
	2.static修饰方法：表示(静态方法)类方法 属于类 不属于对象 
		静态方法中没有this引用变量
		静态方法中不可以访问成员变量和调用成员方法
		只能访问类属性和调用类方法
	3.static修饰语句块
		静态语句块
		在类加载时执行，只会执行一次
		加载图片、视频等资源
		普通的语句块：在实例化对象时被调用 在构造方法之前先执行

final:
	1.修饰变量或者属性  表示该变量和属性不能修改
	2.final修饰属性 只能直接初始化 或者 在语句块、或者构造方法中初始化
		只能选择其中之一
	3.final修饰方法 表示该方法不能被子类重写
	4.final修饰类   表示该类不能被继承
	5.final和static同时修饰的属性 称为常量
		只能直接初始化 或者 在静态语句块中进行初始化
</code></pre> 
  <p>练习：<br> 封装一个学生类<br> 属性：学号、姓名、年龄<br> 学号自动生成(构造学生时不需要传递学号)<br> class Stu{<br> static int makeId;<br> int id;<br> Stu(…){<br> id = makeId++;<br> }<br> }<br> 再封闭一个班级类<br> 班级号<br> 班级名称<br> 学生数组</p> 
  <pre><code>	1.在班级中增加一个学生
	2.按指定学号删除班级中的一个学生
	3.显示班级中所有的学生信息

//
class Stu{

}

包 package
	zhizhen.core.src.day01
		包里面的.其实代表的是目录的层级关系
		
如何表示一个唯一的类：
	包.类名 
	
	导包： import 包名.*;
		   import 包名.类名;
		   Ctrl+Shift+o
	package 包名;
	
继承:另一个类继承另外一个类，那么这个类称为子类或者派生类
	被继承的类称为父类或者基类
	子类拥有父类的属性和方法
	
	子类的构造方法：
		默认调用父类的无参构造方法
		super(参数);
		this(参数);

	重写：
		子类重写父类中同名的方法
		1.子类重写父类的方法
		2.方法名相同
		3.参数列表相同
		3.返回值类型：
			基本数据类型必须一致
			如果是引用数据类型 子类可以返回父类方法返回值类型的子类类型
		4.子类重写的方法的访问控制属性不能比父类方法的访问属性更窄
		public&gt;protected&gt;[default]&gt;private
		
	子类类型对象，可以用父类类型的引用变量引用
	但是通过父类类型的引用变量只能访问父类中声明的属性和方法
	
	如果子类重写父类中的方法，那么用父类类型的引用变量引用子类类型对象时，调用的是子类自己的方法，这个现象称为多态

	子类重写父类中的方法时，可以用 super.方法名(参数)  来调用父类中的方法
	
	
	重载：
		同一个作用域下，方法名相名，参数不相同即构成重载

	子类的属性名可以和父类中的属性名相同，
		为了以示区别：
			在访问父类中声明的属性时加上   this.
多态：
	父类类型的引用变量引用子类对象时，调用的是子类重写的方法

抽象方法：
	abstract修饰的方法称为抽象方法
		抽象方法没有方法体 
		
一个拥有抽象方法的类必须声明为抽象类(abstract修饰的类称为抽象类)
	抽象类是不完整的类，所以不能实例化对象
	
抽象类可以有属性和普通的成员方法 构造方法都可以有

	抽象类的意义：
		1.提供一个公共的类型
		2.封装子类共同拥有的属性和方法
		3.为子类提供统一的接口

一个继承一个抽象类，必须实现抽象类里面所有的抽象方法，否则该类只能声明抽象类


接口: 更加彻底抽象的类  接口也是一种类型
interface  
	接口中只能有常量和抽象方法
	定义的属性默认是 final static
	定义的方法默认是 public abstract
接口可以继承接口
	interface I extends M{}
	
接口可以被类实现
	class X implements I{
		
	}

	为什么要接口？
	java中的继承是单一继承，即一个类只能有一个父类
	一个类可以实现多个接口
</code></pre> 
  <p>练习：<br> 银行卡<br> 卡号 密码 账号余额 int type 1:中国银行卡 2:招商银行卡<br> 中国银行卡<br> 招商银行卡<br> 在线银行系统ATM<br> 插卡<br> 取卡<br> 取钱<br> 中国银行<br> 1.拿中国银行的卡去中国银行取钱 不收手续费<br> 拿其它行的卡来中国银行取钱 收取5% （从余额中直接扣除）<br> 招商银行<br> 1.拿招商银行的卡去招商银行取钱 收取每次1元的手续费<br> 拿其它行的卡来招商银行取钱 2元/每次手续费</p> 
  <p>class Card{}<br> class ZGcard extends Card{}<br> class ZScard extends Card{}</p> 
  <p>class ATM{<br> Card c;<br> //insert<br> //push<br> //查询账户余额<br> //takemoney 抽象方法<br> }</p> 
  <p>class ZGATM extends ATM{}<br> class ZSATM extends ATM{}</p> 
  <pre><code>instanceof  
	引用对象 instanceof 类型
	判断某个引用变量引用的对象是否是某种类型实例化的对象
	子类对象一定是父类类型的实例化

向上造型： 子类对象可以用父类类型的引用变量引用
向下造型:  一般来说需要结合instanceof
	子类 obj = (子类)(父类引用对象);
	如果该父类引用对象并不是 强转子类类型的对象 将发生以下异常
	java.lang.ClassCastException
	

抽象类与接口的区别：
	1.抽象类可以有普通的成员属性和方法
		接口里只能有常量和抽象方法
	2.抽象类可以有构造方法
		接口没有构造方法
	3.一个类只能继承一个抽象类，但是可以实现多个接口
		extends    implements
	

内部类：
	1.成员内部类
	2.静态内部类
	3.局部内部类
	4.匿名内部类 
		直接new 抽象类或者接口对象，但得同时实现抽象方法
		new 抽象类(){
			//实现抽象方法
		};
		new 接口(){
			//实现抽象方法
		};

定时器任务
鼠标监听事件

面向过程
面向对象
</code></pre> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
