<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>消息知识点 « NotBeCN</title>
  <meta name="description" content="                  routing key   生产者在将消息发送给 Exchange 的时候，一般会指定一个 routing key，来指定这   个消息的路由规则，而这个 routing key 需要与 Exchange Type 及 binding key 联合使   用才能最终生效。   ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/yb13215657368_90116362.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">消息知识点</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div id="content_views" class="markdown_views prism-atom-one-dark"> 
  <!-- flowchart 箭头图标 勿删 --> 
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> 
  <p>routing key</p> 
  <p>生产者在将消息发送给 Exchange 的时候，一般会指定一个 routing key，来指定这</p> 
  <p>个消息的路由规则，而这个 routing key 需要与 Exchange Type 及 binding key 联合使</p> 
  <p>用才能最终生效。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Binding</p> 
  <p>RabbitMQ 中通过<br> Binding 将 Exchange 与 Queue 关联起来，这样 RabbitMQ 就知道</p> 
  <p>如何正确地将消息路由到指定的 Queue 了。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Binding key</p> 
  <p>在绑定（Binding）Exchange<br> 与 Queue 的同时，一般会指定一个 binding key；消费</p> 
  <p>者将消息发送给 Exchange 时，一般会指定一个 routing key；当 binding key 与 routing</p> 
  <p>key 相匹配时，消息将会被路由到对应的 Queue 中。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Exchange Types</p> 
  <p></p> 
  <p></p> 
  <p>fanout</p> 
  <p>fanout 类型的 Exchange<br> 路由规则非常简单，它会把所有发送到该 Exchange 的消息</p> 
  <p>路由到所有与它绑定的 Queue 中。</p> 
  <p></p> 
  <p></p> 
  <p>direct</p> 
  <p>direct 类型的 Exchange<br> 路由规则也很简单，它会把消息路由到那些 binding key 与</p> 
  <p>routing key 完全匹配的<br> Queue 中。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>topic</p> 
  <p>前面讲到 direct 类型的<br> Exchange 路由规则是完全匹配 binding key 与 routing</p> 
  <p>key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic 类型的 Exchange</p> 
  <p>在匹配规则上进行了扩展，它与 direct 类型的 Exchage 相似，也是将消息路由到 binding</p> 
  <p>key 与 routing key 相匹配的 Queue 中，但这里的匹配规则有些不同，它约定：</p> 
  <p>&nbsp;<br> routing key 为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一</p> 
  <p>段独立的字符串称为一个单词），如“stock.usd.nyse ”、“nyse.vmw”、</p> 
  <p>“quick.orange.rabbit”</p> 
  <p>&nbsp;<br> binding key 与 routing key 一样也是句点号“. ”分隔的字符串</p> 
  <p>&nbsp;<br> binding key 中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹</p> 
  <p>配一个单词，“#”用于匹配多个单词（可以是零个）</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>工作队列-消息轮询分发-消费者收到的消息数量平均分配，单位时间内消息处理</p> 
  <p>速度加快，提高了吞吐量。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>案例&nbsp;<br> 02 ： 工作 模式 队列- - 消息公平分发<br> (fair dispatc h)</p> 
  <p>在案例 01 中对于消息分发采用的是默认轮询分发，消息应答采用的自动应答模式，这</p> 
  <p>是因为当消息进入队列，RabbitMQ 就会分派消息。它不看消费者为应答的数目，只是盲目</p> 
  <p>的将第 n 条消息发给第 n 个消费者。</p> 
  <p>为了解决这个问题，我们使用 basicQos(prefetchCount = 1)方法，来限制 RabbitMQ</p> 
  <p>只发不超过 1 条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发</p> 
  <p>送。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>案例&nbsp;<br> 03 ： 消息的发布与订阅 模式队列 (Publish/Subscribe)</p> 
  <p>对于微信公众号，相信每个人都订阅过，当公众号发送新的消息后，对于订阅过该公众</p> 
  <p>号的所有用户均可以收到消息，这个场景大家都能明白，同样对于 RabbitMQ 消息的处理也支持这种消息处理，当生产者把消息投送出去后，不同的消费者均可以对该消息进行消费，</p> 
  <p>而不是消息被一个消费者消费后就立即从队列中删除，对于这种消息处理，我们通常称之为</p> 
  <p>消息的发布与订阅模式，凡是消费者订阅了该消息，均能够收到对应消息进行处理，比较常</p> 
  <p>见的如用户注册操作。模型图如下:</p> 
  <p></p> 
  <p></p> 
  <p>从图中看到:</p> 
  <p>1.消息产生后不是直接投送到队列中，而是将消息先投送给 Exchange 交换机，然后消</p> 
  <p>息经过 Exchange 交换机投递到相关队列</p> 
  <p>2.多个消费者消费的不再是同一个队列，而是每个消费者消费属于自己的队列。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Routing-路由模式队列</p> 
  <p>案例&nbsp;<br> 04 ： 路由 模式队列( ( Routing) )</p> 
  <p>通过案例 03,可以看到，生产者将消息投送给交换机后，消息经交换机分发到不同的队</p> 
  <p>列即:交换机收到消息，默认对于绑定到每个交换机的队列均会接收到交换机分发的消息，</p> 
  <p>对于案例 03 的交换机的消息分发<br> Exchange Types 为 fanout 类型，通常在真正项目开发</p> 
  <p>时会遇到这种情况:在对项目信息输出日志进行收集时，会把日志(error warning,info)</p> 
  <p>分类进行输出，这时通过 Exchange Types 中的 direct 类型就可以实现，针对不同的消</p> 
  <p>息，在对消息进行消费时，通过 Exchange types 以及 Routing key 设置的规则 ，便可</p> 
  <p>以将不同消息路由到不同的队列中然后交给不同消费者进行消费操作。模型图如下:</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>从图中可以看出:</p> 
  <ol> 
   <li> <p>生产者产生的消息投给交换机</p> </li> 
   <li> <p>交换机投送消息时的<br> Exchange Types 为 direct 类型</p> </li> 
   <li> <p>消息通过定义的 Routing<br> Key 被路由到指定的队列进行后续消费</p> </li> 
  </ol> 
  <p>总结</p> 
  <p>从结果可以看出生产者发送了多条设置了路由规则的消息，消费者可以根据具体的路由</p> 
  <p>规则消费对应队列中的消息，而不是所有消费者都可以消费所有消息了。</p> 
  <p>问题：生产者产生的消息如果场景需求过多需要设置很多路由规则，可不可以减少？</p> 
  <p>解决：采用 topic 主题模式。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Topics-主题模式队列</p> 
  <p>案例 0 05 5 ：主题模式队列(<br> (T T opic)</p> 
  <p></p> 
  <p></p> 
  <p>通过案例 04 看到消息通过交换机<br> Exchange Type 以及 Routing Key 规则，可以将消</p> 
  <p>息路由到指定的队列，也符合在工作中的场景去使用的一种方式，对于 RabbitMq 除了</p> 
  <p>direct 模式外，Mq 同样还提供了 topics 主题模式来对消息进行匹配路由，比如在项目</p> 
  <p>开发中，拿商品模块来说，对于商品的查询功能在对商品进行查询时我们将查询消息路由到</p> 
  <p>查询对应队列，而对于商品的添加、更新、删除等操作我们统一路由到另外一个队列来进行</p> 
  <p>处理，此时采用 direct 模式可以实现，但对于维护的队列可能就不太容易进行维护，如果</p> 
  <p>涉及模块很多，此时对应队列数量就很多，此时我们就可以通过 topic 主题模式来对消息</p> 
  <p>路由时进行匹配，通过指定的匹配模式将消息路由到匹配到的队列中进行后续处理。对于</p> 
  <p>routing key 匹配模式定义规则举例如下:</p> 
  <p>•&nbsp;<br> routing key 为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一</p> 
  <p>段 独 立 的 字 符 串 称 为 一 个 单 词 ）， 如 “<br> stock.usd.nyse ” 、 “ nyse.vmw ” 、</p> 
  <p>“quick.orange.rabbit”</p> 
  <p>•&nbsp;<br> routing key 中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹</p> 
  <p>配一个单词，“#”用于匹配多个单词（可以是零个）</p> 
  <p>例如:</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>以上图中的配置为例：</p> 
  <p>routingKey=”quick.orange.rabbit”的消息会同时路由到 Q1 与 Q2，</p> 
  <p>routingKey=”lazy.orange.fox”的消息会路由到 Q1，Q2,</p> 
  <p>routingKey=”lazy.brown.fox”的消息会路由到 Q2，</p> 
  <p>routingKey=”lazy.pink.rabbit”的消息会路由到 Q2；</p> 
  <p>routingKey=”quick.brown.fox”、</p> 
  <p>routingKey=”orange”、</p> 
  <p>routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配</p> 
  <p>任何 bindingKey。</p> 
  <p></p> 
  <p>从结果可以看出生产者发送了多条设置了路由匹配规则(主题)的消息，根据不同的路</p> 
  <p>由匹配规则(主题)，可以将消息根据指定的 routing key 路由到匹配到的队列中，也是在</p> 
  <p>生产中比较常见的一种消息处理方式。</p> 
  <p>问题：RabbitMQ 本身是基于异步的消息处理，是否可以同步实现？</p> 
  <p>解决：采用 RPC 模式。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Rabbit MQ消息的事物机制</p> 
  <p></p> 
  <p>RabbitMQ 为我们提供了两种方式：</p> 
  <ol> 
   <li> <p>通过 AMQP 事务机制实现，这也是 AMQP 协议层面提供的解决方案；</p> </li> 
   <li> <p>通过将 channel 设置成 confirm 模式来实现；</p> </li> 
  </ol> 
  <p></p> 
  <p></p> 
  <p>RabbitMQ 中与事务机制有关的方法有三个：txSelect(), txCommit()以及</p> 
  <p>txRollback(), txSelect 用于将当前 channel 设置成 transaction 模式，txCommit()</p> 
  <p>用于提交事务，txRollback()用于回滚事务，在通过 txSelect()开启事务之后，我们便</p> 
  <p>可以发布消息给 broker 代理服务器了，如果 txCommit()提交成功了，则消息一定到达了</p> 
  <p>broker 了，如果在<br> txCommit()执行之前 broker 异常崩溃或者由于其他原因抛出异常，这</p> 
  <p>个时候我们便可以捕获异常通过 txRollback()回滚事务</p> 
  <p></p> 
  <p>事务确实能够解决 producer 与<br> broker 之间消息确认的问题，只有消息成功被 broker</p> 
  <p>接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，</p> 
  <p>但是使用事务机制的话会降低 RabbitMQ 的性能，那么有没有更好的方法既能保障</p> 
  <p>producer 知道消息已经正确送到，又能基本上不带来性能上的损失呢？从 AMQP 协议的层</p> 
  <p>面看是没有更好的方法，但是 RabbitMQ 提供了一个更好的方案，即将 channel 信道设置</p> 
  <p>成 confirm 模式。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Confirm&nbsp;<br> 确认模式原理</p> 
  <p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布</p> 
  <p>的消息都会被指派一个唯一的 ID(从<br> 1 开始)，一旦消息被投递到所有匹配的队列之后，</p> 
  <p>broker 就会发送一个确认给生产者（包含消息的唯一 ID）,这就使得生产者知道消息已经</p> 
  <p>正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后</p> 
  <p>发出，broker 回传给生产者的确认消息中 deliver-tag 域包含了确认消息的序列号，此外</p> 
  <p>broker 也可以设置<br> basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经</p> 
  <p>得到了处理。</p> 
  <p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以</p> 
  <p>在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可</p> 
  <p>以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p>Confirm&nbsp;<br> 确认机制代码实现</p> 
  <p>实现生产者 confirm 机制有三种方式:</p> 
  <ol> 
   <li>普通 confirm 模式：每发送一条消息后，调用 waitForConfirms()方法，等待服</li> 
  </ol> 
  <p>务器端 confirm。实际上是一种串行 confirm 了。</p> 
  <ol start="2"> 
   <li>批量 confirm 模式：每发送一批消息后，调用 waitForConfirmsOrDie()方法，</li> 
  </ol> 
  <p>等待服务器端 confirm。</p> 
  <ol start="3"> 
   <li>异步 confirm 模式：提供一个回调方法，服务端 confirm 了一条或者多条消息后</li> 
  </ol> 
  <p>Client 端会回调这个方法。</p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
  <p></p> 
 </div> 
 <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet"> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
