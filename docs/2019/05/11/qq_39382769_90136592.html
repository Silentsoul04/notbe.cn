<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>java后台面试之计算机网络问题集锦 « NotBeCN</title>
  <meta name="description" content="              java后台面试之计算机网络问题集锦                   1.http和https的区别      2.对称加密和非对称加密      3.三次握手与四次挥手的流程      4.为什么TCP需要三次握手？两次不可以吗？为什么      5.为什么TCP挥手需要四次？三...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://notbe.cn/2019/05/11/qq_39382769_90136592.html">
  <link rel="alternate" type="application/rss+xml" title="NotBeCN" href="https://notbe.cn/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">NotBeCN</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/" target="_blank">关于</a>
      
        
        <a class="page-link" href="https://uzshare.com" target="_blank">社区</a>
      
        
        <a class="page-link" href="/donate/" target="_blank">Donate</a>
      
        
        <a class="page-link" href="/games/shejiyazi/" target="_blank">射个鸭子</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">java后台面试之计算机网络问题集锦</h1>
    <p class="post-meta">May 11, 2019</p>
  </header>

  <article class="post-content">
    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css"> 
 <div class="htmledit_views" id="content_views"> 
  <div class="post"> 
   <h1 class="postTitle"> <a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yinbiao/p/10661945.html" rel="nofollow">java后台面试之计算机网络问题集锦</a> </h1> 
   <div class="clear"></div> 
   <div class="postBody"> 
    <div id="cnblogs_post_body" class="blogpost-body">
     <p><a href="#m1" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">1.http和https的区别</span></a></p> 
     <p><a href="#m2" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">2.对称加密和非对称加密</span></a></p> 
     <p><a href="#m3" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">3.三次握手与四次挥手的流程</span></a></p> 
     <p><a href="#m4" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">4.为什么TCP需要三次握手？两次不可以吗？为什么</span></a></p> 
     <p><a href="#m5" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">5.为什么TCP挥手需要四次？三次不行吗？</span></a></p> 
     <p><a href="#m6" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">6.TCP协议如何来保证传输的可靠性？</span></a></p> 
     <p><a href="#m7" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">7.客户端不断进行请求连接会怎么样？DDOS攻击？</span></a></p> 
     <p><a href="#m8" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">8.get和post的区别</span></a></p> 
     <p><a href="#m9" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">9.TCP和UDP的区别</span></a></p> 
     <p><a href="#m10" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">10.TCP的拥塞处理</span></a></p> 
     <p><a href="#m11" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">11.从输入网址到获得页面的过程</span></a></p> 
     <p><a href="#m12" rel="nofollow"><span style="font-family:'楷体';font-size:18px;">12.TCP和UDP分别对应的常见的应用层协议</span></a></p> 
     <p>&nbsp;</p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m1"></a>1.http和https的区别</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）原理不同</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">http协议运行于TCP之上，明文传输，客户端和服务端都无法验证对方身份</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">https是身披SSL（Secure Socket Layer）外壳的http，运行于SSL之上，是添加了加密和认证机制的http</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）端口不同：http使用的是80端口，https使用的是443端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">3）资源消耗不同：和http通信相比，https会由于加密解密出来消耗更多的cpu资源和内存</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">4）开销：https通信需要证书，证书需要向认证机构购买</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">httpd的加密机制是一种共享密钥加密和公开公钥加密并用的混合加密机制</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m2"></a>2.对称加密和非对称加密</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥的发送问题，即任何将密钥安全的发送给对方，而非对称密钥加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但是私钥只有自己知道，发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息之后，使用自己的私钥进行解密</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密的方式发送信息，加密的密钥可以通过非对称加密的方式发送出去</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m3"></a>3.三次握手与四次挥手的流程</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1)三次握手（我要和你建立连接，你真的要和我建立连接吗？我真的要和你建立连接，成功）</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第一次握手：客户端：发送序号200（随机的），标志位SYN=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第二次握手（建立接收缓冲区）：服务器端：发送序号500（随机的），确认序号200+1，标志位SYN=1，ACK=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第三次握手（建立发送缓冲区）：客户：发送序号=201，确认序号=500+1，标志位ACK=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">要发送的发送序号=上一次接收到的确认序号</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">要发送的确认序号=上一次的发送序号+1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a href="https://img2018.cnblogs.com/blog/1301290/201812/1301290-20181218214900051-1428955693.jpg" rel="nofollow"><img title="wps5B21.tmp" src="https://img2018.cnblogs.com/blog/1301290/201812/1301290-20181218214900459-2091907232.jpg" alt="wps5B21.tmp" width="434" height="370" border="0"></a></span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）四次挥手（我要和你断开连接；好吧，断吧，但要先等我发完剩余数据；剩余数据发完了，我也要和你断开连接；好吧，断吧）</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第一次挥手：客户：发送序号=200，标志位FIN=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第二次挥手（释放接收缓冲区）：服务端：发现接收到的FIN=1，就发送序号=500，确认序号=200+1，标志位ACK=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第三次挥手（释放发送缓冲区）：服务器：发送序号=300，确认序号=200+1，标志位FIN=1，ACK=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*第四次挥手：客户：发送序号=201，确认序号=300+1，标志位ACK=1</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a href="https://img2018.cnblogs.com/blog/1301290/201812/1301290-20181218214901248-253228379.jpg" rel="nofollow"><img title="wps5B32.tmp" src="https://img2018.cnblogs.com/blog/1301290/201812/1301290-20181218214901913-507693456.jpg" alt="wps5B32.tmp" width="517" height="221" border="0"></a></span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m4"></a>4.为什么TCP需要三次握手？两次不可以吗？为什么</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">为了防止已经失效的连接请求报文突然又传送到了服务器端（网络堵塞的原因）</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">如果客户端发出的连接请求报文并未丢失而是在某个网络结点长时间堵塞了，导致延误到连接释放以后的某个时间才到达服务器，这时服务器误以为是客户端发出了一个新的连接请求，于是就向客户端发送确认数据包，同意建立连接，如果不采用三次握手，那么只要服务器端发送确认数据包，连接就建立成功了，由于客户端并未发出连接请求，所以不会理睬服务器的确认，也不与服务器通信，而这个时候服务器一直在等待客户端发送数据，这样服务器就白白浪费了资源，如果采用三次握手，那么服务器端密钥收到来自客户端的确认，就知道客户端并没有请求建立连接，就不会建立连接</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m5"></a>5.为什么TCP挥手需要四次？三次不行吗？</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">三次和四次的区别就在于服务器连续给客户端发了两个报文，那把这两个报文合并成一个不可以吗？为什么呢？答案是不可以，首先客户端发来请求断开连接的报文，假设这个时候服务器端仍然在发送报文（因为是全双工），如果是三次挥手，那么服务器只会确认客户的断开请求，客户端不会说我还有数据没有发送完，你要等等我，这样会导致客户端接收的数据不完整，如果是四次挥手，那么服务器接收到客户的断开请求，会先说可以断开，但是你要先等我发送完剩余的数据，然后说我剩余的数据发送完了，我要和你断开连接</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">挥手过程之所以比握手过程多一次，就是因为握手过程只需要处理连接，而挥手过程需要处理连接和数据！！</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m6"></a>6.TCP协议如何来保证传输的可靠性？</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">TCP提供一种面向连接的，可靠的字节流服务，其中，面向连接意味着两个使用TCP的应用在彼此交换数据之前必须先建立一个TCP连接，在一个TCP中，仅有两方进行彼此通信，而字节流服务意味着两个应用程序通过TCP连接交换8比特字节构成的字节流，TCP不在字节流中插入记录标识符</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">对于可靠性，TCP通过以下方式保证：</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）数据包校验：目的是检测数据在传输过程中的任何变化，若校验包出错，则丢弃报文段并且不给出响应，这时TCP数据发送端超时重发数据</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段到达也可能会失序，TCP将失序数据重排序才交给应用层</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">3）丢弃重复数据</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">4）应答机制：当TCP收到一个报文就发送一个确认信号</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">5）超时重传：一个TCP报文段发送出去后，启动计时器，到达某个时间没有收到确认信号就重传该报文段</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">6）流量控制：TCP连接的每一方都有一块固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区能容纳的数据，这样可以防止较快主机使得较快主机缓冲区溢出，同样也能避免网络拥塞，TCP使用的流量控制协议就是可变大小的滑动窗口协议</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m7"></a>7.客户端不断进行请求连接会怎么样？DDOS攻击？</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">服务器会为每个请求创立一个连接，并向其发送确认报文，然后等待客户端进行确认</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）DDOS攻击</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*客户端向服务端发送请求数据包</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*服务端向客户端发送确认数据包</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*客户端不向服务端发送确认数据包，服务器一直等待客户端的确认</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）DDOS攻击的预防（没有办法根治，除非不使用TCP）</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*限制同时打开的SYN半连接数目</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*缩短SYN半连接的Time Out时间</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*关闭不必要服务</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m8"></a>8.get和post的区别</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">get和post是http所属的方法，而http又是基于TCP/IP实现的，所以get和post的底层都是TCP/IP协议，只不过http定义的规则和浏览器的限制导致他们在应用上存在一定的区别，最重要的区别就是get产生一个TCP数据包，而post产生两个TCP数据包，对于get的请求，浏览器会把浏览器的header和data一起发送出去，服务器响应200，对于post，浏览器先发送header，浏览器响应100，浏览器再发送data，服务器响应200，也就是说get只需要汽车跑一趟就把货送到了，而post需要跑两趟，第一趟先去和服务器打个招呼告诉它我等下要送货过来，开门迎接我，第二趟就是把货送过去，据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间查基本可以无视，而在网络环境差的情况下，两次包的TCP在验证数据包完整性上有很大的优势，所以不推荐使用get来优化性能，当然，并不是所有的浏览器都会在post中发两次tcp包，火狐浏览器就只发一次</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">下面我们看看get和post应用上的区别：</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*get的参数通过URL传递，post放在request body中</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*get在URL中的参数是有长度限制的，而post没有</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*get只能进行URL编码，而post支持多种</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*get只接受ASSIC字符，而post没有限制</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*post比get安全，因为get的参数暴露在URL中</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m9"></a>9.TCP和UDP的区别</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）TCP面向连接，而UDP是无连接的</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）TCP可靠，UDP不可靠</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">3）TCP只支持点对点通信，而UDP支持1对1，1对多，多对1，多对多的通信模式</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">4）TCP是面向字节流的，UDP是面向报文的</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">5）TCP有拥塞控制，UDP没有拥塞控制，适合媒体通信</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">6)TCP首部开销（20字节）比UDP首部开销（8个字节）要大</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m10"></a>10.TCP的拥塞处理</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">拥塞控制就是防止过多的数据注入网络，造成网络堵塞，拥塞控制和流量控制不同，拥塞控制是一个全局性过程，而流量控制是点对点通信的控制，拥塞控制的方法主要有以下5种：</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）拥塞窗口：动态窗口，和网络拥塞程度有关，网络拥塞程度大，拥塞窗口就小</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）慢启动：不要一开始就发送大量数据，先探测一下网络的拥塞程度，也就是说从小到大逐渐增加拥塞窗口的大小</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">3）拥塞避免（AMDI：加法增大乘法减小）：让拥塞窗口缓慢增大，每经过一个往返时间就将拥塞窗口+1,缓慢增大拥塞窗口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">4）快重传：发送方只要一收到三个重复的确认就应该立即重传对方并未收到的报文段，而不必继续等待重传计时器到达重传时间，快重传并不是取消重传计时器，而是在某些情况下更早的重传丢失的报文</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">5）快恢复：根据收到的重复的ACK的多少调节慢开始门限值ssthresh</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m11"></a>11.从输入网址到获得页面的过程</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）浏览器查询DNS，获得域名对应的IP地址</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*先从浏览器缓存找ip，因为浏览器会缓存DNS记录一段时间</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*如果没有找到，再从Host文件查找是否有该域名对应的IP</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*如果没有找到，再从路由器缓存找</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*如果没有找到，再从DNS缓存找</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*如果都没有找到，就从浏览器域名服务器向根域名服务器查找，没有找到就继续迭代，知道找到为止</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）浏览器获得IP地址后，浏览器向服务器请求连接，发起三次握手</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">3）连接建立起来后，浏览器向服务器发送http请求</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">4）服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将视图以及相应的结果返回给浏览器</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">5）浏览器解析并渲染视图，若遇到对js，css文件以及静态图片资源的引用，重复上述步骤向服务器请求资源</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">6）浏览器根据请求到的资源，数据渲染页面，最终向用户呈现</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;"><a name="m12"></a>12.TCP和UDP分别对应的常见的应用层协议</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">1）TCP对应的应用层协议</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*FTP：文件传输协议，21端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*Telnet：远程登陆协议，23端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*SMTP：简单邮件传送协议，25端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*POP3：和SMTP对应，POP3用于接收邮件，110端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*HTTP：超文本传输协议，80端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">2）UDP对应的应用层协议</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*DNS：域名解析协议，53端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*SNMP：简单网络管理协议，161端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">*TFTP:简单文件传输协议，69端口</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p> 
     <p><span style="font-family:'楷体';font-size:18px;">&nbsp;</span></p>
    </div>
    <div id="MySignature"></div> 
    <div class="clear"></div> 
    <div id="blog_post_info_block"> 
     <div id="BlogPostCategory"></div> 
     <div id="EntryTag"></div> 
     <div id="blog_post_info"> 
     </div> 
     <div class="clear"></div> 
     <div id="post_next_prev"></div> 
    </div> 
   </div> 
   <div class="postDesc">
    posted @ 
    <span id="post-date">2019-05-11 08:06</span> 
    <a href="https://www.cnblogs.com/yinbiao/" rel="nofollow">Y先森0.0</a> 阅读(
    <span id="post_view_count">...</span>) 评论(
    <span id="post_comment_count">...</span>) 
    <a href="https://i.cnblogs.com/EditPosts.aspx?postid=10661945" rel="nofollow">编辑</a> 
    <a href="#" rel="nofollow">收藏</a>
   </div> 
  </div> 
 </div> 
</div>
  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://uzstatic-360cdn.belost.xyz/theme/default/images/logo.png" alt="柚子社区">
  <div class="col-box-title name">NotBeCN</div>
  <!-- <p>最新资讯</p> -->
  <p class="contact">
    
    <a href="mailto:fandyvon@163.com" target="_blank">邮箱</a>
    
    <a href="https://uzshare.com" target="_blank">柚子社区</a>
    
    <a href="https://uzzz.org" target="_blank">找组织</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">最新</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/2019/05/14/zxh1220_90138586.html">[原创软件] [软件发布] 定时备份文件发送邮箱，不再怕数据丢失了</a></li>
    
      <li><a class="post-link" href="/2019/05/14/weixin_45037290_90140056.html">Get智能写作满月记 ——产品篇</a></li>
    
      <li><a class="post-link" href="/2019/05/14/nulio__90138386.html">《深度探索C++对象模型》..............</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_41248707_90140031.html">mysql 多表联查之连接查询</a></li>
    
      <li><a class="post-link" href="/2019/05/13/qq_21122683_90125902.html">golang基础(二)</a></li>
    
      <li><a class="post-link" href="/2019/05/13/1557726108256.html">今日份的PTA刷题</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90137366.html">Android之折线图</a></li>
    
      <li><a class="post-link" href="/2019/05/12/zzzfffei_90136638.html">Android之实现选中时改变样式</a></li>
    
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">目录</div>
</div>

<div class="col-box">
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- right_sidebar -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-8889449066804352"
       data-ad-slot="2081363239"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2019 
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123344652-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123344652-5');
</script>


<script data-ad-client="ca-pub-8889449066804352" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.async = true;
  hm.src = "https://hm.baidu.com/hm.js?9b378145d7399199b371d067f4c8be96";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>




  </body>

</html>
